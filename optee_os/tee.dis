
out/arm/core/tee.elf:     file format elf64-littleaarch64


Disassembly of section .text:

0000000001100000 <_start>:
#endif
		msr	sctlr_el1, x0
	.endm

FUNC _start , :
	mov	x19, x0		/* Save pagable part address */
 1100000:	aa0003f3 	mov	x19, x0
#if defined(CFG_DT_ADDR)
	ldr     x20, =CFG_DT_ADDR
#else
	mov	x20, x2		/* Save DT address */
 1100004:	aa0203f4 	mov	x20, x2
#endif

	adr	x0, reset_vect_table
 1100008:	10007fc0 	adr	x0, 1101000 <reset_vect_table>
	msr	vbar_el1, x0
 110000c:	d518c000 	msr	vbar_el1, x0
	isb
 1100010:	d5033fdf 	isb

	set_sctlr_el1
 1100014:	d5381000 	mrs	x0, sctlr_el1
 1100018:	b2740000 	orr	x0, x0, #0x1000
 110001c:	b27d0000 	orr	x0, x0, #0x8
 1100020:	b2690000 	orr	x0, x0, #0x800000
 1100024:	b26d0000 	orr	x0, x0, #0x80000
 1100028:	927ef800 	and	x0, x0, #0xfffffffffffffffd
 110002c:	d5181000 	msr	sctlr_el1, x0
	isb
 1100030:	d5033fdf 	isb
	 * The binary is built as:
	 * [Core, rodata and data] : In correct location
	 * [struct boot_embdata + data] : Should be moved to __end, first
	 * uint32_t tells the length of the struct + data
	 */
	adr_l	x0, __end		/* dst */
 1100034:	d0000480 	adrp	x0, 1192000 <stack_tmp+0x1d80>
 1100038:	910e0000 	add	x0, x0, #0x380
	adr_l	x1, __data_end		/* src */
 110003c:	b00002e1 	adrp	x1, 115d000 <_curve_names+0x590>
 1100040:	91300021 	add	x1, x1, #0xc00
	ldr	w2, [x1]		/* struct boot_embdata::total_len */
 1100044:	b9400022 	ldr	w2, [x1]
	/* Copy backwards (as memmove) in case we're overlapping */
	add	x0, x0, x2
 1100048:	8b020000 	add	x0, x0, x2
	add	x1, x1, x2
 110004c:	8b020021 	add	x1, x1, x2
	adr	x3, cached_mem_end
 1100050:	10000943 	adr	x3, 1100178 <cached_mem_end>
	str	x0, [x3]
 1100054:	f9000060 	str	x0, [x3]
	adr_l	x2, __end
 1100058:	d0000482 	adrp	x2, 1192000 <stack_tmp+0x1d80>
 110005c:	910e0042 	add	x2, x2, #0x380

0000000001100060 <copy_init>:

copy_init:
	ldp	x3, x4, [x1, #-16]!
 1100060:	a9ff1023 	ldp	x3, x4, [x1, #-16]!
	stp	x3, x4, [x0, #-16]!
 1100064:	a9bf1003 	stp	x3, x4, [x0, #-16]!
	cmp	x0, x2
 1100068:	eb02001f 	cmp	x0, x2
	b.gt	copy_init
 110006c:	54ffffac 	b.gt	1100060 <copy_init>

	/*
	 * Clear .bss, this code obviously depends on the linker keeping
	 * start/end of .bss at least 8 byte aligned.
	 */
	adr_l	x0, __bss_start
 1100070:	b00002e0 	adrp	x0, 115d000 <_curve_names+0x590>
 1100074:	91300000 	add	x0, x0, #0xc00
	adr_l	x1, __bss_end
 1100078:	b0000341 	adrp	x1, 1169000 <threads+0x540>
 110007c:	9137a021 	add	x1, x1, #0xde8

0000000001100080 <clear_bss>:
clear_bss:
	str	xzr, [x0], #8
 1100080:	f800841f 	str	xzr, [x0], #8
	cmp	x0, x1
 1100084:	eb01001f 	cmp	x0, x1
	b.lt	clear_bss
 1100088:	54ffffcb 	b.lt	1100080 <clear_bss>  // b.tstop
	cmp	x0, x1
	b.lt	clear_nex_bss
#endif

	/* Setup SP_EL0 and SP_EL1, SP will be set to SP_EL0 */
	set_sp
 110008c:	94000632 	bl	1101954 <__get_core_pos>
 1100090:	f100101f 	cmp	x0, #0x4
 1100094:	5400c72a 	b.ge	1101978 <unhandled_cpu>  // b.tcont
 1100098:	1000c5c1 	adr	x1, 1101950 <stack_tmp_stride>
 110009c:	b9400021 	ldr	w1, [x1]
 11000a0:	9b017c01 	mul	x1, x0, x1
 11000a4:	b0000000 	adrp	x0, 1101000 <reset_vect_table>
 11000a8:	911e2000 	add	x0, x0, #0x788
 11000ac:	f9400000 	ldr	x0, [x0]
 11000b0:	d50040bf 	msr	spsel, #0x0
 11000b4:	8b20603f 	add	sp, x1, x0
 11000b8:	9400142f 	bl	1105174 <thread_get_core_local>
 11000bc:	d50041bf 	msr	spsel, #0x1
 11000c0:	9100001f 	mov	sp, x0
 11000c4:	d50040bf 	msr	spsel, #0x0

	bl	thread_init_thread_core_local
 11000c8:	9400161a 	bl	1105930 <thread_init_thread_core_local>

	/* Enable aborts now that we can receive exceptions */
	msr	daifclr, #DAIFBIT_ABT
 11000cc:	d50344ff 	msr	daifclr, #0x4
	 * Invalidate dcache for all memory used during initialization to
	 * avoid nasty surprices when the cache is turned on. We must not
	 * invalidate memory not used by OP-TEE since we may invalidate
	 * entries used by for instance ARM Trusted Firmware.
	 */
	adr_l	x0, __text_start
 11000d0:	90000000 	adrp	x0, 1100000 <_start>
 11000d4:	91000000 	add	x0, x0, #0x0
	ldr	x1, cached_mem_end
 11000d8:	58000501 	ldr	x1, 1100178 <cached_mem_end>
	sub	x1, x1, x0
 11000dc:	cb000021 	sub	x1, x1, x0
	bl	dcache_cleaninv_range
 11000e0:	94001137 	bl	11045bc <dcache_cleaninv_range>

	/* Enable Console */
	bl	console_init
 11000e4:	940033fd 	bl	110d0d8 <console_init>

#ifdef CFG_CORE_ASLR
	mov	x0, x20
 11000e8:	aa1403e0 	mov	x0, x20
	bl	get_aslr_seed
 11000ec:	94002005 	bl	1108100 <get_aslr_seed>
#else
	mov	x0, #0
#endif

	adr	x1, boot_mmu_config
 11000f0:	10003cc1 	adr	x1, 1100888 <boot_mmu_config>
	bl	core_init_mmu_map
 11000f4:	94002334 	bl	1108dc4 <core_init_mmu_map>
	/*
	 * Process relocation information again updating for the new
	 * offset. We're doing this now before MMU is enabled as some of
	 * the memory will become write protected.
	 */
	ldr	x0, boot_mmu_config + CORE_MMU_CONFIG_LOAD_OFFSET
 11000f8:	58003d80 	ldr	x0, 11008a8 <boot_mmu_config+0x20>
	/*
	 * Update cached_mem_end address with load offset since it was
	 * calculated before relocation.
	 */
	adr	x5, cached_mem_end
 11000fc:	100003e5 	adr	x5, 1100178 <cached_mem_end>
	ldr	x6, [x5]
 1100100:	f94000a6 	ldr	x6, [x5]
	add	x6, x6, x0
 1100104:	8b0000c6 	add	x6, x6, x0
	str	x6, [x5]
 1100108:	f90000a6 	str	x6, [x5]
	bl	relocate
 110010c:	9400200a 	bl	1108134 <relocate>
#endif

	bl	__get_core_pos
 1100110:	94000611 	bl	1101954 <__get_core_pos>
	bl	enable_mmu
 1100114:	940001bb 	bl	1100800 <enable_mmu>
	/*
	 * Reinitialize console, since register_serial_console() has
	 * previously registered a PA and with ASLR the VA is different
	 * from the PA.
	 */
	bl	console_init
 1100118:	940033f0 	bl	110d0d8 <console_init>
	 * default_partition which has been relocated now to a different VA
	 */
	bl	core_mmu_set_default_prtn_tbl
#endif

	mov	x0, x19		/* pagable part address */
 110011c:	aa1303e0 	mov	x0, x19
	mov	x1, #-1
 1100120:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
	bl	boot_init_primary_early
 1100124:	94001fc0 	bl	1108024 <boot_init_primary_early>
#ifndef CFG_VIRTUALIZATION
	mov	x21, sp
 1100128:	910003f5 	mov	x21, sp
	adr_l	x0, threads
 110012c:	90000340 	adrp	x0, 1168000 <data.5093+0x9e28>
 1100130:	912b0000 	add	x0, x0, #0xac0
	ldr	x0, [x0, #THREAD_CTX_STACK_VA_END]
 1100134:	f9409000 	ldr	x0, [x0, #288]
	mov	sp, x0
 1100138:	9100001f 	mov	sp, x0
#endif
	mov	x0, x20		/* DT address */
 110013c:	aa1403e0 	mov	x0, x20
	bl	boot_init_primary_late
 1100140:	94001f50 	bl	1107e80 <boot_init_primary_late>
#ifndef CFG_VIRTUALIZATION
	mov	sp, x21
 1100144:	910002bf 	mov	sp, x21
	/*
	 * In case we've touched memory that secondary CPUs will use before
	 * they have turned on their D-cache, clean and invalidate the
	 * D-cache before exiting to normal world.
	 */
	adr_l	x0, __text_start
 1100148:	90000000 	adrp	x0, 1100000 <_start>
 110014c:	91000000 	add	x0, x0, #0x0
	ldr	x1, cached_mem_end
 1100150:	58000141 	ldr	x1, 1100178 <cached_mem_end>
	sub	x1, x1, x0
 1100154:	cb000021 	sub	x1, x1, x0
	bl	dcache_cleaninv_range
 1100158:	94001119 	bl	11045bc <dcache_cleaninv_range>
	 * Clear current thread id now to allow the thread to be reused on
	 * next entry. Matches the thread_init_boot_thread in
	 * boot.c.
	 */
#ifndef CFG_VIRTUALIZATION
	bl 	thread_clr_boot_thread
 110015c:	9400140b 	bl	1105188 <thread_clr_boot_thread>
	/*
	 * Pass the vector address returned from main_init
	 * Compensate for the load offset since cpu_on_handler() is
	 * called with MMU off.
	 */
	ldr	x0, boot_mmu_config + CORE_MMU_CONFIG_LOAD_OFFSET
 1100160:	58003a40 	ldr	x0, 11008a8 <boot_mmu_config+0x20>
	adr	x1, thread_vector_table
 1100164:	1000ba41 	adr	x1, 11018ac <thread_vector_table>
	sub	x1, x1, x0
 1100168:	cb000021 	sub	x1, x1, x0
	mov	x0, #TEESMC_OPTEED_RETURN_ENTRY_DONE
 110016c:	d2b7c000 	mov	x0, #0xbe000000            	// #3187671040
	smc	#0
 1100170:	d4000003 	smc	#0x0
	b	.	/* SMC should not return */
 1100174:	14000000 	b	1100174 <clear_bss+0xf4>

0000000001100178 <cached_mem_end>:
	...

0000000001100180 <__identity_map_init_start>:
	...

0000000001100800 <enable_mmu>:
 * physical address and virtual address is the same. After MMU has been
 * enabled the instruction pointer will be updated to execute as the new
 * offset instead. Stack pointers and the return address are updated.
 */
LOCAL_FUNC enable_mmu , : , .identity_map
	adr	x1, boot_mmu_config
 1100800:	10000441 	adr	x1, 1100888 <boot_mmu_config>
	load_xregs x1, 0, 2, 6
 1100804:	a9400c22 	ldp	x2, x3, [x1]
 1100808:	a9411424 	ldp	x4, x5, [x1, #16]
 110080c:	f9401026 	ldr	x6, [x1, #32]
	 * x3 = mair_el1
	 * x4 = ttbr0_el1_base
	 * x5 = ttbr0_core_offset
	 * x6 = load_offset
	 */
	msr	tcr_el1, x2
 1100810:	d5182042 	msr	tcr_el1, x2
	msr	mair_el1, x3
 1100814:	d518a203 	msr	mair_el1, x3

	/*
	 * ttbr0_el1 = ttbr0_el1_base + ttbr0_core_offset * core_pos
	 */
	madd	x1, x5, x0, x4
 1100818:	9b0010a1 	madd	x1, x5, x0, x4
	msr	ttbr0_el1, x1
 110081c:	d5182001 	msr	ttbr0_el1, x1
	msr	ttbr1_el1, xzr
 1100820:	d518203f 	msr	ttbr1_el1, xzr
	isb
 1100824:	d5033fdf 	isb

	/* Invalidate TLB */
	tlbi	vmalle1
 1100828:	d508871f 	tlbi	vmalle1

	/*
	 * Make sure translation table writes have drained into memory and
	 * the TLB invalidation is complete.
	 */
	dsb	sy
 110082c:	d5033f9f 	dsb	sy
	isb
 1100830:	d5033fdf 	isb

	/* Enable the MMU */
	mrs	x1, sctlr_el1
 1100834:	d5381001 	mrs	x1, sctlr_el1
	orr	x1, x1, #SCTLR_M
 1100838:	b2400021 	orr	x1, x1, #0x1
	msr	sctlr_el1, x1
 110083c:	d5181001 	msr	sctlr_el1, x1
	isb
 1100840:	d5033fdf 	isb

	/* Update vbar */
	mrs	x1, vbar_el1
 1100844:	d538c001 	mrs	x1, vbar_el1
	add	x1, x1, x6
 1100848:	8b060021 	add	x1, x1, x6
	msr	vbar_el1, x1
 110084c:	d518c001 	msr	vbar_el1, x1
	isb
 1100850:	d5033fdf 	isb

	/* Invalidate instruction cache and branch predictor */
	ic	iallu
 1100854:	d508751f 	ic	iallu
	isb
 1100858:	d5033fdf 	isb

	/* Enable I and D cache */
	mrs	x1, sctlr_el1
 110085c:	d5381001 	mrs	x1, sctlr_el1
	orr	x1, x1, #SCTLR_I
 1100860:	b2740021 	orr	x1, x1, #0x1000
	orr	x1, x1, #SCTLR_C
 1100864:	b27e0021 	orr	x1, x1, #0x4
	msr	sctlr_el1, x1
 1100868:	d5181001 	msr	sctlr_el1, x1
	isb
 110086c:	d5033fdf 	isb

	/* Adjust stack pointers and return address */
	msr	spsel, #1
 1100870:	d50041bf 	msr	spsel, #0x1
	add	sp, sp, x6
 1100874:	8b2663ff 	add	sp, sp, x6
	msr	spsel, #0
 1100878:	d50040bf 	msr	spsel, #0x0
	add	sp, sp, x6
 110087c:	8b2663ff 	add	sp, sp, x6
	add	x30, x30, x6
 1100880:	8b0603de 	add	x30, x30, x6

	ret
 1100884:	d65f03c0 	ret

0000000001100888 <boot_mmu_config>:
	...
 11008b0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 11008c0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 11008d0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 11008e0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 11008f0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100900:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100910:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100920:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100930:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100940:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100950:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100960:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100970:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100980:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100990:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 11009a0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 11009b0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 11009c0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 11009d0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 11009e0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 11009f0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100a00:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100a10:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100a20:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100a30:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100a40:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100a50:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100a60:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100a70:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100a80:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100a90:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100aa0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100ab0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100ac0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100ad0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100ae0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100af0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100b00:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100b10:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100b20:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100b30:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100b40:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100b50:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100b60:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100b70:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100b80:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100b90:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100ba0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100bb0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100bc0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100bd0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100be0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100bf0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100c00:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100c10:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100c20:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100c30:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100c40:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100c50:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100c60:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100c70:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100c80:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100c90:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100ca0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100cb0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100cc0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100cd0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100ce0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100cf0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100d00:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100d10:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100d20:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100d30:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100d40:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100d50:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100d60:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100d70:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100d80:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100d90:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100da0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100db0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100dc0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100dd0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100de0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100df0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100e00:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100e10:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100e20:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100e30:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100e40:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100e50:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100e60:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100e70:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100e80:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100e90:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100ea0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100eb0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100ec0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100ed0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100ee0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100ef0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100f00:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100f10:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100f20:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100f30:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100f40:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100f50:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100f60:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100f70:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100f80:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100f90:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100fa0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100fb0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100fc0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100fd0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100fe0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
 1100ff0:	d503201f d503201f d503201f d503201f     . ... ... ... ..

0000000001101000 <reset_vect_table>:
	/* -----------------------------------------------------
	 * Current EL with SP0 : 0x0 - 0x180
	 * -----------------------------------------------------
	 */
SynchronousExceptionSP0:
	b	SynchronousExceptionSP0
 1101000:	14000000 	b	1101000 <reset_vect_table>
 1101004:	d503201f 	nop
 1101008:	d503201f 	nop
 110100c:	d503201f 	nop
 1101010:	d503201f 	nop
 1101014:	d503201f 	nop
 1101018:	d503201f 	nop
 110101c:	d503201f 	nop
 1101020:	d503201f 	nop
 1101024:	d503201f 	nop
 1101028:	d503201f 	nop
 110102c:	d503201f 	nop
 1101030:	d503201f 	nop
 1101034:	d503201f 	nop
 1101038:	d503201f 	nop
 110103c:	d503201f 	nop
 1101040:	d503201f 	nop
 1101044:	d503201f 	nop
 1101048:	d503201f 	nop
 110104c:	d503201f 	nop
 1101050:	d503201f 	nop
 1101054:	d503201f 	nop
 1101058:	d503201f 	nop
 110105c:	d503201f 	nop
 1101060:	d503201f 	nop
 1101064:	d503201f 	nop
 1101068:	d503201f 	nop
 110106c:	d503201f 	nop
 1101070:	d503201f 	nop
 1101074:	d503201f 	nop
 1101078:	d503201f 	nop
 110107c:	d503201f 	nop

0000000001101080 <IrqSP0>:
	check_vector_size SynchronousExceptionSP0

	.align	7
IrqSP0:
	b	IrqSP0
 1101080:	14000000 	b	1101080 <IrqSP0>
 1101084:	d503201f 	nop
 1101088:	d503201f 	nop
 110108c:	d503201f 	nop
 1101090:	d503201f 	nop
 1101094:	d503201f 	nop
 1101098:	d503201f 	nop
 110109c:	d503201f 	nop
 11010a0:	d503201f 	nop
 11010a4:	d503201f 	nop
 11010a8:	d503201f 	nop
 11010ac:	d503201f 	nop
 11010b0:	d503201f 	nop
 11010b4:	d503201f 	nop
 11010b8:	d503201f 	nop
 11010bc:	d503201f 	nop
 11010c0:	d503201f 	nop
 11010c4:	d503201f 	nop
 11010c8:	d503201f 	nop
 11010cc:	d503201f 	nop
 11010d0:	d503201f 	nop
 11010d4:	d503201f 	nop
 11010d8:	d503201f 	nop
 11010dc:	d503201f 	nop
 11010e0:	d503201f 	nop
 11010e4:	d503201f 	nop
 11010e8:	d503201f 	nop
 11010ec:	d503201f 	nop
 11010f0:	d503201f 	nop
 11010f4:	d503201f 	nop
 11010f8:	d503201f 	nop
 11010fc:	d503201f 	nop

0000000001101100 <FiqSP0>:
	check_vector_size IrqSP0

	.align	7
FiqSP0:
	b	FiqSP0
 1101100:	14000000 	b	1101100 <FiqSP0>
 1101104:	d503201f 	nop
 1101108:	d503201f 	nop
 110110c:	d503201f 	nop
 1101110:	d503201f 	nop
 1101114:	d503201f 	nop
 1101118:	d503201f 	nop
 110111c:	d503201f 	nop
 1101120:	d503201f 	nop
 1101124:	d503201f 	nop
 1101128:	d503201f 	nop
 110112c:	d503201f 	nop
 1101130:	d503201f 	nop
 1101134:	d503201f 	nop
 1101138:	d503201f 	nop
 110113c:	d503201f 	nop
 1101140:	d503201f 	nop
 1101144:	d503201f 	nop
 1101148:	d503201f 	nop
 110114c:	d503201f 	nop
 1101150:	d503201f 	nop
 1101154:	d503201f 	nop
 1101158:	d503201f 	nop
 110115c:	d503201f 	nop
 1101160:	d503201f 	nop
 1101164:	d503201f 	nop
 1101168:	d503201f 	nop
 110116c:	d503201f 	nop
 1101170:	d503201f 	nop
 1101174:	d503201f 	nop
 1101178:	d503201f 	nop
 110117c:	d503201f 	nop

0000000001101180 <SErrorSP0>:
	check_vector_size FiqSP0

	.align	7
SErrorSP0:
	b	SErrorSP0
 1101180:	14000000 	b	1101180 <SErrorSP0>
 1101184:	d503201f 	nop
 1101188:	d503201f 	nop
 110118c:	d503201f 	nop
 1101190:	d503201f 	nop
 1101194:	d503201f 	nop
 1101198:	d503201f 	nop
 110119c:	d503201f 	nop
 11011a0:	d503201f 	nop
 11011a4:	d503201f 	nop
 11011a8:	d503201f 	nop
 11011ac:	d503201f 	nop
 11011b0:	d503201f 	nop
 11011b4:	d503201f 	nop
 11011b8:	d503201f 	nop
 11011bc:	d503201f 	nop
 11011c0:	d503201f 	nop
 11011c4:	d503201f 	nop
 11011c8:	d503201f 	nop
 11011cc:	d503201f 	nop
 11011d0:	d503201f 	nop
 11011d4:	d503201f 	nop
 11011d8:	d503201f 	nop
 11011dc:	d503201f 	nop
 11011e0:	d503201f 	nop
 11011e4:	d503201f 	nop
 11011e8:	d503201f 	nop
 11011ec:	d503201f 	nop
 11011f0:	d503201f 	nop
 11011f4:	d503201f 	nop
 11011f8:	d503201f 	nop
 11011fc:	d503201f 	nop

0000000001101200 <SynchronousExceptionSPx>:
	 * Current EL with SPx: 0x200 - 0x380
	 * -----------------------------------------------------
	 */
	.align	7
SynchronousExceptionSPx:
	b	SynchronousExceptionSPx
 1101200:	14000000 	b	1101200 <SynchronousExceptionSPx>
 1101204:	d503201f 	nop
 1101208:	d503201f 	nop
 110120c:	d503201f 	nop
 1101210:	d503201f 	nop
 1101214:	d503201f 	nop
 1101218:	d503201f 	nop
 110121c:	d503201f 	nop
 1101220:	d503201f 	nop
 1101224:	d503201f 	nop
 1101228:	d503201f 	nop
 110122c:	d503201f 	nop
 1101230:	d503201f 	nop
 1101234:	d503201f 	nop
 1101238:	d503201f 	nop
 110123c:	d503201f 	nop
 1101240:	d503201f 	nop
 1101244:	d503201f 	nop
 1101248:	d503201f 	nop
 110124c:	d503201f 	nop
 1101250:	d503201f 	nop
 1101254:	d503201f 	nop
 1101258:	d503201f 	nop
 110125c:	d503201f 	nop
 1101260:	d503201f 	nop
 1101264:	d503201f 	nop
 1101268:	d503201f 	nop
 110126c:	d503201f 	nop
 1101270:	d503201f 	nop
 1101274:	d503201f 	nop
 1101278:	d503201f 	nop
 110127c:	d503201f 	nop

0000000001101280 <IrqSPx>:
	check_vector_size SynchronousExceptionSPx

	.align	7
IrqSPx:
	b	IrqSPx
 1101280:	14000000 	b	1101280 <IrqSPx>
 1101284:	d503201f 	nop
 1101288:	d503201f 	nop
 110128c:	d503201f 	nop
 1101290:	d503201f 	nop
 1101294:	d503201f 	nop
 1101298:	d503201f 	nop
 110129c:	d503201f 	nop
 11012a0:	d503201f 	nop
 11012a4:	d503201f 	nop
 11012a8:	d503201f 	nop
 11012ac:	d503201f 	nop
 11012b0:	d503201f 	nop
 11012b4:	d503201f 	nop
 11012b8:	d503201f 	nop
 11012bc:	d503201f 	nop
 11012c0:	d503201f 	nop
 11012c4:	d503201f 	nop
 11012c8:	d503201f 	nop
 11012cc:	d503201f 	nop
 11012d0:	d503201f 	nop
 11012d4:	d503201f 	nop
 11012d8:	d503201f 	nop
 11012dc:	d503201f 	nop
 11012e0:	d503201f 	nop
 11012e4:	d503201f 	nop
 11012e8:	d503201f 	nop
 11012ec:	d503201f 	nop
 11012f0:	d503201f 	nop
 11012f4:	d503201f 	nop
 11012f8:	d503201f 	nop
 11012fc:	d503201f 	nop

0000000001101300 <FiqSPx>:
	check_vector_size IrqSPx

	.align	7
FiqSPx:
	b	FiqSPx
 1101300:	14000000 	b	1101300 <FiqSPx>
 1101304:	d503201f 	nop
 1101308:	d503201f 	nop
 110130c:	d503201f 	nop
 1101310:	d503201f 	nop
 1101314:	d503201f 	nop
 1101318:	d503201f 	nop
 110131c:	d503201f 	nop
 1101320:	d503201f 	nop
 1101324:	d503201f 	nop
 1101328:	d503201f 	nop
 110132c:	d503201f 	nop
 1101330:	d503201f 	nop
 1101334:	d503201f 	nop
 1101338:	d503201f 	nop
 110133c:	d503201f 	nop
 1101340:	d503201f 	nop
 1101344:	d503201f 	nop
 1101348:	d503201f 	nop
 110134c:	d503201f 	nop
 1101350:	d503201f 	nop
 1101354:	d503201f 	nop
 1101358:	d503201f 	nop
 110135c:	d503201f 	nop
 1101360:	d503201f 	nop
 1101364:	d503201f 	nop
 1101368:	d503201f 	nop
 110136c:	d503201f 	nop
 1101370:	d503201f 	nop
 1101374:	d503201f 	nop
 1101378:	d503201f 	nop
 110137c:	d503201f 	nop

0000000001101380 <SErrorSPx>:
	check_vector_size FiqSPx

	.align	7
SErrorSPx:
	b	SErrorSPx
 1101380:	14000000 	b	1101380 <SErrorSPx>
 1101384:	d503201f 	nop
 1101388:	d503201f 	nop
 110138c:	d503201f 	nop
 1101390:	d503201f 	nop
 1101394:	d503201f 	nop
 1101398:	d503201f 	nop
 110139c:	d503201f 	nop
 11013a0:	d503201f 	nop
 11013a4:	d503201f 	nop
 11013a8:	d503201f 	nop
 11013ac:	d503201f 	nop
 11013b0:	d503201f 	nop
 11013b4:	d503201f 	nop
 11013b8:	d503201f 	nop
 11013bc:	d503201f 	nop
 11013c0:	d503201f 	nop
 11013c4:	d503201f 	nop
 11013c8:	d503201f 	nop
 11013cc:	d503201f 	nop
 11013d0:	d503201f 	nop
 11013d4:	d503201f 	nop
 11013d8:	d503201f 	nop
 11013dc:	d503201f 	nop
 11013e0:	d503201f 	nop
 11013e4:	d503201f 	nop
 11013e8:	d503201f 	nop
 11013ec:	d503201f 	nop
 11013f0:	d503201f 	nop
 11013f4:	d503201f 	nop
 11013f8:	d503201f 	nop
 11013fc:	d503201f 	nop

0000000001101400 <SynchronousExceptionA64>:
	 * Lower EL using AArch64 : 0x400 - 0x580
	 * -----------------------------------------------------
	 */
	.align	7
SynchronousExceptionA64:
	b	SynchronousExceptionA64
 1101400:	14000000 	b	1101400 <SynchronousExceptionA64>
 1101404:	d503201f 	nop
 1101408:	d503201f 	nop
 110140c:	d503201f 	nop
 1101410:	d503201f 	nop
 1101414:	d503201f 	nop
 1101418:	d503201f 	nop
 110141c:	d503201f 	nop
 1101420:	d503201f 	nop
 1101424:	d503201f 	nop
 1101428:	d503201f 	nop
 110142c:	d503201f 	nop
 1101430:	d503201f 	nop
 1101434:	d503201f 	nop
 1101438:	d503201f 	nop
 110143c:	d503201f 	nop
 1101440:	d503201f 	nop
 1101444:	d503201f 	nop
 1101448:	d503201f 	nop
 110144c:	d503201f 	nop
 1101450:	d503201f 	nop
 1101454:	d503201f 	nop
 1101458:	d503201f 	nop
 110145c:	d503201f 	nop
 1101460:	d503201f 	nop
 1101464:	d503201f 	nop
 1101468:	d503201f 	nop
 110146c:	d503201f 	nop
 1101470:	d503201f 	nop
 1101474:	d503201f 	nop
 1101478:	d503201f 	nop
 110147c:	d503201f 	nop

0000000001101480 <IrqA64>:
	check_vector_size SynchronousExceptionA64

	.align	7
IrqA64:
	b	IrqA64
 1101480:	14000000 	b	1101480 <IrqA64>
 1101484:	d503201f 	nop
 1101488:	d503201f 	nop
 110148c:	d503201f 	nop
 1101490:	d503201f 	nop
 1101494:	d503201f 	nop
 1101498:	d503201f 	nop
 110149c:	d503201f 	nop
 11014a0:	d503201f 	nop
 11014a4:	d503201f 	nop
 11014a8:	d503201f 	nop
 11014ac:	d503201f 	nop
 11014b0:	d503201f 	nop
 11014b4:	d503201f 	nop
 11014b8:	d503201f 	nop
 11014bc:	d503201f 	nop
 11014c0:	d503201f 	nop
 11014c4:	d503201f 	nop
 11014c8:	d503201f 	nop
 11014cc:	d503201f 	nop
 11014d0:	d503201f 	nop
 11014d4:	d503201f 	nop
 11014d8:	d503201f 	nop
 11014dc:	d503201f 	nop
 11014e0:	d503201f 	nop
 11014e4:	d503201f 	nop
 11014e8:	d503201f 	nop
 11014ec:	d503201f 	nop
 11014f0:	d503201f 	nop
 11014f4:	d503201f 	nop
 11014f8:	d503201f 	nop
 11014fc:	d503201f 	nop

0000000001101500 <FiqA64>:
	check_vector_size IrqA64

	.align	7
FiqA64:
	b	FiqA64
 1101500:	14000000 	b	1101500 <FiqA64>
 1101504:	d503201f 	nop
 1101508:	d503201f 	nop
 110150c:	d503201f 	nop
 1101510:	d503201f 	nop
 1101514:	d503201f 	nop
 1101518:	d503201f 	nop
 110151c:	d503201f 	nop
 1101520:	d503201f 	nop
 1101524:	d503201f 	nop
 1101528:	d503201f 	nop
 110152c:	d503201f 	nop
 1101530:	d503201f 	nop
 1101534:	d503201f 	nop
 1101538:	d503201f 	nop
 110153c:	d503201f 	nop
 1101540:	d503201f 	nop
 1101544:	d503201f 	nop
 1101548:	d503201f 	nop
 110154c:	d503201f 	nop
 1101550:	d503201f 	nop
 1101554:	d503201f 	nop
 1101558:	d503201f 	nop
 110155c:	d503201f 	nop
 1101560:	d503201f 	nop
 1101564:	d503201f 	nop
 1101568:	d503201f 	nop
 110156c:	d503201f 	nop
 1101570:	d503201f 	nop
 1101574:	d503201f 	nop
 1101578:	d503201f 	nop
 110157c:	d503201f 	nop

0000000001101580 <SErrorA64>:
	check_vector_size FiqA64

	.align	7
SErrorA64:
	b   	SErrorA64
 1101580:	14000000 	b	1101580 <SErrorA64>
 1101584:	d503201f 	nop
 1101588:	d503201f 	nop
 110158c:	d503201f 	nop
 1101590:	d503201f 	nop
 1101594:	d503201f 	nop
 1101598:	d503201f 	nop
 110159c:	d503201f 	nop
 11015a0:	d503201f 	nop
 11015a4:	d503201f 	nop
 11015a8:	d503201f 	nop
 11015ac:	d503201f 	nop
 11015b0:	d503201f 	nop
 11015b4:	d503201f 	nop
 11015b8:	d503201f 	nop
 11015bc:	d503201f 	nop
 11015c0:	d503201f 	nop
 11015c4:	d503201f 	nop
 11015c8:	d503201f 	nop
 11015cc:	d503201f 	nop
 11015d0:	d503201f 	nop
 11015d4:	d503201f 	nop
 11015d8:	d503201f 	nop
 11015dc:	d503201f 	nop
 11015e0:	d503201f 	nop
 11015e4:	d503201f 	nop
 11015e8:	d503201f 	nop
 11015ec:	d503201f 	nop
 11015f0:	d503201f 	nop
 11015f4:	d503201f 	nop
 11015f8:	d503201f 	nop
 11015fc:	d503201f 	nop

0000000001101600 <SynchronousExceptionA32>:
	 * Lower EL using AArch32 : 0x0 - 0x180
	 * -----------------------------------------------------
	 */
	.align	7
SynchronousExceptionA32:
	b	SynchronousExceptionA32
 1101600:	14000000 	b	1101600 <SynchronousExceptionA32>
 1101604:	d503201f 	nop
 1101608:	d503201f 	nop
 110160c:	d503201f 	nop
 1101610:	d503201f 	nop
 1101614:	d503201f 	nop
 1101618:	d503201f 	nop
 110161c:	d503201f 	nop
 1101620:	d503201f 	nop
 1101624:	d503201f 	nop
 1101628:	d503201f 	nop
 110162c:	d503201f 	nop
 1101630:	d503201f 	nop
 1101634:	d503201f 	nop
 1101638:	d503201f 	nop
 110163c:	d503201f 	nop
 1101640:	d503201f 	nop
 1101644:	d503201f 	nop
 1101648:	d503201f 	nop
 110164c:	d503201f 	nop
 1101650:	d503201f 	nop
 1101654:	d503201f 	nop
 1101658:	d503201f 	nop
 110165c:	d503201f 	nop
 1101660:	d503201f 	nop
 1101664:	d503201f 	nop
 1101668:	d503201f 	nop
 110166c:	d503201f 	nop
 1101670:	d503201f 	nop
 1101674:	d503201f 	nop
 1101678:	d503201f 	nop
 110167c:	d503201f 	nop

0000000001101680 <IrqA32>:
	check_vector_size SynchronousExceptionA32

	.align	7
IrqA32:
	b	IrqA32
 1101680:	14000000 	b	1101680 <IrqA32>
 1101684:	d503201f 	nop
 1101688:	d503201f 	nop
 110168c:	d503201f 	nop
 1101690:	d503201f 	nop
 1101694:	d503201f 	nop
 1101698:	d503201f 	nop
 110169c:	d503201f 	nop
 11016a0:	d503201f 	nop
 11016a4:	d503201f 	nop
 11016a8:	d503201f 	nop
 11016ac:	d503201f 	nop
 11016b0:	d503201f 	nop
 11016b4:	d503201f 	nop
 11016b8:	d503201f 	nop
 11016bc:	d503201f 	nop
 11016c0:	d503201f 	nop
 11016c4:	d503201f 	nop
 11016c8:	d503201f 	nop
 11016cc:	d503201f 	nop
 11016d0:	d503201f 	nop
 11016d4:	d503201f 	nop
 11016d8:	d503201f 	nop
 11016dc:	d503201f 	nop
 11016e0:	d503201f 	nop
 11016e4:	d503201f 	nop
 11016e8:	d503201f 	nop
 11016ec:	d503201f 	nop
 11016f0:	d503201f 	nop
 11016f4:	d503201f 	nop
 11016f8:	d503201f 	nop
 11016fc:	d503201f 	nop

0000000001101700 <FiqA32>:
	check_vector_size IrqA32

	.align	7
FiqA32:
	b	FiqA32
 1101700:	14000000 	b	1101700 <FiqA32>
 1101704:	d503201f 	nop
 1101708:	d503201f 	nop
 110170c:	d503201f 	nop
 1101710:	d503201f 	nop
 1101714:	d503201f 	nop
 1101718:	d503201f 	nop
 110171c:	d503201f 	nop
 1101720:	d503201f 	nop
 1101724:	d503201f 	nop
 1101728:	d503201f 	nop
 110172c:	d503201f 	nop
 1101730:	d503201f 	nop
 1101734:	d503201f 	nop
 1101738:	d503201f 	nop
 110173c:	d503201f 	nop
 1101740:	d503201f 	nop
 1101744:	d503201f 	nop
 1101748:	d503201f 	nop
 110174c:	d503201f 	nop
 1101750:	d503201f 	nop
 1101754:	d503201f 	nop
 1101758:	d503201f 	nop
 110175c:	d503201f 	nop
 1101760:	d503201f 	nop
 1101764:	d503201f 	nop
 1101768:	d503201f 	nop
 110176c:	d503201f 	nop
 1101770:	d503201f 	nop
 1101774:	d503201f 	nop
 1101778:	d503201f 	nop
 110177c:	d503201f 	nop

0000000001101780 <SErrorA32>:
	check_vector_size FiqA32

	.align	7
SErrorA32:
	b	SErrorA32
 1101780:	14000000 	b	1101780 <SErrorA32>
 1101784:	00000000 	.inst	0x00000000 ; undefined

0000000001101788 <stack_tmp_export>:
 1101788:	01190ab0 00000000                       ........

0000000001101790 <vector_std_smc_entry>:
1111:
#endif
	.endm

LOCAL_FUNC vector_std_smc_entry , : , .identity_map
	readjust_pc
 1101790:	58000a10 	ldr	x16, 11018d0 <thread_vector_table+0x24>
 1101794:	d61f0200 	br	x16
	bl	thread_handle_std_smc
 1101798:	940014ff 	bl	1106b94 <thread_handle_std_smc>
	 * Normally thread_handle_std_smc() should return via
	 * thread_exit(), thread_rpc(), but if thread_handle_std_smc()
	 * hasn't switched stack (error detected) it will do a normal "C"
	 * return.
	 */
	mov	w1, w0
 110179c:	2a0003e1 	mov	w1, w0
	ldr	x0, =TEESMC_OPTEED_RETURN_CALL_DONE
 11017a0:	580009c0 	ldr	x0, 11018d8 <thread_vector_table+0x2c>
	smc	#0
 11017a4:	d4000003 	smc	#0x0
	b	.	/* SMC should not return */
 11017a8:	14000000 	b	11017a8 <vector_std_smc_entry+0x18>

00000000011017ac <vector_fast_smc_entry>:
END_FUNC vector_std_smc_entry

LOCAL_FUNC vector_fast_smc_entry , : , .identity_map
	readjust_pc
 11017ac:	580009b0 	ldr	x16, 11018e0 <thread_vector_table+0x34>
 11017b0:	d61f0200 	br	x16
	sub	sp, sp, #THREAD_SMC_ARGS_SIZE
 11017b4:	d10103ff 	sub	sp, sp, #0x40
	store_xregs sp, THREAD_SMC_ARGS_X0, 0, 7
 11017b8:	a90007e0 	stp	x0, x1, [sp]
 11017bc:	a9010fe2 	stp	x2, x3, [sp, #16]
 11017c0:	a90217e4 	stp	x4, x5, [sp, #32]
 11017c4:	a9031fe6 	stp	x6, x7, [sp, #48]
	mov	x0, sp
 11017c8:	910003e0 	mov	x0, sp
	bl	thread_handle_fast_smc
 11017cc:	940014dc 	bl	1106b3c <thread_handle_fast_smc>
	load_xregs sp, THREAD_SMC_ARGS_X0, 1, 8
 11017d0:	a9400be1 	ldp	x1, x2, [sp]
 11017d4:	a94113e3 	ldp	x3, x4, [sp, #16]
 11017d8:	a9421be5 	ldp	x5, x6, [sp, #32]
 11017dc:	a94323e7 	ldp	x7, x8, [sp, #48]
	add	sp, sp, #THREAD_SMC_ARGS_SIZE
 11017e0:	910103ff 	add	sp, sp, #0x40
	ldr	x0, =TEESMC_OPTEED_RETURN_CALL_DONE
 11017e4:	580007a0 	ldr	x0, 11018d8 <thread_vector_table+0x2c>
	smc	#0
 11017e8:	d4000003 	smc	#0x0
	b	.	/* SMC should not return */
 11017ec:	14000000 	b	11017ec <vector_fast_smc_entry+0x40>

00000000011017f0 <vector_fiq_entry>:
END_FUNC vector_fast_smc_entry

LOCAL_FUNC vector_fiq_entry , : , .identity_map
	readjust_pc
 11017f0:	580007d0 	ldr	x16, 11018e8 <thread_vector_table+0x3c>
 11017f4:	d61f0200 	br	x16
	/* Secure Monitor received a FIQ and passed control to us. */
	bl	thread_check_canaries
 11017f8:	94000d0e 	bl	1104c30 <thread_check_canaries>
	bl	itr_core_handler
 11017fc:	94002e34 	bl	110d0cc <itr_core_handler>
	ldr	x0, =TEESMC_OPTEED_RETURN_FIQ_DONE
 1101800:	58000780 	ldr	x0, 11018f0 <thread_vector_table+0x44>
	smc	#0
 1101804:	d4000003 	smc	#0x0
	b	.	/* SMC should not return */
 1101808:	14000000 	b	1101808 <vector_fiq_entry+0x18>

000000000110180c <vector_cpu_on_entry>:
END_FUNC vector_fiq_entry

LOCAL_FUNC vector_cpu_on_entry , : , .identity_map
	bl	cpu_on_handler
 110180c:	94001a5a 	bl	1108174 <cpu_on_handler>
	mov	x1, x0
 1101810:	aa0003e1 	mov	x1, x0
	ldr	x0, =TEESMC_OPTEED_RETURN_ON_DONE
 1101814:	58000720 	ldr	x0, 11018f8 <thread_vector_table+0x4c>
	smc	#0
 1101818:	d4000003 	smc	#0x0
	b	.	/* SMC should not return */
 110181c:	14000000 	b	110181c <vector_cpu_on_entry+0x10>

0000000001101820 <vector_cpu_off_entry>:
END_FUNC vector_cpu_on_entry

LOCAL_FUNC vector_cpu_off_entry , : , .identity_map
	readjust_pc
 1101820:	58000710 	ldr	x16, 1101900 <thread_vector_table+0x54>
 1101824:	d61f0200 	br	x16
	bl	thread_cpu_off_handler
 1101828:	94000cd0 	bl	1104b68 <thread_cpu_off_handler>
	mov	x1, x0
 110182c:	aa0003e1 	mov	x1, x0
	ldr	x0, =TEESMC_OPTEED_RETURN_OFF_DONE
 1101830:	580006c0 	ldr	x0, 1101908 <thread_vector_table+0x5c>
	smc	#0
 1101834:	d4000003 	smc	#0x0
	b	.	/* SMC should not return */
 1101838:	14000000 	b	1101838 <vector_cpu_off_entry+0x18>

000000000110183c <vector_cpu_suspend_entry>:
END_FUNC vector_cpu_off_entry

LOCAL_FUNC vector_cpu_suspend_entry , : , .identity_map
	readjust_pc
 110183c:	580006b0 	ldr	x16, 1101910 <thread_vector_table+0x64>
 1101840:	d61f0200 	br	x16
	bl	thread_cpu_suspend_handler
 1101844:	94000cf5 	bl	1104c18 <thread_cpu_suspend_handler>
	mov	x1, x0
 1101848:	aa0003e1 	mov	x1, x0
	ldr	x0, =TEESMC_OPTEED_RETURN_SUSPEND_DONE
 110184c:	58000660 	ldr	x0, 1101918 <thread_vector_table+0x6c>
	smc	#0
 1101850:	d4000003 	smc	#0x0
	b	.	/* SMC should not return */
 1101854:	14000000 	b	1101854 <vector_cpu_suspend_entry+0x18>

0000000001101858 <vector_cpu_resume_entry>:
END_FUNC vector_cpu_suspend_entry

LOCAL_FUNC vector_cpu_resume_entry , : , .identity_map
	readjust_pc
 1101858:	58000650 	ldr	x16, 1101920 <thread_vector_table+0x74>
 110185c:	d61f0200 	br	x16
	bl	thread_cpu_resume_handler
 1101860:	94000cf0 	bl	1104c20 <thread_cpu_resume_handler>
	mov	x1, x0
 1101864:	aa0003e1 	mov	x1, x0
	ldr	x0, =TEESMC_OPTEED_RETURN_RESUME_DONE
 1101868:	58000600 	ldr	x0, 1101928 <thread_vector_table+0x7c>
	smc	#0
 110186c:	d4000003 	smc	#0x0
	b	.	/* SMC should not return */
 1101870:	14000000 	b	1101870 <vector_cpu_resume_entry+0x18>

0000000001101874 <vector_system_off_entry>:
END_FUNC vector_cpu_resume_entry

LOCAL_FUNC vector_system_off_entry , : , .identity_map
	readjust_pc
 1101874:	580005f0 	ldr	x16, 1101930 <thread_vector_table+0x84>
 1101878:	d61f0200 	br	x16
	bl	thread_system_off_handler
 110187c:	94000ceb 	bl	1104c28 <thread_system_off_handler>
	mov	x1, x0
 1101880:	aa0003e1 	mov	x1, x0
	ldr	x0, =TEESMC_OPTEED_RETURN_SYSTEM_OFF_DONE
 1101884:	580005a0 	ldr	x0, 1101938 <thread_vector_table+0x8c>
	smc	#0
 1101888:	d4000003 	smc	#0x0
	b	.	/* SMC should not return */
 110188c:	14000000 	b	110188c <vector_system_off_entry+0x18>

0000000001101890 <vector_system_reset_entry>:
END_FUNC vector_system_off_entry

LOCAL_FUNC vector_system_reset_entry , : , .identity_map
	readjust_pc
 1101890:	58000590 	ldr	x16, 1101940 <thread_vector_table+0x94>
 1101894:	d61f0200 	br	x16
	bl	thread_system_reset_handler
 1101898:	94000cde 	bl	1104c10 <thread_system_reset_handler>
	mov	x1, x0
 110189c:	aa0003e1 	mov	x1, x0
	ldr	x0, =TEESMC_OPTEED_RETURN_SYSTEM_RESET_DONE
 11018a0:	58000540 	ldr	x0, 1101948 <thread_vector_table+0x9c>
	smc	#0
 11018a4:	d4000003 	smc	#0x0
	b	.	/* SMC should not return */
 11018a8:	14000000 	b	11018a8 <vector_system_reset_entry+0x18>

00000000011018ac <thread_vector_table>:
 *
 * Note that ARM-TF depends on the layout of this vector table, any change
 * in layout has to be synced with ARM-TF.
 */
FUNC thread_vector_table , : , .identity_map
	b	vector_std_smc_entry
 11018ac:	17ffffb9 	b	1101790 <vector_std_smc_entry>
	b	vector_fast_smc_entry
 11018b0:	17ffffbf 	b	11017ac <vector_fast_smc_entry>
	b	vector_cpu_on_entry
 11018b4:	17ffffd6 	b	110180c <vector_cpu_on_entry>
	b	vector_cpu_off_entry
 11018b8:	17ffffda 	b	1101820 <vector_cpu_off_entry>
	b	vector_cpu_resume_entry
 11018bc:	17ffffe7 	b	1101858 <vector_cpu_resume_entry>
	b	vector_cpu_suspend_entry
 11018c0:	17ffffdf 	b	110183c <vector_cpu_suspend_entry>
	b	vector_fiq_entry
 11018c4:	17ffffcb 	b	11017f0 <vector_fiq_entry>
	b	vector_system_off_entry
 11018c8:	17ffffeb 	b	1101874 <vector_system_off_entry>
	b	vector_system_reset_entry
 11018cc:	17fffff1 	b	1101890 <vector_system_reset_entry>
 11018d0:	01101798 	.word	0x01101798
 11018d4:	00000000 	.word	0x00000000
 11018d8:	be000005 	.word	0xbe000005
 11018dc:	00000000 	.word	0x00000000
 11018e0:	011017b4 	.word	0x011017b4
 11018e4:	00000000 	.word	0x00000000
 11018e8:	011017f8 	.word	0x011017f8
 11018ec:	00000000 	.word	0x00000000
 11018f0:	be000006 	.word	0xbe000006
 11018f4:	00000000 	.word	0x00000000
 11018f8:	be000001 	.word	0xbe000001
 11018fc:	00000000 	.word	0x00000000
 1101900:	01101828 	.word	0x01101828
 1101904:	00000000 	.word	0x00000000
 1101908:	be000002 	.word	0xbe000002
 110190c:	00000000 	.word	0x00000000
 1101910:	01101844 	.word	0x01101844
 1101914:	00000000 	.word	0x00000000
 1101918:	be000003 	.word	0xbe000003
 110191c:	00000000 	.word	0x00000000
 1101920:	01101860 	.word	0x01101860
 1101924:	00000000 	.word	0x00000000
 1101928:	be000004 	.word	0xbe000004
 110192c:	00000000 	.word	0x00000000
 1101930:	0110187c 	.word	0x0110187c
 1101934:	00000000 	.word	0x00000000
 1101938:	be000007 	.word	0xbe000007
 110193c:	00000000 	.word	0x00000000
 1101940:	01101898 	.word	0x01101898
 1101944:	00000000 	.word	0x00000000
 1101948:	be000008 	.word	0xbe000008
 110194c:	00000000 	.word	0x00000000

0000000001101950 <stack_tmp_stride>:
 1101950:	00000840                                @...

0000000001101954 <__get_core_pos>:
#include <arm.h>
#include <platform_config.h>

/* size_t __get_core_pos(void); */
FUNC __get_core_pos , : , .identity_map
	mrs	x0, mpidr_el1
 1101954:	d53800a0 	mrs	x0, mpidr_el1
	b get_core_pos_mpidr
 1101958:	14000001 	b	110195c <get_core_pos_mpidr>

000000000110195c <get_core_pos_mpidr>:
	 * Using logical shift ensures AFF0 to be filled with zeroes.
	 * This part is necessary even if CFG_CORE_THREAD_SHIFT is 0 because
	 * MT bit can be set on single threaded systems where all the AFF0
	 * values are zeroes.
	 */
	tst	x0, #MPIDR_MT_MASK
 110195c:	f268001f 	tst	x0, #0x1000000
	lsl	x3, x0, #MPIDR_AFFINITY_BITS
 1101960:	d378dc03 	lsl	x3, x0, #8
	csel	x3, x3, x0, eq
 1101964:	9a800063 	csel	x3, x3, x0, eq  // eq = none
	 * At this point the MPIDR layout is always shifted so it looks
	 * as follows AFF2 -> cluster, AFF1 -> core, AFF0 -> thread
	 */
#if CFG_CORE_THREAD_SHIFT == 0
	/* Calculate CorePos = (ClusterId * (cores/cluster)) + CoreId */
	ubfx	x0, x3, #MPIDR_AFF1_SHIFT, #MPIDR_AFFINITY_BITS
 1101968:	d3483c60 	ubfx	x0, x3, #8, #8
	ubfx	x1, x3, #MPIDR_AFF2_SHIFT, #MPIDR_AFFINITY_BITS
 110196c:	d3505c61 	ubfx	x1, x3, #16, #8
	add	x0, x0, x1, LSL #(CFG_CORE_CLUSTER_SHIFT)
 1101970:	8b010800 	add	x0, x0, x1, lsl #2
	ubfx	x2, x3, #MPIDR_AFF2_SHIFT, #MPIDR_AFFINITY_BITS
	add	x1, x1, x2, LSL #(CFG_CORE_CLUSTER_SHIFT)
	add	x0, x0, x1, LSL #(CFG_CORE_THREAD_SHIFT)
#endif

	ret
 1101974:	d65f03c0 	ret

0000000001101978 <unhandled_cpu>:
	wfi
 1101978:	d503207f 	wfi
	b	unhandled_cpu
 110197c:	17ffffff 	b	1101978 <unhandled_cpu>

0000000001101980 <init>:
	assert(!mempool_default);
	mempool_default = p;
}

static int init(void **a)
{
 1101980:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	mbedtls_mpi *bn = mempool_alloc(mbedtls_mpi_mempool, sizeof(*bn));
 1101984:	d2800301 	mov	x1, #0x18                  	// #24
{
 1101988:	910003fd 	mov	x29, sp
 110198c:	a90153f3 	stp	x19, x20, [sp, #16]
 1101990:	aa0003f4 	mov	x20, x0
	mbedtls_mpi *bn = mempool_alloc(mbedtls_mpi_mempool, sizeof(*bn));
 1101994:	b00002c0 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1101998:	f9424c00 	ldr	x0, [x0, #1176]
 110199c:	f9400000 	ldr	x0, [x0]
 11019a0:	94010d38 	bl	1144e80 <mempool_alloc>

	if (!bn)
 11019a4:	b4000100 	cbz	x0, 11019c4 <init+0x44>
 11019a8:	aa0003f3 	mov	x19, x0
		return CRYPT_MEM;

	mbedtls_mpi_init_mempool(bn);
 11019ac:	9400f97f 	bl	113ffa8 <mbedtls_mpi_init_mempool>
	*a = bn;
	return CRYPT_OK;
 11019b0:	52800000 	mov	w0, #0x0                   	// #0
	*a = bn;
 11019b4:	f9000293 	str	x19, [x20]
}
 11019b8:	a94153f3 	ldp	x19, x20, [sp, #16]
 11019bc:	a8c27bfd 	ldp	x29, x30, [sp], #32
 11019c0:	d65f03c0 	ret
		return CRYPT_MEM;
 11019c4:	528001a0 	mov	w0, #0xd                   	// #13
 11019c8:	17fffffc 	b	11019b8 <init+0x38>
	...

0000000001102000 <thread_excp_vect>:
	 * EL1 with SP0 : 0x0 - 0x180
	 * -----------------------------------------------------
	 */
	.balign	128, INV_INSN
el1_sync_sp0:
	store_xregs sp, THREAD_CORE_LOCAL_X0, 0, 3
 1102000:	a90007e0 	stp	x0, x1, [sp]
 1102004:	a9010fe2 	stp	x2, x3, [sp, #16]
	b	el1_sync_abort
 1102008:	14000a20 	b	1104888 <el1_sync_abort>
	...

0000000001102080 <el1_irq_sp0>:
	check_vector_size el1_sync_sp0

	.balign	128, INV_INSN
el1_irq_sp0:
	store_xregs sp, THREAD_CORE_LOCAL_X0, 0, 3
 1102080:	a90007e0 	stp	x0, x1, [sp]
 1102084:	a9010fe2 	stp	x2, x3, [sp, #16]
	b	elx_irq
 1102088:	14000480 	b	1103288 <elx_irq>
	...

0000000001102100 <el1_fiq_sp0>:
	check_vector_size el1_irq_sp0

	.balign	128, INV_INSN
el1_fiq_sp0:
	store_xregs sp, THREAD_CORE_LOCAL_X0, 0, 3
 1102100:	a90007e0 	stp	x0, x1, [sp]
 1102104:	a9010fe2 	stp	x2, x3, [sp, #16]
	b	elx_fiq
 1102108:	14000a6b 	b	1104ab4 <elx_fiq>
	...

0000000001102180 <el1_serror_sp0>:
	check_vector_size el1_fiq_sp0

	.balign	128, INV_INSN
el1_serror_sp0:
	b	el1_serror_sp0
 1102180:	14000000 	b	1102180 <el1_serror_sp0>
	...

0000000001102200 <el1_sync_sp1>:
	 * Current EL with SP1: 0x200 - 0x380
	 * -----------------------------------------------------
	 */
	.balign	128, INV_INSN
el1_sync_sp1:
	b	el1_sync_sp1
 1102200:	14000000 	b	1102200 <el1_sync_sp1>
	...

0000000001102280 <el1_irq_sp1>:
	check_vector_size el1_sync_sp1

	.balign	128, INV_INSN
el1_irq_sp1:
	b	el1_irq_sp1
 1102280:	14000000 	b	1102280 <el1_irq_sp1>
	...

0000000001102300 <el1_fiq_sp1>:
	check_vector_size el1_irq_sp1

	.balign	128, INV_INSN
el1_fiq_sp1:
	b	el1_fiq_sp1
 1102300:	14000000 	b	1102300 <el1_fiq_sp1>
	...

0000000001102380 <el1_serror_sp1>:
	check_vector_size el1_fiq_sp1

	.balign	128, INV_INSN
el1_serror_sp1:
	b	el1_serror_sp1
 1102380:	14000000 	b	1102380 <el1_serror_sp1>
	...

0000000001102400 <el0_sync_a64>:
	 * Lower EL using AArch64 : 0x400 - 0x580
	 * -----------------------------------------------------
	 */
	.balign	128, INV_INSN
el0_sync_a64:
	restore_mapping
 1102400:	d518d080 	msr	tpidr_el1, x0
 1102404:	d51bd061 	msr	tpidrro_el0, x1
 1102408:	d5382000 	mrs	x0, ttbr0_el1
 110240c:	d1020000 	sub	x0, x0, #0x80
 1102410:	924ff800 	and	x0, x0, #0xfffeffffffffffff
 1102414:	d5182000 	msr	ttbr0_el1, x0
 1102418:	d5033fdf 	isb
 110241c:	58006360 	ldr	x0, 1103088 <icache_inv_user_range+0x98>
 1102420:	d61f0000 	br	x0
 1102424:	f0000320 	adrp	x0, 1169000 <threads+0x540>
 1102428:	91274000 	add	x0, x0, #0x9d0
 110242c:	f9400000 	ldr	x0, [x0]
 1102430:	d538c001 	mrs	x1, vbar_el1
 1102434:	8b000021 	add	x1, x1, x0
 1102438:	d518c001 	msr	vbar_el1, x1
 110243c:	d5033fdf 	isb
 1102440:	f0000320 	adrp	x0, 1169000 <threads+0x540>
 1102444:	91230000 	add	x0, x0, #0x8c0
 1102448:	f9400000 	ldr	x0, [x0]
 110244c:	8b2063ff 	add	sp, sp, x0
 1102450:	d538d080 	mrs	x0, tpidr_el1
 1102454:	d53bd061 	mrs	x1, tpidrro_el0
 1102458:	a90007e0 	stp	x0, x1, [sp]
 110245c:	a9010fe2 	stp	x2, x3, [sp, #16]

	mrs	x2, esr_el1
 1102460:	d5385202 	mrs	x2, esr_el1
	mrs	x3, sp_el0
 1102464:	d5384103 	mrs	x3, sp_el0
	lsr	x2, x2, #ESR_EC_SHIFT
 1102468:	d35afc42 	lsr	x2, x2, #26
	cmp	x2, #ESR_EC_AARCH64_SVC
 110246c:	f100545f 	cmp	x2, #0x15
	b.eq	el0_svc
 1102470:	54006840 	b.eq	1103178 <el0_svc>  // b.none
	b	el0_sync_abort
 1102474:	1400094b 	b	11049a0 <el0_sync_abort>
	...

0000000001102480 <el0_irq_a64>:
	check_vector_size el0_sync_a64

	.balign	128, INV_INSN
el0_irq_a64:
	restore_mapping
 1102480:	d518d080 	msr	tpidr_el1, x0
 1102484:	d51bd061 	msr	tpidrro_el0, x1
 1102488:	d5382000 	mrs	x0, ttbr0_el1
 110248c:	d1020000 	sub	x0, x0, #0x80
 1102490:	924ff800 	and	x0, x0, #0xfffeffffffffffff
 1102494:	d5182000 	msr	ttbr0_el1, x0
 1102498:	d5033fdf 	isb
 110249c:	58005fa0 	ldr	x0, 1103090 <icache_inv_user_range+0xa0>
 11024a0:	d61f0000 	br	x0
 11024a4:	f0000320 	adrp	x0, 1169000 <threads+0x540>
 11024a8:	91274000 	add	x0, x0, #0x9d0
 11024ac:	f9400000 	ldr	x0, [x0]
 11024b0:	d538c001 	mrs	x1, vbar_el1
 11024b4:	8b000021 	add	x1, x1, x0
 11024b8:	d518c001 	msr	vbar_el1, x1
 11024bc:	d5033fdf 	isb
 11024c0:	f0000320 	adrp	x0, 1169000 <threads+0x540>
 11024c4:	91230000 	add	x0, x0, #0x8c0
 11024c8:	f9400000 	ldr	x0, [x0]
 11024cc:	8b2063ff 	add	sp, sp, x0
 11024d0:	d538d080 	mrs	x0, tpidr_el1
 11024d4:	d53bd061 	mrs	x1, tpidrro_el0
 11024d8:	a90007e0 	stp	x0, x1, [sp]
 11024dc:	a9010fe2 	stp	x2, x3, [sp, #16]

	b	elx_irq
 11024e0:	1400036a 	b	1103288 <elx_irq>
	...

0000000001102500 <el0_fiq_a64>:
	check_vector_size el0_irq_a64

	.balign	128, INV_INSN
el0_fiq_a64:
	restore_mapping
 1102500:	d518d080 	msr	tpidr_el1, x0
 1102504:	d51bd061 	msr	tpidrro_el0, x1
 1102508:	d5382000 	mrs	x0, ttbr0_el1
 110250c:	d1020000 	sub	x0, x0, #0x80
 1102510:	924ff800 	and	x0, x0, #0xfffeffffffffffff
 1102514:	d5182000 	msr	ttbr0_el1, x0
 1102518:	d5033fdf 	isb
 110251c:	58005be0 	ldr	x0, 1103098 <icache_inv_user_range+0xa8>
 1102520:	d61f0000 	br	x0
 1102524:	f0000320 	adrp	x0, 1169000 <threads+0x540>
 1102528:	91274000 	add	x0, x0, #0x9d0
 110252c:	f9400000 	ldr	x0, [x0]
 1102530:	d538c001 	mrs	x1, vbar_el1
 1102534:	8b000021 	add	x1, x1, x0
 1102538:	d518c001 	msr	vbar_el1, x1
 110253c:	d5033fdf 	isb
 1102540:	f0000320 	adrp	x0, 1169000 <threads+0x540>
 1102544:	91230000 	add	x0, x0, #0x8c0
 1102548:	f9400000 	ldr	x0, [x0]
 110254c:	8b2063ff 	add	sp, sp, x0
 1102550:	d538d080 	mrs	x0, tpidr_el1
 1102554:	d53bd061 	mrs	x1, tpidrro_el0
 1102558:	a90007e0 	stp	x0, x1, [sp]
 110255c:	a9010fe2 	stp	x2, x3, [sp, #16]

	b	elx_fiq
 1102560:	14000955 	b	1104ab4 <elx_fiq>
	...

0000000001102580 <el0_serror_a64>:
	check_vector_size el0_fiq_a64

	.balign	128, INV_INSN
el0_serror_a64:
	b   	el0_serror_a64
 1102580:	14000000 	b	1102580 <el0_serror_a64>
	...

0000000001102600 <el0_sync_a32>:
	 * Lower EL using AArch32 : 0x0 - 0x180
	 * -----------------------------------------------------
	 */
	.balign	128, INV_INSN
el0_sync_a32:
	restore_mapping
 1102600:	d518d080 	msr	tpidr_el1, x0
 1102604:	d51bd061 	msr	tpidrro_el0, x1
 1102608:	d5382000 	mrs	x0, ttbr0_el1
 110260c:	d1020000 	sub	x0, x0, #0x80
 1102610:	924ff800 	and	x0, x0, #0xfffeffffffffffff
 1102614:	d5182000 	msr	ttbr0_el1, x0
 1102618:	d5033fdf 	isb
 110261c:	58005420 	ldr	x0, 11030a0 <icache_inv_user_range+0xb0>
 1102620:	d61f0000 	br	x0
 1102624:	f0000320 	adrp	x0, 1169000 <threads+0x540>
 1102628:	91274000 	add	x0, x0, #0x9d0
 110262c:	f9400000 	ldr	x0, [x0]
 1102630:	d538c001 	mrs	x1, vbar_el1
 1102634:	8b000021 	add	x1, x1, x0
 1102638:	d518c001 	msr	vbar_el1, x1
 110263c:	d5033fdf 	isb
 1102640:	f0000320 	adrp	x0, 1169000 <threads+0x540>
 1102644:	91230000 	add	x0, x0, #0x8c0
 1102648:	f9400000 	ldr	x0, [x0]
 110264c:	8b2063ff 	add	sp, sp, x0
 1102650:	d538d080 	mrs	x0, tpidr_el1
 1102654:	d53bd061 	mrs	x1, tpidrro_el0
 1102658:	a90007e0 	stp	x0, x1, [sp]
 110265c:	a9010fe2 	stp	x2, x3, [sp, #16]

	mrs	x2, esr_el1
 1102660:	d5385202 	mrs	x2, esr_el1
	mrs	x3, sp_el0
 1102664:	d5384103 	mrs	x3, sp_el0
	lsr	x2, x2, #ESR_EC_SHIFT
 1102668:	d35afc42 	lsr	x2, x2, #26
	cmp	x2, #ESR_EC_AARCH32_SVC
 110266c:	f100445f 	cmp	x2, #0x11
	b.eq	el0_svc
 1102670:	54005840 	b.eq	1103178 <el0_svc>  // b.none
	b	el0_sync_abort
 1102674:	140008cb 	b	11049a0 <el0_sync_abort>
	...

0000000001102680 <el0_irq_a32>:
	check_vector_size el0_sync_a32

	.balign	128, INV_INSN
el0_irq_a32:
	restore_mapping
 1102680:	d518d080 	msr	tpidr_el1, x0
 1102684:	d51bd061 	msr	tpidrro_el0, x1
 1102688:	d5382000 	mrs	x0, ttbr0_el1
 110268c:	d1020000 	sub	x0, x0, #0x80
 1102690:	924ff800 	and	x0, x0, #0xfffeffffffffffff
 1102694:	d5182000 	msr	ttbr0_el1, x0
 1102698:	d5033fdf 	isb
 110269c:	58005060 	ldr	x0, 11030a8 <icache_inv_user_range+0xb8>
 11026a0:	d61f0000 	br	x0
 11026a4:	f0000320 	adrp	x0, 1169000 <threads+0x540>
 11026a8:	91274000 	add	x0, x0, #0x9d0
 11026ac:	f9400000 	ldr	x0, [x0]
 11026b0:	d538c001 	mrs	x1, vbar_el1
 11026b4:	8b000021 	add	x1, x1, x0
 11026b8:	d518c001 	msr	vbar_el1, x1
 11026bc:	d5033fdf 	isb
 11026c0:	f0000320 	adrp	x0, 1169000 <threads+0x540>
 11026c4:	91230000 	add	x0, x0, #0x8c0
 11026c8:	f9400000 	ldr	x0, [x0]
 11026cc:	8b2063ff 	add	sp, sp, x0
 11026d0:	d538d080 	mrs	x0, tpidr_el1
 11026d4:	d53bd061 	mrs	x1, tpidrro_el0
 11026d8:	a90007e0 	stp	x0, x1, [sp]
 11026dc:	a9010fe2 	stp	x2, x3, [sp, #16]

	b	elx_irq
 11026e0:	140002ea 	b	1103288 <elx_irq>
	...

0000000001102700 <el0_fiq_a32>:
	check_vector_size el0_irq_a32

	.balign	128, INV_INSN
el0_fiq_a32:
	restore_mapping
 1102700:	d518d080 	msr	tpidr_el1, x0
 1102704:	d51bd061 	msr	tpidrro_el0, x1
 1102708:	d5382000 	mrs	x0, ttbr0_el1
 110270c:	d1020000 	sub	x0, x0, #0x80
 1102710:	924ff800 	and	x0, x0, #0xfffeffffffffffff
 1102714:	d5182000 	msr	ttbr0_el1, x0
 1102718:	d5033fdf 	isb
 110271c:	58004ca0 	ldr	x0, 11030b0 <icache_inv_user_range+0xc0>
 1102720:	d61f0000 	br	x0
 1102724:	f0000320 	adrp	x0, 1169000 <threads+0x540>
 1102728:	91274000 	add	x0, x0, #0x9d0
 110272c:	f9400000 	ldr	x0, [x0]
 1102730:	d538c001 	mrs	x1, vbar_el1
 1102734:	8b000021 	add	x1, x1, x0
 1102738:	d518c001 	msr	vbar_el1, x1
 110273c:	d5033fdf 	isb
 1102740:	f0000320 	adrp	x0, 1169000 <threads+0x540>
 1102744:	91230000 	add	x0, x0, #0x8c0
 1102748:	f9400000 	ldr	x0, [x0]
 110274c:	8b2063ff 	add	sp, sp, x0
 1102750:	d538d080 	mrs	x0, tpidr_el1
 1102754:	d53bd061 	mrs	x1, tpidrro_el0
 1102758:	a90007e0 	stp	x0, x1, [sp]
 110275c:	a9010fe2 	stp	x2, x3, [sp, #16]

	b	elx_fiq
 1102760:	140008d5 	b	1104ab4 <elx_fiq>
	...

0000000001102780 <el0_serror_a32>:
	check_vector_size el0_fiq_a32

	.balign	128, INV_INSN
el0_serror_a32:
	b	el0_serror_a32
 1102780:	14000000 	b	1102780 <el0_serror_a32>
	...

0000000001102800 <thread_excp_vect_workaround>:
	 * EL1 with SP0 : 0x0 - 0x180
	 * -----------------------------------------------------
	 */
	.balign	128, INV_INSN
workaround_el1_sync_sp0:
	b	el1_sync_sp0
 1102800:	17fffe00 	b	1102000 <thread_excp_vect>
	...

0000000001102880 <workaround_el1_irq_sp0>:
	check_vector_size workaround_el1_sync_sp0

	.balign	128, INV_INSN
workaround_el1_irq_sp0:
	b	el1_irq_sp0
 1102880:	17fffe00 	b	1102080 <el1_irq_sp0>
	...

0000000001102900 <workaround_el1_fiq_sp0>:
	check_vector_size workaround_el1_irq_sp0

	.balign	128, INV_INSN
workaround_el1_fiq_sp0:
	b	el1_fiq_sp0
 1102900:	17fffe00 	b	1102100 <el1_fiq_sp0>
	...

0000000001102980 <workaround_el1_serror_sp0>:
	check_vector_size workaround_el1_fiq_sp0

	.balign	128, INV_INSN
workaround_el1_serror_sp0:
	b	el1_serror_sp0
 1102980:	17fffe00 	b	1102180 <el1_serror_sp0>
	...

0000000001102a00 <workaround_el1_sync_sp1>:
	 * Current EL with SP1: 0x200 - 0x380
	 * -----------------------------------------------------
	 */
	.balign	128, INV_INSN
workaround_el1_sync_sp1:
	b	workaround_el1_sync_sp1
 1102a00:	14000000 	b	1102a00 <workaround_el1_sync_sp1>
	...

0000000001102a80 <workaround_el1_irq_sp1>:
	check_vector_size workaround_el1_sync_sp1

	.balign	128, INV_INSN
workaround_el1_irq_sp1:
	b	workaround_el1_irq_sp1
 1102a80:	14000000 	b	1102a80 <workaround_el1_irq_sp1>
	...

0000000001102b00 <workaround_el1_fiq_sp1>:
	check_vector_size workaround_el1_irq_sp1

	.balign	128, INV_INSN
workaround_el1_fiq_sp1:
	b	workaround_el1_fiq_sp1
 1102b00:	14000000 	b	1102b00 <workaround_el1_fiq_sp1>
	...

0000000001102b80 <workaround_el1_serror_sp1>:
	check_vector_size workaround_el1_fiq_sp1

	.balign	128, INV_INSN
workaround_el1_serror_sp1:
	b	workaround_el1_serror_sp1
 1102b80:	14000000 	b	1102b80 <workaround_el1_serror_sp1>
	...

0000000001102c00 <workaround_el0_sync_a64>:
	 * Lower EL using AArch64 : 0x400 - 0x580
	 * -----------------------------------------------------
	 */
	.balign	128, INV_INSN
workaround_el0_sync_a64:
	invalidate_branch_predictor
 1102c00:	a90007e0 	stp	x0, x1, [sp]
 1102c04:	a9010fe2 	stp	x2, x3, [sp, #16]
 1102c08:	d2c00000 	movz	x0, #0x0, lsl #32
 1102c0c:	f2b00000 	movk	x0, #0x8000, lsl #16
 1102c10:	f2900000 	movk	x0, #0x8000
 1102c14:	d4000003 	smc	#0x0
 1102c18:	a94007e0 	ldp	x0, x1, [sp]
 1102c1c:	a9410fe2 	ldp	x2, x3, [sp, #16]
	b	el0_sync_a64
 1102c20:	17fffdf8 	b	1102400 <el0_sync_a64>
	...

0000000001102c80 <workaround_el0_irq_a64>:
	check_vector_size workaround_el0_sync_a64

	.balign	128, INV_INSN
workaround_el0_irq_a64:
	invalidate_branch_predictor
 1102c80:	a90007e0 	stp	x0, x1, [sp]
 1102c84:	a9010fe2 	stp	x2, x3, [sp, #16]
 1102c88:	d2c00000 	movz	x0, #0x0, lsl #32
 1102c8c:	f2b00000 	movk	x0, #0x8000, lsl #16
 1102c90:	f2900000 	movk	x0, #0x8000
 1102c94:	d4000003 	smc	#0x0
 1102c98:	a94007e0 	ldp	x0, x1, [sp]
 1102c9c:	a9410fe2 	ldp	x2, x3, [sp, #16]
	b	el0_irq_a64
 1102ca0:	17fffdf8 	b	1102480 <el0_irq_a64>
	...

0000000001102d00 <workaround_el0_fiq_a64>:
	check_vector_size workaround_el0_irq_a64

	.balign	128, INV_INSN
workaround_el0_fiq_a64:
	invalidate_branch_predictor
 1102d00:	a90007e0 	stp	x0, x1, [sp]
 1102d04:	a9010fe2 	stp	x2, x3, [sp, #16]
 1102d08:	d2c00000 	movz	x0, #0x0, lsl #32
 1102d0c:	f2b00000 	movk	x0, #0x8000, lsl #16
 1102d10:	f2900000 	movk	x0, #0x8000
 1102d14:	d4000003 	smc	#0x0
 1102d18:	a94007e0 	ldp	x0, x1, [sp]
 1102d1c:	a9410fe2 	ldp	x2, x3, [sp, #16]
	b	el0_fiq_a64
 1102d20:	17fffdf8 	b	1102500 <el0_fiq_a64>
	...

0000000001102d80 <workaround_el0_serror_a64>:
	check_vector_size workaround_el0_fiq_a64

	.balign	128, INV_INSN
workaround_el0_serror_a64:
	b   	workaround_el0_serror_a64
 1102d80:	14000000 	b	1102d80 <workaround_el0_serror_a64>
	...

0000000001102e00 <workaround_el0_sync_a32>:
	 * Lower EL using AArch32 : 0x0 - 0x180
	 * -----------------------------------------------------
	 */
	.balign	128, INV_INSN
workaround_el0_sync_a32:
	invalidate_branch_predictor
 1102e00:	a90007e0 	stp	x0, x1, [sp]
 1102e04:	a9010fe2 	stp	x2, x3, [sp, #16]
 1102e08:	d2c00000 	movz	x0, #0x0, lsl #32
 1102e0c:	f2b00000 	movk	x0, #0x8000, lsl #16
 1102e10:	f2900000 	movk	x0, #0x8000
 1102e14:	d4000003 	smc	#0x0
 1102e18:	a94007e0 	ldp	x0, x1, [sp]
 1102e1c:	a9410fe2 	ldp	x2, x3, [sp, #16]
	b	el0_sync_a32
 1102e20:	17fffdf8 	b	1102600 <el0_sync_a32>
	...

0000000001102e80 <workaround_el0_irq_a32>:
	check_vector_size workaround_el0_sync_a32

	.balign	128, INV_INSN
workaround_el0_irq_a32:
	invalidate_branch_predictor
 1102e80:	a90007e0 	stp	x0, x1, [sp]
 1102e84:	a9010fe2 	stp	x2, x3, [sp, #16]
 1102e88:	d2c00000 	movz	x0, #0x0, lsl #32
 1102e8c:	f2b00000 	movk	x0, #0x8000, lsl #16
 1102e90:	f2900000 	movk	x0, #0x8000
 1102e94:	d4000003 	smc	#0x0
 1102e98:	a94007e0 	ldp	x0, x1, [sp]
 1102e9c:	a9410fe2 	ldp	x2, x3, [sp, #16]
	b	el0_irq_a32
 1102ea0:	17fffdf8 	b	1102680 <el0_irq_a32>
	...

0000000001102f00 <workaround_el0_fiq_a32>:
	check_vector_size workaround_el0_irq_a32

	.balign	128, INV_INSN
workaround_el0_fiq_a32:
	invalidate_branch_predictor
 1102f00:	a90007e0 	stp	x0, x1, [sp]
 1102f04:	a9010fe2 	stp	x2, x3, [sp, #16]
 1102f08:	d2c00000 	movz	x0, #0x0, lsl #32
 1102f0c:	f2b00000 	movk	x0, #0x8000, lsl #16
 1102f10:	f2900000 	movk	x0, #0x8000
 1102f14:	d4000003 	smc	#0x0
 1102f18:	a94007e0 	ldp	x0, x1, [sp]
 1102f1c:	a9410fe2 	ldp	x2, x3, [sp, #16]
	b	el0_fiq_a32
 1102f20:	17fffdf8 	b	1102700 <el0_fiq_a32>
	...

0000000001102f80 <workaround_el0_serror_a32>:
	check_vector_size workaround_el0_fiq_a32

	.balign	128, INV_INSN
workaround_el0_serror_a32:
	b	workaround_el0_serror_a32
 1102f80:	14000000 	b	1102f80 <workaround_el0_serror_a32>

0000000001102f84 <eret_to_el0>:
 */
eret_to_el0:

#ifdef CFG_CORE_UNMAP_CORE_AT_EL0
	/* Point to the vector into the reduced mapping */
	adr_l	x0, thread_user_kcode_offset
 1102f84:	f0000320 	adrp	x0, 1169000 <threads+0x540>
 1102f88:	91274000 	add	x0, x0, #0x9d0
	ldr	x0, [x0]
 1102f8c:	f9400000 	ldr	x0, [x0]
	mrs	x1, vbar_el1
 1102f90:	d538c001 	mrs	x1, vbar_el1
	sub	x1, x1, x0
 1102f94:	cb000021 	sub	x1, x1, x0
	msr	vbar_el1, x1
 1102f98:	d518c001 	msr	vbar_el1, x1
	isb
 1102f9c:	d5033fdf 	isb

#ifdef CFG_CORE_WORKAROUND_SPECTRE_BP_SEC
	/* Store the SP offset in tpidr_el1 to be used below to update SP */
	adr_l	x1, thread_user_kdata_sp_offset
 1102fa0:	f0000321 	adrp	x1, 1169000 <threads+0x540>
 1102fa4:	91230021 	add	x1, x1, #0x8c0
	ldr	x1, [x1]
 1102fa8:	f9400021 	ldr	x1, [x1]
	msr	tpidr_el1, x1
 1102fac:	d518d081 	msr	tpidr_el1, x1
#endif

	/* Jump into the reduced mapping and continue execution */
	ldr	x1, =1f
 1102fb0:	58000841 	ldr	x1, 11030b8 <icache_inv_user_range+0xc8>
	sub	x1, x1, x0
 1102fb4:	cb000021 	sub	x1, x1, x0
	br	x1
 1102fb8:	d61f0020 	br	x1
1:

	load_xregs sp, THREAD_CORE_LOCAL_X0, 0, 1
 1102fbc:	a94007e0 	ldp	x0, x1, [sp]
	msr	tpidrro_el0, x0
 1102fc0:	d51bd060 	msr	tpidrro_el0, x0

	/* Update the mapping to exclude the full kernel mapping */
	mrs	x0, ttbr0_el1
 1102fc4:	d5382000 	mrs	x0, ttbr0_el1
	add	x0, x0, #CORE_MMU_L1_TBL_OFFSET
 1102fc8:	91020000 	add	x0, x0, #0x80
	orr	x0, x0, #BIT(TTBR_ASID_SHIFT) /* switch to user mode ASID */
 1102fcc:	b2500000 	orr	x0, x0, #0x1000000000000
	msr	ttbr0_el1, x0
 1102fd0:	d5182000 	msr	ttbr0_el1, x0
	isb
 1102fd4:	d5033fdf 	isb
#ifdef CFG_CORE_WORKAROUND_SPECTRE_BP_SEC
	/*
	 * Update the SP with thread_user_kdata_sp_offset as described in
	 * init_user_kcode().
	 */
	mrs	x0, tpidr_el1
 1102fd8:	d538d080 	mrs	x0, tpidr_el1
	sub	sp, sp, x0
 1102fdc:	cb2063ff 	sub	sp, sp, x0
#endif

	mrs	x0, tpidrro_el0
 1102fe0:	d53bd060 	mrs	x0, tpidrro_el0
	msr	ttbr0_el1, x0
	isb
	load_xregs sp, THREAD_CORE_LOCAL_X0, 0, 1
#endif /*CFG_CORE_UNMAP_CORE_AT_EL0*/

	return_from_exception
 1102fe4:	d69f03e0 	eret
 1102fe8:	d503379f 	dsb	nsh
 1102fec:	d5033fdf 	isb

0000000001102ff0 <icache_inv_user_range>:
	 */
	.global icache_inv_user_range
	.type icache_inv_user_range , %function
icache_inv_user_range:
	/* Mask all exceptions */
	mrs	x6, daif	/* this register must be preserved */
 1102ff0:	d53b4226 	mrs	x6, daif
	msr	daifset, #DAIFBIT_ALL
 1102ff4:	d5034fdf 	msr	daifset, #0xf

#ifdef CFG_CORE_UNMAP_CORE_AT_EL0
	/* Point to the vector into the reduced mapping */
	adr_l	x2, thread_user_kcode_offset
 1102ff8:	f0000322 	adrp	x2, 1169000 <threads+0x540>
 1102ffc:	91274042 	add	x2, x2, #0x9d0
	ldr	x2, [x2]
 1103000:	f9400042 	ldr	x2, [x2]
	mrs	x4, vbar_el1	/* this register must be preserved */
 1103004:	d538c004 	mrs	x4, vbar_el1
	sub	x3, x4, x2
 1103008:	cb020083 	sub	x3, x4, x2
	msr	vbar_el1, x3
 110300c:	d518c003 	msr	vbar_el1, x3
	isb
 1103010:	d5033fdf 	isb

	/* Jump into the reduced mapping and continue execution */
	ldr	x3, =1f
 1103014:	58000563 	ldr	x3, 11030c0 <icache_inv_user_range+0xd0>
	sub	x3, x3, x2
 1103018:	cb020063 	sub	x3, x3, x2
	br	x3
 110301c:	d61f0060 	br	x3
1:

	/* Update the mapping to exclude the full kernel mapping */
	mrs	x5, ttbr0_el1	/* this register must be preserved */
 1103020:	d5382005 	mrs	x5, ttbr0_el1
	add	x2, x5, #CORE_MMU_L1_TBL_OFFSET
 1103024:	910200a2 	add	x2, x5, #0x80
	orr	x2, x2, #BIT(TTBR_ASID_SHIFT) /* switch to user mode ASID */
 1103028:	b2500042 	orr	x2, x2, #0x1000000000000
	msr	ttbr0_el1, x2
 110302c:	d5182002 	msr	ttbr0_el1, x2
	isb
 1103030:	d5033fdf 	isb
	/*
	 * Do the actual icache invalidation
	 */

	/* Calculate minimum icache line size, result in x2 */
	mrs	x3, ctr_el0
 1103034:	d53b0023 	mrs	x3, ctr_el0
	and	x3, x3, #CTR_IMINLINE_MASK
 1103038:	92400c63 	and	x3, x3, #0xf
	mov	x2, #CTR_WORD_SIZE
 110303c:	d2800082 	mov	x2, #0x4                   	// #4
	lsl	x2, x2, x3
 1103040:	9ac32042 	lsl	x2, x2, x3

	add	x1, x0, x1
 1103044:	8b010001 	add	x1, x0, x1
	sub	x3, x2, #1
 1103048:	d1000443 	sub	x3, x2, #0x1
	bic	x0, x0, x3
 110304c:	8a230000 	bic	x0, x0, x3
1:
	ic	ivau, x0
 1103050:	d50b7520 	ic	ivau, x0
	add	x0, x0, x2
 1103054:	8b020000 	add	x0, x0, x2
	cmp	x0, x1
 1103058:	eb01001f 	cmp	x0, x1
	b.lo    1b
 110305c:	54ffffa3 	b.cc	1103050 <icache_inv_user_range+0x60>  // b.lo, b.ul, b.last
	dsb	ish
 1103060:	d5033b9f 	dsb	ish

#ifdef CFG_CORE_UNMAP_CORE_AT_EL0
	/* Update the mapping to use the full kernel mapping and ASID */
	msr	ttbr0_el1, x5
 1103064:	d5182005 	msr	ttbr0_el1, x5
	isb
 1103068:	d5033fdf 	isb

	/* Jump into the full mapping and continue execution */
	ldr	x0, =1f
 110306c:	580002e0 	ldr	x0, 11030c8 <icache_inv_user_range+0xd8>
	br	x0
 1103070:	d61f0000 	br	x0
1:

	/* Point to the vector into the full mapping */
	msr	vbar_el1, x4
 1103074:	d518c004 	msr	vbar_el1, x4
	isb
 1103078:	d5033fdf 	isb
	/* switch to kernel mode ASID */
	msr	ttbr0_el1, x5
	isb
#endif /*CFG_CORE_UNMAP_CORE_AT_EL0*/

	msr	daif, x6	/* restore exceptions */
 110307c:	d51b4226 	msr	daif, x6
	ret	/* End of icache_inv_user_range() */
 1103080:	d65f03c0 	ret
 1103084:	00000000 	.inst	0x00000000 ; undefined
 1103088:	01102424 	.word	0x01102424
 110308c:	00000000 	.word	0x00000000
 1103090:	011024a4 	.word	0x011024a4
 1103094:	00000000 	.word	0x00000000
 1103098:	01102524 	.word	0x01102524
 110309c:	00000000 	.word	0x00000000
 11030a0:	01102624 	.word	0x01102624
 11030a4:	00000000 	.word	0x00000000
 11030a8:	011026a4 	.word	0x011026a4
 11030ac:	00000000 	.word	0x00000000
 11030b0:	01102724 	.word	0x01102724
 11030b4:	00000000 	.word	0x00000000
 11030b8:	01102fbc 	.word	0x01102fbc
 11030bc:	00000000 	.word	0x00000000
 11030c0:	01103020 	.word	0x01103020
 11030c4:	00000000 	.word	0x00000000
 11030c8:	01103074 	.word	0x01103074
 11030cc:	00000000 	.word	0x00000000

00000000011030d0 <__thread_enter_user_mode>:
	sub	sp, sp, #THREAD_USER_MODE_REC_SIZE
 11030d0:	d10203ff 	sub	sp, sp, #0x80
	store_xregs sp, THREAD_USER_MODE_REC_CTX_REGS_PTR, 0, 2
 11030d4:	a90007e0 	stp	x0, x1, [sp]
 11030d8:	f9000be2 	str	x2, [sp, #16]
	store_xregs sp, THREAD_USER_MODE_REC_X19, 19, 30
 11030dc:	a90253f3 	stp	x19, x20, [sp, #32]
 11030e0:	a9035bf5 	stp	x21, x22, [sp, #48]
 11030e4:	a90463f7 	stp	x23, x24, [sp, #64]
 11030e8:	a9056bf9 	stp	x25, x26, [sp, #80]
 11030ec:	a90673fb 	stp	x27, x28, [sp, #96]
 11030f0:	a9077bfd 	stp	x29, x30, [sp, #112]
	mov	x19, sp
 11030f4:	910003f3 	mov	x19, sp
	msr	spsel, #1
 11030f8:	d50041bf 	msr	spsel, #0x1
	get_thread_ctx sp, 21, 20, 22
 11030fc:	794053f4 	ldrh	w20, [sp, #40]
 1103100:	58000395 	ldr	x21, 1103170 <__thread_enter_user_mode+0xa0>
 1103104:	d280e016 	mov	x22, #0x700                 	// #1792
 1103108:	9b165695 	madd	x21, x20, x22, x21
	str	x19, [x21, #THREAD_CTX_KERN_SP]
 110310c:	f900a6b3 	str	x19, [x21, #328]
	load_xregs x0, THREAD_CTX_REGS_SP, 1, 3
 1103110:	a9400801 	ldp	x1, x2, [x0]
 1103114:	f9400803 	ldr	x3, [x0, #16]
	msr	sp_el0, x1
 1103118:	d5184101 	msr	sp_el0, x1
	msr	elr_el1, x2
 110311c:	d5184022 	msr	elr_el1, x2
	msr	spsr_el1, x3
 1103120:	d5184003 	msr	spsr_el1, x3
	load_xregs x0, THREAD_CTX_REGS_X0, 1, 2
 1103124:	a9418801 	ldp	x1, x2, [x0, #24]
	store_xregs sp, THREAD_CORE_LOCAL_X0, 1, 2
 1103128:	a9000be1 	stp	x1, x2, [sp]
	load_xregs x0, THREAD_CTX_REGS_X2, 2, 30
 110312c:	a9428c02 	ldp	x2, x3, [x0, #40]
 1103130:	a9439404 	ldp	x4, x5, [x0, #56]
 1103134:	a9449c06 	ldp	x6, x7, [x0, #72]
 1103138:	a945a408 	ldp	x8, x9, [x0, #88]
 110313c:	a946ac0a 	ldp	x10, x11, [x0, #104]
 1103140:	a947b40c 	ldp	x12, x13, [x0, #120]
 1103144:	a948bc0e 	ldp	x14, x15, [x0, #136]
 1103148:	a949c410 	ldp	x16, x17, [x0, #152]
 110314c:	a94acc12 	ldp	x18, x19, [x0, #168]
 1103150:	a94bd414 	ldp	x20, x21, [x0, #184]
 1103154:	a94cdc16 	ldp	x22, x23, [x0, #200]
 1103158:	a94de418 	ldp	x24, x25, [x0, #216]
 110315c:	a94eec1a 	ldp	x26, x27, [x0, #232]
 1103160:	a94ff41c 	ldp	x28, x29, [x0, #248]
 1103164:	f940841e 	ldr	x30, [x0, #264]
	b eret_to_el0
 1103168:	17ffff87 	b	1102f84 <eret_to_el0>
 110316c:	00000000 	.inst	0x00000000 ; undefined
 1103170:	01168ac0 	.word	0x01168ac0
 1103174:	00000000 	.word	0x00000000

0000000001103178 <el0_svc>:
thread_excp_vect_end:
END_FUNC thread_excp_vect

LOCAL_FUNC el0_svc , :
	/* get pointer to current thread context in x0 */
	get_thread_ctx sp, 0, 1, 2
 1103178:	794053e1 	ldrh	w1, [sp, #40]
 110317c:	58000820 	ldr	x0, 1103280 <el0_svc+0x108>
 1103180:	d280e002 	mov	x2, #0x700                 	// #1792
 1103184:	9b020020 	madd	x0, x1, x2, x0
	mrs	x1, tpidr_el0
 1103188:	d53bd041 	mrs	x1, tpidr_el0
	str	x1, [x0, #THREAD_CTX_REGS_TPIDR_EL0]
 110318c:	f9008801 	str	x1, [x0, #272]
	/* load saved kernel sp */
	ldr	x0, [x0, #THREAD_CTX_KERN_SP]
 1103190:	f940a400 	ldr	x0, [x0, #328]
	/* Keep pointer to initial recod in x1 */
	mov	x1, sp
 1103194:	910003e1 	mov	x1, sp
	/* Switch to SP_EL0 and restore kernel sp */
	msr	spsel, #0
 1103198:	d50040bf 	msr	spsel, #0x0
	mov	x2, sp	/* Save SP_EL0 */
 110319c:	910003e2 	mov	x2, sp
	mov	sp, x0
 11031a0:	9100001f 	mov	sp, x0

	/* Make room for struct thread_svc_regs */
	sub	sp, sp, #THREAD_SVC_REG_SIZE
 11031a4:	d10283ff 	sub	sp, sp, #0xa0
	stp	x30,x2, [sp, #THREAD_SVC_REG_X30]
 11031a8:	a9088bfe 	stp	x30, x2, [sp, #136]

	/* Restore x0-x3 */
	ldp	x2, x3, [x1, #THREAD_CORE_LOCAL_X2]
 11031ac:	a9410c22 	ldp	x2, x3, [x1, #16]
	ldp	x0, x1, [x1, #THREAD_CORE_LOCAL_X0]
 11031b0:	a9400420 	ldp	x0, x1, [x1]

	/* Prepare the argument for the handler */
	store_xregs sp, THREAD_SVC_REG_X0, 0, 14
 11031b4:	a90107e0 	stp	x0, x1, [sp, #16]
 11031b8:	a9020fe2 	stp	x2, x3, [sp, #32]
 11031bc:	a90317e4 	stp	x4, x5, [sp, #48]
 11031c0:	a9041fe6 	stp	x6, x7, [sp, #64]
 11031c4:	a90527e8 	stp	x8, x9, [sp, #80]
 11031c8:	a9062fea 	stp	x10, x11, [sp, #96]
 11031cc:	a90737ec 	stp	x12, x13, [sp, #112]
 11031d0:	f90043ee 	str	x14, [sp, #128]
	mrs	x0, elr_el1
 11031d4:	d5384020 	mrs	x0, elr_el1
	mrs	x1, spsr_el1
 11031d8:	d5384001 	mrs	x1, spsr_el1
	store_xregs sp, THREAD_SVC_REG_ELR, 0, 1
 11031dc:	a90007e0 	stp	x0, x1, [sp]
	mov	x0, sp
 11031e0:	910003e0 	mov	x0, sp
	 * re-enable foreign interrupts by itself.
	 */
#if defined(CFG_ARM_GICV3)
	msr	daifclr, #(DAIFBIT_IRQ | DAIFBIT_ABT | DAIFBIT_DBG)
#else
	msr	daifclr, #(DAIFBIT_FIQ | DAIFBIT_ABT | DAIFBIT_DBG)
 11031e4:	d5034dff 	msr	daifclr, #0xd
#endif

	/* Call the handler */
	bl	thread_svc_handler
 11031e8:	94000c57 	bl	1106344 <thread_svc_handler>

	/* Mask all maskable exceptions since we're switching back to sp_el1 */
	msr	daifset, #DAIFBIT_ALL
 11031ec:	d5034fdf 	msr	daifset, #0xf
	 * Save kernel sp we'll had at the beginning of this function.
	 * This is when this TA has called another TA because
	 * __thread_enter_user_mode() also saves the stack pointer in this
	 * field.
	 */
	msr	spsel, #1
 11031f0:	d50041bf 	msr	spsel, #0x1
	get_thread_ctx sp, 0, 1, 2
 11031f4:	794053e1 	ldrh	w1, [sp, #40]
 11031f8:	58000440 	ldr	x0, 1103280 <el0_svc+0x108>
 11031fc:	d280e002 	mov	x2, #0x700                 	// #1792
 1103200:	9b020020 	madd	x0, x1, x2, x0
	msr	spsel, #0
 1103204:	d50040bf 	msr	spsel, #0x0
	add	x1, sp, #THREAD_SVC_REG_SIZE
 1103208:	910283e1 	add	x1, sp, #0xa0
	str	x1, [x0, #THREAD_CTX_KERN_SP]
 110320c:	f900a401 	str	x1, [x0, #328]

	/* Restore registers to the required state and return*/
	ldr	x1, [x0, #THREAD_CTX_REGS_TPIDR_EL0]
 1103210:	f9408801 	ldr	x1, [x0, #272]
	msr	tpidr_el0, x1
 1103214:	d51bd041 	msr	tpidr_el0, x1
	load_xregs sp, THREAD_SVC_REG_ELR, 0, 1
 1103218:	a94007e0 	ldp	x0, x1, [sp]
	msr	elr_el1, x0
 110321c:	d5184020 	msr	elr_el1, x0
	msr	spsr_el1, x1
 1103220:	d5184001 	msr	spsr_el1, x1
	load_xregs sp, THREAD_SVC_REG_X2, 2, 14
 1103224:	a9420fe2 	ldp	x2, x3, [sp, #32]
 1103228:	a94317e4 	ldp	x4, x5, [sp, #48]
 110322c:	a9441fe6 	ldp	x6, x7, [sp, #64]
 1103230:	a94527e8 	ldp	x8, x9, [sp, #80]
 1103234:	a9462fea 	ldp	x10, x11, [sp, #96]
 1103238:	a94737ec 	ldp	x12, x13, [sp, #112]
 110323c:	f94043ee 	ldr	x14, [sp, #128]
	mov	x30, sp
 1103240:	910003fe 	mov	x30, sp
	ldr	x0, [x30, #THREAD_SVC_REG_SP_EL0]
 1103244:	f9404bc0 	ldr	x0, [x30, #144]
	mov	sp, x0
 1103248:	9100001f 	mov	sp, x0
	b_if_spsr_is_el0 w1, 1f
 110324c:	37800101 	tbnz	w1, #16, 110326c <el0_svc+0xf4>
 1103250:	721e043f 	tst	w1, #0xc
 1103254:	540000c0 	b.eq	110326c <el0_svc+0xf4>  // b.none
	ldp	x0, x1, [x30, THREAD_SVC_REG_X0]
 1103258:	a94107c0 	ldp	x0, x1, [x30, #16]
	ldr	x30, [x30, #THREAD_SVC_REG_X30]
 110325c:	f94047de 	ldr	x30, [x30, #136]

	return_from_exception
 1103260:	d69f03e0 	eret
 1103264:	d503379f 	dsb	nsh
 1103268:	d5033fdf 	isb

1:	ldp	x0, x1, [x30, THREAD_SVC_REG_X0]
 110326c:	a94107c0 	ldp	x0, x1, [x30, #16]
	ldr	x30, [x30, #THREAD_SVC_REG_X30]
 1103270:	f94047de 	ldr	x30, [x30, #136]

	msr	spsel, #1
 1103274:	d50041bf 	msr	spsel, #0x1
	store_xregs sp, THREAD_CORE_LOCAL_X0, 0, 1
 1103278:	a90007e0 	stp	x0, x1, [sp]
	b	eret_to_el0
 110327c:	17ffff42 	b	1102f84 <eret_to_el0>
 1103280:	01168ac0 	.word	0x01168ac0
 1103284:	00000000 	.word	0x00000000

0000000001103288 <elx_irq>:

LOCAL_FUNC elx_irq , :
#if defined(CFG_ARM_GICV3)
	native_intr_handler	irq
#else
	foreign_intr_handler	irq
 1103288:	b9402fe1 	ldr	w1, [sp, #44]
 110328c:	531c6c21 	lsl	w1, w1, #4
 1103290:	32000021 	orr	w1, w1, #0x1
 1103294:	321e0021 	orr	w1, w1, #0x4
 1103298:	b9002fe1 	str	w1, [sp, #44]
 110329c:	794053e1 	ldrh	w1, [sp, #40]
 11032a0:	58000540 	ldr	x0, 1103348 <elx_irq+0xc0>
 11032a4:	d280e002 	mov	x2, #0x700                 	// #1792
 11032a8:	9b020020 	madd	x0, x1, x2, x0
 11032ac:	d5384102 	mrs	x2, sp_el0
 11032b0:	f9000002 	str	x2, [x0]
 11032b4:	d53bd042 	mrs	x2, tpidr_el0
 11032b8:	f9008802 	str	x2, [x0, #272]
 11032bc:	a9039404 	stp	x4, x5, [x0, #56]
 11032c0:	a9049c06 	stp	x6, x7, [x0, #72]
 11032c4:	a905a408 	stp	x8, x9, [x0, #88]
 11032c8:	a906ac0a 	stp	x10, x11, [x0, #104]
 11032cc:	a907b40c 	stp	x12, x13, [x0, #120]
 11032d0:	a908bc0e 	stp	x14, x15, [x0, #136]
 11032d4:	a909c410 	stp	x16, x17, [x0, #152]
 11032d8:	a90acc12 	stp	x18, x19, [x0, #168]
 11032dc:	a90bd414 	stp	x20, x21, [x0, #184]
 11032e0:	a90cdc16 	stp	x22, x23, [x0, #200]
 11032e4:	a90de418 	stp	x24, x25, [x0, #216]
 11032e8:	a90eec1a 	stp	x26, x27, [x0, #232]
 11032ec:	a90ff41c 	stp	x28, x29, [x0, #248]
 11032f0:	f900841e 	str	x30, [x0, #264]
 11032f4:	a9402fea 	ldp	x10, x11, [sp]
 11032f8:	a94137ec 	ldp	x12, x13, [sp, #16]
 11032fc:	a901ac0a 	stp	x10, x11, [x0, #24]
 1103300:	a902b40c 	stp	x12, x13, [x0, #40]
 1103304:	f94013e1 	ldr	x1, [sp, #32]
 1103308:	d50040bf 	msr	spsel, #0x0
 110330c:	9100003f 	mov	sp, x1
 1103310:	d2800020 	mov	x0, #0x1                   	// #1
 1103314:	94000508 	bl	1104734 <dcache_op_louis>
 1103318:	d508751f 	ic	iallu
 110331c:	52800080 	mov	w0, #0x4                   	// #4
 1103320:	d5384001 	mrs	x1, spsr_el1
 1103324:	d5384022 	mrs	x2, elr_el1
 1103328:	94000b3e 	bl	1106020 <thread_state_suspend>
 110332c:	d50041bf 	msr	spsel, #0x1
 1103330:	b9402fe1 	ldr	w1, [sp, #44]
 1103334:	53047c21 	lsr	w1, w1, #4
 1103338:	32000021 	orr	w1, w1, #0x1
 110333c:	b9002fe1 	str	w1, [sp, #44]
 1103340:	d50040bf 	msr	spsel, #0x0
 1103344:	14000f92 	b	110718c <thread_foreign_intr_exit>
 1103348:	01168ac0 	.word	0x01168ac0
 110334c:	00000000 	.word	0x00000000

0000000001103350 <thread_std_smc_entry>:
END_FUNC thread_vector_table
DECLARE_KEEP_PAGER thread_vector_table

FUNC thread_std_smc_entry , :
	bl	__thread_std_smc_entry
 1103350:	94000e34 	bl	1106c20 <__thread_std_smc_entry>
	mov	w20, w0	/* Save return value for later */
 1103354:	2a0003f4 	mov	w20, w0

	/* Mask all maskable exceptions before switching to temporary stack */
	msr	daifset, #DAIFBIT_ALL
 1103358:	d5034fdf 	msr	daifset, #0xf
	bl	thread_get_tmp_sp
 110335c:	940007af 	bl	1105218 <thread_get_tmp_sp>
	mov	sp, x0
 1103360:	9100001f 	mov	sp, x0

	bl	thread_state_free
 1103364:	94000922 	bl	11057ec <thread_state_free>

	ldr	x0, =TEESMC_OPTEED_RETURN_CALL_DONE
 1103368:	58000100 	ldr	x0, 1103388 <thread_std_smc_entry+0x38>
	mov	w1, w20
 110336c:	2a1403e1 	mov	w1, w20
	mov	x2, #0
 1103370:	d2800002 	mov	x2, #0x0                   	// #0
	mov	x3, #0
 1103374:	d2800003 	mov	x3, #0x0                   	// #0
	mov	x4, #0
 1103378:	d2800004 	mov	x4, #0x0                   	// #0
	smc	#0
 110337c:	d4000003 	smc	#0x0
	b	.	/* SMC should not return */
 1103380:	14000000 	b	1103380 <thread_std_smc_entry+0x30>
 1103384:	00000000 	.inst	0x00000000 ; undefined
 1103388:	be000005 	.word	0xbe000005
 110338c:	00000000 	.word	0x00000000

0000000001103390 <memcpy>:
	long *aligned_dst;
	_CONST long *aligned_src;

	/* If the size is small, or either SRC or DST is unaligned,
	   then punt into the byte copy loop.  This should be rare.  */
	if (!TOO_SMALL(len0) && !UNALIGNED(src, dst)) {
 1103390:	f1007c5f 	cmp	x2, #0x1f
 1103394:	54000629 	b.ls	1103458 <memcpy+0xc8>  // b.plast
 1103398:	aa000025 	orr	x5, x1, x0
 110339c:	f24008a5 	ands	x5, x5, #0x7
 11033a0:	54000641 	b.ne	1103468 <memcpy+0xd8>  // b.any
 11033a4:	d1008048 	sub	x8, x2, #0x20
		aligned_dst = (long *)dst;
		aligned_src = (long *)src;
 11033a8:	aa0103e4 	mov	x4, x1
 11033ac:	927be908 	and	x8, x8, #0xffffffffffffffe0
		aligned_dst = (long *)dst;
 11033b0:	aa0003e3 	mov	x3, x0
 11033b4:	91008108 	add	x8, x8, #0x20
 11033b8:	8b080007 	add	x7, x0, x8
 11033bc:	d503201f 	nop

		/* Copy 4X long words at a time if possible.  */
		while (len0 >= BIGBLOCKSIZE) {
			*aligned_dst++ = *aligned_src++;
 11033c0:	f9400086 	ldr	x6, [x4]
 11033c4:	f9000066 	str	x6, [x3]
			*aligned_dst++ = *aligned_src++;
 11033c8:	91008084 	add	x4, x4, #0x20
 11033cc:	91008063 	add	x3, x3, #0x20
 11033d0:	f85e8086 	ldur	x6, [x4, #-24]
 11033d4:	f81e8066 	stur	x6, [x3, #-24]
			*aligned_dst++ = *aligned_src++;
 11033d8:	f85f0086 	ldur	x6, [x4, #-16]
 11033dc:	f81f0066 	stur	x6, [x3, #-16]
		while (len0 >= BIGBLOCKSIZE) {
 11033e0:	eb0300ff 	cmp	x7, x3
			*aligned_dst++ = *aligned_src++;
 11033e4:	f85f8086 	ldur	x6, [x4, #-8]
 11033e8:	f81f8066 	stur	x6, [x3, #-8]
		while (len0 >= BIGBLOCKSIZE) {
 11033ec:	54fffea1 	b.ne	11033c0 <memcpy+0x30>  // b.any
 11033f0:	8b080021 	add	x1, x1, x8
			len0 -= BIGBLOCKSIZE;
		}

		/* Copy one long word at a time if possible.  */
		while (len0 >= LITTLEBLOCKSIZE) {
 11033f4:	f27d045f 	tst	x2, #0x18
 11033f8:	92401044 	and	x4, x2, #0x1f
 11033fc:	540003c0 	b.eq	1103474 <memcpy+0xe4>  // b.none
			*aligned_dst++ = *aligned_src++;
 1103400:	f8656826 	ldr	x6, [x1, x5]
 1103404:	f8256866 	str	x6, [x3, x5]
		while (len0 >= LITTLEBLOCKSIZE) {
 1103408:	910020a5 	add	x5, x5, #0x8
 110340c:	cb050086 	sub	x6, x4, x5
 1103410:	f1001cdf 	cmp	x6, #0x7
 1103414:	54ffff68 	b.hi	1103400 <memcpy+0x70>  // b.pmore
 1103418:	d1002084 	sub	x4, x4, #0x8
 110341c:	92400842 	and	x2, x2, #0x7
 1103420:	927df084 	and	x4, x4, #0xfffffffffffffff8
		/* Pick up any residual with a byte copier.  */
		dst = (char *)aligned_dst;
		src = (char *)aligned_src;
	}

	while (len0--)
 1103424:	d1000446 	sub	x6, x2, #0x1
 1103428:	91002084 	add	x4, x4, #0x8
 110342c:	8b040063 	add	x3, x3, x4
 1103430:	8b040021 	add	x1, x1, x4
 1103434:	b4000102 	cbz	x2, 1103454 <memcpy+0xc4>
	char *dst = dst0;
 1103438:	d2800002 	mov	x2, #0x0                   	// #0
 110343c:	d503201f 	nop
		*dst++ = *src++;
 1103440:	38626825 	ldrb	w5, [x1, x2]
	while (len0--)
 1103444:	eb0200df 	cmp	x6, x2
		*dst++ = *src++;
 1103448:	38226865 	strb	w5, [x3, x2]
	while (len0--)
 110344c:	91000442 	add	x2, x2, #0x1
 1103450:	54ffff81 	b.ne	1103440 <memcpy+0xb0>  // b.any

	return dst0;
#endif /* not PREFER_SIZE_OVER_SPEED */
}
 1103454:	d65f03c0 	ret
	char *dst = dst0;
 1103458:	aa0003e3 	mov	x3, x0
	while (len0--)
 110345c:	d1000446 	sub	x6, x2, #0x1
 1103460:	b5fffec2 	cbnz	x2, 1103438 <memcpy+0xa8>
}
 1103464:	d65f03c0 	ret
	while (len0--)
 1103468:	d1000446 	sub	x6, x2, #0x1
	char *dst = dst0;
 110346c:	aa0003e3 	mov	x3, x0
 1103470:	17fffff2 	b	1103438 <memcpy+0xa8>
		while (len0 >= LITTLEBLOCKSIZE) {
 1103474:	aa0403e2 	mov	x2, x4
 1103478:	17fffff9 	b	110345c <memcpy+0xcc>
 110347c:	00000000 	.inst	0x00000000 ; undefined

0000000001103480 <__udivti3>:
 1103480:	aa0203e4 	mov	x4, x2
 1103484:	aa0003e5 	mov	x5, x0
 1103488:	aa0103e6 	mov	x6, x1
 110348c:	b50004e3 	cbnz	x3, 1103528 <__udivti3+0xa8>
 1103490:	eb01005f 	cmp	x2, x1
 1103494:	54000d49 	b.ls	110363c <__udivti3+0x1bc>  // b.plast
 1103498:	dac01040 	clz	x0, x2
 110349c:	b40000e0 	cbz	x0, 11034b8 <__udivti3+0x38>
 11034a0:	4b0003e1 	neg	w1, w0
 11034a4:	9ac020c2 	lsl	x2, x6, x0
 11034a8:	9ac02084 	lsl	x4, x4, x0
 11034ac:	9ac124a6 	lsr	x6, x5, x1
 11034b0:	aa0200c6 	orr	x6, x6, x2
 11034b4:	9ac020a5 	lsl	x5, x5, x0
 11034b8:	d360fc83 	lsr	x3, x4, #32
 11034bc:	92407c87 	and	x7, x4, #0xffffffff
 11034c0:	9ac308c2 	udiv	x2, x6, x3
 11034c4:	aa0203e0 	mov	x0, x2
 11034c8:	9b039842 	msub	x2, x2, x3, x6
 11034cc:	9b007ce6 	mul	x6, x7, x0
 11034d0:	93c58041 	extr	x1, x2, x5, #32
 11034d4:	eb0100df 	cmp	x6, x1
 11034d8:	540000a9 	b.ls	11034ec <__udivti3+0x6c>  // b.plast
 11034dc:	ab010081 	adds	x1, x4, x1
 11034e0:	fa4130c0 	ccmp	x6, x1, #0x0, cc  // cc = lo, ul, last
 11034e4:	54001648 	b.hi	11037ac <__udivti3+0x32c>  // b.pmore
 11034e8:	d1000400 	sub	x0, x0, #0x1
 11034ec:	cb060021 	sub	x1, x1, x6
 11034f0:	9ac30826 	udiv	x6, x1, x3
 11034f4:	9b0384c1 	msub	x1, x6, x3, x1
 11034f8:	aa0603e2 	mov	x2, x6
 11034fc:	9b067ce7 	mul	x7, x7, x6
 1103500:	b3607c25 	bfi	x5, x1, #32, #32
 1103504:	eb0500ff 	cmp	x7, x5
 1103508:	540000a9 	b.ls	110351c <__udivti3+0x9c>  // b.plast
 110350c:	ab050085 	adds	x5, x4, x5
 1103510:	fa4530e0 	ccmp	x7, x5, #0x0, cc  // cc = lo, ul, last
 1103514:	9a8684c2 	cinc	x2, x6, ls  // ls = plast
 1103518:	d1000842 	sub	x2, x2, #0x2
 110351c:	aa008040 	orr	x0, x2, x0, lsl #32
 1103520:	d2800001 	mov	x1, #0x0                   	// #0
 1103524:	d65f03c0 	ret
 1103528:	eb01007f 	cmp	x3, x1
 110352c:	54000089 	b.ls	110353c <__udivti3+0xbc>  // b.plast
 1103530:	d2800001 	mov	x1, #0x0                   	// #0
 1103534:	d2800000 	mov	x0, #0x0                   	// #0
 1103538:	d65f03c0 	ret
 110353c:	dac01067 	clz	x7, x3
 1103540:	b40010a7 	cbz	x7, 1103754 <__udivti3+0x2d4>
 1103544:	d2800804 	mov	x4, #0x40                  	// #64
 1103548:	cb070084 	sub	x4, x4, x7
 110354c:	9ac72063 	lsl	x3, x3, x7
 1103550:	9ac42445 	lsr	x5, x2, x4
 1103554:	aa0300a3 	orr	x3, x5, x3
 1103558:	9ac42426 	lsr	x6, x1, x4
 110355c:	92407c68 	and	x8, x3, #0xffffffff
 1103560:	d360fc6a 	lsr	x10, x3, #32
 1103564:	9ac42404 	lsr	x4, x0, x4
 1103568:	9ac72021 	lsl	x1, x1, x7
 110356c:	aa010081 	orr	x1, x4, x1
 1103570:	9ac72042 	lsl	x2, x2, x7
 1103574:	9aca08c5 	udiv	x5, x6, x10
 1103578:	aa0503e4 	mov	x4, x5
 110357c:	9b0a98a5 	msub	x5, x5, x10, x6
 1103580:	9b047d06 	mul	x6, x8, x4
 1103584:	93c180a5 	extr	x5, x5, x1, #32
 1103588:	eb0500df 	cmp	x6, x5
 110358c:	540000a9 	b.ls	11035a0 <__udivti3+0x120>  // b.plast
 1103590:	ab050065 	adds	x5, x3, x5
 1103594:	fa4530c0 	ccmp	x6, x5, #0x0, cc  // cc = lo, ul, last
 1103598:	54000fe8 	b.hi	1103794 <__udivti3+0x314>  // b.pmore
 110359c:	d1000484 	sub	x4, x4, #0x1
 11035a0:	cb0600a6 	sub	x6, x5, x6
 11035a4:	9aca08c9 	udiv	x9, x6, x10
 11035a8:	9b0a9926 	msub	x6, x9, x10, x6
 11035ac:	aa0903e5 	mov	x5, x9
 11035b0:	9b097d08 	mul	x8, x8, x9
 11035b4:	b3607cc1 	bfi	x1, x6, #32, #32
 11035b8:	eb01011f 	cmp	x8, x1
 11035bc:	540000a9 	b.ls	11035d0 <__udivti3+0x150>  // b.plast
 11035c0:	ab010061 	adds	x1, x3, x1
 11035c4:	fa413100 	ccmp	x8, x1, #0x0, cc  // cc = lo, ul, last
 11035c8:	54000da8 	b.hi	110377c <__udivti3+0x2fc>  // b.pmore
 11035cc:	d1000525 	sub	x5, x9, #0x1
 11035d0:	aa0480a4 	orr	x4, x5, x4, lsl #32
 11035d4:	92407c49 	and	x9, x2, #0xffffffff
 11035d8:	2a0503e5 	mov	w5, w5
 11035dc:	d360fc42 	lsr	x2, x2, #32
 11035e0:	d360fc86 	lsr	x6, x4, #32
 11035e4:	cb080021 	sub	x1, x1, x8
 11035e8:	d2c0002a 	mov	x10, #0x100000000           	// #4294967296
 11035ec:	9b097cab 	mul	x11, x5, x9
 11035f0:	9b097cc8 	mul	x8, x6, x9
 11035f4:	9b0220a5 	madd	x5, x5, x2, x8
 11035f8:	9b027cc2 	mul	x2, x6, x2
 11035fc:	8b4b80a3 	add	x3, x5, x11, lsr #32
 1103600:	8b0a0045 	add	x5, x2, x10
 1103604:	eb03011f 	cmp	x8, x3
 1103608:	9a8280a2 	csel	x2, x5, x2, hi  // hi = pmore
 110360c:	8b438042 	add	x2, x2, x3, lsr #32
 1103610:	eb02003f 	cmp	x1, x2
 1103614:	540000e3 	b.cc	1103630 <__udivti3+0x1b0>  // b.lo, b.ul, b.last
 1103618:	92407d6b 	and	x11, x11, #0xffffffff
 110361c:	9ac72000 	lsl	x0, x0, x7
 1103620:	8b038163 	add	x3, x11, x3, lsl #32
 1103624:	eb03001f 	cmp	x0, x3
 1103628:	fa423020 	ccmp	x1, x2, #0x0, cc  // cc = lo, ul, last
 110362c:	540009c1 	b.ne	1103764 <__udivti3+0x2e4>  // b.any
 1103630:	d1000480 	sub	x0, x4, #0x1
 1103634:	d2800001 	mov	x1, #0x0                   	// #0
 1103638:	d65f03c0 	ret
 110363c:	b5000062 	cbnz	x2, 1103648 <__udivti3+0x1c8>
 1103640:	d2800022 	mov	x2, #0x1                   	// #1
 1103644:	9ac40844 	udiv	x4, x2, x4
 1103648:	dac01088 	clz	x8, x4
 110364c:	b50003c8 	cbnz	x8, 11036c4 <__udivti3+0x244>
 1103650:	d360fc86 	lsr	x6, x4, #32
 1103654:	92407c87 	and	x7, x4, #0xffffffff
 1103658:	cb040022 	sub	x2, x1, x4
 110365c:	d2800021 	mov	x1, #0x1                   	// #1
 1103660:	9ac60843 	udiv	x3, x2, x6
 1103664:	aa0303e0 	mov	x0, x3
 1103668:	9b068863 	msub	x3, x3, x6, x2
 110366c:	9b077c08 	mul	x8, x0, x7
 1103670:	93c58062 	extr	x2, x3, x5, #32
 1103674:	eb02011f 	cmp	x8, x2
 1103678:	540000a9 	b.ls	110368c <__udivti3+0x20c>  // b.plast
 110367c:	ab020082 	adds	x2, x4, x2
 1103680:	fa423100 	ccmp	x8, x2, #0x0, cc  // cc = lo, ul, last
 1103684:	540008e8 	b.hi	11037a0 <__udivti3+0x320>  // b.pmore
 1103688:	d1000400 	sub	x0, x0, #0x1
 110368c:	cb080042 	sub	x2, x2, x8
 1103690:	9ac60848 	udiv	x8, x2, x6
 1103694:	9b068902 	msub	x2, x8, x6, x2
 1103698:	aa0803e3 	mov	x3, x8
 110369c:	9b077d07 	mul	x7, x8, x7
 11036a0:	b3607c45 	bfi	x5, x2, #32, #32
 11036a4:	eb0500ff 	cmp	x7, x5
 11036a8:	540000a9 	b.ls	11036bc <__udivti3+0x23c>  // b.plast
 11036ac:	ab050084 	adds	x4, x4, x5
 11036b0:	fa4430e0 	ccmp	x7, x4, #0x0, cc  // cc = lo, ul, last
 11036b4:	9a888503 	cinc	x3, x8, ls  // ls = plast
 11036b8:	d1000863 	sub	x3, x3, #0x2
 11036bc:	aa008060 	orr	x0, x3, x0, lsl #32
 11036c0:	d65f03c0 	ret
 11036c4:	9ac82084 	lsl	x4, x4, x8
 11036c8:	d2800803 	mov	x3, #0x40                  	// #64
 11036cc:	cb080063 	sub	x3, x3, x8
 11036d0:	d360fc86 	lsr	x6, x4, #32
 11036d4:	9ac82022 	lsl	x2, x1, x8
 11036d8:	92407c87 	and	x7, x4, #0xffffffff
 11036dc:	9ac32421 	lsr	x1, x1, x3
 11036e0:	9ac32403 	lsr	x3, x0, x3
 11036e4:	aa020063 	orr	x3, x3, x2
 11036e8:	9ac60822 	udiv	x2, x1, x6
 11036ec:	9ac82005 	lsl	x5, x0, x8
 11036f0:	9b068441 	msub	x1, x2, x6, x1
 11036f4:	aa0203e0 	mov	x0, x2
 11036f8:	9b027ce2 	mul	x2, x7, x2
 11036fc:	93c38021 	extr	x1, x1, x3, #32
 1103700:	eb01005f 	cmp	x2, x1
 1103704:	540000a9 	b.ls	1103718 <__udivti3+0x298>  // b.plast
 1103708:	ab010081 	adds	x1, x4, x1
 110370c:	fa413040 	ccmp	x2, x1, #0x0, cc  // cc = lo, ul, last
 1103710:	54000308 	b.hi	1103770 <__udivti3+0x2f0>  // b.pmore
 1103714:	d1000400 	sub	x0, x0, #0x1
 1103718:	cb020021 	sub	x1, x1, x2
 110371c:	9ac60822 	udiv	x2, x1, x6
 1103720:	9b068441 	msub	x1, x2, x6, x1
 1103724:	aa0203e8 	mov	x8, x2
 1103728:	9b027ce2 	mul	x2, x7, x2
 110372c:	b3607c23 	bfi	x3, x1, #32, #32
 1103730:	eb03005f 	cmp	x2, x3
 1103734:	540000a9 	b.ls	1103748 <__udivti3+0x2c8>  // b.plast
 1103738:	ab030083 	adds	x3, x4, x3
 110373c:	fa433040 	ccmp	x2, x3, #0x0, cc  // cc = lo, ul, last
 1103740:	54000248 	b.hi	1103788 <__udivti3+0x308>  // b.pmore
 1103744:	d1000508 	sub	x8, x8, #0x1
 1103748:	cb020062 	sub	x2, x3, x2
 110374c:	aa008101 	orr	x1, x8, x0, lsl #32
 1103750:	17ffffc4 	b	1103660 <__udivti3+0x1e0>
 1103754:	fa402040 	ccmp	x2, x0, #0x0, cs  // cs = hs, nlast
 1103758:	d2800001 	mov	x1, #0x0                   	// #0
 110375c:	9a9f87e0 	cset	x0, ls  // ls = plast
 1103760:	d65f03c0 	ret
 1103764:	aa0403e0 	mov	x0, x4
 1103768:	d2800001 	mov	x1, #0x0                   	// #0
 110376c:	d65f03c0 	ret
 1103770:	d1000800 	sub	x0, x0, #0x2
 1103774:	8b040021 	add	x1, x1, x4
 1103778:	17ffffe8 	b	1103718 <__udivti3+0x298>
 110377c:	d1000925 	sub	x5, x9, #0x2
 1103780:	8b030021 	add	x1, x1, x3
 1103784:	17ffff93 	b	11035d0 <__udivti3+0x150>
 1103788:	d1000908 	sub	x8, x8, #0x2
 110378c:	8b040063 	add	x3, x3, x4
 1103790:	17ffffee 	b	1103748 <__udivti3+0x2c8>
 1103794:	d1000884 	sub	x4, x4, #0x2
 1103798:	8b0300a5 	add	x5, x5, x3
 110379c:	17ffff81 	b	11035a0 <__udivti3+0x120>
 11037a0:	d1000800 	sub	x0, x0, #0x2
 11037a4:	8b040042 	add	x2, x2, x4
 11037a8:	17ffffb9 	b	110368c <__udivti3+0x20c>
 11037ac:	d1000800 	sub	x0, x0, #0x2
 11037b0:	8b040021 	add	x1, x1, x4
 11037b4:	17ffff4e 	b	11034ec <__udivti3+0x6c>

00000000011037b8 <alloc_and_map_ldelf_fobj>:
#endif

static TEE_Result alloc_and_map_ldelf_fobj(struct user_mode_ctx *uctx,
					   size_t sz, uint32_t prot,
					   vaddr_t *va)
{
 11037b8:	d10143ff 	sub	sp, sp, #0x50
	size_t num_pgs = ROUNDUP(sz, SMALL_PAGE_SIZE) / SMALL_PAGE_SIZE;
 11037bc:	913ffc21 	add	x1, x1, #0xfff
{
 11037c0:	a9017bfd 	stp	x29, x30, [sp, #16]
 11037c4:	910043fd 	add	x29, sp, #0x10
 11037c8:	a90253f3 	stp	x19, x20, [sp, #32]
	size_t num_pgs = ROUNDUP(sz, SMALL_PAGE_SIZE) / SMALL_PAGE_SIZE;
 11037cc:	d34cfc34 	lsr	x20, x1, #12
{
 11037d0:	a9035bf5 	stp	x21, x22, [sp, #48]
 11037d4:	aa0003f6 	mov	x22, x0
	struct fobj *fobj = fobj_ta_mem_alloc(num_pgs);
 11037d8:	2a1403e0 	mov	w0, w20
{
 11037dc:	a90463f7 	stp	x23, x24, [sp, #64]
 11037e0:	2a0203f8 	mov	w24, w2
 11037e4:	aa0303f7 	mov	x23, x3
	struct fobj *fobj = fobj_ta_mem_alloc(num_pgs);
 11037e8:	94005398 	bl	1118648 <fobj_sec_mem_alloc>
 11037ec:	aa0003f5 	mov	x21, x0
	struct mobj *mobj = mobj_with_fobj_alloc(fobj, NULL);
 11037f0:	d2800001 	mov	x1, #0x0                   	// #0
 11037f4:	9400531c 	bl	1118464 <mobj_with_fobj_alloc>
 11037f8:	aa0003f3 	mov	x19, x0
 * If reference counter reaches 0, matching the numbers of fobj_alloc_*() +
 * fobj_get(), the fobj is freed.
 */
static inline void fobj_put(struct fobj *fobj)
{
	if (fobj && refcount_dec(&fobj->refc))
 11037fc:	b4000135 	cbz	x21, 1103820 <alloc_and_map_ldelf_fobj+0x68>
 1103800:	910032a0 	add	x0, x21, #0xc
 1103804:	94003f6a 	bl	11135ac <refcount_dec>
 1103808:	72001c1f 	tst	w0, #0xff
 110380c:	540000a0 	b.eq	1103820 <alloc_and_map_ldelf_fobj+0x68>  // b.none
		fobj->ops->free(fobj);
 1103810:	f94002a0 	ldr	x0, [x21]
 1103814:	f9400001 	ldr	x1, [x0]
 1103818:	aa1503e0 	mov	x0, x21
 110381c:	d63f0020 	blr	x1
	TEE_Result res = TEE_SUCCESS;

	fobj_put(fobj);
	if (!mobj)
 1103820:	b4000373 	cbz	x19, 110388c <alloc_and_map_ldelf_fobj+0xd4>
 */
static inline TEE_Result vm_map(struct user_mode_ctx *uctx, vaddr_t *va,
				size_t len, uint32_t prot, uint32_t flags,
				struct mobj *mobj, size_t offs)
{
	return vm_map_pad(uctx, va, len, prot, flags, mobj, offs, 0, 0, 0);
 1103824:	d374ce82 	lsl	x2, x20, #12
 1103828:	aa1303e5 	mov	x5, x19
 110382c:	2a1803e3 	mov	w3, w24
 1103830:	aa1703e1 	mov	x1, x23
 1103834:	a9007fff 	stp	xzr, xzr, [sp]
 1103838:	d2800007 	mov	x7, #0x0                   	// #0
 110383c:	d2800006 	mov	x6, #0x0                   	// #0
 1103840:	52800104 	mov	w4, #0x8                   	// #8
 1103844:	aa1603e0 	mov	x0, x22
 1103848:	940058bc 	bl	1119b38 <vm_map_pad>
 110384c:	2a0003f4 	mov	w20, w0
 * Decreases reference counter of the @mobj and frees it if the counter
 * reaches 0.
 */
static inline void mobj_put(struct mobj *mobj)
{
	if (mobj && refcount_dec(&mobj->refc))
 1103850:	91006260 	add	x0, x19, #0x18
 1103854:	94003f56 	bl	11135ac <refcount_dec>
 1103858:	72001c1f 	tst	w0, #0xff
 110385c:	540000a0 	b.eq	1103870 <alloc_and_map_ldelf_fobj+0xb8>  // b.none
		mobj->ops->free(mobj);
 1103860:	f9400260 	ldr	x0, [x19]
 1103864:	f9401401 	ldr	x1, [x0, #40]
 1103868:	aa1303e0 	mov	x0, x19
 110386c:	d63f0020 	blr	x1
	res = vm_map(uctx, va, num_pgs * SMALL_PAGE_SIZE,
		     prot, VM_FLAG_LDELF, mobj, 0);
	mobj_put(mobj);

	return res;
}
 1103870:	2a1403e0 	mov	w0, w20
 1103874:	a9417bfd 	ldp	x29, x30, [sp, #16]
 1103878:	a94253f3 	ldp	x19, x20, [sp, #32]
 110387c:	a9435bf5 	ldp	x21, x22, [sp, #48]
 1103880:	a94463f7 	ldp	x23, x24, [sp, #64]
 1103884:	910143ff 	add	sp, sp, #0x50
 1103888:	d65f03c0 	ret
		return TEE_ERROR_OUT_OF_MEMORY;
 110388c:	129ffe74 	mov	w20, #0xffff000c            	// #-65524
 1103890:	17fffff8 	b	1103870 <alloc_and_map_ldelf_fobj+0xb8>

0000000001103894 <ldelf_load_ldelf>:
 * This function may leave a few mappings behind on error, but that's taken
 * care of by tee_ta_init_user_ta_session() since the entire context is
 * removed then.
 */
TEE_Result ldelf_load_ldelf(struct user_mode_ctx *uctx)
{
 1103894:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
	vaddr_t code_addr = 0;
	vaddr_t rw_addr = 0;

	uctx->is_32bit = is_arm32;

	res = alloc_and_map_ldelf_fobj(uctx, LDELF_STACK_SIZE,
 1103898:	52803602 	mov	w2, #0x1b0                 	// #432
 110389c:	d2840001 	mov	x1, #0x2000                	// #8192
{
 11038a0:	910003fd 	mov	x29, sp
 11038a4:	a90153f3 	stp	x19, x20, [sp, #16]
	res = alloc_and_map_ldelf_fobj(uctx, LDELF_STACK_SIZE,
 11038a8:	910123e3 	add	x3, sp, #0x48
{
 11038ac:	aa0003f4 	mov	x20, x0
 11038b0:	a9025bf5 	stp	x21, x22, [sp, #32]
 11038b4:	a90363f7 	stp	x23, x24, [sp, #48]
	uctx->is_32bit = is_arm32;
 11038b8:	3909a01f 	strb	wzr, [x0, #616]
	vaddr_t code_addr = 0;
 11038bc:	a904ffff 	stp	xzr, xzr, [sp, #72]
	vaddr_t rw_addr = 0;
 11038c0:	f9002fff 	str	xzr, [sp, #88]
	res = alloc_and_map_ldelf_fobj(uctx, LDELF_STACK_SIZE,
 11038c4:	97ffffbd 	bl	11037b8 <alloc_and_map_ldelf_fobj>
 11038c8:	2a0003f3 	mov	w19, w0
				       TEE_MATTR_URW | TEE_MATTR_PRW,
				       &stack_addr);
	if (res)
 11038cc:	350007a0 	cbnz	w0, 11039c0 <ldelf_load_ldelf+0x12c>
		return res;
	uctx->ldelf_stack_ptr = stack_addr + LDELF_STACK_SIZE;
 11038d0:	f94027e0 	ldr	x0, [sp, #72]

	res = alloc_and_map_ldelf_fobj(uctx, ldelf_code_size, TEE_MATTR_PRW,
 11038d4:	f00002b5 	adrp	x21, 115a000 <__scattered_array_1phys_mem_map+0x8>
 11038d8:	910143e3 	add	x3, sp, #0x50
 11038dc:	52800602 	mov	w2, #0x30                  	// #48
	uctx->ldelf_stack_ptr = stack_addr + LDELF_STACK_SIZE;
 11038e0:	91400800 	add	x0, x0, #0x2, lsl #12
 11038e4:	f9013280 	str	x0, [x20, #608]
	res = alloc_and_map_ldelf_fobj(uctx, ldelf_code_size, TEE_MATTR_PRW,
 11038e8:	f941a6a0 	ldr	x0, [x21, #840]
 11038ec:	b9400016 	ldr	w22, [x0]
 11038f0:	aa1403e0 	mov	x0, x20
 11038f4:	2a1603f7 	mov	w23, w22
 11038f8:	aa1703e1 	mov	x1, x23
 11038fc:	97ffffaf 	bl	11037b8 <alloc_and_map_ldelf_fobj>
 1103900:	2a0003f3 	mov	w19, w0
				       &code_addr);
	if (res)
 1103904:	350005e0 	cbnz	w0, 11039c0 <ldelf_load_ldelf+0x12c>
		return res;
	uctx->entry_func = code_addr + ldelf_entry;
 1103908:	f94196a1 	ldr	x1, [x21, #808]

	rw_addr = ROUNDUP(code_addr + ldelf_code_size, SMALL_PAGE_SIZE);
	res = alloc_and_map_ldelf_fobj(uctx, ldelf_data_size,
 110390c:	910163e3 	add	x3, sp, #0x58
	uctx->entry_func = code_addr + ldelf_entry;
 1103910:	f9402be0 	ldr	x0, [sp, #80]
	res = alloc_and_map_ldelf_fobj(uctx, ldelf_data_size,
 1103914:	52803602 	mov	w2, #0x1b0                 	// #432
	uctx->entry_func = code_addr + ldelf_entry;
 1103918:	b9400021 	ldr	w1, [x1]
 110391c:	8b000021 	add	x1, x1, x0
	rw_addr = ROUNDUP(code_addr + ldelf_code_size, SMALL_PAGE_SIZE);
 1103920:	913ffc00 	add	x0, x0, #0xfff
 1103924:	8b170000 	add	x0, x0, x23
	uctx->entry_func = code_addr + ldelf_entry;
 1103928:	f9012681 	str	x1, [x20, #584]
	rw_addr = ROUNDUP(code_addr + ldelf_code_size, SMALL_PAGE_SIZE);
 110392c:	9274cc00 	and	x0, x0, #0xfffffffffffff000
 1103930:	f9002fe0 	str	x0, [sp, #88]
	res = alloc_and_map_ldelf_fobj(uctx, ldelf_data_size,
 1103934:	f94176a0 	ldr	x0, [x21, #744]
 1103938:	b9400018 	ldr	w24, [x0]
 110393c:	aa1403e0 	mov	x0, x20
 1103940:	aa1803e1 	mov	x1, x24
 1103944:	97ffff9d 	bl	11037b8 <alloc_and_map_ldelf_fobj>
 1103948:	2a0003f3 	mov	w19, w0
				       TEE_MATTR_URW | TEE_MATTR_PRW, &rw_addr);
	if (res)
 110394c:	350003a0 	cbnz	w0, 11039c0 <ldelf_load_ldelf+0x12c>
		return res;

	vm_set_ctx(uctx->ts_ctx);
 1103950:	f9412280 	ldr	x0, [x20, #576]
 1103954:	940057e2 	bl	11198dc <vm_set_ctx>

	memcpy((void *)code_addr, ldelf_data, ldelf_code_size);
 1103958:	f9402be0 	ldr	x0, [sp, #80]
 110395c:	aa1703e2 	mov	x2, x23
 1103960:	f941eab5 	ldr	x21, [x21, #976]
 1103964:	aa1503e1 	mov	x1, x21
 1103968:	97fffe8a 	bl	1103390 <memcpy>
	memcpy((void *)rw_addr, ldelf_data + ldelf_code_size, ldelf_data_size);
 110396c:	f9402fe0 	ldr	x0, [sp, #88]
 1103970:	aa1803e2 	mov	x2, x24
 1103974:	8b1702a1 	add	x1, x21, x23
 1103978:	97fffe86 	bl	1103390 <memcpy>

	res = vm_set_prot(uctx, code_addr,
 110397c:	f9402be1 	ldr	x1, [sp, #80]
			  ROUNDUP(ldelf_code_size, SMALL_PAGE_SIZE),
 1103980:	113ffec2 	add	w2, w22, #0xfff
	res = vm_set_prot(uctx, code_addr,
 1103984:	92744c42 	and	x2, x2, #0xfffff000
 1103988:	aa1403e0 	mov	x0, x20
 110398c:	52805003 	mov	w3, #0x280                 	// #640
 1103990:	94005a50 	bl	111a2d0 <vm_set_prot>
 1103994:	2a0003f3 	mov	w19, w0
			  TEE_MATTR_URX);
	if (res)
 1103998:	35000140 	cbnz	w0, 11039c0 <ldelf_load_ldelf+0x12c>
		return res;

	DMSG("ldelf load address %#"PRIxVA, code_addr);
 110399c:	f9402be5 	ldr	x5, [sp, #80]
 11039a0:	d0000264 	adrp	x4, 1151000 <small_prime+0x168>
 11039a4:	d0000260 	adrp	x0, 1151000 <small_prime+0x168>
 11039a8:	91070884 	add	x4, x4, #0x1c2
 11039ac:	910b2400 	add	x0, x0, #0x2c9
 11039b0:	52800023 	mov	w3, #0x1                   	// #1
 11039b4:	52800062 	mov	w2, #0x3                   	// #3
 11039b8:	52800b61 	mov	w1, #0x5b                  	// #91
 11039bc:	940104e2 	bl	1144d44 <trace_printf>

	return TEE_SUCCESS;
}
 11039c0:	2a1303e0 	mov	w0, w19
 11039c4:	a94153f3 	ldp	x19, x20, [sp, #16]
 11039c8:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11039cc:	a94363f7 	ldp	x23, x24, [sp, #48]
 11039d0:	a8c67bfd 	ldp	x29, x30, [sp], #96
 11039d4:	d65f03c0 	ret

00000000011039d8 <ldelf_init_with_ldelf>:

TEE_Result ldelf_init_with_ldelf(struct ts_session *sess,
				 struct user_mode_ctx *uctx)
{
 11039d8:	d10183ff 	sub	sp, sp, #0x60
	uaddr_t usr_stack = 0;

	usr_stack = uctx->ldelf_stack_ptr;
	usr_stack -= ROUNDUP(sizeof(*arg), STACK_ALIGNMENT);
	arg = (struct ldelf_arg *)usr_stack;
	memset(arg, 0, sizeof(*arg));
 11039dc:	d2800902 	mov	x2, #0x48                  	// #72
{
 11039e0:	a9017bfd 	stp	x29, x30, [sp, #16]
 11039e4:	910043fd 	add	x29, sp, #0x10
 11039e8:	a9035bf5 	stp	x21, x22, [sp, #48]
 11039ec:	aa0003f6 	mov	x22, x0
	usr_stack = uctx->ldelf_stack_ptr;
 11039f0:	f9413035 	ldr	x21, [x1, #608]
{
 11039f4:	a90253f3 	stp	x19, x20, [sp, #32]
 11039f8:	aa0103f3 	mov	x19, x1
 11039fc:	f90023f7 	str	x23, [sp, #64]
	usr_stack -= ROUNDUP(sizeof(*arg), STACK_ALIGNMENT);
 1103a00:	d10202b7 	sub	x23, x21, #0x80
	memset(arg, 0, sizeof(*arg));
 1103a04:	52800001 	mov	w1, #0x0                   	// #0
 1103a08:	aa1703e0 	mov	x0, x23
	uint32_t panicked = 0;
 1103a0c:	290b7fff 	stp	wzr, wzr, [sp, #88]
	memset(arg, 0, sizeof(*arg));
 1103a10:	940100b4 	bl	1143ce0 <memset>
	arg->uuid = uctx->ts_ctx->uuid;
 1103a14:	f9412260 	ldr	x0, [x19, #576]
	sess->handle_svc = ldelf_handle_svc;

	res = thread_enter_user_mode((vaddr_t)arg, 0, 0, 0,
 1103a18:	910173e7 	add	x7, sp, #0x5c
 1103a1c:	f9412665 	ldr	x5, [x19, #584]
 1103a20:	aa1703e4 	mov	x4, x23
	arg->uuid = uctx->ts_ctx->uuid;
 1103a24:	a9400001 	ldp	x1, x0, [x0]
 1103a28:	a93802a1 	stp	x1, x0, [x21, #-128]
	res = thread_enter_user_mode((vaddr_t)arg, 0, 0, 0,
 1103a2c:	52800006 	mov	w6, #0x0                   	// #0
 1103a30:	d2800003 	mov	x3, #0x0                   	// #0
 1103a34:	d2800002 	mov	x2, #0x0                   	// #0
	sess->handle_svc = ldelf_handle_svc;
 1103a38:	f00002a0 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
	res = thread_enter_user_mode((vaddr_t)arg, 0, 0, 0,
 1103a3c:	d2800001 	mov	x1, #0x0                   	// #0
	sess->handle_svc = ldelf_handle_svc;
 1103a40:	f9419800 	ldr	x0, [x0, #816]
 1103a44:	f90012c0 	str	x0, [x22, #32]
	res = thread_enter_user_mode((vaddr_t)arg, 0, 0, 0,
 1103a48:	910163e0 	add	x0, sp, #0x58
 1103a4c:	f90003e0 	str	x0, [sp]
 1103a50:	aa1703e0 	mov	x0, x23
 1103a54:	940009cf 	bl	1106190 <thread_enter_user_mode>
 1103a58:	2a0003f4 	mov	w20, w0
				     usr_stack, uctx->entry_func,
				     is_arm32, &panicked, &panic_code);

	sess->handle_svc = sess->ctx->ops->handle_svc;
 1103a5c:	f9400ac0 	ldr	x0, [x22, #16]
 1103a60:	f9400800 	ldr	x0, [x0, #16]
 1103a64:	f9401c00 	ldr	x0, [x0, #56]
 1103a68:	f90012c0 	str	x0, [x22, #32]
	thread_user_clear_vfp(uctx);
 1103a6c:	aa1303e0 	mov	x0, x19
 1103a70:	940009b5 	bl	1106144 <thread_user_clear_vfp>
	ldelf_sess_cleanup(sess);
 1103a74:	aa1603e0 	mov	x0, x22
 1103a78:	94003de7 	bl	1113214 <ldelf_sess_cleanup>

	if (panicked) {
 1103a7c:	b9405fe0 	ldr	w0, [sp, #92]
 1103a80:	34000240 	cbz	w0, 1103ac8 <ldelf_init_with_ldelf+0xf0>
		abort_print_current_ts();
		EMSG("ldelf panicked");
		return TEE_ERROR_GENERIC;
 1103a84:	52bffff4 	mov	w20, #0xffff0000            	// #-65536
		abort_print_current_ts();
 1103a88:	94000f17 	bl	11076e4 <abort_print_current_ts>
		EMSG("ldelf panicked");
 1103a8c:	d0000264 	adrp	x4, 1151000 <small_prime+0x168>
 1103a90:	52800023 	mov	w3, #0x1                   	// #1
 1103a94:	91076884 	add	x4, x4, #0x1da
 1103a98:	52800022 	mov	w2, #0x1                   	// #1
 1103a9c:	52800f41 	mov	w1, #0x7a                  	// #122
 1103aa0:	d0000260 	adrp	x0, 1151000 <small_prime+0x168>
 1103aa4:	910b6800 	add	x0, x0, #0x2da
 1103aa8:	940104a7 	bl	1144d44 <trace_printf>
	sess->fbuf = arg->fbuf;
#endif
	uctx->dl_entry_func = arg->dl_entry;

	return TEE_SUCCESS;
}
 1103aac:	2a1403e0 	mov	w0, w20
 1103ab0:	a9417bfd 	ldp	x29, x30, [sp, #16]
 1103ab4:	a94253f3 	ldp	x19, x20, [sp, #32]
 1103ab8:	a9435bf5 	ldp	x21, x22, [sp, #48]
 1103abc:	f94023f7 	ldr	x23, [sp, #64]
 1103ac0:	910183ff 	add	sp, sp, #0x60
 1103ac4:	d65f03c0 	ret
	if (res) {
 1103ac8:	34000174 	cbz	w20, 1103af4 <ldelf_init_with_ldelf+0x11c>
		EMSG("ldelf failed with res: %#"PRIx32, res);
 1103acc:	2a1403e5 	mov	w5, w20
 1103ad0:	d0000264 	adrp	x4, 1151000 <small_prime+0x168>
 1103ad4:	52800023 	mov	w3, #0x1                   	// #1
 1103ad8:	9107a484 	add	x4, x4, #0x1e9
 1103adc:	52800022 	mov	w2, #0x1                   	// #1
 1103ae0:	52800fc1 	mov	w1, #0x7e                  	// #126
 1103ae4:	d0000260 	adrp	x0, 1151000 <small_prime+0x168>
 1103ae8:	910b6800 	add	x0, x0, #0x2da
 1103aec:	94010496 	bl	1144d44 <trace_printf>
		return res;
 1103af0:	17ffffef 	b	1103aac <ldelf_init_with_ldelf+0xd4>
	res = vm_check_access_rights(uctx,
 1103af4:	aa1703e2 	mov	x2, x23
 1103af8:	aa1303e0 	mov	x0, x19
 1103afc:	d2800903 	mov	x3, #0x48                  	// #72
 1103b00:	528000a1 	mov	w1, #0x5                   	// #5
 1103b04:	9400573a 	bl	11197ec <vm_check_access_rights>
 1103b08:	2a0003f4 	mov	w20, w0
	if (res)
 1103b0c:	35fffd00 	cbnz	w0, 1103aac <ldelf_init_with_ldelf+0xd4>
	if (is_user_ta_ctx(uctx->ts_ctx)) {
 1103b10:	f9412260 	ldr	x0, [x19, #576]
 1103b14:	940049b6 	bl	11161ec <is_user_ta_ctx>
 1103b18:	72001c1f 	tst	w0, #0xff
 1103b1c:	54000280 	b.eq	1103b6c <ldelf_init_with_ldelf+0x194>  // b.none
		if (arg->flags & ~TA_FLAGS_MASK)
 1103b20:	b85942a0 	ldur	w0, [x21, #-108]
 1103b24:	7215501f 	tst	w0, #0xfffff800
 1103b28:	540003c1 	b.ne	1103ba0 <ldelf_init_with_ldelf+0x1c8>  // b.any
		to_user_ta_ctx(uctx->ts_ctx)->ta_ctx.flags = arg->flags;
 1103b2c:	f9412276 	ldr	x22, [x19, #576]
}
#endif

static inline struct user_ta_ctx *to_user_ta_ctx(struct ts_ctx *ctx)
{
	assert(is_user_ta_ctx(ctx));
 1103b30:	aa1603e0 	mov	x0, x22
 1103b34:	940049ae 	bl	11161ec <is_user_ta_ctx>
 1103b38:	72001c1f 	tst	w0, #0xff
 1103b3c:	54000141 	b.ne	1103b64 <ldelf_init_with_ldelf+0x18c>  // b.any
 1103b40:	d0000263 	adrp	x3, 1151000 <small_prime+0x168>
 1103b44:	d0000261 	adrp	x1, 1151000 <small_prime+0x168>
 1103b48:	910ae863 	add	x3, x3, #0x2ba
 1103b4c:	91081021 	add	x1, x1, #0x204
 1103b50:	d0000260 	adrp	x0, 1151000 <small_prime+0x168>
 1103b54:	91088800 	add	x0, x0, #0x222
 1103b58:	52800702 	mov	w2, #0x38                  	// #56
 1103b5c:	940039d4 	bl	11122ac <_assert_log>
 1103b60:	940039e4 	bl	11122f0 <_assert_break>
 1103b64:	b85942a0 	ldur	w0, [x21, #-108]
 1103b68:	b81e82c0 	stur	w0, [x22, #-24]
	uctx->is_32bit = arg->is_32bit;
 1103b6c:	b85902a0 	ldur	w0, [x21, #-112]
 1103b70:	7100001f 	cmp	w0, #0x0
 1103b74:	1a9f07e0 	cset	w0, ne  // ne = any
 1103b78:	3909a260 	strb	w0, [x19, #616]
	uctx->entry_func = arg->entry_func;
 1103b7c:	f85982a0 	ldur	x0, [x21, #-104]
 1103b80:	f9012660 	str	x0, [x19, #584]
	uctx->stack_ptr = arg->stack_ptr;
 1103b84:	f85a02a0 	ldur	x0, [x21, #-96]
 1103b88:	f9013a60 	str	x0, [x19, #624]
	uctx->dump_entry_func = arg->dump_entry;
 1103b8c:	f85a82a0 	ldur	x0, [x21, #-88]
 1103b90:	f9012a60 	str	x0, [x19, #592]
	uctx->dl_entry_func = arg->dl_entry;
 1103b94:	f85b82a0 	ldur	x0, [x21, #-72]
 1103b98:	f9012e60 	str	x0, [x19, #600]
	return TEE_SUCCESS;
 1103b9c:	17ffffc4 	b	1103aac <ldelf_init_with_ldelf+0xd4>
			return TEE_ERROR_BAD_FORMAT;
 1103ba0:	129fff54 	mov	w20, #0xffff0005            	// #-65531
 1103ba4:	17ffffc2 	b	1103aac <ldelf_init_with_ldelf+0xd4>

0000000001103ba8 <ldelf_dump_state>:

TEE_Result ldelf_dump_state(struct user_mode_ctx *uctx)
{
 1103ba8:	d10183ff 	sub	sp, sp, #0x60
 1103bac:	a9017bfd 	stp	x29, x30, [sp, #16]
 1103bb0:	910043fd 	add	x29, sp, #0x10
 1103bb4:	a9035bf5 	stp	x21, x22, [sp, #48]
 1103bb8:	aa0003f6 	mov	x22, x0
 1103bbc:	a90253f3 	stp	x19, x20, [sp, #32]
 1103bc0:	a90463f7 	stp	x23, x24, [sp, #64]
	uint32_t panic_code = 0;
	uint32_t panicked = 0;
	struct thread_specific_data *tsd = thread_get_tsd();
	struct ts_session *sess = NULL;
	struct vm_region *r = NULL;
	size_t n = 0;
 1103bc4:	d2800017 	mov	x23, #0x0                   	// #0
	uint32_t panicked = 0;
 1103bc8:	290b7fff 	stp	wzr, wzr, [sp, #88]
	struct thread_specific_data *tsd = thread_get_tsd();
 1103bcc:	940007fd 	bl	1105bc0 <thread_get_tsd>
 1103bd0:	aa0003f4 	mov	x20, x0

	TAILQ_FOREACH(r, &uctx->vm_info.regions, link)
 1103bd4:	f94002c0 	ldr	x0, [x22]
 1103bd8:	b5000380 	cbnz	x0, 1103c48 <ldelf_dump_state+0xa0>
		if (r->attr & TEE_MATTR_URWX)
			n++;

	usr_stack = uctx->ldelf_stack_ptr;
	usr_stack -= ROUNDUP(sizeof(*arg) + n * sizeof(struct dump_map),
 1103bdc:	d37beaf8 	lsl	x24, x23, #5
			     STACK_ALIGNMENT);
	arg = (struct dump_entry_arg *)usr_stack;

	res = vm_check_access_rights(uctx,
 1103be0:	aa1603e0 	mov	x0, x22
	usr_stack -= ROUNDUP(sizeof(*arg) + n * sizeof(struct dump_map),
 1103be4:	91023f04 	add	x4, x24, #0x8f
	res = vm_check_access_rights(uctx,
 1103be8:	d2800a03 	mov	x3, #0x50                  	// #80
	usr_stack = uctx->ldelf_stack_ptr;
 1103bec:	f94132d3 	ldr	x19, [x22, #608]
	usr_stack -= ROUNDUP(sizeof(*arg) + n * sizeof(struct dump_map),
 1103bf0:	927ae484 	and	x4, x4, #0xffffffffffffffc0
	res = vm_check_access_rights(uctx,
 1103bf4:	528000a1 	mov	w1, #0x5                   	// #5
	usr_stack -= ROUNDUP(sizeof(*arg) + n * sizeof(struct dump_map),
 1103bf8:	cb040273 	sub	x19, x19, x4
	res = vm_check_access_rights(uctx,
 1103bfc:	aa1303e2 	mov	x2, x19
 1103c00:	940056fb 	bl	11197ec <vm_check_access_rights>
 1103c04:	2a0003f5 	mov	w21, w0
				     TEE_MEMORY_ACCESS_READ |
				     TEE_MEMORY_ACCESS_ANY_OWNER,
				     (uaddr_t)arg, sizeof(*arg));
	if (res) {
 1103c08:	340002c0 	cbz	w0, 1103c60 <ldelf_dump_state+0xb8>
		EMSG("ldelf stack is inaccessible!");
 1103c0c:	d0000264 	adrp	x4, 1151000 <small_prime+0x168>
 1103c10:	d0000260 	adrp	x0, 1151000 <small_prime+0x168>
 1103c14:	9108d884 	add	x4, x4, #0x236
 1103c18:	910bc000 	add	x0, x0, #0x2f0
 1103c1c:	52800023 	mov	w3, #0x1                   	// #1
 1103c20:	52800022 	mov	w2, #0x1                   	// #1
 1103c24:	52801761 	mov	w1, #0xbb                  	// #187
 1103c28:	94010447 	bl	1144d44 <trace_printf>
		abort_print_current_ts();
		res = TEE_ERROR_TARGET_DEAD;
	}

	return res;
}
 1103c2c:	2a1503e0 	mov	w0, w21
 1103c30:	a9417bfd 	ldp	x29, x30, [sp, #16]
 1103c34:	a94253f3 	ldp	x19, x20, [sp, #32]
 1103c38:	a9435bf5 	ldp	x21, x22, [sp, #48]
 1103c3c:	a94463f7 	ldp	x23, x24, [sp, #64]
 1103c40:	910183ff 	add	sp, sp, #0x60
 1103c44:	d65f03c0 	ret
		if (r->attr & TEE_MATTR_URWX)
 1103c48:	79404001 	ldrh	w1, [x0, #32]
	TAILQ_FOREACH(r, &uctx->vm_info.regions, link)
 1103c4c:	f9401400 	ldr	x0, [x0, #40]
		if (r->attr & TEE_MATTR_URWX)
 1103c50:	7219083f 	tst	w1, #0x380
			n++;
 1103c54:	9a9f07e1 	cset	x1, ne  // ne = any
 1103c58:	8b0102f7 	add	x23, x23, x1
	TAILQ_FOREACH(r, &uctx->vm_info.regions, link)
 1103c5c:	17ffffdf 	b	1103bd8 <ldelf_dump_state+0x30>
	memset(arg, 0, sizeof(*arg) + n * sizeof(struct dump_map));
 1103c60:	91014302 	add	x2, x24, #0x50
 1103c64:	aa1303e0 	mov	x0, x19
 1103c68:	52800001 	mov	w1, #0x0                   	// #0
 1103c6c:	9401001d 	bl	1143ce0 <memset>
	arg->num_maps = n;
 1103c70:	f9002677 	str	x23, [x19, #72]
	n = 0;
 1103c74:	d2800018 	mov	x24, #0x0                   	// #0
	TAILQ_FOREACH(r, &uctx->vm_info.regions, link) {
 1103c78:	f94002d7 	ldr	x23, [x22]
 1103c7c:	b5000957 	cbnz	x23, 1103da4 <ldelf_dump_state+0x1fc>
	arg->is_arm32 = uctx->is_32bit;
 1103c80:	3949a2c1 	ldrb	w1, [x22, #616]
 1103c84:	39010261 	strb	w1, [x19, #64]
	if (uctx->is_32bit) {
 1103c88:	f9409a80 	ldr	x0, [x20, #304]
 1103c8c:	34000ee1 	cbz	w1, 1103e68 <ldelf_dump_state+0x2c0>
		arg->arm32.regs[0] = tsd->abort_regs.x0;
 1103c90:	f9401e81 	ldr	x1, [x20, #56]
 1103c94:	b9000261 	str	w1, [x19]
		arg->arm32.regs[1] = tsd->abort_regs.x1;
 1103c98:	f9402281 	ldr	x1, [x20, #64]
 1103c9c:	b9000661 	str	w1, [x19, #4]
		arg->arm32.regs[2] = tsd->abort_regs.x2;
 1103ca0:	f9402681 	ldr	x1, [x20, #72]
 1103ca4:	b9000a61 	str	w1, [x19, #8]
		arg->arm32.regs[3] = tsd->abort_regs.x3;
 1103ca8:	f9402a81 	ldr	x1, [x20, #80]
 1103cac:	b9000e61 	str	w1, [x19, #12]
		arg->arm32.regs[4] = tsd->abort_regs.x4;
 1103cb0:	f9402e81 	ldr	x1, [x20, #88]
 1103cb4:	b9001261 	str	w1, [x19, #16]
		arg->arm32.regs[5] = tsd->abort_regs.x5;
 1103cb8:	f9403281 	ldr	x1, [x20, #96]
 1103cbc:	b9001661 	str	w1, [x19, #20]
		arg->arm32.regs[6] = tsd->abort_regs.x6;
 1103cc0:	f9403681 	ldr	x1, [x20, #104]
 1103cc4:	b9001a61 	str	w1, [x19, #24]
		arg->arm32.regs[7] = tsd->abort_regs.x7;
 1103cc8:	f9403a81 	ldr	x1, [x20, #112]
 1103ccc:	b9001e61 	str	w1, [x19, #28]
		arg->arm32.regs[8] = tsd->abort_regs.x8;
 1103cd0:	f9403e81 	ldr	x1, [x20, #120]
 1103cd4:	b9002261 	str	w1, [x19, #32]
		arg->arm32.regs[9] = tsd->abort_regs.x9;
 1103cd8:	f9404281 	ldr	x1, [x20, #128]
 1103cdc:	b9002661 	str	w1, [x19, #36]
		arg->arm32.regs[10] = tsd->abort_regs.x10;
 1103ce0:	f9404681 	ldr	x1, [x20, #136]
 1103ce4:	b9002a61 	str	w1, [x19, #40]
		arg->arm32.regs[11] = tsd->abort_regs.x11;
 1103ce8:	f9404a81 	ldr	x1, [x20, #144]
 1103cec:	b9002e61 	str	w1, [x19, #44]
		arg->arm32.regs[12] = tsd->abort_regs.x12;
 1103cf0:	f9404e81 	ldr	x1, [x20, #152]
 1103cf4:	b9003261 	str	w1, [x19, #48]
		arg->arm32.regs[13] = tsd->abort_regs.x13; /*SP*/
 1103cf8:	f9405281 	ldr	x1, [x20, #160]
 1103cfc:	b9003661 	str	w1, [x19, #52]
		arg->arm32.regs[14] = tsd->abort_regs.x14; /*LR*/
 1103d00:	f9405681 	ldr	x1, [x20, #168]
		arg->arm32.regs[15] = tsd->abort_regs.elr; /*PC*/
 1103d04:	29070261 	stp	w1, w0, [x19, #56]
	sess = ts_get_current_session();
 1103d08:	94004336 	bl	11149e0 <ts_get_current_session>
 1103d0c:	aa0003f4 	mov	x20, x0
	sess->handle_svc = ldelf_handle_svc;
 1103d10:	f00002a0 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
	res = thread_enter_user_mode((vaddr_t)arg, 0, 0, 0,
 1103d14:	910173e7 	add	x7, sp, #0x5c
 1103d18:	f9412ac5 	ldr	x5, [x22, #592]
 1103d1c:	aa1303e4 	mov	x4, x19
	sess->handle_svc = ldelf_handle_svc;
 1103d20:	f9419800 	ldr	x0, [x0, #816]
 1103d24:	f9001280 	str	x0, [x20, #32]
	res = thread_enter_user_mode((vaddr_t)arg, 0, 0, 0,
 1103d28:	910163e0 	add	x0, sp, #0x58
 1103d2c:	f90003e0 	str	x0, [sp]
 1103d30:	52800006 	mov	w6, #0x0                   	// #0
 1103d34:	d2800003 	mov	x3, #0x0                   	// #0
 1103d38:	d2800002 	mov	x2, #0x0                   	// #0
 1103d3c:	d2800001 	mov	x1, #0x0                   	// #0
 1103d40:	aa1303e0 	mov	x0, x19
 1103d44:	94000913 	bl	1106190 <thread_enter_user_mode>
 1103d48:	2a0003f5 	mov	w21, w0
	sess->handle_svc = sess->ctx->ops->handle_svc;
 1103d4c:	f9400a80 	ldr	x0, [x20, #16]
 1103d50:	f9400800 	ldr	x0, [x0, #16]
 1103d54:	f9401c00 	ldr	x0, [x0, #56]
 1103d58:	f9001280 	str	x0, [x20, #32]
	thread_user_clear_vfp(uctx);
 1103d5c:	aa1603e0 	mov	x0, x22
 1103d60:	940008f9 	bl	1106144 <thread_user_clear_vfp>
	ldelf_sess_cleanup(sess);
 1103d64:	aa1403e0 	mov	x0, x20
 1103d68:	94003d2b 	bl	1113214 <ldelf_sess_cleanup>
	if (panicked) {
 1103d6c:	b9405fe0 	ldr	w0, [sp, #92]
 1103d70:	34fff5e0 	cbz	w0, 1103c2c <ldelf_dump_state+0x84>
		EMSG("ldelf dump function panicked");
 1103d74:	d0000264 	adrp	x4, 1151000 <small_prime+0x168>
 1103d78:	d0000260 	adrp	x0, 1151000 <small_prime+0x168>
 1103d7c:	91094c84 	add	x4, x4, #0x253
 1103d80:	910bc000 	add	x0, x0, #0x2f0
 1103d84:	52800023 	mov	w3, #0x1                   	// #1
 1103d88:	52800022 	mov	w2, #0x1                   	// #1
 1103d8c:	52802261 	mov	w1, #0x113                 	// #275
		uctx->dump_entry_func = 0;
 1103d90:	f9012adf 	str	xzr, [x22, #592]
		res = TEE_ERROR_TARGET_DEAD;
 1103d94:	1299fb75 	mov	w21, #0xffff3024            	// #-53212
		EMSG("ldelf dump function panicked");
 1103d98:	940103eb 	bl	1144d44 <trace_printf>
		abort_print_current_ts();
 1103d9c:	94000e52 	bl	11076e4 <abort_print_current_ts>
		res = TEE_ERROR_TARGET_DEAD;
 1103da0:	17ffffa3 	b	1103c2c <ldelf_dump_state+0x84>
		if (r->attr & TEE_MATTR_URWX) {
 1103da4:	794042e0 	ldrh	w0, [x23, #32]
 1103da8:	7219081f 	tst	w0, #0x380
 1103dac:	540005a0 	b.eq	1103e60 <ldelf_dump_state+0x2b8>  // b.none
			if (r->mobj)
 1103db0:	f94002e0 	ldr	x0, [x23]
 1103db4:	d37beb15 	lsl	x21, x24, #5
 1103db8:	b4000140 	cbz	x0, 1103de0 <ldelf_dump_state+0x238>
	if (mobj && mobj->ops && mobj->ops->get_pa)
 1103dbc:	f9400001 	ldr	x1, [x0]
 1103dc0:	b4000101 	cbz	x1, 1103de0 <ldelf_dump_state+0x238>
 1103dc4:	f9400424 	ldr	x4, [x1, #8]
 1103dc8:	b40000c4 	cbz	x4, 1103de0 <ldelf_dump_state+0x238>
		return mobj->ops->get_pa(mobj, offs, granule, pa);
 1103dcc:	f94006e1 	ldr	x1, [x23, #8]
				mobj_get_pa(r->mobj, r->offset, 0,
 1103dd0:	910162a3 	add	x3, x21, #0x58
 1103dd4:	8b030263 	add	x3, x19, x3
 1103dd8:	d2800002 	mov	x2, #0x0                   	// #0
 1103ddc:	d63f0080 	blr	x4
			arg->maps[n].va = r->va;
 1103de0:	8b150261 	add	x1, x19, x21
 1103de4:	f9400ae0 	ldr	x0, [x23, #16]
 1103de8:	f9002820 	str	x0, [x1, #80]
			arg->maps[n].sz = r->size;
 1103dec:	f9400ee0 	ldr	x0, [x23, #24]
 1103df0:	f9003020 	str	x0, [x1, #96]
			if (r->attr & TEE_MATTR_UR)
 1103df4:	794042e0 	ldrh	w0, [x23, #32]
 1103df8:	36380080 	tbz	w0, #7, 1103e08 <ldelf_dump_state+0x260>
				arg->maps[n].flags |= DUMP_MAP_READ;
 1103dfc:	b9406822 	ldr	w2, [x1, #104]
 1103e00:	32000042 	orr	w2, w2, #0x1
 1103e04:	b9006822 	str	w2, [x1, #104]
			if (r->attr & TEE_MATTR_UW)
 1103e08:	36400080 	tbz	w0, #8, 1103e18 <ldelf_dump_state+0x270>
				arg->maps[n].flags |= DUMP_MAP_WRITE;
 1103e0c:	b9406822 	ldr	w2, [x1, #104]
 1103e10:	321f0042 	orr	w2, w2, #0x2
 1103e14:	b9006822 	str	w2, [x1, #104]
			if (r->attr & TEE_MATTR_UX)
 1103e18:	36480080 	tbz	w0, #9, 1103e28 <ldelf_dump_state+0x280>
				arg->maps[n].flags |= DUMP_MAP_EXEC;
 1103e1c:	b9406822 	ldr	w2, [x1, #104]
 1103e20:	321e0042 	orr	w2, w2, #0x4
 1103e24:	b9006822 	str	w2, [x1, #104]
			if (r->attr & TEE_MATTR_SECURE)
 1103e28:	36580080 	tbz	w0, #11, 1103e38 <ldelf_dump_state+0x290>
				arg->maps[n].flags |= DUMP_MAP_SECURE;
 1103e2c:	b9406820 	ldr	w0, [x1, #104]
 1103e30:	321d0000 	orr	w0, w0, #0x8
 1103e34:	b9006820 	str	w0, [x1, #104]
			if (r->flags & VM_FLAG_EPHEMERAL)
 1103e38:	794046e2 	ldrh	w2, [x23, #34]
 1103e3c:	36000082 	tbz	w2, #0, 1103e4c <ldelf_dump_state+0x2a4>
				arg->maps[n].flags |= DUMP_MAP_EPHEM;
 1103e40:	b9406820 	ldr	w0, [x1, #104]
 1103e44:	321c0000 	orr	w0, w0, #0x10
 1103e48:	b9006820 	str	w0, [x1, #104]
			if (r->flags & VM_FLAG_LDELF)
 1103e4c:	36180082 	tbz	w2, #3, 1103e5c <ldelf_dump_state+0x2b4>
				arg->maps[n].flags |= DUMP_MAP_LDELF;
 1103e50:	b9406820 	ldr	w0, [x1, #104]
 1103e54:	32190000 	orr	w0, w0, #0x80
 1103e58:	b9006820 	str	w0, [x1, #104]
			n++;
 1103e5c:	91000718 	add	x24, x24, #0x1
	TAILQ_FOREACH(r, &uctx->vm_info.regions, link) {
 1103e60:	f94016f7 	ldr	x23, [x23, #40]
 1103e64:	17ffff86 	b	1103c7c <ldelf_dump_state+0xd4>
		arg->arm64.fp = tsd->abort_regs.x29;
 1103e68:	f9409281 	ldr	x1, [x20, #288]
		arg->arm64.pc = tsd->abort_regs.elr;
 1103e6c:	f9000a60 	str	x0, [x19, #16]
		arg->arm64.sp = tsd->abort_regs.sp_el0;
 1103e70:	f940a280 	ldr	x0, [x20, #320]
		arg->arm64.fp = tsd->abort_regs.x29;
 1103e74:	f9000261 	str	x1, [x19]
		arg->arm64.sp = tsd->abort_regs.sp_el0;
 1103e78:	f9000660 	str	x0, [x19, #8]
 1103e7c:	17ffffa3 	b	1103d08 <ldelf_dump_state+0x160>

0000000001103e80 <ldelf_dlopen>:
}
#endif /*CFG_FTRACE_SUPPORT*/

TEE_Result ldelf_dlopen(struct user_mode_ctx *uctx, TEE_UUID *uuid,
			uint32_t flags)
{
 1103e80:	d10183ff 	sub	sp, sp, #0x60
 1103e84:	a9017bfd 	stp	x29, x30, [sp, #16]
 1103e88:	910043fd 	add	x29, sp, #0x10
 1103e8c:	a90253f3 	stp	x19, x20, [sp, #32]
 1103e90:	a9035bf5 	stp	x21, x22, [sp, #48]
 1103e94:	a90463f7 	stp	x23, x24, [sp, #64]
	uaddr_t usr_stack = uctx->ldelf_stack_ptr;
	TEE_Result res = TEE_ERROR_GENERIC;
	struct dl_entry_arg *arg = NULL;
	uint32_t panic_code = 0;
	uint32_t panicked = 0;
 1103e98:	290b7fff 	stp	wzr, wzr, [sp, #88]
	uaddr_t usr_stack = uctx->ldelf_stack_ptr;
 1103e9c:	f9413015 	ldr	x21, [x0, #608]
	struct ts_session *sess = NULL;

	assert(uuid);
 1103ea0:	b5000141 	cbnz	x1, 1103ec8 <ldelf_dlopen+0x48>
 1103ea4:	d0000263 	adrp	x3, 1151000 <small_prime+0x168>
 1103ea8:	d0000261 	adrp	x1, 1151000 <small_prime+0x168>
 1103eac:	910c0463 	add	x3, x3, #0x301
 1103eb0:	9109c021 	add	x1, x1, #0x270
 1103eb4:	d0000260 	adrp	x0, 1151000 <small_prime+0x168>
 1103eb8:	910a5000 	add	x0, x0, #0x294
 1103ebc:	52802ba2 	mov	w2, #0x15d                 	// #349
 1103ec0:	940038fb 	bl	11122ac <_assert_log>
 1103ec4:	9400390b 	bl	11122f0 <_assert_break>

	usr_stack -= ROUNDUP(sizeof(*arg), STACK_ALIGNMENT);
 1103ec8:	d10102b6 	sub	x22, x21, #0x40
 1103ecc:	aa0003f7 	mov	x23, x0
 1103ed0:	aa0103f4 	mov	x20, x1
 1103ed4:	2a0203f8 	mov	w24, w2
	arg = (struct dl_entry_arg *)usr_stack;

	res = vm_check_access_rights(uctx,
 1103ed8:	d2800403 	mov	x3, #0x20                  	// #32
 1103edc:	aa1603e2 	mov	x2, x22
 1103ee0:	528000e1 	mov	w1, #0x7                   	// #7
 1103ee4:	94005642 	bl	11197ec <vm_check_access_rights>
 1103ee8:	2a0003f3 	mov	w19, w0
				     TEE_MEMORY_ACCESS_READ |
				     TEE_MEMORY_ACCESS_WRITE |
				     TEE_MEMORY_ACCESS_ANY_OWNER,
				     (uaddr_t)arg, sizeof(*arg));
	if (res) {
 1103eec:	34000200 	cbz	w0, 1103f2c <ldelf_dlopen+0xac>
		EMSG("ldelf stack is inaccessible!");
 1103ef0:	d0000264 	adrp	x4, 1151000 <small_prime+0x168>
 1103ef4:	d0000260 	adrp	x0, 1151000 <small_prime+0x168>
 1103ef8:	9108d884 	add	x4, x4, #0x236
 1103efc:	910c0400 	add	x0, x0, #0x301
 1103f00:	52800023 	mov	w3, #0x1                   	// #1
 1103f04:	52800022 	mov	w2, #0x1                   	// #1
 1103f08:	52802d01 	mov	w1, #0x168                 	// #360
 1103f0c:	9401038e 	bl	1144d44 <trace_printf>
	}
	if (!res)
		res = arg->ret;

	return res;
}
 1103f10:	2a1303e0 	mov	w0, w19
 1103f14:	a9417bfd 	ldp	x29, x30, [sp, #16]
 1103f18:	a94253f3 	ldp	x19, x20, [sp, #32]
 1103f1c:	a9435bf5 	ldp	x21, x22, [sp, #48]
 1103f20:	a94463f7 	ldp	x23, x24, [sp, #64]
 1103f24:	910183ff 	add	sp, sp, #0x60
 1103f28:	d65f03c0 	ret
	memset(arg, 0, sizeof(*arg));
 1103f2c:	d2800402 	mov	x2, #0x20                  	// #32
 1103f30:	52800001 	mov	w1, #0x0                   	// #0
 1103f34:	aa1603e0 	mov	x0, x22
 1103f38:	9400ff6a 	bl	1143ce0 <memset>
	arg->cmd = LDELF_DL_ENTRY_DLOPEN;
 1103f3c:	b81c02bf 	stur	wzr, [x21, #-64]
	arg->dlopen.uuid = *uuid;
 1103f40:	aa1403e1 	mov	x1, x20
 1103f44:	d2800202 	mov	x2, #0x10                  	// #16
 1103f48:	910022c0 	add	x0, x22, #0x8
 1103f4c:	97fffd11 	bl	1103390 <memcpy>
	arg->dlopen.flags = flags;
 1103f50:	b81d82b8 	stur	w24, [x21, #-40]
	sess = ts_get_current_session();
 1103f54:	940042a3 	bl	11149e0 <ts_get_current_session>
 1103f58:	aa0003f4 	mov	x20, x0
	sess->handle_svc = ldelf_handle_svc;
 1103f5c:	f00002a0 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
	res = thread_enter_user_mode((vaddr_t)arg, 0, 0, 0,
 1103f60:	910173e7 	add	x7, sp, #0x5c
 1103f64:	aa1603e4 	mov	x4, x22
 1103f68:	52800006 	mov	w6, #0x0                   	// #0
	sess->handle_svc = ldelf_handle_svc;
 1103f6c:	f9419800 	ldr	x0, [x0, #816]
 1103f70:	f9001280 	str	x0, [x20, #32]
	res = thread_enter_user_mode((vaddr_t)arg, 0, 0, 0,
 1103f74:	910163e0 	add	x0, sp, #0x58
 1103f78:	f90003e0 	str	x0, [sp]
 1103f7c:	d2800003 	mov	x3, #0x0                   	// #0
 1103f80:	d2800002 	mov	x2, #0x0                   	// #0
 1103f84:	f9412ee5 	ldr	x5, [x23, #600]
 1103f88:	d2800001 	mov	x1, #0x0                   	// #0
 1103f8c:	aa1603e0 	mov	x0, x22
 1103f90:	94000880 	bl	1106190 <thread_enter_user_mode>
 1103f94:	2a0003f3 	mov	w19, w0
	sess->handle_svc = sess->ctx->ops->handle_svc;
 1103f98:	f9400a80 	ldr	x0, [x20, #16]
 1103f9c:	f9400800 	ldr	x0, [x0, #16]
 1103fa0:	f9401c00 	ldr	x0, [x0, #56]
 1103fa4:	f9001280 	str	x0, [x20, #32]
	ldelf_sess_cleanup(sess);
 1103fa8:	aa1403e0 	mov	x0, x20
 1103fac:	94003c9a 	bl	1113214 <ldelf_sess_cleanup>
	if (panicked) {
 1103fb0:	b9405fe0 	ldr	w0, [sp, #92]
 1103fb4:	34000180 	cbz	w0, 1103fe4 <ldelf_dlopen+0x164>
		EMSG("ldelf dl_entry function panicked");
 1103fb8:	d0000264 	adrp	x4, 1151000 <small_prime+0x168>
 1103fbc:	d0000260 	adrp	x0, 1151000 <small_prime+0x168>
 1103fc0:	910a6484 	add	x4, x4, #0x299
 1103fc4:	910c0400 	add	x0, x0, #0x301
 1103fc8:	52800023 	mov	w3, #0x1                   	// #1
 1103fcc:	52800022 	mov	w2, #0x1                   	// #1
 1103fd0:	52802f81 	mov	w1, #0x17c                 	// #380
		res = TEE_ERROR_TARGET_DEAD;
 1103fd4:	1299fb73 	mov	w19, #0xffff3024            	// #-53212
		EMSG("ldelf dl_entry function panicked");
 1103fd8:	9401035b 	bl	1144d44 <trace_printf>
		abort_print_current_ts();
 1103fdc:	94000dc2 	bl	11076e4 <abort_print_current_ts>
	if (!res)
 1103fe0:	17ffffcc 	b	1103f10 <ldelf_dlopen+0x90>
 1103fe4:	35fff973 	cbnz	w19, 1103f10 <ldelf_dlopen+0x90>
		res = arg->ret;
 1103fe8:	b85c42b3 	ldur	w19, [x21, #-60]
 1103fec:	17ffffc9 	b	1103f10 <ldelf_dlopen+0x90>

0000000001103ff0 <ldelf_dlsym>:

TEE_Result ldelf_dlsym(struct user_mode_ctx *uctx, TEE_UUID *uuid,
		       const char *sym, size_t maxlen, vaddr_t *val)
{
 1103ff0:	d101c3ff 	sub	sp, sp, #0x70
 1103ff4:	a9017bfd 	stp	x29, x30, [sp, #16]
 1103ff8:	910043fd 	add	x29, sp, #0x10
 1103ffc:	a90253f3 	stp	x19, x20, [sp, #32]
 1104000:	aa0303f3 	mov	x19, x3
 1104004:	a9035bf5 	stp	x21, x22, [sp, #48]
 1104008:	aa0403f6 	mov	x22, x4
 110400c:	a90463f7 	stp	x23, x24, [sp, #64]
 1104010:	aa0003f7 	mov	x23, x0
 1104014:	aa0203f8 	mov	x24, x2
 1104018:	a9056bf9 	stp	x25, x26, [sp, #80]
 110401c:	aa0103f9 	mov	x25, x1
	uaddr_t usr_stack = uctx->ldelf_stack_ptr;
	TEE_Result res = TEE_ERROR_GENERIC;
	struct dl_entry_arg *arg = NULL;
	uint32_t panic_code = 0;
	uint32_t panicked = 0;
	size_t len = strnlen(sym, maxlen);
 1104020:	aa0303e1 	mov	x1, x3
	uint32_t panicked = 0;
 1104024:	290d7fff 	stp	wzr, wzr, [sp, #104]
	uaddr_t usr_stack = uctx->ldelf_stack_ptr;
 1104028:	f9413014 	ldr	x20, [x0, #608]
	size_t len = strnlen(sym, maxlen);
 110402c:	aa0203e0 	mov	x0, x2
 1104030:	9400ff51 	bl	1143d74 <strnlen>
	struct ts_session *sess = NULL;

	if (len == maxlen)
 1104034:	eb00027f 	cmp	x19, x0
 1104038:	54000ac0 	b.eq	1104190 <ldelf_dlsym+0x1a0>  // b.none
		return TEE_ERROR_BAD_PARAMETERS;

	usr_stack -= ROUNDUP(sizeof(*arg) + len + 1, STACK_ALIGNMENT);
 110403c:	91018004 	add	x4, x0, #0x60
	arg = (struct dl_entry_arg *)usr_stack;

	res = vm_check_access_rights(uctx,
 1104040:	91008403 	add	x3, x0, #0x21
	usr_stack -= ROUNDUP(sizeof(*arg) + len + 1, STACK_ALIGNMENT);
 1104044:	927ae484 	and	x4, x4, #0xffffffffffffffc0
 1104048:	aa0003f5 	mov	x21, x0
 110404c:	cb040294 	sub	x20, x20, x4
	res = vm_check_access_rights(uctx,
 1104050:	aa1703e0 	mov	x0, x23
 1104054:	aa1403e2 	mov	x2, x20
 1104058:	528000e1 	mov	w1, #0x7                   	// #7
 110405c:	940055e4 	bl	11197ec <vm_check_access_rights>
 1104060:	2a0003f3 	mov	w19, w0
				     TEE_MEMORY_ACCESS_READ |
				     TEE_MEMORY_ACCESS_WRITE |
				     TEE_MEMORY_ACCESS_ANY_OWNER,
				     (uaddr_t)arg, sizeof(*arg) + len + 1);
	if (res) {
 1104064:	34000220 	cbz	w0, 11040a8 <ldelf_dlsym+0xb8>
		EMSG("ldelf stack is inaccessible!");
 1104068:	b0000264 	adrp	x4, 1151000 <small_prime+0x168>
 110406c:	b0000260 	adrp	x0, 1151000 <small_prime+0x168>
 1104070:	9108d884 	add	x4, x4, #0x236
 1104074:	910c3800 	add	x0, x0, #0x30e
 1104078:	52800023 	mov	w3, #0x1                   	// #1
 110407c:	52800022 	mov	w2, #0x1                   	// #1
 1104080:	528033a1 	mov	w1, #0x19d                 	// #413
 1104084:	94010330 	bl	1144d44 <trace_printf>
		if (!res)
			*val = arg->dlsym.val;
	}

	return res;
}
 1104088:	2a1303e0 	mov	w0, w19
 110408c:	a9417bfd 	ldp	x29, x30, [sp, #16]
 1104090:	a94253f3 	ldp	x19, x20, [sp, #32]
 1104094:	a9435bf5 	ldp	x21, x22, [sp, #48]
 1104098:	a94463f7 	ldp	x23, x24, [sp, #64]
 110409c:	a9456bf9 	ldp	x25, x26, [sp, #80]
 11040a0:	9101c3ff 	add	sp, sp, #0x70
 11040a4:	d65f03c0 	ret
	memset(arg, 0, sizeof(*arg));
 11040a8:	d2800402 	mov	x2, #0x20                  	// #32
 11040ac:	52800001 	mov	w1, #0x0                   	// #0
 11040b0:	aa1403e0 	mov	x0, x20
 11040b4:	9400ff0b 	bl	1143ce0 <memset>
	arg->cmd = LDELF_DL_ENTRY_DLSYM;
 11040b8:	aa1403e0 	mov	x0, x20
 11040bc:	5280003a 	mov	w26, #0x1                   	// #1
	arg->dlsym.uuid = *uuid;
 11040c0:	aa1903e1 	mov	x1, x25
 11040c4:	d2800202 	mov	x2, #0x10                  	// #16
	arg->cmd = LDELF_DL_ENTRY_DLSYM;
 11040c8:	b800841a 	str	w26, [x0], #8
	arg->dlsym.uuid = *uuid;
 11040cc:	97fffcb1 	bl	1103390 <memcpy>
	memcpy(arg->dlsym.symbol, sym, len);
 11040d0:	aa1503e2 	mov	x2, x21
	arg->dlsym.symbol[len] = '\0';
 11040d4:	8b150295 	add	x21, x20, x21
	memcpy(arg->dlsym.symbol, sym, len);
 11040d8:	aa1803e1 	mov	x1, x24
 11040dc:	91008280 	add	x0, x20, #0x20
 11040e0:	97fffcac 	bl	1103390 <memcpy>
	arg->dlsym.symbol[len] = '\0';
 11040e4:	390082bf 	strb	wzr, [x21, #32]
	sess = ts_get_current_session();
 11040e8:	9400423e 	bl	11149e0 <ts_get_current_session>
 11040ec:	aa0003f5 	mov	x21, x0
	sess->handle_svc = ldelf_handle_svc;
 11040f0:	d00002a0 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
	res = thread_enter_user_mode((vaddr_t)arg, 0, 0, 0,
 11040f4:	9101b3e7 	add	x7, sp, #0x6c
 11040f8:	f9412ee5 	ldr	x5, [x23, #600]
 11040fc:	aa1403e4 	mov	x4, x20
	sess->handle_svc = ldelf_handle_svc;
 1104100:	f9419800 	ldr	x0, [x0, #816]
 1104104:	f90012a0 	str	x0, [x21, #32]
	res = thread_enter_user_mode((vaddr_t)arg, 0, 0, 0,
 1104108:	9101a3e0 	add	x0, sp, #0x68
 110410c:	f90003e0 	str	x0, [sp]
 1104110:	52800006 	mov	w6, #0x0                   	// #0
 1104114:	d2800003 	mov	x3, #0x0                   	// #0
 1104118:	d2800002 	mov	x2, #0x0                   	// #0
 110411c:	d2800001 	mov	x1, #0x0                   	// #0
 1104120:	aa1403e0 	mov	x0, x20
 1104124:	9400081b 	bl	1106190 <thread_enter_user_mode>
 1104128:	2a0003f3 	mov	w19, w0
	sess->handle_svc = sess->ctx->ops->handle_svc;
 110412c:	f9400aa0 	ldr	x0, [x21, #16]
 1104130:	f9400800 	ldr	x0, [x0, #16]
 1104134:	f9401c00 	ldr	x0, [x0, #56]
 1104138:	f90012a0 	str	x0, [x21, #32]
	ldelf_sess_cleanup(sess);
 110413c:	aa1503e0 	mov	x0, x21
 1104140:	94003c35 	bl	1113214 <ldelf_sess_cleanup>
	if (panicked) {
 1104144:	b9406fe0 	ldr	w0, [sp, #108]
 1104148:	34000180 	cbz	w0, 1104178 <ldelf_dlsym+0x188>
		EMSG("ldelf dl_entry function panicked");
 110414c:	2a1a03e3 	mov	w3, w26
 1104150:	2a1a03e2 	mov	w2, w26
 1104154:	b0000264 	adrp	x4, 1151000 <small_prime+0x168>
 1104158:	b0000260 	adrp	x0, 1151000 <small_prime+0x168>
 110415c:	910a6484 	add	x4, x4, #0x299
 1104160:	910c3800 	add	x0, x0, #0x30e
 1104164:	52803641 	mov	w1, #0x1b2                 	// #434
		res = TEE_ERROR_TARGET_DEAD;
 1104168:	1299fb73 	mov	w19, #0xffff3024            	// #-53212
		EMSG("ldelf dl_entry function panicked");
 110416c:	940102f6 	bl	1144d44 <trace_printf>
		abort_print_current_ts();
 1104170:	94000d5d 	bl	11076e4 <abort_print_current_ts>
	if (!res) {
 1104174:	17ffffc5 	b	1104088 <ldelf_dlsym+0x98>
 1104178:	35fff893 	cbnz	w19, 1104088 <ldelf_dlsym+0x98>
		res = arg->ret;
 110417c:	b9400693 	ldr	w19, [x20, #4]
		if (!res)
 1104180:	35fff853 	cbnz	w19, 1104088 <ldelf_dlsym+0x98>
			*val = arg->dlsym.val;
 1104184:	f9400e80 	ldr	x0, [x20, #24]
 1104188:	f90002c0 	str	x0, [x22]
 110418c:	17ffffbf 	b	1104088 <ldelf_dlsym+0x98>
		return TEE_ERROR_BAD_PARAMETERS;
 1104190:	129fff33 	mov	w19, #0xffff0006            	// #-65530
 1104194:	17ffffbd 	b	1104088 <ldelf_dlsym+0x98>

0000000001104198 <register_time_source>:
#include <string.h>

struct time_source _time_source;

static TEE_Result register_time_source(void)
{
 1104198:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 110419c:	910003fd 	mov	x29, sp
	time_source_init();
 11041a0:	9400006e 	bl	1104358 <time_source_init>

	return TEE_SUCCESS;
}
 11041a4:	52800000 	mov	w0, #0x0                   	// #0
 11041a8:	a8c17bfd 	ldp	x29, x30, [sp], #16
 11041ac:	d65f03c0 	ret

00000000011041b0 <tee_time_get_sys_time>:
early_init(register_time_source);

TEE_Result tee_time_get_sys_time(TEE_Time *time)
{
	return _time_source.get_sys_time(time);
 11041b0:	d00002a1 	adrp	x1, 115a000 <__scattered_array_1phys_mem_map+0x8>
 11041b4:	f9417021 	ldr	x1, [x1, #736]
 11041b8:	f9400821 	ldr	x1, [x1, #16]
 11041bc:	aa0103f0 	mov	x16, x1
 11041c0:	d61f0200 	br	x16

00000000011041c4 <tee_time_get_sys_time_protection_level>:
}

uint32_t tee_time_get_sys_time_protection_level(void)
{
	return _time_source.protection_level;
 11041c4:	d00002a0 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
}
 11041c8:	f9417000 	ldr	x0, [x0, #736]
 11041cc:	b9400800 	ldr	w0, [x0, #8]
 11041d0:	d65f03c0 	ret

00000000011041d4 <tee_time_wait>:

void tee_time_wait(uint32_t milliseconds_delay)
{
 11041d4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	struct thread_param params =
 11041d8:	2a0003e0 	mov	w0, w0
 11041dc:	52800021 	mov	w1, #0x1                   	// #1
{
 11041e0:	910003fd 	mov	x29, sp
		THREAD_PARAM_VALUE(IN, milliseconds_delay, 0, 0);

	thread_rpc_cmd(OPTEE_RPC_CMD_SUSPEND, 1, &params);
 11041e4:	910043e2 	add	x2, sp, #0x10
	struct thread_param params =
 11041e8:	b90013e1 	str	w1, [sp, #16]
	thread_rpc_cmd(OPTEE_RPC_CMD_SUSPEND, 1, &params);
 11041ec:	d2800021 	mov	x1, #0x1                   	// #1
	struct thread_param params =
 11041f0:	a901ffe0 	stp	x0, xzr, [sp, #24]
	thread_rpc_cmd(OPTEE_RPC_CMD_SUSPEND, 1, &params);
 11041f4:	528000a0 	mov	w0, #0x5                   	// #5
	struct thread_param params =
 11041f8:	f90017ff 	str	xzr, [sp, #40]
	thread_rpc_cmd(OPTEE_RPC_CMD_SUSPEND, 1, &params);
 11041fc:	94000b58 	bl	1106f5c <thread_rpc_cmd>
}
 1104200:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1104204:	d65f03c0 	ret

0000000001104208 <tee_time_get_ree_time>:
 */
TEE_Result tee_time_get_ree_time(TEE_Time *time)
{
	TEE_Result res;

	if (!time)
 1104208:	b4000300 	cbz	x0, 1104268 <tee_time_get_ree_time+0x60>
{
 110420c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
		return TEE_ERROR_BAD_PARAMETERS;

	struct thread_param params = THREAD_PARAM_VALUE(OUT, 0, 0, 0);

	res = thread_rpc_cmd(OPTEE_RPC_CMD_GET_TIME, 1, &params);
 1104210:	d2800021 	mov	x1, #0x1                   	// #1
{
 1104214:	910003fd 	mov	x29, sp
 1104218:	f9000bf3 	str	x19, [sp, #16]
 110421c:	aa0003f3 	mov	x19, x0
	struct thread_param params = THREAD_PARAM_VALUE(OUT, 0, 0, 0);
 1104220:	52800040 	mov	w0, #0x2                   	// #2
	res = thread_rpc_cmd(OPTEE_RPC_CMD_GET_TIME, 1, &params);
 1104224:	910083e2 	add	x2, sp, #0x20
	struct thread_param params = THREAD_PARAM_VALUE(OUT, 0, 0, 0);
 1104228:	b90023e0 	str	w0, [sp, #32]
	res = thread_rpc_cmd(OPTEE_RPC_CMD_GET_TIME, 1, &params);
 110422c:	52800060 	mov	w0, #0x3                   	// #3
	struct thread_param params = THREAD_PARAM_VALUE(OUT, 0, 0, 0);
 1104230:	a902ffff 	stp	xzr, xzr, [sp, #40]
 1104234:	f9001fff 	str	xzr, [sp, #56]
	res = thread_rpc_cmd(OPTEE_RPC_CMD_GET_TIME, 1, &params);
 1104238:	94000b49 	bl	1106f5c <thread_rpc_cmd>
	if (res == TEE_SUCCESS) {
 110423c:	35000100 	cbnz	w0, 110425c <tee_time_get_ree_time+0x54>
		time->seconds = params.u.value.a;
 1104240:	f94017e1 	ldr	x1, [sp, #40]
 1104244:	b9000261 	str	w1, [x19]
		time->millis = params.u.value.b / 1000000;
 1104248:	f9401be1 	ldr	x1, [sp, #48]
 110424c:	d2884802 	mov	x2, #0x4240                	// #16960
 1104250:	f2a001e2 	movk	x2, #0xf, lsl #16
 1104254:	9ac20821 	udiv	x1, x1, x2
 1104258:	b9000661 	str	w1, [x19, #4]
	}

	return res;
}
 110425c:	f9400bf3 	ldr	x19, [sp, #16]
 1104260:	a8c47bfd 	ldp	x29, x30, [sp], #64
 1104264:	d65f03c0 	ret
		return TEE_ERROR_BAD_PARAMETERS;
 1104268:	129fff20 	mov	w0, #0xffff0006            	// #-65530
}
 110426c:	d65f03c0 	ret

0000000001104270 <tee_otp_get_hw_unique_key>:
 *
 * The default implementation just sets it to a constant.
 */

__weak TEE_Result tee_otp_get_hw_unique_key(struct tee_hw_unique_key *hwkey)
{
 1104270:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	memset(&hwkey->data[0], 0, sizeof(hwkey->data));
 1104274:	d2800202 	mov	x2, #0x10                  	// #16
 1104278:	52800001 	mov	w1, #0x0                   	// #0
{
 110427c:	910003fd 	mov	x29, sp
	memset(&hwkey->data[0], 0, sizeof(hwkey->data));
 1104280:	9400fe98 	bl	1143ce0 <memset>
	return TEE_SUCCESS;
}
 1104284:	52800000 	mov	w0, #0x0                   	// #0
 1104288:	a8c17bfd 	ldp	x29, x30, [sp], #16
 110428c:	d65f03c0 	ret

0000000001104290 <tee_otp_get_die_id>:

__weak int tee_otp_get_die_id(uint8_t *buffer, size_t len)
{
 1104290:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	if (huk_subkey_derive(HUK_SUBKEY_DIE_ID, NULL, 0, buffer, len))
 1104294:	aa0103e4 	mov	x4, x1
 1104298:	aa0003e3 	mov	x3, x0
{
 110429c:	910003fd 	mov	x29, sp
	if (huk_subkey_derive(HUK_SUBKEY_DIE_ID, NULL, 0, buffer, len))
 11042a0:	d2800002 	mov	x2, #0x0                   	// #0
 11042a4:	d2800001 	mov	x1, #0x0                   	// #0
 11042a8:	52800040 	mov	w0, #0x2                   	// #2
 11042ac:	940041e2 	bl	1114a34 <huk_subkey_derive>
 11042b0:	7100001f 	cmp	w0, #0x0
		return -1;

	return 0;
}
 11042b4:	5a9f03e0 	csetm	w0, ne  // ne = any
 11042b8:	a8c17bfd 	ldp	x29, x30, [sp], #16
 11042bc:	d65f03c0 	ret

00000000011042c0 <tee_otp_get_ta_enc_key>:
 *
 * The default implementation chooses option (1).
 */
__weak TEE_Result tee_otp_get_ta_enc_key(uint32_t key_type __maybe_unused,
					 uint8_t *buffer, size_t len)
{
 11042c0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 11042c4:	910003fd 	mov	x29, sp
	assert(key_type == SHDR_ENC_KEY_DEV_SPECIFIC);
 11042c8:	34000140 	cbz	w0, 11042f0 <tee_otp_get_ta_enc_key+0x30>
 11042cc:	b0000263 	adrp	x3, 1151000 <small_prime+0x168>
 11042d0:	b0000261 	adrp	x1, 1151000 <small_prime+0x168>
 11042d4:	910dd863 	add	x3, x3, #0x376
 11042d8:	910cbc21 	add	x1, x1, #0x32f
 11042dc:	b0000260 	adrp	x0, 1151000 <small_prime+0x168>
 11042e0:	910d4000 	add	x0, x0, #0x350
 11042e4:	528005e2 	mov	w2, #0x2f                  	// #47
 11042e8:	940037f1 	bl	11122ac <_assert_log>
 11042ec:	94003801 	bl	11122f0 <_assert_break>
 11042f0:	aa0103e3 	mov	x3, x1

	if (huk_subkey_derive(HUK_SUBKEY_TA_ENC, ta_pub_key_modulus,
 11042f4:	d00002a1 	adrp	x1, 115a000 <__scattered_array_1phys_mem_map+0x8>
 11042f8:	aa0203e4 	mov	x4, x2
 11042fc:	f9419020 	ldr	x0, [x1, #800]
 1104300:	f941f421 	ldr	x1, [x1, #1000]
 1104304:	f9400002 	ldr	x2, [x0]
 1104308:	52800080 	mov	w0, #0x4                   	// #4
 110430c:	940041ca 	bl	1114a34 <huk_subkey_derive>
			      ta_pub_key_modulus_size, buffer, len))
		return TEE_ERROR_SECURITY;
 1104310:	7100001f 	cmp	w0, #0x0

	return TEE_SUCCESS;
}
 1104314:	129ffe01 	mov	w1, #0xffff000f            	// #-65521
 1104318:	1a810000 	csel	w0, w0, w1, eq  // eq = none
 110431c:	a8c17bfd 	ldp	x29, x30, [sp], #16
 1104320:	d65f03c0 	ret

0000000001104324 <arm_cntpct_get_sys_time>:
#define TLBI_ASID_MASK		0xff

#ifndef __ASSEMBLER__
static inline __noprof void isb(void)
{
	asm volatile ("isb");
 1104324:	d5033fdf 	isb
DEFINE_U32_REG_READ_FUNC(contextidr_el1)
DEFINE_U32_REG_READ_FUNC(sctlr_el1)

/* ARM Generic timer functions */
DEFINE_REG_READ_FUNC_(cntfrq, uint32_t, cntfrq_el0)
DEFINE_REG_READ_FUNC_(cntpct, uint64_t, cntpct_el0)
 1104328:	d53be024 	mrs	x4, cntpct_el0
DEFINE_REG_READ_FUNC_(cntfrq, uint32_t, cntfrq_el0)
 110432c:	d53be002 	mrs	x2, cntfrq_el0
static TEE_Result arm_cntpct_get_sys_time(TEE_Time *time)
{
	uint64_t cntpct = barrier_read_cntpct();
	uint32_t cntfrq = read_cntfrq();

	time->seconds = cntpct / cntfrq;
 1104330:	92407c43 	and	x3, x2, #0xffffffff
 1104334:	9ac30881 	udiv	x1, x4, x3
 1104338:	b9000001 	str	w1, [x0]
	time->millis = (cntpct % cntfrq) / (cntfrq / TEE_TIME_MILLIS_BASE);
 110433c:	9b039021 	msub	x1, x1, x3, x4
 1104340:	52807d03 	mov	w3, #0x3e8                 	// #1000
 1104344:	1ac30842 	udiv	w2, w2, w3
 1104348:	9ac20821 	udiv	x1, x1, x2
 110434c:	b9000401 	str	w1, [x0, #4]

	return TEE_SUCCESS;
}
 1104350:	52800000 	mov	w0, #0x0                   	// #0
 1104354:	d65f03c0 	ret

0000000001104358 <time_source_init>:
	.name = "arm cntpct",
	.protection_level = 1000,
	.get_sys_time = arm_cntpct_get_sys_time,
};

REGISTER_TIME_SOURCE(arm_cntpct_time_source)
 1104358:	d00002a0 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 110435c:	b0000261 	adrp	x1, 1151000 <small_prime+0x168>
 1104360:	910e3421 	add	x1, x1, #0x38d
 1104364:	f9417000 	ldr	x0, [x0, #736]
 1104368:	f9000001 	str	x1, [x0]
 110436c:	52807d01 	mov	w1, #0x3e8                 	// #1000
 1104370:	b9000801 	str	w1, [x0, #8]
 1104374:	90000001 	adrp	x1, 1104000 <ldelf_dlsym+0x10>
 1104378:	910c9021 	add	x1, x1, #0x324
 110437c:	f9000801 	str	x1, [x0, #16]
 1104380:	d65f03c0 	ret

0000000001104384 <plat_prng_add_jitter_entropy>:
 *
 * and adding one byte of entropy when we reach 8 rotated bits.
 */

void plat_prng_add_jitter_entropy(enum crypto_rng_src sid, unsigned int *pnum)
{
 1104384:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1104388:	910003fd 	mov	x29, sp
 110438c:	a90153f3 	stp	x19, x20, [sp, #16]
 1104390:	2a0003f3 	mov	w19, w0
 1104394:	aa0103f4 	mov	x20, x1
 1104398:	a9025bf5 	stp	x21, x22, [sp, #32]
	asm volatile ("isb");
 110439c:	d5033fdf 	isb
DEFINE_REG_READ_FUNC_(cntpct, uint64_t, cntpct_el0)
 11043a0:	d53be021 	mrs	x1, cntpct_el0
	uint64_t tsc = barrier_read_cntpct();
	int bytes = 0, n;
	static uint8_t first, bits;
	static uint16_t acc;

	if (!first) {
 11043a4:	90000320 	adrp	x0, 1168000 <data.5093+0x9e28>
 11043a8:	90000324 	adrp	x4, 1168000 <data.5093+0x9e28>
 11043ac:	396a3c02 	ldrb	w2, [x0, #2703]
 11043b0:	35000362 	cbnz	w2, 110441c <plat_prng_add_jitter_entropy+0x98>
		acc = tsc;
 11043b4:	79151881 	strh	w1, [x4, #2700]
		bytes = 2;
 11043b8:	52800055 	mov	w21, #0x2                   	// #2
		first = 1;
 11043bc:	52800021 	mov	w1, #0x1                   	// #1
 11043c0:	392a3c01 	strb	w1, [x0, #2703]
			bits = 0;
			bytes = 1;
		}
	}
	if (bytes) {
		FMSG("0x%02X", (int)acc & ((1 << (bytes * 8)) - 1));
 11043c4:	531d72a2 	lsl	w2, w21, #3
 11043c8:	79551885 	ldrh	w5, [x4, #2700]
 11043cc:	52800023 	mov	w3, #0x1                   	// #1
 11043d0:	912a3096 	add	x22, x4, #0xa8c
 11043d4:	1ac22062 	lsl	w2, w3, w2
 11043d8:	51000442 	sub	w2, w2, #0x1
 11043dc:	0a050045 	and	w5, w2, w5
 11043e0:	52800901 	mov	w1, #0x48                  	// #72
 11043e4:	52800082 	mov	w2, #0x4                   	// #4
 11043e8:	b0000264 	adrp	x4, 1151000 <small_prime+0x168>
 11043ec:	b0000260 	adrp	x0, 1151000 <small_prime+0x168>
 11043f0:	910e6084 	add	x4, x4, #0x398
 11043f4:	910e7c00 	add	x0, x0, #0x39f
 11043f8:	94010253 	bl	1144d44 <trace_printf>
		crypto_rng_add_event(sid, pnum, (uint8_t *)&acc, bytes);
 11043fc:	93407ea3 	sxtw	x3, w21
 1104400:	aa1603e2 	mov	x2, x22
 1104404:	aa1403e1 	mov	x1, x20
 1104408:	2a1303e0 	mov	w0, w19
	}
}
 110440c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1104410:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1104414:	a8c37bfd 	ldp	x29, x30, [sp], #48
		crypto_rng_add_event(sid, pnum, (uint8_t *)&acc, bytes);
 1104418:	14002be9 	b	110f3bc <crypto_rng_add_event>
		acc = (acc << 2) | ((acc >> 6) & 3);
 110441c:	79551882 	ldrh	w2, [x4, #2700]
		for (n = 0; n < 64; n += 2)
 1104420:	52800003 	mov	w3, #0x0                   	// #0
		acc = (acc << 2) | ((acc >> 6) & 3);
 1104424:	d3461c40 	ubfx	x0, x2, #6, #2
 1104428:	2a020802 	orr	w2, w0, w2, lsl #2
 110442c:	12003c42 	and	w2, w2, #0xffff
			acc ^= (tsc >> n) & 3;
 1104430:	9ac32420 	lsr	x0, x1, x3
		for (n = 0; n < 64; n += 2)
 1104434:	11000863 	add	w3, w3, #0x2
			acc ^= (tsc >> n) & 3;
 1104438:	12000400 	and	w0, w0, #0x3
		for (n = 0; n < 64; n += 2)
 110443c:	7101007f 	cmp	w3, #0x40
			acc ^= (tsc >> n) & 3;
 1104440:	4a000042 	eor	w2, w2, w0
		for (n = 0; n < 64; n += 2)
 1104444:	54ffff61 	b.ne	1104430 <plat_prng_add_jitter_entropy+0xac>  // b.any
		bits += 2;
 1104448:	90000320 	adrp	x0, 1168000 <data.5093+0x9e28>
 110444c:	79151882 	strh	w2, [x4, #2700]
 1104450:	396a3802 	ldrb	w2, [x0, #2702]
 1104454:	11000842 	add	w2, w2, #0x2
 1104458:	12001c42 	and	w2, w2, #0xff
		if (bits >= 8) {
 110445c:	71001c5f 	cmp	w2, #0x7
 1104460:	540000c8 	b.hi	1104478 <plat_prng_add_jitter_entropy+0xf4>  // b.pmore
		bits += 2;
 1104464:	392a3802 	strb	w2, [x0, #2702]
}
 1104468:	a94153f3 	ldp	x19, x20, [sp, #16]
 110446c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1104470:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1104474:	d65f03c0 	ret
			bits = 0;
 1104478:	392a381f 	strb	wzr, [x0, #2702]
			bytes = 1;
 110447c:	52800035 	mov	w21, #0x1                   	// #1
 1104480:	17ffffd1 	b	11043c4 <plat_prng_add_jitter_entropy+0x40>

0000000001104484 <__cpu_spin_lock>:
#include <asm.S>
#include <kernel/spinlock.h>

/* void __cpu_spin_lock(unsigned int *lock); */
FUNC __cpu_spin_lock , :
	mov	w2, #SPINLOCK_LOCK
 1104484:	52800022 	mov	w2, #0x1                   	// #1
	sevl
 1104488:	d50320bf 	sevl

000000000110448c <l1>:
l1:	wfe
 110448c:	d503205f 	wfe

0000000001104490 <l2>:
l2:	ldaxr	w1, [x0]
 1104490:	885ffc01 	ldaxr	w1, [x0]
	cbnz	w1, l1
 1104494:	35ffffc1 	cbnz	w1, 110448c <l1>
	stxr	w1, w2, [x0]
 1104498:	88017c02 	stxr	w1, w2, [x0]
	cbnz	w1, l2
 110449c:	35ffffa1 	cbnz	w1, 1104490 <l2>
	ret
 11044a0:	d65f03c0 	ret

00000000011044a4 <__cpu_spin_trylock>:
END_FUNC __cpu_spin_lock

/* unsigned int __cpu_spin_trylock(unsigned int *lock); */
FUNC __cpu_spin_trylock , :
	mov     x1, x0
 11044a4:	aa0003e1 	mov	x1, x0
	mov     w2, #SPINLOCK_LOCK
 11044a8:	52800022 	mov	w2, #0x1                   	// #1

00000000011044ac <.loop>:
.loop:	ldaxr   w0, [x1]
 11044ac:	885ffc20 	ldaxr	w0, [x1]
	cbnz    w0, .cpu_spin_trylock_out
 11044b0:	35000060 	cbnz	w0, 11044bc <.cpu_spin_trylock_out>
	stxr    w0, w2, [x1]
 11044b4:	88007c22 	stxr	w0, w2, [x1]
	cbnz    w0, .loop
 11044b8:	35ffffa0 	cbnz	w0, 11044ac <.loop>

00000000011044bc <.cpu_spin_trylock_out>:
.cpu_spin_trylock_out:
	ret
 11044bc:	d65f03c0 	ret

00000000011044c0 <__cpu_spin_unlock>:
END_FUNC __cpu_spin_trylock

/* void __cpu_spin_unlock(unsigned int *lock); */
FUNC __cpu_spin_unlock , :
	stlr	wzr, [x0]
 11044c0:	889ffc1f 	stlr	wzr, [x0]
	ret
 11044c4:	d65f03c0 	ret

00000000011044c8 <spinlock_count_incr>:
#include <compiler.h>
#include <kernel/spinlock.h>
#include "thread_private.h"

void spinlock_count_incr(void)
{
 11044c8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 11044cc:	910003fd 	mov	x29, sp
	struct thread_core_local *l = thread_get_core_local();
 11044d0:	94000329 	bl	1105174 <thread_get_core_local>

	l->locked_count++;
 11044d4:	b9403801 	ldr	w1, [x0, #56]
 11044d8:	11000421 	add	w1, w1, #0x1
 11044dc:	b9003801 	str	w1, [x0, #56]
	assert(l->locked_count);
 11044e0:	35000141 	cbnz	w1, 1104508 <spinlock_count_incr+0x40>
 11044e4:	b0000263 	adrp	x3, 1151000 <small_prime+0x168>
 11044e8:	b0000261 	adrp	x1, 1151000 <small_prime+0x168>
 11044ec:	910fcc63 	add	x3, x3, #0x3f3
 11044f0:	910ef021 	add	x1, x1, #0x3bc
 11044f4:	b0000260 	adrp	x0, 1151000 <small_prime+0x168>
 11044f8:	910f8c00 	add	x0, x0, #0x3e3
 11044fc:	52800202 	mov	w2, #0x10                  	// #16
 1104500:	9400376b 	bl	11122ac <_assert_log>
 1104504:	9400377b 	bl	11122f0 <_assert_break>
}
 1104508:	a8c17bfd 	ldp	x29, x30, [sp], #16
 110450c:	d65f03c0 	ret

0000000001104510 <spinlock_count_decr>:

void spinlock_count_decr(void)
{
 1104510:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 1104514:	910003fd 	mov	x29, sp
	struct thread_core_local *l = thread_get_core_local();
 1104518:	94000317 	bl	1105174 <thread_get_core_local>

	assert(l->locked_count);
 110451c:	b9403801 	ldr	w1, [x0, #56]
 1104520:	35000141 	cbnz	w1, 1104548 <spinlock_count_decr+0x38>
 1104524:	b0000263 	adrp	x3, 1151000 <small_prime+0x168>
 1104528:	b0000261 	adrp	x1, 1151000 <small_prime+0x168>
 110452c:	91101c63 	add	x3, x3, #0x407
 1104530:	910ef021 	add	x1, x1, #0x3bc
 1104534:	b0000260 	adrp	x0, 1151000 <small_prime+0x168>
 1104538:	910f8c00 	add	x0, x0, #0x3e3
 110453c:	528002e2 	mov	w2, #0x17                  	// #23
 1104540:	9400375b 	bl	11122ac <_assert_log>
 1104544:	9400376b 	bl	11122f0 <_assert_break>
	l->locked_count--;
 1104548:	51000421 	sub	w1, w1, #0x1
 110454c:	b9003801 	str	w1, [x0, #56]
}
 1104550:	a8c17bfd 	ldp	x29, x30, [sp], #16
 1104554:	d65f03c0 	ret

0000000001104558 <have_spinlock>:

bool __nostackcheck have_spinlock(void)
{
 1104558:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 110455c:	910003fd 	mov	x29, sp
void thread_unmask_exceptions(uint32_t state);


static inline bool __nostackcheck thread_foreign_intr_disabled(void)
{
	return !!(thread_get_exceptions() & THREAD_EXCP_FOREIGN_INTR);
 1104560:	9400026d 	bl	1104f14 <thread_get_exceptions>
	struct thread_core_local *l;

	if (!thread_foreign_intr_disabled()) {
 1104564:	360800e0 	tbz	w0, #1, 1104580 <have_spinlock+0x28>
		 * logic is flawed).
		 */
		return false;
	}

	l = thread_get_core_local();
 1104568:	94000303 	bl	1105174 <thread_get_core_local>

	return !!l->locked_count;
 110456c:	b9403800 	ldr	w0, [x0, #56]
 1104570:	7100001f 	cmp	w0, #0x0
 1104574:	1a9f07e0 	cset	w0, ne  // ne = any
}
 1104578:	a8c17bfd 	ldp	x29, x30, [sp], #16
 110457c:	d65f03c0 	ret
		return false;
 1104580:	52800000 	mov	w0, #0x0                   	// #0
 1104584:	17fffffd 	b	1104578 <have_spinlock+0x20>

0000000001104588 <tlbi_all>:
#include <asm.S>
#include <util.h>

/* void tlbi_all(void); */
FUNC tlbi_all , :
	dsb	ishst		/* Sync with table update */
 1104588:	d5033a9f 	dsb	ishst
	tlbi	vmalle1is	/* All tlb in inner shareable */
 110458c:	d508831f 	tlbi	vmalle1is
	dsb	ish		/* Sync with tlb invalidation completion */
 1104590:	d5033b9f 	dsb	ish
	isb			/* Sync execution on tlb update */
 1104594:	d5033fdf 	isb
	ret
 1104598:	d65f03c0 	ret

000000000110459c <tlbi_asid>:
	ret
END_FUNC tlbi_mva_allasid

/* void tlbi_asid(unsigned int asid); */
FUNC tlbi_asid , :
	lsl	x0, x0, #TLBI_ASID_SHIFT
 110459c:	d3503c00 	lsl	x0, x0, #48
	dsb	ishst		/* Sync with table update */
 11045a0:	d5033a9f 	dsb	ishst
	tlbi	aside1is, x0	/* Invalidate tlb by asid in inner shareable */
 11045a4:	d5088340 	tlbi	aside1is, x0
	orr	x0, x0, #BIT(TLBI_ASID_SHIFT) /* Select the kernel ASID */
 11045a8:	b2500000 	orr	x0, x0, #0x1000000000000
	tlbi	aside1is, x0	/* Invalidate tlb by asid in inner shareable */
 11045ac:	d5088340 	tlbi	aside1is, x0
	dsb	ish		/* Sync with tlb invalidation completion */
 11045b0:	d5033b9f 	dsb	ish
	isb			/* Sync execution on tlb update */
 11045b4:	d5033fdf 	isb
	ret
 11045b8:	d65f03c0 	ret

00000000011045bc <dcache_cleaninv_range>:
	 * Clean+Invalidate from base address till
	 * size. 'x0' = addr, 'x1' = size
	 * ------------------------------------------
	 */
FUNC dcache_cleaninv_range , :
	do_dcache_maintenance_by_mva civac
 11045bc:	d53b0023 	mrs	x3, ctr_el0
 11045c0:	d3504c63 	ubfx	x3, x3, #16, #4
 11045c4:	d2800082 	mov	x2, #0x4                   	// #4
 11045c8:	9ac32042 	lsl	x2, x2, x3
 11045cc:	8b010001 	add	x1, x0, x1
 11045d0:	d1000443 	sub	x3, x2, #0x1
 11045d4:	8a230000 	bic	x0, x0, x3

00000000011045d8 <loop_civac>:
 11045d8:	d50b7e20 	dc	civac, x0
 11045dc:	8b020000 	add	x0, x0, x2
 11045e0:	eb01001f 	cmp	x0, x1
 11045e4:	54ffffa3 	b.cc	11045d8 <loop_civac>  // b.lo, b.ul, b.last
 11045e8:	d5033f9f 	dsb	sy
 11045ec:	d65f03c0 	ret

00000000011045f0 <dcache_clean_range>:
	 * Clean from base address till size.
	 * 'x0' = addr, 'x1' = size
	 * ------------------------------------------
	 */
FUNC dcache_clean_range , :
	do_dcache_maintenance_by_mva cvac
 11045f0:	d53b0023 	mrs	x3, ctr_el0
 11045f4:	d3504c63 	ubfx	x3, x3, #16, #4
 11045f8:	d2800082 	mov	x2, #0x4                   	// #4
 11045fc:	9ac32042 	lsl	x2, x2, x3
 1104600:	8b010001 	add	x1, x0, x1
 1104604:	d1000443 	sub	x3, x2, #0x1
 1104608:	8a230000 	bic	x0, x0, x3

000000000110460c <loop_cvac>:
 110460c:	d50b7a20 	dc	cvac, x0
 1104610:	8b020000 	add	x0, x0, x2
 1104614:	eb01001f 	cmp	x0, x1
 1104618:	54ffffa3 	b.cc	110460c <loop_cvac>  // b.lo, b.ul, b.last
 110461c:	d5033f9f 	dsb	sy
 1104620:	d65f03c0 	ret

0000000001104624 <dcache_inv_range>:
	 * Invalidate from base address till
	 * size. 'x0' = addr, 'x1' = size
	 * ------------------------------------------
	 */
FUNC dcache_inv_range , :
	do_dcache_maintenance_by_mva ivac
 1104624:	d53b0023 	mrs	x3, ctr_el0
 1104628:	d3504c63 	ubfx	x3, x3, #16, #4
 110462c:	d2800082 	mov	x2, #0x4                   	// #4
 1104630:	9ac32042 	lsl	x2, x2, x3
 1104634:	8b010001 	add	x1, x0, x1
 1104638:	d1000443 	sub	x3, x2, #0x1
 110463c:	8a230000 	bic	x0, x0, x3

0000000001104640 <loop_ivac>:
 1104640:	d5087620 	dc	ivac, x0
 1104644:	8b020000 	add	x0, x0, x2
 1104648:	eb01001f 	cmp	x0, x1
 110464c:	54ffffa3 	b.cc	1104640 <loop_ivac>  // b.lo, b.ul, b.last
 1104650:	d5033f9f 	dsb	sy
 1104654:	d65f03c0 	ret

0000000001104658 <do_dcsw_op>:
	mov	x10, xzr
	b	do_dcsw_op
	.endm

LOCAL_FUNC do_dcsw_op , :
	cbz	x3, exit
 1104658:	b40003c3 	cbz	x3, 11046d0 <exit>
	adr	x14, dcsw_loop_table	// compute inner loop address
 110465c:	100003ce 	adr	x14, 11046d4 <dcsw_loop_table>
	add	x14, x14, x0, lsl #5	// inner loop is 8x32-bit instructions
 1104660:	8b0015ce 	add	x14, x14, x0, lsl #5
	mov	x0, x9
 1104664:	aa0903e0 	mov	x0, x9
	mov	w8, #1
 1104668:	52800028 	mov	w8, #0x1                   	// #1

000000000110466c <loop1>:
loop1:
	add	x2, x10, x10, lsr #1	// work out 3x current cache level
 110466c:	8b4a0542 	add	x2, x10, x10, lsr #1
	lsr	x1, x0, x2		// extract cache type bits from clidr
 1104670:	9ac22401 	lsr	x1, x0, x2
	and	x1, x1, #7		// mask the bits for current cache only
 1104674:	92400821 	and	x1, x1, #0x7
	cmp	x1, #2			// see what cache we have at this level
 1104678:	f100083f 	cmp	x1, #0x2
	b.lo	level_done		// nothing to do if no cache or icache
 110467c:	540001e3 	b.cc	11046b8 <level_done>  // b.lo, b.ul, b.last

	msr	csselr_el1, x10		// select current cache level in csselr
 1104680:	d51a000a 	msr	csselr_el1, x10
	isb				// isb to sych the new cssr&csidr
 1104684:	d5033fdf 	isb
	mrs	x1, ccsidr_el1		// read the new ccsidr
 1104688:	d5390001 	mrs	x1, ccsidr_el1
	and	x2, x1, #7		// extract the length of the cache lines
 110468c:	92400822 	and	x2, x1, #0x7
	add	x2, x2, #4		// add 4 (line length offset)
 1104690:	91001042 	add	x2, x2, #0x4
	ubfx	x4, x1, #3, #10		// maximum way number
 1104694:	d3433024 	ubfx	x4, x1, #3, #10
	clz	w5, w4			// bit position of way size increment
 1104698:	5ac01085 	clz	w5, w4
	lsl	w9, w4, w5		// w9 = aligned max way number
 110469c:	1ac52089 	lsl	w9, w4, w5
	lsl	w16, w8, w5		// w16 = way number loop decrement
 11046a0:	1ac52110 	lsl	w16, w8, w5
	orr	w9, w10, w9		// w9 = combine way and cache number
 11046a4:	2a090149 	orr	w9, w10, w9
	ubfx	w6, w1, #13, #15	// w6 = max set number
 11046a8:	530d6c26 	ubfx	w6, w1, #13, #15
	lsl	w17, w8, w2		// w17 = set number loop decrement
 11046ac:	1ac22111 	lsl	w17, w8, w2
	dsb	sy			// barrier before we start this level
 11046b0:	d5033f9f 	dsb	sy
	br	x14			// jump to DC operation specific loop
 11046b4:	d61f01c0 	br	x14

00000000011046b8 <level_done>:

	b	level_done
	.endm

level_done:
	add	x10, x10, #2		// increment cache number
 11046b8:	9100094a 	add	x10, x10, #0x2
	cmp	x3, x10
 11046bc:	eb0a007f 	cmp	x3, x10
	b.hi    loop1
 11046c0:	54fffd68 	b.hi	110466c <loop1>  // b.pmore
	msr	csselr_el1, xzr		// select cache level 0 in csselr
 11046c4:	d51a001f 	msr	csselr_el1, xzr
	dsb	sy			// barrier to complete final cache operation
 11046c8:	d5033f9f 	dsb	sy
	isb
 11046cc:	d5033fdf 	isb

00000000011046d0 <exit>:
exit:
	ret
 11046d0:	d65f03c0 	ret

00000000011046d4 <dcsw_loop_table>:

dcsw_loop_table:
	dcsw_loop isw
 11046d4:	1ac220c7 	lsl	w7, w6, w2

00000000011046d8 <loop3_isw>:
 11046d8:	2a07012b 	orr	w11, w9, w7
 11046dc:	d508764b 	dc	isw, x11
 11046e0:	6b1100e7 	subs	w7, w7, w17
 11046e4:	54ffffa2 	b.cs	11046d8 <loop3_isw>  // b.hs, b.nlast
 11046e8:	eb100129 	subs	x9, x9, x16
 11046ec:	54ffff42 	b.cs	11046d4 <dcsw_loop_table>  // b.hs, b.nlast
 11046f0:	17fffff2 	b	11046b8 <level_done>

00000000011046f4 <loop2_cisw>:
	dcsw_loop cisw
 11046f4:	1ac220c7 	lsl	w7, w6, w2

00000000011046f8 <loop3_cisw>:
 11046f8:	2a07012b 	orr	w11, w9, w7
 11046fc:	d5087e4b 	dc	cisw, x11
 1104700:	6b1100e7 	subs	w7, w7, w17
 1104704:	54ffffa2 	b.cs	11046f8 <loop3_cisw>  // b.hs, b.nlast
 1104708:	eb100129 	subs	x9, x9, x16
 110470c:	54ffff42 	b.cs	11046f4 <loop2_cisw>  // b.hs, b.nlast
 1104710:	17ffffea 	b	11046b8 <level_done>

0000000001104714 <loop2_csw>:
	dcsw_loop csw
 1104714:	1ac220c7 	lsl	w7, w6, w2

0000000001104718 <loop3_csw>:
 1104718:	2a07012b 	orr	w11, w9, w7
 110471c:	d5087a4b 	dc	csw, x11
 1104720:	6b1100e7 	subs	w7, w7, w17
 1104724:	54ffffa2 	b.cs	1104718 <loop3_csw>  // b.hs, b.nlast
 1104728:	eb100129 	subs	x9, x9, x16
 110472c:	54ffff42 	b.cs	1104714 <loop2_csw>  // b.hs, b.nlast
 1104730:	17ffffe2 	b	11046b8 <level_done>

0000000001104734 <dcache_op_louis>:
END_FUNC do_dcsw_op

FUNC dcache_op_louis , :
	dcsw_op #CLIDR_LOUIS_SHIFT, #CLIDR_FIELD_WIDTH, #CSSELR_LEVEL_SHIFT
 1104734:	d5390029 	mrs	x9, clidr_el1
 1104738:	d3555d23 	ubfx	x3, x9, #21, #3
 110473c:	d37ff863 	lsl	x3, x3, #1
 1104740:	aa1f03ea 	mov	x10, xzr
 1104744:	17ffffc5 	b	1104658 <do_dcsw_op>

0000000001104748 <dcache_op_all>:
END_FUNC dcache_op_louis

FUNC dcache_op_all , :
	dcsw_op #CLIDR_LOC_SHIFT, #CLIDR_FIELD_WIDTH, #CSSELR_LEVEL_SHIFT
 1104748:	d5390029 	mrs	x9, clidr_el1
 110474c:	d3586923 	ubfx	x3, x9, #24, #3
 1104750:	d37ff863 	lsl	x3, x3, #1
 1104754:	aa1f03ea 	mov	x10, xzr
 1104758:	17ffffc0 	b	1104658 <do_dcsw_op>

000000000110475c <icache_inv_all>:
	dcsw_op_level #(3 << CSSELR_LEVEL_SHIFT)
END_FUNC dcache_op_level3

FUNC icache_inv_all , :
	/* Invalidate Entire Instruction Cache */
	ic	ialluis
 110475c:	d508711f 	ic	ialluis

	dsb	ish	/* ensure that maintenance operations are seen */
 1104760:	d5033b9f 	dsb	ish
	isb		/* by the instructions rigth after the isb */
 1104764:	d5033fdf 	isb

	ret
 1104768:	d65f03c0 	ret

000000000110476c <icache_inv_range>:
END_FUNC icache_inv_all

FUNC icache_inv_range , :
	icache_line_size x2, x3
 110476c:	d53b0023 	mrs	x3, ctr_el0
 1104770:	92400c63 	and	x3, x3, #0xf
 1104774:	d2800082 	mov	x2, #0x4                   	// #4
 1104778:	9ac32042 	lsl	x2, x2, x3
	add	x1, x0, x1
 110477c:	8b010001 	add	x1, x0, x1
	sub	x3, x2, #1
 1104780:	d1000443 	sub	x3, x2, #0x1
	bic	x0, x0, x3
 1104784:	8a230000 	bic	x0, x0, x3

0000000001104788 <loop_ic_inv>:
loop_ic_inv:
	ic	ivau, x0
 1104788:	d50b7520 	ic	ivau, x0
	add	x0, x0, x2
 110478c:	8b020000 	add	x0, x0, x2
	cmp	x0, x1
 1104790:	eb01001f 	cmp	x0, x1
	b.lo    loop_ic_inv
 1104794:	54ffffa3 	b.cc	1104788 <loop_ic_inv>  // b.lo, b.ul, b.last
	dsb	ish
 1104798:	d5033b9f 	dsb	ish
	ret
 110479c:	d65f03c0 	ret

00000000011047a0 <thread_resume>:
	load_xregs x0, THREAD_CTX_REGS_SP, 1, 3
 11047a0:	a9400801 	ldp	x1, x2, [x0]
 11047a4:	f9400803 	ldr	x3, [x0, #16]
	load_xregs x0, THREAD_CTX_REGS_X4, 4, 30
 11047a8:	a9439404 	ldp	x4, x5, [x0, #56]
 11047ac:	a9449c06 	ldp	x6, x7, [x0, #72]
 11047b0:	a945a408 	ldp	x8, x9, [x0, #88]
 11047b4:	a946ac0a 	ldp	x10, x11, [x0, #104]
 11047b8:	a947b40c 	ldp	x12, x13, [x0, #120]
 11047bc:	a948bc0e 	ldp	x14, x15, [x0, #136]
 11047c0:	a949c410 	ldp	x16, x17, [x0, #152]
 11047c4:	a94acc12 	ldp	x18, x19, [x0, #168]
 11047c8:	a94bd414 	ldp	x20, x21, [x0, #184]
 11047cc:	a94cdc16 	ldp	x22, x23, [x0, #200]
 11047d0:	a94de418 	ldp	x24, x25, [x0, #216]
 11047d4:	a94eec1a 	ldp	x26, x27, [x0, #232]
 11047d8:	a94ff41c 	ldp	x28, x29, [x0, #248]
 11047dc:	f940841e 	ldr	x30, [x0, #264]
	mov	sp, x1
 11047e0:	9100003f 	mov	sp, x1
	msr	elr_el1, x2
 11047e4:	d5184022 	msr	elr_el1, x2
	msr	spsr_el1, x3
 11047e8:	d5184003 	msr	spsr_el1, x3
	ldr	x1, [x0, THREAD_CTX_REGS_TPIDR_EL0]
 11047ec:	f9408801 	ldr	x1, [x0, #272]
	msr	tpidr_el0, x1
 11047f0:	d51bd041 	msr	tpidr_el0, x1
	b_if_spsr_is_el0 w3, 1f
 11047f4:	37800123 	tbnz	w3, #16, 1104818 <thread_resume+0x78>
 11047f8:	721e047f 	tst	w3, #0xc
 11047fc:	540000e0 	b.eq	1104818 <thread_resume+0x78>  // b.none
	load_xregs x0, THREAD_CTX_REGS_X1, 1, 3
 1104800:	a9420801 	ldp	x1, x2, [x0, #32]
 1104804:	f9401803 	ldr	x3, [x0, #48]
	ldr	x0, [x0, THREAD_CTX_REGS_X0]
 1104808:	f9400c00 	ldr	x0, [x0, #24]
	return_from_exception
 110480c:	d69f03e0 	eret
 1104810:	d503379f 	dsb	nsh
 1104814:	d5033fdf 	isb
1:	load_xregs x0, THREAD_CTX_REGS_X1, 1, 3
 1104818:	a9420801 	ldp	x1, x2, [x0, #32]
 110481c:	f9401803 	ldr	x3, [x0, #48]
	ldr	x0, [x0, THREAD_CTX_REGS_X0]
 1104820:	f9400c00 	ldr	x0, [x0, #24]
	msr	spsel, #1
 1104824:	d50041bf 	msr	spsel, #0x1
	store_xregs sp, THREAD_CORE_LOCAL_X0, 0, 1
 1104828:	a90007e0 	stp	x0, x1, [sp]
	b	eret_to_el0
 110482c:	17fff9d6 	b	1102f84 <eret_to_el0>

0000000001104830 <thread_smc>:
	smc	#0
 1104830:	d4000003 	smc	#0x0
	ret
 1104834:	d65f03c0 	ret

0000000001104838 <thread_init_vbar>:
	msr	vbar_el1, x0
 1104838:	d518c000 	msr	vbar_el1, x0
	ret
 110483c:	d65f03c0 	ret

0000000001104840 <thread_unwind_user_mode>:
	load_xregs sp, THREAD_USER_MODE_REC_CTX_REGS_PTR, 3, 5
 1104840:	a94013e3 	ldp	x3, x4, [sp]
 1104844:	f9400be5 	ldr	x5, [sp, #16]
	str	w1, [x4]
 1104848:	b9000081 	str	w1, [x4]
	str	w2, [x5]
 110484c:	b90000a2 	str	w2, [x5]
	store_xregs x3, THREAD_CTX_REGS_X19, 19, 30
 1104850:	a90b5073 	stp	x19, x20, [x3, #176]
 1104854:	a90c5875 	stp	x21, x22, [x3, #192]
 1104858:	a90d6077 	stp	x23, x24, [x3, #208]
 110485c:	a90e6879 	stp	x25, x26, [x3, #224]
 1104860:	a90f707b 	stp	x27, x28, [x3, #240]
 1104864:	a910787d 	stp	x29, x30, [x3, #256]
	load_xregs sp, THREAD_USER_MODE_REC_X19, 19, 30
 1104868:	a94253f3 	ldp	x19, x20, [sp, #32]
 110486c:	a9435bf5 	ldp	x21, x22, [sp, #48]
 1104870:	a94463f7 	ldp	x23, x24, [sp, #64]
 1104874:	a9456bf9 	ldp	x25, x26, [sp, #80]
 1104878:	a94673fb 	ldp	x27, x28, [sp, #96]
 110487c:	a9477bfd 	ldp	x29, x30, [sp, #112]
	add	sp, sp, #THREAD_USER_MODE_REC_SIZE
 1104880:	910203ff 	add	sp, sp, #0x80
	ret
 1104884:	d65f03c0 	ret

0000000001104888 <el1_sync_abort>:
	mov	x0, sp
 1104888:	910003e0 	mov	x0, sp
	msr	spsel, #0
 110488c:	d50040bf 	msr	spsel, #0x0
	mov	x3, sp		/* Save original sp */
 1104890:	910003e3 	mov	x3, sp
	ldr	w1, [x0, #THREAD_CORE_LOCAL_FLAGS]
 1104894:	b9402c01 	ldr	w1, [x0, #44]
	lsl	w1, w1, #THREAD_CLF_SAVED_SHIFT
 1104898:	531c6c21 	lsl	w1, w1, #4
	orr	w1, w1, #THREAD_CLF_ABORT
 110489c:	321f0021 	orr	w1, w1, #0x2
	tbnz	w1, #(THREAD_CLF_SAVED_SHIFT + THREAD_CLF_ABORT_SHIFT), \
 11048a0:	37280061 	tbnz	w1, #5, 11048ac <el1_sync_abort+0x24>
	ldr	x2, [x0, #THREAD_CORE_LOCAL_ABT_STACK_VA_END]
 11048a4:	f9401802 	ldr	x2, [x0, #48]
	b	.Lset_sp
 11048a8:	14000003 	b	11048b4 <el1_sync_abort+0x2c>
	ldr	x2, [x0, #THREAD_CORE_LOCAL_TMP_STACK_VA_END]
 11048ac:	f9401002 	ldr	x2, [x0, #32]
	orr	w1, w1, #THREAD_CLF_TMP	/* flags |= THREAD_CLF_TMP; */
 11048b0:	32000021 	orr	w1, w1, #0x1
	mov	sp, x2
 11048b4:	9100005f 	mov	sp, x2
	str	w1, [x0, #THREAD_CORE_LOCAL_FLAGS]
 11048b8:	b9002c01 	str	w1, [x0, #44]
	sub	sp, sp, #THREAD_ABT_REGS_SIZE
 11048bc:	d10443ff 	sub	sp, sp, #0x110
	mrs	x2, spsr_el1
 11048c0:	d5384002 	mrs	x2, spsr_el1
	stp	x2, x3, [sp, #THREAD_ABT_REG_SPSR]
 11048c4:	a9100fe2 	stp	x2, x3, [sp, #256]
	ldp	x2, x3, [x0, #THREAD_CORE_LOCAL_X0]
 11048c8:	a9400c02 	ldp	x2, x3, [x0]
	stp	x2, x3, [sp, #THREAD_ABT_REG_X0]
 11048cc:	a9000fe2 	stp	x2, x3, [sp]
	ldp	x2, x3, [x0, #THREAD_CORE_LOCAL_X2]
 11048d0:	a9410c02 	ldp	x2, x3, [x0, #16]
	store_xregs sp, THREAD_ABT_REG_X2, 2, 29
 11048d4:	a9010fe2 	stp	x2, x3, [sp, #16]
 11048d8:	a90217e4 	stp	x4, x5, [sp, #32]
 11048dc:	a9031fe6 	stp	x6, x7, [sp, #48]
 11048e0:	a90427e8 	stp	x8, x9, [sp, #64]
 11048e4:	a9052fea 	stp	x10, x11, [sp, #80]
 11048e8:	a90637ec 	stp	x12, x13, [sp, #96]
 11048ec:	a9073fee 	stp	x14, x15, [sp, #112]
 11048f0:	a90847f0 	stp	x16, x17, [sp, #128]
 11048f4:	a9094ff2 	stp	x18, x19, [sp, #144]
 11048f8:	a90a57f4 	stp	x20, x21, [sp, #160]
 11048fc:	a90b5ff6 	stp	x22, x23, [sp, #176]
 1104900:	a90c67f8 	stp	x24, x25, [sp, #192]
 1104904:	a90d6ffa 	stp	x26, x27, [sp, #208]
 1104908:	a90e77fc 	stp	x28, x29, [sp, #224]
	mrs	x0, elr_el1
 110490c:	d5384020 	mrs	x0, elr_el1
	stp	x30, x0, [sp, #THREAD_ABT_REG_X30]
 1104910:	a90f03fe 	stp	x30, x0, [sp, #240]
	mov	x0, #0
 1104914:	d2800000 	mov	x0, #0x0                   	// #0
	mov	x1, sp
 1104918:	910003e1 	mov	x1, sp
	bl	abort_handler
 110491c:	94000bbf 	bl	1107818 <abort_handler>
	ldp	x30, x0, [sp, #THREAD_ABT_REG_X30]
 1104920:	a94f03fe 	ldp	x30, x0, [sp, #240]
	msr	elr_el1, x0
 1104924:	d5184020 	msr	elr_el1, x0
	load_xregs sp, THREAD_ABT_REG_X0, 0, 29
 1104928:	a94007e0 	ldp	x0, x1, [sp]
 110492c:	a9410fe2 	ldp	x2, x3, [sp, #16]
 1104930:	a94217e4 	ldp	x4, x5, [sp, #32]
 1104934:	a9431fe6 	ldp	x6, x7, [sp, #48]
 1104938:	a94427e8 	ldp	x8, x9, [sp, #64]
 110493c:	a9452fea 	ldp	x10, x11, [sp, #80]
 1104940:	a94637ec 	ldp	x12, x13, [sp, #96]
 1104944:	a9473fee 	ldp	x14, x15, [sp, #112]
 1104948:	a94847f0 	ldp	x16, x17, [sp, #128]
 110494c:	a9494ff2 	ldp	x18, x19, [sp, #144]
 1104950:	a94a57f4 	ldp	x20, x21, [sp, #160]
 1104954:	a94b5ff6 	ldp	x22, x23, [sp, #176]
 1104958:	a94c67f8 	ldp	x24, x25, [sp, #192]
 110495c:	a94d6ffa 	ldp	x26, x27, [sp, #208]
 1104960:	a94e77fc 	ldp	x28, x29, [sp, #224]
	msr	spsel, #1
 1104964:	d50041bf 	msr	spsel, #0x1
	store_xregs sp, THREAD_CORE_LOCAL_X0, 0, 3
 1104968:	a90007e0 	stp	x0, x1, [sp]
 110496c:	a9010fe2 	stp	x2, x3, [sp, #16]
	mrs	x3, sp_el0
 1104970:	d5384103 	mrs	x3, sp_el0
	ldp	x0, x1, [x3, #THREAD_ABT_REG_SPSR]
 1104974:	a9500460 	ldp	x0, x1, [x3, #256]
	msr	spsr_el1, x0
 1104978:	d5184000 	msr	spsr_el1, x0
	msr	sp_el0, x1
 110497c:	d5184101 	msr	sp_el0, x1
	ldr	w0, [sp, #THREAD_CORE_LOCAL_FLAGS]
 1104980:	b9402fe0 	ldr	w0, [sp, #44]
	lsr	w0, w0, #THREAD_CLF_SAVED_SHIFT
 1104984:	53047c00 	lsr	w0, w0, #4
	str	w0, [sp, #THREAD_CORE_LOCAL_FLAGS]
 1104988:	b9002fe0 	str	w0, [sp, #44]
	load_xregs sp, THREAD_CORE_LOCAL_X0, 0, 3
 110498c:	a94007e0 	ldp	x0, x1, [sp]
 1104990:	a9410fe2 	ldp	x2, x3, [sp, #16]
	return_from_exception
 1104994:	d69f03e0 	eret
 1104998:	d503379f 	dsb	nsh
 110499c:	d5033fdf 	isb

00000000011049a0 <el0_sync_abort>:
	ldr	w1, [sp, #THREAD_CORE_LOCAL_FLAGS]
 11049a0:	b9402fe1 	ldr	w1, [sp, #44]
	lsl	w1, w1, #THREAD_CLF_SAVED_SHIFT
 11049a4:	531c6c21 	lsl	w1, w1, #4
	orr	w1, w1, #THREAD_CLF_ABORT
 11049a8:	321f0021 	orr	w1, w1, #0x2
	str	w1, [sp, #THREAD_CORE_LOCAL_FLAGS]
 11049ac:	b9002fe1 	str	w1, [sp, #44]
	ldr	x1, [sp, #THREAD_CORE_LOCAL_ABT_STACK_VA_END]
 11049b0:	f9401be1 	ldr	x1, [sp, #48]
	mov	x0, sp
 11049b4:	910003e0 	mov	x0, sp
	msr	spsel, #0
 11049b8:	d50040bf 	msr	spsel, #0x0
	mov	sp, x1
 11049bc:	9100003f 	mov	sp, x1
	sub	sp, sp, #THREAD_ABT_REGS_SIZE
 11049c0:	d10443ff 	sub	sp, sp, #0x110
	mrs	x2, spsr_el1
 11049c4:	d5384002 	mrs	x2, spsr_el1
	stp	x2, x3, [sp, #THREAD_ABT_REG_SPSR]
 11049c8:	a9100fe2 	stp	x2, x3, [sp, #256]
	ldp	x2, x3, [x0, #THREAD_CORE_LOCAL_X0]
 11049cc:	a9400c02 	ldp	x2, x3, [x0]
	stp	x2, x3, [sp, #THREAD_ABT_REG_X0]
 11049d0:	a9000fe2 	stp	x2, x3, [sp]
	ldp	x2, x3, [x0, #THREAD_CORE_LOCAL_X2]
 11049d4:	a9410c02 	ldp	x2, x3, [x0, #16]
	store_xregs sp, THREAD_ABT_REG_X2, 2, 29
 11049d8:	a9010fe2 	stp	x2, x3, [sp, #16]
 11049dc:	a90217e4 	stp	x4, x5, [sp, #32]
 11049e0:	a9031fe6 	stp	x6, x7, [sp, #48]
 11049e4:	a90427e8 	stp	x8, x9, [sp, #64]
 11049e8:	a9052fea 	stp	x10, x11, [sp, #80]
 11049ec:	a90637ec 	stp	x12, x13, [sp, #96]
 11049f0:	a9073fee 	stp	x14, x15, [sp, #112]
 11049f4:	a90847f0 	stp	x16, x17, [sp, #128]
 11049f8:	a9094ff2 	stp	x18, x19, [sp, #144]
 11049fc:	a90a57f4 	stp	x20, x21, [sp, #160]
 1104a00:	a90b5ff6 	stp	x22, x23, [sp, #176]
 1104a04:	a90c67f8 	stp	x24, x25, [sp, #192]
 1104a08:	a90d6ffa 	stp	x26, x27, [sp, #208]
 1104a0c:	a90e77fc 	stp	x28, x29, [sp, #224]
	mrs	x0, elr_el1
 1104a10:	d5384020 	mrs	x0, elr_el1
	stp	x30, x0, [sp, #THREAD_ABT_REG_X30]
 1104a14:	a90f03fe 	stp	x30, x0, [sp, #240]
	mov	x0, #0
 1104a18:	d2800000 	mov	x0, #0x0                   	// #0
	mov	x1, sp
 1104a1c:	910003e1 	mov	x1, sp
	bl	abort_handler
 1104a20:	94000b7e 	bl	1107818 <abort_handler>
	ldp	x30, x0, [sp, #THREAD_ABT_REG_X30]
 1104a24:	a94f03fe 	ldp	x30, x0, [sp, #240]
	msr	elr_el1, x0
 1104a28:	d5184020 	msr	elr_el1, x0
	load_xregs sp, THREAD_ABT_REG_X0, 0, 29
 1104a2c:	a94007e0 	ldp	x0, x1, [sp]
 1104a30:	a9410fe2 	ldp	x2, x3, [sp, #16]
 1104a34:	a94217e4 	ldp	x4, x5, [sp, #32]
 1104a38:	a9431fe6 	ldp	x6, x7, [sp, #48]
 1104a3c:	a94427e8 	ldp	x8, x9, [sp, #64]
 1104a40:	a9452fea 	ldp	x10, x11, [sp, #80]
 1104a44:	a94637ec 	ldp	x12, x13, [sp, #96]
 1104a48:	a9473fee 	ldp	x14, x15, [sp, #112]
 1104a4c:	a94847f0 	ldp	x16, x17, [sp, #128]
 1104a50:	a9494ff2 	ldp	x18, x19, [sp, #144]
 1104a54:	a94a57f4 	ldp	x20, x21, [sp, #160]
 1104a58:	a94b5ff6 	ldp	x22, x23, [sp, #176]
 1104a5c:	a94c67f8 	ldp	x24, x25, [sp, #192]
 1104a60:	a94d6ffa 	ldp	x26, x27, [sp, #208]
 1104a64:	a94e77fc 	ldp	x28, x29, [sp, #224]
	msr	spsel, #1
 1104a68:	d50041bf 	msr	spsel, #0x1
	store_xregs sp, THREAD_CORE_LOCAL_X0, 0, 3
 1104a6c:	a90007e0 	stp	x0, x1, [sp]
 1104a70:	a9010fe2 	stp	x2, x3, [sp, #16]
	mrs	x3, sp_el0
 1104a74:	d5384103 	mrs	x3, sp_el0
	ldp	x0, x1, [x3, #THREAD_ABT_REG_SPSR]
 1104a78:	a9500460 	ldp	x0, x1, [x3, #256]
	msr	spsr_el1, x0
 1104a7c:	d5184000 	msr	spsr_el1, x0
	msr	sp_el0, x1
 1104a80:	d5184101 	msr	sp_el0, x1
	ldr	w1, [sp, #THREAD_CORE_LOCAL_FLAGS]
 1104a84:	b9402fe1 	ldr	w1, [sp, #44]
	lsr	w1, w1, #THREAD_CLF_SAVED_SHIFT
 1104a88:	53047c21 	lsr	w1, w1, #4
	str	w1, [sp, #THREAD_CORE_LOCAL_FLAGS]
 1104a8c:	b9002fe1 	str	w1, [sp, #44]
	load_xregs sp, THREAD_CORE_LOCAL_X2, 2, 3
 1104a90:	a9410fe2 	ldp	x2, x3, [sp, #16]
	b_if_spsr_is_el0 w0, 1f
 1104a94:	378000e0 	tbnz	w0, #16, 1104ab0 <el0_sync_abort+0x110>
 1104a98:	721e041f 	tst	w0, #0xc
 1104a9c:	540000a0 	b.eq	1104ab0 <el0_sync_abort+0x110>  // b.none
	load_xregs sp, THREAD_CORE_LOCAL_X0, 0, 1
 1104aa0:	a94007e0 	ldp	x0, x1, [sp]
	return_from_exception
 1104aa4:	d69f03e0 	eret
 1104aa8:	d503379f 	dsb	nsh
 1104aac:	d5033fdf 	isb
1:	b	eret_to_el0
 1104ab0:	17fff935 	b	1102f84 <eret_to_el0>

0000000001104ab4 <elx_fiq>:

LOCAL_FUNC elx_fiq , :
#if defined(CFG_ARM_GICV3)
	foreign_intr_handler	fiq
#else
	native_intr_handler	fiq
 1104ab4:	b9402fe1 	ldr	w1, [sp, #44]
 1104ab8:	531c6c21 	lsl	w1, w1, #4
 1104abc:	321d0021 	orr	w1, w1, #0x8
 1104ac0:	32000021 	orr	w1, w1, #0x1
 1104ac4:	b9002fe1 	str	w1, [sp, #44]
 1104ac8:	f94013e1 	ldr	x1, [sp, #32]
 1104acc:	d5384102 	mrs	x2, sp_el0
 1104ad0:	d50040bf 	msr	spsel, #0x0
 1104ad4:	9100003f 	mov	sp, x1
 1104ad8:	d10243ff 	sub	sp, sp, #0x90
 1104adc:	a90017e4 	stp	x4, x5, [sp]
 1104ae0:	a9011fe6 	stp	x6, x7, [sp, #16]
 1104ae4:	a90227e8 	stp	x8, x9, [sp, #32]
 1104ae8:	a9032fea 	stp	x10, x11, [sp, #48]
 1104aec:	a90437ec 	stp	x12, x13, [sp, #64]
 1104af0:	a9053fee 	stp	x14, x15, [sp, #80]
 1104af4:	a90647f0 	stp	x16, x17, [sp, #96]
 1104af8:	f9003bf2 	str	x18, [sp, #112]
 1104afc:	a9080bfe 	stp	x30, x2, [sp, #128]
 1104b00:	9400004c 	bl	1104c30 <thread_check_canaries>
 1104b04:	94002172 	bl	110d0cc <itr_core_handler>
 1104b08:	a94017e4 	ldp	x4, x5, [sp]
 1104b0c:	a9411fe6 	ldp	x6, x7, [sp, #16]
 1104b10:	a94227e8 	ldp	x8, x9, [sp, #32]
 1104b14:	a9432fea 	ldp	x10, x11, [sp, #48]
 1104b18:	a94437ec 	ldp	x12, x13, [sp, #64]
 1104b1c:	a9453fee 	ldp	x14, x15, [sp, #80]
 1104b20:	a94647f0 	ldp	x16, x17, [sp, #96]
 1104b24:	f9403bf2 	ldr	x18, [sp, #112]
 1104b28:	a9480bfe 	ldp	x30, x2, [sp, #128]
 1104b2c:	9100005f 	mov	sp, x2
 1104b30:	d50041bf 	msr	spsel, #0x1
 1104b34:	b9402fe0 	ldr	w0, [sp, #44]
 1104b38:	53047c00 	lsr	w0, w0, #4
 1104b3c:	b9002fe0 	str	w0, [sp, #44]
 1104b40:	d5384000 	mrs	x0, spsr_el1
 1104b44:	a9410fe2 	ldp	x2, x3, [sp, #16]
 1104b48:	378000e0 	tbnz	w0, #16, 1104b64 <elx_fiq+0xb0>
 1104b4c:	721e041f 	tst	w0, #0xc
 1104b50:	540000a0 	b.eq	1104b64 <elx_fiq+0xb0>  // b.none
 1104b54:	a94007e0 	ldp	x0, x1, [sp]
 1104b58:	d69f03e0 	eret
 1104b5c:	d503379f 	dsb	nsh
 1104b60:	d5033fdf 	isb
 1104b64:	17fff908 	b	1102f84 <eret_to_el0>

0000000001104b68 <thread_cpu_off_handler>:
 */
unsigned long __weak thread_cpu_off_handler(unsigned long a0 __unused,
					    unsigned long a1 __unused)
{
	return 0;
}
 1104b68:	d2800000 	mov	x0, #0x0                   	// #0
 1104b6c:	d65f03c0 	ret

0000000001104b70 <clear_shm_cache_entry>:
{
 1104b70:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1104b74:	910003fd 	mov	x29, sp
 1104b78:	f9000bf3 	str	x19, [sp, #16]
 1104b7c:	aa0003f3 	mov	x19, x0
	if (ce->mobj) {
 1104b80:	f9400000 	ldr	x0, [x0]
 1104b84:	b4000100 	cbz	x0, 1104ba4 <clear_shm_cache_entry+0x34>
		switch (ce->type) {
 1104b88:	b9401261 	ldr	w1, [x19, #16]
 1104b8c:	7100043f 	cmp	w1, #0x1
 1104b90:	54000120 	b.eq	1104bb4 <clear_shm_cache_entry+0x44>  // b.none
 1104b94:	7100083f 	cmp	w1, #0x2
 1104b98:	54000120 	b.eq	1104bbc <clear_shm_cache_entry+0x4c>  // b.none
 1104b9c:	35000141 	cbnz	w1, 1104bc4 <clear_shm_cache_entry+0x54>
			thread_rpc_free_payload(ce->mobj);
 1104ba0:	9400093e 	bl	1107098 <thread_rpc_free_payload>
	ce->size = 0;
 1104ba4:	a9007e7f 	stp	xzr, xzr, [x19]
}
 1104ba8:	f9400bf3 	ldr	x19, [sp, #16]
 1104bac:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1104bb0:	d65f03c0 	ret
			thread_rpc_free_kernel_payload(ce->mobj);
 1104bb4:	9400092e 	bl	110706c <thread_rpc_free_kernel_payload>
			break;
 1104bb8:	17fffffb 	b	1104ba4 <clear_shm_cache_entry+0x34>
			thread_rpc_free_global_payload(ce->mobj);
 1104bbc:	94000944 	bl	11070cc <thread_rpc_free_global_payload>
			break;
 1104bc0:	17fffff9 	b	1104ba4 <clear_shm_cache_entry+0x34>
			assert(0); /* "can't happen" */
 1104bc4:	b0000263 	adrp	x3, 1151000 <small_prime+0x168>
 1104bc8:	b0000261 	adrp	x1, 1151000 <small_prime+0x168>
 1104bcc:	91273c63 	add	x3, x3, #0x9cf
 1104bd0:	91106c21 	add	x1, x1, #0x41b
 1104bd4:	b00002a0 	adrp	x0, 1159000 <Worder+0x2854>
 1104bd8:	912c1c00 	add	x0, x0, #0xb07
 1104bdc:	5280cac2 	mov	w2, #0x656                 	// #1622
 1104be0:	940035b3 	bl	11122ac <_assert_log>
 1104be4:	940035c3 	bl	11122f0 <_assert_break>

0000000001104be8 <mobj_get_va.constprop.0>:
	if (mobj && mobj->ops && mobj->ops->get_va)
 1104be8:	b4000100 	cbz	x0, 1104c08 <mobj_get_va.constprop.0+0x20>
 1104bec:	f9400001 	ldr	x1, [x0]
 1104bf0:	b40000c1 	cbz	x1, 1104c08 <mobj_get_va.constprop.0+0x20>
 1104bf4:	f9400022 	ldr	x2, [x1]
 1104bf8:	b4000082 	cbz	x2, 1104c08 <mobj_get_va.constprop.0+0x20>
		return mobj->ops->get_va(mobj, offset);
 1104bfc:	aa0203f0 	mov	x16, x2
 1104c00:	d2800001 	mov	x1, #0x0                   	// #0
 1104c04:	d61f0200 	br	x16
}
 1104c08:	d2800000 	mov	x0, #0x0                   	// #0
 1104c0c:	d65f03c0 	ret

0000000001104c10 <thread_system_reset_handler>:
 1104c10:	d2800000 	mov	x0, #0x0                   	// #0
 1104c14:	d65f03c0 	ret

0000000001104c18 <thread_cpu_suspend_handler>:
 1104c18:	d2800000 	mov	x0, #0x0                   	// #0
 1104c1c:	d65f03c0 	ret

0000000001104c20 <thread_cpu_resume_handler>:
 1104c20:	d2800000 	mov	x0, #0x0                   	// #0
 1104c24:	d65f03c0 	ret

0000000001104c28 <thread_system_off_handler>:
 1104c28:	d2800000 	mov	x0, #0x0                   	// #0
 1104c2c:	d65f03c0 	ret

0000000001104c30 <thread_check_canaries>:
{
 1104c30:	d10083ff 	sub	sp, sp, #0x20
 1104c34:	90000460 	adrp	x0, 1190000 <stack_thread+0x3e00>
		if (*canary != START_CANARY_VALUE)
 1104c38:	529bdbc4 	mov	w4, #0xdede                	// #57054
		if (*canary != END_CANARY_VALUE)
 1104c3c:	52957565 	mov	w5, #0xabab                	// #43947
 1104c40:	910a0002 	add	x2, x0, #0x280
	for (n = 0; n < ARRAY_SIZE(stack_tmp); n++) {
 1104c44:	d2800007 	mov	x7, #0x0                   	// #0
 1104c48:	d2810803 	mov	x3, #0x840                 	// #2112
		if (*canary != START_CANARY_VALUE)
 1104c4c:	72bbdbc4 	movk	w4, #0xdede, lsl #16
		if (*canary != END_CANARY_VALUE)
 1104c50:	72b57565 	movk	w5, #0xabab, lsl #16
{
 1104c54:	a9017bfd 	stp	x29, x30, [sp, #16]
 1104c58:	910043fd 	add	x29, sp, #0x10
		if (*canary != START_CANARY_VALUE)
 1104c5c:	b9400046 	ldr	w6, [x2]
 1104c60:	9b037ce1 	mul	x1, x7, x3
 1104c64:	6b0400df 	cmp	w6, w4
 1104c68:	540002c0 	b.eq	1104cc0 <thread_check_canaries+0x90>  // b.none
		canary = &GET_START_CANARY(stack_tmp, n);
 1104c6c:	910a0000 	add	x0, x0, #0x280
			CANARY_DIED(stack_tmp, start, n, canary);
 1104c70:	52800023 	mov	w3, #0x1                   	// #1
		canary = &GET_START_CANARY(stack_tmp, n);
 1104c74:	8b000020 	add	x0, x1, x0
			CANARY_DIED(stack_tmp, start, n, canary);
 1104c78:	f90003e0 	str	x0, [sp]
 1104c7c:	52800022 	mov	w2, #0x1                   	// #1
 1104c80:	52800001 	mov	w1, #0x0                   	// #0
 1104c84:	b0000266 	adrp	x6, 1151000 <small_prime+0x168>
 1104c88:	d0000265 	adrp	x5, 1152000 <trace_ext_prefix+0x2e>
 1104c8c:	9110e4c6 	add	x6, x6, #0x439
 1104c90:	9109eca5 	add	x5, x5, #0x27b
 1104c94:	b0000264 	adrp	x4, 1151000 <small_prime+0x168>
 1104c98:	d2800000 	mov	x0, #0x0                   	// #0
 1104c9c:	91110c84 	add	x4, x4, #0x443
 1104ca0:	94010029 	bl	1144d44 <trace_printf>
 1104ca4:	b0000262 	adrp	x2, 1151000 <small_prime+0x168>
 1104ca8:	91208442 	add	x2, x2, #0x821
 1104cac:	d2800003 	mov	x3, #0x0                   	// #0
 1104cb0:	52801ae1 	mov	w1, #0xd7                  	// #215
			CANARY_DIED(stack_tmp, end, n, canary);
 1104cb4:	b0000260 	adrp	x0, 1151000 <small_prime+0x168>
 1104cb8:	91106c00 	add	x0, x0, #0x41b
 1104cbc:	940039eb 	bl	1113468 <__do_panic>
		if (*canary != END_CANARY_VALUE)
 1104cc0:	b9483c46 	ldr	w6, [x2, #2108]
 1104cc4:	6b0500df 	cmp	w6, w5
 1104cc8:	540002a0 	b.eq	1104d1c <thread_check_canaries+0xec>  // b.none
		canary = &GET_END_CANARY(stack_tmp, n);
 1104ccc:	9120f021 	add	x1, x1, #0x83c
 1104cd0:	910a0000 	add	x0, x0, #0x280
 1104cd4:	8b000020 	add	x0, x1, x0
			CANARY_DIED(stack_tmp, end, n, canary);
 1104cd8:	f90003e0 	str	x0, [sp]
 1104cdc:	52800023 	mov	w3, #0x1                   	// #1
 1104ce0:	52800022 	mov	w2, #0x1                   	// #1
 1104ce4:	52800001 	mov	w1, #0x0                   	// #0
 1104ce8:	b0000266 	adrp	x6, 1151000 <small_prime+0x168>
 1104cec:	b00002a5 	adrp	x5, 1159000 <Worder+0x2854>
 1104cf0:	9110e4c6 	add	x6, x6, #0x439
 1104cf4:	9131c0a5 	add	x5, x5, #0xc70
 1104cf8:	b0000264 	adrp	x4, 1151000 <small_prime+0x168>
 1104cfc:	d2800000 	mov	x0, #0x0                   	// #0
 1104d00:	91110c84 	add	x4, x4, #0x443
 1104d04:	94010010 	bl	1144d44 <trace_printf>
 1104d08:	b0000262 	adrp	x2, 1151000 <small_prime+0x168>
 1104d0c:	d2800003 	mov	x3, #0x0                   	// #0
 1104d10:	91208442 	add	x2, x2, #0x821
 1104d14:	52801b41 	mov	w1, #0xda                  	// #218
 1104d18:	17ffffe7 	b	1104cb4 <thread_check_canaries+0x84>
	for (n = 0; n < ARRAY_SIZE(stack_tmp); n++) {
 1104d1c:	910004e7 	add	x7, x7, #0x1
 1104d20:	91210042 	add	x2, x2, #0x840
 1104d24:	f10010ff 	cmp	x7, #0x4
 1104d28:	54fff9a1 	b.ne	1104c5c <thread_check_canaries+0x2c>  // b.any
 1104d2c:	b0000420 	adrp	x0, 1189000 <l1_xlation_table>
		if (*canary != START_CANARY_VALUE)
 1104d30:	529bdbc4 	mov	w4, #0xdede                	// #57054
		if (*canary != END_CANARY_VALUE)
 1104d34:	52957563 	mov	w3, #0xabab                	// #43947
 1104d38:	91040002 	add	x2, x0, #0x100
	for (n = 0; n < ARRAY_SIZE(stack_abt); n++) {
 1104d3c:	d2800007 	mov	x7, #0x0                   	// #0
 1104d40:	d2818805 	mov	x5, #0xc40                 	// #3136
		if (*canary != START_CANARY_VALUE)
 1104d44:	72bbdbc4 	movk	w4, #0xdede, lsl #16
		if (*canary != END_CANARY_VALUE)
 1104d48:	72b57563 	movk	w3, #0xabab, lsl #16
		if (*canary != START_CANARY_VALUE)
 1104d4c:	b9400046 	ldr	w6, [x2]
 1104d50:	9b057ce1 	mul	x1, x7, x5
 1104d54:	6b0400df 	cmp	w6, w4
 1104d58:	54000280 	b.eq	1104da8 <thread_check_canaries+0x178>  // b.none
		canary = &GET_START_CANARY(stack_abt, n);
 1104d5c:	91040000 	add	x0, x0, #0x100
			CANARY_DIED(stack_abt, start, n, canary);
 1104d60:	52800023 	mov	w3, #0x1                   	// #1
		canary = &GET_START_CANARY(stack_abt, n);
 1104d64:	8b000020 	add	x0, x1, x0
			CANARY_DIED(stack_abt, start, n, canary);
 1104d68:	f90003e0 	str	x0, [sp]
 1104d6c:	52800022 	mov	w2, #0x1                   	// #1
 1104d70:	52800001 	mov	w1, #0x0                   	// #0
 1104d74:	b0000266 	adrp	x6, 1151000 <small_prime+0x168>
 1104d78:	d0000265 	adrp	x5, 1152000 <trace_ext_prefix+0x2e>
 1104d7c:	91119cc6 	add	x6, x6, #0x467
 1104d80:	9109eca5 	add	x5, x5, #0x27b
 1104d84:	b0000264 	adrp	x4, 1151000 <small_prime+0x168>
 1104d88:	d2800000 	mov	x0, #0x0                   	// #0
 1104d8c:	91110c84 	add	x4, x4, #0x443
 1104d90:	9400ffed 	bl	1144d44 <trace_printf>
 1104d94:	b0000262 	adrp	x2, 1151000 <small_prime+0x168>
 1104d98:	d2800003 	mov	x3, #0x0                   	// #0
 1104d9c:	91208442 	add	x2, x2, #0x821
 1104da0:	52801c01 	mov	w1, #0xe0                  	// #224
 1104da4:	17ffffc4 	b	1104cb4 <thread_check_canaries+0x84>
		if (*canary != END_CANARY_VALUE)
 1104da8:	b94c3c46 	ldr	w6, [x2, #3132]
 1104dac:	6b0300df 	cmp	w6, w3
 1104db0:	540002a0 	b.eq	1104e04 <thread_check_canaries+0x1d4>  // b.none
		canary = &GET_END_CANARY(stack_abt, n);
 1104db4:	9130f021 	add	x1, x1, #0xc3c
 1104db8:	91040000 	add	x0, x0, #0x100
 1104dbc:	8b000020 	add	x0, x1, x0
			CANARY_DIED(stack_abt, end, n, canary);
 1104dc0:	f90003e0 	str	x0, [sp]
 1104dc4:	52800023 	mov	w3, #0x1                   	// #1
 1104dc8:	52800022 	mov	w2, #0x1                   	// #1
 1104dcc:	52800001 	mov	w1, #0x0                   	// #0
 1104dd0:	b0000266 	adrp	x6, 1151000 <small_prime+0x168>
 1104dd4:	b00002a5 	adrp	x5, 1159000 <Worder+0x2854>
 1104dd8:	91119cc6 	add	x6, x6, #0x467
 1104ddc:	9131c0a5 	add	x5, x5, #0xc70
 1104de0:	b0000264 	adrp	x4, 1151000 <small_prime+0x168>
 1104de4:	d2800000 	mov	x0, #0x0                   	// #0
 1104de8:	91110c84 	add	x4, x4, #0x443
 1104dec:	9400ffd6 	bl	1144d44 <trace_printf>
 1104df0:	b0000262 	adrp	x2, 1151000 <small_prime+0x168>
 1104df4:	d2800003 	mov	x3, #0x0                   	// #0
 1104df8:	91208442 	add	x2, x2, #0x821
 1104dfc:	52801c61 	mov	w1, #0xe3                  	// #227
 1104e00:	17ffffad 	b	1104cb4 <thread_check_canaries+0x84>
	for (n = 0; n < ARRAY_SIZE(stack_abt); n++) {
 1104e04:	910004e7 	add	x7, x7, #0x1
 1104e08:	91310042 	add	x2, x2, #0xc40
 1104e0c:	f10010ff 	cmp	x7, #0x4
 1104e10:	54fff9e1 	b.ne	1104d4c <thread_check_canaries+0x11c>  // b.any
		if (*canary != START_CANARY_VALUE)
 1104e14:	90000441 	adrp	x1, 118c000 <__nozi_end+0x2f00>
 1104e18:	91080020 	add	x0, x1, #0x200
 1104e1c:	b9420021 	ldr	w1, [x1, #512]
 1104e20:	6b04003f 	cmp	w1, w4
 1104e24:	540001e1 	b.ne	1104e60 <thread_check_canaries+0x230>  // b.any
		if (*canary != END_CANARY_VALUE)
 1104e28:	b9603c01 	ldr	w1, [x0, #8252]
 1104e2c:	6b03003f 	cmp	w1, w3
 1104e30:	54000441 	b.ne	1104eb8 <thread_check_canaries+0x288>  // b.any
		if (*canary != START_CANARY_VALUE)
 1104e34:	b9604001 	ldr	w1, [x0, #8256]
 1104e38:	6b04003f 	cmp	w1, w4
 1104e3c:	54000361 	b.ne	1104ea8 <thread_check_canaries+0x278>  // b.any
		if (*canary != END_CANARY_VALUE)
 1104e40:	91401000 	add	x0, x0, #0x4, lsl #12
 1104e44:	b9407c00 	ldr	w0, [x0, #124]
 1104e48:	6b03001f 	cmp	w0, w3
 1104e4c:	540005e0 	b.eq	1104f08 <thread_check_canaries+0x2d8>  // b.none
		canary = &GET_END_CANARY(stack_thread, n);
 1104e50:	90000460 	adrp	x0, 1190000 <stack_thread+0x3e00>
	for (n = 0; n < ARRAY_SIZE(stack_thread); n++) {
 1104e54:	d2800027 	mov	x7, #0x1                   	// #1
		canary = &GET_END_CANARY(stack_thread, n);
 1104e58:	9109f000 	add	x0, x0, #0x27c
 1104e5c:	1400001a 	b	1104ec4 <thread_check_canaries+0x294>
	for (n = 0; n < ARRAY_SIZE(stack_thread); n++) {
 1104e60:	d2800007 	mov	x7, #0x0                   	// #0
			CANARY_DIED(stack_thread, start, n, canary);
 1104e64:	f90003e0 	str	x0, [sp]
 1104e68:	52800023 	mov	w3, #0x1                   	// #1
 1104e6c:	52800022 	mov	w2, #0x1                   	// #1
 1104e70:	52800001 	mov	w1, #0x0                   	// #0
 1104e74:	b0000266 	adrp	x6, 1151000 <small_prime+0x168>
 1104e78:	d0000265 	adrp	x5, 1152000 <trace_ext_prefix+0x2e>
 1104e7c:	9111c4c6 	add	x6, x6, #0x471
 1104e80:	9109eca5 	add	x5, x5, #0x27b
 1104e84:	b0000264 	adrp	x4, 1151000 <small_prime+0x168>
 1104e88:	d2800000 	mov	x0, #0x0                   	// #0
 1104e8c:	91110c84 	add	x4, x4, #0x443
 1104e90:	9400ffad 	bl	1144d44 <trace_printf>
 1104e94:	b0000262 	adrp	x2, 1151000 <small_prime+0x168>
 1104e98:	d2800003 	mov	x3, #0x0                   	// #0
 1104e9c:	91208442 	add	x2, x2, #0x821
 1104ea0:	52801d41 	mov	w1, #0xea                  	// #234
 1104ea4:	17ffff84 	b	1104cb4 <thread_check_canaries+0x84>
		canary = &GET_START_CANARY(stack_thread, n);
 1104ea8:	d0000440 	adrp	x0, 118e000 <stack_thread+0x1e00>
	for (n = 0; n < ARRAY_SIZE(stack_thread); n++) {
 1104eac:	d2800027 	mov	x7, #0x1                   	// #1
		canary = &GET_START_CANARY(stack_thread, n);
 1104eb0:	91090000 	add	x0, x0, #0x240
 1104eb4:	17ffffec 	b	1104e64 <thread_check_canaries+0x234>
		canary = &GET_END_CANARY(stack_thread, n);
 1104eb8:	d0000440 	adrp	x0, 118e000 <stack_thread+0x1e00>
 1104ebc:	9108f000 	add	x0, x0, #0x23c
	for (n = 0; n < ARRAY_SIZE(stack_thread); n++) {
 1104ec0:	d2800007 	mov	x7, #0x0                   	// #0
			CANARY_DIED(stack_thread, end, n, canary);
 1104ec4:	f90003e0 	str	x0, [sp]
 1104ec8:	52800023 	mov	w3, #0x1                   	// #1
 1104ecc:	52800022 	mov	w2, #0x1                   	// #1
 1104ed0:	52800001 	mov	w1, #0x0                   	// #0
 1104ed4:	b0000266 	adrp	x6, 1151000 <small_prime+0x168>
 1104ed8:	b00002a5 	adrp	x5, 1159000 <Worder+0x2854>
 1104edc:	9111c4c6 	add	x6, x6, #0x471
 1104ee0:	9131c0a5 	add	x5, x5, #0xc70
 1104ee4:	b0000264 	adrp	x4, 1151000 <small_prime+0x168>
 1104ee8:	d2800000 	mov	x0, #0x0                   	// #0
 1104eec:	91110c84 	add	x4, x4, #0x443
 1104ef0:	9400ff95 	bl	1144d44 <trace_printf>
 1104ef4:	b0000262 	adrp	x2, 1151000 <small_prime+0x168>
 1104ef8:	d2800003 	mov	x3, #0x0                   	// #0
 1104efc:	91208442 	add	x2, x2, #0x821
 1104f00:	52801da1 	mov	w1, #0xed                  	// #237
 1104f04:	17ffff6c 	b	1104cb4 <thread_check_canaries+0x84>
}
 1104f08:	a9417bfd 	ldp	x29, x30, [sp, #16]
 1104f0c:	910083ff 	add	sp, sp, #0x20
 1104f10:	d65f03c0 	ret

0000000001104f14 <thread_get_exceptions>:
DEFINE_U32_REG_READWRITE_FUNCS(daif)
 1104f14:	d53b4220 	mrs	x0, daif
}
 1104f18:	53062000 	ubfx	w0, w0, #6, #3
 1104f1c:	d65f03c0 	ret

0000000001104f20 <thread_lock_global>:
{
 1104f20:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 1104f24:	910003fd 	mov	x29, sp
 1104f28:	a90153f3 	stp	x19, x20, [sp, #16]
 1104f2c:	a9025bf5 	stp	x21, x22, [sp, #32]
 1104f30:	f9001bf7 	str	x23, [sp, #48]
 1104f34:	97fffff8 	bl	1104f14 <thread_get_exceptions>
					  unsigned int *lock)
{
	unsigned int retries = 0;
	unsigned int reminder = 0;

	assert(thread_foreign_intr_disabled());
 1104f38:	36080200 	tbz	w0, #1, 1104f78 <thread_lock_global+0x58>

	while (__cpu_spin_trylock(lock)) {
 1104f3c:	90000334 	adrp	x20, 1168000 <data.5093+0x9e28>
		retries++;
		if (!retries) {
			/* wrapped, time to report */
			trace_printf(func, line, TRACE_ERROR, true,
 1104f40:	b0000276 	adrp	x22, 1151000 <small_prime+0x168>
	while (__cpu_spin_trylock(lock)) {
 1104f44:	91288294 	add	x20, x20, #0xa20
			trace_printf(func, line, TRACE_ERROR, true,
 1104f48:	911316d6 	add	x22, x22, #0x4c5
 1104f4c:	52800013 	mov	w19, #0x0                   	// #0
		if (!retries) {
 1104f50:	d2c00037 	mov	x23, #0x100000000           	// #4294967296
	unsigned int reminder = 0;
 1104f54:	d2800015 	mov	x21, #0x0                   	// #0
	while (__cpu_spin_trylock(lock)) {
 1104f58:	aa1403e0 	mov	x0, x20
 1104f5c:	97fffd52 	bl	11044a4 <__cpu_spin_trylock>
 1104f60:	350001e0 	cbnz	w0, 1104f9c <thread_lock_global+0x7c>
}
 1104f64:	a94153f3 	ldp	x19, x20, [sp, #16]
 1104f68:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1104f6c:	f9401bf7 	ldr	x23, [sp, #48]
 1104f70:	a8c47bfd 	ldp	x29, x30, [sp], #64
			if (reminder < UINT_MAX)
				reminder++;
		}
	}

	spinlock_count_incr();
 1104f74:	17fffd55 	b	11044c8 <spinlock_count_incr>
	assert(thread_foreign_intr_disabled());
 1104f78:	b0000263 	adrp	x3, 1151000 <small_prime+0x168>
 1104f7c:	b0000261 	adrp	x1, 1151000 <small_prime+0x168>
 1104f80:	911fe863 	add	x3, x3, #0x7fa
 1104f84:	9111f821 	add	x1, x1, #0x47e
 1104f88:	b0000260 	adrp	x0, 1151000 <small_prime+0x168>
 1104f8c:	91129800 	add	x0, x0, #0x4a6
 1104f90:	528006e2 	mov	w2, #0x37                  	// #55
 1104f94:	940034c6 	bl	11122ac <_assert_log>
 1104f98:	940034d6 	bl	11122f0 <_assert_break>
		if (!retries) {
 1104f9c:	910006b5 	add	x21, x21, #0x1
 1104fa0:	eb1702bf 	cmp	x21, x23
 1104fa4:	54fffda1 	b.ne	1104f58 <thread_lock_global+0x38>  // b.any
			trace_printf(func, line, TRACE_ERROR, true,
 1104fa8:	2a1303e5 	mov	w5, w19
 1104fac:	aa1603e4 	mov	x4, x22
 1104fb0:	52800023 	mov	w3, #0x1                   	// #1
 1104fb4:	52800022 	mov	w2, #0x1                   	// #1
 1104fb8:	52801ea1 	mov	w1, #0xf5                  	// #245
 1104fbc:	b0000260 	adrp	x0, 1151000 <small_prime+0x168>
 1104fc0:	9120dc00 	add	x0, x0, #0x837
 1104fc4:	9400ff60 	bl	1144d44 <trace_printf>
			if (reminder < UINT_MAX)
 1104fc8:	3100067f 	cmn	w19, #0x1
 1104fcc:	54fffc40 	b.eq	1104f54 <thread_lock_global+0x34>  // b.none
				reminder++;
 1104fd0:	11000673 	add	w19, w19, #0x1
 1104fd4:	17ffffe0 	b	1104f54 <thread_lock_global+0x34>

0000000001104fd8 <get_core_pos>:
#include <types_ext.h>

size_t __get_core_pos(void);

static inline size_t __noprof get_core_pos(void)
{
 1104fd8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 1104fdc:	910003fd 	mov	x29, sp
	/*
	 * Foreign interrupts must be disabled before playing with current
	 * core since we otherwise may be rescheduled to a different core.
	 */
	assert(thread_get_exceptions() & THREAD_EXCP_FOREIGN_INTR);
 1104fe0:	97ffffcd 	bl	1104f14 <thread_get_exceptions>
 1104fe4:	37080140 	tbnz	w0, #1, 110500c <get_core_pos+0x34>
 1104fe8:	b0000263 	adrp	x3, 1151000 <small_prime+0x168>
 1104fec:	b0000261 	adrp	x1, 1151000 <small_prime+0x168>
 1104ff0:	911f5463 	add	x3, x3, #0x7d5
 1104ff4:	9113b021 	add	x1, x1, #0x4ec
 1104ff8:	b0000260 	adrp	x0, 1151000 <small_prime+0x168>
 1104ffc:	91144000 	add	x0, x0, #0x510
 1105000:	528002c2 	mov	w2, #0x16                  	// #22
 1105004:	940034aa 	bl	11122ac <_assert_log>
 1105008:	940034ba 	bl	11122f0 <_assert_break>
	return __get_core_pos();
}
 110500c:	a8c17bfd 	ldp	x29, x30, [sp], #16
	return __get_core_pos();
 1105010:	17fff251 	b	1101954 <__get_core_pos>

0000000001105014 <get_core_local>:
{
 1105014:	2a0003e1 	mov	w1, w0
 1105018:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 110501c:	910003fd 	mov	x29, sp
	assert(thread_get_exceptions() & THREAD_EXCP_FOREIGN_INTR);
 1105020:	97ffffbd 	bl	1104f14 <thread_get_exceptions>
 1105024:	37080140 	tbnz	w0, #1, 110504c <get_core_local+0x38>
 1105028:	90000263 	adrp	x3, 1151000 <small_prime+0x168>
 110502c:	90000261 	adrp	x1, 1151000 <small_prime+0x168>
 1105030:	90000260 	adrp	x0, 1151000 <small_prime+0x168>
 1105034:	91212863 	add	x3, x3, #0x84a
 1105038:	91106c21 	add	x1, x1, #0x41b
 110503c:	91144000 	add	x0, x0, #0x510
 1105040:	528028a2 	mov	w2, #0x145                 	// #325
	assert(pos < CFG_TEE_CORE_NB_CORE);
 1105044:	9400349a 	bl	11122ac <_assert_log>
 1105048:	940034aa 	bl	11122f0 <_assert_break>
 110504c:	71000c3f 	cmp	w1, #0x3
 1105050:	54000129 	b.ls	1105074 <get_core_local+0x60>  // b.plast
 1105054:	90000263 	adrp	x3, 1151000 <small_prime+0x168>
 1105058:	90000261 	adrp	x1, 1151000 <small_prime+0x168>
 110505c:	90000260 	adrp	x0, 1151000 <small_prime+0x168>
 1105060:	91212863 	add	x3, x3, #0x84a
 1105064:	91106c21 	add	x1, x1, #0x41b
 1105068:	91150c00 	add	x0, x0, #0x543
 110506c:	528028e2 	mov	w2, #0x147                 	// #327
 1105070:	17fffff5 	b	1105044 <get_core_local+0x30>
	return &thread_core_local[pos];
 1105074:	b00002a0 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1105078:	d37a7c21 	ubfiz	x1, x1, #6, #32
}
 110507c:	a8c17bfd 	ldp	x29, x30, [sp], #16
 1105080:	f9421000 	ldr	x0, [x0, #1056]
 1105084:	8b010000 	add	x0, x0, x1
 1105088:	d65f03c0 	ret

000000000110508c <thread_unlock_global>:
{
 110508c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 1105090:	910003fd 	mov	x29, sp
 1105094:	97ffffa0 	bl	1104f14 <thread_get_exceptions>
	return !rc;
}

static inline void cpu_spin_unlock(unsigned int *lock)
{
	assert(thread_foreign_intr_disabled());
 1105098:	37080140 	tbnz	w0, #1, 11050c0 <thread_unlock_global+0x34>
 110509c:	90000263 	adrp	x3, 1151000 <small_prime+0x168>
 11050a0:	90000261 	adrp	x1, 1151000 <small_prime+0x168>
 11050a4:	91204463 	add	x3, x3, #0x811
 11050a8:	9111f821 	add	x1, x1, #0x47e
 11050ac:	90000260 	adrp	x0, 1151000 <small_prime+0x168>
 11050b0:	91129800 	add	x0, x0, #0x4a6
 11050b4:	52800b82 	mov	w2, #0x5c                  	// #92
 11050b8:	9400347d 	bl	11122ac <_assert_log>
 11050bc:	9400348d 	bl	11122f0 <_assert_break>
	__cpu_spin_unlock(lock);
 11050c0:	f0000300 	adrp	x0, 1168000 <data.5093+0x9e28>
 11050c4:	91288000 	add	x0, x0, #0xa20
 11050c8:	97fffcfe 	bl	11044c0 <__cpu_spin_unlock>
}
 11050cc:	a8c17bfd 	ldp	x29, x30, [sp], #16
	spinlock_count_decr();
 11050d0:	17fffd10 	b	1104510 <spinlock_count_decr>

00000000011050d4 <thread_set_exceptions>:
{
 11050d4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 11050d8:	910003fd 	mov	x29, sp
 11050dc:	a90153f3 	stp	x19, x20, [sp, #16]
 11050e0:	2a0003f3 	mov	w19, w0
 11050e4:	d53b4234 	mrs	x20, daif
	if (!(exceptions & THREAD_EXCP_FOREIGN_INTR))
 11050e8:	370801b3 	tbnz	w19, #1, 110511c <thread_set_exceptions+0x48>
	assert(!have_spinlock());
 11050ec:	97fffd1b 	bl	1104558 <have_spinlock>
 11050f0:	72001c1f 	tst	w0, #0xff
 11050f4:	54000140 	b.eq	110511c <thread_set_exceptions+0x48>  // b.none
 11050f8:	90000263 	adrp	x3, 1151000 <small_prime+0x168>
 11050fc:	90000261 	adrp	x1, 1151000 <small_prime+0x168>
 1105100:	911f8863 	add	x3, x3, #0x7e2
 1105104:	9111f821 	add	x1, x1, #0x47e
 1105108:	90000260 	adrp	x0, 1151000 <small_prime+0x168>
 110510c:	91157800 	add	x0, x0, #0x55e
 1105110:	52800322 	mov	w2, #0x19                  	// #25
 1105114:	94003466 	bl	11122ac <_assert_log>
 1105118:	94003476 	bl	11122f0 <_assert_break>
	daif &= ~(THREAD_EXCP_ALL << DAIF_F_SHIFT);
 110511c:	12177294 	and	w20, w20, #0xfffffe3f
	daif |= ((exceptions & THREAD_EXCP_ALL) << DAIF_F_SHIFT);
 1105120:	531a0a73 	ubfiz	w19, w19, #6, #3
 1105124:	2a140273 	orr	w19, w19, w20
 1105128:	d51b4233 	msr	daif, x19
}
 110512c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1105130:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1105134:	d65f03c0 	ret

0000000001105138 <thread_mask_exceptions>:
{
 1105138:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 110513c:	2a0003e1 	mov	w1, w0
 1105140:	910003fd 	mov	x29, sp
 1105144:	f9000bf3 	str	x19, [sp, #16]
	uint32_t state = thread_get_exceptions();
 1105148:	97ffff73 	bl	1104f14 <thread_get_exceptions>
	thread_set_exceptions(state | (exceptions & THREAD_EXCP_ALL));
 110514c:	12000821 	and	w1, w1, #0x7
	uint32_t state = thread_get_exceptions();
 1105150:	2a0003f3 	mov	w19, w0
	thread_set_exceptions(state | (exceptions & THREAD_EXCP_ALL));
 1105154:	2a000020 	orr	w0, w1, w0
 1105158:	97ffffdf 	bl	11050d4 <thread_set_exceptions>
}
 110515c:	2a1303e0 	mov	w0, w19
 1105160:	f9400bf3 	ldr	x19, [sp, #16]
 1105164:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1105168:	d65f03c0 	ret

000000000110516c <thread_unmask_exceptions>:
	thread_set_exceptions(state & THREAD_EXCP_ALL);
 110516c:	12000800 	and	w0, w0, #0x7
 1105170:	17ffffd9 	b	11050d4 <thread_set_exceptions>

0000000001105174 <thread_get_core_local>:
{
 1105174:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 1105178:	910003fd 	mov	x29, sp
	unsigned int pos = get_core_pos();
 110517c:	97ffff97 	bl	1104fd8 <get_core_pos>
}
 1105180:	a8c17bfd 	ldp	x29, x30, [sp], #16
	return get_core_local(pos);
 1105184:	17ffffa4 	b	1105014 <get_core_local>

0000000001105188 <thread_clr_boot_thread>:
{
 1105188:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 110518c:	910003fd 	mov	x29, sp
	struct thread_core_local *l = thread_get_core_local();
 1105190:	97fffff9 	bl	1105174 <thread_get_core_local>
	assert(l->curr_thread >= 0 && l->curr_thread < CFG_NUM_THREADS);
 1105194:	79405002 	ldrh	w2, [x0, #40]
 1105198:	79805001 	ldrsh	x1, [x0, #40]
 110519c:	7100045f 	cmp	w2, #0x1
 11051a0:	54000149 	b.ls	11051c8 <thread_clr_boot_thread+0x40>  // b.plast
 11051a4:	90000263 	adrp	x3, 1151000 <small_prime+0x168>
 11051a8:	90000261 	adrp	x1, 1151000 <small_prime+0x168>
 11051ac:	90000260 	adrp	x0, 1151000 <small_prime+0x168>
 11051b0:	9121d063 	add	x3, x3, #0x874
 11051b4:	91106c21 	add	x1, x1, #0x41b
 11051b8:	9115bc00 	add	x0, x0, #0x56f
 11051bc:	52804262 	mov	w2, #0x213                 	// #531
	assert(threads[l->curr_thread].state == THREAD_STATE_ACTIVE);
 11051c0:	9400343b 	bl	11122ac <_assert_log>
 11051c4:	9400344b 	bl	11122f0 <_assert_break>
 11051c8:	b00002a2 	adrp	x2, 115a000 <__scattered_array_1phys_mem_map+0x8>
 11051cc:	d280e003 	mov	x3, #0x700                 	// #1792
 11051d0:	f9417842 	ldr	x2, [x2, #752]
 11051d4:	9b030821 	madd	x1, x1, x3, x2
 11051d8:	b9411822 	ldr	w2, [x1, #280]
 11051dc:	7100085f 	cmp	w2, #0x2
 11051e0:	54000120 	b.eq	1105204 <thread_clr_boot_thread+0x7c>  // b.none
 11051e4:	90000263 	adrp	x3, 1151000 <small_prime+0x168>
 11051e8:	90000261 	adrp	x1, 1151000 <small_prime+0x168>
 11051ec:	90000260 	adrp	x0, 1151000 <small_prime+0x168>
 11051f0:	9121d063 	add	x3, x3, #0x874
 11051f4:	91106c21 	add	x1, x1, #0x41b
 11051f8:	91169c00 	add	x0, x0, #0x5a7
 11051fc:	52804282 	mov	w2, #0x214                 	// #532
 1105200:	17fffff0 	b	11051c0 <thread_clr_boot_thread+0x38>
	threads[l->curr_thread].state = THREAD_STATE_FREE;
 1105204:	b901183f 	str	wzr, [x1, #280]
	l->curr_thread = THREAD_ID_INVALID;
 1105208:	12800001 	mov	w1, #0xffffffff            	// #-1
 110520c:	79005001 	strh	w1, [x0, #40]
}
 1105210:	a8c17bfd 	ldp	x29, x30, [sp], #16
 1105214:	d65f03c0 	ret

0000000001105218 <thread_get_tmp_sp>:
{
 1105218:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 110521c:	910003fd 	mov	x29, sp
	struct thread_core_local *l = thread_get_core_local();
 1105220:	97ffffd5 	bl	1105174 <thread_get_core_local>
	l->flags |= THREAD_CLF_TMP;
 1105224:	b9402c01 	ldr	w1, [x0, #44]
 1105228:	32000021 	orr	w1, w1, #0x1
 110522c:	b9002c01 	str	w1, [x0, #44]
}
 1105230:	f9401000 	ldr	x0, [x0, #32]
 1105234:	a8c17bfd 	ldp	x29, x30, [sp], #16
 1105238:	d65f03c0 	ret

000000000110523c <thread_get_saved_thread_sp>:
{
 110523c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 1105240:	910003fd 	mov	x29, sp
	struct thread_core_local *l = thread_get_core_local();
 1105244:	97ffffcc 	bl	1105174 <thread_get_core_local>
	int ct = l->curr_thread;
 1105248:	79805000 	ldrsh	x0, [x0, #40]
	assert(ct != THREAD_ID_INVALID);
 110524c:	3100041f 	cmn	w0, #0x1
 1105250:	54000141 	b.ne	1105278 <thread_get_saved_thread_sp+0x3c>  // b.any
 1105254:	90000263 	adrp	x3, 1151000 <small_prime+0x168>
 1105258:	90000261 	adrp	x1, 1151000 <small_prime+0x168>
 110525c:	9122e463 	add	x3, x3, #0x8b9
 1105260:	91106c21 	add	x1, x1, #0x41b
 1105264:	90000260 	adrp	x0, 1151000 <small_prime+0x168>
 1105268:	91177000 	add	x0, x0, #0x5dc
 110526c:	52805cc2 	mov	w2, #0x2e6                 	// #742
 1105270:	9400340f 	bl	11122ac <_assert_log>
 1105274:	9400341f 	bl	11122f0 <_assert_break>
	return threads[ct].kern_sp;
 1105278:	b00002a1 	adrp	x1, 115a000 <__scattered_array_1phys_mem_map+0x8>
 110527c:	d280e002 	mov	x2, #0x700                 	// #1792
}
 1105280:	a8c17bfd 	ldp	x29, x30, [sp], #16
	return threads[ct].kern_sp;
 1105284:	f9417821 	ldr	x1, [x1, #752]
 1105288:	9b020400 	madd	x0, x0, x2, x1
}
 110528c:	f940a400 	ldr	x0, [x0, #328]
 1105290:	d65f03c0 	ret

0000000001105294 <thread_stack_size>:
}
 1105294:	d2840000 	mov	x0, #0x2000                	// #8192
 1105298:	d65f03c0 	ret

000000000110529c <get_stack_limits>:
{
 110529c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 11052a0:	910003fd 	mov	x29, sp
 11052a4:	a90153f3 	stp	x19, x20, [sp, #16]
 11052a8:	aa0003f4 	mov	x20, x0
	uint32_t exceptions = thread_mask_exceptions(THREAD_EXCP_FOREIGN_INTR);
 11052ac:	52800040 	mov	w0, #0x2                   	// #2
{
 11052b0:	a9025bf5 	stp	x21, x22, [sp, #32]
 11052b4:	aa0103f5 	mov	x21, x1
	uint32_t exceptions = thread_mask_exceptions(THREAD_EXCP_FOREIGN_INTR);
 11052b8:	97ffffa0 	bl	1105138 <thread_mask_exceptions>
 11052bc:	2a0003f6 	mov	w22, w0
	unsigned int pos = get_core_pos();
 11052c0:	97ffff46 	bl	1104fd8 <get_core_pos>
 11052c4:	aa0003f3 	mov	x19, x0
	struct thread_core_local *l = get_core_local(pos);
 11052c8:	97ffff53 	bl	1105014 <get_core_local>
	if (l->flags & THREAD_CLF_TMP) {
 11052cc:	b9402c01 	ldr	w1, [x0, #44]
 11052d0:	36000241 	tbz	w1, #0, 1105318 <get_stack_limits+0x7c>
		if (hard)
 11052d4:	92407e73 	and	x19, x19, #0xffffffff
 11052d8:	f0000440 	adrp	x0, 1190000 <stack_thread+0x3e00>
 11052dc:	910a0000 	add	x0, x0, #0x280
 11052e0:	d2810801 	mov	x1, #0x840                 	// #2112
 11052e4:	9b010273 	madd	x19, x19, x1, x0
 11052e8:	91004260 	add	x0, x19, #0x10
		*end = GET_STACK_BOTTOM(stack_tmp, pos);
 11052ec:	9120c273 	add	x19, x19, #0x830
 11052f0:	f9000280 	str	x0, [x20]
		*end = GET_STACK_BOTTOM(stack_abt, pos);
 11052f4:	f90002b3 	str	x19, [x21]
		ret = true;
 11052f8:	52800033 	mov	w19, #0x1                   	// #1
	thread_unmask_exceptions(exceptions);
 11052fc:	2a1603e0 	mov	w0, w22
 1105300:	97ffff9b 	bl	110516c <thread_unmask_exceptions>
}
 1105304:	2a1303e0 	mov	w0, w19
 1105308:	a94153f3 	ldp	x19, x20, [sp, #16]
 110530c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1105310:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1105314:	d65f03c0 	ret
	} else if (l->flags & THREAD_CLF_ABORT) {
 1105318:	36080141 	tbz	w1, #1, 1105340 <get_stack_limits+0xa4>
		if (hard)
 110531c:	92407e73 	and	x19, x19, #0xffffffff
 1105320:	90000420 	adrp	x0, 1189000 <l1_xlation_table>
 1105324:	91040000 	add	x0, x0, #0x100
 1105328:	d2818801 	mov	x1, #0xc40                 	// #3136
 110532c:	9b010273 	madd	x19, x19, x1, x0
 1105330:	91004260 	add	x0, x19, #0x10
		*end = GET_STACK_BOTTOM(stack_abt, pos);
 1105334:	9130c273 	add	x19, x19, #0xc30
 1105338:	f9000280 	str	x0, [x20]
 110533c:	17ffffee 	b	11052f4 <get_stack_limits+0x58>
	} else if (!l->flags) {
 1105340:	350001a1 	cbnz	w1, 1105374 <get_stack_limits+0xd8>
	int ct = l->curr_thread;
 1105344:	79805002 	ldrsh	x2, [x0, #40]
		if (ct < 0 || ct >= CFG_NUM_THREADS)
 1105348:	7100045f 	cmp	w2, #0x1
 110534c:	54000148 	b.hi	1105374 <get_stack_limits+0xd8>  // b.pmore
		*end = threads[ct].stack_va_end;
 1105350:	b00002a0 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1105354:	d280e001 	mov	x1, #0x700                 	// #1792
 1105358:	f9417800 	ldr	x0, [x0, #752]
 110535c:	9b010042 	madd	x2, x2, x1, x0
 1105360:	f9409041 	ldr	x1, [x2, #288]
 1105364:	f90002a1 	str	x1, [x21]
		*start = *end - STACK_THREAD_SIZE;
 1105368:	d1400821 	sub	x1, x1, #0x2, lsl #12
 110536c:	f9000281 	str	x1, [x20]
 1105370:	17ffffe2 	b	11052f8 <get_stack_limits+0x5c>
	bool ret = false;
 1105374:	52800013 	mov	w19, #0x0                   	// #0
 1105378:	17ffffe1 	b	11052fc <get_stack_limits+0x60>

000000000110537c <thread_is_from_abort_mode>:
{
 110537c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 1105380:	910003fd 	mov	x29, sp
	struct thread_core_local *l = thread_get_core_local();
 1105384:	97ffff7c 	bl	1105174 <thread_get_core_local>
	return (l->flags >> THREAD_CLF_SAVED_SHIFT) & THREAD_CLF_ABORT;
 1105388:	b9402c00 	ldr	w0, [x0, #44]
}
 110538c:	a8c17bfd 	ldp	x29, x30, [sp], #16
 1105390:	d3451400 	ubfx	x0, x0, #5, #1
 1105394:	d65f03c0 	ret

0000000001105398 <thread_is_in_normal_mode>:
{
 1105398:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	uint32_t exceptions = thread_mask_exceptions(THREAD_EXCP_FOREIGN_INTR);
 110539c:	52800040 	mov	w0, #0x2                   	// #2
{
 11053a0:	910003fd 	mov	x29, sp
 11053a4:	a90153f3 	stp	x19, x20, [sp, #16]
	uint32_t exceptions = thread_mask_exceptions(THREAD_EXCP_FOREIGN_INTR);
 11053a8:	97ffff64 	bl	1105138 <thread_mask_exceptions>
 11053ac:	2a0003f3 	mov	w19, w0
	struct thread_core_local *l = thread_get_core_local();
 11053b0:	97ffff71 	bl	1105174 <thread_get_core_local>
	ret = (l->curr_thread != THREAD_ID_INVALID) &&
 11053b4:	79c05001 	ldrsh	w1, [x0, #40]
 11053b8:	3100043f 	cmn	w1, #0x1
 11053bc:	54000140 	b.eq	11053e4 <thread_is_in_normal_mode+0x4c>  // b.none
	      !(l->flags & ~THREAD_CLF_TMP);
 11053c0:	b9402c00 	ldr	w0, [x0, #44]
	ret = (l->curr_thread != THREAD_ID_INVALID) &&
 11053c4:	721f781f 	tst	w0, #0xfffffffe
 11053c8:	1a9f17f4 	cset	w20, eq  // eq = none
	thread_unmask_exceptions(exceptions);
 11053cc:	2a1303e0 	mov	w0, w19
 11053d0:	97ffff67 	bl	110516c <thread_unmask_exceptions>
}
 11053d4:	2a1403e0 	mov	w0, w20
 11053d8:	a94153f3 	ldp	x19, x20, [sp, #16]
 11053dc:	a8c27bfd 	ldp	x29, x30, [sp], #32
 11053e0:	d65f03c0 	ret
	ret = (l->curr_thread != THREAD_ID_INVALID) &&
 11053e4:	52800014 	mov	w20, #0x0                   	// #0
 11053e8:	17fffff9 	b	11053cc <thread_is_in_normal_mode+0x34>

00000000011053ec <thread_get_id_may_fail>:
{
 11053ec:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	uint32_t exceptions = thread_mask_exceptions(THREAD_EXCP_FOREIGN_INTR);
 11053f0:	52800040 	mov	w0, #0x2                   	// #2
{
 11053f4:	910003fd 	mov	x29, sp
 11053f8:	a90153f3 	stp	x19, x20, [sp, #16]
	uint32_t exceptions = thread_mask_exceptions(THREAD_EXCP_FOREIGN_INTR);
 11053fc:	97ffff4f 	bl	1105138 <thread_mask_exceptions>
 1105400:	2a0003f3 	mov	w19, w0
	struct thread_core_local *l = thread_get_core_local();
 1105404:	97ffff5c 	bl	1105174 <thread_get_core_local>
	short int ct = l->curr_thread;
 1105408:	79c05014 	ldrsh	w20, [x0, #40]
	thread_unmask_exceptions(exceptions);
 110540c:	2a1303e0 	mov	w0, w19
 1105410:	97ffff57 	bl	110516c <thread_unmask_exceptions>
}
 1105414:	2a1403e0 	mov	w0, w20
 1105418:	a94153f3 	ldp	x19, x20, [sp, #16]
 110541c:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1105420:	d65f03c0 	ret

0000000001105424 <thread_stack_start>:
{
 1105424:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 1105428:	910003fd 	mov	x29, sp
	int ct = thread_get_id_may_fail();
 110542c:	97fffff0 	bl	11053ec <thread_get_id_may_fail>
 1105430:	13003c00 	sxth	w0, w0
	if (ct == THREAD_ID_INVALID)
 1105434:	3100041f 	cmn	w0, #0x1
 1105438:	54000120 	b.eq	110545c <thread_stack_start+0x38>  // b.none
	return thr->stack_va_end - STACK_THREAD_SIZE;
 110543c:	b00002a1 	adrp	x1, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1105440:	5280e002 	mov	w2, #0x700                 	// #1792
 1105444:	f9417821 	ldr	x1, [x1, #752]
 1105448:	9b220400 	smaddl	x0, w0, w2, x1
 110544c:	f9409000 	ldr	x0, [x0, #288]
 1105450:	d1400800 	sub	x0, x0, #0x2, lsl #12
}
 1105454:	a8c17bfd 	ldp	x29, x30, [sp], #16
 1105458:	d65f03c0 	ret
		return 0;
 110545c:	d2800000 	mov	x0, #0x0                   	// #0
 1105460:	17fffffd 	b	1105454 <thread_stack_start+0x30>

0000000001105464 <thread_get_id>:
{
 1105464:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 1105468:	910003fd 	mov	x29, sp
	short int ct = thread_get_id_may_fail();
 110546c:	97ffffe0 	bl	11053ec <thread_get_id_may_fail>
	assert(ct >= 0 && ct < CFG_NUM_THREADS);
 1105470:	12003c01 	and	w1, w0, #0xffff
 1105474:	7100043f 	cmp	w1, #0x1
 1105478:	54000149 	b.ls	11054a0 <thread_get_id+0x3c>  // b.plast
 110547c:	90000263 	adrp	x3, 1151000 <small_prime+0x168>
 1105480:	90000261 	adrp	x1, 1151000 <small_prime+0x168>
 1105484:	9123ec63 	add	x3, x3, #0x8fb
 1105488:	91106c21 	add	x1, x1, #0x41b
 110548c:	90000260 	adrp	x0, 1151000 <small_prime+0x168>
 1105490:	9117d000 	add	x0, x0, #0x5f4
 1105494:	52807c42 	mov	w2, #0x3e2                 	// #994
 1105498:	94003385 	bl	11122ac <_assert_log>
 110549c:	94003395 	bl	11122f0 <_assert_break>
}
 11054a0:	a8c17bfd 	ldp	x29, x30, [sp], #16
 11054a4:	d65f03c0 	ret

00000000011054a8 <thread_lazy_save_ns_vfp>:
{
 11054a8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 11054ac:	910003fd 	mov	x29, sp
	struct thread_ctx *thr = threads + thread_get_id();
 11054b0:	97ffffed 	bl	1105464 <thread_get_id>
 11054b4:	13003c00 	sxth	w0, w0
 11054b8:	b00002a1 	adrp	x1, 115a000 <__scattered_array_1phys_mem_map+0x8>
 11054bc:	5280e002 	mov	w2, #0x700                 	// #1792
 11054c0:	f9417821 	ldr	x1, [x1, #752]
 11054c4:	9b220400 	smaddl	x0, w0, w2, x1
	vfp_lazy_save_state_init(&thr->vfp_state.ns);
 11054c8:	91058000 	add	x0, x0, #0x160
	thr->vfp_state.ns_saved = false;
 11054cc:	381f001f 	sturb	wzr, [x0, #-16]
}
 11054d0:	a8c17bfd 	ldp	x29, x30, [sp], #16
	vfp_lazy_save_state_init(&thr->vfp_state.ns);
 11054d4:	140009b6 	b	1107bac <vfp_lazy_save_state_init>

00000000011054d8 <thread_resume_from_rpc>:
{
 11054d8:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
 11054dc:	910003fd 	mov	x29, sp
 11054e0:	a90153f3 	stp	x19, x20, [sp, #16]
 11054e4:	2a0003f4 	mov	w20, w0
 11054e8:	a9025bf5 	stp	x21, x22, [sp, #32]
 11054ec:	a90363f7 	stp	x23, x24, [sp, #48]
 11054f0:	2a0303f8 	mov	w24, w3
 11054f4:	2a0403f7 	mov	w23, w4
 11054f8:	a9046bf9 	stp	x25, x26, [sp, #64]
 11054fc:	2a0103fa 	mov	w26, w1
 1105500:	2a0203f9 	mov	w25, w2
 1105504:	a90573fb 	stp	x27, x28, [sp, #80]
	struct thread_core_local *l = thread_get_core_local();
 1105508:	97ffff1b 	bl	1105174 <thread_get_core_local>
 110550c:	aa0003f6 	mov	x22, x0
	assert(l->curr_thread == THREAD_ID_INVALID);
 1105510:	79c05000 	ldrsh	w0, [x0, #40]
 1105514:	3100041f 	cmn	w0, #0x1
 1105518:	54000140 	b.eq	1105540 <thread_resume_from_rpc+0x68>  // b.none
 110551c:	90000263 	adrp	x3, 1151000 <small_prime+0x168>
 1105520:	90000261 	adrp	x1, 1151000 <small_prime+0x168>
 1105524:	91228863 	add	x3, x3, #0x8a2
 1105528:	91106c21 	add	x1, x1, #0x41b
 110552c:	90000260 	adrp	x0, 1151000 <small_prime+0x168>
 1105530:	91185000 	add	x0, x0, #0x614
 1105534:	528054c2 	mov	w2, #0x2a6                 	// #678
 1105538:	9400335d 	bl	11122ac <_assert_log>
 110553c:	9400336d 	bl	11122f0 <_assert_break>
	thread_lock_global();
 1105540:	97fffe78 	bl	1104f20 <thread_lock_global>
	if (n < CFG_NUM_THREADS && threads[n].state == THREAD_STATE_SUSPENDED) {
 1105544:	f100069f 	cmp	x20, #0x1
 1105548:	54000109 	b.ls	1105568 <thread_resume_from_rpc+0x90>  // b.plast
}
 110554c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1105550:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1105554:	a94363f7 	ldp	x23, x24, [sp, #48]
 1105558:	a9446bf9 	ldp	x25, x26, [sp, #64]
 110555c:	a94573fb 	ldp	x27, x28, [sp, #80]
 1105560:	a8c67bfd 	ldp	x29, x30, [sp], #96
	thread_unlock_global();
 1105564:	17fffeca 	b	110508c <thread_unlock_global>
	if (n < CFG_NUM_THREADS && threads[n].state == THREAD_STATE_SUSPENDED) {
 1105568:	b00002a5 	adrp	x5, 115a000 <__scattered_array_1phys_mem_map+0x8>
 110556c:	d280e01c 	mov	x28, #0x700                 	// #1792
 1105570:	f94178b5 	ldr	x21, [x5, #752]
 1105574:	9b1c569b 	madd	x27, x20, x28, x21
 1105578:	b9411b60 	ldr	w0, [x27, #280]
 110557c:	7100041f 	cmp	w0, #0x1
 1105580:	54fffe61 	b.ne	110554c <thread_resume_from_rpc+0x74>  // b.any
		threads[n].state = THREAD_STATE_ACTIVE;
 1105584:	52800040 	mov	w0, #0x2                   	// #2
 1105588:	b9011b60 	str	w0, [x27, #280]
	thread_unlock_global();
 110558c:	9bbc7e93 	umull	x19, w20, w28
 1105590:	97fffebf 	bl	110508c <thread_unlock_global>
	l->curr_thread = n;
 1105594:	790052d4 	strh	w20, [x22, #40]
	if (threads[n].have_user_map) {
 1105598:	39450360 	ldrb	w0, [x27, #320]
 110559c:	34000080 	cbz	w0, 11055ac <thread_resume_from_rpc+0xd4>
		core_mmu_set_user_map(&threads[n].user_map);
 11055a0:	9104c260 	add	x0, x19, #0x130
 11055a4:	8b0002a0 	add	x0, x21, x0
 11055a8:	94001756 	bl	110b300 <core_mmu_set_user_map>
	if (is_user_mode(&threads[n].regs))
 11055ac:	b00002a5 	adrp	x5, 115a000 <__scattered_array_1phys_mem_map+0x8>
	if (threads[n].flags & THREAD_FLAGS_COPY_ARGS_ON_RETURN) {
 11055b0:	d280e000 	mov	x0, #0x700                 	// #1792
	if (is_user_mode(&threads[n].regs))
 11055b4:	f94178a5 	ldr	x5, [x5, #752]
 11055b8:	8b050273 	add	x19, x19, x5
	if (threads[n].flags & THREAD_FLAGS_COPY_ARGS_ON_RETURN) {
 11055bc:	9b001685 	madd	x5, x20, x0, x5
 11055c0:	b94128a0 	ldr	w0, [x5, #296]
 11055c4:	360000a0 	tbz	w0, #0, 11055d8 <thread_resume_from_rpc+0x100>
		threads[n].flags &= ~THREAD_FLAGS_COPY_ARGS_ON_RETURN;
 11055c8:	121f7800 	and	w0, w0, #0xfffffffe
	regs->x[1] = a1;
 11055cc:	a901e4ba 	stp	x26, x25, [x5, #24]
	regs->x[3] = a3;
 11055d0:	a902dcb8 	stp	x24, x23, [x5, #40]
		threads[n].flags &= ~THREAD_FLAGS_COPY_ARGS_ON_RETURN;
 11055d4:	b90128a0 	str	w0, [x5, #296]
	thread_lazy_save_ns_vfp();
 11055d8:	97ffffb4 	bl	11054a8 <thread_lazy_save_ns_vfp>
	l->flags &= ~THREAD_CLF_TMP;
 11055dc:	b9402ec0 	ldr	w0, [x22, #44]
 11055e0:	121f7800 	and	w0, w0, #0xfffffffe
 11055e4:	b9002ec0 	str	w0, [x22, #44]
	thread_resume(&threads[n].regs);
 11055e8:	aa1303e0 	mov	x0, x19
 11055ec:	97fffc6d 	bl	11047a0 <thread_resume>
	panic();
 11055f0:	90000262 	adrp	x2, 1151000 <small_prime+0x168>
 11055f4:	90000260 	adrp	x0, 1151000 <small_prime+0x168>
 11055f8:	91228842 	add	x2, x2, #0x8a2
 11055fc:	91106c00 	add	x0, x0, #0x41b
 1105600:	d2800003 	mov	x3, #0x0                   	// #0
 1105604:	52805a01 	mov	w1, #0x2d0                 	// #720
 1105608:	94003798 	bl	1113468 <__do_panic>

000000000110560c <thread_alloc_and_run>:
{
 110560c:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 1105610:	910003fd 	mov	x29, sp
 1105614:	a90153f3 	stp	x19, x20, [sp, #16]
 1105618:	a9025bf5 	stp	x21, x22, [sp, #32]
 110561c:	2a0203f6 	mov	w22, w2
 1105620:	2a0303f5 	mov	w21, w3
 1105624:	a90363f7 	stp	x23, x24, [sp, #48]
 1105628:	2a0003f8 	mov	w24, w0
 110562c:	2a0103f7 	mov	w23, w1
 1105630:	a9046bf9 	stp	x25, x26, [sp, #64]
	struct thread_core_local *l = thread_get_core_local();
 1105634:	97fffed0 	bl	1105174 <thread_get_core_local>
 1105638:	aa0003f4 	mov	x20, x0
	assert(l->curr_thread == THREAD_ID_INVALID);
 110563c:	79c05000 	ldrsh	w0, [x0, #40]
 1105640:	3100041f 	cmn	w0, #0x1
 1105644:	54000140 	b.eq	110566c <thread_alloc_and_run+0x60>  // b.none
 1105648:	90000263 	adrp	x3, 1151000 <small_prime+0x168>
 110564c:	90000261 	adrp	x1, 1151000 <small_prime+0x168>
 1105650:	91222c63 	add	x3, x3, #0x88b
 1105654:	91106c21 	add	x1, x1, #0x41b
 1105658:	90000260 	adrp	x0, 1151000 <small_prime+0x168>
 110565c:	91185000 	add	x0, x0, #0x614
 1105660:	52804442 	mov	w2, #0x222                 	// #546
 1105664:	94003312 	bl	11122ac <_assert_log>
 1105668:	94003322 	bl	11122f0 <_assert_break>
	thread_lock_global();
 110566c:	97fffe2d 	bl	1104f20 <thread_lock_global>
		if (threads[n].state == THREAD_STATE_FREE) {
 1105670:	b00002a0 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1105674:	aa0003f9 	mov	x25, x0
 1105678:	f9417801 	ldr	x1, [x0, #752]
 110567c:	b9411822 	ldr	w2, [x1, #280]
 1105680:	34000522 	cbz	w2, 1105724 <thread_alloc_and_run+0x118>
 1105684:	b9481820 	ldr	w0, [x1, #2072]
 1105688:	35000520 	cbnz	w0, 110572c <thread_alloc_and_run+0x120>
	for (n = 0; n < CFG_NUM_THREADS; n++) {
 110568c:	d2800033 	mov	x19, #0x1                   	// #1
			threads[n].state = THREAD_STATE_ACTIVE;
 1105690:	f9417b20 	ldr	x0, [x25, #752]
 1105694:	d280e001 	mov	x1, #0x700                 	// #1792
			found_thread = true;
 1105698:	5280003a 	mov	w26, #0x1                   	// #1
			threads[n].state = THREAD_STATE_ACTIVE;
 110569c:	9b010260 	madd	x0, x19, x1, x0
 11056a0:	52800041 	mov	w1, #0x2                   	// #2
 11056a4:	b9011801 	str	w1, [x0, #280]
	thread_unlock_global();
 11056a8:	97fffe79 	bl	110508c <thread_unlock_global>
	if (!found_thread)
 11056ac:	3400047a 	cbz	w26, 1105738 <thread_alloc_and_run+0x12c>
	threads[n].flags = 0;
 11056b0:	d280e004 	mov	x4, #0x700                 	// #1792
	l->curr_thread = n;
 11056b4:	79005293 	strh	w19, [x20, #40]
	threads[n].flags = 0;
 11056b8:	f9417b20 	ldr	x0, [x25, #752]
 11056bc:	9b047e64 	mul	x4, x19, x4
	thread->regs.pc = (uint64_t)pc;
 11056c0:	f9415b39 	ldr	x25, [x25, #688]
	threads[n].flags = 0;
 11056c4:	8b040013 	add	x19, x0, x4
	thread->regs.cpsr = SPSR_64(SPSR_64_MODE_EL1, SPSR_64_MODE_SP_EL0,
 11056c8:	d2803081 	mov	x1, #0x184                 	// #388
 11056cc:	a9008679 	stp	x25, x1, [x19, #8]
	threads[n].flags = 0;
 11056d0:	b9012a7f 	str	wzr, [x19, #296]
	thread->regs.sp = thread->stack_va_end;
 11056d4:	f9409261 	ldr	x1, [x19, #288]
 11056d8:	f8246801 	str	x1, [x0, x4]
	thread->regs.x[1] = a1;
 11056dc:	a901de78 	stp	x24, x23, [x19, #24]
	thread->regs.x[3] = a3;
 11056e0:	a902d676 	stp	x22, x21, [x19, #40]
	thread->regs.x[5] = a5;
 11056e4:	a903fe7f 	stp	xzr, xzr, [x19, #56]
	thread->regs.x[7] = a7;
 11056e8:	a904fe7f 	stp	xzr, xzr, [x19, #72]
	thread->regs.x[29] = 0;
 11056ec:	f900827f 	str	xzr, [x19, #256]
	thread_lazy_save_ns_vfp();
 11056f0:	97ffff6e 	bl	11054a8 <thread_lazy_save_ns_vfp>
	l->flags &= ~THREAD_CLF_TMP;
 11056f4:	b9402e80 	ldr	w0, [x20, #44]
 11056f8:	121f7800 	and	w0, w0, #0xfffffffe
 11056fc:	b9002e80 	str	w0, [x20, #44]
	thread_resume(&threads[n].regs);
 1105700:	aa1303e0 	mov	x0, x19
 1105704:	97fffc27 	bl	11047a0 <thread_resume>
	panic();
 1105708:	90000262 	adrp	x2, 1151000 <small_prime+0x168>
 110570c:	90000260 	adrp	x0, 1151000 <small_prime+0x168>
 1105710:	91222c42 	add	x2, x2, #0x88b
 1105714:	91106c00 	add	x0, x0, #0x41b
 1105718:	d2800003 	mov	x3, #0x0                   	// #0
 110571c:	528047a1 	mov	w1, #0x23d                 	// #573
 1105720:	94003752 	bl	1113468 <__do_panic>
	for (n = 0; n < CFG_NUM_THREADS; n++) {
 1105724:	d2800013 	mov	x19, #0x0                   	// #0
 1105728:	17ffffda 	b	1105690 <thread_alloc_and_run+0x84>
 110572c:	d2800053 	mov	x19, #0x2                   	// #2
	bool found_thread = false;
 1105730:	5280001a 	mov	w26, #0x0                   	// #0
 1105734:	17ffffdd 	b	11056a8 <thread_alloc_and_run+0x9c>
}
 1105738:	a94153f3 	ldp	x19, x20, [sp, #16]
 110573c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1105740:	a94363f7 	ldp	x23, x24, [sp, #48]
 1105744:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1105748:	a8c57bfd 	ldp	x29, x30, [sp], #80
 110574c:	d65f03c0 	ret

0000000001105750 <thread_lazy_restore_ns_vfp>:
{
 1105750:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1105754:	910003fd 	mov	x29, sp
 1105758:	a90153f3 	stp	x19, x20, [sp, #16]
	struct thread_ctx *thr = threads + thread_get_id();
 110575c:	b00002b3 	adrp	x19, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1105760:	97ffff41 	bl	1105464 <thread_get_id>
 1105764:	f9417a73 	ldr	x19, [x19, #752]
 1105768:	13003c00 	sxth	w0, w0
 110576c:	5280e001 	mov	w1, #0x700                 	// #1792
 1105770:	9b214c13 	smaddl	x19, w0, w1, x19
	assert(!thr->vfp_state.sec_lazy_saved && !thr->vfp_state.sec_saved);
 1105774:	b9415260 	ldr	w0, [x19, #336]
	struct thread_user_vfp_state *tuv = thr->vfp_state.uvfp;
 1105778:	f942c274 	ldr	x20, [x19, #1408]
	assert(!thr->vfp_state.sec_lazy_saved && !thr->vfp_state.sec_saved);
 110577c:	72183c1f 	tst	w0, #0xffff00
 1105780:	54000140 	b.eq	11057a8 <thread_lazy_restore_ns_vfp+0x58>  // b.none
 1105784:	90000263 	adrp	x3, 1151000 <small_prime+0x168>
 1105788:	90000261 	adrp	x1, 1151000 <small_prime+0x168>
 110578c:	91216463 	add	x3, x3, #0x859
 1105790:	91106c21 	add	x1, x1, #0x41b
 1105794:	90000260 	adrp	x0, 1151000 <small_prime+0x168>
 1105798:	9118e000 	add	x0, x0, #0x638
 110579c:	52803682 	mov	w2, #0x1b4                 	// #436
 11057a0:	940032c3 	bl	11122ac <_assert_log>
 11057a4:	940032d3 	bl	11122f0 <_assert_break>
	if (tuv && tuv->lazy_saved && !tuv->saved) {
 11057a8:	b4000154 	cbz	x20, 11057d0 <thread_lazy_restore_ns_vfp+0x80>
 11057ac:	39484280 	ldrb	w0, [x20, #528]
 11057b0:	34000100 	cbz	w0, 11057d0 <thread_lazy_restore_ns_vfp+0x80>
 11057b4:	39484680 	ldrb	w0, [x20, #529]
 11057b8:	350000c0 	cbnz	w0, 11057d0 <thread_lazy_restore_ns_vfp+0x80>
		vfp_lazy_save_state_final(&tuv->vfp, false /*!force_save*/);
 11057bc:	aa1403e0 	mov	x0, x20
 11057c0:	52800001 	mov	w1, #0x0                   	// #0
 11057c4:	940008fd 	bl	1107bb8 <vfp_lazy_save_state_final>
		tuv->saved = true;
 11057c8:	52800020 	mov	w0, #0x1                   	// #1
 11057cc:	39084680 	strb	w0, [x20, #529]
	vfp_lazy_restore_state(&thr->vfp_state.ns, thr->vfp_state.ns_saved);
 11057d0:	39454261 	ldrb	w1, [x19, #336]
 11057d4:	91058260 	add	x0, x19, #0x160
 11057d8:	94000916 	bl	1107c30 <vfp_lazy_restore_state>
	thr->vfp_state.ns_saved = false;
 11057dc:	3905427f 	strb	wzr, [x19, #336]
}
 11057e0:	a94153f3 	ldp	x19, x20, [sp, #16]
 11057e4:	a8c27bfd 	ldp	x29, x30, [sp], #32
 11057e8:	d65f03c0 	ret

00000000011057ec <thread_state_free>:
{
 11057ec:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 11057f0:	910003fd 	mov	x29, sp
 11057f4:	a90153f3 	stp	x19, x20, [sp, #16]
	struct thread_core_local *l = thread_get_core_local();
 11057f8:	97fffe5f 	bl	1105174 <thread_get_core_local>
	int ct = l->curr_thread;
 11057fc:	79805013 	ldrsh	x19, [x0, #40]
	assert(ct != THREAD_ID_INVALID);
 1105800:	3100067f 	cmn	w19, #0x1
 1105804:	54000141 	b.ne	110582c <thread_state_free+0x40>  // b.any
 1105808:	90000263 	adrp	x3, 1151000 <small_prime+0x168>
 110580c:	90000261 	adrp	x1, 1151000 <small_prime+0x168>
 1105810:	90000260 	adrp	x0, 1151000 <small_prime+0x168>
 1105814:	91235063 	add	x3, x3, #0x8d4
 1105818:	91106c21 	add	x1, x1, #0x41b
 110581c:	91177000 	add	x0, x0, #0x5dc
 1105820:	528068e2 	mov	w2, #0x347                 	// #839
	assert(threads[ct].state == THREAD_STATE_ACTIVE);
 1105824:	940032a2 	bl	11122ac <_assert_log>
 1105828:	940032b2 	bl	11122f0 <_assert_break>
 110582c:	aa0003f4 	mov	x20, x0
	thread_lazy_restore_ns_vfp();
 1105830:	97ffffc8 	bl	1105750 <thread_lazy_restore_ns_vfp>
	thread_lock_global();
 1105834:	97fffdbb 	bl	1104f20 <thread_lock_global>
	assert(threads[ct].state == THREAD_STATE_ACTIVE);
 1105838:	b00002a1 	adrp	x1, 115a000 <__scattered_array_1phys_mem_map+0x8>
 110583c:	d280e000 	mov	x0, #0x700                 	// #1792
 1105840:	f9417821 	ldr	x1, [x1, #752]
 1105844:	9b000661 	madd	x1, x19, x0, x1
 1105848:	b9411820 	ldr	w0, [x1, #280]
 110584c:	7100081f 	cmp	w0, #0x2
 1105850:	54000120 	b.eq	1105874 <thread_state_free+0x88>  // b.none
 1105854:	90000263 	adrp	x3, 1151000 <small_prime+0x168>
 1105858:	90000261 	adrp	x1, 1151000 <small_prime+0x168>
 110585c:	90000260 	adrp	x0, 1151000 <small_prime+0x168>
 1105860:	91235063 	add	x3, x3, #0x8d4
 1105864:	91106c21 	add	x1, x1, #0x41b
 1105868:	9119d000 	add	x0, x0, #0x674
 110586c:	52806a02 	mov	w2, #0x350                 	// #848
 1105870:	17ffffed 	b	1105824 <thread_state_free+0x38>
	threads[ct].state = THREAD_STATE_FREE;
 1105874:	b901183f 	str	wzr, [x1, #280]
	l->curr_thread = THREAD_ID_INVALID;
 1105878:	12800000 	mov	w0, #0xffffffff            	// #-1
	threads[ct].flags = 0;
 110587c:	b901283f 	str	wzr, [x1, #296]
	l->curr_thread = THREAD_ID_INVALID;
 1105880:	79005280 	strh	w0, [x20, #40]
}
 1105884:	a94153f3 	ldp	x19, x20, [sp, #16]
 1105888:	a8c27bfd 	ldp	x29, x30, [sp], #32
	thread_unlock_global();
 110588c:	17fffe00 	b	110508c <thread_unlock_global>

0000000001105890 <thread_init_threads>:
{
 1105890:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
		if (!thread_init_stack(n, GET_STACK_BOTTOM(stack_thread, n)))
 1105894:	f0000421 	adrp	x1, 118c000 <__nozi_end+0x2f00>
 1105898:	b0000440 	adrp	x0, 118e000 <stack_thread+0x1e00>
{
 110589c:	910003fd 	mov	x29, sp
 11058a0:	f9000bf3 	str	x19, [sp, #16]
	threads[thread_id].stack_va_end = sp;
 11058a4:	b00002b3 	adrp	x19, 115a000 <__scattered_array_1phys_mem_map+0x8>
		if (!thread_init_stack(n, GET_STACK_BOTTOM(stack_thread, n)))
 11058a8:	91080021 	add	x1, x1, #0x200
 11058ac:	91090000 	add	x0, x0, #0x240
	threads[thread_id].stack_va_end = sp;
 11058b0:	f9417a73 	ldr	x19, [x19, #752]
		if (!thread_init_stack(n, GET_STACK_BOTTOM(stack_thread, n)))
 11058b4:	d2840602 	mov	x2, #0x2030                	// #8240
 11058b8:	8b020000 	add	x0, x0, x2
 11058bc:	8b020021 	add	x1, x1, x2
	threads[thread_id].stack_va_end = sp;
 11058c0:	f9009261 	str	x1, [x19, #288]
 11058c4:	f9041260 	str	x0, [x19, #2080]
	pgt_init();
 11058c8:	94001886 	bl	110bae0 <pgt_init>
		TAILQ_INIT(&threads[n].tsd.sess_stack);
 11058cc:	f902d67f 	str	xzr, [x19, #1448]
 11058d0:	9116a260 	add	x0, x19, #0x5a8
 11058d4:	f902da60 	str	x0, [x19, #1456]
 11058d8:	9132a260 	add	x0, x19, #0xca8
		SLIST_INIT(&threads[n].tsd.pgt_cache);
 11058dc:	f902e27f 	str	xzr, [x19, #1472]
		TAILQ_INIT(&threads[n].tsd.sess_stack);
 11058e0:	f906567f 	str	xzr, [x19, #3240]
 11058e4:	f9065a60 	str	x0, [x19, #3248]
		SLIST_INIT(&threads[n].tsd.pgt_cache);
 11058e8:	f906627f 	str	xzr, [x19, #3264]
}
 11058ec:	f9400bf3 	ldr	x19, [sp, #16]
 11058f0:	a8c27bfd 	ldp	x29, x30, [sp], #32
 11058f4:	d65f03c0 	ret

00000000011058f8 <thread_init_boot_thread>:
{
 11058f8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 11058fc:	910003fd 	mov	x29, sp
 1105900:	f9000bf3 	str	x19, [sp, #16]
	struct thread_core_local *l = thread_get_core_local();
 1105904:	97fffe1c 	bl	1105174 <thread_get_core_local>
 1105908:	aa0003f3 	mov	x19, x0
	thread_init_threads();
 110590c:	97ffffe1 	bl	1105890 <thread_init_threads>
	threads[0].state = THREAD_STATE_ACTIVE;
 1105910:	b00002a0 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1105914:	52800041 	mov	w1, #0x2                   	// #2
 1105918:	f9417800 	ldr	x0, [x0, #752]
	l->curr_thread = 0;
 110591c:	7900527f 	strh	wzr, [x19, #40]
}
 1105920:	f9400bf3 	ldr	x19, [sp, #16]
	threads[0].state = THREAD_STATE_ACTIVE;
 1105924:	b9011801 	str	w1, [x0, #280]
}
 1105928:	a8c27bfd 	ldp	x29, x30, [sp], #32
 110592c:	d65f03c0 	ret

0000000001105930 <thread_init_thread_core_local>:
		tcl[n].curr_thread = THREAD_ID_INVALID;
 1105930:	b00002a0 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
		tcl[n].flags = THREAD_CLF_TMP;
 1105934:	52800021 	mov	w1, #0x1                   	// #1
		tcl[n].curr_thread = THREAD_ID_INVALID;
 1105938:	12800002 	mov	w2, #0xffffffff            	// #-1
 110593c:	f9421000 	ldr	x0, [x0, #1056]
		tcl[n].flags = THREAD_CLF_TMP;
 1105940:	b9002c01 	str	w1, [x0, #44]
 1105944:	b9006c01 	str	w1, [x0, #108]
 1105948:	b900ac01 	str	w1, [x0, #172]
 110594c:	b900ec01 	str	w1, [x0, #236]
	tcl[0].tmp_stack_va_end = GET_STACK_BOTTOM(stack_tmp, 0);
 1105950:	f0000441 	adrp	x1, 1190000 <stack_thread+0x3e00>
 1105954:	910a0021 	add	x1, x1, #0x280
		tcl[n].curr_thread = THREAD_ID_INVALID;
 1105958:	79005002 	strh	w2, [x0, #40]
	tcl[0].tmp_stack_va_end = GET_STACK_BOTTOM(stack_tmp, 0);
 110595c:	9120c021 	add	x1, x1, #0x830
 1105960:	f9001001 	str	x1, [x0, #32]
		tcl[n].curr_thread = THREAD_ID_INVALID;
 1105964:	7900d002 	strh	w2, [x0, #104]
 1105968:	79015002 	strh	w2, [x0, #168]
 110596c:	7901d002 	strh	w2, [x0, #232]
}
 1105970:	d65f03c0 	ret

0000000001105974 <thread_init_primary>:
{
 1105974:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
	INIT_CANARY(stack_tmp);
 1105978:	f0000440 	adrp	x0, 1190000 <stack_thread+0x3e00>
 110597c:	910a0002 	add	x2, x0, #0x280
{
 1105980:	910003fd 	mov	x29, sp
	INIT_CANARY(stack_tmp);
 1105984:	529bdbc1 	mov	w1, #0xdede                	// #57054
 1105988:	72bbdbc1 	movk	w1, #0xdede, lsl #16
 110598c:	b9028001 	str	w1, [x0, #640]
 1105990:	52957560 	mov	w0, #0xabab                	// #43947
{
 1105994:	a90153f3 	stp	x19, x20, [sp, #16]
	INIT_CANARY(stack_tmp);
 1105998:	72b57560 	movk	w0, #0xabab, lsl #16
	INIT_CANARY(stack_abt);
 110599c:	90000423 	adrp	x3, 1189000 <l1_xlation_table>
{
 11059a0:	f90013f5 	str	x21, [sp, #32]
	vaddr_t v = (vaddr_t)thread_excp_vect;
 11059a4:	b00002b3 	adrp	x19, 115a000 <__scattered_array_1phys_mem_map+0x8>
	INIT_CANARY(stack_tmp);
 11059a8:	b9083c40 	str	w0, [x2, #2108]
	thread_user_kcode_size = ve - thread_user_kcode_va;
 11059ac:	900002d4 	adrp	x20, 115d000 <_curve_names+0x590>
	INIT_CANARY(stack_tmp);
 11059b0:	b9084041 	str	w1, [x2, #2112]
	thread_user_kcode_va = ROUNDDOWN(v, CORE_MMU_USER_CODE_SIZE);
 11059b4:	900002d5 	adrp	x21, 115d000 <_curve_names+0x590>
	INIT_CANARY(stack_tmp);
 11059b8:	b9107c40 	str	w0, [x2, #4220]
 11059bc:	b9108041 	str	w1, [x2, #4224]
 11059c0:	b918bc40 	str	w0, [x2, #6332]
 11059c4:	b918c041 	str	w1, [x2, #6336]
 11059c8:	b920fc40 	str	w0, [x2, #8444]
	INIT_CANARY(stack_abt);
 11059cc:	91040062 	add	x2, x3, #0x100
 11059d0:	b9010061 	str	w1, [x3, #256]
	INIT_CANARY(stack_thread);
 11059d4:	f0000423 	adrp	x3, 118c000 <__nozi_end+0x2f00>
	INIT_CANARY(stack_abt);
 11059d8:	b90c3c40 	str	w0, [x2, #3132]
 11059dc:	b90c4041 	str	w1, [x2, #3136]
 11059e0:	b9187c40 	str	w0, [x2, #6268]
 11059e4:	b9188041 	str	w1, [x2, #6272]
 11059e8:	b924bc40 	str	w0, [x2, #9404]
 11059ec:	b924c041 	str	w1, [x2, #9408]
 11059f0:	b930fc40 	str	w0, [x2, #12540]
	INIT_CANARY(stack_thread);
 11059f4:	91080062 	add	x2, x3, #0x200
 11059f8:	b9020061 	str	w1, [x3, #512]
 11059fc:	b9203c40 	str	w0, [x2, #8252]
 1105a00:	b9204041 	str	w1, [x2, #8256]
 1105a04:	91401042 	add	x2, x2, #0x4, lsl #12
 1105a08:	b9007c40 	str	w0, [x2, #124]
	vaddr_t v = (vaddr_t)thread_excp_vect;
 1105a0c:	f9420e60 	ldr	x0, [x19, #1048]
 1105a10:	f9001fe0 	str	x0, [sp, #56]
	thread_user_kcode_va = ROUNDDOWN(v, CORE_MMU_USER_CODE_SIZE);
 1105a14:	9274cc01 	and	x1, x0, #0xfffffffffffff000
 1105a18:	f90606a1 	str	x1, [x21, #3080]
	ve = ROUNDUP(ve, CORE_MMU_USER_CODE_SIZE);
 1105a1c:	f9414a60 	ldr	x0, [x19, #656]
 1105a20:	913ffc00 	add	x0, x0, #0xfff
 1105a24:	9274cc00 	and	x0, x0, #0xfffffffffffff000
	thread_user_kcode_size = ve - thread_user_kcode_va;
 1105a28:	cb010000 	sub	x0, x0, x1
	core_mmu_get_user_va_range(&v, NULL);
 1105a2c:	d2800001 	mov	x1, #0x0                   	// #0
	thread_user_kcode_size = ve - thread_user_kcode_va;
 1105a30:	f9060280 	str	x0, [x20, #3072]
	core_mmu_get_user_va_range(&v, NULL);
 1105a34:	9100e3e0 	add	x0, sp, #0x38
 1105a38:	940015a6 	bl	110b0d0 <core_mmu_get_user_va_range>
	thread_user_kcode_offset = thread_user_kcode_va - v;
 1105a3c:	f9423262 	ldr	x2, [x19, #1120]
 1105a40:	f94606a1 	ldr	x1, [x21, #3080]
 1105a44:	f9401fe0 	ldr	x0, [sp, #56]
}
 1105a48:	f94013f5 	ldr	x21, [sp, #32]
	thread_user_kcode_offset = thread_user_kcode_va - v;
 1105a4c:	cb000021 	sub	x1, x1, x0
 1105a50:	f9000041 	str	x1, [x2]
	thread_user_kdata_sp_offset = (vaddr_t)thread_core_local - v;
 1105a54:	f941de61 	ldr	x1, [x19, #952]
 1105a58:	f9460282 	ldr	x2, [x20, #3072]
 1105a5c:	f9421273 	ldr	x19, [x19, #1056]
 1105a60:	8b020000 	add	x0, x0, x2
 1105a64:	cb000273 	sub	x19, x19, x0
 1105a68:	f9000033 	str	x19, [x1]
}
 1105a6c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1105a70:	a8c47bfd 	ldp	x29, x30, [sp], #64
 1105a74:	d65f03c0 	ret

0000000001105a78 <thread_init_per_cpu>:
{
 1105a78:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1105a7c:	910003fd 	mov	x29, sp
 1105a80:	a90153f3 	stp	x19, x20, [sp, #16]
	size_t pos = get_core_pos();
 1105a84:	97fffd55 	bl	1104fd8 <get_core_pos>
 1105a88:	aa0003f3 	mov	x19, x0
	struct thread_core_local *l = thread_get_core_local();
 1105a8c:	97fffdba 	bl	1105174 <thread_get_core_local>
	set_tmp_stack(l, GET_STACK_BOTTOM(stack_tmp, pos) - STACK_TMP_OFFS);
 1105a90:	f0000442 	adrp	x2, 1190000 <stack_thread+0x3e00>
 1105a94:	910a0042 	add	x2, x2, #0x280
 1105a98:	d2810801 	mov	x1, #0x840                 	// #2112
 1105a9c:	9b010a61 	madd	x1, x19, x1, x2
	set_abt_stack(l, GET_STACK_BOTTOM(stack_abt, pos));
 1105aa0:	d2818802 	mov	x2, #0xc40                 	// #3136
	set_tmp_stack(l, GET_STACK_BOTTOM(stack_tmp, pos) - STACK_TMP_OFFS);
 1105aa4:	9120c021 	add	x1, x1, #0x830
	l->tmp_stack_va_end = sp;
 1105aa8:	f9001001 	str	x1, [x0, #32]
	set_abt_stack(l, GET_STACK_BOTTOM(stack_abt, pos));
 1105aac:	90000421 	adrp	x1, 1189000 <l1_xlation_table>
 1105ab0:	91040021 	add	x1, x1, #0x100
 1105ab4:	9b020673 	madd	x19, x19, x2, x1
 1105ab8:	9130c273 	add	x19, x19, #0xc30
	l->abt_stack_va_end = sp;
 1105abc:	f9001813 	str	x19, [x0, #48]
DEFINE_U64_REG_READ_FUNC(esr_el1)
DEFINE_U64_REG_READ_FUNC(far_el1)
DEFINE_U64_REG_READ_FUNC(mpidr_el1)
/* Alias for reading this register to avoid ifdefs in code */
#define read_mpidr() read_mpidr_el1()
DEFINE_U64_REG_READ_FUNC(midr_el1)
 1105ac0:	d5380000 	mrs	x0, midr_el1
	return (midr >> MIDR_IMPLEMENTER_SHIFT) & MIDR_IMPLEMENTER_MASK;
 1105ac4:	53187c01 	lsr	w1, w0, #24
 1105ac8:	b00002b3 	adrp	x19, 115a000 <__scattered_array_1phys_mem_map+0x8>
	if (get_midr_implementer(midr) != MIDR_IMPLEMENTER_ARM)
 1105acc:	7101043f 	cmp	w1, #0x41
 1105ad0:	54000060 	b.eq	1105adc <thread_init_per_cpu+0x64>  // b.none
		return (vaddr_t)thread_excp_vect;
 1105ad4:	f9420e73 	ldr	x19, [x19, #1048]
 1105ad8:	14000024 	b	1105b68 <thread_init_per_cpu+0xf0>
	return (midr >> MIDR_PRIMARY_PART_NUM_SHIFT) &
 1105adc:	53043c00 	ubfx	w0, w0, #4, #12
	switch (get_midr_primary_part(midr)) {
 1105ae0:	51341c00 	sub	w0, w0, #0xd07
 1105ae4:	71000c1f 	cmp	w0, #0x3
 1105ae8:	54ffff68 	b.hi	1105ad4 <thread_init_per_cpu+0x5c>  // b.pmore
	r = thread_smc(SMCCC_VERSION, 0, 0, 0);
 1105aec:	d2800003 	mov	x3, #0x0                   	// #0
 1105af0:	d2800002 	mov	x2, #0x0                   	// #0
 1105af4:	d2800001 	mov	x1, #0x0                   	// #0
 1105af8:	d2b00000 	mov	x0, #0x80000000            	// #2147483648
 1105afc:	90000274 	adrp	x20, 1151000 <small_prime+0x168>
 1105b00:	97fffb4c 	bl	1104830 <thread_smc>
	if (r < 0x10001)	/* compare with version 1.1 */
 1105b04:	7140401f 	cmp	w0, #0x10, lsl #12
 1105b08:	5400038d 	b.le	1105b78 <thread_init_per_cpu+0x100>
	r = thread_smc(SMCCC_ARCH_FEATURES, SMCCC_ARCH_WORKAROUND_1, 0, 0);
 1105b0c:	d2800003 	mov	x3, #0x0                   	// #0
 1105b10:	d2800002 	mov	x2, #0x0                   	// #0
 1105b14:	320183e1 	mov	w1, #0x80008000            	// #-2147450880
 1105b18:	320107e0 	mov	w0, #0x80000001            	// #-2147483647
 1105b1c:	97fffb45 	bl	1104830 <thread_smc>
	if (probe_workaround_available()) {
 1105b20:	37f802c0 	tbnz	w0, #31, 1105b78 <thread_init_per_cpu+0x100>
		DMSG("SMCCC_ARCH_WORKAROUND_1 (%#08" PRIx32 ") available",
 1105b24:	91242694 	add	x20, x20, #0x909
 1105b28:	320183e5 	mov	w5, #0x80008000            	// #-2147450880
 1105b2c:	aa1403e0 	mov	x0, x20
 1105b30:	52800023 	mov	w3, #0x1                   	// #1
 1105b34:	52800062 	mov	w2, #0x3                   	// #3
 1105b38:	52808fa1 	mov	w1, #0x47d                 	// #1149
		return select_vector((vaddr_t)thread_excp_vect_workaround);
 1105b3c:	f941e673 	ldr	x19, [x19, #968]
		DMSG("SMCCC_ARCH_WORKAROUND_1 (%#08" PRIx32 ") available",
 1105b40:	90000264 	adrp	x4, 1151000 <small_prime+0x168>
 1105b44:	911a7484 	add	x4, x4, #0x69d
 1105b48:	9400fc7f 	bl	1144d44 <trace_printf>
		DMSG("SMC Workaround for CVE-2017-5715 used");
 1105b4c:	90000264 	adrp	x4, 1151000 <small_prime+0x168>
 1105b50:	aa1403e0 	mov	x0, x20
 1105b54:	911b1c84 	add	x4, x4, #0x6c7
 1105b58:	52800023 	mov	w3, #0x1                   	// #1
 1105b5c:	52800062 	mov	w2, #0x3                   	// #3
 1105b60:	52808fe1 	mov	w1, #0x47f                 	// #1151
 1105b64:	9400fc78 	bl	1144d44 <trace_printf>
	thread_init_vbar(get_excp_vect());
 1105b68:	aa1303e0 	mov	x0, x19
}
 1105b6c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1105b70:	a8c27bfd 	ldp	x29, x30, [sp], #32
	thread_init_vbar(get_excp_vect());
 1105b74:	17fffb31 	b	1104838 <thread_init_vbar>
	DMSG("SMCCC_ARCH_WORKAROUND_1 (%#08" PRIx32 ") unavailable",
 1105b78:	91242694 	add	x20, x20, #0x909
 1105b7c:	320183e5 	mov	w5, #0x80008000            	// #-2147450880
 1105b80:	aa1403e0 	mov	x0, x20
 1105b84:	52800023 	mov	w3, #0x1                   	// #1
 1105b88:	52800062 	mov	w2, #0x3                   	// #3
 1105b8c:	52809061 	mov	w1, #0x483                 	// #1155
 1105b90:	90000264 	adrp	x4, 1151000 <small_prime+0x168>
 1105b94:	911bb484 	add	x4, x4, #0x6ed
 1105b98:	9400fc6b 	bl	1144d44 <trace_printf>
	DMSG("SMC Workaround for CVE-2017-5715 not needed (if ARM-TF is up to date)");
 1105b9c:	aa1403e0 	mov	x0, x20
 1105ba0:	90000264 	adrp	x4, 1151000 <small_prime+0x168>
 1105ba4:	52800023 	mov	w3, #0x1                   	// #1
 1105ba8:	911c6484 	add	x4, x4, #0x719
 1105bac:	52800062 	mov	w2, #0x3                   	// #3
 1105bb0:	528090a1 	mov	w1, #0x485                 	// #1157
 1105bb4:	9400fc64 	bl	1144d44 <trace_printf>
	return (vaddr_t)thread_excp_vect;
 1105bb8:	f9420e73 	ldr	x19, [x19, #1048]
 1105bbc:	17ffffeb 	b	1105b68 <thread_init_per_cpu+0xf0>

0000000001105bc0 <thread_get_tsd>:
{
 1105bc0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 1105bc4:	910003fd 	mov	x29, sp
	return &threads[thread_get_id()].tsd;
 1105bc8:	97fffe27 	bl	1105464 <thread_get_id>
 1105bcc:	13003c00 	sxth	w0, w0
 1105bd0:	d280b502 	mov	x2, #0x5a8                 	// #1448
 1105bd4:	5280e001 	mov	w1, #0x700                 	// #1792
}
 1105bd8:	a8c17bfd 	ldp	x29, x30, [sp], #16
	return &threads[thread_get_id()].tsd;
 1105bdc:	9b200821 	smaddl	x1, w1, w0, x2
 1105be0:	b00002a0 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
}
 1105be4:	f9417800 	ldr	x0, [x0, #752]
 1105be8:	8b010000 	add	x0, x0, x1
 1105bec:	d65f03c0 	ret

0000000001105bf0 <thread_get_ctx_regs>:
{
 1105bf0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 1105bf4:	910003fd 	mov	x29, sp
	struct thread_core_local *l = thread_get_core_local();
 1105bf8:	97fffd5f 	bl	1105174 <thread_get_core_local>
	assert(l->curr_thread != THREAD_ID_INVALID);
 1105bfc:	79c05000 	ldrsh	w0, [x0, #40]
 1105c00:	3100041f 	cmn	w0, #0x1
 1105c04:	54000141 	b.ne	1105c2c <thread_get_ctx_regs+0x3c>  // b.any
 1105c08:	90000263 	adrp	x3, 1151000 <small_prime+0x168>
 1105c0c:	90000261 	adrp	x1, 1151000 <small_prime+0x168>
 1105c10:	91245c63 	add	x3, x3, #0x917
 1105c14:	91106c21 	add	x1, x1, #0x41b
 1105c18:	90000260 	adrp	x0, 1151000 <small_prime+0x168>
 1105c1c:	911d7c00 	add	x0, x0, #0x75f
 1105c20:	528099a2 	mov	w2, #0x4cd                 	// #1229
 1105c24:	940031a2 	bl	11122ac <_assert_log>
 1105c28:	940031b2 	bl	11122f0 <_assert_break>
	return &threads[l->curr_thread].regs;
 1105c2c:	b00002a1 	adrp	x1, 115a000 <__scattered_array_1phys_mem_map+0x8>
}
 1105c30:	5280e002 	mov	w2, #0x700                 	// #1792
 1105c34:	a8c17bfd 	ldp	x29, x30, [sp], #16
 1105c38:	f9417821 	ldr	x1, [x1, #752]
 1105c3c:	9b220400 	smaddl	x0, w0, w2, x1
 1105c40:	d65f03c0 	ret

0000000001105c44 <thread_set_foreign_intr>:
{
 1105c44:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1105c48:	910003fd 	mov	x29, sp
 1105c4c:	a90153f3 	stp	x19, x20, [sp, #16]
 1105c50:	12001c14 	and	w20, w0, #0xff
	uint32_t exceptions = thread_mask_exceptions(THREAD_EXCP_FOREIGN_INTR);
 1105c54:	52800040 	mov	w0, #0x2                   	// #2
 1105c58:	97fffd38 	bl	1105138 <thread_mask_exceptions>
 1105c5c:	2a0003f3 	mov	w19, w0
	l = thread_get_core_local();
 1105c60:	97fffd45 	bl	1105174 <thread_get_core_local>
	assert(l->curr_thread != THREAD_ID_INVALID);
 1105c64:	79805001 	ldrsh	x1, [x0, #40]
 1105c68:	3100043f 	cmn	w1, #0x1
 1105c6c:	54000141 	b.ne	1105c94 <thread_set_foreign_intr+0x50>  // b.any
 1105c70:	90000263 	adrp	x3, 1151000 <small_prime+0x168>
 1105c74:	90000261 	adrp	x1, 1151000 <small_prime+0x168>
 1105c78:	9124ac63 	add	x3, x3, #0x92b
 1105c7c:	91106c21 	add	x1, x1, #0x41b
 1105c80:	90000260 	adrp	x0, 1151000 <small_prime+0x168>
 1105c84:	911d7c00 	add	x0, x0, #0x75f
 1105c88:	52809b22 	mov	w2, #0x4d9                 	// #1241
 1105c8c:	94003188 	bl	11122ac <_assert_log>
 1105c90:	94003198 	bl	11122f0 <_assert_break>
	if (enable) {
 1105c94:	b00002a0 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1105c98:	d280e002 	mov	x2, #0x700                 	// #1792
 1105c9c:	f9417800 	ldr	x0, [x0, #752]
 1105ca0:	9b020021 	madd	x1, x1, x2, x0
 1105ca4:	b9412822 	ldr	w2, [x1, #296]
 1105ca8:	340000f4 	cbz	w20, 1105cc4 <thread_set_foreign_intr+0x80>
		threads[l->curr_thread].flags |=
 1105cac:	321f0042 	orr	w2, w2, #0x2
		thread_set_exceptions(exceptions & ~THREAD_EXCP_FOREIGN_INTR);
 1105cb0:	121e7a60 	and	w0, w19, #0xfffffffd
}
 1105cb4:	a94153f3 	ldp	x19, x20, [sp, #16]
		threads[l->curr_thread].flags |=
 1105cb8:	b9012822 	str	w2, [x1, #296]
}
 1105cbc:	a8c27bfd 	ldp	x29, x30, [sp], #32
		thread_set_exceptions(exceptions & ~THREAD_EXCP_FOREIGN_INTR);
 1105cc0:	17fffd05 	b	11050d4 <thread_set_exceptions>
		threads[l->curr_thread].flags &=
 1105cc4:	121e7842 	and	w2, w2, #0xfffffffd
}
 1105cc8:	a94153f3 	ldp	x19, x20, [sp, #16]
		threads[l->curr_thread].flags &=
 1105ccc:	b9012822 	str	w2, [x1, #296]
}
 1105cd0:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1105cd4:	d65f03c0 	ret

0000000001105cd8 <thread_restore_foreign_intr>:
{
 1105cd8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	uint32_t exceptions = thread_mask_exceptions(THREAD_EXCP_FOREIGN_INTR);
 1105cdc:	52800040 	mov	w0, #0x2                   	// #2
{
 1105ce0:	910003fd 	mov	x29, sp
 1105ce4:	f9000bf3 	str	x19, [sp, #16]
	uint32_t exceptions = thread_mask_exceptions(THREAD_EXCP_FOREIGN_INTR);
 1105ce8:	97fffd14 	bl	1105138 <thread_mask_exceptions>
 1105cec:	2a0003f3 	mov	w19, w0
	l = thread_get_core_local();
 1105cf0:	97fffd21 	bl	1105174 <thread_get_core_local>
	assert(l->curr_thread != THREAD_ID_INVALID);
 1105cf4:	79805001 	ldrsh	x1, [x0, #40]
 1105cf8:	3100043f 	cmn	w1, #0x1
 1105cfc:	54000141 	b.ne	1105d24 <thread_restore_foreign_intr+0x4c>  // b.any
 1105d00:	90000263 	adrp	x3, 1151000 <small_prime+0x168>
 1105d04:	90000261 	adrp	x1, 1151000 <small_prime+0x168>
 1105d08:	91250c63 	add	x3, x3, #0x943
 1105d0c:	91106c21 	add	x1, x1, #0x41b
 1105d10:	90000260 	adrp	x0, 1151000 <small_prime+0x168>
 1105d14:	911d7c00 	add	x0, x0, #0x75f
 1105d18:	52809e22 	mov	w2, #0x4f1                 	// #1265
 1105d1c:	94003164 	bl	11122ac <_assert_log>
 1105d20:	94003174 	bl	11122f0 <_assert_break>
	if (threads[l->curr_thread].flags & THREAD_FLAGS_FOREIGN_INTR_ENABLE)
 1105d24:	b00002a0 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1105d28:	d280e002 	mov	x2, #0x700                 	// #1792
 1105d2c:	f9417800 	ldr	x0, [x0, #752]
 1105d30:	9b020021 	madd	x1, x1, x2, x0
 1105d34:	b9412820 	ldr	w0, [x1, #296]
 1105d38:	360800a0 	tbz	w0, #1, 1105d4c <thread_restore_foreign_intr+0x74>
		thread_set_exceptions(exceptions & ~THREAD_EXCP_FOREIGN_INTR);
 1105d3c:	121e7a60 	and	w0, w19, #0xfffffffd
}
 1105d40:	f9400bf3 	ldr	x19, [sp, #16]
 1105d44:	a8c27bfd 	ldp	x29, x30, [sp], #32
		thread_set_exceptions(exceptions & ~THREAD_EXCP_FOREIGN_INTR);
 1105d48:	17fffce3 	b	11050d4 <thread_set_exceptions>
}
 1105d4c:	f9400bf3 	ldr	x19, [sp, #16]
 1105d50:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1105d54:	d65f03c0 	ret

0000000001105d58 <thread_kernel_save_vfp>:
{
 1105d58:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1105d5c:	910003fd 	mov	x29, sp
 1105d60:	f9000bf3 	str	x19, [sp, #16]
	struct thread_ctx *thr = threads + thread_get_id();
 1105d64:	97fffdc0 	bl	1105464 <thread_get_id>
 1105d68:	13003c13 	sxth	w19, w0
	assert(thread_get_exceptions() & THREAD_EXCP_FOREIGN_INTR);
 1105d6c:	97fffc6a 	bl	1104f14 <thread_get_exceptions>
 1105d70:	37080140 	tbnz	w0, #1, 1105d98 <thread_kernel_save_vfp+0x40>
 1105d74:	90000263 	adrp	x3, 1151000 <small_prime+0x168>
 1105d78:	90000261 	adrp	x1, 1151000 <small_prime+0x168>
 1105d7c:	91257c63 	add	x3, x3, #0x95f
 1105d80:	91106c21 	add	x1, x1, #0x41b
 1105d84:	90000260 	adrp	x0, 1151000 <small_prime+0x168>
 1105d88:	91144000 	add	x0, x0, #0x510
 1105d8c:	5280a582 	mov	w2, #0x52c                 	// #1324
 1105d90:	94003147 	bl	11122ac <_assert_log>
 1105d94:	94003157 	bl	11122f0 <_assert_break>
	if (vfp_is_enabled()) {
 1105d98:	94000776 	bl	1107b70 <vfp_is_enabled>
 1105d9c:	72001c1f 	tst	w0, #0xff
 1105da0:	54000120 	b.eq	1105dc4 <thread_kernel_save_vfp+0x6c>  // b.none
	struct thread_ctx *thr = threads + thread_get_id();
 1105da4:	b00002a0 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1105da8:	5280e001 	mov	w1, #0x700                 	// #1792
 1105dac:	f9417800 	ldr	x0, [x0, #752]
 1105db0:	9b210273 	smaddl	x19, w19, w1, x0
		vfp_lazy_save_state_init(&thr->vfp_state.sec);
 1105db4:	910dc260 	add	x0, x19, #0x370
 1105db8:	9400077d 	bl	1107bac <vfp_lazy_save_state_init>
		thr->vfp_state.sec_lazy_saved = true;
 1105dbc:	52800020 	mov	w0, #0x1                   	// #1
 1105dc0:	39054a60 	strb	w0, [x19, #338]
}
 1105dc4:	f9400bf3 	ldr	x19, [sp, #16]
 1105dc8:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1105dcc:	d65f03c0 	ret

0000000001105dd0 <thread_kernel_restore_vfp>:
{
 1105dd0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1105dd4:	910003fd 	mov	x29, sp
 1105dd8:	f9000bf3 	str	x19, [sp, #16]
	struct thread_ctx *thr = threads + thread_get_id();
 1105ddc:	b00002b3 	adrp	x19, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1105de0:	97fffda1 	bl	1105464 <thread_get_id>
 1105de4:	13003c00 	sxth	w0, w0
 1105de8:	f9417a73 	ldr	x19, [x19, #752]
 1105dec:	5280e001 	mov	w1, #0x700                 	// #1792
 1105df0:	9b214c13 	smaddl	x19, w0, w1, x19
	assert(thread_get_exceptions() & THREAD_EXCP_FOREIGN_INTR);
 1105df4:	97fffc48 	bl	1104f14 <thread_get_exceptions>
 1105df8:	37080140 	tbnz	w0, #1, 1105e20 <thread_kernel_restore_vfp+0x50>
 1105dfc:	90000263 	adrp	x3, 1151000 <small_prime+0x168>
 1105e00:	90000261 	adrp	x1, 1151000 <small_prime+0x168>
 1105e04:	90000260 	adrp	x0, 1151000 <small_prime+0x168>
 1105e08:	9125d863 	add	x3, x3, #0x976
 1105e0c:	91106c21 	add	x1, x1, #0x41b
 1105e10:	91144000 	add	x0, x0, #0x510
 1105e14:	5280a6e2 	mov	w2, #0x537                 	// #1335
	assert(!vfp_is_enabled());
 1105e18:	94003125 	bl	11122ac <_assert_log>
 1105e1c:	94003135 	bl	11122f0 <_assert_break>
 1105e20:	94000754 	bl	1107b70 <vfp_is_enabled>
 1105e24:	72001c1f 	tst	w0, #0xff
 1105e28:	54000120 	b.eq	1105e4c <thread_kernel_restore_vfp+0x7c>  // b.none
 1105e2c:	90000263 	adrp	x3, 1151000 <small_prime+0x168>
 1105e30:	90000261 	adrp	x1, 1151000 <small_prime+0x168>
 1105e34:	90000260 	adrp	x0, 1151000 <small_prime+0x168>
 1105e38:	9125d863 	add	x3, x3, #0x976
 1105e3c:	91106c21 	add	x1, x1, #0x41b
 1105e40:	911e0c00 	add	x0, x0, #0x783
 1105e44:	5280a702 	mov	w2, #0x538                 	// #1336
 1105e48:	17fffff4 	b	1105e18 <thread_kernel_restore_vfp+0x48>
	if (thr->vfp_state.sec_lazy_saved) {
 1105e4c:	39454a60 	ldrb	w0, [x19, #338]
 1105e50:	340000c0 	cbz	w0, 1105e68 <thread_kernel_restore_vfp+0x98>
		vfp_lazy_restore_state(&thr->vfp_state.sec,
 1105e54:	39454661 	ldrb	w1, [x19, #337]
 1105e58:	910dc260 	add	x0, x19, #0x370
 1105e5c:	94000775 	bl	1107c30 <vfp_lazy_restore_state>
		thr->vfp_state.sec_saved = false;
 1105e60:	3905467f 	strb	wzr, [x19, #337]
		thr->vfp_state.sec_lazy_saved = false;
 1105e64:	39054a7f 	strb	wzr, [x19, #338]
}
 1105e68:	f9400bf3 	ldr	x19, [sp, #16]
 1105e6c:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1105e70:	d65f03c0 	ret

0000000001105e74 <thread_user_enable_vfp>:
{
 1105e74:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1105e78:	910003fd 	mov	x29, sp
 1105e7c:	a90153f3 	stp	x19, x20, [sp, #16]
 1105e80:	f90013f5 	str	x21, [sp, #32]
 1105e84:	aa0003f5 	mov	x21, x0
	struct thread_ctx *thr = threads + thread_get_id();
 1105e88:	97fffd77 	bl	1105464 <thread_get_id>
 1105e8c:	13003c13 	sxth	w19, w0
 1105e90:	b00002a1 	adrp	x1, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1105e94:	5280e000 	mov	w0, #0x700                 	// #1792
 1105e98:	f9417821 	ldr	x1, [x1, #752]
 1105e9c:	9b200673 	smaddl	x19, w19, w0, x1
	struct thread_user_vfp_state *tuv = thr->vfp_state.uvfp;
 1105ea0:	f942c274 	ldr	x20, [x19, #1408]
	assert(thread_get_exceptions() & THREAD_EXCP_FOREIGN_INTR);
 1105ea4:	97fffc1c 	bl	1104f14 <thread_get_exceptions>
 1105ea8:	37080140 	tbnz	w0, #1, 1105ed0 <thread_user_enable_vfp+0x5c>
 1105eac:	90000263 	adrp	x3, 1151000 <small_prime+0x168>
 1105eb0:	90000261 	adrp	x1, 1151000 <small_prime+0x168>
 1105eb4:	90000260 	adrp	x0, 1151000 <small_prime+0x168>
 1105eb8:	91264063 	add	x3, x3, #0x990
 1105ebc:	91106c21 	add	x1, x1, #0x41b
 1105ec0:	91144000 	add	x0, x0, #0x510
 1105ec4:	5280a8c2 	mov	w2, #0x546                 	// #1350
	assert(!vfp_is_enabled());
 1105ec8:	940030f9 	bl	11122ac <_assert_log>
 1105ecc:	94003109 	bl	11122f0 <_assert_break>
 1105ed0:	94000728 	bl	1107b70 <vfp_is_enabled>
 1105ed4:	72001c1f 	tst	w0, #0xff
 1105ed8:	54000120 	b.eq	1105efc <thread_user_enable_vfp+0x88>  // b.none
 1105edc:	90000263 	adrp	x3, 1151000 <small_prime+0x168>
 1105ee0:	90000261 	adrp	x1, 1151000 <small_prime+0x168>
 1105ee4:	90000260 	adrp	x0, 1151000 <small_prime+0x168>
 1105ee8:	91264063 	add	x3, x3, #0x990
 1105eec:	91106c21 	add	x1, x1, #0x41b
 1105ef0:	911e0c00 	add	x0, x0, #0x783
 1105ef4:	5280a8e2 	mov	w2, #0x547                 	// #1351
 1105ef8:	17fffff4 	b	1105ec8 <thread_user_enable_vfp+0x54>
	if (!thr->vfp_state.ns_saved) {
 1105efc:	39454260 	ldrb	w0, [x19, #336]
 1105f00:	35000220 	cbnz	w0, 1105f44 <thread_user_enable_vfp+0xd0>
		vfp_lazy_save_state_final(&thr->vfp_state.ns,
 1105f04:	91058260 	add	x0, x19, #0x160
 1105f08:	52800021 	mov	w1, #0x1                   	// #1
 1105f0c:	9400072b 	bl	1107bb8 <vfp_lazy_save_state_final>
		thr->vfp_state.ns_saved = true;
 1105f10:	52800020 	mov	w0, #0x1                   	// #1
 1105f14:	39054260 	strb	w0, [x19, #336]
	if (uvfp->lazy_saved)
 1105f18:	394842a0 	ldrb	w0, [x21, #528]
 1105f1c:	34000080 	cbz	w0, 1105f2c <thread_user_enable_vfp+0xb8>
		vfp_lazy_restore_state(&uvfp->vfp, uvfp->saved);
 1105f20:	394846a1 	ldrb	w1, [x21, #529]
 1105f24:	aa1503e0 	mov	x0, x21
 1105f28:	94000742 	bl	1107c30 <vfp_lazy_restore_state>
	uvfp->lazy_saved = false;
 1105f2c:	790422bf 	strh	wzr, [x21, #528]
	thr->vfp_state.uvfp = uvfp;
 1105f30:	f902c275 	str	x21, [x19, #1408]
}
 1105f34:	a94153f3 	ldp	x19, x20, [sp, #16]
 1105f38:	f94013f5 	ldr	x21, [sp, #32]
 1105f3c:	a8c37bfd 	ldp	x29, x30, [sp], #48
	vfp_enable();
 1105f40:	14000710 	b	1107b80 <vfp_enable>
	} else if (tuv && uvfp != tuv) {
 1105f44:	f100029f 	cmp	x20, #0x0
 1105f48:	fa551284 	ccmp	x20, x21, #0x4, ne  // ne = any
 1105f4c:	54fffe60 	b.eq	1105f18 <thread_user_enable_vfp+0xa4>  // b.none
		if (tuv->lazy_saved && !tuv->saved) {
 1105f50:	39484280 	ldrb	w0, [x20, #528]
 1105f54:	34fffe20 	cbz	w0, 1105f18 <thread_user_enable_vfp+0xa4>
 1105f58:	39484680 	ldrb	w0, [x20, #529]
 1105f5c:	35fffde0 	cbnz	w0, 1105f18 <thread_user_enable_vfp+0xa4>
			vfp_lazy_save_state_final(&tuv->vfp,
 1105f60:	aa1403e0 	mov	x0, x20
 1105f64:	52800001 	mov	w1, #0x0                   	// #0
 1105f68:	94000714 	bl	1107bb8 <vfp_lazy_save_state_final>
			tuv->saved = true;
 1105f6c:	52800020 	mov	w0, #0x1                   	// #1
 1105f70:	39084680 	strb	w0, [x20, #529]
 1105f74:	17ffffe9 	b	1105f18 <thread_user_enable_vfp+0xa4>

0000000001105f78 <thread_user_save_vfp>:
{
 1105f78:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1105f7c:	910003fd 	mov	x29, sp
 1105f80:	f9000bf3 	str	x19, [sp, #16]
	struct thread_ctx *thr = threads + thread_get_id();
 1105f84:	97fffd38 	bl	1105464 <thread_get_id>
	struct thread_user_vfp_state *tuv = thr->vfp_state.uvfp;
 1105f88:	b00002a1 	adrp	x1, 115a000 <__scattered_array_1phys_mem_map+0x8>
	struct thread_ctx *thr = threads + thread_get_id();
 1105f8c:	13003c00 	sxth	w0, w0
	struct thread_user_vfp_state *tuv = thr->vfp_state.uvfp;
 1105f90:	5280e002 	mov	w2, #0x700                 	// #1792
 1105f94:	f9417821 	ldr	x1, [x1, #752]
 1105f98:	9b220400 	smaddl	x0, w0, w2, x1
 1105f9c:	f942c013 	ldr	x19, [x0, #1408]
	assert(thread_get_exceptions() & THREAD_EXCP_FOREIGN_INTR);
 1105fa0:	97fffbdd 	bl	1104f14 <thread_get_exceptions>
 1105fa4:	37080140 	tbnz	w0, #1, 1105fcc <thread_user_save_vfp+0x54>
 1105fa8:	90000263 	adrp	x3, 1151000 <small_prime+0x168>
 1105fac:	90000261 	adrp	x1, 1151000 <small_prime+0x168>
 1105fb0:	90000260 	adrp	x0, 1151000 <small_prime+0x168>
 1105fb4:	91269c63 	add	x3, x3, #0x9a7
 1105fb8:	91106c21 	add	x1, x1, #0x41b
 1105fbc:	91144000 	add	x0, x0, #0x510
 1105fc0:	5280ac62 	mov	w2, #0x563                 	// #1379
	assert(tuv && !tuv->lazy_saved && !tuv->saved);
 1105fc4:	940030ba 	bl	11122ac <_assert_log>
 1105fc8:	940030ca 	bl	11122f0 <_assert_break>
	if (!vfp_is_enabled())
 1105fcc:	940006e9 	bl	1107b70 <vfp_is_enabled>
 1105fd0:	72001c1f 	tst	w0, #0xff
 1105fd4:	54000200 	b.eq	1106014 <thread_user_save_vfp+0x9c>  // b.none
	assert(tuv && !tuv->lazy_saved && !tuv->saved);
 1105fd8:	b4000073 	cbz	x19, 1105fe4 <thread_user_save_vfp+0x6c>
 1105fdc:	79442260 	ldrh	w0, [x19, #528]
 1105fe0:	34000120 	cbz	w0, 1106004 <thread_user_save_vfp+0x8c>
 1105fe4:	90000263 	adrp	x3, 1151000 <small_prime+0x168>
 1105fe8:	90000261 	adrp	x1, 1151000 <small_prime+0x168>
 1105fec:	90000260 	adrp	x0, 1151000 <small_prime+0x168>
 1105ff0:	91269c63 	add	x3, x3, #0x9a7
 1105ff4:	91106c21 	add	x1, x1, #0x41b
 1105ff8:	911e5400 	add	x0, x0, #0x795
 1105ffc:	5280ace2 	mov	w2, #0x567                 	// #1383
 1106000:	17fffff1 	b	1105fc4 <thread_user_save_vfp+0x4c>
	vfp_lazy_save_state_init(&tuv->vfp);
 1106004:	aa1303e0 	mov	x0, x19
 1106008:	940006e9 	bl	1107bac <vfp_lazy_save_state_init>
	tuv->lazy_saved = true;
 110600c:	52800020 	mov	w0, #0x1                   	// #1
 1106010:	39084260 	strb	w0, [x19, #528]
}
 1106014:	f9400bf3 	ldr	x19, [sp, #16]
 1106018:	a8c27bfd 	ldp	x29, x30, [sp], #32
 110601c:	d65f03c0 	ret

0000000001106020 <thread_state_suspend>:
{
 1106020:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 1106024:	910003fd 	mov	x29, sp
 1106028:	a90153f3 	stp	x19, x20, [sp, #16]
 110602c:	2a0103f4 	mov	w20, w1
 1106030:	a9025bf5 	stp	x21, x22, [sp, #32]
 1106034:	a90363f7 	stp	x23, x24, [sp, #48]
 1106038:	a9046bf9 	stp	x25, x26, [sp, #64]
 110603c:	2a0003fa 	mov	w26, w0
 1106040:	aa0203f9 	mov	x25, x2
	struct thread_core_local *l = thread_get_core_local();
 1106044:	97fffc4c 	bl	1105174 <thread_get_core_local>
	int ct = l->curr_thread;
 1106048:	79c05015 	ldrsh	w21, [x0, #40]
	assert(ct != THREAD_ID_INVALID);
 110604c:	310006bf 	cmn	w21, #0x1
 1106050:	54000141 	b.ne	1106078 <thread_state_suspend+0x58>  // b.any
 1106054:	f0000243 	adrp	x3, 1151000 <small_prime+0x168>
 1106058:	f0000241 	adrp	x1, 1151000 <small_prime+0x168>
 110605c:	f0000240 	adrp	x0, 1151000 <small_prime+0x168>
 1106060:	91239863 	add	x3, x3, #0x8e6
 1106064:	91106c21 	add	x1, x1, #0x41b
 1106068:	91177000 	add	x0, x0, #0x5dc
 110606c:	52806f62 	mov	w2, #0x37b                 	// #891
	assert(threads[ct].state == THREAD_STATE_ACTIVE);
 1106070:	9400308f 	bl	11122ac <_assert_log>
 1106074:	9400309f 	bl	11122f0 <_assert_break>
 1106078:	aa0003f6 	mov	x22, x0
	if (core_mmu_user_mapping_is_active())
 110607c:	9400145b 	bl	110b1e8 <core_mmu_user_mapping_is_active>
	thread_check_canaries();
 1106080:	97fffaec 	bl	1104c30 <thread_check_canaries>
	if (cpsr & (SPSR_MODE_RW_32 << SPSR_MODE_RW_SHIFT))
 1106084:	37200074 	tbnz	w20, #4, 1106090 <thread_state_suspend+0x70>
	if (((cpsr >> SPSR_64_MODE_EL_SHIFT) & SPSR_64_MODE_EL_MASK) ==
 1106088:	f27e069f 	tst	x20, #0xc
 110608c:	54000041 	b.ne	1106094 <thread_state_suspend+0x74>  // b.any
		thread_user_save_vfp();
 1106090:	97ffffba 	bl	1105f78 <thread_user_save_vfp>
	assert(threads[ct].state == THREAD_STATE_ACTIVE);
 1106094:	900002b8 	adrp	x24, 115a000 <__scattered_array_1phys_mem_map+0x8>
	thread_lazy_restore_ns_vfp();
 1106098:	97fffdae 	bl	1105750 <thread_lazy_restore_ns_vfp>
	thread_lock_global();
 110609c:	97fffba1 	bl	1104f20 <thread_lock_global>
	assert(threads[ct].state == THREAD_STATE_ACTIVE);
 11060a0:	93407eb3 	sxtw	x19, w21
 11060a4:	f9417b18 	ldr	x24, [x24, #752]
 11060a8:	d280e017 	mov	x23, #0x700                 	// #1792
 11060ac:	9b176273 	madd	x19, x19, x23, x24
 11060b0:	b9411a60 	ldr	w0, [x19, #280]
 11060b4:	7100081f 	cmp	w0, #0x2
 11060b8:	54000120 	b.eq	11060dc <thread_state_suspend+0xbc>  // b.none
 11060bc:	f0000243 	adrp	x3, 1151000 <small_prime+0x168>
 11060c0:	f0000241 	adrp	x1, 1151000 <small_prime+0x168>
 11060c4:	f0000240 	adrp	x0, 1151000 <small_prime+0x168>
 11060c8:	91239863 	add	x3, x3, #0x8e6
 11060cc:	91106c21 	add	x1, x1, #0x41b
 11060d0:	9119d000 	add	x0, x0, #0x674
 11060d4:	528071a2 	mov	w2, #0x38d                 	// #909
 11060d8:	17ffffe6 	b	1106070 <thread_state_suspend+0x50>
	threads[ct].flags |= flags;
 11060dc:	b9412a60 	ldr	w0, [x19, #296]
	threads[ct].regs.cpsr = cpsr;
 11060e0:	a900d279 	stp	x25, x20, [x19, #8]
	threads[ct].flags |= flags;
 11060e4:	2a1a001a 	orr	w26, w0, w26
	threads[ct].state = THREAD_STATE_SUSPENDED;
 11060e8:	52800020 	mov	w0, #0x1                   	// #1
 11060ec:	b9011a60 	str	w0, [x19, #280]
	threads[ct].flags |= flags;
 11060f0:	b9012a7a 	str	w26, [x19, #296]
	threads[ct].have_user_map = core_mmu_user_mapping_is_active();
 11060f4:	9400143d 	bl	110b1e8 <core_mmu_user_mapping_is_active>
 11060f8:	39050260 	strb	w0, [x19, #320]
	if (threads[ct].have_user_map) {
 11060fc:	72001c1f 	tst	w0, #0xff
 1106100:	540000e0 	b.eq	110611c <thread_state_suspend+0xfc>  // b.none
		core_mmu_get_user_map(&threads[ct].user_map);
 1106104:	d2802600 	mov	x0, #0x130                 	// #304
 1106108:	9b3502e0 	smaddl	x0, w23, w21, x0
 110610c:	8b000300 	add	x0, x24, x0
 1106110:	94001459 	bl	110b274 <core_mmu_get_user_map>
		core_mmu_set_user_map(NULL);
 1106114:	d2800000 	mov	x0, #0x0                   	// #0
 1106118:	9400147a 	bl	110b300 <core_mmu_set_user_map>
	l->curr_thread = THREAD_ID_INVALID;
 110611c:	12800000 	mov	w0, #0xffffffff            	// #-1
 1106120:	790052c0 	strh	w0, [x22, #40]
	thread_unlock_global();
 1106124:	97fffbda 	bl	110508c <thread_unlock_global>
}
 1106128:	2a1503e0 	mov	w0, w21
 110612c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1106130:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1106134:	a94363f7 	ldp	x23, x24, [sp, #48]
 1106138:	a9446bf9 	ldp	x25, x26, [sp, #64]
 110613c:	a8c57bfd 	ldp	x29, x30, [sp], #80
 1106140:	d65f03c0 	ret

0000000001106144 <thread_user_clear_vfp>:
{
 1106144:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1106148:	910003fd 	mov	x29, sp
 110614c:	f9000bf3 	str	x19, [sp, #16]
 1106150:	aa0003f3 	mov	x19, x0
	struct thread_ctx *thr = threads + thread_get_id();
 1106154:	97fffcc4 	bl	1105464 <thread_get_id>
 1106158:	13003c01 	sxth	w1, w0
 110615c:	900002a0 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1106160:	5280e002 	mov	w2, #0x700                 	// #1792
 1106164:	f9417800 	ldr	x0, [x0, #752]
 1106168:	9b220021 	smaddl	x1, w1, w2, x0
	struct thread_user_vfp_state *uvfp = &uctx->vfp;
 110616c:	91008260 	add	x0, x19, #0x20
	if (uvfp == thr->vfp_state.uvfp)
 1106170:	f942c022 	ldr	x2, [x1, #1408]
 1106174:	eb00005f 	cmp	x2, x0
 1106178:	54000041 	b.ne	1106180 <thread_user_clear_vfp+0x3c>  // b.any
		thr->vfp_state.uvfp = NULL;
 110617c:	f902c03f 	str	xzr, [x1, #1408]
	uvfp->lazy_saved = false;
 1106180:	7904627f 	strh	wzr, [x19, #560]
}
 1106184:	f9400bf3 	ldr	x19, [sp, #16]
 1106188:	a8c27bfd 	ldp	x29, x30, [sp], #32
 110618c:	d65f03c0 	ret

0000000001106190 <thread_enter_user_mode>:
{
 1106190:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
	if (is_32bit) {
 1106194:	72001cdf 	tst	w6, #0xff
{
 1106198:	910003fd 	mov	x29, sp
 110619c:	a90153f3 	stp	x19, x20, [sp, #16]
 11061a0:	a9025bf5 	stp	x21, x22, [sp, #32]
 11061a4:	aa0403f5 	mov	x21, x4
 11061a8:	aa0503f6 	mov	x22, x5
 11061ac:	a90363f7 	stp	x23, x24, [sp, #48]
 11061b0:	aa0703f8 	mov	x24, x7
 11061b4:	a9046bf9 	stp	x25, x26, [sp, #64]
 11061b8:	aa0203fa 	mov	x26, x2
 11061bc:	aa0303f9 	mov	x25, x3
 11061c0:	a90573fb 	stp	x27, x28, [sp, #80]
 11061c4:	aa0003fc 	mov	x28, x0
 11061c8:	aa0103fb 	mov	x27, x1
	if (is_32bit) {
 11061cc:	54000440 	b.eq	1106254 <thread_enter_user_mode+0xc4>  // b.none
DEFINE_U32_REG_READWRITE_FUNCS(daif)
 11061d0:	d53b4220 	mrs	x0, daif
		s |= (entry_func & SPSR_32_T_MASK) << SPSR_32_T_SHIFT;
 11061d4:	531b00b3 	ubfiz	w19, w5, #5, #1
		s = read_daif() & (SPSR_32_AIF_MASK << SPSR_32_AIF_SHIFT);
 11061d8:	121a0800 	and	w0, w0, #0x1c0
 11061dc:	2a000273 	orr	w19, w19, w0
		s |= (entry_func & SPSR_32_T_MASK) << SPSR_32_T_SHIFT;
 11061e0:	321c0273 	orr	w19, w19, #0x10
	exceptions = thread_mask_exceptions(THREAD_EXCP_ALL);
 11061e4:	528000e0 	mov	w0, #0x7                   	// #7
 11061e8:	97fffbd4 	bl	1105138 <thread_mask_exceptions>
 11061ec:	2a0003f7 	mov	w23, w0
	regs = thread_get_ctx_regs();
 11061f0:	97fffe80 	bl	1105bf0 <thread_get_ctx_regs>
	*regs = (struct thread_ctx_regs){ };
 11061f4:	d2802302 	mov	x2, #0x118                 	// #280
	regs = thread_get_ctx_regs();
 11061f8:	aa0003f4 	mov	x20, x0
	*regs = (struct thread_ctx_regs){ };
 11061fc:	52800001 	mov	w1, #0x0                   	// #0
 1106200:	9400f6b8 	bl	1143ce0 <memset>
	rc = __thread_enter_user_mode(regs, exit_status0, exit_status1);
 1106204:	f94033e2 	ldr	x2, [sp, #96]
 1106208:	aa1803e1 	mov	x1, x24
	regs->pc = entry_func;
 110620c:	a9005a95 	stp	x21, x22, [x20]
	rc = __thread_enter_user_mode(regs, exit_status0, exit_status1);
 1106210:	aa1403e0 	mov	x0, x20
	regs->x[0] = a0;
 1106214:	a9017293 	stp	x19, x28, [x20, #16]
	regs->x[2] = a2;
 1106218:	a9026a9b 	stp	x27, x26, [x20, #32]
	regs->x[3] = a3;
 110621c:	f9001a99 	str	x25, [x20, #48]
	regs->x[13] = user_sp;	/* Used when running TA in Aarch32 */
 1106220:	f9004295 	str	x21, [x20, #128]
	rc = __thread_enter_user_mode(regs, exit_status0, exit_status1);
 1106224:	97fff3ab 	bl	11030d0 <__thread_enter_user_mode>
 1106228:	2a0003f3 	mov	w19, w0
	thread_unmask_exceptions(exceptions);
 110622c:	2a1703e0 	mov	w0, w23
 1106230:	97fffbcf 	bl	110516c <thread_unmask_exceptions>
}
 1106234:	2a1303e0 	mov	w0, w19
 1106238:	a94153f3 	ldp	x19, x20, [sp, #16]
 110623c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1106240:	a94363f7 	ldp	x23, x24, [sp, #48]
 1106244:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1106248:	a94573fb 	ldp	x27, x28, [sp, #80]
 110624c:	a8c67bfd 	ldp	x29, x30, [sp], #96
 1106250:	d65f03c0 	ret
 1106254:	d53b4233 	mrs	x19, daif
		s = read_daif() & (SPSR_64_DAIF_MASK << SPSR_64_DAIF_SHIFT);
 1106258:	121a0e73 	and	w19, w19, #0x3c0
 110625c:	17ffffe2 	b	11061e4 <thread_enter_user_mode+0x54>

0000000001106260 <thread_get_user_kcode>:
{
 1106260:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1106264:	910003fd 	mov	x29, sp
 1106268:	a90153f3 	stp	x19, x20, [sp, #16]
 110626c:	aa0303f3 	mov	x19, x3
 1106270:	aa0103f4 	mov	x20, x1
	core_mmu_get_user_va_range(va, NULL);
 1106274:	d2800001 	mov	x1, #0x0                   	// #0
{
 1106278:	f90013f5 	str	x21, [sp, #32]
 110627c:	aa0003f5 	mov	x21, x0
 1106280:	aa0203e0 	mov	x0, x2
	core_mmu_get_user_va_range(va, NULL);
 1106284:	94001393 	bl	110b0d0 <core_mmu_get_user_va_range>
	*mobj = mobj_tee_ram;
 1106288:	900002a2 	adrp	x2, 115a000 <__scattered_array_1phys_mem_map+0x8>
 110628c:	f9420840 	ldr	x0, [x2, #1040]
	*offset = thread_user_kcode_va - VCORE_START_VA;
 1106290:	f9414042 	ldr	x2, [x2, #640]
	*mobj = mobj_tee_ram;
 1106294:	f9400000 	ldr	x0, [x0]
 1106298:	f90002a0 	str	x0, [x21]
	*offset = thread_user_kcode_va - VCORE_START_VA;
 110629c:	f00002a0 	adrp	x0, 115d000 <_curve_names+0x590>
}
 11062a0:	f94013f5 	ldr	x21, [sp, #32]
	*offset = thread_user_kcode_va - VCORE_START_VA;
 11062a4:	f9460400 	ldr	x0, [x0, #3080]
 11062a8:	cb020002 	sub	x2, x0, x2
	*sz = thread_user_kcode_size;
 11062ac:	f00002a0 	adrp	x0, 115d000 <_curve_names+0x590>
	*offset = thread_user_kcode_va - VCORE_START_VA;
 11062b0:	f9000282 	str	x2, [x20]
	*sz = thread_user_kcode_size;
 11062b4:	f9460000 	ldr	x0, [x0, #3072]
 11062b8:	f9000260 	str	x0, [x19]
}
 11062bc:	a94153f3 	ldp	x19, x20, [sp, #16]
 11062c0:	a8c37bfd 	ldp	x29, x30, [sp], #48
 11062c4:	d65f03c0 	ret

00000000011062c8 <thread_get_user_kdata>:
{
 11062c8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 11062cc:	910003fd 	mov	x29, sp
 11062d0:	a90153f3 	stp	x19, x20, [sp, #16]
 11062d4:	aa0303f3 	mov	x19, x3
 11062d8:	aa0103f4 	mov	x20, x1
	core_mmu_get_user_va_range(&v, NULL);
 11062dc:	d2800001 	mov	x1, #0x0                   	// #0
{
 11062e0:	a9025bf5 	stp	x21, x22, [sp, #32]
 11062e4:	aa0203f6 	mov	x22, x2
 11062e8:	aa0003f5 	mov	x21, x0
	core_mmu_get_user_va_range(&v, NULL);
 11062ec:	9100e3e0 	add	x0, sp, #0x38
 11062f0:	94001378 	bl	110b0d0 <core_mmu_get_user_va_range>
	*va = v + thread_user_kcode_size;
 11062f4:	f00002a0 	adrp	x0, 115d000 <_curve_names+0x590>
	*mobj = mobj_tee_ram;
 11062f8:	900002a2 	adrp	x2, 115a000 <__scattered_array_1phys_mem_map+0x8>
	*va = v + thread_user_kcode_size;
 11062fc:	f9460001 	ldr	x1, [x0, #3072]
 1106300:	f9401fe0 	ldr	x0, [sp, #56]
 1106304:	8b010000 	add	x0, x0, x1
 1106308:	f90002c0 	str	x0, [x22]
	*mobj = mobj_tee_ram;
 110630c:	f9420840 	ldr	x0, [x2, #1040]
	*offset = (vaddr_t)thread_user_kdata_page - VCORE_START_VA;
 1106310:	f9414042 	ldr	x2, [x2, #640]
	*mobj = mobj_tee_ram;
 1106314:	f9400000 	ldr	x0, [x0]
 1106318:	f90002a0 	str	x0, [x21]
	*offset = (vaddr_t)thread_user_kdata_page - VCORE_START_VA;
 110631c:	900003a0 	adrp	x0, 117a000 <__heap1_end>
 1106320:	91000000 	add	x0, x0, #0x0
 1106324:	cb020000 	sub	x0, x0, x2
}
 1106328:	a9425bf5 	ldp	x21, x22, [sp, #32]
	*offset = (vaddr_t)thread_user_kdata_page - VCORE_START_VA;
 110632c:	f9000280 	str	x0, [x20]
	*sz = sizeof(thread_user_kdata_page);
 1106330:	d2820000 	mov	x0, #0x1000                	// #4096
 1106334:	f9000260 	str	x0, [x19]
}
 1106338:	a94153f3 	ldp	x19, x20, [sp, #16]
 110633c:	a8c47bfd 	ldp	x29, x30, [sp], #64
 1106340:	d65f03c0 	ret

0000000001106344 <thread_svc_handler>:
{
 1106344:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1106348:	910003fd 	mov	x29, sp
 110634c:	a90153f3 	stp	x19, x20, [sp, #16]
 1106350:	aa0003f3 	mov	x19, x0
	state = thread_get_exceptions();
 1106354:	97fffaf0 	bl	1104f14 <thread_get_exceptions>
	thread_unmask_exceptions(state & ~THREAD_EXCP_NATIVE_INTR);
 1106358:	121f7800 	and	w0, w0, #0xfffffffe
 110635c:	97fffb84 	bl	110516c <thread_unmask_exceptions>
	thread_user_save_vfp();
 1106360:	97ffff06 	bl	1105f78 <thread_user_save_vfp>
	sess = ts_get_current_session();
 1106364:	9400399f 	bl	11149e0 <ts_get_current_session>
 1106368:	aa0003f4 	mov	x20, x0
	thread_restore_foreign_intr();
 110636c:	97fffe5b 	bl	1105cd8 <thread_restore_foreign_intr>
	assert(sess && sess->handle_svc);
 1106370:	b4000074 	cbz	x20, 110637c <thread_svc_handler+0x38>
 1106374:	f9401281 	ldr	x1, [x20, #32]
 1106378:	b5000141 	cbnz	x1, 11063a0 <thread_svc_handler+0x5c>
 110637c:	f0000243 	adrp	x3, 1151000 <small_prime+0x168>
 1106380:	f0000241 	adrp	x1, 1151000 <small_prime+0x168>
 1106384:	9126f063 	add	x3, x3, #0x9bc
 1106388:	91106c21 	add	x1, x1, #0x41b
 110638c:	f0000240 	adrp	x0, 1151000 <small_prime+0x168>
 1106390:	911ef000 	add	x0, x0, #0x7bc
 1106394:	5280c602 	mov	w2, #0x630                 	// #1584
 1106398:	94002fc5 	bl	11122ac <_assert_log>
 110639c:	94002fd5 	bl	11122f0 <_assert_break>
	if (sess->handle_svc(regs)) {
 11063a0:	aa1303e0 	mov	x0, x19
 11063a4:	d63f0020 	blr	x1
 11063a8:	72001c1f 	tst	w0, #0xff
 11063ac:	54000141 	b.ne	11063d4 <thread_svc_handler+0x90>  // b.any
	regs->elr = (uintptr_t)thread_unwind_user_mode;
 11063b0:	900002a0 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 11063b4:	f941f800 	ldr	x0, [x0, #1008]
 11063b8:	f9000260 	str	x0, [x19]
 11063bc:	d53b4220 	mrs	x0, daif
	regs->spsr |= read_daif();
 11063c0:	92407c00 	and	x0, x0, #0xffffffff
 11063c4:	b27e0000 	orr	x0, x0, #0x4
 11063c8:	f9000660 	str	x0, [x19, #8]
	regs->sp_el0 = (uint64_t)(regs + 1);
 11063cc:	91028260 	add	x0, x19, #0xa0
 11063d0:	f9004a60 	str	x0, [x19, #144]
}
 11063d4:	a94153f3 	ldp	x19, x20, [sp, #16]
 11063d8:	a8c27bfd 	ldp	x29, x30, [sp], #32
 11063dc:	d65f03c0 	ret

00000000011063e0 <thread_rpc_shm_cache_alloc>:
{
 11063e0:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
 11063e4:	910003fd 	mov	x29, sp
 11063e8:	a90153f3 	stp	x19, x20, [sp, #16]
 11063ec:	a9025bf5 	stp	x21, x22, [sp, #32]
 11063f0:	a90363f7 	stp	x23, x24, [sp, #48]
 11063f4:	f90023f9 	str	x25, [sp, #64]
	paddr_t p = 0;
 11063f8:	f9002fff 	str	xzr, [sp, #88]
	if (!size)
 11063fc:	b5000062 	cbnz	x2, 1106408 <thread_rpc_shm_cache_alloc+0x28>
	return NULL;
 1106400:	d2800000 	mov	x0, #0x0                   	// #0
 1106404:	14000047 	b	1106520 <thread_rpc_shm_cache_alloc+0x140>
 1106408:	2a0103f6 	mov	w22, w1
 110640c:	2a0003f8 	mov	w24, w0
 1106410:	aa0203f4 	mov	x20, x2
 1106414:	aa0303f5 	mov	x21, x3
	struct thread_shm_cache *cache = &threads[thread_get_id()].shm_cache;
 1106418:	97fffc13 	bl	1105464 <thread_get_id>
	SLIST_FOREACH(ce, cache, link)
 110641c:	93403c17 	sxth	x23, w0
 1106420:	900002a1 	adrp	x1, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1106424:	d280e000 	mov	x0, #0x700                 	// #1792
 1106428:	f9417821 	ldr	x1, [x1, #752]
 110642c:	9b0006e1 	madd	x1, x23, x0, x1
 1106430:	f942d039 	ldr	x25, [x1, #1440]
 1106434:	aa1903f3 	mov	x19, x25
 1106438:	b50003d3 	cbnz	x19, 11064b0 <thread_rpc_shm_cache_alloc+0xd0>
	ce = calloc(1, sizeof(*ce));
 110643c:	d2800401 	mov	x1, #0x20                  	// #32
 1106440:	d2800020 	mov	x0, #0x1                   	// #1
 1106444:	9400f423 	bl	11434d0 <calloc>
 1106448:	aa0003f3 	mov	x19, x0
	if (ce) {
 110644c:	b4fffda0 	cbz	x0, 1106400 <thread_rpc_shm_cache_alloc+0x20>
		SLIST_INSERT_HEAD(cache, ce, link);
 1106450:	900002a1 	adrp	x1, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1106454:	d280e000 	mov	x0, #0x700                 	// #1792
		ce->user = user;
 1106458:	b9001678 	str	w24, [x19, #20]
		SLIST_INSERT_HEAD(cache, ce, link);
 110645c:	f9417821 	ldr	x1, [x1, #752]
 1106460:	f9000e79 	str	x25, [x19, #24]
 1106464:	9b0006e1 	madd	x1, x23, x0, x1
 1106468:	f902d033 	str	x19, [x1, #1440]
	if (ce->type != shm_type || sz > ce->size) {
 110646c:	b9401260 	ldr	w0, [x19, #16]
	sz = ROUNDUP(size, SMALL_PAGE_SIZE);
 1106470:	913ffe94 	add	x20, x20, #0xfff
 1106474:	9274ce94 	and	x20, x20, #0xfffffffffffff000
	if (ce->type != shm_type || sz > ce->size) {
 1106478:	6b16001f 	cmp	w0, w22
 110647c:	54000081 	b.ne	110648c <thread_rpc_shm_cache_alloc+0xac>  // b.any
 1106480:	f9400660 	ldr	x0, [x19, #8]
 1106484:	eb14001f 	cmp	x0, x20
 1106488:	54000642 	b.cs	1106550 <thread_rpc_shm_cache_alloc+0x170>  // b.hs, b.nlast
		clear_shm_cache_entry(ce);
 110648c:	aa1303e0 	mov	x0, x19
 1106490:	97fff9b8 	bl	1104b70 <clear_shm_cache_entry>
	switch (shm_type) {
 1106494:	710006df 	cmp	w22, #0x1
 1106498:	54000500 	b.eq	1106538 <thread_rpc_shm_cache_alloc+0x158>  // b.none
 110649c:	71000adf 	cmp	w22, #0x2
 11064a0:	54000520 	b.eq	1106544 <thread_rpc_shm_cache_alloc+0x164>  // b.none
 11064a4:	34000116 	cbz	w22, 11064c4 <thread_rpc_shm_cache_alloc+0xe4>
		ce->mobj = alloc_shm(shm_type, sz);
 11064a8:	f900027f 	str	xzr, [x19]
		if (!ce->mobj)
 11064ac:	17ffffd5 	b	1106400 <thread_rpc_shm_cache_alloc+0x20>
		if (ce->user == user)
 11064b0:	b9401660 	ldr	w0, [x19, #20]
 11064b4:	6b00031f 	cmp	w24, w0
 11064b8:	54fffda0 	b.eq	110646c <thread_rpc_shm_cache_alloc+0x8c>  // b.none
	SLIST_FOREACH(ce, cache, link)
 11064bc:	f9400e73 	ldr	x19, [x19, #24]
 11064c0:	17ffffde 	b	1106438 <thread_rpc_shm_cache_alloc+0x58>
		return thread_rpc_alloc_payload(size);
 11064c4:	aa1403e0 	mov	x0, x20
 11064c8:	940002e1 	bl	110704c <thread_rpc_alloc_payload>
		ce->mobj = alloc_shm(shm_type, sz);
 11064cc:	f9000260 	str	x0, [x19]
		if (!ce->mobj)
 11064d0:	b4fff980 	cbz	x0, 1106400 <thread_rpc_shm_cache_alloc+0x20>
	if (mobj && mobj->ops && mobj->ops->get_pa)
 11064d4:	f9400001 	ldr	x1, [x0]
 11064d8:	b4000421 	cbz	x1, 110655c <thread_rpc_shm_cache_alloc+0x17c>
 11064dc:	f9400424 	ldr	x4, [x1, #8]
 11064e0:	b40003e4 	cbz	x4, 110655c <thread_rpc_shm_cache_alloc+0x17c>
		return mobj->ops->get_pa(mobj, offs, granule, pa);
 11064e4:	910163e3 	add	x3, sp, #0x58
 11064e8:	d2800002 	mov	x2, #0x0                   	// #0
 11064ec:	d2800001 	mov	x1, #0x0                   	// #0
 11064f0:	d63f0080 	blr	x4
		if (mobj_get_pa(ce->mobj, 0, 0, &p))
 11064f4:	35000340 	cbnz	w0, 110655c <thread_rpc_shm_cache_alloc+0x17c>
		if (!ALIGNMENT_IS_OK(p, uint64_t))
 11064f8:	f9402fe0 	ldr	x0, [sp, #88]
 11064fc:	f240081f 	tst	x0, #0x7
 1106500:	540002e1 	b.ne	110655c <thread_rpc_shm_cache_alloc+0x17c>  // b.any
		va = mobj_get_va(ce->mobj, 0);
 1106504:	f9400260 	ldr	x0, [x19]
 1106508:	97fff9b8 	bl	1104be8 <mobj_get_va.constprop.0>
		if (!va)
 110650c:	b4000280 	cbz	x0, 110655c <thread_rpc_shm_cache_alloc+0x17c>
		ce->size = sz;
 1106510:	f9000674 	str	x20, [x19, #8]
		ce->type = shm_type;
 1106514:	b9001276 	str	w22, [x19, #16]
	*mobj = ce->mobj;
 1106518:	f9400261 	ldr	x1, [x19]
 110651c:	f90002a1 	str	x1, [x21]
}
 1106520:	a94153f3 	ldp	x19, x20, [sp, #16]
 1106524:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1106528:	a94363f7 	ldp	x23, x24, [sp, #48]
 110652c:	f94023f9 	ldr	x25, [sp, #64]
 1106530:	a8c67bfd 	ldp	x29, x30, [sp], #96
 1106534:	d65f03c0 	ret
		return thread_rpc_alloc_kernel_payload(size);
 1106538:	aa1403e0 	mov	x0, x20
 110653c:	940002c6 	bl	1107054 <thread_rpc_alloc_kernel_payload>
 1106540:	17ffffe3 	b	11064cc <thread_rpc_shm_cache_alloc+0xec>
		return thread_rpc_alloc_global_payload(size);
 1106544:	aa1403e0 	mov	x0, x20
 1106548:	940002df 	bl	11070c4 <thread_rpc_alloc_global_payload>
 110654c:	17ffffe0 	b	11064cc <thread_rpc_shm_cache_alloc+0xec>
		va = mobj_get_va(ce->mobj, 0);
 1106550:	f9400260 	ldr	x0, [x19]
 1106554:	97fff9a5 	bl	1104be8 <mobj_get_va.constprop.0>
		if (!va)
 1106558:	b5fffe00 	cbnz	x0, 1106518 <thread_rpc_shm_cache_alloc+0x138>
	clear_shm_cache_entry(ce);
 110655c:	aa1303e0 	mov	x0, x19
 1106560:	97fff984 	bl	1104b70 <clear_shm_cache_entry>
 1106564:	17ffffa7 	b	1106400 <thread_rpc_shm_cache_alloc+0x20>

0000000001106568 <thread_rpc_shm_cache_clear>:
{
 1106568:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 110656c:	910003fd 	mov	x29, sp
 1106570:	a90153f3 	stp	x19, x20, [sp, #16]
 1106574:	aa0003f4 	mov	x20, x0
		struct thread_shm_cache_entry *ce = SLIST_FIRST(cache);
 1106578:	f9400293 	ldr	x19, [x20]
		if (!ce)
 110657c:	b4000113 	cbz	x19, 110659c <thread_rpc_shm_cache_clear+0x34>
		SLIST_REMOVE_HEAD(cache, link);
 1106580:	f9400e60 	ldr	x0, [x19, #24]
 1106584:	f9000280 	str	x0, [x20]
		clear_shm_cache_entry(ce);
 1106588:	aa1303e0 	mov	x0, x19
 110658c:	97fff979 	bl	1104b70 <clear_shm_cache_entry>
		free(ce);
 1106590:	aa1303e0 	mov	x0, x19
 1106594:	9400f413 	bl	11435e0 <free>
	while (true) {
 1106598:	17fffff8 	b	1106578 <thread_rpc_shm_cache_clear+0x10>
}
 110659c:	a94153f3 	ldp	x19, x20, [sp, #16]
 11065a0:	a8c27bfd 	ldp	x29, x30, [sp], #32
 11065a4:	d65f03c0 	ret

00000000011065a8 <mobj_matches>:
	if (mobj && mobj->ops && mobj->ops->matches)
 11065a8:	b40000e0 	cbz	x0, 11065c4 <mobj_matches+0x1c>
 11065ac:	f9400002 	ldr	x2, [x0]
 11065b0:	b40000a2 	cbz	x2, 11065c4 <mobj_matches+0x1c>
 11065b4:	f9401042 	ldr	x2, [x2, #32]
 11065b8:	b4000062 	cbz	x2, 11065c4 <mobj_matches+0x1c>
		return mobj->ops->matches(mobj, attr);
 11065bc:	aa0203f0 	mov	x16, x2
 11065c0:	d61f0200 	br	x16
	return false;
 11065c4:	52800000 	mov	w0, #0x0                   	// #0
}
 11065c8:	d65f03c0 	ret

00000000011065cc <mobj_get_cookie>:
	mobj_put(mobj);
}

static inline uint64_t mobj_get_cookie(struct mobj *mobj)
{
	if (mobj && mobj->ops && mobj->ops->get_cookie)
 11065cc:	b40000e0 	cbz	x0, 11065e8 <mobj_get_cookie+0x1c>
 11065d0:	f9400001 	ldr	x1, [x0]
 11065d4:	b40000a1 	cbz	x1, 11065e8 <mobj_get_cookie+0x1c>
 11065d8:	f9401821 	ldr	x1, [x1, #48]
 11065dc:	b4000061 	cbz	x1, 11065e8 <mobj_get_cookie+0x1c>
		return mobj->ops->get_cookie(mobj);
 11065e0:	aa0103f0 	mov	x16, x1
 11065e4:	d61f0200 	br	x16

	return 0;
}
 11065e8:	d2800000 	mov	x0, #0x0                   	// #0
 11065ec:	d65f03c0 	ret

00000000011065f0 <rpc_shm_mobj_alloc>:
	thread_unmask_exceptions(exceptions);
	return rv;
}

static struct mobj *rpc_shm_mobj_alloc(paddr_t pa, size_t sz, uint64_t cookie)
{
 11065f0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 11065f4:	910003fd 	mov	x29, sp
 11065f8:	a90153f3 	stp	x19, x20, [sp, #16]
 11065fc:	aa0103f3 	mov	x19, x1
 1106600:	aa0203f4 	mov	x20, x2
	/* Check if this region is in static shared space */
	if (core_pbuf_is(CORE_MEM_NSEC_SHM, pa, sz))
 1106604:	aa0103e2 	mov	x2, x1
 1106608:	aa0003e1 	mov	x1, x0
{
 110660c:	f90017e0 	str	x0, [sp, #40]
	if (core_pbuf_is(CORE_MEM_NSEC_SHM, pa, sz))
 1106610:	52800020 	mov	w0, #0x1                   	// #1
 1106614:	94000bf9 	bl	11095f8 <core_pbuf_is>
 1106618:	72001c1f 	tst	w0, #0xff
 110661c:	54000100 	b.eq	110663c <rpc_shm_mobj_alloc+0x4c>  // b.none
		return mobj_shm_alloc(pa, sz, cookie);
 1106620:	f94017e0 	ldr	x0, [sp, #40]
 1106624:	aa1403e2 	mov	x2, x20
 1106628:	aa1303e1 	mov	x1, x19
 110662c:	9400476e 	bl	11183e4 <mobj_shm_alloc>
	if (IS_ENABLED(CFG_CORE_DYN_SHM) &&
	    !(pa & SMALL_PAGE_MASK) && sz <= SMALL_PAGE_SIZE)
		return mobj_mapped_shm_alloc(&pa, 1, 0, cookie);

	return NULL;
}
 1106630:	a94153f3 	ldp	x19, x20, [sp, #16]
 1106634:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1106638:	d65f03c0 	ret
	if (IS_ENABLED(CFG_CORE_DYN_SHM) &&
 110663c:	f94017e0 	ldr	x0, [sp, #40]
 1106640:	f2402c1f 	tst	x0, #0xfff
 1106644:	54000121 	b.ne	1106668 <rpc_shm_mobj_alloc+0x78>  // b.any
	    !(pa & SMALL_PAGE_MASK) && sz <= SMALL_PAGE_SIZE)
 1106648:	f140067f 	cmp	x19, #0x1, lsl #12
 110664c:	540000e8 	b.hi	1106668 <rpc_shm_mobj_alloc+0x78>  // b.pmore
		return mobj_mapped_shm_alloc(&pa, 1, 0, cookie);
 1106650:	aa1403e3 	mov	x3, x20
 1106654:	9100a3e0 	add	x0, sp, #0x28
 1106658:	d2800002 	mov	x2, #0x0                   	// #0
 110665c:	d2800021 	mov	x1, #0x1                   	// #1
 1106660:	9400188c 	bl	110c890 <mobj_mapped_shm_alloc>
 1106664:	17fffff3 	b	1106630 <rpc_shm_mobj_alloc+0x40>
	return NULL;
 1106668:	d2800000 	mov	x0, #0x0                   	// #0
 110666c:	17fffff1 	b	1106630 <rpc_shm_mobj_alloc+0x40>

0000000001106670 <mobj_put>:
	if (mobj && refcount_dec(&mobj->refc))
 1106670:	b4000260 	cbz	x0, 11066bc <mobj_put+0x4c>
{
 1106674:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1106678:	910003fd 	mov	x29, sp
 110667c:	f9000bf3 	str	x19, [sp, #16]
 1106680:	aa0003f3 	mov	x19, x0
	if (mobj && refcount_dec(&mobj->refc))
 1106684:	91006000 	add	x0, x0, #0x18
 1106688:	940033c9 	bl	11135ac <refcount_dec>
 110668c:	72001c1f 	tst	w0, #0xff
 1106690:	54000100 	b.eq	11066b0 <mobj_put+0x40>  // b.none
		mobj->ops->free(mobj);
 1106694:	f9400260 	ldr	x0, [x19]
 1106698:	f9401401 	ldr	x1, [x0, #40]
 110669c:	aa1303e0 	mov	x0, x19
}
 11066a0:	f9400bf3 	ldr	x19, [sp, #16]
		mobj->ops->free(mobj);
 11066a4:	aa0103f0 	mov	x16, x1
}
 11066a8:	a8c27bfd 	ldp	x29, x30, [sp], #32
		mobj->ops->free(mobj);
 11066ac:	d61f0200 	br	x16
}
 11066b0:	f9400bf3 	ldr	x19, [sp, #16]
 11066b4:	a8c27bfd 	ldp	x29, x30, [sp], #32
 11066b8:	d65f03c0 	ret
 11066bc:	d65f03c0 	ret

00000000011066c0 <mobj_get_va.constprop.0>:
	if (mobj && mobj->ops && mobj->ops->get_va)
 11066c0:	b4000100 	cbz	x0, 11066e0 <mobj_get_va.constprop.0+0x20>
 11066c4:	f9400001 	ldr	x1, [x0]
 11066c8:	b40000c1 	cbz	x1, 11066e0 <mobj_get_va.constprop.0+0x20>
 11066cc:	f9400022 	ldr	x2, [x1]
 11066d0:	b4000082 	cbz	x2, 11066e0 <mobj_get_va.constprop.0+0x20>
		return mobj->ops->get_va(mobj, offset);
 11066d4:	aa0203f0 	mov	x16, x2
 11066d8:	d2800001 	mov	x1, #0x0                   	// #0
 11066dc:	d61f0200 	br	x16
}
 11066e0:	d2800000 	mov	x0, #0x0                   	// #0
 11066e4:	d65f03c0 	ret

00000000011066e8 <thread_rpc_free_arg>:
	if (cookie) {
 11066e8:	b4000180 	cbz	x0, 1106718 <thread_rpc_free_arg+0x30>
{
 11066ec:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
		uint32_t rpc_args[THREAD_RPC_NUM_ARGS] = {
 11066f0:	129fffa1 	mov	w1, #0xffff0002            	// #-65534
{
 11066f4:	910003fd 	mov	x29, sp
		uint32_t rpc_args[THREAD_RPC_NUM_ARGS] = {
 11066f8:	b90013e1 	str	w1, [sp, #16]
}

static inline void reg_pair_from_64(uint64_t val, uint32_t *reg0,
				    uint32_t *reg1)
{
	*reg0 = val >> 32;
 11066fc:	d360fc01 	lsr	x1, x0, #32
 1106700:	b90017e1 	str	w1, [sp, #20]
 1106704:	29037fe0 	stp	w0, wzr, [sp, #24]
		thread_rpc(rpc_args);
 1106708:	910043e0 	add	x0, sp, #0x10
 110670c:	9400027b 	bl	11070f8 <thread_rpc>
}
 1106710:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1106714:	d65f03c0 	ret
 1106718:	d65f03c0 	ret

000000000110671c <get_rpc_arg>:
}

static uint32_t get_rpc_arg(uint32_t cmd, size_t num_params,
			    struct thread_param *params, void **arg_ret,
			    uint64_t *carg_ret)
{
 110671c:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
 1106720:	910003fd 	mov	x29, sp
 1106724:	a90153f3 	stp	x19, x20, [sp, #16]
 1106728:	aa0203f3 	mov	x19, x2
 110672c:	a9025bf5 	stp	x21, x22, [sp, #32]
 1106730:	a90363f7 	stp	x23, x24, [sp, #48]
 1106734:	aa0403f8 	mov	x24, x4
 1106738:	a9046bf9 	stp	x25, x26, [sp, #64]
 110673c:	aa0103fa 	mov	x26, x1
 1106740:	aa0303f9 	mov	x25, x3
 1106744:	a90573fb 	stp	x27, x28, [sp, #80]
 1106748:	2a0003fb 	mov	w27, w0
	struct thread_ctx *thr = threads + thread_get_id();
 110674c:	97fffb46 	bl	1105464 <thread_get_id>
 1106750:	900002a1 	adrp	x1, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1106754:	13003c16 	sxth	w22, w0
 1106758:	5280e000 	mov	w0, #0x700                 	// #1792
	struct optee_msg_arg *arg = thr->rpc_arg;
	size_t sz = OPTEE_MSG_GET_ARG_SIZE(THREAD_RPC_MAX_NUM_PARAMS);

	if (num_params > THREAD_RPC_MAX_NUM_PARAMS)
 110675c:	f100135f 	cmp	x26, #0x4
	struct thread_ctx *thr = threads + thread_get_id();
 1106760:	f9417821 	ldr	x1, [x1, #752]
 1106764:	9b2006d6 	smaddl	x22, w22, w0, x1
	if (num_params > THREAD_RPC_MAX_NUM_PARAMS)
 1106768:	54000069 	b.ls	1106774 <get_rpc_arg+0x58>  // b.plast
	arg->cmd = cmd;
	arg->num_params = num_params;
	arg->ret = TEE_ERROR_GENERIC; /* in case value isn't updated */

	for (size_t n = 0; n < num_params; n++) {
		switch (params[n].attr) {
 110676c:	129fff20 	mov	w0, #0xffff0006            	// #-65530
 1106770:	14000017 	b	11067cc <get_rpc_arg+0xb0>
	struct optee_msg_arg *arg = thr->rpc_arg;
 1106774:	f942cad5 	ldr	x21, [x22, #1424]
	if (!arg) {
 1106778:	b5000555 	cbnz	x21, 1106820 <get_rpc_arg+0x104>
	uint32_t rpc_args[THREAD_RPC_NUM_ARGS] = {
 110677c:	d2bfffe0 	mov	x0, #0xffff0000            	// #4294901760
 1106780:	f2c01400 	movk	x0, #0xa0, lsl #32
 1106784:	a9067fe0 	stp	x0, xzr, [sp, #96]
	thread_rpc(rpc_args);
 1106788:	910183e0 	add	x0, sp, #0x60
 110678c:	9400025b 	bl	11070f8 <thread_rpc>
	return (uint64_t)reg0 << 32 | reg1;
 1106790:	294c07e0 	ldp	w0, w1, [sp, #96]
 1106794:	294d0bf4 	ldp	w20, w2, [sp, #104]
 1106798:	aa008020 	orr	x0, x1, x0, lsl #32
	if (!ALIGNMENT_IS_OK(pa, struct optee_msg_arg))
 110679c:	f240083f 	tst	x1, #0x7
 11067a0:	aa148054 	orr	x20, x2, x20, lsl #32
 11067a4:	54000220 	b.eq	11067e8 <get_rpc_arg+0xcc>  // b.none
	if (cookie) {
 11067a8:	b4000114 	cbz	x20, 11067c8 <get_rpc_arg+0xac>
		uint32_t rpc_args[THREAD_RPC_NUM_ARGS] = {
 11067ac:	129fffa0 	mov	w0, #0xffff0002            	// #-65534
 11067b0:	b90073e0 	str	w0, [sp, #112]
	*reg0 = val >> 32;
 11067b4:	d360fe80 	lsr	x0, x20, #32
 11067b8:	b90077e0 	str	w0, [sp, #116]
		thread_rpc(rpc_args);
 11067bc:	9101c3e0 	add	x0, sp, #0x70
		uint32_t rpc_args[THREAD_RPC_NUM_ARGS] = {
 11067c0:	290f7ff4 	stp	w20, wzr, [sp, #120]
		thread_rpc(rpc_args);
 11067c4:	9400024d 	bl	11070f8 <thread_rpc>
			return TEE_ERROR_OUT_OF_MEMORY;
 11067c8:	129ffe60 	mov	w0, #0xffff000c            	// #-65524

	*arg_ret = arg;
	*carg_ret = mobj_get_cookie(thr->rpc_mobj);

	return TEE_SUCCESS;
}
 11067cc:	a94153f3 	ldp	x19, x20, [sp, #16]
 11067d0:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11067d4:	a94363f7 	ldp	x23, x24, [sp, #48]
 11067d8:	a9446bf9 	ldp	x25, x26, [sp, #64]
 11067dc:	a94573fb 	ldp	x27, x28, [sp, #80]
 11067e0:	a8c87bfd 	ldp	x29, x30, [sp], #128
 11067e4:	d65f03c0 	ret
	mobj = rpc_shm_mobj_alloc(pa, size, co);
 11067e8:	aa1403e2 	mov	x2, x20
 11067ec:	d2801401 	mov	x1, #0xa0                  	// #160
 11067f0:	97ffff80 	bl	11065f0 <rpc_shm_mobj_alloc>
 11067f4:	aa0003f7 	mov	x23, x0
	if (!mobj)
 11067f8:	b4fffd80 	cbz	x0, 11067a8 <get_rpc_arg+0x8c>
		arg = mobj_get_va(mobj, 0);
 11067fc:	97ffffb1 	bl	11066c0 <mobj_get_va.constprop.0>
 1106800:	aa0003f5 	mov	x21, x0
		if (!arg) {
 1106804:	b50000a0 	cbnz	x0, 1106818 <get_rpc_arg+0xfc>
			thread_rpc_free_arg(mobj_get_cookie(mobj));
 1106808:	aa1703e0 	mov	x0, x23
 110680c:	97ffff70 	bl	11065cc <mobj_get_cookie>
 1106810:	97ffffb6 	bl	11066e8 <thread_rpc_free_arg>
 1106814:	17ffffed 	b	11067c8 <get_rpc_arg+0xac>
		thr->rpc_arg = arg;
 1106818:	f902cac0 	str	x0, [x22, #1424]
		thr->rpc_mobj = mobj;
 110681c:	f902ced7 	str	x23, [x22, #1432]
	memset(arg, 0, OPTEE_MSG_GET_ARG_SIZE(num_params));
 1106820:	91000757 	add	x23, x26, #0x1
 1106824:	aa1503e0 	mov	x0, x21
 1106828:	52800001 	mov	w1, #0x0                   	// #0
 110682c:	910082b4 	add	x20, x21, #0x20
 1106830:	d37beaf7 	lsl	x23, x23, #5
 1106834:	aa1703e2 	mov	x2, x23
 1106838:	d10082f7 	sub	x23, x23, #0x20
 110683c:	9400f529 	bl	1143ce0 <memset>
	arg->cmd = cmd;
 1106840:	8b170277 	add	x23, x19, x23
	arg->num_params = num_params;
 1106844:	b9001eba 	str	w26, [x21, #28]
		return mobj->ops->get_pa(mobj, offs, granule, pa);
 1106848:	9101c3fa 	add	x26, sp, #0x70
	arg->ret = TEE_ERROR_GENERIC; /* in case value isn't updated */
 110684c:	52bfffe0 	mov	w0, #0xffff0000            	// #-65536
	arg->cmd = cmd;
 1106850:	b90002bb 	str	w27, [x21]
	arg->ret = TEE_ERROR_GENERIC; /* in case value isn't updated */
 1106854:	b90016a0 	str	w0, [x21, #20]
	for (size_t n = 0; n < num_params; n++) {
 1106858:	eb1302ff 	cmp	x23, x19
 110685c:	540000e1 	b.ne	1106878 <get_rpc_arg+0x15c>  // b.any
	*arg_ret = arg;
 1106860:	f9000335 	str	x21, [x25]
	*carg_ret = mobj_get_cookie(thr->rpc_mobj);
 1106864:	f942cec0 	ldr	x0, [x22, #1432]
 1106868:	97ffff59 	bl	11065cc <mobj_get_cookie>
 110686c:	f9000300 	str	x0, [x24]
	return TEE_SUCCESS;
 1106870:	52800000 	mov	w0, #0x0                   	// #0
 1106874:	17ffffd6 	b	11067cc <get_rpc_arg+0xb0>
		switch (params[n].attr) {
 1106878:	b9400260 	ldr	w0, [x19]
 110687c:	71000c1f 	cmp	w0, #0x3
 1106880:	54000168 	b.hi	11068ac <get_rpc_arg+0x190>  // b.pmore
 1106884:	34000380 	cbz	w0, 11068f4 <get_rpc_arg+0x1d8>
					      THREAD_PARAM_ATTR_VALUE_IN +
 1106888:	2a0003e0 	mov	w0, w0
 110688c:	f9000280 	str	x0, [x20]
			arg->params[n].u.value.a = params[n].u.value.a;
 1106890:	f9400660 	ldr	x0, [x19, #8]
 1106894:	f9000680 	str	x0, [x20, #8]
			arg->params[n].u.value.b = params[n].u.value.b;
 1106898:	f9400a60 	ldr	x0, [x19, #16]
 110689c:	f9000a80 	str	x0, [x20, #16]
			arg->params[n].u.value.c = params[n].u.value.c;
 11068a0:	f9400e60 	ldr	x0, [x19, #24]
 11068a4:	f9000e80 	str	x0, [x20, #24]
			break;
 11068a8:	14000014 	b	11068f8 <get_rpc_arg+0x1dc>
		switch (params[n].attr) {
 11068ac:	51001000 	sub	w0, w0, #0x4
 11068b0:	7100081f 	cmp	w0, #0x2
 11068b4:	54fff5c8 	b.hi	110676c <get_rpc_arg+0x50>  // b.pmore
			if (!params[n].u.memref.mobj ||
 11068b8:	f9400e60 	ldr	x0, [x19, #24]
 11068bc:	b5000240 	cbnz	x0, 1106904 <get_rpc_arg+0x1e8>
	param->attr = tpm->attr - THREAD_PARAM_ATTR_MEMREF_IN +
 11068c0:	b9400260 	ldr	w0, [x19]
	struct mobj *mobj = tpm->u.memref.mobj;
 11068c4:	f9400e7c 	ldr	x28, [x19, #24]
	paddr_t pa = 0;
 11068c8:	f9003bff 	str	xzr, [sp, #112]
	param->attr = tpm->attr - THREAD_PARAM_ATTR_MEMREF_IN +
 11068cc:	11001400 	add	w0, w0, #0x5
 11068d0:	f9000280 	str	x0, [x20]
	if (mobj) {
 11068d4:	b500045c 	cbnz	x28, 110695c <get_rpc_arg+0x240>
	uint64_t shm_ref = 0;
 11068d8:	d280001b 	mov	x27, #0x0                   	// #0
	param->u.tmem.size = tpm->u.memref.size;
 11068dc:	f9400a60 	ldr	x0, [x19, #16]
 11068e0:	f9000a80 	str	x0, [x20, #16]
	param->u.tmem.buf_ptr = pa;
 11068e4:	f9403be0 	ldr	x0, [sp, #112]
 11068e8:	f9000680 	str	x0, [x20, #8]
	param->u.tmem.shm_ref = shm_ref;
 11068ec:	f9000e9b 	str	x27, [x20, #24]
	return true;
 11068f0:	14000002 	b	11068f8 <get_rpc_arg+0x1dc>
			arg->params[n].attr = OPTEE_MSG_ATTR_TYPE_NONE;
 11068f4:	f900029f 	str	xzr, [x20]
	for (size_t n = 0; n < num_params; n++) {
 11068f8:	91008294 	add	x20, x20, #0x20
 11068fc:	91008273 	add	x19, x19, #0x20
 1106900:	17ffffd6 	b	1106858 <get_rpc_arg+0x13c>
			    mobj_matches(params[n].u.memref.mobj,
 1106904:	52800021 	mov	w1, #0x1                   	// #1
 1106908:	97ffff28 	bl	11065a8 <mobj_matches>
			if (!params[n].u.memref.mobj ||
 110690c:	72001c1f 	tst	w0, #0xff
 1106910:	54fffd81 	b.ne	11068c0 <get_rpc_arg+0x1a4>  // b.any
			} else  if (mobj_matches(params[n].u.memref.mobj,
 1106914:	f9400e60 	ldr	x0, [x19, #24]
 1106918:	528000e1 	mov	w1, #0x7                   	// #7
 110691c:	97ffff23 	bl	11065a8 <mobj_matches>
 1106920:	72001c1f 	tst	w0, #0xff
 1106924:	54fff240 	b.eq	110676c <get_rpc_arg+0x50>  // b.none
	param->attr = tpm->attr - THREAD_PARAM_ATTR_MEMREF_IN +
 1106928:	b9400260 	ldr	w0, [x19]
 110692c:	11000400 	add	w0, w0, #0x1
 1106930:	f9000280 	str	x0, [x20]
	param->u.rmem.offs = tpm->u.memref.offs;
 1106934:	f9400660 	ldr	x0, [x19, #8]
 1106938:	f9000680 	str	x0, [x20, #8]
	param->u.rmem.size = tpm->u.memref.size;
 110693c:	f9400a60 	ldr	x0, [x19, #16]
 1106940:	f9000a80 	str	x0, [x20, #16]
	if (tpm->u.memref.mobj) {
 1106944:	f9400e60 	ldr	x0, [x19, #24]
 1106948:	b4000280 	cbz	x0, 1106998 <get_rpc_arg+0x27c>
		param->u.rmem.shm_ref = mobj_get_cookie(tpm->u.memref.mobj);
 110694c:	97ffff20 	bl	11065cc <mobj_get_cookie>
 1106950:	f9000e80 	str	x0, [x20, #24]
		if (!param->u.rmem.shm_ref)
 1106954:	b5fffd20 	cbnz	x0, 11068f8 <get_rpc_arg+0x1dc>
 1106958:	17ffff85 	b	110676c <get_rpc_arg+0x50>
		shm_ref = mobj_get_cookie(mobj);
 110695c:	aa1c03e0 	mov	x0, x28
 1106960:	97ffff1b 	bl	11065cc <mobj_get_cookie>
 1106964:	aa0003fb 	mov	x27, x0
		if (!shm_ref)
 1106968:	b4fff020 	cbz	x0, 110676c <get_rpc_arg+0x50>
	if (mobj && mobj->ops && mobj->ops->get_pa)
 110696c:	f9400380 	ldr	x0, [x28]
 1106970:	b4ffefe0 	cbz	x0, 110676c <get_rpc_arg+0x50>
 1106974:	f9400404 	ldr	x4, [x0, #8]
 1106978:	b4ffefa4 	cbz	x4, 110676c <get_rpc_arg+0x50>
		return mobj->ops->get_pa(mobj, offs, granule, pa);
 110697c:	f9400661 	ldr	x1, [x19, #8]
 1106980:	aa1a03e3 	mov	x3, x26
 1106984:	aa1c03e0 	mov	x0, x28
 1106988:	d2800002 	mov	x2, #0x0                   	// #0
 110698c:	d63f0080 	blr	x4
		if (mobj_get_pa(mobj, tpm->u.memref.offs, 0, &pa))
 1106990:	34fffa60 	cbz	w0, 11068dc <get_rpc_arg+0x1c0>
 1106994:	17ffff76 	b	110676c <get_rpc_arg+0x50>
		param->u.rmem.shm_ref = 0;
 1106998:	f9000e9f 	str	xzr, [x20, #24]
 110699c:	17ffffd7 	b	11068f8 <get_rpc_arg+0x1dc>

00000000011069a0 <thread_rpc_free>:
 * @mobj:	mobj that describes allocated buffer
 *
 * This function also frees corresponding mobj.
 */
static void thread_rpc_free(unsigned int bt, uint64_t cookie, struct mobj *mobj)
{
 11069a0:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
	uint32_t rpc_args[THREAD_RPC_NUM_ARGS] = { OPTEE_SMC_RETURN_RPC_CMD };
	void *arg = NULL;
	uint64_t carg = 0;
	struct thread_param param = THREAD_PARAM_VALUE(IN, bt, cookie, 0);
 11069a4:	2a0003e0 	mov	w0, w0
{
 11069a8:	910003fd 	mov	x29, sp
 11069ac:	a90153f3 	stp	x19, x20, [sp, #16]
 11069b0:	aa0203f4 	mov	x20, x2
	uint32_t rpc_args[THREAD_RPC_NUM_ARGS] = { OPTEE_SMC_RETURN_RPC_CMD };
 11069b4:	129fff42 	mov	w2, #0xffff0005            	// #-65531
 11069b8:	a9037fff 	stp	xzr, xzr, [sp, #48]
	uint32_t ret = get_rpc_arg(OPTEE_RPC_CMD_SHM_FREE, 1, &param,
 11069bc:	9100a3e4 	add	x4, sp, #0x28
 11069c0:	910083e3 	add	x3, sp, #0x20
	uint32_t rpc_args[THREAD_RPC_NUM_ARGS] = { OPTEE_SMC_RETURN_RPC_CMD };
 11069c4:	b90033e2 	str	w2, [sp, #48]
	struct thread_param param = THREAD_PARAM_VALUE(IN, bt, cookie, 0);
 11069c8:	52800022 	mov	w2, #0x1                   	// #1
 11069cc:	b90043e2 	str	w2, [sp, #64]
	uint32_t ret = get_rpc_arg(OPTEE_RPC_CMD_SHM_FREE, 1, &param,
 11069d0:	910103e2 	add	x2, sp, #0x40
	struct thread_param param = THREAD_PARAM_VALUE(IN, bt, cookie, 0);
 11069d4:	a90487e0 	stp	x0, x1, [sp, #72]
	uint32_t ret = get_rpc_arg(OPTEE_RPC_CMD_SHM_FREE, 1, &param,
 11069d8:	d2800021 	mov	x1, #0x1                   	// #1
 11069dc:	528000e0 	mov	w0, #0x7                   	// #7
	uint64_t carg = 0;
 11069e0:	a9027fff 	stp	xzr, xzr, [sp, #32]
	struct thread_param param = THREAD_PARAM_VALUE(IN, bt, cookie, 0);
 11069e4:	f9002fff 	str	xzr, [sp, #88]
	uint32_t ret = get_rpc_arg(OPTEE_RPC_CMD_SHM_FREE, 1, &param,
 11069e8:	97ffff4d 	bl	110671c <get_rpc_arg>
 11069ec:	2a0003f3 	mov	w19, w0
				   &arg, &carg);

	mobj_put(mobj);
 11069f0:	aa1403e0 	mov	x0, x20
 11069f4:	97ffff1f 	bl	1106670 <mobj_put>

	if (!ret) {
 11069f8:	350000d3 	cbnz	w19, 1106a10 <thread_rpc_free+0x70>
		reg_pair_from_64(carg, rpc_args + 1, rpc_args + 2);
 11069fc:	f94017e0 	ldr	x0, [sp, #40]
 1106a00:	d360fc01 	lsr	x1, x0, #32
	*reg1 = val;
 1106a04:	290683e1 	stp	w1, w0, [sp, #52]
		thread_rpc(rpc_args);
 1106a08:	9100c3e0 	add	x0, sp, #0x30
 1106a0c:	940001bb 	bl	11070f8 <thread_rpc>
	}
}
 1106a10:	a94153f3 	ldp	x19, x20, [sp, #16]
 1106a14:	a8c67bfd 	ldp	x29, x30, [sp], #96
 1106a18:	d65f03c0 	ret

0000000001106a1c <thread_rpc_alloc.constprop.0>:
 * @align:	required alignment of buffer
 * @bt:		buffer type OPTEE_RPC_SHM_TYPE_*
 *
 * Returns a pointer to MOBJ for the memory on success, or NULL on failure.
 */
static struct mobj *thread_rpc_alloc(size_t size, size_t align, unsigned int bt)
 1106a1c:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
 1106a20:	910003fd 	mov	x29, sp
 1106a24:	a90153f3 	stp	x19, x20, [sp, #16]
 1106a28:	2a0103f4 	mov	w20, w1
{
	uint32_t rpc_args[THREAD_RPC_NUM_ARGS] = { OPTEE_SMC_RETURN_RPC_CMD };
 1106a2c:	129fff41 	mov	w1, #0xffff0005            	// #-65531
 1106a30:	a9047fff 	stp	xzr, xzr, [sp, #64]
	void *arg = NULL;
	uint64_t carg = 0;
	struct thread_param param = THREAD_PARAM_VALUE(IN, bt, size, align);
	uint32_t ret = get_rpc_arg(OPTEE_RPC_CMD_SHM_ALLOC, 1, &param,
 1106a34:	9100e3e4 	add	x4, sp, #0x38
 1106a38:	9100c3e3 	add	x3, sp, #0x30
	uint32_t rpc_args[THREAD_RPC_NUM_ARGS] = { OPTEE_SMC_RETURN_RPC_CMD };
 1106a3c:	b90043e1 	str	w1, [sp, #64]
	struct thread_param param = THREAD_PARAM_VALUE(IN, bt, size, align);
 1106a40:	52800021 	mov	w1, #0x1                   	// #1
 1106a44:	b90053e1 	str	w1, [sp, #80]
 1106a48:	2a1403e1 	mov	w1, w20
 1106a4c:	f90033e0 	str	x0, [sp, #96]
 1106a50:	d2800100 	mov	x0, #0x8                   	// #8
	uint32_t ret = get_rpc_arg(OPTEE_RPC_CMD_SHM_ALLOC, 1, &param,
 1106a54:	910143e2 	add	x2, sp, #0x50
static struct mobj *thread_rpc_alloc(size_t size, size_t align, unsigned int bt)
 1106a58:	f90013f5 	str	x21, [sp, #32]
	uint64_t carg = 0;
 1106a5c:	a9037fff 	stp	xzr, xzr, [sp, #48]
	struct thread_param param = THREAD_PARAM_VALUE(IN, bt, size, align);
 1106a60:	f9002fe1 	str	x1, [sp, #88]
	uint32_t ret = get_rpc_arg(OPTEE_RPC_CMD_SHM_ALLOC, 1, &param,
 1106a64:	d2800021 	mov	x1, #0x1                   	// #1
	struct thread_param param = THREAD_PARAM_VALUE(IN, bt, size, align);
 1106a68:	f90037e0 	str	x0, [sp, #104]
	uint32_t ret = get_rpc_arg(OPTEE_RPC_CMD_SHM_ALLOC, 1, &param,
 1106a6c:	528000c0 	mov	w0, #0x6                   	// #6
 1106a70:	97ffff2b 	bl	110671c <get_rpc_arg>
				   &arg, &carg);

	if (ret)
 1106a74:	35000600 	cbnz	w0, 1106b34 <thread_rpc_alloc.constprop.0+0x118>
		return NULL;

	reg_pair_from_64(carg, rpc_args + 1, rpc_args + 2);
 1106a78:	f9401fe0 	ldr	x0, [sp, #56]
	*reg0 = val >> 32;
 1106a7c:	d360fc01 	lsr	x1, x0, #32
	*reg1 = val;
 1106a80:	290883e1 	stp	w1, w0, [sp, #68]
	thread_rpc(rpc_args);
 1106a84:	910103e0 	add	x0, sp, #0x40
 1106a88:	9400019c 	bl	11070f8 <thread_rpc>

	return get_rpc_alloc_res(arg, bt);
 1106a8c:	f9401be2 	ldr	x2, [sp, #48]
	if (arg->ret || arg->num_params != 1)
 1106a90:	b9401440 	ldr	w0, [x2, #20]
 1106a94:	35000500 	cbnz	w0, 1106b34 <thread_rpc_alloc.constprop.0+0x118>
 1106a98:	b9401c43 	ldr	w3, [x2, #28]
 1106a9c:	7100047f 	cmp	w3, #0x1
 1106aa0:	540004a1 	b.ne	1106b34 <thread_rpc_alloc.constprop.0+0x118>  // b.any
	if (arg->params[0].attr != OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT  &&
 1106aa4:	f9401044 	ldr	x4, [x2, #32]
 1106aa8:	9276f880 	and	x0, x4, #0xfffffffffffffdff
 1106aac:	f100281f 	cmp	x0, #0xa
 1106ab0:	54000421 	b.ne	1106b34 <thread_rpc_alloc.constprop.0+0x118>  // b.any
	cookie = arg->params[0].u.tmem.shm_ref;
 1106ab4:	f9401c55 	ldr	x21, [x2, #56]
	if (arg->params[0].attr == OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT)
 1106ab8:	f100289f 	cmp	x4, #0xa
	sz = arg->params[0].u.tmem.size;
 1106abc:	a9428440 	ldp	x0, x1, [x2, #40]
		mobj = rpc_shm_mobj_alloc(p, sz, cookie);
 1106ac0:	aa1503e2 	mov	x2, x21
	if (arg->params[0].attr == OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT)
 1106ac4:	540001a1 	b.ne	1106af8 <thread_rpc_alloc.constprop.0+0xdc>  // b.any
		mobj = rpc_shm_mobj_alloc(p, sz, cookie);
 1106ac8:	97fffeca 	bl	11065f0 <rpc_shm_mobj_alloc>
		mobj = msg_param_mobj_from_noncontig(p, sz, cookie, true);
 1106acc:	aa0003f3 	mov	x19, x0
	if (!mobj) {
 1106ad0:	b5000180 	cbnz	x0, 1106b00 <thread_rpc_alloc.constprop.0+0xe4>
		thread_rpc_free(bt, cookie, mobj);
 1106ad4:	aa1503e1 	mov	x1, x21
 1106ad8:	2a1403e0 	mov	w0, w20
 1106adc:	d2800002 	mov	x2, #0x0                   	// #0
 1106ae0:	97ffffb0 	bl	11069a0 <thread_rpc_free>
}
 1106ae4:	aa1303e0 	mov	x0, x19
 1106ae8:	a94153f3 	ldp	x19, x20, [sp, #16]
 1106aec:	f94013f5 	ldr	x21, [sp, #32]
 1106af0:	a8c77bfd 	ldp	x29, x30, [sp], #112
 1106af4:	d65f03c0 	ret
		mobj = msg_param_mobj_from_noncontig(p, sz, cookie, true);
 1106af8:	940031f5 	bl	11132cc <msg_param_mobj_from_noncontig>
 1106afc:	17fffff4 	b	1106acc <thread_rpc_alloc.constprop.0+0xb0>
	return NULL;
}

static inline bool mobj_is_nonsec(struct mobj *mobj)
{
	return mobj_matches(mobj, CORE_MEM_NON_SEC);
 1106b00:	52800041 	mov	w1, #0x2                   	// #2
 1106b04:	97fffea9 	bl	11065a8 <mobj_matches>
	assert(mobj_is_nonsec(mobj));
 1106b08:	72001c1f 	tst	w0, #0xff
 1106b0c:	54fffec1 	b.ne	1106ae4 <thread_rpc_alloc.constprop.0+0xc8>  // b.any
 1106b10:	f0000243 	adrp	x3, 1151000 <small_prime+0x168>
 1106b14:	f0000241 	adrp	x1, 1151000 <small_prime+0x168>
 1106b18:	912ab863 	add	x3, x3, #0xaae
 1106b1c:	91279421 	add	x1, x1, #0x9e5
 1106b20:	f0000240 	adrp	x0, 1151000 <small_prime+0x168>
 1106b24:	9129d000 	add	x0, x0, #0xa74
 1106b28:	528045c2 	mov	w2, #0x22e                 	// #558
 1106b2c:	94002de0 	bl	11122ac <_assert_log>
 1106b30:	94002df0 	bl	11122f0 <_assert_break>
		return NULL;
 1106b34:	d2800013 	mov	x19, #0x0                   	// #0
 1106b38:	17ffffeb 	b	1106ae4 <thread_rpc_alloc.constprop.0+0xc8>

0000000001106b3c <thread_handle_fast_smc>:
{
 1106b3c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1106b40:	910003fd 	mov	x29, sp
 1106b44:	f9000bf3 	str	x19, [sp, #16]
 1106b48:	aa0003f3 	mov	x19, x0
	thread_check_canaries();
 1106b4c:	97fff839 	bl	1104c30 <thread_check_canaries>
	tee_entry_fast(args);
 1106b50:	aa1303e0 	mov	x0, x19
 1106b54:	9400193a 	bl	110d03c <tee_entry_fast>
	assert(thread_get_exceptions() == THREAD_EXCP_ALL);
 1106b58:	97fff8ef 	bl	1104f14 <thread_get_exceptions>
 1106b5c:	71001c1f 	cmp	w0, #0x7
 1106b60:	54000140 	b.eq	1106b88 <thread_handle_fast_smc+0x4c>  // b.none
 1106b64:	f0000243 	adrp	x3, 1151000 <small_prime+0x168>
 1106b68:	f0000241 	adrp	x1, 1151000 <small_prime+0x168>
 1106b6c:	912a2463 	add	x3, x3, #0xa89
 1106b70:	91279421 	add	x1, x1, #0x9e5
 1106b74:	f0000240 	adrp	x0, 1151000 <small_prime+0x168>
 1106b78:	91283400 	add	x0, x0, #0xa0d
 1106b7c:	52800622 	mov	w2, #0x31                  	// #49
 1106b80:	94002dcb 	bl	11122ac <_assert_log>
 1106b84:	94002ddb 	bl	11122f0 <_assert_break>
}
 1106b88:	f9400bf3 	ldr	x19, [sp, #16]
 1106b8c:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1106b90:	d65f03c0 	ret

0000000001106b94 <thread_handle_std_smc>:
{
 1106b94:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 1106b98:	910003fd 	mov	x29, sp
 1106b9c:	a90153f3 	stp	x19, x20, [sp, #16]
 1106ba0:	2a0003f3 	mov	w19, w0
 1106ba4:	2a0103f4 	mov	w20, w1
 1106ba8:	a9025bf5 	stp	x21, x22, [sp, #32]
 1106bac:	2a0203f5 	mov	w21, w2
 1106bb0:	2a0303f6 	mov	w22, w3
 1106bb4:	a90363f7 	stp	x23, x24, [sp, #48]
 1106bb8:	2a0403f7 	mov	w23, w4
 1106bbc:	2a0503f8 	mov	w24, w5
	thread_check_canaries();
 1106bc0:	97fff81c 	bl	1104c30 <thread_check_canaries>
	if (a0 == OPTEE_SMC_CALL_RETURN_FROM_RPC) {
 1106bc4:	52800060 	mov	w0, #0x3                   	// #3
 1106bc8:	72a64000 	movk	w0, #0x3200, lsl #16
 1106bcc:	6b00027f 	cmp	w19, w0
 1106bd0:	540001a1 	b.ne	1106c04 <thread_handle_std_smc+0x70>  // b.any
		thread_resume_from_rpc(a3, a1, a2, a4, a5);
 1106bd4:	2a1603e0 	mov	w0, w22
 1106bd8:	2a1803e4 	mov	w4, w24
 1106bdc:	2a1703e3 	mov	w3, w23
 1106be0:	2a1503e2 	mov	w2, w21
 1106be4:	2a1403e1 	mov	w1, w20
 1106be8:	97fffa3c 	bl	11054d8 <thread_resume_from_rpc>
		rv = OPTEE_SMC_RETURN_ERESUME;
 1106bec:	52800060 	mov	w0, #0x3                   	// #3
}
 1106bf0:	a94153f3 	ldp	x19, x20, [sp, #16]
 1106bf4:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1106bf8:	a94363f7 	ldp	x23, x24, [sp, #48]
 1106bfc:	a8c47bfd 	ldp	x29, x30, [sp], #64
 1106c00:	d65f03c0 	ret
		thread_alloc_and_run(a0, a1, a2, a3);
 1106c04:	2a1303e0 	mov	w0, w19
 1106c08:	2a1603e3 	mov	w3, w22
 1106c0c:	2a1503e2 	mov	w2, w21
 1106c10:	2a1403e1 	mov	w1, w20
 1106c14:	97fffa7e 	bl	110560c <thread_alloc_and_run>
		rv = OPTEE_SMC_RETURN_ETHREAD_LIMIT;
 1106c18:	52800020 	mov	w0, #0x1                   	// #1
	return rv;
 1106c1c:	17fffff5 	b	1106bf0 <thread_handle_std_smc+0x5c>

0000000001106c20 <__thread_std_smc_entry>:
{
 1106c20:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 1106c24:	910003fd 	mov	x29, sp
 1106c28:	a90153f3 	stp	x19, x20, [sp, #16]
	if (a0 != OPTEE_SMC_CALL_WITH_ARG) {
 1106c2c:	52800094 	mov	w20, #0x4                   	// #4
 1106c30:	72a64014 	movk	w20, #0x3200, lsl #16
{
 1106c34:	f90013f5 	str	x21, [sp, #32]
	if (a0 != OPTEE_SMC_CALL_WITH_ARG) {
 1106c38:	6b14001f 	cmp	w0, w20
 1106c3c:	54000320 	b.eq	1106ca0 <__thread_std_smc_entry+0x80>  // b.none
		EMSG("Unknown SMC 0x%"PRIx32, a0);
 1106c40:	f0000253 	adrp	x19, 1151000 <small_prime+0x168>
 1106c44:	912a8273 	add	x19, x19, #0xaa0
 1106c48:	2a0003e5 	mov	w5, w0
 1106c4c:	52800023 	mov	w3, #0x1                   	// #1
 1106c50:	aa1303e0 	mov	x0, x19
 1106c54:	52800022 	mov	w2, #0x1                   	// #1
 1106c58:	52801541 	mov	w1, #0xaa                  	// #170
 1106c5c:	f0000244 	adrp	x4, 1151000 <small_prime+0x168>
 1106c60:	9128e084 	add	x4, x4, #0xa38
 1106c64:	9400f838 	bl	1144d44 <trace_printf>
		DMSG("Expected 0x%x", OPTEE_SMC_CALL_WITH_ARG);
 1106c68:	2a1403e5 	mov	w5, w20
		return OPTEE_SMC_RETURN_EBADCMD;
 1106c6c:	528000b4 	mov	w20, #0x5                   	// #5
		DMSG("Expected 0x%x", OPTEE_SMC_CALL_WITH_ARG);
 1106c70:	aa1303e0 	mov	x0, x19
 1106c74:	f0000244 	adrp	x4, 1151000 <small_prime+0x168>
 1106c78:	52800023 	mov	w3, #0x1                   	// #1
 1106c7c:	91292484 	add	x4, x4, #0xa49
 1106c80:	52800062 	mov	w2, #0x3                   	// #3
 1106c84:	52801561 	mov	w1, #0xab                  	// #171
 1106c88:	9400f82f 	bl	1144d44 <trace_printf>
}
 1106c8c:	2a1403e0 	mov	w0, w20
 1106c90:	a94153f3 	ldp	x19, x20, [sp, #16]
 1106c94:	f94013f5 	ldr	x21, [sp, #32]
 1106c98:	a8c47bfd 	ldp	x29, x30, [sp], #64
 1106c9c:	d65f03c0 	ret
	return (uint64_t)reg0 << 32 | reg1;
 1106ca0:	2a0203e2 	mov	w2, w2
	if (core_pbuf_is(CORE_MEM_NSEC_SHM, parg,
 1106ca4:	52800020 	mov	w0, #0x1                   	// #1
 1106ca8:	aa018054 	orr	x20, x2, x1, lsl #32
 1106cac:	d2800402 	mov	x2, #0x20                  	// #32
 1106cb0:	aa1403e1 	mov	x1, x20
 1106cb4:	94000a51 	bl	11095f8 <core_pbuf_is>
 1106cb8:	72001c1f 	tst	w0, #0xff
 1106cbc:	540005a0 	b.eq	1106d70 <__thread_std_smc_entry+0x150>  // b.none
	arg = phys_to_virt(parg, MEM_AREA_NSEC_SHM);
 1106cc0:	aa1403e0 	mov	x0, x20
 1106cc4:	52800141 	mov	w1, #0xa                   	// #10
 1106cc8:	94000e9b 	bl	110a734 <phys_to_virt>
	if (!arg)
 1106ccc:	b50001e0 	cbnz	x0, 1106d08 <__thread_std_smc_entry+0xe8>
		return NULL;
 1106cd0:	d2800013 	mov	x19, #0x0                   	// #0
		EMSG("Bad arg address 0x%" PRIxPA, parg);
 1106cd4:	aa1403e5 	mov	x5, x20
 1106cd8:	f0000244 	adrp	x4, 1151000 <small_prime+0x168>
 1106cdc:	91295c84 	add	x4, x4, #0xa57
 1106ce0:	52800023 	mov	w3, #0x1                   	// #1
 1106ce4:	52800022 	mov	w2, #0x1                   	// #1
 1106ce8:	52801761 	mov	w1, #0xbb                  	// #187
 1106cec:	f0000240 	adrp	x0, 1151000 <small_prime+0x168>
 1106cf0:	912a8000 	add	x0, x0, #0xaa0
 1106cf4:	9400f814 	bl	1144d44 <trace_printf>
		mobj_put(mobj);
 1106cf8:	aa1303e0 	mov	x0, x19
 1106cfc:	97fffe5d 	bl	1106670 <mobj_put>
			return OPTEE_SMC_RETURN_EBADADDR;
 1106d00:	52800094 	mov	w20, #0x4                   	// #4
	return rv;
 1106d04:	17ffffe2 	b	1106c8c <__thread_std_smc_entry+0x6c>
	*num_params = READ_ONCE(arg->num_params);
 1106d08:	91007000 	add	x0, x0, #0x1c
 1106d0c:	b9400015 	ldr	w21, [x0]
	if (*num_params > OPTEE_MSG_MAX_NUM_PARAMS)
 1106d10:	7101febf 	cmp	w21, #0x7f
 1106d14:	54fffde8 	b.hi	1106cd0 <__thread_std_smc_entry+0xb0>  // b.pmore
	args_size = OPTEE_MSG_GET_ARG_SIZE(*num_params);
 1106d18:	d37b7ea1 	ubfiz	x1, x21, #5, #32
	return mobj_shm_alloc(parg, args_size, 0);
 1106d1c:	aa1403e0 	mov	x0, x20
 1106d20:	91008021 	add	x1, x1, #0x20
 1106d24:	d2800002 	mov	x2, #0x0                   	// #0
 1106d28:	940045af 	bl	11183e4 <mobj_shm_alloc>
 1106d2c:	aa0003f3 	mov	x19, x0
	if (!mobj || !ALIGNMENT_IS_OK(parg, struct optee_msg_arg)) {
 1106d30:	b4fffd13 	cbz	x19, 1106cd0 <__thread_std_smc_entry+0xb0>
 1106d34:	f2400a9f 	tst	x20, #0x7
 1106d38:	54fffce1 	b.ne	1106cd4 <__thread_std_smc_entry+0xb4>  // b.any
	arg = mobj_get_va(mobj, 0);
 1106d3c:	aa1303e0 	mov	x0, x19
 1106d40:	97fffe60 	bl	11066c0 <mobj_get_va.constprop.0>
 1106d44:	aa0003f4 	mov	x20, x0
	assert(arg && mobj_is_nonsec(mobj));
 1106d48:	b50003a0 	cbnz	x0, 1106dbc <__thread_std_smc_entry+0x19c>
 1106d4c:	f0000243 	adrp	x3, 1151000 <small_prime+0x168>
 1106d50:	f0000241 	adrp	x1, 1151000 <small_prime+0x168>
 1106d54:	912a8063 	add	x3, x3, #0xaa0
 1106d58:	91279421 	add	x1, x1, #0x9e5
 1106d5c:	f0000240 	adrp	x0, 1151000 <small_prime+0x168>
 1106d60:	9129b400 	add	x0, x0, #0xa6d
 1106d64:	52801822 	mov	w2, #0xc1                  	// #193
 1106d68:	94002d51 	bl	11122ac <_assert_log>
 1106d6c:	94002d61 	bl	11122f0 <_assert_break>
		if (parg & SMALL_PAGE_MASK)
 1106d70:	f2402e9f 	tst	x20, #0xfff
 1106d74:	54fffc61 	b.ne	1106d00 <__thread_std_smc_entry+0xe0>  // b.any
	mobj = mobj_mapped_shm_alloc(&parg, 1, 0, 0);
 1106d78:	9100e3e0 	add	x0, sp, #0x38
 1106d7c:	d2800003 	mov	x3, #0x0                   	// #0
 1106d80:	d2800002 	mov	x2, #0x0                   	// #0
 1106d84:	d2800021 	mov	x1, #0x1                   	// #1
 1106d88:	f9001ff4 	str	x20, [sp, #56]
 1106d8c:	940016c1 	bl	110c890 <mobj_mapped_shm_alloc>
 1106d90:	aa0003f3 	mov	x19, x0
	if (!mobj)
 1106d94:	b4fff9e0 	cbz	x0, 1106cd0 <__thread_std_smc_entry+0xb0>
	arg = mobj_get_va(mobj, 0);
 1106d98:	97fffe4a 	bl	11066c0 <mobj_get_va.constprop.0>
	if (!arg)
 1106d9c:	b40000a0 	cbz	x0, 1106db0 <__thread_std_smc_entry+0x190>
	*num_params = READ_ONCE(arg->num_params);
 1106da0:	91007000 	add	x0, x0, #0x1c
 1106da4:	b9400015 	ldr	w21, [x0]
	if (*num_params > OPTEE_MSG_MAX_NUM_PARAMS)
 1106da8:	7101febf 	cmp	w21, #0x7f
 1106dac:	54fffc29 	b.ls	1106d30 <__thread_std_smc_entry+0x110>  // b.plast
	mobj_put(mobj);
 1106db0:	aa1303e0 	mov	x0, x19
 1106db4:	97fffe2f 	bl	1106670 <mobj_put>
	return NULL;
 1106db8:	17ffffc6 	b	1106cd0 <__thread_std_smc_entry+0xb0>
 1106dbc:	aa1303e0 	mov	x0, x19
 1106dc0:	52800041 	mov	w1, #0x2                   	// #2
 1106dc4:	97fffdf9 	bl	11065a8 <mobj_matches>
	assert(arg && mobj_is_nonsec(mobj));
 1106dc8:	72001c1f 	tst	w0, #0xff
 1106dcc:	54fffc00 	b.eq	1106d4c <__thread_std_smc_entry+0x12c>  // b.none
	rv = tee_entry_std(arg, num_params);
 1106dd0:	2a1503e1 	mov	w1, w21
 1106dd4:	aa1403e0 	mov	x0, x20
 1106dd8:	94005257 	bl	111b734 <tee_entry_std>
 1106ddc:	2a0003f4 	mov	w20, w0
	mobj_put(mobj);
 1106de0:	aa1303e0 	mov	x0, x19
 1106de4:	97fffe23 	bl	1106670 <mobj_put>
	if (rv == OPTEE_SMC_RETURN_OK) {
 1106de8:	35fff534 	cbnz	w20, 1106c8c <__thread_std_smc_entry+0x6c>
		struct thread_ctx *thr = threads + thread_get_id();
 1106dec:	97fff99e 	bl	1105464 <thread_get_id>
 1106df0:	13003c13 	sxth	w19, w0
 1106df4:	900002a0 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1106df8:	5280e001 	mov	w1, #0x700                 	// #1792
 1106dfc:	f9417800 	ldr	x0, [x0, #752]
 1106e00:	9b210273 	smaddl	x19, w19, w1, x0
		thread_rpc_shm_cache_clear(&thr->shm_cache);
 1106e04:	91168260 	add	x0, x19, #0x5a0
 1106e08:	97fffdd8 	bl	1106568 <thread_rpc_shm_cache_clear>
		if (!thread_prealloc_rpc_cache) {
 1106e0c:	d0000300 	adrp	x0, 1168000 <data.5093+0x9e28>
 1106e10:	396a4000 	ldrb	w0, [x0, #2704]
 1106e14:	35fff3c0 	cbnz	w0, 1106c8c <__thread_std_smc_entry+0x6c>
			thread_rpc_free_arg(mobj_get_cookie(thr->rpc_mobj));
 1106e18:	f942ce60 	ldr	x0, [x19, #1432]
 1106e1c:	97fffdec 	bl	11065cc <mobj_get_cookie>
 1106e20:	97fffe32 	bl	11066e8 <thread_rpc_free_arg>
			mobj_put(thr->rpc_mobj);
 1106e24:	f942ce60 	ldr	x0, [x19, #1432]
 1106e28:	97fffe12 	bl	1106670 <mobj_put>
			thr->rpc_arg = 0;
 1106e2c:	f902ca7f 	str	xzr, [x19, #1424]
			thr->rpc_mobj = NULL;
 1106e30:	f902ce7f 	str	xzr, [x19, #1432]
 1106e34:	17ffff96 	b	1106c8c <__thread_std_smc_entry+0x6c>

0000000001106e38 <thread_disable_prealloc_rpc_cache>:
{
 1106e38:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1106e3c:	910003fd 	mov	x29, sp
 1106e40:	a90153f3 	stp	x19, x20, [sp, #16]
 1106e44:	aa0003f4 	mov	x20, x0
	uint32_t exceptions = thread_mask_exceptions(THREAD_EXCP_FOREIGN_INTR);
 1106e48:	52800040 	mov	w0, #0x2                   	// #2
{
 1106e4c:	f90013f5 	str	x21, [sp, #32]
	uint32_t exceptions = thread_mask_exceptions(THREAD_EXCP_FOREIGN_INTR);
 1106e50:	97fff8ba 	bl	1105138 <thread_mask_exceptions>
 1106e54:	2a0003f5 	mov	w21, w0
	thread_lock_global();
 1106e58:	97fff832 	bl	1104f20 <thread_lock_global>
		if (threads[n].state != THREAD_STATE_FREE) {
 1106e5c:	900002a1 	adrp	x1, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1106e60:	f9417821 	ldr	x1, [x1, #752]
 1106e64:	b9411820 	ldr	w0, [x1, #280]
 1106e68:	35000420 	cbnz	w0, 1106eec <thread_disable_prealloc_rpc_cache+0xb4>
 1106e6c:	b9481820 	ldr	w0, [x1, #2072]
 1106e70:	350003e0 	cbnz	w0, 1106eec <thread_disable_prealloc_rpc_cache+0xb4>
		if (threads[n].rpc_arg) {
 1106e74:	f942c820 	ldr	x0, [x1, #1424]
 1106e78:	b50001e0 	cbnz	x0, 1106eb4 <thread_disable_prealloc_rpc_cache+0x7c>
 1106e7c:	f9464820 	ldr	x0, [x1, #3216]
 1106e80:	b5000320 	cbnz	x0, 1106ee4 <thread_disable_prealloc_rpc_cache+0xac>
	thread_prealloc_rpc_cache = false;
 1106e84:	d0000300 	adrp	x0, 1168000 <data.5093+0x9e28>
	*cookie = 0;
 1106e88:	f900029f 	str	xzr, [x20]
	thread_prealloc_rpc_cache = false;
 1106e8c:	392a401f 	strb	wzr, [x0, #2704]
	rv = true;
 1106e90:	52800033 	mov	w19, #0x1                   	// #1
	thread_unlock_global();
 1106e94:	97fff87e 	bl	110508c <thread_unlock_global>
	thread_unmask_exceptions(exceptions);
 1106e98:	2a1503e0 	mov	w0, w21
 1106e9c:	97fff8b4 	bl	110516c <thread_unmask_exceptions>
}
 1106ea0:	2a1303e0 	mov	w0, w19
 1106ea4:	a94153f3 	ldp	x19, x20, [sp, #16]
 1106ea8:	f94013f5 	ldr	x21, [sp, #32]
 1106eac:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1106eb0:	d65f03c0 	ret
	for (n = 0; n < CFG_NUM_THREADS; n++) {
 1106eb4:	d2800013 	mov	x19, #0x0                   	// #0
			*cookie = mobj_get_cookie(threads[n].rpc_mobj);
 1106eb8:	900002a1 	adrp	x1, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1106ebc:	d280e000 	mov	x0, #0x700                 	// #1792
 1106ec0:	f9417821 	ldr	x1, [x1, #752]
 1106ec4:	9b000673 	madd	x19, x19, x0, x1
 1106ec8:	f942ce60 	ldr	x0, [x19, #1432]
 1106ecc:	97fffdc0 	bl	11065cc <mobj_get_cookie>
 1106ed0:	f9000280 	str	x0, [x20]
			mobj_put(threads[n].rpc_mobj);
 1106ed4:	f942ce60 	ldr	x0, [x19, #1432]
 1106ed8:	97fffde6 	bl	1106670 <mobj_put>
			threads[n].rpc_arg = NULL;
 1106edc:	f902ca7f 	str	xzr, [x19, #1424]
 1106ee0:	17ffffec 	b	1106e90 <thread_disable_prealloc_rpc_cache+0x58>
	for (n = 0; n < CFG_NUM_THREADS; n++) {
 1106ee4:	d2800033 	mov	x19, #0x1                   	// #1
 1106ee8:	17fffff4 	b	1106eb8 <thread_disable_prealloc_rpc_cache+0x80>
			rv = false;
 1106eec:	52800013 	mov	w19, #0x0                   	// #0
 1106ef0:	17ffffe9 	b	1106e94 <thread_disable_prealloc_rpc_cache+0x5c>

0000000001106ef4 <thread_enable_prealloc_rpc_cache>:
{
 1106ef4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	uint32_t exceptions = thread_mask_exceptions(THREAD_EXCP_FOREIGN_INTR);
 1106ef8:	52800040 	mov	w0, #0x2                   	// #2
{
 1106efc:	910003fd 	mov	x29, sp
 1106f00:	a90153f3 	stp	x19, x20, [sp, #16]
	uint32_t exceptions = thread_mask_exceptions(THREAD_EXCP_FOREIGN_INTR);
 1106f04:	97fff88d 	bl	1105138 <thread_mask_exceptions>
 1106f08:	2a0003f4 	mov	w20, w0
	thread_lock_global();
 1106f0c:	97fff805 	bl	1104f20 <thread_lock_global>
		if (threads[n].state != THREAD_STATE_FREE) {
 1106f10:	900002a1 	adrp	x1, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1106f14:	f9417821 	ldr	x1, [x1, #752]
 1106f18:	b9411820 	ldr	w0, [x1, #280]
 1106f1c:	350001c0 	cbnz	w0, 1106f54 <thread_enable_prealloc_rpc_cache+0x60>
 1106f20:	b9481820 	ldr	w0, [x1, #2072]
 1106f24:	35000180 	cbnz	w0, 1106f54 <thread_enable_prealloc_rpc_cache+0x60>
	thread_prealloc_rpc_cache = true;
 1106f28:	d0000300 	adrp	x0, 1168000 <data.5093+0x9e28>
 1106f2c:	52800021 	mov	w1, #0x1                   	// #1
	rv = true;
 1106f30:	52800033 	mov	w19, #0x1                   	// #1
	thread_prealloc_rpc_cache = true;
 1106f34:	392a4001 	strb	w1, [x0, #2704]
	thread_unlock_global();
 1106f38:	97fff855 	bl	110508c <thread_unlock_global>
	thread_unmask_exceptions(exceptions);
 1106f3c:	2a1403e0 	mov	w0, w20
 1106f40:	97fff88b 	bl	110516c <thread_unmask_exceptions>
}
 1106f44:	2a1303e0 	mov	w0, w19
 1106f48:	a94153f3 	ldp	x19, x20, [sp, #16]
 1106f4c:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1106f50:	d65f03c0 	ret
			rv = false;
 1106f54:	52800013 	mov	w19, #0x0                   	// #0
 1106f58:	17fffff8 	b	1106f38 <thread_enable_prealloc_rpc_cache+0x44>

0000000001106f5c <thread_rpc_cmd>:
{
 1106f5c:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 1106f60:	910003fd 	mov	x29, sp
 1106f64:	f90013f5 	str	x21, [sp, #32]
 1106f68:	2a0003f5 	mov	w21, w0
	uint32_t rpc_args[THREAD_RPC_NUM_ARGS] = { OPTEE_SMC_RETURN_RPC_CMD };
 1106f6c:	129fff40 	mov	w0, #0xffff0005            	// #-65531
 1106f70:	a9047fff 	stp	xzr, xzr, [sp, #64]
{
 1106f74:	a90153f3 	stp	x19, x20, [sp, #16]
 1106f78:	aa0103f4 	mov	x20, x1
 1106f7c:	aa0203f3 	mov	x19, x2
	plat_prng_add_jitter_entropy(CRYPTO_RNG_SRC_JITTER_RPC,
 1106f80:	d0000301 	adrp	x1, 1168000 <data.5093+0x9e28>
 1106f84:	91289021 	add	x1, x1, #0xa24
	uint64_t carg = 0;
 1106f88:	a9037fff 	stp	xzr, xzr, [sp, #48]
	uint32_t rpc_args[THREAD_RPC_NUM_ARGS] = { OPTEE_SMC_RETURN_RPC_CMD };
 1106f8c:	b90043e0 	str	w0, [sp, #64]
	plat_prng_add_jitter_entropy(CRYPTO_RNG_SRC_JITTER_RPC,
 1106f90:	52800060 	mov	w0, #0x3                   	// #3
 1106f94:	97fff4fc 	bl	1104384 <plat_prng_add_jitter_entropy>
	ret = get_rpc_arg(cmd, num_params, params, &arg, &carg);
 1106f98:	9100e3e4 	add	x4, sp, #0x38
 1106f9c:	9100c3e3 	add	x3, sp, #0x30
 1106fa0:	aa1303e2 	mov	x2, x19
 1106fa4:	aa1403e1 	mov	x1, x20
 1106fa8:	2a1503e0 	mov	w0, w21
 1106fac:	97fffddc 	bl	110671c <get_rpc_arg>
	if (ret)
 1106fb0:	350001a0 	cbnz	w0, 1106fe4 <thread_rpc_cmd+0x88>
	reg_pair_from_64(carg, rpc_args + 1, rpc_args + 2);
 1106fb4:	f9401fe0 	ldr	x0, [sp, #56]
	*reg0 = val >> 32;
 1106fb8:	d360fc01 	lsr	x1, x0, #32
	*reg1 = val;
 1106fbc:	290883e1 	stp	w1, w0, [sp, #68]
	thread_rpc(rpc_args);
 1106fc0:	910103e0 	add	x0, sp, #0x40
 1106fc4:	9400004d 	bl	11070f8 <thread_rpc>
	return get_rpc_arg_res(arg, num_params, params);
 1106fc8:	f9401be4 	ldr	x4, [sp, #48]
	for (size_t n = 0; n < num_params; n++) {
 1106fcc:	aa1303e2 	mov	x2, x19
 1106fd0:	d2800001 	mov	x1, #0x0                   	// #0
 1106fd4:	9100a080 	add	x0, x4, #0x28
 1106fd8:	eb01029f 	cmp	x20, x1
 1106fdc:	540000c1 	b.ne	1106ff4 <thread_rpc_cmd+0x98>  // b.any
	return arg->ret;
 1106fe0:	b9401480 	ldr	w0, [x4, #20]
}
 1106fe4:	a94153f3 	ldp	x19, x20, [sp, #16]
 1106fe8:	f94013f5 	ldr	x21, [sp, #32]
 1106fec:	a8c57bfd 	ldp	x29, x30, [sp], #80
 1106ff0:	d65f03c0 	ret
		switch (params[n].attr) {
 1106ff4:	b9400043 	ldr	w3, [x2]
 1106ff8:	71000c7f 	cmp	w3, #0x3
 1106ffc:	54000148 	b.hi	1107024 <thread_rpc_cmd+0xc8>  // b.pmore
 1107000:	7100047f 	cmp	w3, #0x1
 1107004:	54000169 	b.ls	1107030 <thread_rpc_cmd+0xd4>  // b.plast
			params[n].u.value.a = arg->params[n].u.value.a;
 1107008:	f9400003 	ldr	x3, [x0]
 110700c:	f9000443 	str	x3, [x2, #8]
			params[n].u.value.b = arg->params[n].u.value.b;
 1107010:	f9400403 	ldr	x3, [x0, #8]
 1107014:	f9000843 	str	x3, [x2, #16]
			params[n].u.value.c = arg->params[n].u.value.c;
 1107018:	f9400803 	ldr	x3, [x0, #16]
 110701c:	f9000c43 	str	x3, [x2, #24]
			break;
 1107020:	14000004 	b	1107030 <thread_rpc_cmd+0xd4>
		switch (params[n].attr) {
 1107024:	51001463 	sub	w3, w3, #0x5
 1107028:	7100047f 	cmp	w3, #0x1
 110702c:	540000a9 	b.ls	1107040 <thread_rpc_cmd+0xe4>  // b.plast
	for (size_t n = 0; n < num_params; n++) {
 1107030:	91000421 	add	x1, x1, #0x1
 1107034:	91008000 	add	x0, x0, #0x20
 1107038:	91008042 	add	x2, x2, #0x20
 110703c:	17ffffe7 	b	1106fd8 <thread_rpc_cmd+0x7c>
			params[n].u.memref.size = arg->params[n].u.rmem.size;
 1107040:	f9400403 	ldr	x3, [x0, #8]
 1107044:	f9000843 	str	x3, [x2, #16]
			break;
 1107048:	17fffffa 	b	1107030 <thread_rpc_cmd+0xd4>

000000000110704c <thread_rpc_alloc_payload>:

struct mobj *thread_rpc_alloc_payload(size_t size)
{
	return thread_rpc_alloc(size, 8, OPTEE_RPC_SHM_TYPE_APPL);
 110704c:	52800001 	mov	w1, #0x0                   	// #0
 1107050:	17fffe73 	b	1106a1c <thread_rpc_alloc.constprop.0>

0000000001107054 <thread_rpc_alloc_kernel_payload>:
	/*
	 * Error out early since kernel private dynamic shared memory
	 * allocations don't currently use the `OPTEE_MSG_ATTR_NONCONTIG` bit
	 * and therefore cannot be larger than a page.
	 */
	if (IS_ENABLED(CFG_CORE_DYN_SHM) && size > SMALL_PAGE_SIZE)
 1107054:	f140041f 	cmp	x0, #0x1, lsl #12
 1107058:	54000068 	b.hi	1107064 <thread_rpc_alloc_kernel_payload+0x10>  // b.pmore
		return NULL;

	return thread_rpc_alloc(size, 8, OPTEE_RPC_SHM_TYPE_KERNEL);
 110705c:	52800021 	mov	w1, #0x1                   	// #1
 1107060:	17fffe6f 	b	1106a1c <thread_rpc_alloc.constprop.0>
}
 1107064:	d2800000 	mov	x0, #0x0                   	// #0
 1107068:	d65f03c0 	ret

000000000110706c <thread_rpc_free_kernel_payload>:

void thread_rpc_free_kernel_payload(struct mobj *mobj)
{
 110706c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1107070:	910003fd 	mov	x29, sp
 1107074:	f9000bf3 	str	x19, [sp, #16]
 1107078:	aa0003f3 	mov	x19, x0
	thread_rpc_free(OPTEE_RPC_SHM_TYPE_KERNEL, mobj_get_cookie(mobj), mobj);
 110707c:	97fffd54 	bl	11065cc <mobj_get_cookie>
 1107080:	aa0003e1 	mov	x1, x0
 1107084:	aa1303e2 	mov	x2, x19
 1107088:	52800020 	mov	w0, #0x1                   	// #1
}
 110708c:	f9400bf3 	ldr	x19, [sp, #16]
 1107090:	a8c27bfd 	ldp	x29, x30, [sp], #32
	thread_rpc_free(OPTEE_RPC_SHM_TYPE_KERNEL, mobj_get_cookie(mobj), mobj);
 1107094:	17fffe43 	b	11069a0 <thread_rpc_free>

0000000001107098 <thread_rpc_free_payload>:

void thread_rpc_free_payload(struct mobj *mobj)
{
 1107098:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 110709c:	910003fd 	mov	x29, sp
 11070a0:	f9000bf3 	str	x19, [sp, #16]
 11070a4:	aa0003f3 	mov	x19, x0
	thread_rpc_free(OPTEE_RPC_SHM_TYPE_APPL, mobj_get_cookie(mobj),
 11070a8:	97fffd49 	bl	11065cc <mobj_get_cookie>
 11070ac:	aa0003e1 	mov	x1, x0
 11070b0:	aa1303e2 	mov	x2, x19
 11070b4:	52800000 	mov	w0, #0x0                   	// #0
			mobj);
}
 11070b8:	f9400bf3 	ldr	x19, [sp, #16]
 11070bc:	a8c27bfd 	ldp	x29, x30, [sp], #32
	thread_rpc_free(OPTEE_RPC_SHM_TYPE_APPL, mobj_get_cookie(mobj),
 11070c0:	17fffe38 	b	11069a0 <thread_rpc_free>

00000000011070c4 <thread_rpc_alloc_global_payload>:

struct mobj *thread_rpc_alloc_global_payload(size_t size)
{
	return thread_rpc_alloc(size, 8, OPTEE_RPC_SHM_TYPE_GLOBAL);
 11070c4:	52800041 	mov	w1, #0x2                   	// #2
 11070c8:	17fffe55 	b	1106a1c <thread_rpc_alloc.constprop.0>

00000000011070cc <thread_rpc_free_global_payload>:
}

void thread_rpc_free_global_payload(struct mobj *mobj)
{
 11070cc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 11070d0:	910003fd 	mov	x29, sp
 11070d4:	f9000bf3 	str	x19, [sp, #16]
 11070d8:	aa0003f3 	mov	x19, x0
	thread_rpc_free(OPTEE_RPC_SHM_TYPE_GLOBAL, mobj_get_cookie(mobj),
 11070dc:	97fffd3c 	bl	11065cc <mobj_get_cookie>
 11070e0:	aa0003e1 	mov	x1, x0
 11070e4:	aa1303e2 	mov	x2, x19
 11070e8:	52800040 	mov	w0, #0x2                   	// #2
			mobj);
}
 11070ec:	f9400bf3 	ldr	x19, [sp, #16]
 11070f0:	a8c27bfd 	ldp	x29, x30, [sp], #32
	thread_rpc_free(OPTEE_RPC_SHM_TYPE_GLOBAL, mobj_get_cookie(mobj),
 11070f4:	17fffe2b 	b	11069a0 <thread_rpc_free>

00000000011070f8 <thread_rpc>:
END_FUNC thread_std_smc_entry

/* void thread_rpc(uint32_t rv[THREAD_RPC_NUM_ARGS]) */
FUNC thread_rpc , :
	/* Read daif and create an SPSR */
	mrs	x1, daif
 11070f8:	d53b4221 	mrs	x1, daif
	orr	x1, x1, #(SPSR_64_MODE_EL1 << SPSR_64_MODE_EL_SHIFT)
 11070fc:	b27e0021 	orr	x1, x1, #0x4

	/* Mask all maskable exceptions before switching to temporary stack */
	msr	daifset, #DAIFBIT_ALL
 1107100:	d5034fdf 	msr	daifset, #0xf
	push	x0, xzr
 1107104:	a9bf7fe0 	stp	x0, xzr, [sp, #-16]!
	push	x1, x30
 1107108:	a9bf7be1 	stp	x1, x30, [sp, #-16]!
	bl	thread_get_ctx_regs
 110710c:	97fffab9 	bl	1105bf0 <thread_get_ctx_regs>
	ldr	x30, [sp, #8]
 1107110:	f94007fe 	ldr	x30, [sp, #8]
	store_xregs x0, THREAD_CTX_REGS_X19, 19, 30
 1107114:	a90b5013 	stp	x19, x20, [x0, #176]
 1107118:	a90c5815 	stp	x21, x22, [x0, #192]
 110711c:	a90d6017 	stp	x23, x24, [x0, #208]
 1107120:	a90e6819 	stp	x25, x26, [x0, #224]
 1107124:	a90f701b 	stp	x27, x28, [x0, #240]
 1107128:	a910781d 	stp	x29, x30, [x0, #256]
	mov	x19, x0
 110712c:	aa0003f3 	mov	x19, x0

	bl	thread_get_tmp_sp
 1107130:	97fff83a 	bl	1105218 <thread_get_tmp_sp>
	pop	x1, xzr		/* Match "push x1, x30" above */
 1107134:	a8c17fe1 	ldp	x1, xzr, [sp], #16
	mov	x2, sp
 1107138:	910003e2 	mov	x2, sp
	str	x2, [x19, #THREAD_CTX_REGS_SP]
 110713c:	f9000262 	str	x2, [x19]
	ldr	x20, [sp]	/* Get pointer to rv[] */
 1107140:	f94003f4 	ldr	x20, [sp]
	mov	sp, x0		/* Switch to tmp stack */
 1107144:	9100001f 	mov	sp, x0
	/*
	 * We need to read rv[] early, because thread_state_suspend
	 * can invoke virt_unset_guest() which will unmap pages,
	 * where rv[] resides
	 */
	load_wregs x20, 0, 21, 23	/* Load rv[] into w20-w22 */
 1107148:	29405a95 	ldp	w21, w22, [x20]
 110714c:	b9400a97 	ldr	w23, [x20, #8]

	adr	x2, .thread_rpc_return
 1107150:	10000142 	adr	x2, 1107178 <.thread_rpc_return>
	mov	w0, #THREAD_FLAGS_COPY_ARGS_ON_RETURN
 1107154:	52800020 	mov	w0, #0x1                   	// #1
	bl	thread_state_suspend
 1107158:	97fffbb2 	bl	1106020 <thread_state_suspend>
	mov	x4, x0		/* Supply thread index */
 110715c:	aa0003e4 	mov	x4, x0
	ldr	w0, =TEESMC_OPTEED_RETURN_CALL_DONE
 1107160:	18000140 	ldr	w0, 1107188 <.thread_rpc_return+0x10>
	mov	x1, x21
 1107164:	aa1503e1 	mov	x1, x21
	mov	x2, x22
 1107168:	aa1603e2 	mov	x2, x22
	mov	x3, x23
 110716c:	aa1703e3 	mov	x3, x23
	smc	#0
 1107170:	d4000003 	smc	#0x0
	b	.		/* SMC should not return */
 1107174:	14000000 	b	1107174 <thread_rpc+0x7c>

0000000001107178 <.thread_rpc_return>:
	 *
	 * Jumps here from thread_resume above when RPC has returned. The
	 * IRQ and FIQ bits are restored to what they where when this
	 * function was originally entered.
	 */
	pop	x16, xzr	/* Get pointer to rv[] */
 1107178:	a8c17ff0 	ldp	x16, xzr, [sp], #16
	store_wregs x16, 0, 0, 3	/* Store w0-w3 into rv[] */
 110717c:	29000600 	stp	w0, w1, [x16]
 1107180:	29010e02 	stp	w2, w3, [x16, #8]
	ret
 1107184:	d65f03c0 	ret
 1107188:	be000005 	.word	0xbe000005

000000000110718c <thread_foreign_intr_exit>:
 * The current thread as indicated by @thread_index has just been
 * suspended.  The job here is just to inform normal world the thread id to
 * resume when returning.
 */
FUNC thread_foreign_intr_exit , :
	mov	w4, w0
 110718c:	2a0003e4 	mov	w4, w0
	ldr	w0, =TEESMC_OPTEED_RETURN_CALL_DONE
 1107190:	180000c0 	ldr	w0, 11071a8 <thread_foreign_intr_exit+0x1c>
	ldr	w1, =OPTEE_SMC_RETURN_RPC_FOREIGN_INTR
 1107194:	180000c1 	ldr	w1, 11071ac <thread_foreign_intr_exit+0x20>
	mov	w2, #0
 1107198:	52800002 	mov	w2, #0x0                   	// #0
	mov	w3, #0
 110719c:	52800003 	mov	w3, #0x0                   	// #0
	smc	#0
 11071a0:	d4000003 	smc	#0x0
	b	.	/* SMC should not return */
 11071a4:	14000000 	b	11071a4 <thread_foreign_intr_exit+0x18>
 11071a8:	be000005 	.word	0xbe000005
 11071ac:	ffff0004 	.word	0xffff0004

00000000011071b0 <get_core_pos>:
{
 11071b0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 11071b4:	910003fd 	mov	x29, sp
	assert(thread_get_exceptions() & THREAD_EXCP_FOREIGN_INTR);
 11071b8:	97fff757 	bl	1104f14 <thread_get_exceptions>
 11071bc:	37080140 	tbnz	w0, #1, 11071e4 <get_core_pos+0x34>
 11071c0:	d0000243 	adrp	x3, 1151000 <small_prime+0x168>
 11071c4:	d0000241 	adrp	x1, 1151000 <small_prime+0x168>
 11071c8:	913c3c63 	add	x3, x3, #0xf0f
 11071cc:	9113b021 	add	x1, x1, #0x4ec
 11071d0:	d0000240 	adrp	x0, 1151000 <small_prime+0x168>
 11071d4:	91144000 	add	x0, x0, #0x510
 11071d8:	528002c2 	mov	w2, #0x16                  	// #22
 11071dc:	94002c34 	bl	11122ac <_assert_log>
 11071e0:	94002c44 	bl	11122f0 <_assert_break>
}
 11071e4:	a8c17bfd 	ldp	x29, x30, [sp], #16
	return __get_core_pos();
 11071e8:	17ffe9db 	b	1101954 <__get_core_pos>

00000000011071ec <save_abort_info_in_tsd>:
	}
#endif
}

static void save_abort_info_in_tsd(struct abort_info *ai)
{
 11071ec:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 11071f0:	910003fd 	mov	x29, sp
 11071f4:	a90153f3 	stp	x19, x20, [sp, #16]
 11071f8:	aa0003f4 	mov	x20, x0
	struct thread_specific_data *tsd = thread_get_tsd();
 11071fc:	97fffa71 	bl	1105bc0 <thread_get_tsd>
 1107200:	aa0003f3 	mov	x19, x0

	tsd->abort_type = ai->abort_type;
	tsd->abort_descr = ai->fault_descr;
	tsd->abort_va = ai->va;
	tsd->abort_regs = *ai->regs;
 1107204:	d2802202 	mov	x2, #0x110                 	// #272
	tsd->abort_type = ai->abort_type;
 1107208:	b9400280 	ldr	w0, [x20]
	tsd->abort_regs = *ai->regs;
 110720c:	f9400e81 	ldr	x1, [x20, #24]
	tsd->abort_type = ai->abort_type;
 1107210:	b9002260 	str	w0, [x19, #32]
	tsd->abort_descr = ai->fault_descr;
 1107214:	b9400680 	ldr	w0, [x20, #4]
 1107218:	b9002660 	str	w0, [x19, #36]
	tsd->abort_va = ai->va;
 110721c:	f9400680 	ldr	x0, [x20, #8]
 1107220:	f9001660 	str	x0, [x19, #40]
	tsd->abort_regs = *ai->regs;
 1107224:	9100e260 	add	x0, x19, #0x38
 1107228:	97fff05a 	bl	1103390 <memcpy>
	tsd->abort_core = get_core_pos();
 110722c:	97ffffe1 	bl	11071b0 <get_core_pos>
 1107230:	b9003260 	str	w0, [x19, #48]
}
 1107234:	a94153f3 	ldp	x19, x20, [sp, #16]
 1107238:	a8c27bfd 	ldp	x29, x30, [sp], #32
 110723c:	d65f03c0 	ret

0000000001107240 <handle_user_mode_panic.isra.0>:
		ai->regs->spsr &= ~CPSR_T;
}
#endif /*ARM32*/

#ifdef ARM64
static void handle_user_mode_panic(struct abort_info *ai)
 1107240:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1107244:	910003fd 	mov	x29, sp
 1107248:	a90153f3 	stp	x19, x20, [sp, #16]
 110724c:	aa0003f4 	mov	x20, x0

	/*
	 * It was a user exception, stop user execution and return
	 * to TEE Core.
	 */
	ai->regs->x0 = TEE_ERROR_TARGET_DEAD;
 1107250:	1299fb60 	mov	w0, #0xffff3024            	// #-53212
 1107254:	f9400293 	ldr	x19, [x20]
 1107258:	f9000260 	str	x0, [x19]
	ai->regs->x1 = true;
 110725c:	d2800020 	mov	x0, #0x1                   	// #1
 1107260:	f9000660 	str	x0, [x19, #8]
	ai->regs->x2 = 0xdeadbeef;
 1107264:	d297dde0 	mov	x0, #0xbeef                	// #48879
 1107268:	f2bbd5a0 	movk	x0, #0xdead, lsl #16
 110726c:	f9000a60 	str	x0, [x19, #16]
	ai->regs->elr = (vaddr_t)thread_unwind_user_mode;
 1107270:	f0000280 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1107274:	f941f800 	ldr	x0, [x0, #1008]
 1107278:	f9007e60 	str	x0, [x19, #248]
	ai->regs->sp_el0 = thread_get_saved_thread_sp();
 110727c:	97fff7f0 	bl	110523c <thread_get_saved_thread_sp>

	daif = (ai->regs->spsr >> SPSR_32_AIF_SHIFT) & SPSR_32_AIF_MASK;
 1107280:	f9400281 	ldr	x1, [x20]
	ai->regs->sp_el0 = thread_get_saved_thread_sp();
 1107284:	f9008660 	str	x0, [x19, #264]
	/* XXX what about DAIF_D? */
	ai->regs->spsr = SPSR_64(SPSR_64_MODE_EL1, SPSR_64_MODE_SP_EL0, daif);
}
 1107288:	a94153f3 	ldp	x19, x20, [sp, #16]
	daif = (ai->regs->spsr >> SPSR_32_AIF_SHIFT) & SPSR_32_AIF_MASK;
 110728c:	f9408020 	ldr	x0, [x1, #256]
	ai->regs->spsr = SPSR_64(SPSR_64_MODE_EL1, SPSR_64_MODE_SP_EL0, daif);
 1107290:	927a0800 	and	x0, x0, #0x1c0
 1107294:	b27e0000 	orr	x0, x0, #0x4
 1107298:	f9008020 	str	x0, [x1, #256]
}
 110729c:	a8c27bfd 	ldp	x29, x30, [sp], #32
 11072a0:	d65f03c0 	ret

00000000011072a4 <__abort_print.part.0>:
	assert(!abort_is_user_exception(ai));
 11072a4:	d0000243 	adrp	x3, 1151000 <small_prime+0x168>
 11072a8:	d0000241 	adrp	x1, 1151000 <small_prime+0x168>
 11072ac:	913cdc63 	add	x3, x3, #0xf37
 11072b0:	912b0021 	add	x1, x1, #0xac0
 11072b4:	d0000240 	adrp	x0, 1151000 <small_prime+0x168>
 11072b8:	912b7400 	add	x0, x0, #0xadd
static void __abort_print(struct abort_info *ai, bool stack_dump)
 11072bc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	assert(!abort_is_user_exception(ai));
 11072c0:	52801b22 	mov	w2, #0xd9                  	// #217
static void __abort_print(struct abort_info *ai, bool stack_dump)
 11072c4:	910003fd 	mov	x29, sp
	assert(!abort_is_user_exception(ai));
 11072c8:	94002bf9 	bl	11122ac <_assert_log>
 11072cc:	94002c09 	bl	11122f0 <_assert_break>

00000000011072d0 <abort_is_user_exception>:

#ifdef ARM64
/* Returns true if the exception originated from user mode */
bool abort_is_user_exception(struct abort_info *ai)
{
	uint32_t spsr = ai->regs->spsr;
 11072d0:	f9400c00 	ldr	x0, [x0, #24]
 11072d4:	f9408000 	ldr	x0, [x0, #256]

	if (spsr & (SPSR_MODE_RW_32 << SPSR_MODE_RW_SHIFT))
 11072d8:	37200080 	tbnz	w0, #4, 11072e8 <abort_is_user_exception+0x18>
		return true;
	if (((spsr >> SPSR_64_MODE_EL_SHIFT) & SPSR_64_MODE_EL_MASK) ==
 11072dc:	721e041f 	tst	w0, #0xc
 11072e0:	1a9f17e0 	cset	w0, eq  // eq = none
	    SPSR_64_MODE_EL0)
		return true;
	return false;
}
 11072e4:	d65f03c0 	ret
		return true;
 11072e8:	52800020 	mov	w0, #0x1                   	// #1
 11072ec:	17fffffe 	b	11072e4 <abort_is_user_exception+0x14>

00000000011072f0 <__print_abort_info>:
{
 11072f0:	d10143ff 	sub	sp, sp, #0x50
 11072f4:	a9017bfd 	stp	x29, x30, [sp, #16]
 11072f8:	910043fd 	add	x29, sp, #0x10
 11072fc:	a90253f3 	stp	x19, x20, [sp, #32]
 1107300:	aa0003f3 	mov	x19, x0
 1107304:	a9035bf5 	stp	x21, x22, [sp, #48]
 1107308:	aa0103f6 	mov	x22, x1
 110730c:	a90463f7 	stp	x23, x24, [sp, #64]
	if (abort_is_user_exception(ai))
 1107310:	97fffff0 	bl	11072d0 <abort_is_user_exception>
 1107314:	72001c1f 	tst	w0, #0xff
 1107318:	54000420 	b.eq	110739c <__print_abort_info+0xac>  // b.none
		core_pos = thread_get_tsd()->abort_core;
 110731c:	97fffa29 	bl	1105bc0 <thread_get_tsd>
 1107320:	b9403015 	ldr	w21, [x0, #48]
	EMSG_RAW("");
 1107324:	d2800000 	mov	x0, #0x0                   	// #0
 1107328:	f0000254 	adrp	x20, 1152000 <trace_ext_prefix+0x2e>
 110732c:	52800023 	mov	w3, #0x1                   	// #1
 1107330:	9104aa84 	add	x4, x20, #0x12a
 1107334:	52800022 	mov	w2, #0x1                   	// #1
 1107338:	52800001 	mov	w1, #0x0                   	// #0
 110733c:	9400f682 	bl	1144d44 <trace_printf>
	EMSG_RAW("%s %s-abort at address 0x%" PRIxVA "%s",
 1107340:	b9400260 	ldr	w0, [x19]
	if (abort_type == ABORT_TYPE_DATA)
 1107344:	7100081f 	cmp	w0, #0x2
 1107348:	54000300 	b.eq	11073a8 <__print_abort_info+0xb8>  // b.none
		return "prefetch";
 110734c:	7100041f 	cmp	w0, #0x1
 1107350:	d0000246 	adrp	x6, 1151000 <small_prime+0x168>
 1107354:	d0000257 	adrp	x23, 1151000 <small_prime+0x168>
 1107358:	912c00c6 	add	x6, x6, #0xb00
 110735c:	912beaf7 	add	x23, x23, #0xafa
 1107360:	9a8612f7 	csel	x23, x23, x6, ne  // ne = any
	if (abort_type != ABORT_TYPE_DATA && abort_type != ABORT_TYPE_PREFETCH)
 1107364:	51000400 	sub	w0, w0, #0x1
 1107368:	7100041f 	cmp	w0, #0x1
	EMSG_RAW("%s %s-abort at address 0x%" PRIxVA "%s",
 110736c:	f9400678 	ldr	x24, [x19, #8]
	if (abort_type != ABORT_TYPE_DATA && abort_type != ABORT_TYPE_PREFETCH)
 1107370:	54001b08 	b.hi	11076d0 <__print_abort_info+0x3e0>  // b.pmore
	switch (core_mmu_get_fault_type(fault_descr)) {
 1107374:	b9400660 	ldr	w0, [x19, #4]
 1107378:	9400101b 	bl	110b3e4 <core_mmu_get_fault_type>
 110737c:	7100101f 	cmp	w0, #0x4
 1107380:	54001a88 	b.hi	11076d0 <__print_abort_info+0x3e0>  // b.pmore
 1107384:	f0000221 	adrp	x1, 114e000 <ldelf_data+0x8000>
 1107388:	91164021 	add	x1, x1, #0x590
 110738c:	78605820 	ldrh	w0, [x1, w0, uxtw #1]
 1107390:	10000061 	adr	x1, 110739c <__print_abort_info+0xac>
 1107394:	8b20a820 	add	x0, x1, w0, sxth #2
 1107398:	d61f0000 	br	x0
		core_pos = get_core_pos();
 110739c:	97ffff85 	bl	11071b0 <get_core_pos>
 11073a0:	aa0003f5 	mov	x21, x0
 11073a4:	17ffffe0 	b	1107324 <__print_abort_info+0x34>
		return "data";
 11073a8:	d0000277 	adrp	x23, 1155000 <__func__.3826+0xa8>
 11073ac:	913f0af7 	add	x23, x23, #0xfc2
 11073b0:	17ffffed 	b	1107364 <__print_abort_info+0x74>
	switch (core_mmu_get_fault_type(fault_descr)) {
 11073b4:	d0000242 	adrp	x2, 1151000 <small_prime+0x168>
 11073b8:	912d3c42 	add	x2, x2, #0xb4f
	EMSG_RAW("%s %s-abort at address 0x%" PRIxVA "%s",
 11073bc:	f90003e2 	str	x2, [sp]
 11073c0:	aa1803e7 	mov	x7, x24
 11073c4:	aa1703e6 	mov	x6, x23
 11073c8:	aa1603e5 	mov	x5, x22
 11073cc:	52800023 	mov	w3, #0x1                   	// #1
 11073d0:	52800001 	mov	w1, #0x0                   	// #0
 11073d4:	d2800000 	mov	x0, #0x0                   	// #0
 11073d8:	52800022 	mov	w2, #0x1                   	// #1
 11073dc:	d0000244 	adrp	x4, 1151000 <small_prime+0x168>
 11073e0:	912d9084 	add	x4, x4, #0xb64
 11073e4:	9400f658 	bl	1144d44 <trace_printf>
DEFINE_U64_REG_READWRITE_FUNCS(ttbr0_el1)
 11073e8:	d5382006 	mrs	x6, ttbr0_el1
DEFINE_U64_REG_READWRITE_FUNCS(ttbr1_el1)
 11073ec:	d5382027 	mrs	x7, ttbr1_el1
DEFINE_U32_REG_READ_FUNC(contextidr_el1)
 11073f0:	d538d020 	mrs	x0, contextidr_el1
	EMSG_RAW(" esr 0x%08x  ttbr0 0x%08" PRIx64 "   ttbr1 0x%08" PRIx64
 11073f4:	b9400665 	ldr	w5, [x19, #4]
 11073f8:	52800023 	mov	w3, #0x1                   	// #1
 11073fc:	b90003e0 	str	w0, [sp]
 1107400:	52800022 	mov	w2, #0x1                   	// #1
 1107404:	52800001 	mov	w1, #0x0                   	// #0
 1107408:	d2800000 	mov	x0, #0x0                   	// #0
 110740c:	d0000244 	adrp	x4, 1151000 <small_prime+0x168>
 1107410:	912e0c84 	add	x4, x4, #0xb83
 1107414:	9400f64c 	bl	1144d44 <trace_printf>
	EMSG_RAW(" cpu #%zu          cpsr 0x%08x",
 1107418:	f9400e60 	ldr	x0, [x19, #24]
 110741c:	aa1503e5 	mov	x5, x21
 1107420:	52800023 	mov	w3, #0x1                   	// #1
 1107424:	52800022 	mov	w2, #0x1                   	// #1
 1107428:	52800001 	mov	w1, #0x0                   	// #0
 110742c:	d0000244 	adrp	x4, 1151000 <small_prime+0x168>
 1107430:	b9410006 	ldr	w6, [x0, #256]
 1107434:	912ee884 	add	x4, x4, #0xbba
 1107438:	d2800000 	mov	x0, #0x0                   	// #0
 110743c:	9400f642 	bl	1144d44 <trace_printf>
	EMSG_RAW(" x0  %016" PRIx64 " x1  %016" PRIx64,
 1107440:	f9400e60 	ldr	x0, [x19, #24]
 1107444:	52800023 	mov	w3, #0x1                   	// #1
 1107448:	52800022 	mov	w2, #0x1                   	// #1
 110744c:	52800001 	mov	w1, #0x0                   	// #0
 1107450:	d0000244 	adrp	x4, 1151000 <small_prime+0x168>
 1107454:	912f6484 	add	x4, x4, #0xbd9
 1107458:	a9401805 	ldp	x5, x6, [x0]
 110745c:	d2800000 	mov	x0, #0x0                   	// #0
 1107460:	9400f639 	bl	1144d44 <trace_printf>
	EMSG_RAW(" x2  %016" PRIx64 " x3  %016" PRIx64,
 1107464:	f9400e60 	ldr	x0, [x19, #24]
 1107468:	52800023 	mov	w3, #0x1                   	// #1
 110746c:	52800022 	mov	w2, #0x1                   	// #1
 1107470:	52800001 	mov	w1, #0x0                   	// #0
 1107474:	d0000244 	adrp	x4, 1151000 <small_prime+0x168>
 1107478:	912fc084 	add	x4, x4, #0xbf0
 110747c:	a9411805 	ldp	x5, x6, [x0, #16]
 1107480:	d2800000 	mov	x0, #0x0                   	// #0
 1107484:	9400f630 	bl	1144d44 <trace_printf>
	EMSG_RAW(" x4  %016" PRIx64 " x5  %016" PRIx64,
 1107488:	f9400e60 	ldr	x0, [x19, #24]
 110748c:	52800023 	mov	w3, #0x1                   	// #1
 1107490:	52800022 	mov	w2, #0x1                   	// #1
 1107494:	52800001 	mov	w1, #0x0                   	// #0
 1107498:	d0000244 	adrp	x4, 1151000 <small_prime+0x168>
 110749c:	91301c84 	add	x4, x4, #0xc07
 11074a0:	a9421805 	ldp	x5, x6, [x0, #32]
 11074a4:	d2800000 	mov	x0, #0x0                   	// #0
 11074a8:	9400f627 	bl	1144d44 <trace_printf>
	EMSG_RAW(" x6  %016" PRIx64 " x7  %016" PRIx64,
 11074ac:	f9400e60 	ldr	x0, [x19, #24]
 11074b0:	52800023 	mov	w3, #0x1                   	// #1
 11074b4:	52800022 	mov	w2, #0x1                   	// #1
 11074b8:	52800001 	mov	w1, #0x0                   	// #0
 11074bc:	d0000244 	adrp	x4, 1151000 <small_prime+0x168>
 11074c0:	91307884 	add	x4, x4, #0xc1e
 11074c4:	a9431805 	ldp	x5, x6, [x0, #48]
 11074c8:	d2800000 	mov	x0, #0x0                   	// #0
 11074cc:	9400f61e 	bl	1144d44 <trace_printf>
	EMSG_RAW(" x8  %016" PRIx64 " x9  %016" PRIx64,
 11074d0:	f9400e60 	ldr	x0, [x19, #24]
 11074d4:	52800023 	mov	w3, #0x1                   	// #1
 11074d8:	52800022 	mov	w2, #0x1                   	// #1
 11074dc:	52800001 	mov	w1, #0x0                   	// #0
 11074e0:	d0000244 	adrp	x4, 1151000 <small_prime+0x168>
 11074e4:	9130d484 	add	x4, x4, #0xc35
 11074e8:	a9441805 	ldp	x5, x6, [x0, #64]
 11074ec:	d2800000 	mov	x0, #0x0                   	// #0
 11074f0:	9400f615 	bl	1144d44 <trace_printf>
	EMSG_RAW(" x10 %016" PRIx64 " x11 %016" PRIx64,
 11074f4:	f9400e60 	ldr	x0, [x19, #24]
 11074f8:	52800023 	mov	w3, #0x1                   	// #1
 11074fc:	52800022 	mov	w2, #0x1                   	// #1
 1107500:	52800001 	mov	w1, #0x0                   	// #0
 1107504:	d0000244 	adrp	x4, 1151000 <small_prime+0x168>
 1107508:	91313084 	add	x4, x4, #0xc4c
 110750c:	a9451805 	ldp	x5, x6, [x0, #80]
 1107510:	d2800000 	mov	x0, #0x0                   	// #0
 1107514:	9400f60c 	bl	1144d44 <trace_printf>
	EMSG_RAW(" x12 %016" PRIx64 " x13 %016" PRIx64,
 1107518:	f9400e60 	ldr	x0, [x19, #24]
 110751c:	52800023 	mov	w3, #0x1                   	// #1
 1107520:	52800022 	mov	w2, #0x1                   	// #1
 1107524:	52800001 	mov	w1, #0x0                   	// #0
 1107528:	d0000244 	adrp	x4, 1151000 <small_prime+0x168>
 110752c:	91318c84 	add	x4, x4, #0xc63
 1107530:	a9461805 	ldp	x5, x6, [x0, #96]
 1107534:	d2800000 	mov	x0, #0x0                   	// #0
 1107538:	9400f603 	bl	1144d44 <trace_printf>
	EMSG_RAW(" x14 %016" PRIx64 " x15 %016" PRIx64,
 110753c:	f9400e60 	ldr	x0, [x19, #24]
 1107540:	52800023 	mov	w3, #0x1                   	// #1
 1107544:	52800022 	mov	w2, #0x1                   	// #1
 1107548:	52800001 	mov	w1, #0x0                   	// #0
 110754c:	d0000244 	adrp	x4, 1151000 <small_prime+0x168>
 1107550:	9131e884 	add	x4, x4, #0xc7a
 1107554:	a9471805 	ldp	x5, x6, [x0, #112]
 1107558:	d2800000 	mov	x0, #0x0                   	// #0
 110755c:	9400f5fa 	bl	1144d44 <trace_printf>
	EMSG_RAW(" x16 %016" PRIx64 " x17 %016" PRIx64,
 1107560:	f9400e60 	ldr	x0, [x19, #24]
 1107564:	52800023 	mov	w3, #0x1                   	// #1
 1107568:	52800022 	mov	w2, #0x1                   	// #1
 110756c:	52800001 	mov	w1, #0x0                   	// #0
 1107570:	d0000244 	adrp	x4, 1151000 <small_prime+0x168>
 1107574:	91324484 	add	x4, x4, #0xc91
 1107578:	a9481805 	ldp	x5, x6, [x0, #128]
 110757c:	d2800000 	mov	x0, #0x0                   	// #0
 1107580:	9400f5f1 	bl	1144d44 <trace_printf>
	EMSG_RAW(" x18 %016" PRIx64 " x19 %016" PRIx64,
 1107584:	f9400e60 	ldr	x0, [x19, #24]
 1107588:	52800023 	mov	w3, #0x1                   	// #1
 110758c:	52800022 	mov	w2, #0x1                   	// #1
 1107590:	52800001 	mov	w1, #0x0                   	// #0
 1107594:	d0000244 	adrp	x4, 1151000 <small_prime+0x168>
 1107598:	9132a084 	add	x4, x4, #0xca8
 110759c:	a9491805 	ldp	x5, x6, [x0, #144]
 11075a0:	d2800000 	mov	x0, #0x0                   	// #0
 11075a4:	9400f5e8 	bl	1144d44 <trace_printf>
	EMSG_RAW(" x20 %016" PRIx64 " x21 %016" PRIx64,
 11075a8:	f9400e60 	ldr	x0, [x19, #24]
 11075ac:	52800023 	mov	w3, #0x1                   	// #1
 11075b0:	52800022 	mov	w2, #0x1                   	// #1
 11075b4:	52800001 	mov	w1, #0x0                   	// #0
 11075b8:	d0000244 	adrp	x4, 1151000 <small_prime+0x168>
 11075bc:	9132fc84 	add	x4, x4, #0xcbf
 11075c0:	a94a1805 	ldp	x5, x6, [x0, #160]
 11075c4:	d2800000 	mov	x0, #0x0                   	// #0
 11075c8:	9400f5df 	bl	1144d44 <trace_printf>
	EMSG_RAW(" x22 %016" PRIx64 " x23 %016" PRIx64,
 11075cc:	f9400e60 	ldr	x0, [x19, #24]
 11075d0:	52800023 	mov	w3, #0x1                   	// #1
 11075d4:	52800022 	mov	w2, #0x1                   	// #1
 11075d8:	52800001 	mov	w1, #0x0                   	// #0
 11075dc:	d0000244 	adrp	x4, 1151000 <small_prime+0x168>
 11075e0:	91335884 	add	x4, x4, #0xcd6
 11075e4:	a94b1805 	ldp	x5, x6, [x0, #176]
 11075e8:	d2800000 	mov	x0, #0x0                   	// #0
 11075ec:	9400f5d6 	bl	1144d44 <trace_printf>
	EMSG_RAW(" x24 %016" PRIx64 " x25 %016" PRIx64,
 11075f0:	f9400e60 	ldr	x0, [x19, #24]
 11075f4:	52800023 	mov	w3, #0x1                   	// #1
 11075f8:	52800022 	mov	w2, #0x1                   	// #1
 11075fc:	52800001 	mov	w1, #0x0                   	// #0
 1107600:	d0000244 	adrp	x4, 1151000 <small_prime+0x168>
 1107604:	9133b484 	add	x4, x4, #0xced
 1107608:	a94c1805 	ldp	x5, x6, [x0, #192]
 110760c:	d2800000 	mov	x0, #0x0                   	// #0
 1107610:	9400f5cd 	bl	1144d44 <trace_printf>
	EMSG_RAW(" x26 %016" PRIx64 " x27 %016" PRIx64,
 1107614:	f9400e60 	ldr	x0, [x19, #24]
 1107618:	52800023 	mov	w3, #0x1                   	// #1
 110761c:	52800022 	mov	w2, #0x1                   	// #1
 1107620:	52800001 	mov	w1, #0x0                   	// #0
 1107624:	d0000244 	adrp	x4, 1151000 <small_prime+0x168>
 1107628:	91341084 	add	x4, x4, #0xd04
 110762c:	a94d1805 	ldp	x5, x6, [x0, #208]
 1107630:	d2800000 	mov	x0, #0x0                   	// #0
 1107634:	9400f5c4 	bl	1144d44 <trace_printf>
	EMSG_RAW(" x28 %016" PRIx64 " x29 %016" PRIx64,
 1107638:	f9400e60 	ldr	x0, [x19, #24]
 110763c:	52800023 	mov	w3, #0x1                   	// #1
 1107640:	52800022 	mov	w2, #0x1                   	// #1
 1107644:	52800001 	mov	w1, #0x0                   	// #0
 1107648:	d0000244 	adrp	x4, 1151000 <small_prime+0x168>
 110764c:	91346c84 	add	x4, x4, #0xd1b
 1107650:	a94e1805 	ldp	x5, x6, [x0, #224]
 1107654:	d2800000 	mov	x0, #0x0                   	// #0
 1107658:	9400f5bb 	bl	1144d44 <trace_printf>
	EMSG_RAW(" x30 %016" PRIx64 " elr %016" PRIx64,
 110765c:	f9400e60 	ldr	x0, [x19, #24]
 1107660:	52800023 	mov	w3, #0x1                   	// #1
 1107664:	52800022 	mov	w2, #0x1                   	// #1
 1107668:	52800001 	mov	w1, #0x0                   	// #0
 110766c:	d0000244 	adrp	x4, 1151000 <small_prime+0x168>
 1107670:	9134c884 	add	x4, x4, #0xd32
 1107674:	a94f1805 	ldp	x5, x6, [x0, #240]
 1107678:	d2800000 	mov	x0, #0x0                   	// #0
 110767c:	9400f5b2 	bl	1144d44 <trace_printf>
	EMSG_RAW(" sp_el0 %016" PRIx64, ai->regs->sp_el0);
 1107680:	f9400e60 	ldr	x0, [x19, #24]
 1107684:	d0000244 	adrp	x4, 1151000 <small_prime+0x168>
}
 1107688:	a9417bfd 	ldp	x29, x30, [sp, #16]
	EMSG_RAW(" sp_el0 %016" PRIx64, ai->regs->sp_el0);
 110768c:	91352484 	add	x4, x4, #0xd49
}
 1107690:	a94253f3 	ldp	x19, x20, [sp, #32]
	EMSG_RAW(" sp_el0 %016" PRIx64, ai->regs->sp_el0);
 1107694:	52800023 	mov	w3, #0x1                   	// #1
}
 1107698:	a9435bf5 	ldp	x21, x22, [sp, #48]
	EMSG_RAW(" sp_el0 %016" PRIx64, ai->regs->sp_el0);
 110769c:	52800022 	mov	w2, #0x1                   	// #1
}
 11076a0:	a94463f7 	ldp	x23, x24, [sp, #64]
	EMSG_RAW(" sp_el0 %016" PRIx64, ai->regs->sp_el0);
 11076a4:	52800001 	mov	w1, #0x0                   	// #0
 11076a8:	f9408405 	ldr	x5, [x0, #264]
}
 11076ac:	910143ff 	add	sp, sp, #0x50
	EMSG_RAW(" sp_el0 %016" PRIx64, ai->regs->sp_el0);
 11076b0:	d2800000 	mov	x0, #0x0                   	// #0
 11076b4:	1400f5a4 	b	1144d44 <trace_printf>
		return " (read permission fault)";
 11076b8:	d0000242 	adrp	x2, 1151000 <small_prime+0x168>
 11076bc:	912c7042 	add	x2, x2, #0xb1c
 11076c0:	17ffff3f 	b	11073bc <__print_abort_info+0xcc>
		return " (write permission fault)";
 11076c4:	d0000242 	adrp	x2, 1151000 <small_prime+0x168>
 11076c8:	912cd442 	add	x2, x2, #0xb35
 11076cc:	17ffff3c 	b	11073bc <__print_abort_info+0xcc>
		return "";
 11076d0:	9104aa82 	add	x2, x20, #0x12a
 11076d4:	17ffff3a 	b	11073bc <__print_abort_info+0xcc>
		return " (alignment fault)";
 11076d8:	d0000242 	adrp	x2, 1151000 <small_prime+0x168>
 11076dc:	912c2442 	add	x2, x2, #0xb09
 11076e0:	17ffff37 	b	11073bc <__print_abort_info+0xcc>

00000000011076e4 <abort_print_current_ts>:
{
 11076e4:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 11076e8:	910003fd 	mov	x29, sp
 11076ec:	a90153f3 	stp	x19, x20, [sp, #16]
	struct thread_specific_data *tsd = thread_get_tsd();
 11076f0:	97fff934 	bl	1105bc0 <thread_get_tsd>
 11076f4:	aa0003f3 	mov	x19, x0
	struct abort_info ai = { };
 11076f8:	a9027fff 	stp	xzr, xzr, [sp, #32]
 11076fc:	a9037fff 	stp	xzr, xzr, [sp, #48]
	struct ts_session *s = ts_get_current_session();
 1107700:	940034b8 	bl	11149e0 <ts_get_current_session>
 1107704:	aa0003f4 	mov	x20, x0
	ai.va = tsd->abort_va;
 1107708:	a9420662 	ldp	x2, x1, [x19, #32]
 110770c:	a90207e2 	stp	x2, x1, [sp, #32]
	ai.abort_type = tsd->abort_type;
 1107710:	b9402260 	ldr	w0, [x19, #32]
	ai.pc = tsd->abort_regs.elr;
 1107714:	f9409a61 	ldr	x1, [x19, #304]
	ai.regs = &tsd->abort_regs;
 1107718:	9100e273 	add	x19, x19, #0x38
	ai.pc = tsd->abort_regs.elr;
 110771c:	b90033e1 	str	w1, [sp, #48]
	if (ai.abort_type != ABORT_TYPE_USER_MODE_PANIC)
 1107720:	71000c1f 	cmp	w0, #0x3
	ai.regs = &tsd->abort_regs;
 1107724:	f9001ff3 	str	x19, [sp, #56]
	if (ai.abort_type != ABORT_TYPE_USER_MODE_PANIC)
 1107728:	540000a0 	b.eq	110773c <abort_print_current_ts+0x58>  // b.none
		__print_abort_info(&ai, "User mode");
 110772c:	d0000241 	adrp	x1, 1151000 <small_prime+0x168>
 1107730:	910083e0 	add	x0, sp, #0x20
 1107734:	91356021 	add	x1, x1, #0xd58
 1107738:	97fffeee 	bl	11072f0 <__print_abort_info>
	s->ctx->ops->dump_state(s->ctx);
 110773c:	f9400a80 	ldr	x0, [x20, #16]
 1107740:	f9400801 	ldr	x1, [x0, #16]
 1107744:	f9400c21 	ldr	x1, [x1, #24]
 1107748:	d63f0020 	blr	x1
}
 110774c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1107750:	a8c47bfd 	ldp	x29, x30, [sp], #64
 1107754:	d65f03c0 	ret

0000000001107758 <abort_print_error>:
{
 1107758:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 110775c:	910003fd 	mov	x29, sp
 1107760:	f9000bf3 	str	x19, [sp, #16]
 1107764:	aa0003f3 	mov	x19, x0
	assert(!abort_is_user_exception(ai));
 1107768:	97fffeda 	bl	11072d0 <abort_is_user_exception>
 110776c:	72001c1f 	tst	w0, #0xff
 1107770:	54000040 	b.eq	1107778 <abort_print_error+0x20>  // b.none
 1107774:	97fffecc 	bl	11072a4 <__abort_print.part.0>
	__print_abort_info(ai, "Core");
 1107778:	aa1303e0 	mov	x0, x19
 110777c:	d0000241 	adrp	x1, 1151000 <small_prime+0x168>
 1107780:	91358821 	add	x1, x1, #0xd62
 1107784:	97fffedb 	bl	11072f0 <__print_abort_info>
		trace_printf_helper_raw(TRACE_ERROR, true,
 1107788:	f0000285 	adrp	x5, 115a000 <__scattered_array_1phys_mem_map+0x8>
 110778c:	52800023 	mov	w3, #0x1                   	// #1
 1107790:	52800022 	mov	w2, #0x1                   	// #1
 1107794:	52800001 	mov	w1, #0x0                   	// #0
 1107798:	f94140a5 	ldr	x5, [x5, #640]
 110779c:	d2800000 	mov	x0, #0x0                   	// #0
 11077a0:	d0000244 	adrp	x4, 1151000 <small_prime+0x168>
 11077a4:	91359c84 	add	x4, x4, #0xd67
 11077a8:	9400f567 	bl	1144d44 <trace_printf>
		__print_stack_unwind(ai);
 11077ac:	f9400e60 	ldr	x0, [x19, #24]
	struct unwind_state_arm64 state = {
 11077b0:	f9407401 	ldr	x1, [x0, #232]
 11077b4:	a902ffe1 	stp	x1, xzr, [sp, #40]
 11077b8:	f9407c00 	ldr	x0, [x0, #248]
 11077bc:	f9001fe0 	str	x0, [sp, #56]
	print_stack_arm64(&state, thread_stack_start(), thread_stack_size());
 11077c0:	97fff719 	bl	1105424 <thread_stack_start>
 11077c4:	aa0003f3 	mov	x19, x0
 11077c8:	97fff6b3 	bl	1105294 <thread_stack_size>
 11077cc:	aa0003e2 	mov	x2, x0
 11077d0:	aa1303e1 	mov	x1, x19
 11077d4:	9100a3e0 	add	x0, sp, #0x28
 11077d8:	940081fe 	bl	1127fd0 <print_stack_arm64>
}
 11077dc:	f9400bf3 	ldr	x19, [sp, #16]
 11077e0:	a8c47bfd 	ldp	x29, x30, [sp], #64
 11077e4:	d65f03c0 	ret

00000000011077e8 <abort_print>:
{
 11077e8:	aa0003e2 	mov	x2, x0
 11077ec:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 11077f0:	910003fd 	mov	x29, sp
	assert(!abort_is_user_exception(ai));
 11077f4:	97fffeb7 	bl	11072d0 <abort_is_user_exception>
 11077f8:	72001c1f 	tst	w0, #0xff
 11077fc:	54000040 	b.eq	1107804 <abort_print+0x1c>  // b.none
 1107800:	97fffea9 	bl	11072a4 <__abort_print.part.0>
}
 1107804:	a8c17bfd 	ldp	x29, x30, [sp], #16
	__print_abort_info(ai, "Core");
 1107808:	aa0203e0 	mov	x0, x2
 110780c:	d0000241 	adrp	x1, 1151000 <small_prime+0x168>
 1107810:	91358821 	add	x1, x1, #0xd62
 1107814:	17fffeb7 	b	11072f0 <__print_abort_info>

0000000001107818 <abort_handler>:
		return FAULT_TYPE_IGNORE;
	}
}

void abort_handler(uint32_t abort_type, struct thread_abort_regs *regs)
{
 1107818:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 110781c:	910003fd 	mov	x29, sp
 1107820:	a90153f3 	stp	x19, x20, [sp, #16]
DEFINE_U64_REG_READ_FUNC(esr_el1)
 1107824:	d5385202 	mrs	x2, esr_el1
	ai->fault_descr = read_esr_el1();
 1107828:	b90027e2 	str	w2, [sp, #36]
	switch ((ai->fault_descr >> ESR_EC_SHIFT) & ESR_EC_MASK) {
 110782c:	531a7c42 	lsr	w2, w2, #26
 1107830:	7100845f 	cmp	w2, #0x21
 1107834:	f9407c20 	ldr	x0, [x1, #248]
 1107838:	54000488 	b.hi	11078c8 <abort_handler+0xb0>  // b.pmore
 110783c:	71007c5f 	cmp	w2, #0x1f
 1107840:	540004a9 	b.ls	11078d4 <abort_handler+0xbc>  // b.plast
		ai->abort_type = ABORT_TYPE_PREFETCH;
 1107844:	52800023 	mov	w3, #0x1                   	// #1
		ai->abort_type = ABORT_TYPE_DATA;
 1107848:	b90023e3 	str	w3, [sp, #32]
DEFINE_U64_REG_READ_FUNC(far_el1)
 110784c:	d5386003 	mrs	x3, far_el1
		ai->va = read_far_el1();
 1107850:	f90017e3 	str	x3, [sp, #40]
	if (abort_is_user_exception(ai)) {
 1107854:	910083f3 	add	x19, sp, #0x20
	ai->pc = regs->elr;
 1107858:	b90033e0 	str	w0, [sp, #48]
	if (abort_is_user_exception(ai)) {
 110785c:	aa1303e0 	mov	x0, x19
	ai->regs = regs;
 1107860:	f9001fe1 	str	x1, [sp, #56]
	if (abort_is_user_exception(ai)) {
 1107864:	97fffe9b 	bl	11072d0 <abort_is_user_exception>
 1107868:	72001c1f 	tst	w0, #0xff
 110786c:	540003e0 	b.eq	11078e8 <abort_handler+0xd0>  // b.none
	switch ((ai->fault_descr >> ESR_EC_SHIFT) & ESR_EC_MASK) {
 1107870:	7100b05f 	cmp	w2, #0x2c
 1107874:	540011a8 	b.hi	1107aa8 <abort_handler+0x290>  // b.pmore
 1107878:	d2800020 	mov	x0, #0x1                   	// #1
 110787c:	9ac22002 	lsl	x2, x0, x2
 1107880:	d2801000 	mov	x0, #0x80                  	// #128
 1107884:	f2c22000 	movk	x0, #0x1100, lsl #32
 1107888:	ea00005f 	tst	x2, x0
 110788c:	540010e0 	b.eq	1107aa8 <abort_handler+0x290>  // b.none
	struct ts_session *s = ts_get_current_session();
 1107890:	94003454 	bl	11149e0 <ts_get_current_session>
	thread_user_enable_vfp(&to_user_mode_ctx(s->ctx)->vfp);
 1107894:	f9400813 	ldr	x19, [x0, #16]
	return is_user_ta_ctx(ctx) || is_stmm_ctx(ctx) || is_sp_ctx(ctx);
}

static inline struct user_mode_ctx *to_user_mode_ctx(struct ts_ctx *ctx)
{
	if (is_user_ta_ctx(ctx))
 1107898:	aa1303e0 	mov	x0, x19
 110789c:	94003a54 	bl	11161ec <is_user_ta_ctx>
 11078a0:	72001c1f 	tst	w0, #0xff
 11078a4:	540011e1 	b.ne	1107ae0 <abort_handler+0x2c8>  // b.any
	       ctx && ctx->ops == stmm_sp_ops_ptr;
}

static inline struct stmm_ctx *to_stmm_ctx(struct ts_ctx *ctx)
{
	assert(is_stmm_ctx(ctx));
 11078a8:	d0000243 	adrp	x3, 1151000 <small_prime+0x168>
 11078ac:	d0000241 	adrp	x1, 1151000 <small_prime+0x168>
 11078b0:	d0000240 	adrp	x0, 1151000 <small_prime+0x168>
 11078b4:	913c7063 	add	x3, x3, #0xf1c
 11078b8:	913a8421 	add	x1, x1, #0xea1
 11078bc:	913b2000 	add	x0, x0, #0xec8
 11078c0:	52801322 	mov	w2, #0x99                  	// #153
 11078c4:	14000092 	b	1107b0c <abort_handler+0x2f4>
	switch ((ai->fault_descr >> ESR_EC_SHIFT) & ESR_EC_MASK) {
 11078c8:	51009043 	sub	w3, w2, #0x24
 11078cc:	7100087f 	cmp	w3, #0x2
 11078d0:	54000089 	b.ls	11078e0 <abort_handler+0xc8>  // b.plast
		ai->abort_type = ABORT_TYPE_UNDEF;
 11078d4:	b90023ff 	str	wzr, [sp, #32]
		ai->va = regs->elr;
 11078d8:	f90017e0 	str	x0, [sp, #40]
 11078dc:	17ffffde 	b	1107854 <abort_handler+0x3c>
		ai->abort_type = ABORT_TYPE_DATA;
 11078e0:	52800043 	mov	w3, #0x2                   	// #2
 11078e4:	17ffffd9 	b	1107848 <abort_handler+0x30>
	if (thread_is_from_abort_mode()) {
 11078e8:	97fff6a5 	bl	110537c <thread_is_from_abort_mode>
 11078ec:	72001c1f 	tst	w0, #0xff
 11078f0:	54000160 	b.eq	110791c <abort_handler+0x104>  // b.none
		abort_print_error(ai);
 11078f4:	aa1303e0 	mov	x0, x19
 11078f8:	97ffff98 	bl	1107758 <abort_print_error>
		panic("[abort] abort in abort handler (trap CPU)");
 11078fc:	d0000243 	adrp	x3, 1151000 <small_prime+0x168>
 1107900:	d0000242 	adrp	x2, 1151000 <small_prime+0x168>
 1107904:	9135fc63 	add	x3, x3, #0xd7f
 1107908:	913d1442 	add	x2, x2, #0xf45
 110790c:	52803aa1 	mov	w1, #0x1d5                 	// #469
		panic("[abort] undefined abort (trap CPU)");
 1107910:	d0000240 	adrp	x0, 1151000 <small_prime+0x168>
 1107914:	912b0000 	add	x0, x0, #0xac0
 1107918:	94002ed4 	bl	1113468 <__do_panic>
	if (ai->abort_type == ABORT_TYPE_UNDEF) {
 110791c:	b94023e0 	ldr	w0, [sp, #32]
 1107920:	350001a0 	cbnz	w0, 1107954 <abort_handler+0x13c>
		if (abort_is_user_exception(ai))
 1107924:	aa1303e0 	mov	x0, x19
 1107928:	97fffe6a 	bl	11072d0 <abort_is_user_exception>
 110792c:	72001c1f 	tst	w0, #0xff
 1107930:	54000bc1 	b.ne	1107aa8 <abort_handler+0x290>  // b.any
		abort_print_error(ai);
 1107934:	aa1303e0 	mov	x0, x19
 1107938:	97ffff88 	bl	1107758 <abort_print_error>
		panic("[abort] undefined abort (trap CPU)");
 110793c:	d0000243 	adrp	x3, 1151000 <small_prime+0x168>
 1107940:	d0000242 	adrp	x2, 1151000 <small_prime+0x168>
 1107944:	9136a463 	add	x3, x3, #0xda9
 1107948:	913d1442 	add	x2, x2, #0xf45
 110794c:	52803b81 	mov	w1, #0x1dc                 	// #476
 1107950:	17fffff0 	b	1107910 <abort_handler+0xf8>
	switch (core_mmu_get_fault_type(ai->fault_descr)) {
 1107954:	b94027e0 	ldr	w0, [sp, #36]
 1107958:	94000ea3 	bl	110b3e4 <core_mmu_get_fault_type>
 110795c:	7100181f 	cmp	w0, #0x6
 1107960:	54000788 	b.hi	1107a50 <abort_handler+0x238>  // b.pmore
 1107964:	f0000221 	adrp	x1, 114e000 <ldelf_data+0x8000>
 1107968:	91167021 	add	x1, x1, #0x59c
 110796c:	38604820 	ldrb	w0, [x1, w0, uxtw]
 1107970:	10000061 	adr	x1, 110797c <abort_handler+0x164>
 1107974:	8b208820 	add	x0, x1, w0, sxtb #2
 1107978:	d61f0000 	br	x0
		if (abort_is_user_exception(ai))
 110797c:	aa1303e0 	mov	x0, x19
 1107980:	97fffe54 	bl	11072d0 <abort_is_user_exception>
 1107984:	72001c1f 	tst	w0, #0xff
 1107988:	54000901 	b.ne	1107aa8 <abort_handler+0x290>  // b.any
		abort_print_error(ai);
 110798c:	aa1303e0 	mov	x0, x19
 1107990:	97ffff72 	bl	1107758 <abort_print_error>
		panic("[abort] alignement fault!  (trap CPU)");
 1107994:	d0000243 	adrp	x3, 1151000 <small_prime+0x168>
 1107998:	d0000242 	adrp	x2, 1151000 <small_prime+0x168>
 110799c:	91373063 	add	x3, x3, #0xdcc
 11079a0:	913d1442 	add	x2, x2, #0xf45
 11079a4:	52803c81 	mov	w1, #0x1e4                 	// #484
 11079a8:	17ffffda 	b	1107910 <abort_handler+0xf8>
		if (abort_is_user_exception(ai))
 11079ac:	aa1303e0 	mov	x0, x19
 11079b0:	97fffe48 	bl	11072d0 <abort_is_user_exception>
 11079b4:	72001c1f 	tst	w0, #0xff
 11079b8:	54000781 	b.ne	1107aa8 <abort_handler+0x290>  // b.any
		abort_print_error(ai);
 11079bc:	aa1303e0 	mov	x0, x19
 11079c0:	97ffff66 	bl	1107758 <abort_print_error>
		panic("[abort] access bit fault!  (trap CPU)");
 11079c4:	d0000243 	adrp	x3, 1151000 <small_prime+0x168>
 11079c8:	d0000242 	adrp	x2, 1151000 <small_prime+0x168>
 11079cc:	9137c863 	add	x3, x3, #0xdf2
 11079d0:	913d1442 	add	x2, x2, #0xf45
 11079d4:	52803d61 	mov	w1, #0x1eb                 	// #491
 11079d8:	17ffffce 	b	1107910 <abort_handler+0xf8>
		if (!abort_is_user_exception(ai))
 11079dc:	aa1303e0 	mov	x0, x19
 11079e0:	97fffe3c 	bl	11072d0 <abort_is_user_exception>
 11079e4:	72001c1f 	tst	w0, #0xff
 11079e8:	54000061 	b.ne	11079f4 <abort_handler+0x1dc>  // b.any
			abort_print(ai);
 11079ec:	aa1303e0 	mov	x0, x19
 11079f0:	97ffff7e 	bl	11077e8 <abort_print>
		DMSG("[abort] Ignoring debug event!");
 11079f4:	d0000244 	adrp	x4, 1151000 <small_prime+0x168>
 11079f8:	91386084 	add	x4, x4, #0xe18
 11079fc:	52800023 	mov	w3, #0x1                   	// #1
 1107a00:	52800062 	mov	w2, #0x3                   	// #3
 1107a04:	52803e21 	mov	w1, #0x1f1                 	// #497
		DMSG("[abort] Ignoring async external abort!");
 1107a08:	d0000240 	adrp	x0, 1151000 <small_prime+0x168>
 1107a0c:	913d1400 	add	x0, x0, #0xf45
 1107a10:	9400f4cd 	bl	1144d44 <trace_printf>
			vfp_disable();
			handle_user_mode_panic(&ai);
		}
		break;
	}
}
 1107a14:	a94153f3 	ldp	x19, x20, [sp, #16]
 1107a18:	a8c47bfd 	ldp	x29, x30, [sp], #64
 1107a1c:	d65f03c0 	ret
		if (!abort_is_user_exception(ai))
 1107a20:	aa1303e0 	mov	x0, x19
 1107a24:	97fffe2b 	bl	11072d0 <abort_is_user_exception>
 1107a28:	72001c1f 	tst	w0, #0xff
 1107a2c:	54000061 	b.ne	1107a38 <abort_handler+0x220>  // b.any
			abort_print(ai);
 1107a30:	aa1303e0 	mov	x0, x19
 1107a34:	97ffff6d 	bl	11077e8 <abort_print>
		DMSG("[abort] Ignoring async external abort!");
 1107a38:	d0000244 	adrp	x4, 1151000 <small_prime+0x168>
 1107a3c:	52800023 	mov	w3, #0x1                   	// #1
 1107a40:	9138d884 	add	x4, x4, #0xe36
 1107a44:	52800062 	mov	w2, #0x3                   	// #3
 1107a48:	52803f81 	mov	w1, #0x1fc                 	// #508
 1107a4c:	17ffffef 	b	1107a08 <abort_handler+0x1f0>
		if (!abort_is_user_exception(ai))
 1107a50:	aa1303e0 	mov	x0, x19
 1107a54:	97fffe1f 	bl	11072d0 <abort_is_user_exception>
 1107a58:	72001c1f 	tst	w0, #0xff
 1107a5c:	54000061 	b.ne	1107a68 <abort_handler+0x250>  // b.any
			abort_print(ai);
 1107a60:	aa1303e0 	mov	x0, x19
 1107a64:	97ffff61 	bl	11077e8 <abort_print>
		DMSG("[abort] Unhandled fault!");
 1107a68:	d0000244 	adrp	x4, 1151000 <small_prime+0x168>
 1107a6c:	52800023 	mov	w3, #0x1                   	// #1
 1107a70:	91397484 	add	x4, x4, #0xe5d
 1107a74:	52800062 	mov	w2, #0x3                   	// #3
 1107a78:	52804061 	mov	w1, #0x203                 	// #515
 1107a7c:	17ffffe3 	b	1107a08 <abort_handler+0x1f0>
		if (thread_get_id_may_fail() < 0) {
 1107a80:	d0000254 	adrp	x20, 1151000 <small_prime+0x168>
 1107a84:	97fff65a 	bl	11053ec <thread_get_id_may_fail>
 1107a88:	367804c0 	tbz	w0, #15, 1107b20 <abort_handler+0x308>
			abort_print_error(&ai);
 1107a8c:	aa1303e0 	mov	x0, x19
 1107a90:	97ffff32 	bl	1107758 <abort_print_error>
			panic("abort outside thread context");
 1107a94:	d0000243 	adrp	x3, 1151000 <small_prime+0x168>
 1107a98:	913d5282 	add	x2, x20, #0xf54
 1107a9c:	913b6463 	add	x3, x3, #0xed9
 1107aa0:	52804421 	mov	w1, #0x221                 	// #545
 1107aa4:	17ffff9b 	b	1107910 <abort_handler+0xf8>
		DMSG("[abort] abort in User mode (TA will panic)");
 1107aa8:	d0000244 	adrp	x4, 1151000 <small_prime+0x168>
 1107aac:	d0000240 	adrp	x0, 1151000 <small_prime+0x168>
 1107ab0:	9139d884 	add	x4, x4, #0xe76
 1107ab4:	913d5000 	add	x0, x0, #0xf54
 1107ab8:	52800023 	mov	w3, #0x1                   	// #1
 1107abc:	52800062 	mov	w2, #0x3                   	// #3
 1107ac0:	52804261 	mov	w1, #0x213                 	// #531
			DMSG("[abort] abort in User mode (TA will panic)");
 1107ac4:	9400f4a0 	bl	1144d44 <trace_printf>
			save_abort_info_in_tsd(&ai);
 1107ac8:	aa1303e0 	mov	x0, x19
 1107acc:	97fffdc8 	bl	11071ec <save_abort_info_in_tsd>
			vfp_disable();
 1107ad0:	94000031 	bl	1107b94 <vfp_disable>
			handle_user_mode_panic(&ai);
 1107ad4:	91006260 	add	x0, x19, #0x18
 1107ad8:	97fffdda 	bl	1107240 <handle_user_mode_panic.isra.0>
}
 1107adc:	17ffffce 	b	1107a14 <abort_handler+0x1fc>
 1107ae0:	aa1303e0 	mov	x0, x19
 1107ae4:	940039c2 	bl	11161ec <is_user_ta_ctx>
 1107ae8:	72001c1f 	tst	w0, #0xff
 1107aec:	54000141 	b.ne	1107b14 <abort_handler+0x2fc>  // b.any
 1107af0:	d0000243 	adrp	x3, 1151000 <small_prime+0x168>
 1107af4:	d0000241 	adrp	x1, 1151000 <small_prime+0x168>
 1107af8:	d0000240 	adrp	x0, 1151000 <small_prime+0x168>
 1107afc:	913ca063 	add	x3, x3, #0xf28
 1107b00:	91081021 	add	x1, x1, #0x204
 1107b04:	91088800 	add	x0, x0, #0x222
 1107b08:	52800702 	mov	w2, #0x38                  	// #56
 1107b0c:	940029e8 	bl	11122ac <_assert_log>
 1107b10:	940029f8 	bl	11122f0 <_assert_break>
	thread_user_enable_vfp(&to_user_mode_ctx(s->ctx)->vfp);
 1107b14:	d109e260 	sub	x0, x19, #0x278
 1107b18:	97fff8d7 	bl	1105e74 <thread_user_enable_vfp>
}
 1107b1c:	17ffffbe 	b	1107a14 <abort_handler+0x1fc>
		thread_kernel_save_vfp();
 1107b20:	97fff88e 	bl	1105d58 <thread_kernel_save_vfp>
		thread_kernel_restore_vfp();
 1107b24:	97fff8ab 	bl	1105dd0 <thread_kernel_restore_vfp>
			if (!abort_is_user_exception(&ai)) {
 1107b28:	aa1303e0 	mov	x0, x19
 1107b2c:	97fffde9 	bl	11072d0 <abort_is_user_exception>
 1107b30:	72001c1f 	tst	w0, #0xff
 1107b34:	54000101 	b.ne	1107b54 <abort_handler+0x33c>  // b.any
				abort_print_error(&ai);
 1107b38:	aa1303e0 	mov	x0, x19
 1107b3c:	97ffff07 	bl	1107758 <abort_print_error>
				panic("unhandled pageable abort");
 1107b40:	d0000243 	adrp	x3, 1151000 <small_prime+0x168>
 1107b44:	913d5282 	add	x2, x20, #0xf54
 1107b48:	913bd863 	add	x3, x3, #0xef6
 1107b4c:	52804521 	mov	w1, #0x229                 	// #553
 1107b50:	17ffff70 	b	1107910 <abort_handler+0xf8>
			DMSG("[abort] abort in User mode (TA will panic)");
 1107b54:	d0000244 	adrp	x4, 1151000 <small_prime+0x168>
 1107b58:	913d5280 	add	x0, x20, #0xf54
 1107b5c:	9139d884 	add	x4, x4, #0xe76
 1107b60:	52800023 	mov	w3, #0x1                   	// #1
 1107b64:	52800062 	mov	w2, #0x3                   	// #3
 1107b68:	52804561 	mov	w1, #0x22b                 	// #555
 1107b6c:	17ffffd6 	b	1107ac4 <abort_handler+0x2ac>

0000000001107b70 <vfp_is_enabled>:
DEFINE_U32_REG_READWRITE_FUNCS(cpacr_el1)
 1107b70:	d5381040 	mrs	x0, cpacr_el1
#endif /* ARM32 */

#ifdef ARM64
bool vfp_is_enabled(void)
{
	return (CPACR_EL1_FPEN(read_cpacr_el1()) & CPACR_EL1_FPEN_EL0EL1);
 1107b74:	720c041f 	tst	w0, #0x300000
}
 1107b78:	1a9f07e0 	cset	w0, ne  // ne = any
 1107b7c:	d65f03c0 	ret

0000000001107b80 <vfp_enable>:
 1107b80:	d5381040 	mrs	x0, cpacr_el1
 1107b84:	320c0400 	orr	w0, w0, #0x300000
 1107b88:	d5181040 	msr	cpacr_el1, x0
	asm volatile ("isb");
 1107b8c:	d5033fdf 	isb
	uint32_t val = read_cpacr_el1();

	val |= (CPACR_EL1_FPEN_EL0EL1 << CPACR_EL1_FPEN_SHIFT);
	write_cpacr_el1(val);
	isb();
}
 1107b90:	d65f03c0 	ret

0000000001107b94 <vfp_disable>:
DEFINE_U32_REG_READWRITE_FUNCS(cpacr_el1)
 1107b94:	d5381040 	mrs	x0, cpacr_el1
 1107b98:	92407c00 	and	x0, x0, #0xffffffff
 1107b9c:	926af400 	and	x0, x0, #0xffffffffffcfffff
 1107ba0:	d5181040 	msr	cpacr_el1, x0
	asm volatile ("isb");
 1107ba4:	d5033fdf 	isb
	uint32_t val = read_cpacr_el1();

	val &= ~(CPACR_EL1_FPEN_MASK << CPACR_EL1_FPEN_SHIFT);
	write_cpacr_el1(val);
	isb();
}
 1107ba8:	d65f03c0 	ret

0000000001107bac <vfp_lazy_save_state_init>:
DEFINE_U32_REG_READWRITE_FUNCS(cpacr_el1)
 1107bac:	d5381041 	mrs	x1, cpacr_el1
 1107bb0:	b9020801 	str	w1, [x0, #520]

void vfp_lazy_save_state_init(struct vfp_state *state)
{
	state->cpacr_el1 = read_cpacr_el1();
	vfp_disable();
 1107bb4:	17fffff8 	b	1107b94 <vfp_disable>

0000000001107bb8 <vfp_lazy_save_state_final>:
}

void vfp_lazy_save_state_final(struct vfp_state *state, bool force_save)
{
 1107bb8:	aa0003e2 	mov	x2, x0
	if ((CPACR_EL1_FPEN(state->cpacr_el1) & CPACR_EL1_FPEN_EL0EL1) ||
 1107bbc:	b9420800 	ldr	w0, [x0, #520]
 1107bc0:	f26c041f 	tst	x0, #0x300000
 1107bc4:	54000061 	b.ne	1107bd0 <vfp_lazy_save_state_final+0x18>  // b.any
 1107bc8:	12001c21 	and	w1, w1, #0xff
 1107bcc:	34000301 	cbz	w1, 1107c2c <vfp_lazy_save_state_final+0x74>
{
 1107bd0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 1107bd4:	910003fd 	mov	x29, sp
	    force_save) {
		assert(!vfp_is_enabled());
 1107bd8:	97ffffe6 	bl	1107b70 <vfp_is_enabled>
 1107bdc:	72001c1f 	tst	w0, #0xff
 1107be0:	54000140 	b.eq	1107c08 <vfp_lazy_save_state_final+0x50>  // b.none
 1107be4:	d0000243 	adrp	x3, 1151000 <small_prime+0x168>
 1107be8:	d0000241 	adrp	x1, 1151000 <small_prime+0x168>
 1107bec:	913df463 	add	x3, x3, #0xf7d
 1107bf0:	913d8821 	add	x1, x1, #0xf62
 1107bf4:	d0000240 	adrp	x0, 1151000 <small_prime+0x168>
 1107bf8:	911e0c00 	add	x0, x0, #0x783
 1107bfc:	52800ca2 	mov	w2, #0x65                  	// #101
 1107c00:	940029ab 	bl	11122ac <_assert_log>
 1107c04:	940029bb 	bl	11122f0 <_assert_break>
		vfp_enable();
 1107c08:	97ffffde 	bl	1107b80 <vfp_enable>
DEFINE_U32_REG_READWRITE_FUNCS(fpcr)
 1107c0c:	d53b4400 	mrs	x0, fpcr
 1107c10:	b9020440 	str	w0, [x2, #516]
DEFINE_U32_REG_READWRITE_FUNCS(fpsr)
 1107c14:	d53b4420 	mrs	x0, fpsr
 1107c18:	b9020040 	str	w0, [x2, #512]
		state->fpcr = read_fpcr();
		state->fpsr = read_fpsr();
		vfp_save_extension_regs(state->reg);
 1107c1c:	aa0203e0 	mov	x0, x2
 1107c20:	94000017 	bl	1107c7c <vfp_save_extension_regs>
		vfp_disable();
	}
}
 1107c24:	a8c17bfd 	ldp	x29, x30, [sp], #16
		vfp_disable();
 1107c28:	17ffffdb 	b	1107b94 <vfp_disable>
 1107c2c:	d65f03c0 	ret

0000000001107c30 <vfp_lazy_restore_state>:

void vfp_lazy_restore_state(struct vfp_state *state, bool full_state)
{
 1107c30:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	if (full_state) {
 1107c34:	72001c3f 	tst	w1, #0xff
{
 1107c38:	910003fd 	mov	x29, sp
 1107c3c:	f9000bf3 	str	x19, [sp, #16]
 1107c40:	aa0003f3 	mov	x19, x0
	if (full_state) {
 1107c44:	54000100 	b.eq	1107c64 <vfp_lazy_restore_state+0x34>  // b.none
		 * Only restore VFP registers if they have been touched as they
		 * otherwise are intact.
		 */

		/* CPACR_EL1 is restored to what's in state->cpacr_el1 below */
		vfp_enable();
 1107c48:	97ffffce 	bl	1107b80 <vfp_enable>
DEFINE_U32_REG_READWRITE_FUNCS(fpcr)
 1107c4c:	b9420660 	ldr	w0, [x19, #516]
 1107c50:	d51b4400 	msr	fpcr, x0
DEFINE_U32_REG_READWRITE_FUNCS(fpsr)
 1107c54:	b9420260 	ldr	w0, [x19, #512]
 1107c58:	d51b4420 	msr	fpsr, x0
		write_fpcr(state->fpcr);
		write_fpsr(state->fpsr);
		vfp_restore_extension_regs(state->reg);
 1107c5c:	aa1303e0 	mov	x0, x19
 1107c60:	94000018 	bl	1107cc0 <vfp_restore_extension_regs>
DEFINE_U32_REG_READWRITE_FUNCS(cpacr_el1)
 1107c64:	b9420a60 	ldr	w0, [x19, #520]
 1107c68:	d5181040 	msr	cpacr_el1, x0
	asm volatile ("isb");
 1107c6c:	d5033fdf 	isb
	}
	write_cpacr_el1(state->cpacr_el1);
	isb();
}
 1107c70:	f9400bf3 	ldr	x19, [sp, #16]
 1107c74:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1107c78:	d65f03c0 	ret

0000000001107c7c <vfp_save_extension_regs>:

#include <asm.S>

/* void vfp_save_extension_regs(struct vfp_reg regs[VFP_NUM_REGS]); */
FUNC vfp_save_extension_regs , :
	stp	q0, q1, [x0, #16 * 0]
 1107c7c:	ad000400 	stp	q0, q1, [x0]
	stp	q2, q3, [x0, #16 * 2]
 1107c80:	ad010c02 	stp	q2, q3, [x0, #32]
	stp	q4, q5, [x0, #16 * 4]
 1107c84:	ad021404 	stp	q4, q5, [x0, #64]
	stp	q6, q7, [x0, #16 * 6]
 1107c88:	ad031c06 	stp	q6, q7, [x0, #96]
	stp	q8, q9, [x0, #16 * 8]
 1107c8c:	ad042408 	stp	q8, q9, [x0, #128]
	stp	q10, q11, [x0, #16 * 10]
 1107c90:	ad052c0a 	stp	q10, q11, [x0, #160]
	stp	q12, q13, [x0, #16 * 12]
 1107c94:	ad06340c 	stp	q12, q13, [x0, #192]
	stp	q14, q15, [x0, #16 * 14]
 1107c98:	ad073c0e 	stp	q14, q15, [x0, #224]
	stp	q16, q17, [x0, #16 * 16]
 1107c9c:	ad084410 	stp	q16, q17, [x0, #256]
	stp	q18, q19, [x0, #16 * 18]
 1107ca0:	ad094c12 	stp	q18, q19, [x0, #288]
	stp	q20, q21, [x0, #16 * 20]
 1107ca4:	ad0a5414 	stp	q20, q21, [x0, #320]
	stp	q22, q23, [x0, #16 * 22]
 1107ca8:	ad0b5c16 	stp	q22, q23, [x0, #352]
	stp	q24, q25, [x0, #16 * 24]
 1107cac:	ad0c6418 	stp	q24, q25, [x0, #384]
	stp	q26, q27, [x0, #16 * 26]
 1107cb0:	ad0d6c1a 	stp	q26, q27, [x0, #416]
	stp	q28, q29, [x0, #16 * 28]
 1107cb4:	ad0e741c 	stp	q28, q29, [x0, #448]
	stp	q30, q31, [x0, #16 * 30]
 1107cb8:	ad0f7c1e 	stp	q30, q31, [x0, #480]
	ret
 1107cbc:	d65f03c0 	ret

0000000001107cc0 <vfp_restore_extension_regs>:
END_FUNC vfp_save_extension_regs

/* void vfp_restore_extension_regs(struct vfp_reg regs[VFP_NUM_REGS]); */
FUNC vfp_restore_extension_regs , :
	ldp	q0, q1, [x0, #16 * 0]
 1107cc0:	ad400400 	ldp	q0, q1, [x0]
	ldp	q2, q3, [x0, #16 * 2]
 1107cc4:	ad410c02 	ldp	q2, q3, [x0, #32]
	ldp	q4, q5, [x0, #16 * 4]
 1107cc8:	ad421404 	ldp	q4, q5, [x0, #64]
	ldp	q6, q7, [x0, #16 * 6]
 1107ccc:	ad431c06 	ldp	q6, q7, [x0, #96]
	ldp	q8, q9, [x0, #16 * 8]
 1107cd0:	ad442408 	ldp	q8, q9, [x0, #128]
	ldp	q10, q11, [x0, #16 * 10]
 1107cd4:	ad452c0a 	ldp	q10, q11, [x0, #160]
	ldp	q12, q13, [x0, #16 * 12]
 1107cd8:	ad46340c 	ldp	q12, q13, [x0, #192]
	ldp	q14, q15, [x0, #16 * 14]
 1107cdc:	ad473c0e 	ldp	q14, q15, [x0, #224]
	ldp	q16, q17, [x0, #16 * 16]
 1107ce0:	ad484410 	ldp	q16, q17, [x0, #256]
	ldp	q18, q19, [x0, #16 * 18]
 1107ce4:	ad494c12 	ldp	q18, q19, [x0, #288]
	ldp	q20, q21, [x0, #16 * 20]
 1107ce8:	ad4a5414 	ldp	q20, q21, [x0, #320]
	ldp	q22, q23, [x0, #16 * 22]
 1107cec:	ad4b5c16 	ldp	q22, q23, [x0, #352]
	ldp	q24, q25, [x0, #16 * 24]
 1107cf0:	ad4c6418 	ldp	q24, q25, [x0, #384]
	ldp	q26, q27, [x0, #16 * 26]
 1107cf4:	ad4d6c1a 	ldp	q26, q27, [x0, #416]
	ldp	q28, q29, [x0, #16 * 28]
 1107cf8:	ad4e741c 	ldp	q28, q29, [x0, #448]
	ldp	q30, q31, [x0, #16 * 30]
 1107cfc:	ad4f7c1e 	ldp	q30, q31, [x0, #480]
	ret
 1107d00:	d65f03c0 	ret

0000000001107d04 <plat_trace_ext_puts>:
int trace_level __nex_data = TRACE_LEVEL;
static unsigned int puts_lock __nex_bss = SPINLOCK_UNLOCK;

void __weak plat_trace_ext_puts(const char *str __unused)
{
}
 1107d04:	d65f03c0 	ret

0000000001107d08 <trace_ext_puts>:

void trace_ext_puts(const char *str)
{
 1107d08:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1107d0c:	910003fd 	mov	x29, sp
 1107d10:	a90153f3 	stp	x19, x20, [sp, #16]
 1107d14:	aa0003f3 	mov	x19, x0
	uint32_t itr_status = thread_mask_exceptions(THREAD_EXCP_ALL);
 1107d18:	528000e0 	mov	w0, #0x7                   	// #7
{
 1107d1c:	a9025bf5 	stp	x21, x22, [sp, #32]
	uint32_t itr_status = thread_mask_exceptions(THREAD_EXCP_ALL);
 1107d20:	97fff506 	bl	1105138 <thread_mask_exceptions>
 1107d24:	2a0003f6 	mov	w22, w0
	bool mmu_enabled = cpu_mmu_enabled();
 1107d28:	94000ad7 	bl	110a884 <cpu_mmu_enabled>
	bool was_contended = false;
	const char *p;

	if (mmu_enabled && !cpu_spin_trylock(&puts_lock)) {
 1107d2c:	72001c14 	ands	w20, w0, #0xff
 1107d30:	54000240 	b.eq	1107d78 <trace_ext_puts+0x70>  // b.none
 1107d34:	97fff478 	bl	1104f14 <thread_get_exceptions>
	assert(thread_foreign_intr_disabled());
 1107d38:	37080140 	tbnz	w0, #1, 1107d60 <trace_ext_puts+0x58>
 1107d3c:	d0000243 	adrp	x3, 1151000 <small_prime+0x168>
 1107d40:	913ec463 	add	x3, x3, #0xfb1
 1107d44:	52800a62 	mov	w2, #0x53                  	// #83
	assert(thread_foreign_intr_disabled());
 1107d48:	d0000241 	adrp	x1, 1151000 <small_prime+0x168>
 1107d4c:	d0000240 	adrp	x0, 1151000 <small_prime+0x168>
 1107d50:	9111f821 	add	x1, x1, #0x47e
 1107d54:	91129800 	add	x0, x0, #0x4a6
 1107d58:	94002955 	bl	11122ac <_assert_log>
 1107d5c:	94002965 	bl	11122f0 <_assert_break>
	rc = __cpu_spin_trylock(lock);
 1107d60:	b0000315 	adrp	x21, 1168000 <data.5093+0x9e28>
 1107d64:	9128a2b5 	add	x21, x21, #0xa28
 1107d68:	aa1503e0 	mov	x0, x21
 1107d6c:	97fff1ce 	bl	11044a4 <__cpu_spin_trylock>
	if (!rc)
 1107d70:	35000480 	cbnz	w0, 1107e00 <trace_ext_puts+0xf8>
		spinlock_count_incr();
 1107d74:	97fff1d5 	bl	11044c8 <spinlock_count_incr>
	bool was_contended = false;
 1107d78:	52800015 	mov	w21, #0x0                   	// #0
 1107d7c:	14000005 	b	1107d90 <trace_ext_puts+0x88>
	__cpu_spin_lock(lock);
 1107d80:	aa1503e0 	mov	x0, x21
		was_contended = true;
 1107d84:	2a1403f5 	mov	w21, w20
 1107d88:	97fff1bf 	bl	1104484 <__cpu_spin_lock>
	spinlock_count_incr();
 1107d8c:	97fff1cf 	bl	11044c8 <spinlock_count_incr>
		cpu_spin_lock_no_dldetect(&puts_lock);
	}

	plat_trace_ext_puts(str);
 1107d90:	aa1303e0 	mov	x0, x19
 1107d94:	97ffffdc 	bl	1107d04 <plat_trace_ext_puts>

	console_flush();
 1107d98:	94002978 	bl	1112378 <console_flush>

	if (was_contended)
 1107d9c:	34000075 	cbz	w21, 1107da8 <trace_ext_puts+0xa0>
		console_putc('*');
 1107da0:	52800540 	mov	w0, #0x2a                  	// #42
 1107da4:	9400295c 	bl	1112314 <console_putc>

	for (p = str; *p; p++)
 1107da8:	39400260 	ldrb	w0, [x19]
 1107dac:	35000120 	cbnz	w0, 1107dd0 <trace_ext_puts+0xc8>
		console_putc(*p);

	console_flush();
 1107db0:	94002972 	bl	1112378 <console_flush>

	if (mmu_enabled)
 1107db4:	340001d4 	cbz	w20, 1107dec <trace_ext_puts+0xe4>
 1107db8:	97fff457 	bl	1104f14 <thread_get_exceptions>
	assert(thread_foreign_intr_disabled());
 1107dbc:	37080100 	tbnz	w0, #1, 1107ddc <trace_ext_puts+0xd4>
 1107dc0:	d0000243 	adrp	x3, 1151000 <small_prime+0x168>
 1107dc4:	52800b82 	mov	w2, #0x5c                  	// #92
 1107dc8:	913f0863 	add	x3, x3, #0xfc2
 1107dcc:	17ffffdf 	b	1107d48 <trace_ext_puts+0x40>
	for (p = str; *p; p++)
 1107dd0:	91000673 	add	x19, x19, #0x1
		console_putc(*p);
 1107dd4:	94002950 	bl	1112314 <console_putc>
	for (p = str; *p; p++)
 1107dd8:	17fffff4 	b	1107da8 <trace_ext_puts+0xa0>
	__cpu_spin_unlock(lock);
 1107ddc:	b0000300 	adrp	x0, 1168000 <data.5093+0x9e28>
 1107de0:	9128a000 	add	x0, x0, #0xa28
 1107de4:	97fff1b7 	bl	11044c0 <__cpu_spin_unlock>
	spinlock_count_decr();
 1107de8:	97fff1ca 	bl	1104510 <spinlock_count_decr>
		cpu_spin_unlock(&puts_lock);

	thread_unmask_exceptions(itr_status);
 1107dec:	2a1603e0 	mov	w0, w22
}
 1107df0:	a94153f3 	ldp	x19, x20, [sp, #16]
 1107df4:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1107df8:	a8c37bfd 	ldp	x29, x30, [sp], #48
	thread_unmask_exceptions(itr_status);
 1107dfc:	17fff4dc 	b	110516c <thread_unmask_exceptions>
 1107e00:	97fff445 	bl	1104f14 <thread_get_exceptions>
	assert(thread_foreign_intr_disabled());
 1107e04:	370ffbe0 	tbnz	w0, #1, 1107d80 <trace_ext_puts+0x78>
 1107e08:	d0000243 	adrp	x3, 1151000 <small_prime+0x168>
 1107e0c:	52800502 	mov	w2, #0x28                  	// #40
 1107e10:	913e5c63 	add	x3, x3, #0xf97
 1107e14:	17ffffcd 	b	1107d48 <trace_ext_puts+0x40>

0000000001107e18 <trace_ext_get_thread_id>:

int trace_ext_get_thread_id(void)
{
 1107e18:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 1107e1c:	910003fd 	mov	x29, sp
	return thread_get_id_may_fail();
 1107e20:	97fff573 	bl	11053ec <thread_get_id_may_fail>
}
 1107e24:	13003c00 	sxth	w0, w0
 1107e28:	a8c17bfd 	ldp	x29, x30, [sp], #16
 1107e2c:	d65f03c0 	ret

0000000001107e30 <get_core_pos>:
{
 1107e30:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 1107e34:	910003fd 	mov	x29, sp
	assert(thread_get_exceptions() & THREAD_EXCP_FOREIGN_INTR);
 1107e38:	97fff437 	bl	1104f14 <thread_get_exceptions>
 1107e3c:	37080140 	tbnz	w0, #1, 1107e64 <get_core_pos+0x34>
 1107e40:	f0000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 1107e44:	d0000241 	adrp	x1, 1151000 <small_prime+0x168>
 1107e48:	91064463 	add	x3, x3, #0x191
 1107e4c:	9113b021 	add	x1, x1, #0x4ec
 1107e50:	d0000240 	adrp	x0, 1151000 <small_prime+0x168>
 1107e54:	91144000 	add	x0, x0, #0x510
 1107e58:	528002c2 	mov	w2, #0x16                  	// #22
 1107e5c:	94002914 	bl	11122ac <_assert_log>
 1107e60:	94002924 	bl	11122f0 <_assert_break>
}
 1107e64:	a8c17bfd 	ldp	x29, x30, [sp], #16
	return __get_core_pos();
 1107e68:	17ffe6bb 	b	1101954 <__get_core_pos>

0000000001107e6c <init_tee_runtime>:
{
}
#endif /*!CFG_CORE_DYN_SHM*/

void init_tee_runtime(void)
{
 1107e6c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 1107e70:	910003fd 	mov	x29, sp
	malloc_add_pool(__heap1_start, __heap1_end - __heap1_start);
#endif

#ifndef CFG_WITH_PAGER
	/* Pager initializes TA RAM early */
	core_mmu_init_ta_ram();
 1107e74:	94000aa9 	bl	110a918 <core_mmu_init_ta_ram>
#endif
	call_initcalls();
}
 1107e78:	a8c17bfd 	ldp	x29, x30, [sp], #16
	call_initcalls();
 1107e7c:	1400339d 	b	1114cf0 <call_initcalls>

0000000001107e80 <boot_init_primary_late>:
/*
 * Note: this function is weak just to make it possible to exclude it from
 * the unpaged area.
 */
void __weak boot_init_primary_late(unsigned long fdt)
{
 1107e80:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1107e84:	910003fd 	mov	x29, sp
 1107e88:	a90153f3 	stp	x19, x20, [sp, #16]
 1107e8c:	d0000293 	adrp	x19, 1159000 <Worder+0x2854>
 1107e90:	f90013f5 	str	x21, [sp, #32]
	mem_begin = phys_ddr_overall_begin;
 1107e94:	d0000295 	adrp	x21, 1159000 <Worder+0x2854>
 1107e98:	913c62a0 	add	x0, x21, #0xf18
 1107e9c:	940032e5 	bl	1114a30 <scattered_array_relax_ptr>
	nelems = mem_end - mem_begin;
 1107ea0:	d0000281 	adrp	x1, 1159000 <Worder+0x2854>
 1107ea4:	913c6021 	add	x1, x1, #0xf18
 1107ea8:	cb000020 	sub	x0, x1, x0
 1107eac:	9345fc14 	asr	x20, x0, #5
	if (nelems) {
 1107eb0:	eb8017ff 	cmp	xzr, x0, asr #5
 1107eb4:	d0000280 	adrp	x0, 1159000 <Worder+0x2854>
		assert(phys_ddr_overall_compat_begin ==
 1107eb8:	913c6000 	add	x0, x0, #0xf18
	if (nelems) {
 1107ebc:	540001c0 	b.eq	1107ef4 <boot_init_primary_late+0x74>  // b.none
		assert(phys_ddr_overall_compat_begin ==
 1107ec0:	913c6273 	add	x19, x19, #0xf18
 1107ec4:	940032db 	bl	1114a30 <scattered_array_relax_ptr>
 1107ec8:	eb00027f 	cmp	x19, x0
 1107ecc:	54000300 	b.eq	1107f2c <boot_init_primary_late+0xac>  // b.none
 1107ed0:	f0000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 1107ed4:	d0000241 	adrp	x1, 1151000 <small_prime+0x168>
 1107ed8:	91067863 	add	x3, x3, #0x19e
 1107edc:	913f5421 	add	x1, x1, #0xfd5
 1107ee0:	f0000240 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 1107ee4:	91003400 	add	x0, x0, #0xd
 1107ee8:	52808fa2 	mov	w2, #0x47d                 	// #1149
 1107eec:	940028f0 	bl	11122ac <_assert_log>
 1107ef0:	94002900 	bl	11122f0 <_assert_break>
		nelems = mem_end - mem_begin;
 1107ef4:	913c6273 	add	x19, x19, #0xf18
		mem_begin = phys_ddr_overall_compat_begin;
 1107ef8:	940032ce 	bl	1114a30 <scattered_array_relax_ptr>
		nelems = mem_end - mem_begin;
 1107efc:	cb000260 	sub	x0, x19, x0
 1107f00:	9345fc14 	asr	x20, x0, #5
		if (!nelems)
 1107f04:	eb8017ff 	cmp	xzr, x0, asr #5
 1107f08:	540003c0 	b.eq	1107f80 <boot_init_primary_late+0x100>  // b.none
		DMSG("Warning register_dynamic_shm() is deprecated, please use register_ddr() instead");
 1107f0c:	f0000244 	adrp	x4, 1152000 <trace_ext_prefix+0x2e>
 1107f10:	f0000240 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 1107f14:	91012884 	add	x4, x4, #0x4a
 1107f18:	91067800 	add	x0, x0, #0x19e
 1107f1c:	52800023 	mov	w3, #0x1                   	// #1
 1107f20:	52800062 	mov	w2, #0x3                   	// #3
 1107f24:	528090a1 	mov	w1, #0x485                 	// #1157
 1107f28:	9400f387 	bl	1144d44 <trace_printf>
	mem = nex_calloc(nelems, sizeof(*mem));
 1107f2c:	aa1403e0 	mov	x0, x20
 1107f30:	d2800401 	mov	x1, #0x20                  	// #32
 1107f34:	9400ed67 	bl	11434d0 <calloc>
 1107f38:	aa0003f3 	mov	x19, x0
	if (!mem)
 1107f3c:	b5000100 	cbnz	x0, 1107f5c <boot_init_primary_late+0xdc>
		panic();
 1107f40:	f0000242 	adrp	x2, 1152000 <trace_ext_prefix+0x2e>
 1107f44:	d0000240 	adrp	x0, 1151000 <small_prime+0x168>
 1107f48:	91067842 	add	x2, x2, #0x19e
 1107f4c:	913f5400 	add	x0, x0, #0xfd5
 1107f50:	d2800003 	mov	x3, #0x0                   	// #0
 1107f54:	52809141 	mov	w1, #0x48a                 	// #1162
 1107f58:	94002d44 	bl	1113468 <__do_panic>
	memcpy(mem, phys_ddr_overall_begin, sizeof(*mem) * nelems);
 1107f5c:	913c62a0 	add	x0, x21, #0xf18
 1107f60:	940032b4 	bl	1114a30 <scattered_array_relax_ptr>
 1107f64:	d37bea82 	lsl	x2, x20, #5
 1107f68:	aa0003e1 	mov	x1, x0
 1107f6c:	aa1303e0 	mov	x0, x19
 1107f70:	97ffed08 	bl	1103390 <memcpy>
	core_mmu_set_discovered_nsec_ddr(mem, nelems);
 1107f74:	aa1403e1 	mov	x1, x20
 1107f78:	aa1303e0 	mov	x0, x19
 1107f7c:	94000272 	bl	1108944 <core_mmu_set_discovered_nsec_ddr>
	tpm_map_log_area(get_external_dt());
	discover_nsec_memory();
	update_external_dt();
	configure_console_from_dt();

	IMSG("OP-TEE version: %s", core_v_str);
 1107f80:	f0000294 	adrp	x20, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1107f84:	f0000253 	adrp	x19, 1152000 <trace_ext_prefix+0x2e>
 1107f88:	9106ce73 	add	x19, x19, #0x1b3
 1107f8c:	52800023 	mov	w3, #0x1                   	// #1
 1107f90:	f9423a85 	ldr	x5, [x20, #1136]
 1107f94:	aa1303e0 	mov	x0, x19
 1107f98:	52800042 	mov	w2, #0x2                   	// #2
 1107f9c:	52809a81 	mov	w1, #0x4d4                 	// #1236
 1107fa0:	f0000244 	adrp	x4, 1152000 <trace_ext_prefix+0x2e>
 1107fa4:	91026884 	add	x4, x4, #0x9a
 1107fa8:	9400f367 	bl	1144d44 <trace_printf>
	IMSG("Primary CPU initializing");
 1107fac:	aa1303e0 	mov	x0, x19
 1107fb0:	52800023 	mov	w3, #0x1                   	// #1
 1107fb4:	52800042 	mov	w2, #0x2                   	// #2
 1107fb8:	52809aa1 	mov	w1, #0x4d5                 	// #1237
 1107fbc:	f0000244 	adrp	x4, 1152000 <trace_ext_prefix+0x2e>
 1107fc0:	9102b484 	add	x4, x4, #0xad
 1107fc4:	9400f360 	bl	1144d44 <trace_printf>
#ifdef CFG_CORE_ASLR
	DMSG("Executing at offset %#lx with virtual load address %#"PRIxVA,
 1107fc8:	f941ce80 	ldr	x0, [x20, #920]
 1107fcc:	f0000244 	adrp	x4, 1152000 <trace_ext_prefix+0x2e>
 1107fd0:	f9414286 	ldr	x6, [x20, #640]
 1107fd4:	91031884 	add	x4, x4, #0xc6
 1107fd8:	f9401005 	ldr	x5, [x0, #32]
 1107fdc:	aa1303e0 	mov	x0, x19
 1107fe0:	52800023 	mov	w3, #0x1                   	// #1
 1107fe4:	52800062 	mov	w2, #0x3                   	// #3
 1107fe8:	52809ae1 	mov	w1, #0x4d7                 	// #1239
 1107fec:	9400f356 	bl	1144d44 <trace_printf>
	     (unsigned long)boot_mmu_config.load_offset, VCORE_START_VA);
#endif

	main_init_gic();
 1107ff0:	94001414 	bl	110d040 <main_init_gic>
	init_vfp_nsec();
#ifndef CFG_VIRTUALIZATION
	init_tee_runtime();
 1107ff4:	97ffff9e 	bl	1107e6c <init_tee_runtime>
#endif
#ifdef CFG_VIRTUALIZATION
	IMSG("Initializing virtualization support");
	core_mmu_init_virtualization();
#endif
	call_finalcalls();
 1107ff8:	94003369 	bl	1114d9c <call_finalcalls>
	IMSG("Primary CPU switching to normal world boot");
 1107ffc:	aa1303e0 	mov	x0, x19
 1108000:	d0000244 	adrp	x4, 1152000 <trace_ext_prefix+0x2e>
}
 1108004:	a94153f3 	ldp	x19, x20, [sp, #16]
	IMSG("Primary CPU switching to normal world boot");
 1108008:	9103f884 	add	x4, x4, #0xfe
}
 110800c:	f94013f5 	ldr	x21, [sp, #32]
	IMSG("Primary CPU switching to normal world boot");
 1108010:	52800023 	mov	w3, #0x1                   	// #1
}
 1108014:	a8c37bfd 	ldp	x29, x30, [sp], #48
	IMSG("Primary CPU switching to normal world boot");
 1108018:	52800042 	mov	w2, #0x2                   	// #2
 110801c:	52809ca1 	mov	w1, #0x4e5                 	// #1253
 1108020:	1400f349 	b	1144d44 <trace_printf>

0000000001108024 <boot_init_primary_early>:
 * Note: this function is weak just to make it possible to exclude it from
 * the unpaged area so that it lies in the init area.
 */
void __weak boot_init_primary_early(unsigned long pageable_part,
				    unsigned long nsec_entry __maybe_unused)
{
 1108024:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	thread_set_exceptions(THREAD_EXCP_ALL);
 1108028:	528000e0 	mov	w0, #0x7                   	// #7
{
 110802c:	910003fd 	mov	x29, sp
	thread_set_exceptions(THREAD_EXCP_ALL);
 1108030:	97fff429 	bl	11050d4 <thread_set_exceptions>
	vfp_disable();
 1108034:	97fffed8 	bl	1107b94 <vfp_disable>
	thread_get_core_local()->curr_thread = 0;
 1108038:	97fff44f 	bl	1105174 <thread_get_core_local>
 110803c:	7900501f 	strh	wzr, [x0, #40]
	malloc_add_pool(__heap1_start, __heap1_end - __heap1_start);
 1108040:	d0000280 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1108044:	f9420001 	ldr	x1, [x0, #1024]
 1108048:	f941a800 	ldr	x0, [x0, #848]
 110804c:	cb000021 	sub	x1, x1, x0
 1108050:	9400ed68 	bl	11435f0 <malloc_add_pool>
	IMSG_RAW("\n");
 1108054:	d0000244 	adrp	x4, 1152000 <trace_ext_prefix+0x2e>
 1108058:	9104a484 	add	x4, x4, #0x129
 110805c:	52800023 	mov	w3, #0x1                   	// #1
 1108060:	52800042 	mov	w2, #0x2                   	// #2
 1108064:	52800001 	mov	w1, #0x0                   	// #0
 1108068:	d2800000 	mov	x0, #0x0                   	// #0
 110806c:	9400f336 	bl	1144d44 <trace_printf>
		thread_init_boot_thread();
 1108070:	97fff622 	bl	11058f8 <thread_init_boot_thread>
	thread_init_primary();
 1108074:	97fff640 	bl	1105974 <thread_init_primary>
#if !defined(CFG_WITH_ARM_TRUSTED_FW)
	e = nsec_entry;
#endif

	init_primary(pageable_part, e);
}
 1108078:	a8c17bfd 	ldp	x29, x30, [sp], #16
	thread_init_per_cpu();
 110807c:	17fff67f 	b	1105a78 <thread_init_per_cpu>

0000000001108080 <boot_cpu_on_handler>:

#if defined(CFG_WITH_ARM_TRUSTED_FW)
unsigned long boot_cpu_on_handler(unsigned long a0 __maybe_unused,
				  unsigned long a1 __unused)
{
 1108080:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1108084:	910003fd 	mov	x29, sp
 1108088:	f9000bf3 	str	x19, [sp, #16]
	IMSG("Secondary CPU %zu initializing", get_core_pos());
 110808c:	97ffff69 	bl	1107e30 <get_core_pos>
 1108090:	d0000253 	adrp	x19, 1152000 <trace_ext_prefix+0x2e>
 1108094:	91072a73 	add	x19, x19, #0x1ca
 1108098:	aa0003e5 	mov	x5, x0
 110809c:	52800023 	mov	w3, #0x1                   	// #1
 11080a0:	52800042 	mov	w2, #0x2                   	// #2
 11080a4:	52809d41 	mov	w1, #0x4ea                 	// #1258
 11080a8:	aa1303e0 	mov	x0, x19
 11080ac:	d0000244 	adrp	x4, 1152000 <trace_ext_prefix+0x2e>
 11080b0:	9104ac84 	add	x4, x4, #0x12b
 11080b4:	9400f324 	bl	1144d44 <trace_printf>
	thread_set_exceptions(THREAD_EXCP_ALL);
 11080b8:	528000e0 	mov	w0, #0x7                   	// #7
 11080bc:	97fff406 	bl	11050d4 <thread_set_exceptions>
	thread_init_per_cpu();
 11080c0:	97fff66e 	bl	1105a78 <thread_init_per_cpu>
	main_secondary_init_gic();
 11080c4:	940013ff 	bl	110d0c0 <main_secondary_init_gic>
	vfp_disable();
 11080c8:	97fffeb3 	bl	1107b94 <vfp_disable>
	IMSG("Secondary CPU %zu switching to normal world boot", get_core_pos());
 11080cc:	97ffff59 	bl	1107e30 <get_core_pos>
 11080d0:	aa0003e5 	mov	x5, x0
 11080d4:	52800023 	mov	w3, #0x1                   	// #1
 11080d8:	aa1303e0 	mov	x0, x19
 11080dc:	52800042 	mov	w2, #0x2                   	// #2
 11080e0:	52809f81 	mov	w1, #0x4fc                 	// #1276
 11080e4:	d0000244 	adrp	x4, 1152000 <trace_ext_prefix+0x2e>
 11080e8:	91052884 	add	x4, x4, #0x14a
 11080ec:	9400f316 	bl	1144d44 <trace_printf>
	init_secondary_helper(PADDR_INVALID);
	return 0;
}
 11080f0:	d2800000 	mov	x0, #0x0                   	// #0
 11080f4:	f9400bf3 	ldr	x19, [sp, #16]
 11080f8:	a8c27bfd 	ldp	x29, x30, [sp], #32
 11080fc:	d65f03c0 	ret

0000000001108100 <get_aslr_seed>:

	return fdt64_to_cpu(*seed);
}
#else /*!CFG_DT*/
unsigned long __weak get_aslr_seed(void *fdt __unused)
{
 1108100:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	DMSG("Warning: no ASLR seed");
 1108104:	52800023 	mov	w3, #0x1                   	// #1
 1108108:	52800062 	mov	w2, #0x3                   	// #3
{
 110810c:	910003fd 	mov	x29, sp
	DMSG("Warning: no ASLR seed");
 1108110:	5280ac81 	mov	w1, #0x564                 	// #1380
 1108114:	d0000244 	adrp	x4, 1152000 <trace_ext_prefix+0x2e>
 1108118:	d0000240 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 110811c:	9105ec84 	add	x4, x4, #0x17b
 1108120:	91078000 	add	x0, x0, #0x1e0
 1108124:	9400f308 	bl	1144d44 <trace_printf>
	return 0;
}
 1108128:	d2800000 	mov	x0, #0x0                   	// #0
 110812c:	a8c17bfd 	ldp	x29, x30, [sp], #16
 1108130:	d65f03c0 	ret

0000000001108134 <relocate>:
	adr_l	x6, __end
 1108134:	d0000446 	adrp	x6, 1192000 <stack_tmp+0x1d80>
 1108138:	910e00c6 	add	x6, x6, #0x380
	ldp	w2, w3, [x6, #BOOT_EMBDATA_RELOC_OFFSET]
 110813c:	29420cc2 	ldp	w2, w3, [x6, #16]
	mov_imm	x1, TEE_RAM_START
 1108140:	d2a02201 	mov	x1, #0x1100000             	// #17825792
 1108144:	f2800001 	movk	x1, #0x0
	add	x2, x2, x6	/* start of relocations */
 1108148:	8b060042 	add	x2, x2, x6
	add	x3, x3, x2	/* end of relocations */
 110814c:	8b020063 	add	x3, x3, x2
	b	2f
 1108150:	14000006 	b	1108168 <relocate+0x34>
1:	ldr	w4, [x2], #4
 1108154:	b8404444 	ldr	w4, [x2], #4
	add	x4, x4, x1
 1108158:	8b010084 	add	x4, x4, x1
	ldr	x5, [x4]
 110815c:	f9400085 	ldr	x5, [x4]
	add	x5, x5, x0
 1108160:	8b0000a5 	add	x5, x5, x0
	str	x5, [x4]
 1108164:	f9000085 	str	x5, [x4]
2:	cmp	x2, x3
 1108168:	eb03005f 	cmp	x2, x3
	b.ne	1b
 110816c:	54ffff41 	b.ne	1108154 <relocate+0x20>  // b.any
	ret
 1108170:	d65f03c0 	ret

0000000001108174 <cpu_on_handler>:
	mov	x19, x0
 1108174:	aa0003f3 	mov	x19, x0
	mov	x20, x1
 1108178:	aa0103f4 	mov	x20, x1
	mov	x21, x30
 110817c:	aa1e03f5 	mov	x21, x30
	adr	x0, reset_vect_table
 1108180:	10fc7400 	adr	x0, 1101000 <reset_vect_table>
	msr	vbar_el1, x0
 1108184:	d518c000 	msr	vbar_el1, x0
	isb
 1108188:	d5033fdf 	isb
	set_sctlr_el1
 110818c:	d5381000 	mrs	x0, sctlr_el1
 1108190:	b2740000 	orr	x0, x0, #0x1000
 1108194:	b27d0000 	orr	x0, x0, #0x8
 1108198:	b2690000 	orr	x0, x0, #0x800000
 110819c:	b26d0000 	orr	x0, x0, #0x80000
 11081a0:	927ef800 	and	x0, x0, #0xfffffffffffffffd
 11081a4:	d5181000 	msr	sctlr_el1, x0
	isb
 11081a8:	d5033fdf 	isb
	msr	daifclr, #DAIFBIT_ABT
 11081ac:	d50344ff 	msr	daifclr, #0x4
	bl	__get_core_pos
 11081b0:	97ffe5e9 	bl	1101954 <__get_core_pos>
	bl	enable_mmu
 11081b4:	97ffe193 	bl	1100800 <enable_mmu>
	set_sp
 11081b8:	97ffe5e7 	bl	1101954 <__get_core_pos>
 11081bc:	f100101f 	cmp	x0, #0x4
 11081c0:	54fcbdca 	b.ge	1101978 <unhandled_cpu>  // b.tcont
 11081c4:	10fcbc61 	adr	x1, 1101950 <stack_tmp_stride>
 11081c8:	b9400021 	ldr	w1, [x1]
 11081cc:	9b017c01 	mul	x1, x0, x1
 11081d0:	b0ffffc0 	adrp	x0, 1101000 <reset_vect_table>
 11081d4:	911e2000 	add	x0, x0, #0x788
 11081d8:	f9400000 	ldr	x0, [x0]
 11081dc:	d50040bf 	msr	spsel, #0x0
 11081e0:	8b20603f 	add	sp, x1, x0
 11081e4:	97fff3e4 	bl	1105174 <thread_get_core_local>
 11081e8:	d50041bf 	msr	spsel, #0x1
 11081ec:	9100001f 	mov	sp, x0
 11081f0:	d50040bf 	msr	spsel, #0x0
	mov	x0, x19
 11081f4:	aa1303e0 	mov	x0, x19
	mov	x1, x20
 11081f8:	aa1403e1 	mov	x1, x20
	mov	x30, x21
 11081fc:	aa1503fe 	mov	x30, x21
	b	boot_cpu_on_handler
 1108200:	17ffffa0 	b	1108080 <boot_cpu_on_handler>

0000000001108204 <print_kernel_stack>:
	return NULL;
}

#if defined(CFG_UNWIND) && (TRACE_LEVEL > 0)
void print_kernel_stack(void)
{
 1108204:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 1108208:	910003fd 	mov	x29, sp
	struct unwind_state_arm64 state = { };
	vaddr_t stack_start = 0;
	vaddr_t stack_end = 0;
 110820c:	a901ffff 	stp	xzr, xzr, [sp, #24]
	struct unwind_state_arm64 state = { };
 1108210:	f9001bff 	str	xzr, [sp, #48]
	asm volatile ("adr %0, ." : "=r" (val));
 1108214:	10000000 	adr	x0, 1108214 <print_kernel_stack+0x10>

	state.pc = read_pc();
 1108218:	f9001fe0 	str	x0, [sp, #56]
	asm volatile ("mov %0, x29" : "=r" (val));
 110821c:	aa1d03e0 	mov	x0, x29
	state.fp = read_fp();

	trace_printf_helper_raw(TRACE_ERROR, true,
 1108220:	d0000285 	adrp	x5, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1108224:	b0000244 	adrp	x4, 1151000 <small_prime+0x168>
 1108228:	91359c84 	add	x4, x4, #0xd67
 110822c:	52800023 	mov	w3, #0x1                   	// #1
 1108230:	f94140a5 	ldr	x5, [x5, #640]
 1108234:	52800022 	mov	w2, #0x1                   	// #1
 1108238:	52800001 	mov	w1, #0x0                   	// #0
	state.fp = read_fp();
 110823c:	f90017e0 	str	x0, [sp, #40]
	trace_printf_helper_raw(TRACE_ERROR, true,
 1108240:	d2800000 	mov	x0, #0x0                   	// #0
 1108244:	9400f2c0 	bl	1144d44 <trace_printf>
}

static inline bool __nostackcheck get_stack_hard_limits(vaddr_t *start,
							vaddr_t *end)
{
	return get_stack_limits(start, end, true);
 1108248:	910083e1 	add	x1, sp, #0x20
 110824c:	910063e0 	add	x0, sp, #0x18
 1108250:	52800022 	mov	w2, #0x1                   	// #1
 1108254:	97fff412 	bl	110529c <get_stack_limits>
				"TEE load address @ %#"PRIxVA, VCORE_START_VA);
	get_stack_hard_limits(&stack_start, &stack_end);
	print_stack_arm64(&state, stack_start, stack_end - stack_start);
 1108258:	a9418be1 	ldp	x1, x2, [sp, #24]
 110825c:	9100a3e0 	add	x0, sp, #0x28
 1108260:	cb010042 	sub	x2, x2, x1
 1108264:	94007f5b 	bl	1127fd0 <print_stack_arm64>
}
 1108268:	a8c47bfd 	ldp	x29, x30, [sp], #64
 110826c:	d65f03c0 	ret

0000000001108270 <va_is_in_map>:
	return (pa >= map->pa && pa <= (map->pa + map->size - 1));
}

static bool va_is_in_map(struct tee_mmap_region *map, vaddr_t va)
{
	if (!map)
 1108270:	b4000140 	cbz	x0, 1108298 <va_is_in_map+0x28>
		return false;
	return (va >= map->va && va <= (map->va + map->size - 1));
 1108274:	f9400802 	ldr	x2, [x0, #16]
 1108278:	eb01005f 	cmp	x2, x1
 110827c:	540000e8 	b.hi	1108298 <va_is_in_map+0x28>  // b.pmore
 1108280:	f9400c00 	ldr	x0, [x0, #24]
 1108284:	8b000042 	add	x2, x2, x0
 1108288:	d1000442 	sub	x2, x2, #0x1
 110828c:	eb01005f 	cmp	x2, x1
 1108290:	1a9f37e0 	cset	w0, cs  // cs = hs, nlast
}
 1108294:	d65f03c0 	ret
		return false;
 1108298:	52800000 	mov	w0, #0x0                   	// #0
 110829c:	17fffffe 	b	1108294 <va_is_in_map+0x24>

00000000011082a0 <find_map_by_va>:
	}
	return NULL;
}

static struct tee_mmap_region *find_map_by_va(void *va)
{
 11082a0:	aa0003e2 	mov	x2, x0
	struct tee_mmap_region *map = get_memory_map();
 11082a4:	b00002a1 	adrp	x1, 115d000 <_curve_names+0x590>
 11082a8:	91308020 	add	x0, x1, #0xc20
	unsigned long a = (unsigned long)va;

	while (!core_mmap_is_end_of_table(map)) {
 11082ac:	b9400001 	ldr	w1, [x0]
 11082b0:	35000061 	cbnz	w1, 11082bc <find_map_by_va+0x1c>
		if ((a >= map->va) && (a <= (map->va - 1 + map->size)))
			return map;
		map++;
	}
	return NULL;
 11082b4:	d2800000 	mov	x0, #0x0                   	// #0
}
 11082b8:	d65f03c0 	ret
		if ((a >= map->va) && (a <= (map->va - 1 + map->size)))
 11082bc:	f9400801 	ldr	x1, [x0, #16]
 11082c0:	eb02003f 	cmp	x1, x2
 11082c4:	540000c8 	b.hi	11082dc <find_map_by_va+0x3c>  // b.pmore
 11082c8:	f9400c03 	ldr	x3, [x0, #24]
 11082cc:	8b030021 	add	x1, x1, x3
 11082d0:	d1000421 	sub	x1, x1, #0x1
 11082d4:	eb02003f 	cmp	x1, x2
 11082d8:	54ffff02 	b.cs	11082b8 <find_map_by_va+0x18>  // b.hs, b.nlast
		map++;
 11082dc:	9100a000 	add	x0, x0, #0x28
 11082e0:	17fffff3 	b	11082ac <find_map_by_va+0xc>

00000000011082e4 <find_map_by_pa>:

static struct tee_mmap_region *find_map_by_pa(unsigned long pa)
{
 11082e4:	aa0003e2 	mov	x2, x0
	struct tee_mmap_region *map = get_memory_map();
 11082e8:	b00002a1 	adrp	x1, 115d000 <_curve_names+0x590>
 11082ec:	91308020 	add	x0, x1, #0xc20

	while (!core_mmap_is_end_of_table(map)) {
 11082f0:	b9400001 	ldr	w1, [x0]
 11082f4:	35000061 	cbnz	w1, 1108300 <find_map_by_pa+0x1c>
		if ((pa >= map->pa) && (pa < (map->pa + map->size)))
			return map;
		map++;
	}
	return NULL;
 11082f8:	d2800000 	mov	x0, #0x0                   	// #0
}
 11082fc:	d65f03c0 	ret
		if ((pa >= map->pa) && (pa < (map->pa + map->size)))
 1108300:	f9400401 	ldr	x1, [x0, #8]
 1108304:	eb02003f 	cmp	x1, x2
 1108308:	540000a8 	b.hi	110831c <find_map_by_pa+0x38>  // b.pmore
 110830c:	f9400c03 	ldr	x3, [x0, #24]
 1108310:	8b030021 	add	x1, x1, x3
 1108314:	eb02003f 	cmp	x1, x2
 1108318:	54ffff28 	b.hi	11082fc <find_map_by_pa+0x18>  // b.pmore
		map++;
 110831c:	9100a000 	add	x0, x0, #0x28
 1108320:	17fffff4 	b	11082f0 <find_map_by_pa+0xc>

0000000001108324 <cmp_pmem_by_addr>:
static int cmp_pmem_by_addr(const void *a, const void *b)
{
	const struct core_mmu_phys_mem *pmem_a = a;
	const struct core_mmu_phys_mem *pmem_b = b;

	return CMP_TRILEAN(pmem_a->addr, pmem_b->addr);
 1108324:	f9400802 	ldr	x2, [x0, #16]
 1108328:	f9400821 	ldr	x1, [x1, #16]
 110832c:	eb01005f 	cmp	x2, x1
 1108330:	5a9f23e0 	csetm	w0, cc  // cc = lo, ul, last
 1108334:	1a9f9400 	csinc	w0, w0, wzr, ls  // ls = plast
}
 1108338:	d65f03c0 	ret

000000000110833c <cmp_mmap_by_lower_va>:
static int cmp_mmap_by_lower_va(const void *a, const void *b)
{
	const struct tee_mmap_region *mm_a = a;
	const struct tee_mmap_region *mm_b = b;

	return CMP_TRILEAN(mm_a->va, mm_b->va);
 110833c:	f9400802 	ldr	x2, [x0, #16]
 1108340:	f9400821 	ldr	x1, [x1, #16]
 1108344:	eb01005f 	cmp	x2, x1
 1108348:	5a9f23e0 	csetm	w0, cc  // cc = lo, ul, last
 110834c:	1a9f9400 	csinc	w0, w0, wzr, ls  // ls = plast
}
 1108350:	d65f03c0 	ret

0000000001108354 <map_pa2va>:
	if (!map)
 1108354:	b4000180 	cbz	x0, 1108384 <map_pa2va+0x30>
	return (pa >= map->pa && pa <= (map->pa + map->size - 1));
 1108358:	f9400403 	ldr	x3, [x0, #8]
 110835c:	eb03003f 	cmp	x1, x3
 1108360:	54000143 	b.cc	1108388 <map_pa2va+0x34>  // b.lo, b.ul, b.last
 1108364:	f9400c02 	ldr	x2, [x0, #24]
 1108368:	8b020062 	add	x2, x3, x2
 110836c:	d1000442 	sub	x2, x2, #0x1
	return 0;
}

static void *map_pa2va(struct tee_mmap_region *map, paddr_t pa)
{
	if (!pa_is_in_map(map, pa))
 1108370:	eb02003f 	cmp	x1, x2
 1108374:	540000a8 	b.hi	1108388 <map_pa2va+0x34>  // b.pmore
		return NULL;

	return (void *)(vaddr_t)(map->va + pa - map->pa);
 1108378:	f9400800 	ldr	x0, [x0, #16]
 110837c:	8b000020 	add	x0, x1, x0
 1108380:	cb030000 	sub	x0, x0, x3
}
 1108384:	d65f03c0 	ret
		return NULL;
 1108388:	d2800000 	mov	x0, #0x0                   	// #0
 110838c:	17fffffe 	b	1108384 <map_pa2va+0x30>

0000000001108390 <carve_out_phys_mem>:
{
 1108390:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
 1108394:	910003fd 	mov	x29, sp
 1108398:	a9046bf9 	stp	x25, x26, [sp, #64]
	struct core_mmu_phys_mem *m = *mem;
 110839c:	f940001a 	ldr	x26, [x0]
{
 11083a0:	a90153f3 	stp	x19, x20, [sp, #16]
 11083a4:	aa0203f3 	mov	x19, x2
 11083a8:	aa1a03f4 	mov	x20, x26
 11083ac:	a9025bf5 	stp	x21, x22, [sp, #32]
 11083b0:	aa0303f6 	mov	x22, x3
 11083b4:	a90363f7 	stp	x23, x24, [sp, #48]
 11083b8:	aa0003f8 	mov	x24, x0
 11083bc:	aa0103f7 	mov	x23, x1
	size_t n = 0;
 11083c0:	d2800015 	mov	x21, #0x0                   	// #0
{
 11083c4:	f9002bfb 	str	x27, [sp, #80]
		if (n >= *nelems) {
 11083c8:	f94002e0 	ldr	x0, [x23]
 11083cc:	eb15001f 	cmp	x0, x21
 11083d0:	54000228 	b.hi	1108414 <carve_out_phys_mem+0x84>  // b.pmore
			DMSG("No need to carve out %#" PRIxPA " size %#zx",
 11083d4:	aa1603e6 	mov	x6, x22
 11083d8:	aa1303e5 	mov	x5, x19
}
 11083dc:	a94153f3 	ldp	x19, x20, [sp, #16]
			DMSG("No need to carve out %#" PRIxPA " size %#zx",
 11083e0:	d0000244 	adrp	x4, 1152000 <trace_ext_prefix+0x2e>
}
 11083e4:	a9425bf5 	ldp	x21, x22, [sp, #32]
			DMSG("No need to carve out %#" PRIxPA " size %#zx",
 11083e8:	9107b884 	add	x4, x4, #0x1ee
}
 11083ec:	a94363f7 	ldp	x23, x24, [sp, #48]
			DMSG("No need to carve out %#" PRIxPA " size %#zx",
 11083f0:	52800023 	mov	w3, #0x1                   	// #1
}
 11083f4:	a9446bf9 	ldp	x25, x26, [sp, #64]
			DMSG("No need to carve out %#" PRIxPA " size %#zx",
 11083f8:	52800062 	mov	w2, #0x3                   	// #3
}
 11083fc:	f9402bfb 	ldr	x27, [sp, #80]
			DMSG("No need to carve out %#" PRIxPA " size %#zx",
 1108400:	52802481 	mov	w1, #0x124                 	// #292
}
 1108404:	a8c67bfd 	ldp	x29, x30, [sp], #96
			DMSG("No need to carve out %#" PRIxPA " size %#zx",
 1108408:	d0000240 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 110840c:	912bd000 	add	x0, x0, #0xaf4
 1108410:	1400f24d 	b	1144d44 <trace_printf>
		if (core_is_buffer_inside(pa, size, m[n].addr, m[n].size))
 1108414:	a9410e82 	ldp	x2, x3, [x20, #16]
 1108418:	aa1603e1 	mov	x1, x22
 110841c:	aa1303e0 	mov	x0, x19
 1108420:	d37beab9 	lsl	x25, x21, #5
 1108424:	94002c86 	bl	111363c <core_is_buffer_inside>
 1108428:	72001c1f 	tst	w0, #0xff
 110842c:	54000221 	b.ne	1108470 <carve_out_phys_mem+0xe0>  // b.any
		if (!core_is_buffer_outside(pa, size, m[n].addr, m[n].size))
 1108430:	a9410e82 	ldp	x2, x3, [x20, #16]
 1108434:	aa1603e1 	mov	x1, x22
 1108438:	aa1303e0 	mov	x0, x19
 110843c:	91008294 	add	x20, x20, #0x20
 1108440:	94002c91 	bl	1113684 <core_is_buffer_outside>
 1108444:	72001c1f 	tst	w0, #0xff
 1108448:	54000101 	b.ne	1108468 <carve_out_phys_mem+0xd8>  // b.any
			panic();
 110844c:	d0000242 	adrp	x2, 1152000 <trace_ext_prefix+0x2e>
 1108450:	912bd042 	add	x2, x2, #0xaf4
 1108454:	d2800003 	mov	x3, #0x0                   	// #0
 1108458:	52802561 	mov	w1, #0x12b                 	// #299
			panic();
 110845c:	d0000240 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 1108460:	91084800 	add	x0, x0, #0x212
 1108464:	94002c01 	bl	1113468 <__do_panic>
		n++;
 1108468:	910006b5 	add	x21, x21, #0x1
		if (n >= *nelems) {
 110846c:	17ffffd7 	b	11083c8 <carve_out_phys_mem+0x38>
	if (pa == m[n].addr && size == m[n].size) {
 1108470:	a9410e80 	ldp	x0, x3, [x20, #16]
 1108474:	eb13001f 	cmp	x0, x19
 1108478:	54000461 	b.ne	1108504 <carve_out_phys_mem+0x174>  // b.any
 110847c:	eb16007f 	cmp	x3, x22
 1108480:	54000381 	b.ne	11084f0 <carve_out_phys_mem+0x160>  // b.any
		(*nelems)--;
 1108484:	f94002e2 	ldr	x2, [x23]
		memmove(m + n, m + n + 1, sizeof(*m) * (*nelems - n));
 1108488:	910006a1 	add	x1, x21, #0x1
 110848c:	aa1403e0 	mov	x0, x20
		(*nelems)--;
 1108490:	d1000442 	sub	x2, x2, #0x1
 1108494:	f90002e2 	str	x2, [x23]
		memmove(m + n, m + n + 1, sizeof(*m) * (*nelems - n));
 1108498:	cb150042 	sub	x2, x2, x21
 110849c:	8b011741 	add	x1, x26, x1, lsl #5
 11084a0:	d37be842 	lsl	x2, x2, #5
 11084a4:	9400edf8 	bl	1143c84 <memmove>
		m = nex_realloc(m, sizeof(*m) * *nelems);
 11084a8:	f94002e1 	ldr	x1, [x23]
 11084ac:	aa1a03e0 	mov	x0, x26
 11084b0:	d37be821 	lsl	x1, x1, #5
 11084b4:	9400ec2b 	bl	1143560 <realloc>
		if (!m)
 11084b8:	b50000c0 	cbnz	x0, 11084d0 <carve_out_phys_mem+0x140>
			panic();
 11084bc:	d0000242 	adrp	x2, 1152000 <trace_ext_prefix+0x2e>
 11084c0:	d2800003 	mov	x3, #0x0                   	// #0
 11084c4:	912bd042 	add	x2, x2, #0xaf4
 11084c8:	528026a1 	mov	w1, #0x135                 	// #309
 11084cc:	17ffffe4 	b	110845c <carve_out_phys_mem+0xcc>
		*mem = m;
 11084d0:	f9000300 	str	x0, [x24]
}
 11084d4:	a94153f3 	ldp	x19, x20, [sp, #16]
 11084d8:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11084dc:	a94363f7 	ldp	x23, x24, [sp, #48]
 11084e0:	a9446bf9 	ldp	x25, x26, [sp, #64]
 11084e4:	f9402bfb 	ldr	x27, [sp, #80]
 11084e8:	a8c67bfd 	ldp	x29, x30, [sp], #96
 11084ec:	d65f03c0 	ret
		m[n].addr += size;
 11084f0:	8b160273 	add	x19, x19, x22
 11084f4:	f9000a93 	str	x19, [x20, #16]
		m[n].size -= size;
 11084f8:	cb160076 	sub	x22, x3, x22
 11084fc:	f9000e96 	str	x22, [x20, #24]
 1108500:	17fffff5 	b	11084d4 <carve_out_phys_mem+0x144>
	} else if ((pa + size) == (m[n].addr + m[n].size)) {
 1108504:	8b16027b 	add	x27, x19, x22
 1108508:	8b030000 	add	x0, x0, x3
 110850c:	eb00037f 	cmp	x27, x0
 1108510:	54ffff40 	b.eq	11084f8 <carve_out_phys_mem+0x168>  // b.none
		m = nex_realloc(m, sizeof(*m) * (*nelems + 1));
 1108514:	f94002e1 	ldr	x1, [x23]
 1108518:	aa1a03e0 	mov	x0, x26
 110851c:	91000421 	add	x1, x1, #0x1
 1108520:	d37be821 	lsl	x1, x1, #5
 1108524:	9400ec0f 	bl	1143560 <realloc>
		if (!m)
 1108528:	b50000c0 	cbnz	x0, 1108540 <carve_out_phys_mem+0x1b0>
			panic();
 110852c:	d0000242 	adrp	x2, 1152000 <trace_ext_prefix+0x2e>
 1108530:	d2800003 	mov	x3, #0x0                   	// #0
 1108534:	912bd042 	add	x2, x2, #0xaf4
 1108538:	52802801 	mov	w1, #0x140                 	// #320
 110853c:	17ffffc8 	b	110845c <carve_out_phys_mem+0xcc>
		memmove(m + n + 1, m + n, sizeof(*m) * (*nelems - n));
 1108540:	910006a3 	add	x3, x21, #0x1
 1108544:	8b190019 	add	x25, x0, x25
 1108548:	f94002e2 	ldr	x2, [x23]
 110854c:	8b031403 	add	x3, x0, x3, lsl #5
		*mem = m;
 1108550:	f9000300 	str	x0, [x24]
		memmove(m + n + 1, m + n, sizeof(*m) * (*nelems - n));
 1108554:	aa1903e1 	mov	x1, x25
 1108558:	cb150042 	sub	x2, x2, x21
 110855c:	aa0303e0 	mov	x0, x3
 1108560:	d37be842 	lsl	x2, x2, #5
 1108564:	9400edc8 	bl	1143c84 <memmove>
 1108568:	aa0003e3 	mov	x3, x0
		(*nelems)++;
 110856c:	f94002e0 	ldr	x0, [x23]
 1108570:	91000400 	add	x0, x0, #0x1
 1108574:	f90002e0 	str	x0, [x23]
		m[n].size = pa - m[n].addr;
 1108578:	f9400b20 	ldr	x0, [x25, #16]
 110857c:	cb000273 	sub	x19, x19, x0
 1108580:	f9000f33 	str	x19, [x25, #24]
		m[n + 1].size -= size + m[n].size;
 1108584:	f9400c61 	ldr	x1, [x3, #24]
 1108588:	8b010000 	add	x0, x0, x1
 110858c:	cb1b0000 	sub	x0, x0, x27
 1108590:	a901007b 	stp	x27, x0, [x3, #16]
		m[n + 1].addr = pa + size;
 1108594:	17ffffd0 	b	11084d4 <carve_out_phys_mem+0x144>

0000000001108598 <cpu_spin_lock_dldetect>:
{
 1108598:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 110859c:	910003fd 	mov	x29, sp
 11085a0:	a90153f3 	stp	x19, x20, [sp, #16]
 11085a4:	aa0203f4 	mov	x20, x2
 11085a8:	a9025bf5 	stp	x21, x22, [sp, #32]
 11085ac:	aa0003f6 	mov	x22, x0
 11085b0:	a90363f7 	stp	x23, x24, [sp, #48]
 11085b4:	2a0103f7 	mov	w23, w1
 11085b8:	f90023f9 	str	x25, [sp, #64]
	return !!(thread_get_exceptions() & THREAD_EXCP_FOREIGN_INTR);
 11085bc:	97fff256 	bl	1104f14 <thread_get_exceptions>
	assert(thread_foreign_intr_disabled());
 11085c0:	360801e0 	tbz	w0, #1, 11085fc <cpu_spin_lock_dldetect+0x64>
			trace_printf(func, line, TRACE_ERROR, true,
 11085c4:	b0000258 	adrp	x24, 1151000 <small_prime+0x168>
 11085c8:	91131718 	add	x24, x24, #0x4c5
 11085cc:	52800013 	mov	w19, #0x0                   	// #0
		if (!retries) {
 11085d0:	d2c00039 	mov	x25, #0x100000000           	// #4294967296
	unsigned int reminder = 0;
 11085d4:	d2800015 	mov	x21, #0x0                   	// #0
	while (__cpu_spin_trylock(lock)) {
 11085d8:	aa1403e0 	mov	x0, x20
 11085dc:	97ffefb2 	bl	11044a4 <__cpu_spin_trylock>
 11085e0:	35000200 	cbnz	w0, 1108620 <cpu_spin_lock_dldetect+0x88>
}
 11085e4:	a94153f3 	ldp	x19, x20, [sp, #16]
 11085e8:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11085ec:	a94363f7 	ldp	x23, x24, [sp, #48]
 11085f0:	f94023f9 	ldr	x25, [sp, #64]
 11085f4:	a8c57bfd 	ldp	x29, x30, [sp], #80
	spinlock_count_incr();
 11085f8:	17ffefb4 	b	11044c8 <spinlock_count_incr>
	assert(thread_foreign_intr_disabled());
 11085fc:	d0000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 1108600:	b0000241 	adrp	x1, 1151000 <small_prime+0x168>
 1108604:	912aa463 	add	x3, x3, #0xaa9
 1108608:	9111f821 	add	x1, x1, #0x47e
 110860c:	b0000240 	adrp	x0, 1151000 <small_prime+0x168>
 1108610:	91129800 	add	x0, x0, #0x4a6
 1108614:	528006e2 	mov	w2, #0x37                  	// #55
 1108618:	94002725 	bl	11122ac <_assert_log>
 110861c:	94002735 	bl	11122f0 <_assert_break>
		if (!retries) {
 1108620:	910006b5 	add	x21, x21, #0x1
 1108624:	eb1902bf 	cmp	x21, x25
 1108628:	54fffd81 	b.ne	11085d8 <cpu_spin_lock_dldetect+0x40>  // b.any
			trace_printf(func, line, TRACE_ERROR, true,
 110862c:	2a1303e5 	mov	w5, w19
 1108630:	aa1803e4 	mov	x4, x24
 1108634:	2a1703e1 	mov	w1, w23
 1108638:	aa1603e0 	mov	x0, x22
 110863c:	52800023 	mov	w3, #0x1                   	// #1
 1108640:	52800022 	mov	w2, #0x1                   	// #1
 1108644:	9400f1c0 	bl	1144d44 <trace_printf>
			if (reminder < UINT_MAX)
 1108648:	3100067f 	cmn	w19, #0x1
 110864c:	54fffc40 	b.eq	11085d4 <cpu_spin_lock_dldetect+0x3c>  // b.none
				reminder++;
 1108650:	11000673 	add	w19, w19, #0x1
 1108654:	17ffffe0 	b	11085d4 <cpu_spin_lock_dldetect+0x3c>

0000000001108658 <cmp_init_mem_map>:
	rc = CMP_TRILEAN(mm_a->region_size, mm_b->region_size);
 1108658:	b9400403 	ldr	w3, [x0, #4]
 110865c:	b9400422 	ldr	w2, [x1, #4]
 1108660:	6b02007f 	cmp	w3, w2
 1108664:	54000108 	b.hi	1108684 <cmp_init_mem_map+0x2c>  // b.pmore
 1108668:	54000123 	b.cc	110868c <cmp_init_mem_map+0x34>  // b.lo, b.ul, b.last
		rc = CMP_TRILEAN(mm_a->pa, mm_b->pa);
 110866c:	f9400402 	ldr	x2, [x0, #8]
 1108670:	f9400421 	ldr	x1, [x1, #8]
 1108674:	eb01005f 	cmp	x2, x1
 1108678:	5a9f23e0 	csetm	w0, cc  // cc = lo, ul, last
 110867c:	1a9f9400 	csinc	w0, w0, wzr, ls  // ls = plast
}
 1108680:	d65f03c0 	ret
	rc = CMP_TRILEAN(mm_a->region_size, mm_b->region_size);
 1108684:	52800020 	mov	w0, #0x1                   	// #1
 1108688:	17fffffe 	b	1108680 <cmp_init_mem_map+0x28>
 110868c:	12800000 	mov	w0, #0xffffffff            	// #-1
 1108690:	17fffffc 	b	1108680 <cmp_init_mem_map+0x28>

0000000001108694 <to_user_mode_ctx>:
{
 1108694:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1108698:	910003fd 	mov	x29, sp
 110869c:	f9000bf3 	str	x19, [sp, #16]
 11086a0:	aa0003f3 	mov	x19, x0
	if (is_user_ta_ctx(ctx))
 11086a4:	940036d2 	bl	11161ec <is_user_ta_ctx>
 11086a8:	72001c1f 	tst	w0, #0xff
 11086ac:	54000240 	b.eq	11086f4 <to_user_mode_ctx+0x60>  // b.none
 11086b0:	aa1303e0 	mov	x0, x19
 11086b4:	940036ce 	bl	11161ec <is_user_ta_ctx>
 11086b8:	72001c1f 	tst	w0, #0xff
 11086bc:	54000141 	b.ne	11086e4 <to_user_mode_ctx+0x50>  // b.any
 11086c0:	d0000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 11086c4:	b0000241 	adrp	x1, 1151000 <small_prime+0x168>
 11086c8:	b0000240 	adrp	x0, 1151000 <small_prime+0x168>
 11086cc:	912b7063 	add	x3, x3, #0xadc
 11086d0:	91081021 	add	x1, x1, #0x204
 11086d4:	91088800 	add	x0, x0, #0x222
 11086d8:	52800702 	mov	w2, #0x38                  	// #56
 11086dc:	940026f4 	bl	11122ac <_assert_log>
 11086e0:	94002704 	bl	11122f0 <_assert_break>
		return &to_user_ta_ctx(ctx)->uctx;
 11086e4:	d10a6260 	sub	x0, x19, #0x298
	else if (is_sp_ctx(ctx))
		return &to_sp_ctx(ctx)->uctx;
	else
		return &to_stmm_ctx(ctx)->uctx;
}
 11086e8:	f9400bf3 	ldr	x19, [sp, #16]
 11086ec:	a8c27bfd 	ldp	x29, x30, [sp], #32
 11086f0:	d65f03c0 	ret
 11086f4:	d0000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 11086f8:	b0000241 	adrp	x1, 1151000 <small_prime+0x168>
 11086fc:	b0000240 	adrp	x0, 1151000 <small_prime+0x168>
 1108700:	912b4063 	add	x3, x3, #0xad0
 1108704:	913a8421 	add	x1, x1, #0xea1
 1108708:	913b2000 	add	x0, x0, #0xec8
 110870c:	52801322 	mov	w2, #0x99                  	// #153
 1108710:	17fffff3 	b	11086dc <to_user_mode_ctx+0x48>

0000000001108714 <add_va_space.constprop.0>:
static void add_va_space(struct tee_mmap_region *memory_map, size_t num_elems,
 1108714:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
	DMSG("type %s size 0x%08zx", teecore_memtype_name(type), size);
 1108718:	aa0203e6 	mov	x6, x2
 110871c:	d0000244 	adrp	x4, 1152000 <trace_ext_prefix+0x2e>
static void add_va_space(struct tee_mmap_region *memory_map, size_t num_elems,
 1108720:	910003fd 	mov	x29, sp
 1108724:	a9025bf5 	stp	x21, x22, [sp, #32]
 1108728:	2a0103f5 	mov	w21, w1
 110872c:	aa0303f6 	mov	x22, x3
 1108730:	a90363f7 	stp	x23, x24, [sp, #48]
 1108734:	aa0003f8 	mov	x24, x0
	DMSG("type %s size 0x%08zx", teecore_memtype_name(type), size);
 1108738:	f0000280 	adrp	x0, 115b000 <__vcore_unpg_rw_start>
 110873c:	91004000 	add	x0, x0, #0x10
 1108740:	52800023 	mov	w3, #0x1                   	// #1
static void add_va_space(struct tee_mmap_region *memory_map, size_t num_elems,
 1108744:	aa0203f7 	mov	x23, x2
	DMSG("type %s size 0x%08zx", teecore_memtype_name(type), size);
 1108748:	9108b884 	add	x4, x4, #0x22e
 110874c:	52800062 	mov	w2, #0x3                   	// #3
 1108750:	52804b81 	mov	w1, #0x25c                 	// #604
 1108754:	f8755805 	ldr	x5, [x0, w21, uxtw #3]
static void add_va_space(struct tee_mmap_region *memory_map, size_t num_elems,
 1108758:	a90153f3 	stp	x19, x20, [sp, #16]
	DMSG("type %s size 0x%08zx", teecore_memtype_name(type), size);
 110875c:	d0000254 	adrp	x20, 1152000 <trace_ext_prefix+0x2e>
 1108760:	912d3e80 	add	x0, x20, #0xb4f
 1108764:	aa1803f3 	mov	x19, x24
 1108768:	9400f177 	bl	1144d44 <trace_printf>
		if (n == *last)
 110876c:	f94002c2 	ldr	x2, [x22]
	size_t n = 0;
 1108770:	d2800003 	mov	x3, #0x0                   	// #0
		if (n == *last)
 1108774:	aa0303e0 	mov	x0, x3
 1108778:	91000463 	add	x3, x3, #0x1
 110877c:	eb00005f 	cmp	x2, x0
 1108780:	540002c0 	b.eq	11087d8 <add_va_space.constprop.0+0xc4>  // b.none
		if (type < memory_map[n].type)
 1108784:	b9400261 	ldr	w1, [x19]
 1108788:	6b0102bf 	cmp	w21, w1
 110878c:	54000263 	b.cc	11087d8 <add_va_space.constprop.0+0xc4>  // b.lo, b.ul, b.last
		if (n >= (num_elems - 1)) {
 1108790:	9100a273 	add	x19, x19, #0x28
 1108794:	f100387f 	cmp	x3, #0xe
 1108798:	54fffee1 	b.ne	1108774 <add_va_space.constprop.0+0x60>  // b.any
			EMSG("Out of entries (%zu) in memory_map", num_elems);
 110879c:	d0000244 	adrp	x4, 1152000 <trace_ext_prefix+0x2e>
 11087a0:	91090c84 	add	x4, x4, #0x243
 11087a4:	912d3e94 	add	x20, x20, #0xb4f
 11087a8:	d28001e5 	mov	x5, #0xf                   	// #15
 11087ac:	aa1403e0 	mov	x0, x20
 11087b0:	52800023 	mov	w3, #0x1                   	// #1
 11087b4:	52800022 	mov	w2, #0x1                   	// #1
 11087b8:	52804be1 	mov	w1, #0x25f                 	// #607
 11087bc:	9400f162 	bl	1144d44 <trace_printf>
			panic();
 11087c0:	d0000240 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 11087c4:	aa1403e2 	mov	x2, x20
 11087c8:	91084800 	add	x0, x0, #0x212
 11087cc:	d2800003 	mov	x3, #0x0                   	// #0
 11087d0:	52804c01 	mov	w1, #0x260                 	// #608
 11087d4:	94002b25 	bl	1113468 <__do_panic>
		sizeof(struct tee_mmap_region) * (*last - n));
 11087d8:	cb000042 	sub	x2, x2, x0
	memmove(memory_map + n + 1, memory_map + n,
 11087dc:	d2800514 	mov	x20, #0x28                  	// #40
 11087e0:	aa1303e1 	mov	x1, x19
 11087e4:	9b146060 	madd	x0, x3, x20, x24
 11087e8:	9b147c42 	mul	x2, x2, x20
 11087ec:	9400ed26 	bl	1143c84 <memmove>
	(*last)++;
 11087f0:	f94002c0 	ldr	x0, [x22]
	memset(memory_map + n, 0, sizeof(memory_map[0]));
 11087f4:	aa1403e2 	mov	x2, x20
 11087f8:	52800001 	mov	w1, #0x0                   	// #0
	(*last)++;
 11087fc:	91000400 	add	x0, x0, #0x1
 1108800:	f90002c0 	str	x0, [x22]
	memset(memory_map + n, 0, sizeof(memory_map[0]));
 1108804:	aa1303e0 	mov	x0, x19
 1108808:	9400ed36 	bl	1143ce0 <memset>
	memory_map[n].type = type;
 110880c:	b9000275 	str	w21, [x19]
	memory_map[n].size = size;
 1108810:	f9000e77 	str	x23, [x19, #24]
}
 1108814:	a94153f3 	ldp	x19, x20, [sp, #16]
 1108818:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110881c:	a94363f7 	ldp	x23, x24, [sp, #48]
 1108820:	a8c47bfd 	ldp	x29, x30, [sp], #64
 1108824:	d65f03c0 	ret

0000000001108828 <_pbuf_is_inside.constprop.0>:
static bool _pbuf_is_inside(struct memaccess_area *a, size_t alen,
 1108828:	aa0003e4 	mov	x4, x0
 110882c:	aa0103e0 	mov	x0, x1
 1108830:	aa0203e1 	mov	x1, x2
		if (core_is_buffer_inside(pa, size, a[n].paddr, a[n].size))
 1108834:	a9400c82 	ldp	x2, x3, [x4]
 1108838:	14002b81 	b	111363c <core_is_buffer_inside>

000000000110883c <mmu_lock>:
{
 110883c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!

static inline uint32_t cpu_spin_lock_xsave_dldetect(const char *func,
						    const int line,
						    unsigned int *lock)
{
	uint32_t exceptions = thread_mask_exceptions(THREAD_EXCP_ALL);
 1108840:	528000e0 	mov	w0, #0x7                   	// #7
 1108844:	910003fd 	mov	x29, sp
 1108848:	f9000bf3 	str	x19, [sp, #16]
 110884c:	97fff23b 	bl	1105138 <thread_mask_exceptions>

	cpu_spin_lock_dldetect(func, line, lock);
 1108850:	528012e1 	mov	w1, #0x97                  	// #151
	uint32_t exceptions = thread_mask_exceptions(THREAD_EXCP_ALL);
 1108854:	2a0003f3 	mov	w19, w0
	cpu_spin_lock_dldetect(func, line, lock);
 1108858:	90000302 	adrp	x2, 1168000 <data.5093+0x9e28>
 110885c:	d0000240 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 1108860:	9128c042 	add	x2, x2, #0xa30
 1108864:	912bac00 	add	x0, x0, #0xaeb
 1108868:	97ffff4c 	bl	1108598 <cpu_spin_lock_dldetect>
}
 110886c:	2a1303e0 	mov	w0, w19
 1108870:	f9400bf3 	ldr	x19, [sp, #16]
 1108874:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1108878:	d65f03c0 	ret

000000000110887c <cpu_spin_unlock>:
{
 110887c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1108880:	910003fd 	mov	x29, sp
 1108884:	f9000bf3 	str	x19, [sp, #16]
 1108888:	aa0003f3 	mov	x19, x0
 110888c:	97fff1a2 	bl	1104f14 <thread_get_exceptions>
	assert(thread_foreign_intr_disabled());
 1108890:	37080140 	tbnz	w0, #1, 11088b8 <cpu_spin_unlock+0x3c>
 1108894:	d0000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 1108898:	b0000241 	adrp	x1, 1151000 <small_prime+0x168>
 110889c:	912b0063 	add	x3, x3, #0xac0
 11088a0:	9111f821 	add	x1, x1, #0x47e
 11088a4:	b0000240 	adrp	x0, 1151000 <small_prime+0x168>
 11088a8:	91129800 	add	x0, x0, #0x4a6
 11088ac:	52800b82 	mov	w2, #0x5c                  	// #92
 11088b0:	9400267f 	bl	11122ac <_assert_log>
 11088b4:	9400268f 	bl	11122f0 <_assert_break>
	__cpu_spin_unlock(lock);
 11088b8:	aa1303e0 	mov	x0, x19
 11088bc:	97ffef01 	bl	11044c0 <__cpu_spin_unlock>
}
 11088c0:	f9400bf3 	ldr	x19, [sp, #16]
 11088c4:	a8c27bfd 	ldp	x29, x30, [sp], #32
	spinlock_count_decr();
 11088c8:	17ffef12 	b	1104510 <spinlock_count_decr>

00000000011088cc <mmu_unlock>:
{
 11088cc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 11088d0:	910003fd 	mov	x29, sp
 11088d4:	f9000bf3 	str	x19, [sp, #16]
 11088d8:	2a0003f3 	mov	w19, w0
#endif

static inline void cpu_spin_unlock_xrestore(unsigned int *lock,
					    uint32_t exceptions)
{
	cpu_spin_unlock(lock);
 11088dc:	90000300 	adrp	x0, 1168000 <data.5093+0x9e28>
 11088e0:	9128c000 	add	x0, x0, #0xa30
 11088e4:	97ffffe6 	bl	110887c <cpu_spin_unlock>
	thread_unmask_exceptions(exceptions);
 11088e8:	2a1303e0 	mov	w0, w19
}
 11088ec:	f9400bf3 	ldr	x19, [sp, #16]
 11088f0:	a8c27bfd 	ldp	x29, x30, [sp], #32
 11088f4:	17fff21e 	b	110516c <thread_unmask_exceptions>

00000000011088f8 <find_map_by_type_and_pa>:
{
 11088f8:	2a0003e3 	mov	w3, w0
	for (map = get_memory_map(); !core_mmap_is_end_of_table(map); map++) {
 11088fc:	b00002a2 	adrp	x2, 115d000 <_curve_names+0x590>
 1108900:	91308040 	add	x0, x2, #0xc20
 1108904:	b9400002 	ldr	w2, [x0]
 1108908:	35000062 	cbnz	w2, 1108914 <find_map_by_type_and_pa+0x1c>
	return NULL;
 110890c:	d2800000 	mov	x0, #0x0                   	// #0
}
 1108910:	d65f03c0 	ret
		if (map->type != type)
 1108914:	6b02007f 	cmp	w3, w2
 1108918:	54000121 	b.ne	110893c <find_map_by_type_and_pa+0x44>  // b.any
	return (pa >= map->pa && pa <= (map->pa + map->size - 1));
 110891c:	f9400402 	ldr	x2, [x0, #8]
 1108920:	eb02003f 	cmp	x1, x2
 1108924:	540000c3 	b.cc	110893c <find_map_by_type_and_pa+0x44>  // b.lo, b.ul, b.last
 1108928:	f9400c04 	ldr	x4, [x0, #24]
 110892c:	8b040042 	add	x2, x2, x4
 1108930:	d1000442 	sub	x2, x2, #0x1
 1108934:	eb02003f 	cmp	x1, x2
 1108938:	54fffec9 	b.ls	1108910 <find_map_by_type_and_pa+0x18>  // b.plast
	for (map = get_memory_map(); !core_mmap_is_end_of_table(map); map++) {
 110893c:	9100a000 	add	x0, x0, #0x28
 1108940:	17fffff1 	b	1108904 <find_map_by_type_and_pa+0xc>

0000000001108944 <core_mmu_set_discovered_nsec_ddr>:
{
 1108944:	d101c3ff 	sub	sp, sp, #0x70
 1108948:	a9017bfd 	stp	x29, x30, [sp, #16]
 110894c:	910043fd 	add	x29, sp, #0x10
 1108950:	a9035bf5 	stp	x21, x22, [sp, #48]
	assert(!discovered_nsec_ddr_start);
 1108954:	b00002b5 	adrp	x21, 115d000 <_curve_names+0x590>
 1108958:	f9460ea4 	ldr	x4, [x21, #3096]
{
 110895c:	a90253f3 	stp	x19, x20, [sp, #32]
 1108960:	a90463f7 	stp	x23, x24, [sp, #64]
 1108964:	a9056bf9 	stp	x25, x26, [sp, #80]
	size_t num_elems = nelems;
 1108968:	a90607e0 	stp	x0, x1, [sp, #96]
	assert(!discovered_nsec_ddr_start);
 110896c:	b4000144 	cbz	x4, 1108994 <core_mmu_set_discovered_nsec_ddr+0x50>
 1108970:	d0000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 1108974:	d0000241 	adrp	x1, 1152000 <trace_ext_prefix+0x2e>
 1108978:	d0000240 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 110897c:	912c8463 	add	x3, x3, #0xb21
 1108980:	91084821 	add	x1, x1, #0x212
 1108984:	91099800 	add	x0, x0, #0x266
 1108988:	52802de2 	mov	w2, #0x16f                 	// #367
	assert(m && num_elems);
 110898c:	94002648 	bl	11122ac <_assert_log>
 1108990:	94002658 	bl	11122f0 <_assert_break>
 1108994:	f100001f 	cmp	x0, #0x0
 1108998:	fa401824 	ccmp	x1, #0x0, #0x4, ne  // ne = any
 110899c:	54000121 	b.ne	11089c0 <core_mmu_set_discovered_nsec_ddr+0x7c>  // b.any
 11089a0:	d0000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 11089a4:	d0000241 	adrp	x1, 1152000 <trace_ext_prefix+0x2e>
 11089a8:	d0000240 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 11089ac:	912c8463 	add	x3, x3, #0xb21
 11089b0:	91084821 	add	x1, x1, #0x212
 11089b4:	910a0400 	add	x0, x0, #0x281
 11089b8:	52802e02 	mov	w2, #0x170                 	// #368
 11089bc:	17fffff4 	b	110898c <core_mmu_set_discovered_nsec_ddr+0x48>
	for (map = static_memory_map; !core_mmap_is_end_of_table(map); map++) {
 11089c0:	b00002b3 	adrp	x19, 115d000 <_curve_names+0x590>
 11089c4:	91308273 	add	x19, x19, #0xc20
	carve_out_phys_mem(&m, &num_elems, TEE_RAM_START, TEE_RAM_PH_SIZE);
 11089c8:	9101a3f6 	add	x22, sp, #0x68
 11089cc:	910183f7 	add	x23, sp, #0x60
	qsort(m, num_elems, sizeof(*m), cmp_pmem_by_addr);
 11089d0:	d2800402 	mov	x2, #0x20                  	// #32
 11089d4:	90000003 	adrp	x3, 1108000 <boot_init_primary_late+0x180>
 11089d8:	910c9063 	add	x3, x3, #0x324
 11089dc:	9400eb99 	bl	1143840 <qsort>
	carve_out_phys_mem(&m, &num_elems, TEE_RAM_START, TEE_RAM_PH_SIZE);
 11089e0:	aa1603e1 	mov	x1, x22
 11089e4:	aa1703e0 	mov	x0, x23
 11089e8:	d2a00203 	mov	x3, #0x100000              	// #1048576
 11089ec:	d2a02202 	mov	x2, #0x1100000             	// #17825792
 11089f0:	97fffe68 	bl	1108390 <carve_out_phys_mem>
	carve_out_phys_mem(&m, &num_elems, TA_RAM_START, TA_RAM_SIZE);
 11089f4:	aa1603e1 	mov	x1, x22
 11089f8:	aa1703e0 	mov	x0, x23
 11089fc:	d2a00203 	mov	x3, #0x100000              	// #1048576
 1108a00:	d2a02402 	mov	x2, #0x1200000             	// #18874368
 1108a04:	97fffe63 	bl	1108390 <carve_out_phys_mem>
	for (map = static_memory_map; !core_mmap_is_end_of_table(map); map++) {
 1108a08:	b9400260 	ldr	w0, [x19]
 1108a0c:	35000280 	cbnz	w0, 1108a5c <core_mmu_set_discovered_nsec_ddr+0x118>
	discovered_nsec_ddr_nelems = num_elems;
 1108a10:	a94603e1 	ldp	x1, x0, [sp, #96]
 1108a14:	b00002a2 	adrp	x2, 115d000 <_curve_names+0x590>
	discovered_nsec_ddr_start = m;
 1108a18:	f9060ea1 	str	x1, [x21, #3096]
	discovered_nsec_ddr_nelems = num_elems;
 1108a1c:	f9060840 	str	x0, [x2, #3088]
	if (!core_mmu_check_end_pa(m[num_elems - 1].addr,
 1108a20:	8b001420 	add	x0, x1, x0, lsl #5
 1108a24:	d1008000 	sub	x0, x0, #0x20

static inline bool core_mmu_check_end_pa(paddr_t pa, size_t len)
{
	paddr_t end_pa = 0;

	if (ADD_OVERFLOW(pa, len - 1, &end_pa))
 1108a28:	f9400c01 	ldr	x1, [x0, #24]
 1108a2c:	f9400800 	ldr	x0, [x0, #16]
 1108a30:	d1000421 	sub	x1, x1, #0x1
 1108a34:	ab010000 	adds	x0, x0, x1
 1108a38:	54000082 	b.cs	1108a48 <core_mmu_set_discovered_nsec_ddr+0x104>  // b.hs, b.nlast
 1108a3c:	b2407fe1 	mov	x1, #0xffffffff            	// #4294967295
 1108a40:	eb01001f 	cmp	x0, x1
 1108a44:	540006a9 	b.ls	1108b18 <core_mmu_set_discovered_nsec_ddr+0x1d4>  // b.plast
		panic();
 1108a48:	d0000242 	adrp	x2, 1152000 <trace_ext_prefix+0x2e>
 1108a4c:	d2800003 	mov	x3, #0x0                   	// #0
 1108a50:	912c8442 	add	x2, x2, #0xb21
 1108a54:	528033a1 	mov	w1, #0x19d                 	// #413
 1108a58:	14000024 	b	1108ae8 <core_mmu_set_discovered_nsec_ddr+0x1a4>
		switch (map->type) {
 1108a5c:	7100281f 	cmp	w0, #0xa
 1108a60:	540004a0 	b.eq	1108af4 <core_mmu_set_discovered_nsec_ddr+0x1b0>  // b.none
 1108a64:	51003c00 	sub	w0, w0, #0xf
 1108a68:	7100101f 	cmp	w0, #0x4
 1108a6c:	540004e9 	b.ls	1108b08 <core_mmu_set_discovered_nsec_ddr+0x1c4>  // b.plast
			check_phys_mem_is_outside(m, num_elems, map);
 1108a70:	a9466bf4 	ldp	x20, x26, [sp, #96]
	for (n = 0; n < nelems; n++) {
 1108a74:	d2800018 	mov	x24, #0x0                   	// #0
 1108a78:	eb18035f 	cmp	x26, x24
 1108a7c:	54000460 	b.eq	1108b08 <core_mmu_set_discovered_nsec_ddr+0x1c4>  // b.none
		if (!core_is_buffer_outside(start[n].addr, start[n].size,
 1108a80:	a9410680 	ldp	x0, x1, [x20, #16]
 1108a84:	aa1403f9 	mov	x25, x20
 1108a88:	f9400662 	ldr	x2, [x19, #8]
 1108a8c:	91008294 	add	x20, x20, #0x20
 1108a90:	f9400e63 	ldr	x3, [x19, #24]
 1108a94:	94002afc 	bl	1113684 <core_is_buffer_outside>
 1108a98:	72001c1f 	tst	w0, #0xff
 1108a9c:	540003a1 	b.ne	1108b10 <core_mmu_set_discovered_nsec_ddr+0x1cc>  // b.any
			EMSG("Non-sec mem (%#" PRIxPA ":%#" PRIxPASZ
 1108aa0:	f9400e60 	ldr	x0, [x19, #24]
 1108aa4:	f90007e0 	str	x0, [sp, #8]
 1108aa8:	f9400660 	ldr	x0, [x19, #8]
 1108aac:	f90003e0 	str	x0, [sp]
 1108ab0:	b9400267 	ldr	w7, [x19]
 1108ab4:	d0000254 	adrp	x20, 1152000 <trace_ext_prefix+0x2e>
 1108ab8:	a9411b25 	ldp	x5, x6, [x25, #16]
 1108abc:	912c1e94 	add	x20, x20, #0xb07
 1108ac0:	52800023 	mov	w3, #0x1                   	// #1
 1108ac4:	52800022 	mov	w2, #0x1                   	// #1
 1108ac8:	52802a61 	mov	w1, #0x153                 	// #339
 1108acc:	aa1403e0 	mov	x0, x20
 1108ad0:	d0000244 	adrp	x4, 1152000 <trace_ext_prefix+0x2e>
 1108ad4:	910a4084 	add	x4, x4, #0x290
 1108ad8:	9400f09b 	bl	1144d44 <trace_printf>
			panic();
 1108adc:	aa1403e2 	mov	x2, x20
 1108ae0:	d2800003 	mov	x3, #0x0                   	// #0
 1108ae4:	52802ae1 	mov	w1, #0x157                 	// #343
		panic();
 1108ae8:	d0000240 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 1108aec:	91084800 	add	x0, x0, #0x212
 1108af0:	94002a5e 	bl	1113468 <__do_panic>
			carve_out_phys_mem(&m, &num_elems, map->pa, map->size);
 1108af4:	f9400662 	ldr	x2, [x19, #8]
 1108af8:	aa1603e1 	mov	x1, x22
 1108afc:	f9400e63 	ldr	x3, [x19, #24]
 1108b00:	aa1703e0 	mov	x0, x23
 1108b04:	97fffe23 	bl	1108390 <carve_out_phys_mem>
	for (map = static_memory_map; !core_mmap_is_end_of_table(map); map++) {
 1108b08:	9100a273 	add	x19, x19, #0x28
 1108b0c:	17ffffbf 	b	1108a08 <core_mmu_set_discovered_nsec_ddr+0xc4>
	for (n = 0; n < nelems; n++) {
 1108b10:	91000718 	add	x24, x24, #0x1
 1108b14:	17ffffd9 	b	1108a78 <core_mmu_set_discovered_nsec_ddr+0x134>
}
 1108b18:	a9417bfd 	ldp	x29, x30, [sp, #16]
 1108b1c:	a94253f3 	ldp	x19, x20, [sp, #32]
 1108b20:	a9435bf5 	ldp	x21, x22, [sp, #48]
 1108b24:	a94463f7 	ldp	x23, x24, [sp, #64]
 1108b28:	a9456bf9 	ldp	x25, x26, [sp, #80]
 1108b2c:	9101c3ff 	add	sp, sp, #0x70
 1108b30:	d65f03c0 	ret

0000000001108b34 <core_mmu_nsec_ddr_is_defined>:
	if (!discovered_nsec_ddr_start)
 1108b34:	b00002a0 	adrp	x0, 115d000 <_curve_names+0x590>
 1108b38:	f9460c00 	ldr	x0, [x0, #3096]
 1108b3c:	b40000c0 	cbz	x0, 1108b54 <core_mmu_nsec_ddr_is_defined+0x20>
	*end = discovered_nsec_ddr_start + discovered_nsec_ddr_nelems;
 1108b40:	b00002a0 	adrp	x0, 115d000 <_curve_names+0x590>
 1108b44:	f9460800 	ldr	x0, [x0, #3088]
	return start != end;
 1108b48:	eb0017ff 	cmp	xzr, x0, lsl #5
 1108b4c:	1a9f07e0 	cset	w0, ne  // ne = any
}
 1108b50:	d65f03c0 	ret
		return false;
 1108b54:	52800000 	mov	w0, #0x0                   	// #0
 1108b58:	17fffffe 	b	1108b50 <core_mmu_nsec_ddr_is_defined+0x1c>

0000000001108b5c <core_mmu_type_to_attr>:
	switch (t) {
 1108b5c:	51000400 	sub	w0, w0, #0x1
 1108b60:	7100541f 	cmp	w0, #0x15
 1108b64:	540002e8 	b.hi	1108bc0 <core_mmu_type_to_attr+0x64>  // b.pmore
 1108b68:	d0000221 	adrp	x1, 114e000 <ldelf_data+0x8000>
 1108b6c:	91169021 	add	x1, x1, #0x5a4
 1108b70:	38604820 	ldrb	w0, [x1, w0, uxtw]
 1108b74:	10000061 	adr	x1, 1108b80 <core_mmu_type_to_attr+0x24>
 1108b78:	8b208820 	add	x0, x1, w0, sxtb #2
 1108b7c:	d61f0000 	br	x0
		return attr | TEE_MATTR_SECURE | TEE_MATTR_PRW | noncache;
 1108b80:	52830a20 	mov	w0, #0x1851                	// #6225
 1108b84:	d65f03c0 	ret
		return attr | TEE_MATTR_SECURE | TEE_MATTR_PRW | cached;
 1108b88:	52830620 	mov	w0, #0x1831                	// #6193
 1108b8c:	d65f03c0 	ret
		return attr | TEE_MATTR_SECURE | TEE_MATTR_PRWX | noncache;
 1108b90:	52810e20 	mov	w0, #0x871                 	// #2161
 1108b94:	d65f03c0 	ret
		return attr | TEE_MATTR_PRW | cached;
 1108b98:	52820620 	mov	w0, #0x1031                	// #4145
 1108b9c:	d65f03c0 	ret
		return attr | TEE_MATTR_PRW | noncache;
 1108ba0:	52800620 	mov	w0, #0x31                  	// #49
 1108ba4:	d65f03c0 	ret
		return attr | TEE_MATTR_SECURE | TEE_MATTR_PRW | noncache;
 1108ba8:	52810620 	mov	w0, #0x831                 	// #2097
 1108bac:	d65f03c0 	ret
		return 0;
 1108bb0:	52800000 	mov	w0, #0x0                   	// #0
 1108bb4:	d65f03c0 	ret
		return TEE_MATTR_SECURE;
 1108bb8:	52810000 	mov	w0, #0x800                 	// #2048
 1108bbc:	d65f03c0 	ret
{
 1108bc0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
		panic("invalid type");
 1108bc4:	d0000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 1108bc8:	d0000242 	adrp	x2, 1152000 <trace_ext_prefix+0x2e>
{
 1108bcc:	910003fd 	mov	x29, sp
		panic("invalid type");
 1108bd0:	d0000240 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 1108bd4:	910b2463 	add	x3, x3, #0x2c9
 1108bd8:	912d7042 	add	x2, x2, #0xb5c
 1108bdc:	91084800 	add	x0, x0, #0x212
 1108be0:	52805341 	mov	w1, #0x29a                 	// #666
 1108be4:	94002a21 	bl	1113468 <__do_panic>
		return attr | TEE_MATTR_SECURE | TEE_MATTR_PRWX | cached;
 1108be8:	52830e20 	mov	w0, #0x1871                	// #6257
 1108bec:	d65f03c0 	ret
		return attr | TEE_MATTR_SECURE | TEE_MATTR_PR | cached;
 1108bf0:	52830220 	mov	w0, #0x1811                	// #6161
}
 1108bf4:	d65f03c0 	ret

0000000001108bf8 <assign_mem_va>:
{
 1108bf8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1108bfc:	910003fd 	mov	x29, sp
 1108c00:	a90153f3 	stp	x19, x20, [sp, #16]
 1108c04:	aa0103f4 	mov	x20, x1
 1108c08:	f90013f5 	str	x21, [sp, #32]
 1108c0c:	aa0003f5 	mov	x21, x0
	for (map = memory_map; !core_mmap_is_end_of_table(map); map++)
 1108c10:	aa0103e0 	mov	x0, x1
 1108c14:	b9400001 	ldr	w1, [x0]
 1108c18:	350004c1 	cbnz	w1, 1108cb0 <assign_mem_va+0xb8>
	vaddr_t va = tee_ram_va;
 1108c1c:	aa1503f3 	mov	x19, x21
	for (map = memory_map; !core_mmap_is_end_of_table(map); map++) {
 1108c20:	aa1403e0 	mov	x0, x20
			if (IS_ENABLED(ARM64) && va >= BIT64(get_va_width()))
 1108c24:	b2407fe3 	mov	x3, #0xffffffff            	// #4294967295
	for (map = memory_map; !core_mmap_is_end_of_table(map); map++) {
 1108c28:	b9400001 	ldr	w1, [x0]
 1108c2c:	35000481 	cbnz	w1, 1108cbc <assign_mem_va+0xc4>
	if (core_mmu_place_tee_ram_at_top(tee_ram_va)) {
 1108c30:	aa1503e0 	mov	x0, x21
 1108c34:	94000807 	bl	110ac50 <core_mmu_place_tee_ram_at_top>
 1108c38:	72001c1f 	tst	w0, #0xff
 1108c3c:	54000bc1 	b.ne	1108db4 <assign_mem_va+0x1bc>  // b.any
			if (IS_ENABLED(ARM64) && va >= BIT64(get_va_width()))
 1108c40:	b2407ff5 	mov	x21, #0xffffffff            	// #4294967295
		for (map = memory_map; !core_mmap_is_end_of_table(map); map++) {
 1108c44:	b9400280 	ldr	w0, [x20]
 1108c48:	34000ba0 	cbz	w0, 1108dbc <assign_mem_va+0x1c4>
			map->attr = core_mmu_type_to_attr(map->type);
 1108c4c:	97ffffc4 	bl	1108b5c <core_mmu_type_to_attr>
 1108c50:	b9002280 	str	w0, [x20, #32]
			if (map->va)
 1108c54:	f9400a80 	ldr	x0, [x20, #16]
 1108c58:	b5000280 	cbnz	x0, 1108ca8 <assign_mem_va+0xb0>
			if (ROUNDUP_OVERFLOW(va, map->region_size, &va))
 1108c5c:	b9400681 	ldr	w1, [x20, #4]
 1108c60:	d1000420 	sub	x0, x1, #0x1
 1108c64:	ab000260 	adds	x0, x19, x0
 1108c68:	54000062 	b.cs	1108c74 <assign_mem_va+0x7c>  // b.hs, b.nlast
 1108c6c:	cb0103f3 	neg	x19, x1
 1108c70:	8a000273 	and	x19, x19, x0
			if (map->size > 2 * CORE_MMU_PGDIR_SIZE) {
 1108c74:	f9400e81 	ldr	x1, [x20, #24]
 1108c78:	f150003f 	cmp	x1, #0x400, lsl #12
 1108c7c:	540000c9 	b.ls	1108c94 <assign_mem_va+0x9c>  // b.plast
				vaddr_t offs = (map->pa - va) &
 1108c80:	f9400680 	ldr	x0, [x20, #8]
 1108c84:	cb130000 	sub	x0, x0, x19
 1108c88:	92405000 	and	x0, x0, #0x1fffff
				if (ADD_OVERFLOW(va, offs, &va))
 1108c8c:	ab000273 	adds	x19, x19, x0
 1108c90:	54000582 	b.cs	1108d40 <assign_mem_va+0x148>  // b.hs, b.nlast
			map->va = va;
 1108c94:	f9000a93 	str	x19, [x20, #16]
			if (ADD_OVERFLOW(va, map->size, &va))
 1108c98:	ab010273 	adds	x19, x19, x1
 1108c9c:	54000522 	b.cs	1108d40 <assign_mem_va+0x148>  // b.hs, b.nlast
			if (IS_ENABLED(ARM64) && va >= BIT64(get_va_width()))
 1108ca0:	eb15027f 	cmp	x19, x21
 1108ca4:	540004e8 	b.hi	1108d40 <assign_mem_va+0x148>  // b.pmore
		for (map = memory_map; !core_mmap_is_end_of_table(map); map++) {
 1108ca8:	9100a294 	add	x20, x20, #0x28
 1108cac:	17ffffe6 	b	1108c44 <assign_mem_va+0x4c>
	for (map = memory_map; !core_mmap_is_end_of_table(map); map++)
 1108cb0:	9100a000 	add	x0, x0, #0x28
		map->va = 0;
 1108cb4:	f81e801f 	stur	xzr, [x0, #-24]
	for (map = memory_map; !core_mmap_is_end_of_table(map); map++)
 1108cb8:	17ffffd7 	b	1108c14 <assign_mem_va+0x1c>
	switch (mm->type) {
 1108cbc:	7100143f 	cmp	w1, #0x5
 1108cc0:	540000a9 	b.ls	1108cd4 <assign_mem_va+0xdc>  // b.plast
 1108cc4:	71001c3f 	cmp	w1, #0x7
 1108cc8:	54000060 	b.eq	1108cd4 <assign_mem_va+0xdc>  // b.none
		if (map_is_tee_ram(map) ||
 1108ccc:	71004c3f 	cmp	w1, #0x13
 1108cd0:	54000461 	b.ne	1108d5c <assign_mem_va+0x164>  // b.any
			assert(!(va & (map->region_size - 1)));
 1108cd4:	b9400401 	ldr	w1, [x0, #4]
 1108cd8:	51000421 	sub	w1, w1, #0x1
 1108cdc:	ea13003f 	tst	x1, x19
 1108ce0:	54000140 	b.eq	1108d08 <assign_mem_va+0x110>  // b.none
 1108ce4:	d0000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 1108ce8:	d0000241 	adrp	x1, 1152000 <trace_ext_prefix+0x2e>
 1108cec:	d0000240 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 1108cf0:	912f6063 	add	x3, x3, #0xbd8
 1108cf4:	91084821 	add	x1, x1, #0x212
 1108cf8:	910b5800 	add	x0, x0, #0x2d6
 1108cfc:	52807302 	mov	w2, #0x398                 	// #920
			assert(!(map->size & (map->region_size - 1)));
 1108d00:	9400256b 	bl	11122ac <_assert_log>
 1108d04:	9400257b 	bl	11122f0 <_assert_break>
 1108d08:	f9400c02 	ldr	x2, [x0, #24]
 1108d0c:	ea02003f 	tst	x1, x2
 1108d10:	54000120 	b.eq	1108d34 <assign_mem_va+0x13c>  // b.none
 1108d14:	d0000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 1108d18:	d0000241 	adrp	x1, 1152000 <trace_ext_prefix+0x2e>
 1108d1c:	d0000240 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 1108d20:	912f6063 	add	x3, x3, #0xbd8
 1108d24:	91084821 	add	x1, x1, #0x212
 1108d28:	910bd400 	add	x0, x0, #0x2f5
 1108d2c:	52807322 	mov	w2, #0x399                 	// #921
 1108d30:	17fffff4 	b	1108d00 <assign_mem_va+0x108>
			map->va = va;
 1108d34:	f9000813 	str	x19, [x0, #16]
			if (ADD_OVERFLOW(va, map->size, &va))
 1108d38:	ab020273 	adds	x19, x19, x2
 1108d3c:	540000c3 	b.cc	1108d54 <assign_mem_va+0x15c>  // b.lo, b.ul, b.last
				return false;
 1108d40:	52800000 	mov	w0, #0x0                   	// #0
}
 1108d44:	a94153f3 	ldp	x19, x20, [sp, #16]
 1108d48:	f94013f5 	ldr	x21, [sp, #32]
 1108d4c:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1108d50:	d65f03c0 	ret
			if (IS_ENABLED(ARM64) && va >= BIT64(get_va_width()))
 1108d54:	eb03027f 	cmp	x19, x3
 1108d58:	54ffff48 	b.hi	1108d40 <assign_mem_va+0x148>  // b.pmore
	for (map = memory_map; !core_mmap_is_end_of_table(map); map++) {
 1108d5c:	9100a000 	add	x0, x0, #0x28
 1108d60:	17ffffb2 	b	1108c28 <assign_mem_va+0x30>
			map->attr = core_mmu_type_to_attr(map->type);
 1108d64:	97ffff7e 	bl	1108b5c <core_mmu_type_to_attr>
 1108d68:	b9002280 	str	w0, [x20, #32]
			if (map->va)
 1108d6c:	f9400a80 	ldr	x0, [x20, #16]
 1108d70:	b5000200 	cbnz	x0, 1108db0 <assign_mem_va+0x1b8>
			if (SUB_OVERFLOW(va, map->size, &va))
 1108d74:	f9400e81 	ldr	x1, [x20, #24]
 1108d78:	eb0102b5 	subs	x21, x21, x1
 1108d7c:	54fffe23 	b.cc	1108d40 <assign_mem_va+0x148>  // b.lo, b.ul, b.last
			va = ROUNDDOWN(va, map->region_size);
 1108d80:	b9400680 	ldr	w0, [x20, #4]
			if (map->size > 2 * CORE_MMU_PGDIR_SIZE) {
 1108d84:	f150003f 	cmp	x1, #0x400, lsl #12
			va = ROUNDDOWN(va, map->region_size);
 1108d88:	cb0003e0 	neg	x0, x0
 1108d8c:	8a150015 	and	x21, x0, x21
			if (map->size > 2 * CORE_MMU_PGDIR_SIZE) {
 1108d90:	540000e9 	b.ls	1108dac <assign_mem_va+0x1b4>  // b.plast
				if (SUB_OVERFLOW(va, CORE_MMU_PGDIR_SIZE, &va))
 1108d94:	f14802b5 	subs	x21, x21, #0x200, lsl #12
 1108d98:	54fffd43 	b.cc	1108d40 <assign_mem_va+0x148>  // b.lo, b.ul, b.last
				va += (map->pa - va) & CORE_MMU_PGDIR_MASK;
 1108d9c:	f9400680 	ldr	x0, [x20, #8]
 1108da0:	cb150000 	sub	x0, x0, x21
 1108da4:	92405000 	and	x0, x0, #0x1fffff
 1108da8:	8b150015 	add	x21, x0, x21
			map->va = va;
 1108dac:	f9000a95 	str	x21, [x20, #16]
		for (map = memory_map; !core_mmap_is_end_of_table(map); map++) {
 1108db0:	9100a294 	add	x20, x20, #0x28
 1108db4:	b9400280 	ldr	w0, [x20]
 1108db8:	35fffd60 	cbnz	w0, 1108d64 <assign_mem_va+0x16c>
	return true;
 1108dbc:	52800020 	mov	w0, #0x1                   	// #1
 1108dc0:	17ffffe1 	b	1108d44 <assign_mem_va+0x14c>

0000000001108dc4 <core_init_mmu_map>:
{
 1108dc4:	d10343ff 	sub	sp, sp, #0xd0
	vaddr_t start = ROUNDDOWN((vaddr_t)__nozi_start, SMALL_PAGE_SIZE);
 1108dc8:	d0000284 	adrp	x4, 115a000 <__scattered_array_1phys_mem_map+0x8>
	memset(tmp_mmap, 0, sizeof(static_memory_map));
 1108dcc:	d2804b02 	mov	x2, #0x258                 	// #600
{
 1108dd0:	a9027bfd 	stp	x29, x30, [sp, #32]
 1108dd4:	910083fd 	add	x29, sp, #0x20
 1108dd8:	a90563f7 	stp	x23, x24, [sp, #80]
 1108ddc:	aa0003f7 	mov	x23, x0
 1108de0:	aa0103f8 	mov	x24, x1
	memset(tmp_mmap, 0, sizeof(static_memory_map));
 1108de4:	f941a880 	ldr	x0, [x4, #848]
 1108de8:	52800001 	mov	w1, #0x0                   	// #0
{
 1108dec:	a90353f3 	stp	x19, x20, [sp, #48]
		if (pbuf_intersects(nsec_shared, secure_only[n].paddr,
 1108df0:	f0000294 	adrp	x20, 115b000 <__vcore_unpg_rw_start>
{
 1108df4:	a9045bf5 	stp	x21, x22, [sp, #64]
		if (core_is_buffer_intersect(pa, size, a[n].paddr, a[n].size))
 1108df8:	f0000295 	adrp	x21, 115b000 <__vcore_unpg_rw_start>
	vaddr_t len = ROUNDUP((vaddr_t)__nozi_end, SMALL_PAGE_SIZE) - start;
 1108dfc:	f941d896 	ldr	x22, [x4, #944]
{
 1108e00:	a9066bf9 	stp	x25, x26, [sp, #96]
	vaddr_t start = ROUNDDOWN((vaddr_t)__nozi_start, SMALL_PAGE_SIZE);
 1108e04:	f941bc99 	ldr	x25, [x4, #888]
{
 1108e08:	a90773fb 	stp	x27, x28, [sp, #112]
	vaddr_t len = ROUNDUP((vaddr_t)__nozi_end, SMALL_PAGE_SIZE) - start;
 1108e0c:	913ffed6 	add	x22, x22, #0xfff
	memset(tmp_mmap, 0, sizeof(static_memory_map));
 1108e10:	f90047e4 	str	x4, [sp, #136]
 1108e14:	9400ebb3 	bl	1143ce0 <memset>
		if (core_is_buffer_intersect(pa, size, a[n].paddr, a[n].size))
 1108e18:	910002a1 	add	x1, x21, #0x0
		if (pbuf_intersects(nsec_shared, secure_only[n].paddr,
 1108e1c:	91032280 	add	x0, x20, #0xc8
		if (core_is_buffer_intersect(pa, size, a[n].paddr, a[n].size))
 1108e20:	f94002a2 	ldr	x2, [x21]
	vaddr_t start = ROUNDDOWN((vaddr_t)__nozi_start, SMALL_PAGE_SIZE);
 1108e24:	9274cf39 	and	x25, x25, #0xfffffffffffff000
		if (core_is_buffer_intersect(pa, size, a[n].paddr, a[n].size))
 1108e28:	f9400423 	ldr	x3, [x1, #8]
	vaddr_t len = ROUNDUP((vaddr_t)__nozi_end, SMALL_PAGE_SIZE) - start;
 1108e2c:	9274ced6 	and	x22, x22, #0xfffffffffffff000
		if (core_is_buffer_intersect(pa, size, a[n].paddr, a[n].size))
 1108e30:	f9400401 	ldr	x1, [x0, #8]
	vaddr_t len = ROUNDUP((vaddr_t)__nozi_end, SMALL_PAGE_SIZE) - start;
 1108e34:	cb1902d6 	sub	x22, x22, x25
		if (core_is_buffer_intersect(pa, size, a[n].paddr, a[n].size))
 1108e38:	f9406680 	ldr	x0, [x20, #200]
 1108e3c:	94002a22 	bl	11136c4 <core_is_buffer_intersect>
 1108e40:	a90953f5 	stp	x21, x20, [sp, #144]
 1108e44:	72001c1f 	tst	w0, #0xff
 1108e48:	f94047e4 	ldr	x4, [sp, #136]
 1108e4c:	54003a60 	b.eq	1109598 <core_init_mmu_map+0x7d4>  // b.none
			panic("Invalid memory access config: sec/nsec");
 1108e50:	d0000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 1108e54:	d0000242 	adrp	x2, 1152000 <trace_ext_prefix+0x2e>
 1108e58:	9113d063 	add	x3, x3, #0x4f4
 1108e5c:	912e5042 	add	x2, x2, #0xb94
 1108e60:	52806761 	mov	w1, #0x33b                 	// #827
 1108e64:	14000094 	b	11090b4 <core_init_mmu_map+0x2f0>
		struct core_mmu_phys_mem m = *mem;
 1108e68:	f9400e96 	ldr	x22, [x20, #24]
		if (!m.size)
 1108e6c:	b50007d6 	cbnz	x22, 1108f64 <core_init_mmu_map+0x1a0>
	for (mem = phys_mem_map_begin; mem < phys_mem_map_end; mem++) {
 1108e70:	91008294 	add	x20, x20, #0x20
 1108e74:	f94047e0 	ldr	x0, [sp, #136]
 1108e78:	eb00029f 	cmp	x20, x0
 1108e7c:	54ffff63 	b.cc	1108e68 <core_init_mmu_map+0xa4>  // b.lo, b.ul, b.last
	add_va_space(memory_map, num_elems, MEM_AREA_RES_VASPACE,
 1108e80:	f941aa60 	ldr	x0, [x19, #848]
 1108e84:	910323f6 	add	x22, sp, #0xc8
 1108e88:	aa1603e3 	mov	x3, x22
 1108e8c:	d2a01402 	mov	x2, #0xa00000              	// #10485760
 1108e90:	aa0003f9 	mov	x25, x0
 1108e94:	52800201 	mov	w1, #0x10                  	// #16
 1108e98:	97fffe1f 	bl	1108714 <add_va_space.constprop.0>
	add_va_space(memory_map, num_elems, MEM_AREA_SHM_VASPACE,
 1108e9c:	aa1603e3 	mov	x3, x22
 1108ea0:	aa1903e0 	mov	x0, x25
 1108ea4:	d2a04002 	mov	x2, #0x2000000             	// #33554432
 1108ea8:	52800221 	mov	w1, #0x11                  	// #17
 1108eac:	97fffe1a 	bl	1108714 <add_va_space.constprop.0>
	memory_map[last].type = MEM_AREA_END;
 1108eb0:	f94067f6 	ldr	x22, [sp, #200]
 1108eb4:	d2800500 	mov	x0, #0x28                  	// #40
			map->region_size = SMALL_PAGE_SIZE;
 1108eb8:	52820003 	mov	w3, #0x1000                	// #4096
			map->region_size = CORE_MMU_PGDIR_SIZE;
 1108ebc:	52a00404 	mov	w4, #0x200000              	// #2097152
	memory_map[last].type = MEM_AREA_END;
 1108ec0:	9b007ec0 	mul	x0, x22, x0
 1108ec4:	b839681f 	str	wzr, [x0, x25]
	for (map = memory_map; !core_mmap_is_end_of_table(map); map++) {
 1108ec8:	aa1903e0 	mov	x0, x25
 1108ecc:	b9400002 	ldr	w2, [x0]
 1108ed0:	35000f82 	cbnz	w2, 11090c0 <core_init_mmu_map+0x2fc>
	qsort(memory_map, last, sizeof(struct tee_mmap_region),
 1108ed4:	f941aa79 	ldr	x25, [x19, #848]
 1108ed8:	aa1603e1 	mov	x1, x22
 1108edc:	90000003 	adrp	x3, 1108000 <boot_init_primary_late+0x180>
 1108ee0:	d2800502 	mov	x2, #0x28                  	// #40
 1108ee4:	91196063 	add	x3, x3, #0x658
 1108ee8:	aa1903e0 	mov	x0, x25
 1108eec:	9400ea55 	bl	1143840 <qsort>
	if (*last >= (num_elems - 1)) {
 1108ef0:	f10036df 	cmp	x22, #0xd
 1108ef4:	54001148 	b.hi	110911c <core_init_mmu_map+0x358>  // b.pmore
 1108ef8:	aa1903e0 	mov	x0, x25
 1108efc:	d2800024 	mov	x4, #0x1                   	// #1
	size_t pos = 0;
 1108f00:	d2800003 	mov	x3, #0x0                   	// #0
	paddr_t begin = 0;
 1108f04:	d2800001 	mov	x1, #0x0                   	// #0
	for (n = 0; !core_mmap_is_end_of_table(mmap + n); n++) {
 1108f08:	b9400002 	ldr	w2, [x0]
 1108f0c:	35001242 	cbnz	w2, 1109154 <core_init_mmu_map+0x390>
	end = mmap[pos - 1].pa + mmap[pos - 1].size;
 1108f10:	d2800502 	mov	x2, #0x28                  	// #40
	size = TEE_RAM_VA_SIZE - (end - begin);
 1108f14:	91440021 	add	x1, x1, #0x100, lsl #12
	end = mmap[pos - 1].pa + mmap[pos - 1].size;
 1108f18:	f941aa7b 	ldr	x27, [x19, #848]
 1108f1c:	9b027c7c 	mul	x28, x3, x2
 1108f20:	d100a380 	sub	x0, x28, #0x28
 1108f24:	8b1b0000 	add	x0, x0, x27
	size = TEE_RAM_VA_SIZE - (end - begin);
 1108f28:	f9400419 	ldr	x25, [x0, #8]
 1108f2c:	f9400c00 	ldr	x0, [x0, #24]
 1108f30:	8b000339 	add	x25, x25, x0
	if (!size)
 1108f34:	eb190039 	subs	x25, x1, x25
 1108f38:	54001460 	b.eq	11091c4 <core_init_mmu_map+0x400>  // b.none
	assert(pos <= *last);
 1108f3c:	eb16007f 	cmp	x3, x22
 1108f40:	540011e9 	b.ls	110917c <core_init_mmu_map+0x3b8>  // b.plast
 1108f44:	d0000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 1108f48:	d0000241 	adrp	x1, 1152000 <trace_ext_prefix+0x2e>
 1108f4c:	d0000240 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 1108f50:	912e0863 	add	x3, x3, #0xb82
 1108f54:	91084821 	add	x1, x1, #0x212
 1108f58:	910f4400 	add	x0, x0, #0x3d1
 1108f5c:	52806502 	mov	w2, #0x328                 	// #808
 1108f60:	1400000e 	b	1108f98 <core_init_mmu_map+0x1d4>
		struct core_mmu_phys_mem m = *mem;
 1108f64:	f9400a95 	ldr	x21, [x20, #16]
 1108f68:	b9400a99 	ldr	w25, [x20, #8]
		assert(m.addr || !core_mmu_type_to_attr(m.type));
 1108f6c:	b50001b5 	cbnz	x21, 1108fa0 <core_init_mmu_map+0x1dc>
 1108f70:	2a1903e0 	mov	w0, w25
 1108f74:	97fffefa 	bl	1108b5c <core_mmu_type_to_attr>
 1108f78:	34000140 	cbz	w0, 1108fa0 <core_init_mmu_map+0x1dc>
 1108f7c:	d0000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 1108f80:	d0000241 	adrp	x1, 1152000 <trace_ext_prefix+0x2e>
 1108f84:	d0000240 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 1108f88:	912eb863 	add	x3, x3, #0xbae
 1108f8c:	91084821 	add	x1, x1, #0x212
 1108f90:	910ca400 	add	x0, x0, #0x329
 1108f94:	528069a2 	mov	w2, #0x34d                 	// #845
	assert(pos <= *last);
 1108f98:	940024c5 	bl	11122ac <_assert_log>
 1108f9c:	940024d5 	bl	11122f0 <_assert_break>
		[MEM_AREA_DDR_OVERALL] = "DDR_OVERALL",
		[MEM_AREA_SEC_RAM_OVERALL] = "SEC_RAM_OVERALL",
	};

	COMPILE_TIME_ASSERT(ARRAY_SIZE(names) == MEM_AREA_MAXTYPE);
	return names[type];
 1108fa0:	f94053e0 	ldr	x0, [sp, #160]
	DMSG("%s type %s 0x%08" PRIxPA " size 0x%08" PRIxPASZ,
 1108fa4:	f90003f6 	str	x22, [sp]
 1108fa8:	52800023 	mov	w3, #0x1                   	// #1
 1108fac:	52804681 	mov	w1, #0x234                 	// #564
 1108fb0:	91004000 	add	x0, x0, #0x10
 1108fb4:	aa1503e7 	mov	x7, x21
 1108fb8:	f9400285 	ldr	x5, [x20]
 1108fbc:	d0000244 	adrp	x4, 1152000 <trace_ext_prefix+0x2e>
 1108fc0:	f8795806 	ldr	x6, [x0, w25, uxtw #3]
 1108fc4:	910d4884 	add	x4, x4, #0x352
 1108fc8:	912d0b40 	add	x0, x26, #0xb42
 1108fcc:	52800062 	mov	w2, #0x3                   	// #3
 1108fd0:	9400ef5d 	bl	1144d44 <trace_printf>
		    ((pa <= (mem->addr + (mem->size - 1))) &&
 1108fd4:	8b1602a1 	add	x1, x21, x22
	size_t n = 0;
 1108fd8:	d2800000 	mov	x0, #0x0                   	// #0
 1108fdc:	f941aa7b 	ldr	x27, [x19, #848]
		    ((pa <= (mem->addr + (mem->size - 1))) &&
 1108fe0:	d1000421 	sub	x1, x1, #0x1
		if (n == *last)
 1108fe4:	f94067e3 	ldr	x3, [sp, #200]
 1108fe8:	eb00007f 	cmp	x3, x0
 1108fec:	54002ae0 	b.eq	1109548 <core_init_mmu_map+0x784>  // b.none
		if (mem->type == memory_map[n].type &&
 1108ff0:	b9400362 	ldr	w2, [x27]
 1108ff4:	6b02033f 	cmp	w25, w2
 1108ff8:	54002a61 	b.ne	1109544 <core_init_mmu_map+0x780>  // b.any
		pa = memory_map[n].pa;
 1108ffc:	f940076a 	ldr	x10, [x27, #8]
		if (mem->type == memory_map[n].type &&
 1109000:	eb01015f 	cmp	x10, x1
 1109004:	54000328 	b.hi	1109068 <core_init_mmu_map+0x2a4>  // b.pmore
		size = memory_map[n].size;
 1109008:	f9400f69 	ldr	x9, [x27, #24]
		    (mem->addr <= (pa + (size - 1))))) {
 110900c:	8b090142 	add	x2, x10, x9
 1109010:	d1000442 	sub	x2, x2, #0x1
		    ((pa <= (mem->addr + (mem->size - 1))) &&
 1109014:	eb15005f 	cmp	x2, x21
 1109018:	54000283 	b.cc	1109068 <core_init_mmu_map+0x2a4>  // b.lo, b.ul, b.last
			DMSG("Physical mem map overlaps 0x%" PRIxPA, mem->addr);
 110901c:	aa1503e5 	mov	x5, x21
 1109020:	aa1c03e0 	mov	x0, x28
 1109024:	b0000244 	adrp	x4, 1152000 <trace_ext_prefix+0x2e>
 1109028:	52800023 	mov	w3, #0x1                   	// #1
 110902c:	910dc884 	add	x4, x4, #0x372
 1109030:	52800062 	mov	w2, #0x3                   	// #3
 1109034:	52804841 	mov	w1, #0x242                 	// #578
 1109038:	a90b27ea 	stp	x10, x9, [sp, #176]
 110903c:	9400ef42 	bl	1144d44 <trace_printf>
			memory_map[n].size = MAX(size, mem->size) +
 1109040:	a94b27ea 	ldp	x10, x9, [sp, #176]
			memory_map[n].pa = MIN(pa, mem->addr);
 1109044:	eb15015f 	cmp	x10, x21
 1109048:	9a959147 	csel	x7, x10, x21, ls  // ls = plast
			memory_map[n].size = MAX(size, mem->size) +
 110904c:	eb16013f 	cmp	x9, x22
 1109050:	9a962136 	csel	x22, x9, x22, cs  // cs = hs, nlast
			memory_map[n].pa = MIN(pa, mem->addr);
 1109054:	f9000767 	str	x7, [x27, #8]
			memory_map[n].size = MAX(size, mem->size) +
 1109058:	8b0a02d6 	add	x22, x22, x10
 110905c:	cb0702c7 	sub	x7, x22, x7
 1109060:	f9000f67 	str	x7, [x27, #24]
			return;
 1109064:	17ffff83 	b	1108e70 <core_init_mmu_map+0xac>
		    (mem->type == memory_map[n].type && mem->addr < pa))
 1109068:	eb15015f 	cmp	x10, x21
 110906c:	540026e8 	b.hi	1109548 <core_init_mmu_map+0x784>  // b.pmore
		n++;
 1109070:	91000400 	add	x0, x0, #0x1
		if (n >= (num_elems - 1)) {
 1109074:	9100a37b 	add	x27, x27, #0x28
 1109078:	f100381f 	cmp	x0, #0xe
 110907c:	54fffb61 	b.ne	1108fe8 <core_init_mmu_map+0x224>  // b.any
			EMSG("Out of entries (%zu) in memory_map", num_elems);
 1109080:	f94057e0 	ldr	x0, [sp, #168]
 1109084:	52800023 	mov	w3, #0x1                   	// #1
 1109088:	52800022 	mov	w2, #0x1                   	// #1
 110908c:	52804701 	mov	w1, #0x238                 	// #568
 1109090:	912d0813 	add	x19, x0, #0xb42
 1109094:	d28001e5 	mov	x5, #0xf                   	// #15
 1109098:	aa1303e0 	mov	x0, x19
 110909c:	b0000244 	adrp	x4, 1152000 <trace_ext_prefix+0x2e>
 11090a0:	91090c84 	add	x4, x4, #0x243
 11090a4:	9400ef28 	bl	1144d44 <trace_printf>
			panic();
 11090a8:	aa1303e2 	mov	x2, x19
 11090ac:	d2800003 	mov	x3, #0x0                   	// #0
 11090b0:	52804721 	mov	w1, #0x239                 	// #569
			panic("Invalid memory access config: sec/nsec");
 11090b4:	b0000240 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 11090b8:	91084800 	add	x0, x0, #0x212
 11090bc:	940028eb 	bl	1113468 <__do_panic>
		paddr_t mask = map->pa | map->size;
 11090c0:	f9400401 	ldr	x1, [x0, #8]
 11090c4:	f9400c05 	ldr	x5, [x0, #24]
 11090c8:	aa050021 	orr	x1, x1, x5
		if (!(mask & CORE_MMU_PGDIR_MASK))
 11090cc:	f240503f 	tst	x1, #0x1fffff
 11090d0:	54000121 	b.ne	11090f4 <core_init_mmu_map+0x330>  // b.any
			map->region_size = CORE_MMU_PGDIR_SIZE;
 11090d4:	b9000404 	str	w4, [x0, #4]
	switch (mm->type) {
 11090d8:	7100145f 	cmp	w2, #0x5
 11090dc:	54000069 	b.ls	11090e8 <core_init_mmu_map+0x324>  // b.plast
 11090e0:	71001c5f 	cmp	w2, #0x7
 11090e4:	54000041 	b.ne	11090ec <core_init_mmu_map+0x328>  // b.any
			map->region_size = SMALL_PAGE_SIZE;
 11090e8:	b9000403 	str	w3, [x0, #4]
	for (map = memory_map; !core_mmap_is_end_of_table(map); map++) {
 11090ec:	9100a000 	add	x0, x0, #0x28
 11090f0:	17ffff77 	b	1108ecc <core_init_mmu_map+0x108>
		else if (!(mask & SMALL_PAGE_MASK))
 11090f4:	f2402c3f 	tst	x1, #0xfff
 11090f8:	54000061 	b.ne	1109104 <core_init_mmu_map+0x340>  // b.any
			map->region_size = SMALL_PAGE_SIZE;
 11090fc:	b9000403 	str	w3, [x0, #4]
 1109100:	17fffff6 	b	11090d8 <core_init_mmu_map+0x314>
			panic("Impossible memory alignment");
 1109104:	b0000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 1109108:	b0000242 	adrp	x2, 1152000 <trace_ext_prefix+0x2e>
 110910c:	910e4863 	add	x3, x3, #0x392
 1109110:	912f0442 	add	x2, x2, #0xbc1
 1109114:	52806e41 	mov	w1, #0x372                 	// #882
 1109118:	17ffffe7 	b	11090b4 <core_init_mmu_map+0x2f0>
		EMSG("Out of entries (%zu) in memory map", num_elems);
 110911c:	b0000253 	adrp	x19, 1152000 <trace_ext_prefix+0x2e>
 1109120:	912e0a73 	add	x19, x19, #0xb82
 1109124:	52800023 	mov	w3, #0x1                   	// #1
 1109128:	52800022 	mov	w2, #0x1                   	// #1
 110912c:	528062e1 	mov	w1, #0x317                 	// #791
 1109130:	aa1303e0 	mov	x0, x19
 1109134:	d28001e5 	mov	x5, #0xf                   	// #15
 1109138:	b0000244 	adrp	x4, 1152000 <trace_ext_prefix+0x2e>
 110913c:	910eb884 	add	x4, x4, #0x3ae
 1109140:	9400ef01 	bl	1144d44 <trace_printf>
		panic();
 1109144:	aa1303e2 	mov	x2, x19
 1109148:	d2800003 	mov	x3, #0x0                   	// #0
 110914c:	52806301 	mov	w1, #0x318                 	// #792
 1109150:	17ffffd9 	b	11090b4 <core_init_mmu_map+0x2f0>
	switch (mm->type) {
 1109154:	7100145f 	cmp	w2, #0x5
 1109158:	54000069 	b.ls	1109164 <core_init_mmu_map+0x3a0>  // b.plast
 110915c:	71001c5f 	cmp	w2, #0x7
 1109160:	54000081 	b.ne	1109170 <core_init_mmu_map+0x3ac>  // b.any
			if (!begin)
 1109164:	b5000041 	cbnz	x1, 110916c <core_init_mmu_map+0x3a8>
				begin = mmap[n].pa;
 1109168:	f9400401 	ldr	x1, [x0, #8]
			pos = n + 1;
 110916c:	aa0403e3 	mov	x3, x4
	for (n = 0; !core_mmap_is_end_of_table(mmap + n); n++) {
 1109170:	91000484 	add	x4, x4, #0x1
 1109174:	9100a000 	add	x0, x0, #0x28
 1109178:	17ffff64 	b	1108f08 <core_init_mmu_map+0x144>
		sizeof(struct tee_mmap_region) * (*last - pos));
 110917c:	cb0302c3 	sub	x3, x22, x3
	memmove(mmap + pos + 1, mmap + pos,
 1109180:	8b1b039a 	add	x26, x28, x27
 1109184:	9100a380 	add	x0, x28, #0x28
 1109188:	aa1a03e1 	mov	x1, x26
 110918c:	8b000360 	add	x0, x27, x0
	(*last)++;
 1109190:	910006d6 	add	x22, x22, #0x1
	memmove(mmap + pos + 1, mmap + pos,
 1109194:	9b027c62 	mul	x2, x3, x2
 1109198:	9400eabb 	bl	1143c84 <memmove>
	memset(mmap + pos, 0, sizeof(mmap[0]));
 110919c:	91002340 	add	x0, x26, #0x8
 11091a0:	d2800402 	mov	x2, #0x20                  	// #32
 11091a4:	52800001 	mov	w1, #0x0                   	// #0
 11091a8:	9400eace 	bl	1143ce0 <memset>
	mmap[pos].type = MEM_AREA_PAGER_VASPACE;
 11091ac:	d2800260 	mov	x0, #0x13                  	// #19
	mmap[pos].size = size;
 11091b0:	a901675f 	stp	xzr, x25, [x26, #16]
	mmap[pos].type = MEM_AREA_PAGER_VASPACE;
 11091b4:	f2c20000 	movk	x0, #0x1000, lsl #32
 11091b8:	f83b6b80 	str	x0, [x28, x27]
	mmap[pos].attr = core_mmu_type_to_attr(MEM_AREA_PAGER_VASPACE);
 11091bc:	52810000 	mov	w0, #0x800                 	// #2048
 11091c0:	b9002340 	str	w0, [x26, #32]
	if (IS_ENABLED(CFG_CORE_ASLR) && seed) {
 11091c4:	b4001037 	cbz	x23, 11093c8 <core_init_mmu_map+0x604>
	vaddr_t id_map_end = (vaddr_t)__identity_map_init_end;
 11091c8:	f9412a79 	ldr	x25, [x19, #592]
		vaddr_t base_addr = TEE_RAM_START + seed;
 11091cc:	d2a0221c 	mov	x28, #0x1100000             	// #17825792
	vaddr_t id_map_start = (vaddr_t)__identity_map_init_start;
 11091d0:	f942367a 	ldr	x26, [x19, #1128]
	vaddr_t end = ROUNDUP(id_map_end, SMALL_PAGE_SIZE);
 11091d4:	913fff39 	add	x25, x25, #0xfff
		vaddr_t base_addr = TEE_RAM_START + seed;
 11091d8:	8b1c02fc 	add	x28, x23, x28
	vaddr_t end = ROUNDUP(id_map_end, SMALL_PAGE_SIZE);
 11091dc:	9274cf39 	and	x25, x25, #0xfffffffffffff000
	vaddr_t start = ROUNDDOWN(id_map_start, SMALL_PAGE_SIZE);
 11091e0:	9274cf5a 	and	x26, x26, #0xfffffffffffff000
		vaddr_t ba = base_addr;
 11091e4:	aa1c03e5 	mov	x5, x28
	size_t len = end - start;
 11091e8:	cb1a0339 	sub	x25, x25, x26
		vaddr_t base_addr = TEE_RAM_START + seed;
 11091ec:	528003fb 	mov	w27, #0x1f                  	// #31
			if (assign_mem_va(ba, memory_map) &&
 11091f0:	f941aa74 	ldr	x20, [x19, #848]
			ba &= va_mask;
 11091f4:	92744cb5 	and	x21, x5, #0xfffff000
			if (assign_mem_va(ba, memory_map) &&
 11091f8:	aa1503e0 	mov	x0, x21
 11091fc:	aa1403e1 	mov	x1, x20
 1109200:	97fffe7e 	bl	1108bf8 <assign_mem_va>
 1109204:	72001c1f 	tst	w0, #0xff
 1109208:	54000b80 	b.eq	1109378 <core_init_mmu_map+0x5b4>  // b.none
	if (*last >= num_elems - 1) {
 110920c:	f1003adf 	cmp	x22, #0xe
 1109210:	54000361 	b.ne	110927c <core_init_mmu_map+0x4b8>  // b.any
		EMSG("Out of entries (%zu) in memory map", num_elems);
 1109214:	b0000253 	adrp	x19, 1152000 <trace_ext_prefix+0x2e>
 1109218:	912f9a73 	add	x19, x19, #0xbe6
 110921c:	52800023 	mov	w3, #0x1                   	// #1
 1109220:	52800022 	mov	w2, #0x1                   	// #1
 1109224:	52808181 	mov	w1, #0x40c                 	// #1036
 1109228:	aa1303e0 	mov	x0, x19
 110922c:	d28001e5 	mov	x5, #0xf                   	// #15
 1109230:	b0000244 	adrp	x4, 1152000 <trace_ext_prefix+0x2e>
 1109234:	910eb884 	add	x4, x4, #0x3ae
 1109238:	9400eec3 	bl	1144d44 <trace_printf>
		panic();
 110923c:	aa1303e2 	mov	x2, x19
 1109240:	d2800003 	mov	x3, #0x0                   	// #0
 1109244:	528081a1 	mov	w1, #0x40d                 	// #1037
 1109248:	17ffff9b 	b	11090b4 <core_init_mmu_map+0x2f0>
				ba = base_addr ^ BIT64(va_width - n);
 110924c:	d2800025 	mov	x5, #0x1                   	// #1
 1109250:	9adb20a5 	lsl	x5, x5, x27
 1109254:	5100077b 	sub	w27, w27, #0x1
 1109258:	ca1c00a5 	eor	x5, x5, x28
 110925c:	17ffffe5 	b	11091f0 <core_init_mmu_map+0x42c>
		if (core_is_buffer_intersect(map->va, map->size, start, len))
 1109260:	a9410680 	ldp	x0, x1, [x20, #16]
 1109264:	aa1903e3 	mov	x3, x25
 1109268:	aa1a03e2 	mov	x2, x26
 110926c:	94002916 	bl	11136c4 <core_is_buffer_intersect>
 1109270:	72001c1f 	tst	w0, #0xff
 1109274:	54000821 	b.ne	1109378 <core_init_mmu_map+0x5b4>  // b.any
	for (map = memory_map; !core_mmap_is_end_of_table(map); map++)
 1109278:	9100a294 	add	x20, x20, #0x28
 110927c:	b9400280 	ldr	w0, [x20]
 1109280:	35ffff00 	cbnz	w0, 1109260 <core_init_mmu_map+0x49c>
	*map = (struct tee_mmap_region){
 1109284:	d2800100 	mov	x0, #0x8                   	// #8
				offs = ba - TEE_RAM_START;
 1109288:	929ffff7 	mov	x23, #0xffffffffffff0000    	// #-65536
	*map = (struct tee_mmap_region){
 110928c:	f2c20000 	movk	x0, #0x1000, lsl #32
 1109290:	a9006a80 	stp	x0, x26, [x20]
 1109294:	52830a20 	mov	w0, #0x1851                	// #6225
 1109298:	a901669a 	stp	x26, x25, [x20, #16]
				offs = ba - TEE_RAM_START;
 110929c:	f2bfde17 	movk	x23, #0xfef0, lsl #16
 11092a0:	8b1702b7 	add	x23, x21, x23
	*map = (struct tee_mmap_region){
 11092a4:	b9002280 	str	w0, [x20, #32]
				DMSG("Mapping core at %#"PRIxVA" offs %#lx",
 11092a8:	b0000244 	adrp	x4, 1152000 <trace_ext_prefix+0x2e>
 11092ac:	b0000240 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
	(*last)++;
 11092b0:	910006d6 	add	x22, x22, #0x1
				DMSG("Mapping core at %#"PRIxVA" offs %#lx",
 11092b4:	aa1703e6 	mov	x6, x23
 11092b8:	aa1503e5 	mov	x5, x21
 11092bc:	910f7884 	add	x4, x4, #0x3de
 11092c0:	912fe400 	add	x0, x0, #0xbf9
 11092c4:	52800023 	mov	w3, #0x1                   	// #1
 11092c8:	52800062 	mov	w2, #0x3                   	// #3
 11092cc:	528089e1 	mov	w1, #0x44f                 	// #1103
 11092d0:	9400ee9d 	bl	1144d44 <trace_printf>
	qsort(memory_map, last, sizeof(struct tee_mmap_region),
 11092d4:	f941aa60 	ldr	x0, [x19, #848]
 11092d8:	d0000299 	adrp	x25, 115b000 <__vcore_unpg_rw_start>
		DMSG("type %-12s va 0x%08" PRIxVA "..0x%08" PRIxVA
 11092dc:	b000025a 	adrp	x26, 1152000 <trace_ext_prefix+0x2e>
 11092e0:	91004339 	add	x25, x25, #0x10
 11092e4:	910c8f5a 	add	x26, x26, #0x323
 11092e8:	b000025b 	adrp	x27, 1152000 <trace_ext_prefix+0x2e>
	qsort(memory_map, last, sizeof(struct tee_mmap_region),
 11092ec:	aa1603e1 	mov	x1, x22
 11092f0:	f0ffffe3 	adrp	x3, 1108000 <boot_init_primary_late+0x180>
 11092f4:	aa0003f6 	mov	x22, x0
 11092f8:	910cf063 	add	x3, x3, #0x33c
 11092fc:	d2800502 	mov	x2, #0x28                  	// #40
 1109300:	9400e950 	bl	1143840 <qsort>
	for (map = memory_map; !core_mmap_is_end_of_table(map); map++) {
 1109304:	b94002c4 	ldr	w4, [x22]
 1109308:	35000764 	cbnz	w4, 11093f4 <core_init_mmu_map+0x630>
			if (!pbuf_is_inside(nsec_shared, m->pa, m->size))
 110930c:	f9404be0 	ldr	x0, [sp, #144]
 1109310:	b0000239 	adrp	x25, 114e000 <ldelf_data+0x8000>
	for (m = map; !core_mmap_is_end_of_table(m); m++) {
 1109314:	f941aa76 	ldr	x22, [x19, #848]
			if (!pbuf_is_inside(nsec_shared, m->pa, m->size))
 1109318:	91000015 	add	x21, x0, #0x0
			if (!pbuf_is_inside(secure_only, m->pa, m->size))
 110931c:	f9404fe0 	ldr	x0, [sp, #152]
 1109320:	9116f339 	add	x25, x25, #0x5bc
 1109324:	91032014 	add	x20, x0, #0xc8
	for (m = map; !core_mmap_is_end_of_table(m); m++) {
 1109328:	b94002c5 	ldr	w5, [x22]
 110932c:	35000985 	cbnz	w5, 110945c <core_init_mmu_map+0x698>
	core_init_mmu(tmp_mmap);
 1109330:	f941aa73 	ldr	x19, [x19, #848]
 1109334:	aa1303e0 	mov	x0, x19
 1109338:	9400060c 	bl	110ab68 <core_init_mmu>
	core_init_mmu_regs(cfg);
 110933c:	aa1803e0 	mov	x0, x24
 1109340:	94000649 	bl	110ac64 <core_init_mmu_regs>
	memcpy(static_memory_map, tmp_mmap, sizeof(static_memory_map));
 1109344:	aa1303e1 	mov	x1, x19
 1109348:	d2804b02 	mov	x2, #0x258                 	// #600
}
 110934c:	a9427bfd 	ldp	x29, x30, [sp, #32]
	memcpy(static_memory_map, tmp_mmap, sizeof(static_memory_map));
 1109350:	900002a0 	adrp	x0, 115d000 <_curve_names+0x590>
}
 1109354:	a94353f3 	ldp	x19, x20, [sp, #48]
	memcpy(static_memory_map, tmp_mmap, sizeof(static_memory_map));
 1109358:	91308000 	add	x0, x0, #0xc20
}
 110935c:	a9445bf5 	ldp	x21, x22, [sp, #64]
 1109360:	a9466bf9 	ldp	x25, x26, [sp, #96]
 1109364:	a94773fb 	ldp	x27, x28, [sp, #112]
	cfg->load_offset = offs;
 1109368:	f9001317 	str	x23, [x24, #32]
}
 110936c:	a94563f7 	ldp	x23, x24, [sp, #80]
 1109370:	910343ff 	add	sp, sp, #0xd0
	memcpy(static_memory_map, tmp_mmap, sizeof(static_memory_map));
 1109374:	17ffe807 	b	1103390 <memcpy>
				DMSG("Failed to map core at %#"PRIxVA, ba);
 1109378:	b0000240 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 110937c:	912fe414 	add	x20, x0, #0xbf9
 1109380:	aa1503e5 	mov	x5, x21
 1109384:	aa1403e0 	mov	x0, x20
 1109388:	b0000244 	adrp	x4, 1152000 <trace_ext_prefix+0x2e>
 110938c:	52800023 	mov	w3, #0x1                   	// #1
 1109390:	910ff484 	add	x4, x4, #0x3fd
 1109394:	52800062 	mov	w2, #0x3                   	// #3
 1109398:	52808a61 	mov	w1, #0x453                 	// #1107
 110939c:	9400ee6a 	bl	1144d44 <trace_printf>
		for (n = 0; n < 3; n++) {
 11093a0:	7100777f 	cmp	w27, #0x1d
 11093a4:	54fff541 	b.ne	110924c <core_init_mmu_map+0x488>  // b.any
		EMSG("Failed to map core with seed %#lx", seed);
 11093a8:	b0000244 	adrp	x4, 1152000 <trace_ext_prefix+0x2e>
 11093ac:	aa1703e5 	mov	x5, x23
 11093b0:	91106084 	add	x4, x4, #0x418
 11093b4:	aa1403e0 	mov	x0, x20
 11093b8:	52800023 	mov	w3, #0x1                   	// #1
 11093bc:	52800022 	mov	w2, #0x1                   	// #1
 11093c0:	52808ac1 	mov	w1, #0x456                 	// #1110
 11093c4:	9400ee60 	bl	1144d44 <trace_printf>
	if (!assign_mem_va(TEE_RAM_START, memory_map))
 11093c8:	f941aa61 	ldr	x1, [x19, #848]
 11093cc:	d2a02200 	mov	x0, #0x1100000             	// #17825792
	unsigned long offs = 0;
 11093d0:	d2800017 	mov	x23, #0x0                   	// #0
	if (!assign_mem_va(TEE_RAM_START, memory_map))
 11093d4:	97fffe09 	bl	1108bf8 <assign_mem_va>
 11093d8:	72001c1f 	tst	w0, #0xff
 11093dc:	54fff7c1 	b.ne	11092d4 <core_init_mmu_map+0x510>  // b.any
		panic();
 11093e0:	b0000242 	adrp	x2, 1152000 <trace_ext_prefix+0x2e>
 11093e4:	d2800003 	mov	x3, #0x0                   	// #0
 11093e8:	912fe442 	add	x2, x2, #0xbf9
 11093ec:	52808b41 	mov	w1, #0x45a                 	// #1114
 11093f0:	17ffff31 	b	11090b4 <core_init_mmu_map+0x2f0>
		vstart = map->va + ((vaddr_t)map->pa & (map->region_size - 1));
 11093f4:	a94082c1 	ldp	x1, x0, [x22, #8]
	for (map = memory_map; !core_mmap_is_end_of_table(map); map++) {
 11093f8:	9100a2d6 	add	x22, x22, #0x28
		vstart = map->va + ((vaddr_t)map->pa & (map->region_size - 1));
 11093fc:	b85dc2c5 	ldur	w5, [x22, #-36]
		DMSG("type %-12s va 0x%08" PRIxVA "..0x%08" PRIxVA
 1109400:	f85f02c3 	ldur	x3, [x22, #-16]
		vstart = map->va + ((vaddr_t)map->pa & (map->region_size - 1));
 1109404:	510004a6 	sub	w6, w5, #0x1
		DMSG("type %-12s va 0x%08" PRIxVA "..0x%08" PRIxVA
 1109408:	714004bf 	cmp	w5, #0x1, lsl #12
		vstart = map->va + ((vaddr_t)map->pa & (map->region_size - 1));
 110940c:	8a0100c6 	and	x6, x6, x1
		DMSG("type %-12s va 0x%08" PRIxVA "..0x%08" PRIxVA
 1109410:	8b030022 	add	x2, x1, x3
 1109414:	f8645b25 	ldr	x5, [x25, w4, uxtw #3]
		vstart = map->va + ((vaddr_t)map->pa & (map->region_size - 1));
 1109418:	8b0000c6 	add	x6, x6, x0
		DMSG("type %-12s va 0x%08" PRIxVA "..0x%08" PRIxVA
 110941c:	910c6f60 	add	x0, x27, #0x31b
 1109420:	d1000442 	sub	x2, x2, #0x1
 1109424:	9a9a0000 	csel	x0, x0, x26, eq  // eq = none
 1109428:	a9000be1 	stp	x1, x2, [sp]
 110942c:	d1000467 	sub	x7, x3, #0x1
 1109430:	a90103e3 	stp	x3, x0, [sp, #16]
 1109434:	8b0600e7 	add	x7, x7, x6
 1109438:	b0000244 	adrp	x4, 1152000 <trace_ext_prefix+0x2e>
 110943c:	52800023 	mov	w3, #0x1                   	// #1
 1109440:	9110e884 	add	x4, x4, #0x43a
 1109444:	52800062 	mov	w2, #0x3                   	// #3
 1109448:	528058e1 	mov	w1, #0x2c7                 	// #711
 110944c:	b0000240 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 1109450:	912dc800 	add	x0, x0, #0xb72
 1109454:	9400ee3c 	bl	1144d44 <trace_printf>
	for (map = memory_map; !core_mmap_is_end_of_table(map); map++) {
 1109458:	17ffffab 	b	1109304 <core_init_mmu_map+0x540>
		switch (m->type) {
 110945c:	510004a0 	sub	w0, w5, #0x1
 1109460:	7100541f 	cmp	w0, #0x15
 1109464:	54000528 	b.hi	1109508 <core_init_mmu_map+0x744>  // b.pmore
 1109468:	38604b20 	ldrb	w0, [x25, w0, uxtw]
 110946c:	10000061 	adr	x1, 1109478 <core_init_mmu_map+0x6b4>
 1109470:	8b208820 	add	x0, x1, w0, sxtb #2
 1109474:	d61f0000 	br	x0
			if (!pbuf_is_inside(secure_only, m->pa, m->size))
 1109478:	f94006c1 	ldr	x1, [x22, #8]
 110947c:	aa1403e0 	mov	x0, x20
 1109480:	f9400ec2 	ldr	x2, [x22, #24]
 1109484:	97fffce9 	bl	1108828 <_pbuf_is_inside.constprop.0>
 1109488:	72001c1f 	tst	w0, #0xff
 110948c:	54000581 	b.ne	110953c <core_init_mmu_map+0x778>  // b.any
				panic("TEE_RAM can't fit in secure_only");
 1109490:	b0000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 1109494:	b0000242 	adrp	x2, 1152000 <trace_ext_prefix+0x2e>
 1109498:	9111fc63 	add	x3, x3, #0x47f
 110949c:	91301842 	add	x2, x2, #0xc06
 11094a0:	52808e41 	mov	w1, #0x472                 	// #1138
 11094a4:	17ffff04 	b	11090b4 <core_init_mmu_map+0x2f0>
			if (!pbuf_is_inside(secure_only, m->pa, m->size))
 11094a8:	f94006c1 	ldr	x1, [x22, #8]
 11094ac:	aa1403e0 	mov	x0, x20
 11094b0:	f9400ec2 	ldr	x2, [x22, #24]
 11094b4:	97fffcdd 	bl	1108828 <_pbuf_is_inside.constprop.0>
 11094b8:	72001c1f 	tst	w0, #0xff
 11094bc:	54000401 	b.ne	110953c <core_init_mmu_map+0x778>  // b.any
				panic("TA_RAM can't fit in secure_only");
 11094c0:	b0000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 11094c4:	b0000242 	adrp	x2, 1152000 <trace_ext_prefix+0x2e>
 11094c8:	91128063 	add	x3, x3, #0x4a0
 11094cc:	91301842 	add	x2, x2, #0xc06
 11094d0:	52808ec1 	mov	w1, #0x476                 	// #1142
 11094d4:	17fffef8 	b	11090b4 <core_init_mmu_map+0x2f0>
			if (!pbuf_is_inside(nsec_shared, m->pa, m->size))
 11094d8:	f94006c1 	ldr	x1, [x22, #8]
 11094dc:	aa1503e0 	mov	x0, x21
 11094e0:	f9400ec2 	ldr	x2, [x22, #24]
 11094e4:	97fffcd1 	bl	1108828 <_pbuf_is_inside.constprop.0>
 11094e8:	72001c1f 	tst	w0, #0xff
 11094ec:	54000281 	b.ne	110953c <core_init_mmu_map+0x778>  // b.any
				panic("NS_SHM can't fit in nsec_shared");
 11094f0:	b0000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 11094f4:	b0000242 	adrp	x2, 1152000 <trace_ext_prefix+0x2e>
 11094f8:	91130063 	add	x3, x3, #0x4c0
 11094fc:	91301842 	add	x2, x2, #0xc06
 1109500:	52808f41 	mov	w1, #0x47a                 	// #1146
 1109504:	17fffeec 	b	11090b4 <core_init_mmu_map+0x2f0>
			EMSG("Uhandled memtype %d", m->type);
 1109508:	b0000253 	adrp	x19, 1152000 <trace_ext_prefix+0x2e>
 110950c:	91301a73 	add	x19, x19, #0xc06
 1109510:	52800023 	mov	w3, #0x1                   	// #1
 1109514:	52800022 	mov	w2, #0x1                   	// #1
 1109518:	52809121 	mov	w1, #0x489                 	// #1161
 110951c:	aa1303e0 	mov	x0, x19
 1109520:	b0000244 	adrp	x4, 1152000 <trace_ext_prefix+0x2e>
 1109524:	91138084 	add	x4, x4, #0x4e0
 1109528:	9400ee07 	bl	1144d44 <trace_printf>
			panic();
 110952c:	aa1303e2 	mov	x2, x19
 1109530:	d2800003 	mov	x3, #0x0                   	// #0
 1109534:	52809141 	mov	w1, #0x48a                 	// #1162
 1109538:	17fffedf 	b	11090b4 <core_init_mmu_map+0x2f0>
	for (m = map; !core_mmap_is_end_of_table(m); m++) {
 110953c:	9100a2d6 	add	x22, x22, #0x28
 1109540:	17ffff7a 	b	1109328 <core_init_mmu_map+0x564>
		if (mem->type < memory_map[n].type ||
 1109544:	54ffd962 	b.cs	1109070 <core_init_mmu_map+0x2ac>  // b.hs, b.nlast
		sizeof(struct tee_mmap_region) * (*last - n));
 1109548:	cb000062 	sub	x2, x3, x0
	memmove(memory_map + n + 1, memory_map + n,
 110954c:	d2800505 	mov	x5, #0x28                  	// #40
 1109550:	f941aa64 	ldr	x4, [x19, #848]
 1109554:	9b051400 	madd	x0, x0, x5, x5
 1109558:	9b057c42 	mul	x2, x2, x5
 110955c:	aa1b03e1 	mov	x1, x27
 1109560:	8b000080 	add	x0, x4, x0
		sizeof(struct tee_mmap_region) * (*last - n));
 1109564:	a90b0fe5 	stp	x5, x3, [sp, #176]
	memmove(memory_map + n + 1, memory_map + n,
 1109568:	9400e9c7 	bl	1143c84 <memmove>
	(*last)++;
 110956c:	a94b0fe5 	ldp	x5, x3, [sp, #176]
	memset(memory_map + n, 0, sizeof(memory_map[0]));
 1109570:	aa1b03e0 	mov	x0, x27
 1109574:	52800001 	mov	w1, #0x0                   	// #0
	(*last)++;
 1109578:	91000463 	add	x3, x3, #0x1
	memset(memory_map + n, 0, sizeof(memory_map[0]));
 110957c:	aa0503e2 	mov	x2, x5
	(*last)++;
 1109580:	f90067e3 	str	x3, [sp, #200]
	memset(memory_map + n, 0, sizeof(memory_map[0]));
 1109584:	9400e9d7 	bl	1143ce0 <memset>
	memory_map[n].type = mem->type;
 1109588:	b9000379 	str	w25, [x27]
	memory_map[n].pa = mem->addr;
 110958c:	f9000775 	str	x21, [x27, #8]
	memory_map[n].size = mem->size;
 1109590:	f9000f76 	str	x22, [x27, #24]
 1109594:	17fffe37 	b	1108e70 <core_init_mmu_map+0xac>
	static_memory_map[0] = (struct tee_mmap_region){
 1109598:	900002a1 	adrp	x1, 115d000 <_curve_names+0x590>
 110959c:	91308020 	add	x0, x1, #0xc20
 11095a0:	d2800022 	mov	x2, #0x1                   	// #1
 11095a4:	aa0403f3 	mov	x19, x4
 11095a8:	f2c20002 	movk	x2, #0x1000, lsl #32
 11095ac:	f9061022 	str	x2, [x1, #3104]
 11095b0:	52830a21 	mov	w1, #0x1851                	// #6225
 11095b4:	a900e419 	stp	x25, x25, [x0, #8]
	for (mem = phys_mem_map_begin; mem < phys_mem_map_end; mem++) {
 11095b8:	b000029b 	adrp	x27, 115a000 <__scattered_array_1phys_mem_map+0x8>
	static_memory_map[0] = (struct tee_mmap_region){
 11095bc:	f9000c16 	str	x22, [x0, #24]
	DMSG("%s type %s 0x%08" PRIxPA " size 0x%08" PRIxPASZ,
 11095c0:	b000025a 	adrp	x26, 1152000 <trace_ext_prefix+0x2e>
	static_memory_map[0] = (struct tee_mmap_region){
 11095c4:	b9002001 	str	w1, [x0, #32]
	for (mem = phys_mem_map_begin; mem < phys_mem_map_end; mem++) {
 11095c8:	90000280 	adrp	x0, 1159000 <Worder+0x2854>
 11095cc:	913c6000 	add	x0, x0, #0xf18
	size_t last = 0;
 11095d0:	f90067ff 	str	xzr, [sp, #200]
	for (mem = phys_mem_map_begin; mem < phys_mem_map_end; mem++) {
 11095d4:	94002d17 	bl	1114a30 <scattered_array_relax_ptr>
 11095d8:	aa0003f4 	mov	x20, x0
 11095dc:	9100e360 	add	x0, x27, #0x38
			DMSG("Physical mem map overlaps 0x%" PRIxPA, mem->addr);
 11095e0:	912d0b5c 	add	x28, x26, #0xb42
	for (mem = phys_mem_map_begin; mem < phys_mem_map_end; mem++) {
 11095e4:	f90047e0 	str	x0, [sp, #136]
 11095e8:	d0000280 	adrp	x0, 115b000 <__vcore_unpg_rw_start>
 11095ec:	f90053e0 	str	x0, [sp, #160]
 11095f0:	f90057fa 	str	x26, [sp, #168]
 11095f4:	17fffe20 	b	1108e74 <core_init_mmu_map+0xb0>

00000000011095f8 <core_pbuf_is>:
	if (len == 0)
 11095f8:	b4000a22 	cbz	x2, 110973c <core_pbuf_is+0x144>
	switch (attr) {
 11095fc:	7100141f 	cmp	w0, #0x5
 1109600:	54000a28 	b.hi	1109744 <core_pbuf_is+0x14c>  // b.pmore
{
 1109604:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1109608:	910003fd 	mov	x29, sp
 110960c:	a90153f3 	stp	x19, x20, [sp, #16]
 1109610:	aa0103f3 	mov	x19, x1
 1109614:	aa0203f4 	mov	x20, x2
 1109618:	b0000221 	adrp	x1, 114e000 <ldelf_data+0x8000>
 110961c:	91175021 	add	x1, x1, #0x5d4
 1109620:	a9025bf5 	stp	x21, x22, [sp, #32]
 1109624:	38604820 	ldrb	w0, [x1, w0, uxtw]
 1109628:	10000061 	adr	x1, 1109634 <core_pbuf_is+0x3c>
 110962c:	8b208820 	add	x0, x1, w0, sxtb #2
 1109630:	d61f0000 	br	x0
		return pbuf_is_inside(secure_only, pbuf, len);
 1109634:	aa1303e1 	mov	x1, x19
 1109638:	d0000280 	adrp	x0, 115b000 <__vcore_unpg_rw_start>
}
 110963c:	a94153f3 	ldp	x19, x20, [sp, #16]
		return pbuf_is_inside(secure_only, pbuf, len);
 1109640:	91032000 	add	x0, x0, #0xc8
}
 1109644:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1109648:	a8c37bfd 	ldp	x29, x30, [sp], #48
		return pbuf_is_inside(secure_only, pbuf, len);
 110964c:	17fffc77 	b	1108828 <_pbuf_is_inside.constprop.0>
		return pbuf_is_inside(nsec_shared, pbuf, len) ||
 1109650:	aa1303e1 	mov	x1, x19
 1109654:	d0000280 	adrp	x0, 115b000 <__vcore_unpg_rw_start>
 1109658:	91000000 	add	x0, x0, #0x0
 110965c:	97fffc73 	bl	1108828 <_pbuf_is_inside.constprop.0>
 1109660:	72001c1f 	tst	w0, #0xff
 1109664:	540000c0 	b.eq	110967c <core_pbuf_is+0x84>  // b.none
 1109668:	52800020 	mov	w0, #0x1                   	// #1
}
 110966c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1109670:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1109674:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1109678:	d65f03c0 	ret
	if (!discovered_nsec_ddr_start)
 110967c:	900002a0 	adrp	x0, 115d000 <_curve_names+0x590>
 1109680:	f9460c15 	ldr	x21, [x0, #3096]
 1109684:	b5000075 	cbnz	x21, 1109690 <core_pbuf_is+0x98>
			return false;
 1109688:	52800000 	mov	w0, #0x0                   	// #0
 110968c:	17fffff8 	b	110966c <core_pbuf_is+0x74>
	*end = discovered_nsec_ddr_start + discovered_nsec_ddr_nelems;
 1109690:	900002a0 	adrp	x0, 115d000 <_curve_names+0x590>
 1109694:	f9460816 	ldr	x22, [x0, #3088]
 1109698:	8b1616b6 	add	x22, x21, x22, lsl #5
	for (mem = start; mem < end; mem++) {
 110969c:	eb1502df 	cmp	x22, x21
 11096a0:	54ffff49 	b.ls	1109688 <core_pbuf_is+0x90>  // b.plast
		if (core_is_buffer_inside(pbuf, len, mem->addr, mem->size))
 11096a4:	a9410ea2 	ldp	x2, x3, [x21, #16]
 11096a8:	aa1403e1 	mov	x1, x20
 11096ac:	aa1303e0 	mov	x0, x19
 11096b0:	940027e3 	bl	111363c <core_is_buffer_inside>
 11096b4:	72001c1f 	tst	w0, #0xff
 11096b8:	54fffd81 	b.ne	1109668 <core_pbuf_is+0x70>  // b.any
	for (mem = start; mem < end; mem++) {
 11096bc:	910082b5 	add	x21, x21, #0x20
 11096c0:	17fffff7 	b	110969c <core_pbuf_is+0xa4>
		return core_is_buffer_inside(pbuf, len, TEE_RAM_START,
 11096c4:	d2a00203 	mov	x3, #0x100000              	// #1048576
 11096c8:	d2a02202 	mov	x2, #0x1100000             	// #17825792
		return core_is_buffer_inside(pbuf, len, TEE_SHMEM_START,
 11096cc:	aa1403e1 	mov	x1, x20
 11096d0:	aa1303e0 	mov	x0, x19
}
 11096d4:	a94153f3 	ldp	x19, x20, [sp, #16]
 11096d8:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11096dc:	a8c37bfd 	ldp	x29, x30, [sp], #48
		return core_is_buffer_inside(pbuf, len, TEE_SHMEM_START,
 11096e0:	140027d7 	b	111363c <core_is_buffer_inside>
		return core_is_buffer_inside(pbuf, len, TA_RAM_START,
 11096e4:	d2a00203 	mov	x3, #0x100000              	// #1048576
 11096e8:	d2a02402 	mov	x2, #0x1200000             	// #18874368
 11096ec:	17fffff8 	b	11096cc <core_pbuf_is+0xd4>
		return core_is_buffer_inside(pbuf, len, TEE_SHMEM_START,
 11096f0:	d2a00803 	mov	x3, #0x400000              	// #4194304
 11096f4:	d2a02602 	mov	x2, #0x1300000             	// #19922944
 11096f8:	17fffff5 	b	11096cc <core_pbuf_is+0xd4>
		map = find_map_by_pa(pbuf);
 11096fc:	aa1303e0 	mov	x0, x19
 1109700:	97fffaf9 	bl	11082e4 <find_map_by_pa>
 1109704:	aa0003f5 	mov	x21, x0
		if (map == NULL || !pbuf_inside_map_area(pbuf, len, map))
 1109708:	b4fffc00 	cbz	x0, 1109688 <core_pbuf_is+0x90>
	return core_is_buffer_inside(p, l, map->pa, map->size);
 110970c:	f94006a2 	ldr	x2, [x21, #8]
 1109710:	aa1403e1 	mov	x1, x20
 1109714:	f9400ea3 	ldr	x3, [x21, #24]
 1109718:	aa1303e0 	mov	x0, x19
 110971c:	940027c8 	bl	111363c <core_is_buffer_inside>
		if (map == NULL || !pbuf_inside_map_area(pbuf, len, map))
 1109720:	72001c1f 	tst	w0, #0xff
 1109724:	54fffb20 	b.eq	1109688 <core_pbuf_is+0x90>  // b.none
		return map->attr >> TEE_MATTR_CACHE_SHIFT ==
 1109728:	b94022a0 	ldr	w0, [x21, #32]
 110972c:	530c7c00 	lsr	w0, w0, #12
 1109730:	7100041f 	cmp	w0, #0x1
 1109734:	1a9f17e0 	cset	w0, eq  // eq = none
 1109738:	17ffffcd 	b	110966c <core_pbuf_is+0x74>
		return true;
 110973c:	52800020 	mov	w0, #0x1                   	// #1
 1109740:	d65f03c0 	ret
	if (len == 0)
 1109744:	52800000 	mov	w0, #0x0                   	// #0
}
 1109748:	d65f03c0 	ret

000000000110974c <core_mmu_get_mem_by_type>:
	for (map = get_memory_map(); !core_mmap_is_end_of_table(map); map++)
 110974c:	900002a3 	adrp	x3, 115d000 <_curve_names+0x590>
 1109750:	91308063 	add	x3, x3, #0xc20
 1109754:	b9400064 	ldr	w4, [x3]
 1109758:	35000084 	cbnz	w4, 1109768 <core_mmu_get_mem_by_type+0x1c>

	if (map) {
		*s = map->va;
		*e = map->va + map->size;
	} else {
		*s = 0;
 110975c:	f900003f 	str	xzr, [x1]
		*e = 0;
 1109760:	f900005f 	str	xzr, [x2]
 1109764:	1400000a 	b	110978c <core_mmu_get_mem_by_type+0x40>
		if (map->type == type)
 1109768:	6b04001f 	cmp	w0, w4
 110976c:	54000060 	b.eq	1109778 <core_mmu_get_mem_by_type+0x2c>  // b.none
	for (map = get_memory_map(); !core_mmap_is_end_of_table(map); map++)
 1109770:	9100a063 	add	x3, x3, #0x28
 1109774:	17fffff8 	b	1109754 <core_mmu_get_mem_by_type+0x8>
		*s = map->va;
 1109778:	f9400864 	ldr	x4, [x3, #16]
 110977c:	f9000024 	str	x4, [x1]
		*e = map->va + map->size;
 1109780:	f9400c60 	ldr	x0, [x3, #24]
 1109784:	8b040000 	add	x0, x0, x4
 1109788:	f9000040 	str	x0, [x2]
	}
}
 110978c:	d65f03c0 	ret

0000000001109790 <tlbi_mva_range_asid>:
	dsb_ish();
	isb();
}

void tlbi_mva_range_asid(vaddr_t va, size_t len, size_t granule, uint32_t asid)
{
 1109790:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	assert(granule == CORE_MMU_PGDIR_SIZE || granule == SMALL_PAGE_SIZE);
 1109794:	f148005f 	cmp	x2, #0x200, lsl #12
 1109798:	d2820004 	mov	x4, #0x1000                	// #4096
{
 110979c:	910003fd 	mov	x29, sp
	assert(granule == CORE_MMU_PGDIR_SIZE || granule == SMALL_PAGE_SIZE);
 11097a0:	fa441044 	ccmp	x2, x4, #0x4, ne  // ne = any
 11097a4:	54000140 	b.eq	11097cc <tlbi_mva_range_asid+0x3c>  // b.none
 11097a8:	b0000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 11097ac:	b0000241 	adrp	x1, 1152000 <trace_ext_prefix+0x2e>
 11097b0:	b0000240 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 11097b4:	91305063 	add	x3, x3, #0xc14
 11097b8:	91084821 	add	x1, x1, #0x212
 11097bc:	91146c00 	add	x0, x0, #0x51b
 11097c0:	5280ac62 	mov	w2, #0x563                 	// #1379
	assert(!(va & (granule - 1)) && !(len & (granule - 1)));
 11097c4:	940022ba 	bl	11122ac <_assert_log>
 11097c8:	940022ca 	bl	11122f0 <_assert_break>
 11097cc:	d1000444 	sub	x4, x2, #0x1
 11097d0:	aa010005 	orr	x5, x0, x1
 11097d4:	ea05009f 	tst	x4, x5
 11097d8:	54000120 	b.eq	11097fc <tlbi_mva_range_asid+0x6c>  // b.none
 11097dc:	b0000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 11097e0:	b0000241 	adrp	x1, 1152000 <trace_ext_prefix+0x2e>
 11097e4:	b0000240 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 11097e8:	91305063 	add	x3, x3, #0xc14
 11097ec:	91084821 	add	x1, x1, #0x212
 11097f0:	91156000 	add	x0, x0, #0x558
 11097f4:	5280ac82 	mov	w2, #0x564                 	// #1380
 11097f8:	17fffff3 	b	11097c4 <tlbi_mva_range_asid+0x34>
	asm volatile ("dsb ishst");
 11097fc:	d5033a9f 	dsb	ishst
static inline void tlbi_mva_asid_nosync(vaddr_t va, uint32_t asid)
{
	uint32_t a = asid & TLBI_ASID_MASK;

#ifdef ARM64
	tlbi_vale1is((va >> TLBI_MVA_SHIFT) | SHIFT_U64(a, TLBI_ASID_SHIFT));
 1109800:	d3501c65 	ubfiz	x5, x3, #48, #8
	tlbi_vale1is((va >> TLBI_MVA_SHIFT) |
		     SHIFT_U64(a | 1, TLBI_ASID_SHIFT));
 1109804:	b25000a3 	orr	x3, x5, #0x1000000000000

	dsb_ishst();
	while (len) {
 1109808:	b50000a1 	cbnz	x1, 110981c <tlbi_mva_range_asid+0x8c>
	asm volatile ("dsb ish");
 110980c:	d5033b9f 	dsb	ish
	asm volatile ("isb");
 1109810:	d5033fdf 	isb
		len -= granule;
		va += granule;
	}
	dsb_ish();
	isb();
}
 1109814:	a8c17bfd 	ldp	x29, x30, [sp], #16
 1109818:	d65f03c0 	ret
	tlbi_vale1is((va >> TLBI_MVA_SHIFT) | SHIFT_U64(a, TLBI_ASID_SHIFT));
 110981c:	d34cfc04 	lsr	x4, x0, #12
 1109820:	aa4030a6 	orr	x6, x5, x0, lsr #12
	asm volatile ("tlbi	vale1is, %0" : : "r" (mva));
 1109824:	d50883a6 	tlbi	vale1is, x6
	tlbi_vale1is((va >> TLBI_MVA_SHIFT) |
 1109828:	aa030084 	orr	x4, x4, x3
 110982c:	d50883a4 	tlbi	vale1is, x4
		len -= granule;
 1109830:	cb020021 	sub	x1, x1, x2
		va += granule;
 1109834:	8b020000 	add	x0, x0, x2
 1109838:	17fffff4 	b	1109808 <tlbi_mva_range_asid+0x78>

000000000110983c <cache_op_inner>:

TEE_Result cache_op_inner(enum cache_op op, void *va, size_t len)
{
 110983c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1109840:	71001c1f 	cmp	w0, #0x7
 1109844:	910003fd 	mov	x29, sp
 1109848:	f9000bf3 	str	x19, [sp, #16]
 110984c:	2a0003f3 	mov	w19, w0
 1109850:	540003e8 	b.hi	11098cc <cache_op_inner+0x90>  // b.pmore
 1109854:	aa0103e0 	mov	x0, x1
 1109858:	aa0203e1 	mov	x1, x2
 110985c:	b0000222 	adrp	x2, 114e000 <ldelf_data+0x8000>
 1109860:	91177042 	add	x2, x2, #0x5dc
 1109864:	38734842 	ldrb	w2, [x2, w19, uxtw]
 1109868:	10000063 	adr	x3, 1109874 <cache_op_inner+0x38>
 110986c:	8b228862 	add	x2, x3, w2, sxtb #2
 1109870:	d61f0040 	br	x2
	switch (op) {
	case DCACHE_CLEAN:
		dcache_op_all(DCACHE_OP_CLEAN);
 1109874:	d2800040 	mov	x0, #0x2                   	// #2
 1109878:	97ffebb4 	bl	1104748 <dcache_op_all>
		break;
	default:
		return TEE_ERROR_NOT_IMPLEMENTED;
	}
	return TEE_SUCCESS;
}
 110987c:	2a1303e0 	mov	w0, w19
 1109880:	f9400bf3 	ldr	x19, [sp, #16]
 1109884:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1109888:	d65f03c0 	ret
		dcache_clean_range(va, len);
 110988c:	97ffeb59 	bl	11045f0 <dcache_clean_range>
	return TEE_SUCCESS;
 1109890:	52800013 	mov	w19, #0x0                   	// #0
		break;
 1109894:	17fffffa 	b	110987c <cache_op_inner+0x40>
		dcache_op_all(DCACHE_OP_INV);
 1109898:	d2800000 	mov	x0, #0x0                   	// #0
		dcache_op_all(DCACHE_OP_CLEAN_INV);
 110989c:	97ffebab 	bl	1104748 <dcache_op_all>
 11098a0:	17fffffc 	b	1109890 <cache_op_inner+0x54>
		dcache_inv_range(va, len);
 11098a4:	97ffeb60 	bl	1104624 <dcache_inv_range>
		break;
 11098a8:	17fffffa 	b	1109890 <cache_op_inner+0x54>
		icache_inv_all();
 11098ac:	97ffebac 	bl	110475c <icache_inv_all>
		break;
 11098b0:	17fffff8 	b	1109890 <cache_op_inner+0x54>
		icache_inv_range(va, len);
 11098b4:	97ffebae 	bl	110476c <icache_inv_range>
		break;
 11098b8:	17fffff6 	b	1109890 <cache_op_inner+0x54>
		dcache_op_all(DCACHE_OP_CLEAN_INV);
 11098bc:	d2800020 	mov	x0, #0x1                   	// #1
 11098c0:	17fffff7 	b	110989c <cache_op_inner+0x60>
		dcache_cleaninv_range(va, len);
 11098c4:	97ffeb3e 	bl	11045bc <dcache_cleaninv_range>
		break;
 11098c8:	17fffff2 	b	1109890 <cache_op_inner+0x54>
	return TEE_SUCCESS;
 11098cc:	129ffed3 	mov	w19, #0xffff0009            	// #-65527
 11098d0:	17ffffeb 	b	110987c <cache_op_inner+0x40>

00000000011098d4 <core_mmu_set_entry>:
}
#endif /*CFG_PL310*/

void core_mmu_set_entry(struct core_mmu_table_info *tbl_info, unsigned idx,
			paddr_t pa, uint32_t attr)
{
 11098d4:	2a0303e4 	mov	w4, w3
	assert(idx < tbl_info->num_entries);
 11098d8:	b9401803 	ldr	w3, [x0, #24]
 11098dc:	6b01007f 	cmp	w3, w1
 11098e0:	54000188 	b.hi	1109910 <core_mmu_set_entry+0x3c>  // b.pmore
 11098e4:	b0000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 11098e8:	b0000241 	adrp	x1, 1152000 <trace_ext_prefix+0x2e>
 11098ec:	9130a063 	add	x3, x3, #0xc28
 11098f0:	91084821 	add	x1, x1, #0x212
 11098f4:	b0000240 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 11098f8:	91162000 	add	x0, x0, #0x588
{
 11098fc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	assert(idx < tbl_info->num_entries);
 1109900:	5280b762 	mov	w2, #0x5bb                 	// #1467
{
 1109904:	910003fd 	mov	x29, sp
	assert(idx < tbl_info->num_entries);
 1109908:	94002269 	bl	11122ac <_assert_log>
 110990c:	94002279 	bl	11122f0 <_assert_break>
	core_mmu_set_entry_primitive(tbl_info->table, tbl_info->level,
 1109910:	aa0203e3 	mov	x3, x2
 1109914:	2a0103e2 	mov	w2, w1
 1109918:	b9401001 	ldr	w1, [x0, #16]
 110991c:	f9400000 	ldr	x0, [x0]
 1109920:	14000584 	b	110af30 <core_mmu_set_entry_primitive>

0000000001109924 <set_region>:
	}
}

static void set_region(struct core_mmu_table_info *tbl_info,
		struct tee_mmap_region *region)
{
 1109924:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 1109928:	910003fd 	mov	x29, sp
 110992c:	a9025bf5 	stp	x21, x22, [sp, #32]
 1109930:	aa0103f6 	mov	x22, x1
 1109934:	aa0003f5 	mov	x21, x0
	unsigned end;
	unsigned idx;
	paddr_t pa;

	/* va, len and pa should be block aligned */
	assert(!core_mmu_get_block_offset(tbl_info, region->va));
 1109938:	f9400823 	ldr	x3, [x1, #16]
{
 110993c:	a90153f3 	stp	x19, x20, [sp, #16]
	assert(!core_mmu_get_block_offset(tbl_info, region->va));
 1109940:	b9401401 	ldr	w1, [x0, #20]
 * @returns offset within one block of the translation table
 */
static inline size_t core_mmu_get_block_offset(
			struct core_mmu_table_info *tbl_info, paddr_t pa)
{
	return pa & ((1 << tbl_info->shift) - 1);
 1109944:	52800020 	mov	w0, #0x1                   	// #1
{
 1109948:	a90363f7 	stp	x23, x24, [sp, #48]
 110994c:	1ac12004 	lsl	w4, w0, w1
 1109950:	51000484 	sub	w4, w4, #0x1
 1109954:	93407c84 	sxtw	x4, w4
	assert(!core_mmu_get_block_offset(tbl_info, region->va));
 1109958:	ea04007f 	tst	x3, x4
 110995c:	54000140 	b.eq	1109984 <set_region+0x60>  // b.none
 1109960:	b0000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 1109964:	b0000241 	adrp	x1, 1152000 <trace_ext_prefix+0x2e>
 1109968:	b0000240 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 110996c:	91313863 	add	x3, x3, #0xc4e
 1109970:	91084821 	add	x1, x1, #0x212
 1109974:	91169000 	add	x0, x0, #0x5a4
 1109978:	5280bc82 	mov	w2, #0x5e4                 	// #1508
	assert(!core_mmu_get_block_offset(tbl_info, region->size));
 110997c:	9400224c 	bl	11122ac <_assert_log>
 1109980:	9400225c 	bl	11122f0 <_assert_break>
 1109984:	f9400ed3 	ldr	x19, [x22, #24]
 1109988:	ea04027f 	tst	x19, x4
 110998c:	54000120 	b.eq	11099b0 <set_region+0x8c>  // b.none
 1109990:	b0000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 1109994:	b0000241 	adrp	x1, 1152000 <trace_ext_prefix+0x2e>
 1109998:	b0000240 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 110999c:	91313863 	add	x3, x3, #0xc4e
 11099a0:	91084821 	add	x1, x1, #0x212
 11099a4:	91175400 	add	x0, x0, #0x5d5
 11099a8:	5280bca2 	mov	w2, #0x5e5                 	// #1509
 11099ac:	17fffff4 	b	110997c <set_region+0x58>
	assert(!core_mmu_get_block_offset(tbl_info, region->pa));
 11099b0:	f94006d7 	ldr	x23, [x22, #8]
 11099b4:	ea0402ff 	tst	x23, x4
 11099b8:	54000120 	b.eq	11099dc <set_region+0xb8>  // b.none
 11099bc:	b0000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 11099c0:	b0000241 	adrp	x1, 1152000 <trace_ext_prefix+0x2e>
 11099c4:	b0000240 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 11099c8:	91313863 	add	x3, x3, #0xc4e
 11099cc:	91084821 	add	x1, x1, #0x212
 11099d0:	91182000 	add	x0, x0, #0x608
 11099d4:	5280bcc2 	mov	w2, #0x5e6                 	// #1510
 11099d8:	17ffffe9 	b	110997c <set_region+0x58>
	return (va - tbl_info->va_base) >> tbl_info->shift;
 11099dc:	f94006a2 	ldr	x2, [x21, #8]

	idx = core_mmu_va2idx(tbl_info, region->va);
	end = core_mmu_va2idx(tbl_info, region->va + region->size);
 11099e0:	8b130073 	add	x19, x3, x19
	pa = region->pa;

	while (idx < end) {
		core_mmu_set_entry(tbl_info, idx, pa, region->attr);
		idx++;
		pa += 1 << tbl_info->shift;
 11099e4:	2a0003f8 	mov	w24, w0
 11099e8:	cb020074 	sub	x20, x3, x2
 11099ec:	cb020273 	sub	x19, x19, x2
 11099f0:	9ac12694 	lsr	x20, x20, x1
 11099f4:	9ac12673 	lsr	x19, x19, x1
	while (idx < end) {
 11099f8:	6b13029f 	cmp	w20, w19
 11099fc:	540000c3 	b.cc	1109a14 <set_region+0xf0>  // b.lo, b.ul, b.last
	}
}
 1109a00:	a94153f3 	ldp	x19, x20, [sp, #16]
 1109a04:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1109a08:	a94363f7 	ldp	x23, x24, [sp, #48]
 1109a0c:	a8c47bfd 	ldp	x29, x30, [sp], #64
 1109a10:	d65f03c0 	ret
		core_mmu_set_entry(tbl_info, idx, pa, region->attr);
 1109a14:	b94022c3 	ldr	w3, [x22, #32]
 1109a18:	aa1703e2 	mov	x2, x23
 1109a1c:	2a1403e1 	mov	w1, w20
 1109a20:	aa1503e0 	mov	x0, x21
		idx++;
 1109a24:	11000694 	add	w20, w20, #0x1
		core_mmu_set_entry(tbl_info, idx, pa, region->attr);
 1109a28:	97ffffab 	bl	11098d4 <core_mmu_set_entry>
		pa += 1 << tbl_info->shift;
 1109a2c:	b94016a0 	ldr	w0, [x21, #20]
 1109a30:	1ac02300 	lsl	w0, w24, w0
 1109a34:	8b20c2f7 	add	x23, x23, w0, sxtw
 1109a38:	17fffff0 	b	11099f8 <set_region+0xd4>

0000000001109a3c <core_mmu_get_entry>:
{
 1109a3c:	aa0303e4 	mov	x4, x3
	assert(idx < tbl_info->num_entries);
 1109a40:	b9401803 	ldr	w3, [x0, #24]
 1109a44:	6b01007f 	cmp	w3, w1
 1109a48:	54000188 	b.hi	1109a78 <core_mmu_get_entry+0x3c>  // b.pmore
 1109a4c:	b0000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 1109a50:	b0000241 	adrp	x1, 1152000 <trace_ext_prefix+0x2e>
 1109a54:	9130ec63 	add	x3, x3, #0xc3b
 1109a58:	91084821 	add	x1, x1, #0x212
 1109a5c:	b0000240 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 1109a60:	91162000 	add	x0, x0, #0x588
{
 1109a64:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	assert(idx < tbl_info->num_entries);
 1109a68:	5280b862 	mov	w2, #0x5c3                 	// #1475
{
 1109a6c:	910003fd 	mov	x29, sp
	assert(idx < tbl_info->num_entries);
 1109a70:	9400220f 	bl	11122ac <_assert_log>
 1109a74:	9400221f 	bl	11122f0 <_assert_break>
	core_mmu_get_entry_primitive(tbl_info->table, tbl_info->level,
 1109a78:	aa0203e3 	mov	x3, x2
 1109a7c:	2a0103e2 	mov	w2, w1
 1109a80:	b9401001 	ldr	w1, [x0, #16]
 1109a84:	f9400000 	ldr	x0, [x0]
 1109a88:	14000565 	b	110b01c <core_mmu_get_entry_primitive>

0000000001109a8c <core_mmu_map_region>:

	return true;
}

void core_mmu_map_region(struct mmu_partition *prtn, struct tee_mmap_region *mm)
{
 1109a8c:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
 1109a90:	910003fd 	mov	x29, sp
 1109a94:	a9025bf5 	stp	x21, x22, [sp, #32]
	struct core_mmu_table_info tbl_info;
	unsigned int idx;
	vaddr_t vaddr = mm->va;
 1109a98:	a940d436 	ldp	x22, x21, [x1, #8]
{
 1109a9c:	a90153f3 	stp	x19, x20, [sp, #16]
 1109aa0:	a90363f7 	stp	x23, x24, [sp, #48]
 1109aa4:	aa0003f8 	mov	x24, x0
 1109aa8:	a9046bf9 	stp	x25, x26, [sp, #64]
	ssize_t size_left = mm->size;
	int level;
	bool table_found;
	uint32_t old_attr;

	assert(!((vaddr | paddr) & SMALL_PAGE_MASK));
 1109aac:	aa1602a0 	orr	x0, x21, x22
{
 1109ab0:	a90573fb 	stp	x27, x28, [sp, #80]
	assert(!((vaddr | paddr) & SMALL_PAGE_MASK));
 1109ab4:	f2402c1f 	tst	x0, #0xfff
	ssize_t size_left = mm->size;
 1109ab8:	f9400c37 	ldr	x23, [x1, #24]
	assert(!((vaddr | paddr) & SMALL_PAGE_MASK));
 1109abc:	540001c1 	b.ne	1109af4 <core_mmu_map_region+0x68>  // b.any
 1109ac0:	aa0103f3 	mov	x19, x1
		level = 1;

		while (true) {
			assert(level <= CORE_MMU_PGDIR_LEVEL);

			table_found = core_mmu_find_table(prtn, vaddr, level,
 1109ac4:	910203fa 	add	x26, sp, #0x80
				level++;
				continue;
			}

			/* We can map part of the region at current level */
			core_mmu_get_entry(&tbl_info, idx, NULL, &old_attr);
 1109ac8:	9101f3fb 	add	x27, sp, #0x7c
					      1 << tbl_info.shift, mm)) {
 1109acc:	52800039 	mov	w25, #0x1                   	// #1
	while (size_left > 0) {
 1109ad0:	f10002ff 	cmp	x23, #0x0
 1109ad4:	5400022c 	b.gt	1109b18 <core_mmu_map_region+0x8c>
			size_left -= 1 << tbl_info.shift;

			break;
		}
	}
}
 1109ad8:	a94153f3 	ldp	x19, x20, [sp, #16]
 1109adc:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1109ae0:	a94363f7 	ldp	x23, x24, [sp, #48]
 1109ae4:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1109ae8:	a94573fb 	ldp	x27, x28, [sp, #80]
 1109aec:	a8ca7bfd 	ldp	x29, x30, [sp], #160
 1109af0:	d65f03c0 	ret
	assert(!((vaddr | paddr) & SMALL_PAGE_MASK));
 1109af4:	b0000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 1109af8:	b0000241 	adrp	x1, 1152000 <trace_ext_prefix+0x2e>
 1109afc:	b0000240 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 1109b00:	91319c63 	add	x3, x3, #0xc67
 1109b04:	91084821 	add	x1, x1, #0x212
 1109b08:	9118e400 	add	x0, x0, #0x639
 1109b0c:	5280cba2 	mov	w2, #0x65d                 	// #1629
			assert(level <= CORE_MMU_PGDIR_LEVEL);
 1109b10:	940021e7 	bl	11122ac <_assert_log>
 1109b14:	940021f7 	bl	11122f0 <_assert_break>
	if ((vaddr | paddr) & (block_size - 1))
 1109b18:	aa1602a0 	orr	x0, x21, x22
		level = 1;
 1109b1c:	5280003c 	mov	w28, #0x1                   	// #1
	if ((vaddr | paddr) & (block_size - 1))
 1109b20:	f90037e0 	str	x0, [sp, #104]
			table_found = core_mmu_find_table(prtn, vaddr, level,
 1109b24:	aa1a03e3 	mov	x3, x26
 1109b28:	2a1c03e2 	mov	w2, w28
 1109b2c:	aa1503e1 	mov	x1, x21
 1109b30:	aa1803e0 	mov	x0, x24
 1109b34:	94000477 	bl	110ad10 <core_mmu_find_table>
			if (!table_found)
 1109b38:	72001c1f 	tst	w0, #0xff
 1109b3c:	54000121 	b.ne	1109b60 <core_mmu_map_region+0xd4>  // b.any
				panic("can't find table for mapping");
 1109b40:	b0000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 1109b44:	b0000242 	adrp	x2, 1152000 <trace_ext_prefix+0x2e>
 1109b48:	9119f063 	add	x3, x3, #0x67c
 1109b4c:	91319c42 	add	x2, x2, #0xc67
 1109b50:	5280cd01 	mov	w1, #0x668                 	// #1640
				panic("Page is already mapped");
 1109b54:	b0000240 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 1109b58:	91084800 	add	x0, x0, #0x212
 1109b5c:	94002643 	bl	1113468 <__do_panic>
 1109b60:	f94047f4 	ldr	x20, [sp, #136]
 1109b64:	b94097e0 	ldr	w0, [sp, #148]
 1109b68:	cb1402b4 	sub	x20, x21, x20
	if ((vaddr | paddr) & (block_size - 1))
 1109b6c:	f94037e2 	ldr	x2, [sp, #104]
 1109b70:	9ac02694 	lsr	x20, x20, x0
					      1 << tbl_info.shift, mm)) {
 1109b74:	1ac02320 	lsl	w0, w25, w0
			if (!can_map_at_level(paddr, vaddr, size_left,
 1109b78:	93407c00 	sxtw	x0, w0
	if ((vaddr | paddr) & (block_size - 1))
 1109b7c:	d1000401 	sub	x1, x0, #0x1
 1109b80:	ea01005f 	tst	x2, x1
 1109b84:	54000201 	b.ne	1109bc4 <core_mmu_map_region+0x138>  // b.any
	if (size_left < block_size)
 1109b88:	eb0002ff 	cmp	x23, x0
 1109b8c:	540001c3 	b.cc	1109bc4 <core_mmu_map_region+0x138>  // b.lo, b.ul, b.last
			core_mmu_get_entry(&tbl_info, idx, NULL, &old_attr);
 1109b90:	aa1a03e0 	mov	x0, x26
 1109b94:	aa1b03e3 	mov	x3, x27
 1109b98:	2a1403e1 	mov	w1, w20
 1109b9c:	d2800002 	mov	x2, #0x0                   	// #0
 1109ba0:	97ffffa7 	bl	1109a3c <core_mmu_get_entry>
			if (old_attr)
 1109ba4:	b9407fe0 	ldr	w0, [sp, #124]
 1109ba8:	340003e0 	cbz	w0, 1109c24 <core_mmu_map_region+0x198>
				panic("Page is already mapped");
 1109bac:	b0000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 1109bb0:	b0000242 	adrp	x2, 1152000 <trace_ext_prefix+0x2e>
 1109bb4:	911ac063 	add	x3, x3, #0x6b0
 1109bb8:	91319c42 	add	x2, x2, #0xc67
 1109bbc:	5280cf81 	mov	w1, #0x67c                 	// #1660
 1109bc0:	17ffffe5 	b	1109b54 <core_mmu_map_region+0xc8>
				if (!core_mmu_entry_to_finer_grained(&tbl_info,
 1109bc4:	b9402262 	ldr	w2, [x19, #32]
 1109bc8:	2a1403e1 	mov	w1, w20
 1109bcc:	aa1a03e0 	mov	x0, x26
 1109bd0:	d34b2c42 	ubfx	x2, x2, #11, #1
 1109bd4:	94000491 	bl	110ae18 <core_mmu_entry_to_finer_grained>
 1109bd8:	72001c1f 	tst	w0, #0xff
 1109bdc:	540000e1 	b.ne	1109bf8 <core_mmu_map_region+0x16c>  // b.any
					panic("Can't divide MMU entry");
 1109be0:	b0000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 1109be4:	b0000242 	adrp	x2, 1152000 <trace_ext_prefix+0x2e>
 1109be8:	911a6463 	add	x3, x3, #0x699
 1109bec:	91319c42 	add	x2, x2, #0xc67
 1109bf0:	5280ce81 	mov	w1, #0x674                 	// #1652
 1109bf4:	17ffffd8 	b	1109b54 <core_mmu_map_region+0xc8>
				level++;
 1109bf8:	1100079c 	add	w28, w28, #0x1
			assert(level <= CORE_MMU_PGDIR_LEVEL);
 1109bfc:	7100139f 	cmp	w28, #0x4
 1109c00:	54fff921 	b.ne	1109b24 <core_mmu_map_region+0x98>  // b.any
 1109c04:	b0000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 1109c08:	b0000241 	adrp	x1, 1152000 <trace_ext_prefix+0x2e>
 1109c0c:	b0000240 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 1109c10:	91319c63 	add	x3, x3, #0xc67
 1109c14:	91084821 	add	x1, x1, #0x212
 1109c18:	91197800 	add	x0, x0, #0x65e
 1109c1c:	5280cc62 	mov	w2, #0x663                 	// #1635
 1109c20:	17ffffbc 	b	1109b10 <core_mmu_map_region+0x84>
			core_mmu_set_entry(&tbl_info, idx, paddr, mm->attr);
 1109c24:	b9402263 	ldr	w3, [x19, #32]
 1109c28:	aa1603e2 	mov	x2, x22
 1109c2c:	2a1403e1 	mov	w1, w20
 1109c30:	aa1a03e0 	mov	x0, x26
 1109c34:	97ffff28 	bl	11098d4 <core_mmu_set_entry>
			paddr += 1 << tbl_info.shift;
 1109c38:	b94097e0 	ldr	w0, [sp, #148]
 1109c3c:	52800021 	mov	w1, #0x1                   	// #1
 1109c40:	1ac02020 	lsl	w0, w1, w0
 1109c44:	8b20c2d6 	add	x22, x22, w0, sxtw
			vaddr += 1 << tbl_info.shift;
 1109c48:	8b20c2b5 	add	x21, x21, w0, sxtw
			size_left -= 1 << tbl_info.shift;
 1109c4c:	cb20c2f7 	sub	x23, x23, w0, sxtw
			break;
 1109c50:	17ffffa0 	b	1109ad0 <core_mmu_map_region+0x44>

0000000001109c54 <core_mmu_unmap_pages>:

	return TEE_SUCCESS;
}

void core_mmu_unmap_pages(vaddr_t vstart, size_t num_pages)
{
 1109c54:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
 1109c58:	910003fd 	mov	x29, sp
 1109c5c:	a90153f3 	stp	x19, x20, [sp, #16]
 1109c60:	aa0003f3 	mov	x19, x0
 1109c64:	aa0103f4 	mov	x20, x1
 1109c68:	a9025bf5 	stp	x21, x22, [sp, #32]
 1109c6c:	a90363f7 	stp	x23, x24, [sp, #48]
	struct tee_mmap_region *mm;
	size_t i;
	unsigned int idx;
	uint32_t exceptions;

	exceptions = mmu_lock();
 1109c70:	97fffaf3 	bl	110883c <mmu_lock>
 1109c74:	2a0003f7 	mov	w23, w0

	mm = find_map_by_va((void *)vstart);
 1109c78:	aa1303e0 	mov	x0, x19
 1109c7c:	97fff989 	bl	11082a0 <find_map_by_va>
	if (!mm || !va_is_in_map(mm, vstart + num_pages * SMALL_PAGE_SIZE - 1))
 1109c80:	b40000e0 	cbz	x0, 1109c9c <core_mmu_unmap_pages+0x48>
 1109c84:	aa0003e3 	mov	x3, x0
 1109c88:	8b143261 	add	x1, x19, x20, lsl #12
 1109c8c:	d1000421 	sub	x1, x1, #0x1
 1109c90:	97fff978 	bl	1108270 <va_is_in_map>
 1109c94:	72001c1f 	tst	w0, #0xff
 1109c98:	54000121 	b.ne	1109cbc <core_mmu_unmap_pages+0x68>  // b.any
		panic("VA does not belong to any known mm region");
 1109c9c:	b0000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 1109ca0:	b0000242 	adrp	x2, 1152000 <trace_ext_prefix+0x2e>
 1109ca4:	911be063 	add	x3, x3, #0x6f8
 1109ca8:	91323842 	add	x2, x2, #0xc8e
 1109cac:	5280e481 	mov	w1, #0x724                 	// #1828

	if (!core_mmu_is_dynamic_vaspace(mm))
		panic("Trying to unmap static region");
 1109cb0:	b0000240 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 1109cb4:	91084800 	add	x0, x0, #0x212
 1109cb8:	940025ec 	bl	1113468 <__do_panic>
 * @mm:		memory region to be checked
 * @returns result of the check
 */
static inline bool core_mmu_is_dynamic_vaspace(struct tee_mmap_region *mm)
{
	return mm->type == MEM_AREA_RES_VASPACE ||
 1109cbc:	b9400060 	ldr	w0, [x3]

	for (i = 0; i < num_pages; i++, vstart += SMALL_PAGE_SIZE) {
 1109cc0:	d2800015 	mov	x21, #0x0                   	// #0
 1109cc4:	51004000 	sub	w0, w0, #0x10
	if (!core_mmu_is_dynamic_vaspace(mm))
 1109cc8:	7100041f 	cmp	w0, #0x1
 1109ccc:	540001a8 	b.hi	1109d00 <core_mmu_unmap_pages+0xac>  // b.pmore
		if (!core_mmu_find_table(NULL, vstart, UINT_MAX, &tbl_info))
 1109cd0:	910103f8 	add	x24, sp, #0x40
 1109cd4:	8b153276 	add	x22, x19, x21, lsl #12
	for (i = 0; i < num_pages; i++, vstart += SMALL_PAGE_SIZE) {
 1109cd8:	eb1402bf 	cmp	x21, x20
 1109cdc:	540001e1 	b.ne	1109d18 <core_mmu_unmap_pages+0xc4>  // b.any
			panic("Invalid pagetable level");

		idx = core_mmu_va2idx(&tbl_info, vstart);
		core_mmu_set_entry(&tbl_info, idx, 0, 0);
	}
	tlbi_all();
 1109ce0:	97ffea2a 	bl	1104588 <tlbi_all>

	mmu_unlock(exceptions);
 1109ce4:	2a1703e0 	mov	w0, w23
 1109ce8:	97fffaf9 	bl	11088cc <mmu_unlock>
}
 1109cec:	a94153f3 	ldp	x19, x20, [sp, #16]
 1109cf0:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1109cf4:	a94363f7 	ldp	x23, x24, [sp, #48]
 1109cf8:	a8c67bfd 	ldp	x29, x30, [sp], #96
 1109cfc:	d65f03c0 	ret
		panic("Trying to unmap static region");
 1109d00:	b0000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 1109d04:	b0000242 	adrp	x2, 1152000 <trace_ext_prefix+0x2e>
 1109d08:	911e2863 	add	x3, x3, #0x78a
 1109d0c:	91323842 	add	x2, x2, #0xc8e
 1109d10:	5280e4e1 	mov	w1, #0x727                 	// #1831
 1109d14:	17ffffe7 	b	1109cb0 <core_mmu_unmap_pages+0x5c>
		if (!core_mmu_find_table(NULL, vstart, UINT_MAX, &tbl_info))
 1109d18:	aa1803e3 	mov	x3, x24
 1109d1c:	aa1603e1 	mov	x1, x22
 1109d20:	12800002 	mov	w2, #0xffffffff            	// #-1
 1109d24:	d2800000 	mov	x0, #0x0                   	// #0
 1109d28:	940003fa 	bl	110ad10 <core_mmu_find_table>
 1109d2c:	72001c1f 	tst	w0, #0xff
 1109d30:	540000e1 	b.ne	1109d4c <core_mmu_unmap_pages+0xf8>  // b.any
			panic("Can't find pagetable");
 1109d34:	b0000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 1109d38:	b0000242 	adrp	x2, 1152000 <trace_ext_prefix+0x2e>
 1109d3c:	911ea063 	add	x3, x3, #0x7a8
 1109d40:	91323842 	add	x2, x2, #0xc8e
 1109d44:	5280e561 	mov	w1, #0x72b                 	// #1835
 1109d48:	17ffffda 	b	1109cb0 <core_mmu_unmap_pages+0x5c>
		if (tbl_info.shift != SMALL_PAGE_SHIFT)
 1109d4c:	b94057e0 	ldr	w0, [sp, #84]
 1109d50:	7100301f 	cmp	w0, #0xc
 1109d54:	540000e0 	b.eq	1109d70 <core_mmu_unmap_pages+0x11c>  // b.none
			panic("Invalid pagetable level");
 1109d58:	b0000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 1109d5c:	b0000242 	adrp	x2, 1152000 <trace_ext_prefix+0x2e>
 1109d60:	911ef463 	add	x3, x3, #0x7bd
 1109d64:	91323842 	add	x2, x2, #0xc8e
 1109d68:	5280e5c1 	mov	w1, #0x72e                 	// #1838
 1109d6c:	17ffffd1 	b	1109cb0 <core_mmu_unmap_pages+0x5c>
	return (va - tbl_info->va_base) >> tbl_info->shift;
 1109d70:	f94027e1 	ldr	x1, [sp, #72]
		core_mmu_set_entry(&tbl_info, idx, 0, 0);
 1109d74:	aa1803e0 	mov	x0, x24
	for (i = 0; i < num_pages; i++, vstart += SMALL_PAGE_SIZE) {
 1109d78:	910006b5 	add	x21, x21, #0x1
		core_mmu_set_entry(&tbl_info, idx, 0, 0);
 1109d7c:	52800003 	mov	w3, #0x0                   	// #0
 1109d80:	cb0102c1 	sub	x1, x22, x1
 1109d84:	d2800002 	mov	x2, #0x0                   	// #0
 1109d88:	d34cac21 	ubfx	x1, x1, #12, #32
 1109d8c:	97fffed2 	bl	11098d4 <core_mmu_set_entry>
	for (i = 0; i < num_pages; i++, vstart += SMALL_PAGE_SIZE) {
 1109d90:	17ffffd1 	b	1109cd4 <core_mmu_unmap_pages+0x80>

0000000001109d94 <core_mmu_map_pages>:
{
 1109d94:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
 1109d98:	910003fd 	mov	x29, sp
 1109d9c:	a90153f3 	stp	x19, x20, [sp, #16]
 1109da0:	aa0003f3 	mov	x19, x0
	assert(!(core_mmu_type_to_attr(memtype) & TEE_MATTR_PX));
 1109da4:	2a0303e0 	mov	w0, w3
{
 1109da8:	a9025bf5 	stp	x21, x22, [sp, #32]
 1109dac:	aa0203f6 	mov	x22, x2
 1109db0:	a90363f7 	stp	x23, x24, [sp, #48]
 1109db4:	aa0103f7 	mov	x23, x1
 1109db8:	2a0303f8 	mov	w24, w3
 1109dbc:	a9046bf9 	stp	x25, x26, [sp, #64]
 1109dc0:	a90573fb 	stp	x27, x28, [sp, #80]
	assert(!(core_mmu_type_to_attr(memtype) & TEE_MATTR_PX));
 1109dc4:	97fffb66 	bl	1108b5c <core_mmu_type_to_attr>
 1109dc8:	2a0003f9 	mov	w25, w0
 1109dcc:	36300159 	tbz	w25, #6, 1109df4 <core_mmu_map_pages+0x60>
 1109dd0:	b0000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 1109dd4:	b0000241 	adrp	x1, 1152000 <trace_ext_prefix+0x2e>
 1109dd8:	9131ec63 	add	x3, x3, #0xc7b
 1109ddc:	91084821 	add	x1, x1, #0x212
 1109de0:	b0000240 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 1109de4:	911b1c00 	add	x0, x0, #0x6c7
 1109de8:	5280d2a2 	mov	w2, #0x695                 	// #1685
 1109dec:	94002130 	bl	11122ac <_assert_log>
 1109df0:	94002140 	bl	11122f0 <_assert_break>
	if (vaddr & SMALL_PAGE_MASK)
 1109df4:	f2402e74 	ands	x20, x19, #0xfff
 1109df8:	54000060 	b.eq	1109e04 <core_mmu_map_pages+0x70>  // b.none
	return ret;
 1109dfc:	129fff3a 	mov	w26, #0xffff0006            	// #-65530
 1109e00:	14000024 	b	1109e90 <core_mmu_map_pages+0xfc>
 1109e04:	121a001a 	and	w26, w0, #0x40
	exceptions = mmu_lock();
 1109e08:	97fffa8d 	bl	110883c <mmu_lock>
 1109e0c:	2a0003f5 	mov	w21, w0
	mm = find_map_by_va((void *)vaddr);
 1109e10:	aa1303e0 	mov	x0, x19
 1109e14:	97fff923 	bl	11082a0 <find_map_by_va>
 1109e18:	aa0003e3 	mov	x3, x0
	if (!mm || !va_is_in_map(mm, vaddr + num_pages * SMALL_PAGE_SIZE - 1))
 1109e1c:	b40000c0 	cbz	x0, 1109e34 <core_mmu_map_pages+0xa0>
 1109e20:	8b163261 	add	x1, x19, x22, lsl #12
 1109e24:	d1000421 	sub	x1, x1, #0x1
 1109e28:	97fff912 	bl	1108270 <va_is_in_map>
 1109e2c:	72001c1f 	tst	w0, #0xff
 1109e30:	54000121 	b.ne	1109e54 <core_mmu_map_pages+0xc0>  // b.any
		panic("VA does not belong to any known mm region");
 1109e34:	b0000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 1109e38:	b0000242 	adrp	x2, 1152000 <trace_ext_prefix+0x2e>
 1109e3c:	911be063 	add	x3, x3, #0x6f8
 1109e40:	9131ec42 	add	x2, x2, #0xc7b
 1109e44:	5280d401 	mov	w1, #0x6a0                 	// #1696
		panic("Trying to map into static region");
 1109e48:	b0000240 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 1109e4c:	91084800 	add	x0, x0, #0x212
 1109e50:	94002586 	bl	1113468 <__do_panic>
	return mm->type == MEM_AREA_RES_VASPACE ||
 1109e54:	b9400060 	ldr	w0, [x3]
 1109e58:	51004000 	sub	w0, w0, #0x10
	if (!core_mmu_is_dynamic_vaspace(mm))
 1109e5c:	7100041f 	cmp	w0, #0x1
 1109e60:	54000288 	b.hi	1109eb0 <core_mmu_map_pages+0x11c>  // b.pmore
	secure = core_mmu_type_to_attr(memtype) & TEE_MATTR_SECURE;
 1109e64:	d34b2f20 	ubfx	x0, x25, #11, #1
			if (!core_mmu_find_table(NULL, vaddr, UINT_MAX,
 1109e68:	910203f9 	add	x25, sp, #0x80
	secure = core_mmu_type_to_attr(memtype) & TEE_MATTR_SECURE;
 1109e6c:	f90033e0 	str	x0, [sp, #96]
		core_mmu_get_entry(&tbl_info, idx, NULL, &old_attr);
 1109e70:	9101f3e0 	add	x0, sp, #0x7c
 1109e74:	f90037e0 	str	x0, [sp, #104]
 1109e78:	8b14327b 	add	x27, x19, x20, lsl #12
	for (i = 0; i < num_pages; i++) {
 1109e7c:	eb16029f 	cmp	x20, x22
 1109e80:	54000241 	b.ne	1109ec8 <core_mmu_map_pages+0x134>  // b.any
	asm volatile ("dsb ishst");
 1109e84:	d5033a9f 	dsb	ishst
	mmu_unlock(exceptions);
 1109e88:	2a1503e0 	mov	w0, w21
 1109e8c:	97fffa90 	bl	11088cc <mmu_unlock>
}
 1109e90:	2a1a03e0 	mov	w0, w26
 1109e94:	a94153f3 	ldp	x19, x20, [sp, #16]
 1109e98:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1109e9c:	a94363f7 	ldp	x23, x24, [sp, #48]
 1109ea0:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1109ea4:	a94573fb 	ldp	x27, x28, [sp, #80]
 1109ea8:	a8ca7bfd 	ldp	x29, x30, [sp], #160
 1109eac:	d65f03c0 	ret
		panic("Trying to map into static region");
 1109eb0:	b0000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 1109eb4:	b0000242 	adrp	x2, 1152000 <trace_ext_prefix+0x2e>
 1109eb8:	911c8863 	add	x3, x3, #0x722
 1109ebc:	9131ec42 	add	x2, x2, #0xc7b
 1109ec0:	5280d461 	mov	w1, #0x6a3                 	// #1699
 1109ec4:	17ffffe1 	b	1109e48 <core_mmu_map_pages+0xb4>
		if (pages[i] & SMALL_PAGE_MASK) {
 1109ec8:	f8747ae0 	ldr	x0, [x23, x20, lsl #3]
 1109ecc:	f2402c1f 	tst	x0, #0xfff
 1109ed0:	54000100 	b.eq	1109ef0 <core_mmu_map_pages+0x15c>  // b.none
	mmu_unlock(exceptions);
 1109ed4:	2a1503e0 	mov	w0, w21
 1109ed8:	97fffa7d 	bl	11088cc <mmu_unlock>
	if (i)
 1109edc:	b4fff914 	cbz	x20, 1109dfc <core_mmu_map_pages+0x68>
		core_mmu_unmap_pages(vstart, i);
 1109ee0:	aa1403e1 	mov	x1, x20
 1109ee4:	aa1303e0 	mov	x0, x19
 1109ee8:	97ffff5b 	bl	1109c54 <core_mmu_unmap_pages>
 1109eec:	17ffffc4 	b	1109dfc <core_mmu_map_pages+0x68>
			if (!core_mmu_find_table(NULL, vaddr, UINT_MAX,
 1109ef0:	aa1903e3 	mov	x3, x25
 1109ef4:	aa1b03e1 	mov	x1, x27
 1109ef8:	12800002 	mov	w2, #0xffffffff            	// #-1
 1109efc:	d2800000 	mov	x0, #0x0                   	// #0
 1109f00:	94000384 	bl	110ad10 <core_mmu_find_table>
 1109f04:	72001c1f 	tst	w0, #0xff
 1109f08:	540000e1 	b.ne	1109f24 <core_mmu_map_pages+0x190>  // b.any
				panic("Can't find pagetable for vaddr ");
 1109f0c:	b0000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 1109f10:	b0000242 	adrp	x2, 1152000 <trace_ext_prefix+0x2e>
 1109f14:	911d0c63 	add	x3, x3, #0x743
 1109f18:	9131ec42 	add	x2, x2, #0xc7b
 1109f1c:	5280d5c1 	mov	w1, #0x6ae                 	// #1710
 1109f20:	17ffffca 	b	1109e48 <core_mmu_map_pages+0xb4>
	return (va - tbl_info->va_base) >> tbl_info->shift;
 1109f24:	f94047e4 	ldr	x4, [sp, #136]
 1109f28:	b94097e0 	ldr	w0, [sp, #148]
 1109f2c:	cb040364 	sub	x4, x27, x4
			if (tbl_info.shift == SMALL_PAGE_SHIFT)
 1109f30:	7100301f 	cmp	w0, #0xc
 1109f34:	9ac0249c 	lsr	x28, x4, x0
 1109f38:	540001a0 	b.eq	1109f6c <core_mmu_map_pages+0x1d8>  // b.none
			if (!core_mmu_entry_to_finer_grained(&tbl_info, idx,
 1109f3c:	394183e2 	ldrb	w2, [sp, #96]
 1109f40:	2a1c03e1 	mov	w1, w28
 1109f44:	aa1903e0 	mov	x0, x25
 1109f48:	940003b4 	bl	110ae18 <core_mmu_entry_to_finer_grained>
 1109f4c:	72001c1f 	tst	w0, #0xff
 1109f50:	54fffd01 	b.ne	1109ef0 <core_mmu_map_pages+0x15c>  // b.any
				panic("Failed to spread pgdir on small tables");
 1109f54:	b0000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 1109f58:	b0000242 	adrp	x2, 1152000 <trace_ext_prefix+0x2e>
 1109f5c:	911d8c63 	add	x3, x3, #0x763
 1109f60:	9131ec42 	add	x2, x2, #0xc7b
 1109f64:	5280d6e1 	mov	w1, #0x6b7                 	// #1719
 1109f68:	17ffffb8 	b	1109e48 <core_mmu_map_pages+0xb4>
		core_mmu_get_entry(&tbl_info, idx, NULL, &old_attr);
 1109f6c:	f94037e3 	ldr	x3, [sp, #104]
 1109f70:	aa1903e0 	mov	x0, x25
 1109f74:	2a1c03e1 	mov	w1, w28
 1109f78:	d2800002 	mov	x2, #0x0                   	// #0
 1109f7c:	97fffeb0 	bl	1109a3c <core_mmu_get_entry>
		if (old_attr)
 1109f80:	b9407fe0 	ldr	w0, [sp, #124]
 1109f84:	340000e0 	cbz	w0, 1109fa0 <core_mmu_map_pages+0x20c>
			panic("Page is already mapped");
 1109f88:	b0000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 1109f8c:	b0000242 	adrp	x2, 1152000 <trace_ext_prefix+0x2e>
 1109f90:	911ac063 	add	x3, x3, #0x6b0
 1109f94:	9131ec42 	add	x2, x2, #0xc7b
 1109f98:	5280d781 	mov	w1, #0x6bc                 	// #1724
 1109f9c:	17ffffab 	b	1109e48 <core_mmu_map_pages+0xb4>
		core_mmu_set_entry(&tbl_info, idx, pages[i],
 1109fa0:	f8747afb 	ldr	x27, [x23, x20, lsl #3]
 1109fa4:	2a1803e0 	mov	w0, w24
 1109fa8:	97fffaed 	bl	1108b5c <core_mmu_type_to_attr>
	for (i = 0; i < num_pages; i++) {
 1109fac:	91000694 	add	x20, x20, #0x1
		core_mmu_set_entry(&tbl_info, idx, pages[i],
 1109fb0:	2a0003e3 	mov	w3, w0
 1109fb4:	aa1b03e2 	mov	x2, x27
 1109fb8:	2a1c03e1 	mov	w1, w28
 1109fbc:	aa1903e0 	mov	x0, x25
 1109fc0:	97fffe45 	bl	11098d4 <core_mmu_set_entry>
	for (i = 0; i < num_pages; i++) {
 1109fc4:	17ffffad 	b	1109e78 <core_mmu_map_pages+0xe4>

0000000001109fc8 <asid_alloc>:

	return true;
}

unsigned int asid_alloc(void)
{
 1109fc8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	uint32_t exceptions = thread_mask_exceptions(THREAD_EXCP_ALL);
 1109fcc:	528000e0 	mov	w0, #0x7                   	// #7
 1109fd0:	910003fd 	mov	x29, sp
 1109fd4:	a90153f3 	stp	x19, x20, [sp, #16]
	cpu_spin_lock_dldetect(func, line, lock);
 1109fd8:	f00002f4 	adrp	x20, 1168000 <data.5093+0x9e28>
 1109fdc:	f90013f5 	str	x21, [sp, #32]
	uint32_t exceptions = thread_mask_exceptions(THREAD_EXCP_ALL);
 1109fe0:	97ffec56 	bl	1105138 <thread_mask_exceptions>
	cpu_spin_lock_dldetect(func, line, lock);
 1109fe4:	9128b282 	add	x2, x20, #0xa2c
	uint32_t exceptions = thread_mask_exceptions(THREAD_EXCP_ALL);
 1109fe8:	2a0003f3 	mov	w19, w0
	cpu_spin_lock_dldetect(func, line, lock);
 1109fec:	5280fb21 	mov	w1, #0x7d9                 	// #2009
 1109ff0:	b0000240 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 1109ff4:	91328c00 	add	x0, x0, #0xca3
 1109ff8:	97fff968 	bl	1108598 <cpu_spin_lock_dldetect>
	uint32_t exceptions = cpu_spin_lock_xsave(&g_asid_spinlock);
	unsigned int r;
	int i;

	bit_ffc(g_asid, MMU_NUM_ASID_PAIRS, &i);
 1109ffc:	f00002e2 	adrp	x2, 1168000 <data.5093+0x9e28>
 110a000:	912a4444 	add	x4, x2, #0xa91
 110a004:	d2800003 	mov	x3, #0x0                   	// #0
 110a008:	38646860 	ldrb	w0, [x3, x4]
 110a00c:	7103fc1f 	cmp	w0, #0xff
 110a010:	540002a0 	b.eq	110a064 <asid_alloc+0x9c>  // b.none
 110a014:	531d7061 	lsl	w1, w3, #3
 110a018:	37000200 	tbnz	w0, #0, 110a058 <asid_alloc+0x90>
 110a01c:	7100fc3f 	cmp	w1, #0x3f
	if (i == -1) {
		r = 0;
 110a020:	52800015 	mov	w21, #0x0                   	// #0
	bit_ffc(g_asid, MMU_NUM_ASID_PAIRS, &i);
 110a024:	5400028c 	b.gt	110a074 <asid_alloc+0xac>
	} else {
		bit_set(g_asid, i);
 110a028:	13037c20 	asr	w0, w1, #3
 110a02c:	912a4442 	add	x2, x2, #0xa91
 110a030:	12000824 	and	w4, w1, #0x7
 110a034:	52800023 	mov	w3, #0x1                   	// #1
 110a038:	93407c00 	sxtw	x0, w0
		r = (i + 1) * 2;
 110a03c:	11000421 	add	w1, w1, #0x1
		bit_set(g_asid, i);
 110a040:	1ac42063 	lsl	w3, w3, w4
		r = (i + 1) * 2;
 110a044:	531f7835 	lsl	w21, w1, #1
		bit_set(g_asid, i);
 110a048:	38606844 	ldrb	w4, [x2, x0]
 110a04c:	2a040063 	orr	w3, w3, w4
 110a050:	38206843 	strb	w3, [x2, x0]
		r = (i + 1) * 2;
 110a054:	14000008 	b	110a074 <asid_alloc+0xac>
	bit_ffc(g_asid, MMU_NUM_ASID_PAIRS, &i);
 110a058:	11000421 	add	w1, w1, #0x1
 110a05c:	53017c00 	lsr	w0, w0, #1
 110a060:	17ffffee 	b	110a018 <asid_alloc+0x50>
 110a064:	91000463 	add	x3, x3, #0x1
 110a068:	f100207f 	cmp	x3, #0x8
 110a06c:	54fffce1 	b.ne	110a008 <asid_alloc+0x40>  // b.any
		r = 0;
 110a070:	52800015 	mov	w21, #0x0                   	// #0
	cpu_spin_unlock(lock);
 110a074:	9128b280 	add	x0, x20, #0xa2c
 110a078:	97fffa01 	bl	110887c <cpu_spin_unlock>
	thread_unmask_exceptions(exceptions);
 110a07c:	2a1303e0 	mov	w0, w19
 110a080:	97ffec3b 	bl	110516c <thread_unmask_exceptions>
	}

	cpu_spin_unlock_xrestore(&g_asid_spinlock, exceptions);
	return r;
}
 110a084:	2a1503e0 	mov	w0, w21
 110a088:	a94153f3 	ldp	x19, x20, [sp, #16]
 110a08c:	f94013f5 	ldr	x21, [sp, #32]
 110a090:	a8c37bfd 	ldp	x29, x30, [sp], #48
 110a094:	d65f03c0 	ret

000000000110a098 <asid_free>:

void asid_free(unsigned int asid)
{
 110a098:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 110a09c:	910003fd 	mov	x29, sp
 110a0a0:	a90153f3 	stp	x19, x20, [sp, #16]
 110a0a4:	2a0003f3 	mov	w19, w0
	uint32_t exceptions = thread_mask_exceptions(THREAD_EXCP_ALL);
 110a0a8:	528000e0 	mov	w0, #0x7                   	// #7
 110a0ac:	a9025bf5 	stp	x21, x22, [sp, #32]
	cpu_spin_lock_dldetect(func, line, lock);
 110a0b0:	90000256 	adrp	x22, 1152000 <trace_ext_prefix+0x2e>
 110a0b4:	d00002f4 	adrp	x20, 1168000 <data.5093+0x9e28>
 110a0b8:	f9001bf7 	str	x23, [sp, #48]
	uint32_t exceptions = thread_mask_exceptions(THREAD_EXCP_ALL);
 110a0bc:	97ffec1f 	bl	1105138 <thread_mask_exceptions>
	cpu_spin_lock_dldetect(func, line, lock);
 110a0c0:	9132bad7 	add	x23, x22, #0xcae
	uint32_t exceptions = thread_mask_exceptions(THREAD_EXCP_ALL);
 110a0c4:	2a0003f5 	mov	w21, w0
	cpu_spin_lock_dldetect(func, line, lock);
 110a0c8:	9128b282 	add	x2, x20, #0xa2c
 110a0cc:	aa1703e0 	mov	x0, x23
 110a0d0:	5280fd61 	mov	w1, #0x7eb                 	// #2027
 110a0d4:	97fff931 	bl	1108598 <cpu_spin_lock_dldetect>
	uint32_t exceptions = cpu_spin_lock_xsave(&g_asid_spinlock);

	/* Only even ASIDs are supposed to be allocated */
	assert(!(asid & 1));
 110a0d8:	36000133 	tbz	w19, #0, 110a0fc <asid_free+0x64>
 110a0dc:	90000241 	adrp	x1, 1152000 <trace_ext_prefix+0x2e>
 110a0e0:	90000240 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 110a0e4:	aa1703e3 	mov	x3, x23
 110a0e8:	91084821 	add	x1, x1, #0x212
 110a0ec:	911f5400 	add	x0, x0, #0x7d5
 110a0f0:	5280fdc2 	mov	w2, #0x7ee                 	// #2030

	if (asid) {
		int i = (asid - 1) / 2;

		assert(i < MMU_NUM_ASID_PAIRS && bit_test(g_asid, i));
 110a0f4:	9400206e 	bl	11122ac <_assert_log>
 110a0f8:	9400207e 	bl	11122f0 <_assert_break>
	if (asid) {
 110a0fc:	340002f3 	cbz	w19, 110a158 <asid_free+0xc0>
		int i = (asid - 1) / 2;
 110a100:	51000673 	sub	w19, w19, #0x1
		assert(i < MMU_NUM_ASID_PAIRS && bit_test(g_asid, i));
 110a104:	7101fe7f 	cmp	w19, #0x7f
		int i = (asid - 1) / 2;
 110a108:	53017e61 	lsr	w1, w19, #1
		assert(i < MMU_NUM_ASID_PAIRS && bit_test(g_asid, i));
 110a10c:	54000108 	b.hi	110a12c <asid_free+0x94>  // b.pmore
 110a110:	d3437823 	ubfx	x3, x1, #3, #28
 110a114:	d00002e0 	adrp	x0, 1168000 <data.5093+0x9e28>
 110a118:	912a4400 	add	x0, x0, #0xa91
 110a11c:	12000822 	and	w2, w1, #0x7
 110a120:	38636804 	ldrb	w4, [x0, x3]
 110a124:	1ac22881 	asr	w1, w4, w2
 110a128:	37000101 	tbnz	w1, #0, 110a148 <asid_free+0xb0>
 110a12c:	90000241 	adrp	x1, 1152000 <trace_ext_prefix+0x2e>
 110a130:	90000240 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 110a134:	9132bac3 	add	x3, x22, #0xcae
 110a138:	91084821 	add	x1, x1, #0x212
 110a13c:	911f8400 	add	x0, x0, #0x7e1
 110a140:	5280fe62 	mov	w2, #0x7f3                 	// #2035
 110a144:	17ffffec 	b	110a0f4 <asid_free+0x5c>
		bit_clear(g_asid, i);
 110a148:	52800021 	mov	w1, #0x1                   	// #1
 110a14c:	1ac22021 	lsl	w1, w1, w2
 110a150:	0a210081 	bic	w1, w4, w1
 110a154:	38236801 	strb	w1, [x0, x3]
	cpu_spin_unlock(lock);
 110a158:	9128b280 	add	x0, x20, #0xa2c
 110a15c:	97fff9c8 	bl	110887c <cpu_spin_unlock>
	thread_unmask_exceptions(exceptions);
 110a160:	2a1503e0 	mov	w0, w21
	}

	cpu_spin_unlock_xrestore(&g_asid_spinlock, exceptions);
}
 110a164:	a94153f3 	ldp	x19, x20, [sp, #16]
 110a168:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110a16c:	f9401bf7 	ldr	x23, [sp, #48]
 110a170:	a8c47bfd 	ldp	x29, x30, [sp], #64
 110a174:	17ffebfe 	b	110516c <thread_unmask_exceptions>

000000000110a178 <virt_to_phys>:
{
}
#endif

paddr_t virt_to_phys(void *va)
{
 110a178:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 110a17c:	910003fd 	mov	x29, sp
 110a180:	a90153f3 	stp	x19, x20, [sp, #16]
 110a184:	f90013f5 	str	x21, [sp, #32]
 110a188:	aa0003f5 	mov	x21, x0
	uint32_t exceptions = thread_mask_exceptions(THREAD_EXCP_ALL);
 110a18c:	528000e0 	mov	w0, #0x7                   	// #7
 110a190:	97ffebea 	bl	1105138 <thread_mask_exceptions>
	asm volatile ("at	S1E1R, %0" : : "r" (va));
 110a194:	d5087815 	at	s1e1r, x21
	asm volatile ("isb");
 110a198:	d5033fdf 	isb
/* Alias for reading this register to avoid ifdefs in code */
#define read_midr() read_midr_el1()
DEFINE_U64_REG_READ_FUNC(par_el1)
 110a19c:	d5387413 	mrs	x19, par_el1
	if (par & PAR_F)
 110a1a0:	37000493 	tbnz	w19, #0, 110a230 <virt_to_phys+0xb8>
	*pa = (par & (par_pa_mask << PAR_PA_SHIFT)) |
 110a1a4:	92748e73 	and	x19, x19, #0xfffffffff000
		((vaddr_t)va & ((1 << PAR_PA_SHIFT) - 1));
 110a1a8:	92402ea6 	and	x6, x21, #0xfff
	*pa = (par & (par_pa_mask << PAR_PA_SHIFT)) |
 110a1ac:	aa060273 	orr	x19, x19, x6
	ret = true;
 110a1b0:	52800034 	mov	w20, #0x1                   	// #1
	thread_unmask_exceptions(exceptions);
 110a1b4:	97ffebee 	bl	110516c <thread_unmask_exceptions>
	paddr_t p = 0;
 110a1b8:	f9001fff 	str	xzr, [sp, #56]
	paddr_t pa = 0;

	if (!arm_va2pa_helper(va, &pa))
		pa = 0;
 110a1bc:	7100029f 	cmp	w20, #0x0
 110a1c0:	9a9f1273 	csel	x19, x19, xzr, ne  // ne = any
	if (core_mmu_user_va_range_is_defined()) {
 110a1c4:	940003be 	bl	110b0bc <core_mmu_user_va_range_is_defined>
 110a1c8:	72001c1f 	tst	w0, #0xff
 110a1cc:	540006c0 	b.eq	110a2a4 <virt_to_phys+0x12c>  // b.none
		core_mmu_get_user_va_range(&user_va_base, &user_va_size);
 110a1d0:	910123e1 	add	x1, sp, #0x48
 110a1d4:	910103e0 	add	x0, sp, #0x40
		size_t user_va_size = 0;
 110a1d8:	a9047fff 	stp	xzr, xzr, [sp, #64]
		core_mmu_get_user_va_range(&user_va_base, &user_va_size);
 110a1dc:	940003bd 	bl	110b0d0 <core_mmu_get_user_va_range>
		if (v >= user_va_base &&
 110a1e0:	f94023e1 	ldr	x1, [sp, #64]
 110a1e4:	eb0102bf 	cmp	x21, x1
 110a1e8:	540005e3 	b.cc	110a2a4 <virt_to_phys+0x12c>  // b.lo, b.ul, b.last
		    v <= (user_va_base - 1 + user_va_size)) {
 110a1ec:	f94027e0 	ldr	x0, [sp, #72]
 110a1f0:	8b000021 	add	x1, x1, x0
 110a1f4:	d1000421 	sub	x1, x1, #0x1
		if (v >= user_va_base &&
 110a1f8:	eb0102bf 	cmp	x21, x1
 110a1fc:	54000548 	b.hi	110a2a4 <virt_to_phys+0x12c>  // b.pmore
			if (!core_mmu_user_mapping_is_active()) {
 110a200:	940003fa 	bl	110b1e8 <core_mmu_user_mapping_is_active>
 110a204:	72001c1f 	tst	w0, #0xff
 110a208:	540001a1 	b.ne	110a23c <virt_to_phys+0xc4>  // b.any
				if (pa)
 110a20c:	b4000ab3 	cbz	x19, 110a360 <virt_to_phys+0x1e8>
					panic("issue in linear address space");
 110a210:	90000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 110a214:	90000242 	adrp	x2, 1152000 <trace_ext_prefix+0x2e>
 110a218:	91203c63 	add	x3, x3, #0x80f
 110a21c:	9132e042 	add	x2, x2, #0xcb8
 110a220:	528106e1 	mov	w1, #0x837                 	// #2103
				panic("bad pa");
 110a224:	90000240 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 110a228:	91084800 	add	x0, x0, #0x212
 110a22c:	9400248f 	bl	1113468 <__do_panic>
	paddr_t pa = 0;
 110a230:	d2800013 	mov	x19, #0x0                   	// #0
	bool ret = false;
 110a234:	52800014 	mov	w20, #0x0                   	// #0
 110a238:	17ffffdf 	b	110a1b4 <virt_to_phys+0x3c>
			res = vm_va2pa(to_user_mode_ctx(thread_get_tsd()->ctx),
 110a23c:	97ffee61 	bl	1105bc0 <thread_get_tsd>
 110a240:	f9400800 	ldr	x0, [x0, #16]
 110a244:	97fff914 	bl	1108694 <to_user_mode_ctx>
 110a248:	aa1503e1 	mov	x1, x21
 110a24c:	9100e3e2 	add	x2, sp, #0x38
 110a250:	94003ceb 	bl	11195fc <vm_va2pa>
			if (res == TEE_ERROR_NOT_SUPPORTED)
 110a254:	129ffea1 	mov	w1, #0xffff000a            	// #-65526
 110a258:	6b01001f 	cmp	w0, w1
 110a25c:	54000820 	b.eq	110a360 <virt_to_phys+0x1e8>  // b.none
			if (res == TEE_SUCCESS && pa != p)
 110a260:	35000140 	cbnz	w0, 110a288 <virt_to_phys+0x110>
 110a264:	f9401fe0 	ldr	x0, [sp, #56]
 110a268:	eb13001f 	cmp	x0, x19
 110a26c:	540007a0 	b.eq	110a360 <virt_to_phys+0x1e8>  // b.none
				panic("bad pa");
 110a270:	90000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 110a274:	90000242 	adrp	x2, 1152000 <trace_ext_prefix+0x2e>
 110a278:	9120b463 	add	x3, x3, #0x82d
 110a27c:	9132e042 	add	x2, x2, #0xcb8
 110a280:	52810801 	mov	w1, #0x840                 	// #2112
 110a284:	17ffffe8 	b	110a224 <virt_to_phys+0xac>
			if (res != TEE_SUCCESS && pa)
 110a288:	b40006d3 	cbz	x19, 110a360 <virt_to_phys+0x1e8>
				panic("false pa");
 110a28c:	90000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 110a290:	90000242 	adrp	x2, 1152000 <trace_ext_prefix+0x2e>
 110a294:	9120d063 	add	x3, x3, #0x834
 110a298:	9132e042 	add	x2, x2, #0xcb8
 110a29c:	52810841 	mov	w1, #0x842                 	// #2114
 110a2a0:	17ffffe1 	b	110a224 <virt_to_phys+0xac>
	map = find_map_by_va(va);
 110a2a4:	aa1503e0 	mov	x0, x21
 110a2a8:	97fff7fe 	bl	11082a0 <find_map_by_va>
 110a2ac:	aa0003e3 	mov	x3, x0
	if (!va_is_in_map(map, (vaddr_t)va))
 110a2b0:	aa1503e1 	mov	x1, x21
 110a2b4:	97fff7ef 	bl	1108270 <va_is_in_map>
 110a2b8:	72001c1f 	tst	w0, #0xff
 110a2bc:	54000221 	b.ne	110a300 <virt_to_phys+0x188>  // b.any
		if (pa) {
 110a2c0:	b4000513 	cbz	x19, 110a360 <virt_to_phys+0x1e8>
			DMSG("va %p unmapped, expect 0x%" PRIxPA, va, pa);
 110a2c4:	90000254 	adrp	x20, 1152000 <trace_ext_prefix+0x2e>
 110a2c8:	9132e294 	add	x20, x20, #0xcb8
 110a2cc:	52800023 	mov	w3, #0x1                   	// #1
 110a2d0:	52800062 	mov	w2, #0x3                   	// #3
 110a2d4:	52810dc1 	mov	w1, #0x86e                 	// #2158
 110a2d8:	aa1303e6 	mov	x6, x19
 110a2dc:	aa1503e5 	mov	x5, x21
 110a2e0:	aa1403e0 	mov	x0, x20
 110a2e4:	90000244 	adrp	x4, 1152000 <trace_ext_prefix+0x2e>
 110a2e8:	91217084 	add	x4, x4, #0x85c
 110a2ec:	9400ea96 	bl	1144d44 <trace_printf>
			panic();
 110a2f0:	aa1403e2 	mov	x2, x20
 110a2f4:	d2800003 	mov	x3, #0x0                   	// #0
 110a2f8:	52810de1 	mov	w1, #0x86f                 	// #2159
 110a2fc:	17ffffca 	b	110a224 <virt_to_phys+0xac>
	if (map->pa)
 110a300:	f9400466 	ldr	x6, [x3, #8]
 110a304:	b40002e6 	cbz	x6, 110a360 <virt_to_phys+0x1e8>
		*pa = map->pa + (vaddr_t)va  - map->va;
 110a308:	f9400860 	ldr	x0, [x3, #16]
 110a30c:	8b0602a6 	add	x6, x21, x6
 110a310:	cb0000c6 	sub	x6, x6, x0
 110a314:	f9001fe6 	str	x6, [sp, #56]
		if (p && pa != p) {
 110a318:	b4000246 	cbz	x6, 110a360 <virt_to_phys+0x1e8>
 110a31c:	eb1300df 	cmp	x6, x19
 110a320:	54000200 	b.eq	110a360 <virt_to_phys+0x1e8>  // b.none
			DMSG("va %p maps 0x%" PRIxPA ", expect 0x%" PRIxPA,
 110a324:	90000254 	adrp	x20, 1152000 <trace_ext_prefix+0x2e>
 110a328:	9132e294 	add	x20, x20, #0xcb8
 110a32c:	52800023 	mov	w3, #0x1                   	// #1
 110a330:	52800062 	mov	w2, #0x3                   	// #3
 110a334:	52810d01 	mov	w1, #0x868                 	// #2152
 110a338:	aa1303e7 	mov	x7, x19
 110a33c:	aa1503e5 	mov	x5, x21
 110a340:	aa1403e0 	mov	x0, x20
 110a344:	90000244 	adrp	x4, 1152000 <trace_ext_prefix+0x2e>
 110a348:	9120f484 	add	x4, x4, #0x83d
 110a34c:	9400ea7e 	bl	1144d44 <trace_printf>
			panic();
 110a350:	aa1403e2 	mov	x2, x20
 110a354:	d2800003 	mov	x3, #0x0                   	// #0
 110a358:	52810d41 	mov	w1, #0x86a                 	// #2154
 110a35c:	17ffffb2 	b	110a224 <virt_to_phys+0xac>
	check_pa_matches_va(va, pa);
	return pa;
}
 110a360:	aa1303e0 	mov	x0, x19
 110a364:	a94153f3 	ldp	x19, x20, [sp, #16]
 110a368:	f94013f5 	ldr	x21, [sp, #32]
 110a36c:	a8c57bfd 	ldp	x29, x30, [sp], #80
 110a370:	d65f03c0 	ret

000000000110a374 <core_vbuf_is>:
	if (len == 0)
 110a374:	b40001e2 	cbz	x2, 110a3b0 <core_vbuf_is+0x3c>
{
 110a378:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 110a37c:	910003fd 	mov	x29, sp
 110a380:	a90153f3 	stp	x19, x20, [sp, #16]
 110a384:	2a0003f4 	mov	w20, w0
 110a388:	aa0203f3 	mov	x19, x2
 110a38c:	aa0103e0 	mov	x0, x1
	p = virt_to_phys((void *)vbuf);
 110a390:	97ffff7a 	bl	110a178 <virt_to_phys>
 110a394:	aa0003e1 	mov	x1, x0
	if (!p)
 110a398:	b4000100 	cbz	x0, 110a3b8 <core_vbuf_is+0x44>
	return core_pbuf_is(attr, p, len);
 110a39c:	aa1303e2 	mov	x2, x19
 110a3a0:	2a1403e0 	mov	w0, w20
}
 110a3a4:	a94153f3 	ldp	x19, x20, [sp, #16]
 110a3a8:	a8c27bfd 	ldp	x29, x30, [sp], #32
	return core_pbuf_is(attr, p, len);
 110a3ac:	17fffc93 	b	11095f8 <core_pbuf_is>
		return true;
 110a3b0:	52800020 	mov	w0, #0x1                   	// #1
}
 110a3b4:	d65f03c0 	ret
		return false;
 110a3b8:	52800000 	mov	w0, #0x0                   	// #0
}
 110a3bc:	a94153f3 	ldp	x19, x20, [sp, #16]
 110a3c0:	a8c27bfd 	ldp	x29, x30, [sp], #32
 110a3c4:	d65f03c0 	ret

000000000110a3c8 <core_mmu_populate_user_map>:
{
 110a3c8:	a9b57bfd 	stp	x29, x30, [sp, #-176]!
 110a3cc:	910003fd 	mov	x29, sp
 110a3d0:	a90153f3 	stp	x19, x20, [sp, #16]
 110a3d4:	aa0103f4 	mov	x20, x1
 110a3d8:	aa0003f3 	mov	x19, x0
 110a3dc:	a9025bf5 	stp	x21, x22, [sp, #32]
 110a3e0:	a90363f7 	stp	x23, x24, [sp, #48]
 110a3e4:	a9046bf9 	stp	x25, x26, [sp, #64]
 110a3e8:	a90573fb 	stp	x27, x28, [sp, #80]
	struct core_mmu_table_info pg_info = { };
 110a3ec:	a906ffff 	stp	xzr, xzr, [sp, #104]
 110a3f0:	a907ffff 	stp	xzr, xzr, [sp, #120]
	struct pgt_cache *pgt_cache = &thread_get_tsd()->pgt_cache;
 110a3f4:	97ffedf3 	bl	1105bc0 <thread_get_tsd>
 110a3f8:	aa0003f5 	mov	x21, x0
	r = TAILQ_FIRST(&uctx->vm_info.regions);
 110a3fc:	f9400280 	ldr	x0, [x20]
	if (!r)
 110a400:	b4000300 	cbz	x0, 110a460 <core_mmu_populate_user_map+0x98>
	r_last = TAILQ_LAST(&uctx->vm_info.regions, vm_region_head);
 110a404:	f9400681 	ldr	x1, [x20, #8]
	core_mmu_set_info_table(&pg_info, dir_info->level + 1, 0, NULL);
 110a408:	9101a3f7 	add	x23, sp, #0x68
	pgt_alloc(pgt_cache, uctx->ts_ctx, r->va,
 110a40c:	f9400802 	ldr	x2, [x0, #16]
 110a410:	910062a0 	add	x0, x21, #0x18
	r_last = TAILQ_LAST(&uctx->vm_info.regions, vm_region_head);
 110a414:	f9400421 	ldr	x1, [x1, #8]
		return mobj->ops->get_pa(mobj, offs, granule, pa);
 110a418:	910223f8 	add	x24, sp, #0x88
 110a41c:	91002319 	add	x25, x24, #0x8
			size_t granule = BIT(pg_info->shift);
 110a420:	5280003a 	mov	w26, #0x1                   	// #1
	r_last = TAILQ_LAST(&uctx->vm_info.regions, vm_region_head);
 110a424:	f9400021 	ldr	x1, [x1]
		  r_last->va + r_last->size - 1);
 110a428:	a9410423 	ldp	x3, x1, [x1, #16]
 110a42c:	8b010063 	add	x3, x3, x1
	pgt_alloc(pgt_cache, uctx->ts_ctx, r->va,
 110a430:	f9412281 	ldr	x1, [x20, #576]
 110a434:	d1000463 	sub	x3, x3, #0x1
 110a438:	940005ea 	bl	110bbe0 <pgt_alloc>
	core_mmu_set_info_table(&pg_info, dir_info->level + 1, 0, NULL);
 110a43c:	b9401261 	ldr	w1, [x19, #16]
 110a440:	aa1703e0 	mov	x0, x23
 110a444:	d2800003 	mov	x3, #0x0                   	// #0
 110a448:	d2800002 	mov	x2, #0x0                   	// #0
 110a44c:	11000421 	add	w1, w1, #0x1
	pgt = SLIST_FIRST(pgt_cache);
 110a450:	f9400eb6 	ldr	x22, [x21, #24]
	core_mmu_set_info_table(&pg_info, dir_info->level + 1, 0, NULL);
 110a454:	94000216 	bl	110acac <core_mmu_set_info_table>
	TAILQ_FOREACH(r, &uctx->vm_info.regions, link)
 110a458:	f940029b 	ldr	x27, [x20]
 110a45c:	b500011b 	cbnz	x27, 110a47c <core_mmu_populate_user_map+0xb4>
}
 110a460:	a94153f3 	ldp	x19, x20, [sp, #16]
 110a464:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110a468:	a94363f7 	ldp	x23, x24, [sp, #48]
 110a46c:	a9446bf9 	ldp	x25, x26, [sp, #64]
 110a470:	a94573fb 	ldp	x27, x28, [sp, #80]
 110a474:	a8cb7bfd 	ldp	x29, x30, [sp], #176
 110a478:	d65f03c0 	ret
		.size = region->size,
 110a47c:	a9410375 	ldp	x21, x0, [x27, #16]
	struct tee_mmap_region r = {
 110a480:	a90983f5 	stp	x21, x0, [sp, #152]
		.attr = region->attr,
 110a484:	79404374 	ldrh	w20, [x27, #32]
	struct tee_mmap_region r = {
 110a488:	f90057ff 	str	xzr, [sp, #168]
		.attr = region->attr,
 110a48c:	b900abf4 	str	w20, [sp, #168]
	uint32_t pgt_attr = (r.attr & TEE_MATTR_SECURE) | TEE_MATTR_TABLE;
 110a490:	12150294 	and	w20, w20, #0x800
 110a494:	321d0294 	orr	w20, w20, #0x8
	struct tee_mmap_region r = {
 110a498:	a908ffff 	stp	xzr, xzr, [sp, #136]
	vaddr_t end = r.va + r.size;
 110a49c:	8b0002b5 	add	x21, x21, x0
	while (r.va < end) {
 110a4a0:	f9404fe1 	ldr	x1, [sp, #152]
 110a4a4:	eb0102bf 	cmp	x21, x1
 110a4a8:	54000068 	b.hi	110a4b4 <core_mmu_populate_user_map+0xec>  // b.pmore
	TAILQ_FOREACH(r, &uctx->vm_info.regions, link)
 110a4ac:	f940177b 	ldr	x27, [x27, #40]
 110a4b0:	17ffffeb 	b	110a45c <core_mmu_populate_user_map+0x94>
		if (!pg_info->table ||
 110a4b4:	a94683e2 	ldp	x2, x0, [sp, #104]
 110a4b8:	b4000082 	cbz	x2, 110a4c8 <core_mmu_populate_user_map+0x100>
		     r.va >= (pg_info->va_base + CORE_MMU_PGDIR_SIZE)) {
 110a4bc:	91480002 	add	x2, x0, #0x200, lsl #12
		if (!pg_info->table ||
 110a4c0:	eb01005f 	cmp	x2, x1
 110a4c4:	540004a8 	b.hi	110a558 <core_mmu_populate_user_map+0x190>  // b.pmore
			assert(r.va > pg_info->va_base);
 110a4c8:	eb00003f 	cmp	x1, x0
 110a4cc:	54000148 	b.hi	110a4f4 <core_mmu_populate_user_map+0x12c>  // b.pmore
 110a4d0:	90000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 110a4d4:	90000241 	adrp	x1, 1152000 <trace_ext_prefix+0x2e>
 110a4d8:	90000240 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 110a4dc:	91316463 	add	x3, x3, #0xc59
 110a4e0:	91084821 	add	x1, x1, #0x212
 110a4e4:	9121e400 	add	x0, x0, #0x879
 110a4e8:	5280c102 	mov	w2, #0x608                 	// #1544
			assert(*pgt); /* We should have alloced enough */
 110a4ec:	94001f70 	bl	11122ac <_assert_log>
 110a4f0:	94001f80 	bl	11122f0 <_assert_break>
 110a4f4:	f9400662 	ldr	x2, [x19, #8]
 110a4f8:	b9401660 	ldr	w0, [x19, #20]
 110a4fc:	cb020021 	sub	x1, x1, x2
 110a500:	9ac0243c 	lsr	x28, x1, x0
	return (idx << tbl_info->shift) + tbl_info->va_base;
 110a504:	1ac02380 	lsl	w0, w28, w0
 110a508:	8b020000 	add	x0, x0, x2
			pg_info->va_base = core_mmu_idx2va(dir_info, idx);
 110a50c:	f9003be0 	str	x0, [sp, #112]
			assert(*pgt); /* We should have alloced enough */
 110a510:	b5000136 	cbnz	x22, 110a534 <core_mmu_populate_user_map+0x16c>
 110a514:	90000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 110a518:	90000241 	adrp	x1, 1152000 <trace_ext_prefix+0x2e>
 110a51c:	90000240 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 110a520:	91316463 	add	x3, x3, #0xc59
 110a524:	91084821 	add	x1, x1, #0x212
 110a528:	91224400 	add	x0, x0, #0x891
 110a52c:	5280c362 	mov	w2, #0x61b                 	// #1563
 110a530:	17ffffef 	b	110a4ec <core_mmu_populate_user_map+0x124>
			pg_info->table = (*pgt)->tbl;
 110a534:	f94002c0 	ldr	x0, [x22]
 110a538:	f90037e0 	str	x0, [sp, #104]
			*pgt = SLIST_NEXT(*pgt, link);
 110a53c:	f9400ad6 	ldr	x22, [x22, #16]
			core_mmu_set_entry(dir_info, idx,
 110a540:	97ffff0e 	bl	110a178 <virt_to_phys>
 110a544:	aa0003e2 	mov	x2, x0
 110a548:	2a1403e3 	mov	w3, w20
 110a54c:	2a1c03e1 	mov	w1, w28
 110a550:	aa1303e0 	mov	x0, x19
 110a554:	97fffce0 	bl	11098d4 <core_mmu_set_entry>
		r.size = MIN(CORE_MMU_PGDIR_SIZE - (r.va - pg_info->va_base),
 110a558:	f9403be3 	ldr	x3, [sp, #112]
 110a55c:	f9404fe4 	ldr	x4, [sp, #152]
 110a560:	91480063 	add	x3, x3, #0x200, lsl #12
			size_t granule = BIT(pg_info->shift);
 110a564:	b9407fe2 	ldr	w2, [sp, #124]
		r.size = MIN(CORE_MMU_PGDIR_SIZE - (r.va - pg_info->va_base),
 110a568:	cb0402a0 	sub	x0, x21, x4
 110a56c:	cb040063 	sub	x3, x3, x4
 110a570:	eb00007f 	cmp	x3, x0
 110a574:	9a809063 	csel	x3, x3, x0, ls  // ls = plast
		if (!mobj_is_paged(region->mobj)) {
 110a578:	f9400360 	ldr	x0, [x27]
			size_t offset = r.va - region->va + region->offset;
 110a57c:	a9408766 	ldp	x6, x1, [x27, #8]
	return mobj_matches(mobj, CORE_MEM_SDP_MEM);
}

static inline size_t mobj_get_phys_granule(struct mobj *mobj)
{
	if (mobj->phys_granule)
 110a580:	f9400805 	ldr	x5, [x0, #16]
 110a584:	b5000045 	cbnz	x5, 110a58c <core_mmu_populate_user_map+0x1c4>
		return mobj->phys_granule;
	return mobj->size;
 110a588:	f9400405 	ldr	x5, [x0, #8]
			r.size = MIN(r.size,
 110a58c:	eb05007f 	cmp	x3, x5
 110a590:	9a859063 	csel	x3, x3, x5, ls  // ls = plast
			r.size = ROUNDUP(r.size, SMALL_PAGE_SIZE);
 110a594:	913ffc63 	add	x3, x3, #0xfff
 110a598:	9274cc63 	and	x3, x3, #0xfffffffffffff000
 110a59c:	f90053e3 	str	x3, [sp, #160]
	if (mobj && mobj->ops && mobj->ops->get_pa)
 110a5a0:	f9400003 	ldr	x3, [x0]
 110a5a4:	b5000123 	cbnz	x3, 110a5c8 <core_mmu_populate_user_map+0x200>
				panic("Failed to get PA of unpaged mobj");
 110a5a8:	90000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 110a5ac:	90000242 	adrp	x2, 1152000 <trace_ext_prefix+0x2e>
 110a5b0:	90000240 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 110a5b4:	91225863 	add	x3, x3, #0x896
 110a5b8:	91316442 	add	x2, x2, #0xc59
 110a5bc:	91084800 	add	x0, x0, #0x212
 110a5c0:	5280c641 	mov	w1, #0x632                 	// #1586
 110a5c4:	940023a9 	bl	1113468 <__do_panic>
 110a5c8:	f9400465 	ldr	x5, [x3, #8]
 110a5cc:	b4fffee5 	cbz	x5, 110a5a8 <core_mmu_populate_user_map+0x1e0>
			size_t offset = r.va - region->va + region->offset;
 110a5d0:	8b060084 	add	x4, x4, x6
		return mobj->ops->get_pa(mobj, offs, granule, pa);
 110a5d4:	aa1903e3 	mov	x3, x25
 110a5d8:	cb010081 	sub	x1, x4, x1
 110a5dc:	1ac22342 	lsl	w2, w26, w2
 110a5e0:	d63f00a0 	blr	x5
			if (mobj_get_pa(region->mobj, offset, granule,
 110a5e4:	35fffe20 	cbnz	w0, 110a5a8 <core_mmu_populate_user_map+0x1e0>
			set_region(pg_info, &r);
 110a5e8:	aa1803e1 	mov	x1, x24
 110a5ec:	aa1703e0 	mov	x0, x23
 110a5f0:	97fffccd 	bl	1109924 <set_region>
		r.va += r.size;
 110a5f4:	a94987e0 	ldp	x0, x1, [sp, #152]
 110a5f8:	8b010000 	add	x0, x0, x1
 110a5fc:	f9004fe0 	str	x0, [sp, #152]
 110a600:	17ffffa8 	b	110a4a0 <core_mmu_populate_user_map+0xd8>

000000000110a604 <check_va_matches_pa.part.0>:

#if defined(CFG_TEE_CORE_DEBUG)
static void check_va_matches_pa(paddr_t pa, void *va)
 110a604:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 110a608:	910003fd 	mov	x29, sp
 110a60c:	f90013f5 	str	x21, [sp, #32]
 110a610:	aa0003f5 	mov	x21, x0
	paddr_t p = 0;

	if (!va)
		return;

	p = virt_to_phys(va);
 110a614:	aa0103e0 	mov	x0, x1
static void check_va_matches_pa(paddr_t pa, void *va)
 110a618:	a90153f3 	stp	x19, x20, [sp, #16]
 110a61c:	aa0103f4 	mov	x20, x1
	p = virt_to_phys(va);
 110a620:	97fffed6 	bl	110a178 <virt_to_phys>
	if (p != pa) {
 110a624:	eb15001f 	cmp	x0, x21
 110a628:	54000260 	b.eq	110a674 <check_va_matches_pa.part.0+0x70>  // b.none
 110a62c:	aa0003e6 	mov	x6, x0
		DMSG("va %p maps 0x%" PRIxPA " expect 0x%" PRIxPA, va, p, pa);
 110a630:	aa1503e7 	mov	x7, x21
 110a634:	aa1403e5 	mov	x5, x20
 110a638:	90000244 	adrp	x4, 1152000 <trace_ext_prefix+0x2e>
 110a63c:	9122dc84 	add	x4, x4, #0x8b7
 110a640:	90000253 	adrp	x19, 1152000 <trace_ext_prefix+0x2e>
 110a644:	91333273 	add	x19, x19, #0xccc
 110a648:	52800023 	mov	w3, #0x1                   	// #1
 110a64c:	aa1303e0 	mov	x0, x19
 110a650:	52800062 	mov	w2, #0x3                   	// #3
 110a654:	528111c1 	mov	w1, #0x88e                 	// #2190
 110a658:	9400e9bb 	bl	1144d44 <trace_printf>
		panic();
 110a65c:	90000240 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 110a660:	aa1303e2 	mov	x2, x19
 110a664:	91084800 	add	x0, x0, #0x212
 110a668:	d2800003 	mov	x3, #0x0                   	// #0
 110a66c:	528111e1 	mov	w1, #0x88f                 	// #2191
 110a670:	9400237e 	bl	1113468 <__do_panic>
	}
}
 110a674:	a94153f3 	ldp	x19, x20, [sp, #16]
 110a678:	f94013f5 	ldr	x21, [sp, #32]
 110a67c:	a8c37bfd 	ldp	x29, x30, [sp], #48
 110a680:	d65f03c0 	ret

000000000110a684 <teecore_init_pub_ram>:
	return p->pa;
}

#ifdef CFG_CORE_RESERVED_SHM
static TEE_Result teecore_init_pub_ram(void)
{
 110a684:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	vaddr_t s = 0;
	vaddr_t e = 0;

	/* get virtual addr/size of NSec shared mem allocated from teecore */
	core_mmu_get_mem_by_type(MEM_AREA_NSEC_SHM, &s, &e);
 110a688:	52800140 	mov	w0, #0xa                   	// #10
{
 110a68c:	910003fd 	mov	x29, sp
	core_mmu_get_mem_by_type(MEM_AREA_NSEC_SHM, &s, &e);
 110a690:	910063e2 	add	x2, sp, #0x18
 110a694:	910043e1 	add	x1, sp, #0x10
	vaddr_t e = 0;
 110a698:	a9017fff 	stp	xzr, xzr, [sp, #16]
	core_mmu_get_mem_by_type(MEM_AREA_NSEC_SHM, &s, &e);
 110a69c:	97fffc2c 	bl	110974c <core_mmu_get_mem_by_type>

	if (s >= e || s & SMALL_PAGE_MASK || e & SMALL_PAGE_MASK)
 110a6a0:	a9410be1 	ldp	x1, x2, [sp, #16]
 110a6a4:	eb02003f 	cmp	x1, x2
 110a6a8:	54000082 	b.cs	110a6b8 <teecore_init_pub_ram+0x34>  // b.hs, b.nlast
 110a6ac:	aa020020 	orr	x0, x1, x2
 110a6b0:	f2402c1f 	tst	x0, #0xfff
 110a6b4:	54000120 	b.eq	110a6d8 <teecore_init_pub_ram+0x54>  // b.none
		panic("invalid PUB RAM");
 110a6b8:	90000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 110a6bc:	90000242 	adrp	x2, 1152000 <trace_ext_prefix+0x2e>
 110a6c0:	91235463 	add	x3, x3, #0x8d5
 110a6c4:	9133b042 	add	x2, x2, #0xcec
 110a6c8:	52812781 	mov	w1, #0x93c                 	// #2364

	/* extra check: we could rely on core_mmu_get_mem_by_type() */
	if (!tee_vbuf_is_non_sec(s, e - s))
		panic("PUB RAM is not non-secure");
 110a6cc:	90000240 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 110a6d0:	91084800 	add	x0, x0, #0x212
 110a6d4:	94002365 	bl	1113468 <__do_panic>
	if (!tee_vbuf_is_non_sec(s, e - s))
 110a6d8:	cb010042 	sub	x2, x2, x1
 110a6dc:	52800040 	mov	w0, #0x2                   	// #2
 110a6e0:	97ffff25 	bl	110a374 <core_vbuf_is>
 110a6e4:	72001c1f 	tst	w0, #0xff
 110a6e8:	540000e1 	b.ne	110a704 <teecore_init_pub_ram+0x80>  // b.any
		panic("PUB RAM is not non-secure");
 110a6ec:	90000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 110a6f0:	90000242 	adrp	x2, 1152000 <trace_ext_prefix+0x2e>
 110a6f4:	91239463 	add	x3, x3, #0x8e5
 110a6f8:	9133b042 	add	x2, x2, #0xcec
 110a6fc:	52812801 	mov	w1, #0x940                 	// #2368
 110a700:	17fffff3 	b	110a6cc <teecore_init_pub_ram+0x48>
	tee_l2cc_store_mutex_boot_pa(virt_to_phys((void *)s));
	s += sizeof(uint32_t);			/* size of a pl310 mutex */
	s = ROUNDUP(s, SMALL_PAGE_SIZE);	/* keep required alignment */
#endif

	default_nsec_shm_paddr = virt_to_phys((void *)s);
 110a704:	f9400be0 	ldr	x0, [sp, #16]
 110a708:	97fffe9c 	bl	110a178 <virt_to_phys>
 110a70c:	90000281 	adrp	x1, 115a000 <__scattered_array_1phys_mem_map+0x8>
 110a710:	f9422022 	ldr	x2, [x1, #1088]
	default_nsec_shm_size = e - s;
 110a714:	f9418421 	ldr	x1, [x1, #776]
	default_nsec_shm_paddr = virt_to_phys((void *)s);
 110a718:	f9000040 	str	x0, [x2]
	default_nsec_shm_size = e - s;
 110a71c:	a94103e2 	ldp	x2, x0, [sp, #16]
 110a720:	cb020000 	sub	x0, x0, x2
 110a724:	f9000020 	str	x0, [x1]

	return TEE_SUCCESS;
}
 110a728:	52800000 	mov	w0, #0x0                   	// #0
 110a72c:	a8c27bfd 	ldp	x29, x30, [sp], #32
 110a730:	d65f03c0 	ret

000000000110a734 <phys_to_virt>:
{
 110a734:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	switch (m) {
 110a738:	7100443f 	cmp	w1, #0x11
{
 110a73c:	910003fd 	mov	x29, sp
 110a740:	a90153f3 	stp	x19, x20, [sp, #16]
	switch (m) {
 110a744:	54000680 	b.eq	110a814 <phys_to_virt+0xe0>  // b.none
 110a748:	aa0003f4 	mov	x20, x0
 110a74c:	2a0103e5 	mov	w5, w1
 110a750:	540001e8 	b.hi	110a78c <phys_to_virt+0x58>  // b.pmore
 110a754:	51000420 	sub	w0, w1, #0x1
 110a758:	7100101f 	cmp	w0, #0x4
 110a75c:	54000389 	b.ls	110a7cc <phys_to_virt+0x98>  // b.plast
		va = map_pa2va(find_map_by_type_and_pa(m, pa), pa);
 110a760:	aa1403e1 	mov	x1, x20
 110a764:	2a0503e0 	mov	w0, w5
 110a768:	97fff864 	bl	11088f8 <find_map_by_type_and_pa>
 110a76c:	97fff6fa 	bl	1108354 <map_pa2va>
 110a770:	aa0003f3 	mov	x19, x0
	if (m != MEM_AREA_SEC_RAM_OVERALL)
 110a774:	710058bf 	cmp	w5, #0x16
 110a778:	54000201 	b.ne	110a7b8 <phys_to_virt+0x84>  // b.any
}
 110a77c:	aa1303e0 	mov	x0, x19
 110a780:	a94153f3 	ldp	x19, x20, [sp, #16]
 110a784:	a8c27bfd 	ldp	x29, x30, [sp], #32
 110a788:	d65f03c0 	ret
	switch (m) {
 110a78c:	7100483f 	cmp	w1, #0x12
 110a790:	54fffe81 	b.ne	110a760 <phys_to_virt+0x2c>  // b.any
	if (!core_mmu_user_mapping_is_active())
 110a794:	94000295 	bl	110b1e8 <core_mmu_user_mapping_is_active>
 110a798:	72001c1f 	tst	w0, #0xff
 110a79c:	540003c0 	b.eq	110a814 <phys_to_virt+0xe0>  // b.none
	return vm_pa2va(to_user_mode_ctx(thread_get_tsd()->ctx), pa);
 110a7a0:	97ffed08 	bl	1105bc0 <thread_get_tsd>
 110a7a4:	f9400800 	ldr	x0, [x0, #16]
 110a7a8:	97fff7bb 	bl	1108694 <to_user_mode_ctx>
 110a7ac:	aa1403e1 	mov	x1, x20
 110a7b0:	94003bca 	bl	11196d8 <vm_pa2va>
	return map_pa2va(mmap, pa);
 110a7b4:	aa0003f3 	mov	x19, x0
	if (!va)
 110a7b8:	b4fffe33 	cbz	x19, 110a77c <phys_to_virt+0x48>
 110a7bc:	aa1303e1 	mov	x1, x19
 110a7c0:	aa1403e0 	mov	x0, x20
 110a7c4:	97ffff90 	bl	110a604 <check_va_matches_pa.part.0>
 110a7c8:	17ffffed 	b	110a77c <phys_to_virt+0x48>
	mmap = find_map_by_type_and_pa(MEM_AREA_TEE_RAM, pa);
 110a7cc:	aa1403e1 	mov	x1, x20
 110a7d0:	52800020 	mov	w0, #0x1                   	// #1
 110a7d4:	97fff849 	bl	11088f8 <find_map_by_type_and_pa>
	if (!mmap)
 110a7d8:	b5000180 	cbnz	x0, 110a808 <phys_to_virt+0xd4>
		mmap = find_map_by_type_and_pa(MEM_AREA_NEX_RAM_RW, pa);
 110a7dc:	528000a0 	mov	w0, #0x5                   	// #5
 110a7e0:	97fff846 	bl	11088f8 <find_map_by_type_and_pa>
	if (!mmap)
 110a7e4:	b5000120 	cbnz	x0, 110a808 <phys_to_virt+0xd4>
		mmap = find_map_by_type_and_pa(MEM_AREA_TEE_RAM_RW, pa);
 110a7e8:	52800080 	mov	w0, #0x4                   	// #4
 110a7ec:	97fff843 	bl	11088f8 <find_map_by_type_and_pa>
	if (!mmap)
 110a7f0:	b50000c0 	cbnz	x0, 110a808 <phys_to_virt+0xd4>
		mmap = find_map_by_type_and_pa(MEM_AREA_TEE_RAM_RO, pa);
 110a7f4:	52800060 	mov	w0, #0x3                   	// #3
 110a7f8:	97fff840 	bl	11088f8 <find_map_by_type_and_pa>
	if (!mmap)
 110a7fc:	b5000060 	cbnz	x0, 110a808 <phys_to_virt+0xd4>
		mmap = find_map_by_type_and_pa(MEM_AREA_TEE_RAM_RX, pa);
 110a800:	52800040 	mov	w0, #0x2                   	// #2
 110a804:	97fff83d 	bl	11088f8 <find_map_by_type_and_pa>
	return map_pa2va(mmap, pa);
 110a808:	aa1403e1 	mov	x1, x20
 110a80c:	97fff6d2 	bl	1108354 <map_pa2va>
 110a810:	17ffffe9 	b	110a7b4 <phys_to_virt+0x80>
 110a814:	d2800013 	mov	x19, #0x0                   	// #0
	return va;
 110a818:	17ffffd9 	b	110a77c <phys_to_virt+0x48>

000000000110a81c <phys_to_virt_io>:
{
 110a81c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 110a820:	aa0003e5 	mov	x5, x0
	map = find_map_by_type_and_pa(MEM_AREA_IO_SEC, pa);
 110a824:	aa0003e1 	mov	x1, x0
{
 110a828:	910003fd 	mov	x29, sp
	map = find_map_by_type_and_pa(MEM_AREA_IO_SEC, pa);
 110a82c:	528001c0 	mov	w0, #0xe                   	// #14
{
 110a830:	f9000bf3 	str	x19, [sp, #16]
	map = find_map_by_type_and_pa(MEM_AREA_IO_SEC, pa);
 110a834:	97fff831 	bl	11088f8 <find_map_by_type_and_pa>
	if (!map)
 110a838:	b5000220 	cbnz	x0, 110a87c <phys_to_virt_io+0x60>
		map = find_map_by_type_and_pa(MEM_AREA_IO_NSEC, pa);
 110a83c:	528001a0 	mov	w0, #0xd                   	// #13
 110a840:	97fff82e 	bl	11088f8 <find_map_by_type_and_pa>
 110a844:	aa0003f3 	mov	x19, x0
	if (!map)
 110a848:	b4000120 	cbz	x0, 110a86c <phys_to_virt_io+0x50>
	va = map_pa2va(map, pa);
 110a84c:	aa1303e0 	mov	x0, x19
 110a850:	aa0503e1 	mov	x1, x5
 110a854:	97fff6c0 	bl	1108354 <map_pa2va>
 110a858:	aa0003f3 	mov	x19, x0
	if (!va)
 110a85c:	b4000080 	cbz	x0, 110a86c <phys_to_virt_io+0x50>
 110a860:	aa0003e1 	mov	x1, x0
 110a864:	aa0503e0 	mov	x0, x5
 110a868:	97ffff67 	bl	110a604 <check_va_matches_pa.part.0>
}
 110a86c:	aa1303e0 	mov	x0, x19
 110a870:	f9400bf3 	ldr	x19, [sp, #16]
 110a874:	a8c27bfd 	ldp	x29, x30, [sp], #32
 110a878:	d65f03c0 	ret
 110a87c:	aa0003f3 	mov	x19, x0
 110a880:	17fffff3 	b	110a84c <phys_to_virt_io+0x30>

000000000110a884 <cpu_mmu_enabled>:
DEFINE_U32_REG_READ_FUNC(sctlr_el1)
 110a884:	d5381000 	mrs	x0, sctlr_el1
}
 110a888:	12000000 	and	w0, w0, #0x1
 110a88c:	d65f03c0 	ret

000000000110a890 <io_pa_or_va>:
{
 110a890:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 110a894:	910003fd 	mov	x29, sp
 110a898:	f9000bf3 	str	x19, [sp, #16]
 110a89c:	aa0003f3 	mov	x19, x0
	assert(p->pa);
 110a8a0:	f9400000 	ldr	x0, [x0]
 110a8a4:	b5000140 	cbnz	x0, 110a8cc <io_pa_or_va+0x3c>
 110a8a8:	90000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 110a8ac:	90000241 	adrp	x1, 1152000 <trace_ext_prefix+0x2e>
 110a8b0:	90000240 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 110a8b4:	91338063 	add	x3, x3, #0xce0
 110a8b8:	91084821 	add	x1, x1, #0x212
 110a8bc:	9123fc00 	add	x0, x0, #0x8ff
 110a8c0:	52812202 	mov	w2, #0x910                 	// #2320
		assert(p->va);
 110a8c4:	94001e7a 	bl	11122ac <_assert_log>
 110a8c8:	94001e8a 	bl	11122f0 <_assert_break>
 110a8cc:	d5381001 	mrs	x1, sctlr_el1
	if (cpu_mmu_enabled()) {
 110a8d0:	360001e1 	tbz	w1, #0, 110a90c <io_pa_or_va+0x7c>
		if (!p->va)
 110a8d4:	f9400661 	ldr	x1, [x19, #8]
 110a8d8:	b5000061 	cbnz	x1, 110a8e4 <io_pa_or_va+0x54>
			p->va = (vaddr_t)phys_to_virt_io(p->pa);
 110a8dc:	97ffffd0 	bl	110a81c <phys_to_virt_io>
 110a8e0:	f9000660 	str	x0, [x19, #8]
		assert(p->va);
 110a8e4:	f9400660 	ldr	x0, [x19, #8]
 110a8e8:	b5000120 	cbnz	x0, 110a90c <io_pa_or_va+0x7c>
 110a8ec:	90000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 110a8f0:	90000241 	adrp	x1, 1152000 <trace_ext_prefix+0x2e>
 110a8f4:	90000240 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 110a8f8:	91338063 	add	x3, x3, #0xce0
 110a8fc:	91084821 	add	x1, x1, #0x212
 110a900:	91241400 	add	x0, x0, #0x905
 110a904:	52812282 	mov	w2, #0x914                 	// #2324
 110a908:	17ffffef 	b	110a8c4 <io_pa_or_va+0x34>
}
 110a90c:	f9400bf3 	ldr	x19, [sp, #16]
 110a910:	a8c27bfd 	ldp	x29, x30, [sp], #32
 110a914:	d65f03c0 	ret

000000000110a918 <core_mmu_init_ta_ram>:
early_init(teecore_init_pub_ram);
#endif /*CFG_CORE_RESERVED_SHM*/

void core_mmu_init_ta_ram(void)
{
 110a918:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
	/*
	 * Get virtual addr/size of RAM where TA are loaded/executedNSec
	 * shared mem allocated from teecore.
	 */
#ifndef CFG_VIRTUALIZATION
	core_mmu_get_mem_by_type(MEM_AREA_TA_RAM, &s, &e);
 110a91c:	52800120 	mov	w0, #0x9                   	// #9
{
 110a920:	910003fd 	mov	x29, sp
	core_mmu_get_mem_by_type(MEM_AREA_TA_RAM, &s, &e);
 110a924:	9100e3e2 	add	x2, sp, #0x38
 110a928:	9100c3e1 	add	x1, sp, #0x30
{
 110a92c:	a90153f3 	stp	x19, x20, [sp, #16]
 110a930:	f90013f5 	str	x21, [sp, #32]
	vaddr_t e = 0;
 110a934:	a9037fff 	stp	xzr, xzr, [sp, #48]
	core_mmu_get_mem_by_type(MEM_AREA_TA_RAM, &s, &e);
 110a938:	97fffb85 	bl	110974c <core_mmu_get_mem_by_type>
#else
	virt_get_ta_ram(&s, &e);
#endif
	ps = virt_to_phys((void *)s);
 110a93c:	f9401be0 	ldr	x0, [sp, #48]
 110a940:	97fffe0e 	bl	110a178 <virt_to_phys>
 110a944:	aa0003f3 	mov	x19, x0
	pe = virt_to_phys((void *)(e - 1)) + 1;
 110a948:	f9401fe0 	ldr	x0, [sp, #56]
 110a94c:	d1000400 	sub	x0, x0, #0x1
 110a950:	97fffe0a 	bl	110a178 <virt_to_phys>

	if (!ps || (ps & CORE_MMU_USER_CODE_MASK) ||
 110a954:	b40000d3 	cbz	x19, 110a96c <core_mmu_init_ta_ram+0x54>
 110a958:	91000414 	add	x20, x0, #0x1
 110a95c:	b4000094 	cbz	x20, 110a96c <core_mmu_init_ta_ram+0x54>
	    !pe || (pe & CORE_MMU_USER_CODE_MASK))
 110a960:	aa140260 	orr	x0, x19, x20
 110a964:	f2402c1f 	tst	x0, #0xfff
 110a968:	54000120 	b.eq	110a98c <core_mmu_init_ta_ram+0x74>  // b.none
		panic("invalid TA RAM");
 110a96c:	90000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 110a970:	90000242 	adrp	x2, 1152000 <trace_ext_prefix+0x2e>
 110a974:	91242c63 	add	x3, x3, #0x90b
 110a978:	91340442 	add	x2, x2, #0xd01
 110a97c:	52812cc1 	mov	w1, #0x966                 	// #2406

	/* extra check: we could rely on core_mmu_get_mem_by_type() */
	if (!tee_pbuf_is_sec(ps, pe - ps))
		panic("TA RAM is not secure");
 110a980:	90000240 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 110a984:	91084800 	add	x0, x0, #0x212
 110a988:	940022b8 	bl	1113468 <__do_panic>
	if (!tee_pbuf_is_sec(ps, pe - ps))
 110a98c:	cb130282 	sub	x2, x20, x19
 110a990:	aa1303e1 	mov	x1, x19
 110a994:	52800060 	mov	w0, #0x3                   	// #3
 110a998:	97fffb18 	bl	11095f8 <core_pbuf_is>
 110a99c:	72001c1f 	tst	w0, #0xff
 110a9a0:	540000e1 	b.ne	110a9bc <core_mmu_init_ta_ram+0xa4>  // b.any
		panic("TA RAM is not secure");
 110a9a4:	90000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 110a9a8:	90000242 	adrp	x2, 1152000 <trace_ext_prefix+0x2e>
 110a9ac:	91246863 	add	x3, x3, #0x91a
 110a9b0:	91340442 	add	x2, x2, #0xd01
 110a9b4:	52812d41 	mov	w1, #0x96a                 	// #2410
 110a9b8:	17fffff2 	b	110a980 <core_mmu_init_ta_ram+0x68>

	if (!tee_mm_is_empty(&tee_mm_sec_ddr))
 110a9bc:	90000295 	adrp	x21, 115a000 <__scattered_array_1phys_mem_map+0x8>
 110a9c0:	f94152b5 	ldr	x21, [x21, #672]
 110a9c4:	aa1503e0 	mov	x0, x21
 110a9c8:	94000414 	bl	110ba18 <tee_mm_is_empty>
 110a9cc:	72001c1f 	tst	w0, #0xff
 110a9d0:	540000e1 	b.ne	110a9ec <core_mmu_init_ta_ram+0xd4>  // b.any
		panic("TA RAM pool is not empty");
 110a9d4:	90000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 110a9d8:	90000242 	adrp	x2, 1152000 <trace_ext_prefix+0x2e>
 110a9dc:	9124bc63 	add	x3, x3, #0x92f
 110a9e0:	91340442 	add	x2, x2, #0xd01
 110a9e4:	52812da1 	mov	w1, #0x96d                 	// #2413
 110a9e8:	17ffffe6 	b	110a980 <core_mmu_init_ta_ram+0x68>

	/* remove previous config and init TA ddr memory pool */
	tee_mm_final(&tee_mm_sec_ddr);
 110a9ec:	aa1503e0 	mov	x0, x21
 110a9f0:	940003f7 	bl	110b9cc <tee_mm_final>
	tee_mm_init(&tee_mm_sec_ddr, ps, pe, CORE_MMU_USER_CODE_SHIFT,
 110a9f4:	aa1403e2 	mov	x2, x20
 110a9f8:	aa1303e1 	mov	x1, x19
 110a9fc:	aa1503e0 	mov	x0, x21
 110aa00:	52800004 	mov	w4, #0x0                   	// #0
 110aa04:	52800183 	mov	w3, #0xc                   	// #12
 110aa08:	940002f6 	bl	110b5e0 <tee_mm_init>
		    TEE_MM_POOL_NO_FLAGS);
}
 110aa0c:	a94153f3 	ldp	x19, x20, [sp, #16]
 110aa10:	f94013f5 	ldr	x21, [sp, #32]
 110aa14:	a8c47bfd 	ldp	x29, x30, [sp], #64
 110aa18:	d65f03c0 	ret

000000000110aa1c <get_core_pos>:
{
 110aa1c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 110aa20:	910003fd 	mov	x29, sp
	assert(thread_get_exceptions() & THREAD_EXCP_FOREIGN_INTR);
 110aa24:	97ffe93c 	bl	1104f14 <thread_get_exceptions>
 110aa28:	37080140 	tbnz	w0, #1, 110aa50 <get_core_pos+0x34>
 110aa2c:	90000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 110aa30:	f0000221 	adrp	x1, 1151000 <small_prime+0x168>
 110aa34:	9136c863 	add	x3, x3, #0xdb2
 110aa38:	9113b021 	add	x1, x1, #0x4ec
 110aa3c:	f0000220 	adrp	x0, 1151000 <small_prime+0x168>
 110aa40:	91144000 	add	x0, x0, #0x510
 110aa44:	528002c2 	mov	w2, #0x16                  	// #22
 110aa48:	94001e19 	bl	11122ac <_assert_log>
 110aa4c:	94001e29 	bl	11122f0 <_assert_break>
}
 110aa50:	a8c17bfd 	ldp	x29, x30, [sp], #16
	return __get_core_pos();
 110aa54:	17ffdbc0 	b	1101954 <__get_core_pos>

000000000110aa58 <core_init_mmu_prtn>:
		current_prtn[n] = &default_partition;
}
#endif

void core_init_mmu_prtn(struct mmu_partition *prtn, struct tee_mmap_region *mm)
{
 110aa58:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	size_t n;

	assert(prtn && mm);
 110aa5c:	f100001f 	cmp	x0, #0x0
 110aa60:	fa401824 	ccmp	x1, #0x0, #0x4, ne  // ne = any
{
 110aa64:	910003fd 	mov	x29, sp
 110aa68:	a90153f3 	stp	x19, x20, [sp, #16]
 110aa6c:	a9025bf5 	stp	x21, x22, [sp, #32]
	assert(prtn && mm);
 110aa70:	540003c0 	b.eq	110aae8 <core_init_mmu_prtn+0x90>  // b.none
 110aa74:	aa0003f4 	mov	x20, x0
 110aa78:	aa0103f3 	mov	x19, x1
 110aa7c:	aa0103e0 	mov	x0, x1

	for (n = 0; !core_mmap_is_end_of_table(mm + n); n++) {
 110aa80:	b9400001 	ldr	w1, [x0]
 110aa84:	aa0003e2 	mov	x2, x0
 110aa88:	35000421 	cbnz	w1, 110ab0c <core_init_mmu_prtn+0xb4>
		if (!IS_PAGE_ALIGNED(mm[n].pa) || !IS_PAGE_ALIGNED(mm[n].size))
			panic("unaligned region");
	}

	/* Clear table before use */
	memset(prtn->l1_tables, 0, sizeof(l1_xlation_table));
 110aa8c:	f9400280 	ldr	x0, [x20]
 110aa90:	d2802002 	mov	x2, #0x100                 	// #256
 110aa94:	9400e493 	bl	1143ce0 <memset>

	for (n = 0; !core_mmap_is_end_of_table(mm + n); n++)
 110aa98:	b9400260 	ldr	w0, [x19]
 110aa9c:	35000560 	cbnz	w0, 110ab48 <core_init_mmu_prtn+0xf0>

	/*
	 * Primary mapping table is ready at index `get_core_pos()`
	 * whose value may not be ZERO. Take this index as copy source.
	 */
	for (n = 0; n < CFG_TEE_CORE_NB_CORE; n++) {
 110aaa0:	d2800013 	mov	x19, #0x0                   	// #0
		if (n == get_core_pos())
 110aaa4:	97ffffde 	bl	110aa1c <get_core_pos>
 110aaa8:	eb13001f 	cmp	x0, x19
 110aaac:	54000100 	b.eq	110aacc <core_init_mmu_prtn+0x74>  // b.none
			continue;

		memcpy(prtn->l1_tables[0][n],
 110aab0:	f9400295 	ldr	x21, [x20]
		       prtn->l1_tables[0][get_core_pos()],
 110aab4:	97ffffda 	bl	110aa1c <get_core_pos>
		memcpy(prtn->l1_tables[0][n],
 110aab8:	d2800402 	mov	x2, #0x20                  	// #32
 110aabc:	8b1316b6 	add	x22, x21, x19, lsl #5
 110aac0:	8b0016a1 	add	x1, x21, x0, lsl #5
 110aac4:	aa1603e0 	mov	x0, x22
 110aac8:	97ffe232 	bl	1103390 <memcpy>
	for (n = 0; n < CFG_TEE_CORE_NB_CORE; n++) {
 110aacc:	91000673 	add	x19, x19, #0x1
 110aad0:	f100127f 	cmp	x19, #0x4
 110aad4:	54fffe81 	b.ne	110aaa4 <core_init_mmu_prtn+0x4c>  // b.any
		       XLAT_ENTRY_SIZE * NUM_L1_ENTRIES);
	}
}
 110aad8:	a94153f3 	ldp	x19, x20, [sp, #16]
 110aadc:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110aae0:	a8c37bfd 	ldp	x29, x30, [sp], #48
 110aae4:	d65f03c0 	ret
	assert(prtn && mm);
 110aae8:	90000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 110aaec:	90000241 	adrp	x1, 1152000 <trace_ext_prefix+0x2e>
 110aaf0:	91373463 	add	x3, x3, #0xdcd
 110aaf4:	91345821 	add	x1, x1, #0xd16
 110aaf8:	90000240 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 110aafc:	9134dc00 	add	x0, x0, #0xd37
 110ab00:	52803742 	mov	w2, #0x1ba                 	// #442
 110ab04:	94001dea 	bl	11122ac <_assert_log>
 110ab08:	94001dfa 	bl	11122f0 <_assert_break>
		if (!IS_PAGE_ALIGNED(mm[n].pa) || !IS_PAGE_ALIGNED(mm[n].size))
 110ab0c:	f9400401 	ldr	x1, [x0, #8]
 110ab10:	f2402c3f 	tst	x1, #0xfff
 110ab14:	540000a1 	b.ne	110ab28 <core_init_mmu_prtn+0xd0>  // b.any
 110ab18:	f9400c41 	ldr	x1, [x2, #24]
 110ab1c:	9100a000 	add	x0, x0, #0x28
 110ab20:	f2402c3f 	tst	x1, #0xfff
 110ab24:	54fffae0 	b.eq	110aa80 <core_init_mmu_prtn+0x28>  // b.none
			panic("unaligned region");
 110ab28:	90000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 110ab2c:	90000242 	adrp	x2, 1152000 <trace_ext_prefix+0x2e>
 110ab30:	90000240 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 110ab34:	91350863 	add	x3, x3, #0xd42
 110ab38:	91373442 	add	x2, x2, #0xdcd
 110ab3c:	91345800 	add	x0, x0, #0xd16
 110ab40:	52803821 	mov	w1, #0x1c1                 	// #449
 110ab44:	94002249 	bl	1113468 <__do_panic>
	return mm->type == MEM_AREA_RES_VASPACE ||
 110ab48:	51004000 	sub	w0, w0, #0x10
		if (!core_mmu_is_dynamic_vaspace(mm + n))
 110ab4c:	7100041f 	cmp	w0, #0x1
 110ab50:	54000089 	b.ls	110ab60 <core_init_mmu_prtn+0x108>  // b.plast
			core_mmu_map_region(prtn, mm + n);
 110ab54:	aa1303e1 	mov	x1, x19
 110ab58:	aa1403e0 	mov	x0, x20
 110ab5c:	97fffbcc 	bl	1109a8c <core_mmu_map_region>
	for (n = 0; !core_mmap_is_end_of_table(mm + n); n++)
 110ab60:	9100a273 	add	x19, x19, #0x28
 110ab64:	17ffffcd 	b	110aa98 <core_init_mmu_prtn+0x40>

000000000110ab68 <core_init_mmu>:

void core_init_mmu(struct tee_mmap_region *mm)
{
 110ab68:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
			   sizeof(l1_xlation_table) / 2);
#endif
	COMPILE_TIME_ASSERT(XLAT_TABLES_SIZE == sizeof(xlat_tables));

	/* Initialize default pagetables */
	core_init_mmu_prtn(&default_partition, mm);
 110ab6c:	aa0003e1 	mov	x1, x0
{
 110ab70:	910003fd 	mov	x29, sp
 110ab74:	a90153f3 	stp	x19, x20, [sp, #16]
 110ab78:	aa0003f3 	mov	x19, x0
	core_init_mmu_prtn(&default_partition, mm);
 110ab7c:	b0000294 	adrp	x20, 115b000 <__vcore_unpg_rw_start>
 110ab80:	91036280 	add	x0, x20, #0xd8
 110ab84:	97ffffb5 	bl	110aa58 <core_init_mmu_prtn>

	for (n = 0; !core_mmap_is_end_of_table(mm + n); n++) {
 110ab88:	aa1303e1 	mov	x1, x19
	uint64_t max_va = 0;
 110ab8c:	d2800002 	mov	x2, #0x0                   	// #0
	for (n = 0; !core_mmap_is_end_of_table(mm + n); n++) {
 110ab90:	b8428420 	ldr	w0, [x1], #40
 110ab94:	350002c0 	cbnz	w0, 110abec <core_init_mmu+0x84>
		if (va_end > max_va)
			max_va = va_end;
	}

	for (n = 1; n < NUM_L1_ENTRIES; n++) {
		if (!default_partition.l1_tables[0][0][n]) {
 110ab98:	f9406e80 	ldr	x0, [x20, #216]
 110ab9c:	f0000281 	adrp	x1, 115d000 <_curve_names+0x590>
 110aba0:	f9400403 	ldr	x3, [x0, #8]
 110aba4:	b4000303 	cbz	x3, 110ac04 <core_init_mmu+0x9c>
 110aba8:	f9400803 	ldr	x3, [x0, #16]
 110abac:	b4000303 	cbz	x3, 110ac0c <core_init_mmu+0xa4>
 110abb0:	f9400c00 	ldr	x0, [x0, #24]
 110abb4:	b5000300 	cbnz	x0, 110ac14 <core_init_mmu+0xac>
	for (n = 1; n < NUM_L1_ENTRIES; n++) {
 110abb8:	d2800060 	mov	x0, #0x3                   	// #3
			user_va_idx = n;
 110abbc:	b90be420 	str	w0, [x1, #3044]
		}
	}
	assert(user_va_idx != -1);

	COMPILE_TIME_ASSERT(CFG_LPAE_ADDR_SPACE_BITS > L1_XLAT_ADDRESS_SHIFT);
	assert(max_va < BIT64(CFG_LPAE_ADDR_SPACE_BITS));
 110abc0:	b2407fe0 	mov	x0, #0xffffffff            	// #4294967295
 110abc4:	eb00005f 	cmp	x2, x0
 110abc8:	540003e9 	b.ls	110ac44 <core_init_mmu+0xdc>  // b.plast
 110abcc:	90000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 110abd0:	90000241 	adrp	x1, 1152000 <trace_ext_prefix+0x2e>
 110abd4:	90000240 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 110abd8:	91378063 	add	x3, x3, #0xde0
 110abdc:	91345821 	add	x1, x1, #0xd16
 110abe0:	91359400 	add	x0, x0, #0xd65
 110abe4:	52803ee2 	mov	w2, #0x1f7                 	// #503
 110abe8:	14000015 	b	110ac3c <core_init_mmu+0xd4>
		vaddr_t va_end = mm[n].va + mm[n].size - 1;
 110abec:	a97e8c20 	ldp	x0, x3, [x1, #-24]
 110abf0:	8b030000 	add	x0, x0, x3
 110abf4:	d1000400 	sub	x0, x0, #0x1
 110abf8:	eb00005f 	cmp	x2, x0
 110abfc:	9a802042 	csel	x2, x2, x0, cs  // cs = hs, nlast
	for (n = 0; !core_mmap_is_end_of_table(mm + n); n++) {
 110ac00:	17ffffe4 	b	110ab90 <core_init_mmu+0x28>
	for (n = 1; n < NUM_L1_ENTRIES; n++) {
 110ac04:	d2800020 	mov	x0, #0x1                   	// #1
 110ac08:	17ffffed 	b	110abbc <core_init_mmu+0x54>
 110ac0c:	d2800040 	mov	x0, #0x2                   	// #2
 110ac10:	17ffffeb 	b	110abbc <core_init_mmu+0x54>
	assert(user_va_idx != -1);
 110ac14:	b94be420 	ldr	w0, [x1, #3044]
 110ac18:	3100041f 	cmn	w0, #0x1
 110ac1c:	54fffd21 	b.ne	110abc0 <core_init_mmu+0x58>  // b.any
 110ac20:	90000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 110ac24:	90000241 	adrp	x1, 1152000 <trace_ext_prefix+0x2e>
 110ac28:	90000240 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 110ac2c:	91378063 	add	x3, x3, #0xde0
 110ac30:	91345821 	add	x1, x1, #0xd16
 110ac34:	91354c00 	add	x0, x0, #0xd53
 110ac38:	52803e82 	mov	w2, #0x1f4                 	// #500
	assert(max_va < BIT64(CFG_LPAE_ADDR_SPACE_BITS));
 110ac3c:	94001d9c 	bl	11122ac <_assert_log>
 110ac40:	94001dac 	bl	11122f0 <_assert_break>
}
 110ac44:	a94153f3 	ldp	x19, x20, [sp, #16]
 110ac48:	a8c27bfd 	ldp	x29, x30, [sp], #32
 110ac4c:	d65f03c0 	ret

000000000110ac50 <core_mmu_place_tee_ram_at_top>:
bool core_mmu_place_tee_ram_at_top(paddr_t paddr)
{
	size_t l1size = (1 << L1_XLAT_ADDRESS_SHIFT);
	paddr_t l1mask = l1size - 1;

	return (paddr & l1mask) > (l1size / 2);
 110ac50:	92407400 	and	x0, x0, #0x3fffffff
 110ac54:	d2a40001 	mov	x1, #0x20000000            	// #536870912
 110ac58:	eb01001f 	cmp	x0, x1
}
 110ac5c:	1a9f97e0 	cset	w0, hi  // hi = pmore
 110ac60:	d65f03c0 	ret

000000000110ac64 <core_init_mmu_regs>:
	/* CFG_CORE_ARM64_PA_BITS <= 48 */
	return TCR_PS_BITS_256TB;
}

void core_init_mmu_regs(struct core_mmu_config *cfg)
{
 110ac64:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 110ac68:	910003fd 	mov	x29, sp
 110ac6c:	f9000bf3 	str	x19, [sp, #16]
 110ac70:	aa0003f3 	mov	x19, x0
	uint64_t ips = get_physical_addr_size_bits();
	uint64_t mair = 0;
	uint64_t tcr = 0;

	cfg->ttbr0_el1_base = virt_to_phys(l1_xlation_table[0][0]);
 110ac74:	f00003e0 	adrp	x0, 1189000 <l1_xlation_table>
 110ac78:	91000000 	add	x0, x0, #0x0
 110ac7c:	97fffd3f 	bl	110a178 <virt_to_phys>
 110ac80:	f9000a60 	str	x0, [x19, #16]
	cfg->ttbr0_core_offset = sizeof(l1_xlation_table[0][0]);
 110ac84:	d2800400 	mov	x0, #0x20                  	// #32
 110ac88:	f9000e60 	str	x0, [x19, #24]

	mair  = MAIR_ATTR_SET(ATTR_DEVICE, ATTR_DEVICE_INDEX);
	mair |= MAIR_ATTR_SET(ATTR_IWBWA_OWBWA_NTR, ATTR_IWBWA_OWBWA_NTR_INDEX);
	cfg->mair_el1 = mair;
 110ac8c:	d29fe080 	mov	x0, #0xff04                	// #65284
 110ac90:	f9000660 	str	x0, [x19, #8]

	/*
	 * TCR.A1 = 0 => ASID is stored in TTBR0
	 * TCR.AS = 0 => Same ASID size as in Aarch32/ARMv7
	 */
	cfg->tcr_el1 = tcr;
 110ac94:	d287e400 	mov	x0, #0x3f20                	// #16160
 110ac98:	f2b01000 	movk	x0, #0x8080, lsl #16
 110ac9c:	f9000260 	str	x0, [x19]
}
 110aca0:	f9400bf3 	ldr	x19, [sp, #16]
 110aca4:	a8c27bfd 	ldp	x29, x30, [sp], #32
 110aca8:	d65f03c0 	ret

000000000110acac <core_mmu_set_info_table>:
void core_mmu_set_info_table(struct core_mmu_table_info *tbl_info,
		unsigned level, vaddr_t va_base, void *table)
{
	tbl_info->level = level;
	tbl_info->table = table;
	tbl_info->va_base = va_base;
 110acac:	a9000803 	stp	x3, x2, [x0]
	tbl_info->shift = L1_XLAT_ADDRESS_SHIFT -
 110acb0:	12800102 	mov	w2, #0xfffffff7            	// #-9
			  (level - 1) * XLAT_TABLE_ENTRIES_SHIFT;
	assert(level <= 3);
 110acb4:	71000c3f 	cmp	w1, #0x3
	tbl_info->shift = L1_XLAT_ADDRESS_SHIFT -
 110acb8:	1b027c22 	mul	w2, w1, w2
	tbl_info->level = level;
 110acbc:	b9001001 	str	w1, [x0, #16]
	tbl_info->shift = L1_XLAT_ADDRESS_SHIFT -
 110acc0:	11009c42 	add	w2, w2, #0x27
 110acc4:	b9001402 	str	w2, [x0, #20]
	assert(level <= 3);
 110acc8:	54000189 	b.ls	110acf8 <core_mmu_set_info_table+0x4c>  // b.plast
 110accc:	90000243 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 110acd0:	90000241 	adrp	x1, 1152000 <trace_ext_prefix+0x2e>
 110acd4:	9137b863 	add	x3, x3, #0xdee
 110acd8:	91345821 	add	x1, x1, #0xd16
 110acdc:	90000240 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 110ace0:	91363800 	add	x0, x0, #0xd8e
{
 110ace4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	assert(level <= 3);
 110ace8:	52804cc2 	mov	w2, #0x266                 	// #614
{
 110acec:	910003fd 	mov	x29, sp
	assert(level <= 3);
 110acf0:	94001d6f 	bl	11122ac <_assert_log>
 110acf4:	94001d7f 	bl	11122f0 <_assert_break>
	if (level == 1)
		tbl_info->num_entries = NUM_L1_ENTRIES;
	else
		tbl_info->num_entries = XLAT_TABLE_ENTRIES;
 110acf8:	7100043f 	cmp	w1, #0x1
 110acfc:	52804002 	mov	w2, #0x200                 	// #512
 110ad00:	52800081 	mov	w1, #0x4                   	// #4
 110ad04:	1a820021 	csel	w1, w1, w2, eq  // eq = none
 110ad08:	b9001801 	str	w1, [x0, #24]
 110ad0c:	d65f03c0 	ret

000000000110ad10 <core_mmu_find_table>:
}

bool core_mmu_find_table(struct mmu_partition *prtn, vaddr_t va,
			 unsigned max_level,
			 struct core_mmu_table_info *tbl_info)
{
 110ad10:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
 110ad14:	910003fd 	mov	x29, sp
 110ad18:	a90153f3 	stp	x19, x20, [sp, #16]
 110ad1c:	aa0003f3 	mov	x19, x0
	uint32_t exceptions = thread_mask_exceptions(THREAD_EXCP_ALL);
 110ad20:	528000e0 	mov	w0, #0x7                   	// #7
{
 110ad24:	a9025bf5 	stp	x21, x22, [sp, #32]
 110ad28:	aa0103f5 	mov	x21, x1
 110ad2c:	2a0203f6 	mov	w22, w2
 110ad30:	a90363f7 	stp	x23, x24, [sp, #48]
 110ad34:	aa0303f8 	mov	x24, x3
 110ad38:	a9046bf9 	stp	x25, x26, [sp, #64]
 110ad3c:	f9002bfb 	str	x27, [sp, #80]
	uint32_t exceptions = thread_mask_exceptions(THREAD_EXCP_ALL);
 110ad40:	97ffe8fe 	bl	1105138 <thread_mask_exceptions>
 110ad44:	2a0003f4 	mov	w20, w0
	vaddr_t va_base = 0;
	bool ret = false;
	uintptr_t ntbl;
	uint64_t *tbl;

	if (!prtn)
 110ad48:	b5000073 	cbnz	x19, 110ad54 <core_mmu_find_table+0x44>
		prtn = get_prtn();
 110ad4c:	b0000293 	adrp	x19, 115b000 <__vcore_unpg_rw_start>
 110ad50:	91036273 	add	x19, x19, #0xd8
	tbl = prtn->l1_tables[0][get_core_pos()];
 110ad54:	f9400273 	ldr	x19, [x19]
 110ad58:	97ffff31 	bl	110aa1c <get_core_pos>
	vaddr_t va_base = 0;
 110ad5c:	d280001a 	mov	x26, #0x0                   	// #0
	unsigned int level = 1;
 110ad60:	52800037 	mov	w23, #0x1                   	// #1

	while (true) {
		unsigned level_size_shift =
 110ad64:	1280011b 	mov	w27, #0xfffffff7            	// #-9
	unsigned int num_entries = NUM_L1_ENTRIES;
 110ad68:	52800081 	mov	w1, #0x4                   	// #4
	tbl = prtn->l1_tables[0][get_core_pos()];
 110ad6c:	8b001660 	add	x0, x19, x0, lsl #5
		unsigned level_size_shift =
 110ad70:	1b1b7ef3 	mul	w19, w23, w27
 110ad74:	11009e79 	add	w25, w19, #0x27
			L1_XLAT_ADDRESS_SHIFT - (level - 1) *
						XLAT_TABLE_ENTRIES_SHIFT;
		unsigned n = (va - va_base) >> level_size_shift;
 110ad78:	cb1a02b3 	sub	x19, x21, x26
 110ad7c:	9ad92673 	lsr	x19, x19, x25

		if (n >= num_entries)
 110ad80:	6b13003f 	cmp	w1, w19
 110ad84:	54000469 	b.ls	110ae10 <core_mmu_find_table+0x100>  // b.plast
			goto out;

		if (level == max_level || level == 3 ||
 110ad88:	6b1602ff 	cmp	w23, w22
 110ad8c:	7a431ae4 	ccmp	w23, #0x3, #0x4, ne  // ne = any
 110ad90:	54000221 	b.ne	110add4 <core_mmu_find_table+0xc4>  // b.any
			 * Level 1 is the CPU specific translation table.
			 * It doesn't make sense to return anything based
			 * on that unless foreign interrupts already are
			 * masked.
			 */
			if (level == 1 &&
 110ad94:	710006ff 	cmp	w23, #0x1
 110ad98:	540003a0 	b.eq	110ae0c <core_mmu_find_table+0xfc>  // b.none
			tbl_info->shift = level_size_shift;
			tbl_info->num_entries = num_entries;
#ifdef CFG_VIRTUALIZATION
			tbl_info->prtn = prtn;
#endif
			ret = true;
 110ad9c:	52800033 	mov	w19, #0x1                   	// #1
			tbl_info->va_base = va_base;
 110ada0:	a9006b00 	stp	x0, x26, [x24]
			tbl_info->shift = level_size_shift;
 110ada4:	29026717 	stp	w23, w25, [x24, #16]
			tbl_info->num_entries = num_entries;
 110ada8:	b9001b01 	str	w1, [x24, #24]
		va_base += (vaddr_t)n << level_size_shift;
		level++;
		num_entries = XLAT_TABLE_ENTRIES;
	}
out:
	thread_unmask_exceptions(exceptions);
 110adac:	2a1403e0 	mov	w0, w20
 110adb0:	97ffe8ef 	bl	110516c <thread_unmask_exceptions>
	return ret;
}
 110adb4:	2a1303e0 	mov	w0, w19
 110adb8:	a94153f3 	ldp	x19, x20, [sp, #16]
 110adbc:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110adc0:	a94363f7 	ldp	x23, x24, [sp, #48]
 110adc4:	a9446bf9 	ldp	x25, x26, [sp, #64]
 110adc8:	f9402bfb 	ldr	x27, [sp, #80]
 110adcc:	a8c67bfd 	ldp	x29, x30, [sp], #96
 110add0:	d65f03c0 	ret
 110add4:	92407e73 	and	x19, x19, #0xffffffff
			(tbl[n] & TABLE_DESC) != TABLE_DESC) {
 110add8:	f8737802 	ldr	x2, [x0, x19, lsl #3]
 110addc:	92400443 	and	x3, x2, #0x3
		if (level == max_level || level == 3 ||
 110ade0:	f1000c7f 	cmp	x3, #0x3
 110ade4:	54fffd81 	b.ne	110ad94 <core_mmu_find_table+0x84>  // b.any
		tbl = phys_to_virt(ntbl, MEM_AREA_TEE_RAM_RW_DATA);
 110ade8:	92746c40 	and	x0, x2, #0xfffffff000
 110adec:	52800081 	mov	w1, #0x4                   	// #4
 110adf0:	97fffe51 	bl	110a734 <phys_to_virt>
		if (!tbl)
 110adf4:	b40000e0 	cbz	x0, 110ae10 <core_mmu_find_table+0x100>
		va_base += (vaddr_t)n << level_size_shift;
 110adf8:	9ad92273 	lsl	x19, x19, x25
		level++;
 110adfc:	110006f7 	add	w23, w23, #0x1
		va_base += (vaddr_t)n << level_size_shift;
 110ae00:	8b13035a 	add	x26, x26, x19
		num_entries = XLAT_TABLE_ENTRIES;
 110ae04:	52804001 	mov	w1, #0x200                 	// #512
	while (true) {
 110ae08:	17ffffda 	b	110ad70 <core_mmu_find_table+0x60>
			if (level == 1 &&
 110ae0c:	370ffc94 	tbnz	w20, #1, 110ad9c <core_mmu_find_table+0x8c>
	bool ret = false;
 110ae10:	52800013 	mov	w19, #0x0                   	// #0
 110ae14:	17ffffe6 	b	110adac <core_mmu_find_table+0x9c>

000000000110ae18 <core_mmu_entry_to_finer_grained>:

bool core_mmu_entry_to_finer_grained(struct core_mmu_table_info *tbl_info,
				     unsigned int idx, bool secure __unused)
{
 110ae18:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 110ae1c:	910003fd 	mov	x29, sp
 110ae20:	a90153f3 	stp	x19, x20, [sp, #16]
 110ae24:	a9025bf5 	stp	x21, x22, [sp, #32]
	uint64_t *entry;
	int i;
	paddr_t pa;
	uint64_t attr;
	paddr_t block_size_on_next_lvl = 1 << (L1_XLAT_ADDRESS_SHIFT -
		tbl_info->level * XLAT_TABLE_ENTRIES_SHIFT);
 110ae28:	b9401015 	ldr	w21, [x0, #16]
#else
	prtn = &default_partition;
#endif
	assert(prtn);

	if (tbl_info->level >= 3 || idx > tbl_info->num_entries)
 110ae2c:	71000abf 	cmp	w21, #0x2
 110ae30:	540007c8 	b.hi	110af28 <core_mmu_entry_to_finer_grained+0x110>  // b.pmore
 110ae34:	b9401802 	ldr	w2, [x0, #24]
 110ae38:	6b01005f 	cmp	w2, w1
 110ae3c:	54000763 	b.cc	110af28 <core_mmu_entry_to_finer_grained+0x110>  // b.lo, b.ul, b.last
		return false;

	entry = (uint64_t *)tbl_info->table + idx;
 110ae40:	f9400016 	ldr	x22, [x0]
 110ae44:	d37d7c33 	ubfiz	x19, x1, #3, #32

	if ((*entry & DESC_ENTRY_TYPE_MASK) == TABLE_DESC)
 110ae48:	f8736ac0 	ldr	x0, [x22, x19]
 110ae4c:	92400400 	and	x0, x0, #0x3
 110ae50:	f1000c1f 	cmp	x0, #0x3
 110ae54:	54000560 	b.eq	110af00 <core_mmu_entry_to_finer_grained+0xe8>  // b.none
		return true;

	if (prtn->xlat_tables_used >= MAX_XLAT_TABLES)
 110ae58:	b0000281 	adrp	x1, 115b000 <__vcore_unpg_rw_start>
 110ae5c:	91036021 	add	x1, x1, #0xd8
 110ae60:	b9401820 	ldr	w0, [x1, #24]
 110ae64:	71001c1f 	cmp	w0, #0x7
 110ae68:	54000608 	b.hi	110af28 <core_mmu_entry_to_finer_grained+0x110>  // b.pmore
		return false;

	new_table = prtn->xlat_tables[prtn->xlat_tables_used++];
 110ae6c:	f9400434 	ldr	x20, [x1, #8]
 110ae70:	11000405 	add	w5, w0, #0x1
 110ae74:	d3747c00 	ubfiz	x0, x0, #12, #32

	DMSG("xlat tables used %d / %d",
 110ae78:	52800106 	mov	w6, #0x8                   	// #8
	new_table = prtn->xlat_tables[prtn->xlat_tables_used++];
 110ae7c:	8b000294 	add	x20, x20, x0
	DMSG("xlat tables used %d / %d",
 110ae80:	90000244 	adrp	x4, 1152000 <trace_ext_prefix+0x2e>
 110ae84:	52800023 	mov	w3, #0x1                   	// #1
 110ae88:	91366484 	add	x4, x4, #0xd99
 110ae8c:	52800062 	mov	w2, #0x3                   	// #3
 110ae90:	90000240 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 110ae94:	91381800 	add	x0, x0, #0xe06
	new_table = prtn->xlat_tables[prtn->xlat_tables_used++];
 110ae98:	b9001825 	str	w5, [x1, #24]
	DMSG("xlat tables used %d / %d",
 110ae9c:	52805e21 	mov	w1, #0x2f1                 	// #753
 110aea0:	9400e7a9 	bl	1144d44 <trace_printf>
	     prtn->xlat_tables_used, MAX_XLAT_TABLES);

	if (*entry) {
 110aea4:	f8736ac0 	ldr	x0, [x22, x19]
 110aea8:	b4000360 	cbz	x0, 110af14 <core_mmu_entry_to_finer_grained+0xfc>
		tbl_info->level * XLAT_TABLE_ENTRIES_SHIFT);
 110aeac:	0b150eb5 	add	w21, w21, w21, lsl #3
	paddr_t block_size_on_next_lvl = 1 << (L1_XLAT_ADDRESS_SHIFT -
 110aeb0:	528003c1 	mov	w1, #0x1e                  	// #30
 110aeb4:	4b150035 	sub	w21, w1, w21
 110aeb8:	52800021 	mov	w1, #0x1                   	// #1
		pa = *entry & OUTPUT_ADDRESS_MASK;
 110aebc:	92748c03 	and	x3, x0, #0xfffffffff000
		attr = *entry & ~(OUTPUT_ADDRESS_MASK | DESC_ENTRY_TYPE_MASK);
 110aec0:	927ef400 	and	x0, x0, #0xfffffffffffffffc
	paddr_t block_size_on_next_lvl = 1 << (L1_XLAT_ADDRESS_SHIFT -
 110aec4:	1ad52021 	lsl	w1, w1, w21
		attr = *entry & ~(OUTPUT_ADDRESS_MASK | DESC_ENTRY_TYPE_MASK);
 110aec8:	92506c00 	and	x0, x0, #0xffff000000000fff
	paddr_t block_size_on_next_lvl = 1 << (L1_XLAT_ADDRESS_SHIFT -
 110aecc:	93407c21 	sxtw	x1, w1
		attr = *entry & ~(OUTPUT_ADDRESS_MASK | DESC_ENTRY_TYPE_MASK);
 110aed0:	d2800002 	mov	x2, #0x0                   	// #0
		for (i = 0; i < XLAT_TABLE_ENTRIES; i++) {
			new_table[i] = pa | attr | BLOCK_DESC;
 110aed4:	aa030004 	orr	x4, x0, x3
			pa += block_size_on_next_lvl;
 110aed8:	8b010063 	add	x3, x3, x1
			new_table[i] = pa | attr | BLOCK_DESC;
 110aedc:	b2400084 	orr	x4, x4, #0x1
 110aee0:	f8227a84 	str	x4, [x20, x2, lsl #3]
		for (i = 0; i < XLAT_TABLE_ENTRIES; i++) {
 110aee4:	91000442 	add	x2, x2, #0x1
 110aee8:	f108005f 	cmp	x2, #0x200
 110aeec:	54ffff41 	b.ne	110aed4 <core_mmu_entry_to_finer_grained+0xbc>  // b.any
		}
	} else {
		memset(new_table, 0, XLAT_TABLE_ENTRIES * XLAT_ENTRY_SIZE);
	}

	*entry = virt_to_phys(new_table) | TABLE_DESC;
 110aef0:	aa1403e0 	mov	x0, x20
 110aef4:	97fffca1 	bl	110a178 <virt_to_phys>
 110aef8:	b2400400 	orr	x0, x0, #0x3
 110aefc:	f8336ac0 	str	x0, [x22, x19]
		return true;
 110af00:	52800020 	mov	w0, #0x1                   	// #1

	return true;
}
 110af04:	a94153f3 	ldp	x19, x20, [sp, #16]
 110af08:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110af0c:	a8c37bfd 	ldp	x29, x30, [sp], #48
 110af10:	d65f03c0 	ret
		memset(new_table, 0, XLAT_TABLE_ENTRIES * XLAT_ENTRY_SIZE);
 110af14:	aa1403e0 	mov	x0, x20
 110af18:	d2820002 	mov	x2, #0x1000                	// #4096
 110af1c:	52800001 	mov	w1, #0x0                   	// #0
 110af20:	9400e370 	bl	1143ce0 <memset>
 110af24:	17fffff3 	b	110aef0 <core_mmu_entry_to_finer_grained+0xd8>
		return false;
 110af28:	52800000 	mov	w0, #0x0                   	// #0
 110af2c:	17fffff6 	b	110af04 <core_mmu_entry_to_finer_grained+0xec>

000000000110af30 <core_mmu_set_entry_primitive>:
	if (a & TEE_MATTR_TABLE)
 110af30:	371806e4 	tbnz	w4, #3, 110b00c <core_mmu_set_entry_primitive+0xdc>
	if (!(a & TEE_MATTR_VALID_BLOCK))
 110af34:	36000704 	tbz	w4, #0, 110b014 <core_mmu_set_entry_primitive+0xe4>
	if (a & (TEE_MATTR_PX | TEE_MATTR_PW))
 110af38:	721b049f 	tst	w4, #0x60
 110af3c:	54000040 	b.eq	110af44 <core_mmu_set_entry_primitive+0x14>  // b.none
		a |= TEE_MATTR_PR;
 110af40:	321c0084 	orr	w4, w4, #0x10
	if (a & (TEE_MATTR_UX | TEE_MATTR_UW))
 110af44:	7218049f 	tst	w4, #0x300
 110af48:	54000080 	b.eq	110af58 <core_mmu_set_entry_primitive+0x28>  // b.none
		a |= TEE_MATTR_UR;
 110af4c:	32190084 	orr	w4, w4, #0x80
		a |= TEE_MATTR_PR;
 110af50:	321c0084 	orr	w4, w4, #0x10
 110af54:	14000002 	b	110af5c <core_mmu_set_entry_primitive+0x2c>
	if (a & TEE_MATTR_UR)
 110af58:	373fffc4 	tbnz	w4, #7, 110af50 <core_mmu_set_entry_primitive+0x20>
	if (a & TEE_MATTR_UW)
 110af5c:	36400044 	tbz	w4, #8, 110af64 <core_mmu_set_entry_primitive+0x34>
		a |= TEE_MATTR_PW;
 110af60:	321b0084 	orr	w4, w4, #0x20
		desc = BLOCK_DESC;
 110af64:	71000c3f 	cmp	w1, #0x3
	if (!(a & (TEE_MATTR_PX | TEE_MATTR_UX)))
 110af68:	52804805 	mov	w5, #0x240                 	// #576
		desc = BLOCK_DESC;
 110af6c:	d2800061 	mov	x1, #0x3                   	// #3
 110af70:	9a9f0421 	csinc	x1, x1, xzr, eq  // eq = none
	if (!(a & (TEE_MATTR_PX | TEE_MATTR_UX)))
 110af74:	6a05009f 	tst	w4, w5
 110af78:	54000041 	b.ne	110af80 <core_mmu_set_entry_primitive+0x50>  // b.any
		desc |= UPPER_ATTRS(XN);
 110af7c:	b24a0021 	orr	x1, x1, #0x40000000000000
	if (!(a & TEE_MATTR_PX))
 110af80:	37300044 	tbnz	w4, #6, 110af88 <core_mmu_set_entry_primitive+0x58>
		desc |= UPPER_ATTRS(PXN);
 110af84:	b24b0021 	orr	x1, x1, #0x20000000000000
	if (a & TEE_MATTR_UR)
 110af88:	36380044 	tbz	w4, #7, 110af90 <core_mmu_set_entry_primitive+0x60>
		desc |= LOWER_ATTRS(AP_UNPRIV);
 110af8c:	b27a0021 	orr	x1, x1, #0x40
	if (!(a & TEE_MATTR_PW))
 110af90:	37280044 	tbnz	w4, #5, 110af98 <core_mmu_set_entry_primitive+0x68>
		desc |= LOWER_ATTRS(AP_RO);
 110af94:	b2790021 	orr	x1, x1, #0x80
	switch ((a >> TEE_MATTR_CACHE_SHIFT) & TEE_MATTR_CACHE_MASK) {
 110af98:	d34c3885 	ubfx	x5, x4, #12, #3
 110af9c:	34000185 	cbz	w5, 110afcc <core_mmu_set_entry_primitive+0x9c>
 110afa0:	710004bf 	cmp	w5, #0x1
 110afa4:	540002e0 	b.eq	110b000 <core_mmu_set_entry_primitive+0xd0>  // b.none

void core_mmu_set_entry_primitive(void *table, size_t level, size_t idx,
				  paddr_t pa, uint32_t attr)
{
 110afa8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
		panic();
 110afac:	90000242 	adrp	x2, 1152000 <trace_ext_prefix+0x2e>
 110afb0:	90000240 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
{
 110afb4:	910003fd 	mov	x29, sp
		panic();
 110afb8:	9136fc42 	add	x2, x2, #0xdbf
 110afbc:	91345800 	add	x0, x0, #0xd16
 110afc0:	d2800003 	mov	x3, #0x0                   	// #0
 110afc4:	52802b21 	mov	w1, #0x159                 	// #345
 110afc8:	94002128 	bl	1113468 <__do_panic>
		desc |= LOWER_ATTRS(ATTR_DEVICE_INDEX | OSH);
 110afcc:	b2770021 	orr	x1, x1, #0x200
	if (a & (TEE_MATTR_UR | TEE_MATTR_PR))
 110afd0:	52801205 	mov	w5, #0x90                  	// #144
 110afd4:	6a05009f 	tst	w4, w5
 110afd8:	54000040 	b.eq	110afe0 <core_mmu_set_entry_primitive+0xb0>  // b.none
		desc |= LOWER_ATTRS(ACCESS_FLAG);
 110afdc:	b2760021 	orr	x1, x1, #0x400
	if (!(a & TEE_MATTR_GLOBAL))
 110afe0:	37500044 	tbnz	w4, #10, 110afe8 <core_mmu_set_entry_primitive+0xb8>
		desc |= LOWER_ATTRS(NON_GLOBAL);
 110afe4:	b2750021 	orr	x1, x1, #0x800
	desc |= a & TEE_MATTR_SECURE ? 0 : LOWER_ATTRS(NS);
 110afe8:	f275009f 	tst	x4, #0x800
 110afec:	9a9f17e4 	cset	x4, eq  // eq = none
 110aff0:	aa041421 	orr	x1, x1, x4, lsl #5
	uint64_t *tbl = table;
	uint64_t desc = mattr_to_desc(level, attr);

	tbl[idx] = desc | pa;
 110aff4:	aa010063 	orr	x3, x3, x1
 110aff8:	f8227803 	str	x3, [x0, x2, lsl #3]
 110affc:	d65f03c0 	ret
		desc |= LOWER_ATTRS(ATTR_IWBWA_OWBWA_NTR_INDEX | ISH);
 110b000:	d2806085 	mov	x5, #0x304                 	// #772
 110b004:	aa050021 	orr	x1, x1, x5
		break;
 110b008:	17fffff2 	b	110afd0 <core_mmu_set_entry_primitive+0xa0>
		return TABLE_DESC;
 110b00c:	d2800061 	mov	x1, #0x3                   	// #3
 110b010:	17fffff9 	b	110aff4 <core_mmu_set_entry_primitive+0xc4>
		return 0;
 110b014:	d2800001 	mov	x1, #0x0                   	// #0
 110b018:	17fffff7 	b	110aff4 <core_mmu_set_entry_primitive+0xc4>

000000000110b01c <core_mmu_get_entry_primitive>:
void core_mmu_get_entry_primitive(const void *table, size_t level,
				  size_t idx, paddr_t *pa, uint32_t *attr)
{
	const uint64_t *tbl = table;

	if (pa)
 110b01c:	b4000083 	cbz	x3, 110b02c <core_mmu_get_entry_primitive+0x10>
		*pa = (tbl[idx] & ((1ull << 40) - 1)) & ~((1 << 12) - 1);
 110b020:	f8627805 	ldr	x5, [x0, x2, lsl #3]
 110b024:	92746ca5 	and	x5, x5, #0xfffffff000
 110b028:	f9000065 	str	x5, [x3]

	if (attr)
 110b02c:	b40003a4 	cbz	x4, 110b0a0 <core_mmu_get_entry_primitive+0x84>
		*attr = desc_to_mattr(level, tbl[idx]);
 110b030:	f8627802 	ldr	x2, [x0, x2, lsl #3]
	if (!(desc & 1))
 110b034:	36000402 	tbz	w2, #0, 110b0b4 <core_mmu_get_entry_primitive+0x98>
	if (level == 3) {
 110b038:	92400440 	and	x0, x2, #0x3
 110b03c:	71000c3f 	cmp	w1, #0x3
 110b040:	54000321 	b.ne	110b0a4 <core_mmu_get_entry_primitive+0x88>  // b.any
		if ((desc & DESC_ENTRY_TYPE_MASK) != L3_BLOCK_DESC)
 110b044:	f1000c1f 	cmp	x0, #0x3
 110b048:	54000361 	b.ne	110b0b4 <core_mmu_get_entry_primitive+0x98>  // b.any
		a |= TEE_MATTR_PRX | TEE_MATTR_URX;
 110b04c:	f276005f 	tst	x2, #0x400
 110b050:	52805a20 	mov	w0, #0x2d1                 	// #721
 110b054:	1a9f1401 	csinc	w1, w0, wzr, ne  // ne = any
	if (!(desc & LOWER_ATTRS(AP_RO)))
 110b058:	37380062 	tbnz	w2, #7, 110b064 <core_mmu_get_entry_primitive+0x48>
		a |= TEE_MATTR_PW | TEE_MATTR_UW;
 110b05c:	52802400 	mov	w0, #0x120                 	// #288
 110b060:	2a000021 	orr	w1, w1, w0
	if (!(desc & LOWER_ATTRS(AP_UNPRIV)))
 110b064:	37300042 	tbnz	w2, #6, 110b06c <core_mmu_get_entry_primitive+0x50>
		a &= ~TEE_MATTR_URWX;
 110b068:	12167021 	and	w1, w1, #0xfffffc7f
	if (desc & UPPER_ATTRS(XN))
 110b06c:	b6b00062 	tbz	x2, #54, 110b078 <core_mmu_get_entry_primitive+0x5c>
		a &= ~(TEE_MATTR_PX | TEE_MATTR_UX);
 110b070:	12804800 	mov	w0, #0xfffffdbf            	// #-577
 110b074:	0a000021 	and	w1, w1, w0
	if (desc & UPPER_ATTRS(PXN))
 110b078:	b6a80042 	tbz	x2, #53, 110b080 <core_mmu_get_entry_primitive+0x64>
		a &= ~TEE_MATTR_PX;
 110b07c:	12197821 	and	w1, w1, #0xffffffbf
	a |= ((desc & LOWER_ATTRS(ATTR_INDEX_MASK)) >> LOWER_ATTRS_SHIFT) <<
 110b080:	d342fc40 	lsr	x0, x2, #2
 110b084:	53140800 	ubfiz	w0, w0, #12, #3
 110b088:	2a010000 	orr	w0, w0, w1
	if (!(desc & LOWER_ATTRS(NON_GLOBAL)))
 110b08c:	37580042 	tbnz	w2, #11, 110b094 <core_mmu_get_entry_primitive+0x78>
		a |= TEE_MATTR_GLOBAL;
 110b090:	32160000 	orr	w0, w0, #0x400
	if (!(desc & LOWER_ATTRS(NS)))
 110b094:	37280042 	tbnz	w2, #5, 110b09c <core_mmu_get_entry_primitive+0x80>
		a |= TEE_MATTR_SECURE;
 110b098:	32150000 	orr	w0, w0, #0x800
		*attr = desc_to_mattr(level, tbl[idx]);
 110b09c:	b9000080 	str	w0, [x4]
}
 110b0a0:	d65f03c0 	ret
		if ((desc & DESC_ENTRY_TYPE_MASK) == TABLE_DESC)
 110b0a4:	f1000c1f 	cmp	x0, #0x3
 110b0a8:	54fffd21 	b.ne	110b04c <core_mmu_get_entry_primitive+0x30>  // b.any
			return TEE_MATTR_TABLE;
 110b0ac:	52800100 	mov	w0, #0x8                   	// #8
 110b0b0:	17fffffb 	b	110b09c <core_mmu_get_entry_primitive+0x80>
		return 0;
 110b0b4:	52800000 	mov	w0, #0x0                   	// #0
 110b0b8:	17fffff9 	b	110b09c <core_mmu_get_entry_primitive+0x80>

000000000110b0bc <core_mmu_user_va_range_is_defined>:

bool core_mmu_user_va_range_is_defined(void)
{
	return user_va_idx != -1;
 110b0bc:	d0000280 	adrp	x0, 115d000 <_curve_names+0x590>
 110b0c0:	b94be400 	ldr	w0, [x0, #3044]
 110b0c4:	3100041f 	cmn	w0, #0x1
}
 110b0c8:	1a9f07e0 	cset	w0, ne  // ne = any
 110b0cc:	d65f03c0 	ret

000000000110b0d0 <core_mmu_get_user_va_range>:

void core_mmu_get_user_va_range(vaddr_t *base, size_t *size)
{
	assert(user_va_idx != -1);
 110b0d0:	d0000282 	adrp	x2, 115d000 <_curve_names+0x590>
 110b0d4:	b94be442 	ldr	w2, [x2, #3044]
 110b0d8:	3100045f 	cmn	w2, #0x1
 110b0dc:	54000181 	b.ne	110b10c <core_mmu_get_user_va_range+0x3c>  // b.any
 110b0e0:	f0000223 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 110b0e4:	f0000221 	adrp	x1, 1152000 <trace_ext_prefix+0x2e>
 110b0e8:	91389863 	add	x3, x3, #0xe26
 110b0ec:	91345821 	add	x1, x1, #0xd16
 110b0f0:	f0000220 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 110b0f4:	91354c00 	add	x0, x0, #0xd53
{
 110b0f8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	assert(user_va_idx != -1);
 110b0fc:	52806402 	mov	w2, #0x320                 	// #800
{
 110b100:	910003fd 	mov	x29, sp
	assert(user_va_idx != -1);
 110b104:	94001c6a 	bl	11122ac <_assert_log>
 110b108:	94001c7a 	bl	11122f0 <_assert_break>

	if (base)
 110b10c:	b4000060 	cbz	x0, 110b118 <core_mmu_get_user_va_range+0x48>
		*base = (vaddr_t)user_va_idx << L1_XLAT_ADDRESS_SHIFT;
 110b110:	93627c42 	sbfiz	x2, x2, #30, #32
 110b114:	f9000002 	str	x2, [x0]
	if (size)
 110b118:	b4000061 	cbz	x1, 110b124 <core_mmu_get_user_va_range+0x54>
		*size = 1 << L1_XLAT_ADDRESS_SHIFT;
 110b11c:	d2a80000 	mov	x0, #0x40000000            	// #1073741824
 110b120:	f9000020 	str	x0, [x1]
 110b124:	d65f03c0 	ret

000000000110b128 <core_mmu_get_user_pgdir>:
{
 110b128:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 110b12c:	910003fd 	mov	x29, sp
 110b130:	a90153f3 	stp	x19, x20, [sp, #16]
 110b134:	aa0003f3 	mov	x19, x0
	void *tbl = get_prtn()->l2_ta_tables[thread_get_id()];
 110b138:	90000280 	adrp	x0, 115b000 <__vcore_unpg_rw_start>
 110b13c:	f9407414 	ldr	x20, [x0, #232]
 110b140:	97ffe8c9 	bl	1105464 <thread_get_id>
 110b144:	93743c00 	sbfiz	x0, x0, #12, #16
	core_mmu_get_user_va_range(&va_range_base, NULL);
 110b148:	d2800001 	mov	x1, #0x0                   	// #0
	void *tbl = get_prtn()->l2_ta_tables[thread_get_id()];
 110b14c:	8b000294 	add	x20, x20, x0
	core_mmu_get_user_va_range(&va_range_base, NULL);
 110b150:	9100a3e0 	add	x0, sp, #0x28
 110b154:	97ffffdf 	bl	110b0d0 <core_mmu_get_user_va_range>
	tbl_info->va_base = va_base;
 110b158:	f94017e0 	ldr	x0, [sp, #40]
 110b15c:	a9000274 	stp	x20, x0, [x19]
	tbl_info->level = level;
 110b160:	d2800040 	mov	x0, #0x2                   	// #2
 110b164:	f2c002a0 	movk	x0, #0x15, lsl #32
 110b168:	f9000a60 	str	x0, [x19, #16]
		tbl_info->num_entries = XLAT_TABLE_ENTRIES;
 110b16c:	52804000 	mov	w0, #0x200                 	// #512
 110b170:	b9001a60 	str	w0, [x19, #24]
}
 110b174:	a94153f3 	ldp	x19, x20, [sp, #16]
 110b178:	a8c37bfd 	ldp	x29, x30, [sp], #48
 110b17c:	d65f03c0 	ret

000000000110b180 <core_mmu_create_user_map>:
{
 110b180:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 110b184:	910003fd 	mov	x29, sp
 110b188:	f90013f5 	str	x21, [sp, #32]
	core_mmu_get_user_pgdir(&dir_info);
 110b18c:	9100c3f5 	add	x21, sp, #0x30
{
 110b190:	a90153f3 	stp	x19, x20, [sp, #16]
 110b194:	aa0103f3 	mov	x19, x1
 110b198:	aa0003f4 	mov	x20, x0
	core_mmu_get_user_pgdir(&dir_info);
 110b19c:	aa1503e0 	mov	x0, x21
 110b1a0:	97ffffe2 	bl	110b128 <core_mmu_get_user_pgdir>
	memset(dir_info.table, 0, PGT_SIZE);
 110b1a4:	f9401be0 	ldr	x0, [sp, #48]
 110b1a8:	d2820002 	mov	x2, #0x1000                	// #4096
 110b1ac:	52800001 	mov	w1, #0x0                   	// #0
 110b1b0:	9400e2cc 	bl	1143ce0 <memset>
	core_mmu_populate_user_map(&dir_info, uctx);
 110b1b4:	aa1403e1 	mov	x1, x20
 110b1b8:	aa1503e0 	mov	x0, x21
 110b1bc:	97fffc83 	bl	110a3c8 <core_mmu_populate_user_map>
	map->user_map = virt_to_phys(dir_info.table) | TABLE_DESC;
 110b1c0:	f9401be0 	ldr	x0, [sp, #48]
 110b1c4:	97fffbed 	bl	110a178 <virt_to_phys>
 110b1c8:	b2400400 	orr	x0, x0, #0x3
}
 110b1cc:	f94013f5 	ldr	x21, [sp, #32]
	map->user_map = virt_to_phys(dir_info.table) | TABLE_DESC;
 110b1d0:	f9000260 	str	x0, [x19]
	map->asid = uctx->vm_info.asid;
 110b1d4:	b9401280 	ldr	w0, [x20, #16]
 110b1d8:	b9000a60 	str	w0, [x19, #8]
}
 110b1dc:	a94153f3 	ldp	x19, x20, [sp, #16]
 110b1e0:	a8c57bfd 	ldp	x29, x30, [sp], #80
 110b1e4:	d65f03c0 	ret

000000000110b1e8 <core_mmu_user_mapping_is_active>:
}

bool core_mmu_user_mapping_is_active(void)
{
 110b1e8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	bool ret;
	uint32_t exceptions = thread_mask_exceptions(THREAD_EXCP_ALL);
 110b1ec:	528000e0 	mov	w0, #0x7                   	// #7
{
 110b1f0:	910003fd 	mov	x29, sp
 110b1f4:	a90153f3 	stp	x19, x20, [sp, #16]

	assert(user_va_idx != -1);
 110b1f8:	d0000294 	adrp	x20, 115d000 <_curve_names+0x590>
{
 110b1fc:	f90013f5 	str	x21, [sp, #32]
	uint32_t exceptions = thread_mask_exceptions(THREAD_EXCP_ALL);
 110b200:	97ffe7ce 	bl	1105138 <thread_mask_exceptions>
 110b204:	2a0003f3 	mov	w19, w0
	assert(user_va_idx != -1);
 110b208:	b94be680 	ldr	w0, [x20, #3044]
 110b20c:	3100041f 	cmn	w0, #0x1
 110b210:	54000141 	b.ne	110b238 <core_mmu_user_mapping_is_active+0x50>  // b.any
 110b214:	f0000223 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 110b218:	f0000221 	adrp	x1, 1152000 <trace_ext_prefix+0x2e>
 110b21c:	91390463 	add	x3, x3, #0xe41
 110b220:	91345821 	add	x1, x1, #0xd16
 110b224:	f0000220 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 110b228:	91354c00 	add	x0, x0, #0xd53
 110b22c:	528065a2 	mov	w2, #0x32d                 	// #813
 110b230:	94001c1f 	bl	11122ac <_assert_log>
 110b234:	94001c2f 	bl	11122f0 <_assert_break>
	ret = get_prtn()->l1_tables[0][get_core_pos()][user_va_idx];
 110b238:	90000280 	adrp	x0, 115b000 <__vcore_unpg_rw_start>
 110b23c:	f9406c15 	ldr	x21, [x0, #216]
 110b240:	97fffdf7 	bl	110aa1c <get_core_pos>
 110b244:	b98be681 	ldrsw	x1, [x20, #3044]
 110b248:	8b000820 	add	x0, x1, x0, lsl #2
 110b24c:	f8607aa0 	ldr	x0, [x21, x0, lsl #3]
 110b250:	f100001f 	cmp	x0, #0x0
	thread_unmask_exceptions(exceptions);
 110b254:	2a1303e0 	mov	w0, w19
	ret = get_prtn()->l1_tables[0][get_core_pos()][user_va_idx];
 110b258:	1a9f07f4 	cset	w20, ne  // ne = any
	thread_unmask_exceptions(exceptions);
 110b25c:	97ffe7c4 	bl	110516c <thread_unmask_exceptions>

	return ret;
}
 110b260:	2a1403e0 	mov	w0, w20
 110b264:	a94153f3 	ldp	x19, x20, [sp, #16]
 110b268:	f94013f5 	ldr	x21, [sp, #32]
 110b26c:	a8c37bfd 	ldp	x29, x30, [sp], #48
 110b270:	d65f03c0 	ret

000000000110b274 <core_mmu_get_user_map>:
}
#endif /*ARM32*/

#ifdef ARM64
void core_mmu_get_user_map(struct core_mmu_user_map *map)
{
 110b274:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 110b278:	910003fd 	mov	x29, sp
 110b27c:	a90153f3 	stp	x19, x20, [sp, #16]
	struct mmu_partition *prtn = get_prtn();

	assert(user_va_idx != -1);
 110b280:	d0000294 	adrp	x20, 115d000 <_curve_names+0x590>
{
 110b284:	aa0003f3 	mov	x19, x0
	assert(user_va_idx != -1);
 110b288:	b94be680 	ldr	w0, [x20, #3044]
{
 110b28c:	f90013f5 	str	x21, [sp, #32]
	assert(user_va_idx != -1);
 110b290:	3100041f 	cmn	w0, #0x1
 110b294:	54000141 	b.ne	110b2bc <core_mmu_get_user_map+0x48>  // b.any
 110b298:	f0000223 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 110b29c:	f0000221 	adrp	x1, 1152000 <trace_ext_prefix+0x2e>
 110b2a0:	91398463 	add	x3, x3, #0xe61
 110b2a4:	91345821 	add	x1, x1, #0xd16
 110b2a8:	f0000220 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 110b2ac:	91354c00 	add	x0, x0, #0xd53
 110b2b0:	528071e2 	mov	w2, #0x38f                 	// #911
 110b2b4:	94001bfe 	bl	11122ac <_assert_log>
 110b2b8:	94001c0e 	bl	11122f0 <_assert_break>

	map->user_map = prtn->l1_tables[0][get_core_pos()][user_va_idx];
 110b2bc:	90000280 	adrp	x0, 115b000 <__vcore_unpg_rw_start>
 110b2c0:	f9406c15 	ldr	x21, [x0, #216]
 110b2c4:	97fffdd6 	bl	110aa1c <get_core_pos>
 110b2c8:	b98be681 	ldrsw	x1, [x20, #3044]
 110b2cc:	8b000820 	add	x0, x1, x0, lsl #2
 110b2d0:	f8607aa0 	ldr	x0, [x21, x0, lsl #3]
 110b2d4:	f9000260 	str	x0, [x19]
	if (map->user_map) {
 110b2d8:	b4000100 	cbz	x0, 110b2f8 <core_mmu_get_user_map+0x84>
DEFINE_U64_REG_READWRITE_FUNCS(ttbr0_el1)
 110b2dc:	d5382000 	mrs	x0, ttbr0_el1
		map->asid = (read_ttbr0_el1() >> TTBR_ASID_SHIFT) &
 110b2e0:	d370dc00 	ubfx	x0, x0, #48, #8
			    TTBR_ASID_MASK;
	} else {
		map->asid = 0;
	}
}
 110b2e4:	f94013f5 	ldr	x21, [sp, #32]
 110b2e8:	b9000a60 	str	w0, [x19, #8]
 110b2ec:	a94153f3 	ldp	x19, x20, [sp, #16]
 110b2f0:	a8c37bfd 	ldp	x29, x30, [sp], #48
 110b2f4:	d65f03c0 	ret
		map->asid = 0;
 110b2f8:	52800000 	mov	w0, #0x0                   	// #0
 110b2fc:	17fffffa 	b	110b2e4 <core_mmu_get_user_map+0x70>

000000000110b300 <core_mmu_set_user_map>:

void core_mmu_set_user_map(struct core_mmu_user_map *map)
{
 110b300:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 110b304:	910003fd 	mov	x29, sp
 110b308:	a90153f3 	stp	x19, x20, [sp, #16]
 110b30c:	aa0003f3 	mov	x19, x0
	uint64_t ttbr;
	uint32_t exceptions = thread_mask_exceptions(THREAD_EXCP_ALL);
 110b310:	528000e0 	mov	w0, #0x7                   	// #7
{
 110b314:	a9025bf5 	stp	x21, x22, [sp, #32]
 110b318:	a90363f7 	stp	x23, x24, [sp, #48]
	uint32_t exceptions = thread_mask_exceptions(THREAD_EXCP_ALL);
 110b31c:	97ffe787 	bl	1105138 <thread_mask_exceptions>
 110b320:	2a0003f7 	mov	w23, w0
 110b324:	d5382016 	mrs	x22, ttbr0_el1
	struct mmu_partition *prtn = get_prtn();

	ttbr = read_ttbr0_el1();
	/* Clear ASID */
	ttbr &= ~((uint64_t)TTBR_ASID_MASK << TTBR_ASID_SHIFT);
 110b328:	9248ded6 	and	x22, x22, #0xff00ffffffffffff
 110b32c:	d5182016 	msr	ttbr0_el1, x22
	asm volatile ("isb");
 110b330:	d5033fdf 	isb
	write_ttbr0_el1(ttbr);
	isb();

	/* Set the new map */
	if (map && map->user_map) {
 110b334:	90000295 	adrp	x21, 115b000 <__vcore_unpg_rw_start>
 110b338:	d0000294 	adrp	x20, 115d000 <_curve_names+0x590>
 110b33c:	b40003b3 	cbz	x19, 110b3b0 <core_mmu_set_user_map+0xb0>
 110b340:	f9400260 	ldr	x0, [x19]
 110b344:	b4000360 	cbz	x0, 110b3b0 <core_mmu_set_user_map+0xb0>
 110b348:	f9406eb8 	ldr	x24, [x21, #216]
		prtn->l1_tables[0][get_core_pos()][user_va_idx] =
 110b34c:	97fffdb4 	bl	110aa1c <get_core_pos>
 110b350:	b98be682 	ldrsw	x2, [x20, #3044]
			map->user_map;
 110b354:	f9400261 	ldr	x1, [x19]
		prtn->l1_tables[0][get_core_pos()][user_va_idx] =
 110b358:	8b000840 	add	x0, x2, x0, lsl #2
#ifdef CFG_CORE_UNMAP_CORE_AT_EL0
		prtn->l1_tables[1][get_core_pos()][user_va_idx] =
 110b35c:	f9406eb5 	ldr	x21, [x21, #216]
		prtn->l1_tables[0][get_core_pos()][user_va_idx] =
 110b360:	f8207b01 	str	x1, [x24, x0, lsl #3]
		prtn->l1_tables[1][get_core_pos()][user_va_idx] =
 110b364:	910202b5 	add	x21, x21, #0x80
 110b368:	97fffdad 	bl	110aa1c <get_core_pos>
 110b36c:	b98be682 	ldrsw	x2, [x20, #3044]
			map->user_map;
 110b370:	f9400261 	ldr	x1, [x19]
		prtn->l1_tables[1][get_core_pos()][user_va_idx] =
 110b374:	8b000840 	add	x0, x2, x0, lsl #2
 110b378:	f8207aa1 	str	x1, [x21, x0, lsl #3]
	asm volatile ("dsb sy");
 110b37c:	d5033f9f 	dsb	sy
#endif
		dsb();	/* Make sure the write above is visible */
		ttbr |= ((uint64_t)map->asid << TTBR_ASID_SHIFT);
 110b380:	b9400a60 	ldr	w0, [x19, #8]
 110b384:	aa00c2d6 	orr	x22, x22, x0, lsl #48
DEFINE_U64_REG_READWRITE_FUNCS(ttbr0_el1)
 110b388:	d5182016 	msr	ttbr0_el1, x22
	asm volatile ("isb");
 110b38c:	d5033fdf 	isb
		prtn->l1_tables[1][get_core_pos()][user_va_idx] = 0;
#endif
		dsb();	/* Make sure the write above is visible */
	}

	tlbi_all();
 110b390:	97ffe47e 	bl	1104588 <tlbi_all>
	icache_inv_all();
 110b394:	97ffe4f2 	bl	110475c <icache_inv_all>

	thread_unmask_exceptions(exceptions);
 110b398:	2a1703e0 	mov	w0, w23
}
 110b39c:	a94153f3 	ldp	x19, x20, [sp, #16]
 110b3a0:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110b3a4:	a94363f7 	ldp	x23, x24, [sp, #48]
 110b3a8:	a8c47bfd 	ldp	x29, x30, [sp], #64
	thread_unmask_exceptions(exceptions);
 110b3ac:	17ffe770 	b	110516c <thread_unmask_exceptions>
		prtn->l1_tables[0][get_core_pos()][user_va_idx] = 0;
 110b3b0:	f9406eb3 	ldr	x19, [x21, #216]
 110b3b4:	97fffd9a 	bl	110aa1c <get_core_pos>
 110b3b8:	b98be681 	ldrsw	x1, [x20, #3044]
 110b3bc:	8b000820 	add	x0, x1, x0, lsl #2
 110b3c0:	f8207a7f 	str	xzr, [x19, x0, lsl #3]
		prtn->l1_tables[1][get_core_pos()][user_va_idx] = 0;
 110b3c4:	f9406eb3 	ldr	x19, [x21, #216]
 110b3c8:	97fffd95 	bl	110aa1c <get_core_pos>
 110b3cc:	b98be681 	ldrsw	x1, [x20, #3044]
 110b3d0:	91020273 	add	x19, x19, #0x80
 110b3d4:	8b000820 	add	x0, x1, x0, lsl #2
 110b3d8:	f8207a7f 	str	xzr, [x19, x0, lsl #3]
	asm volatile ("dsb sy");
 110b3dc:	d5033f9f 	dsb	sy
}
 110b3e0:	17ffffec 	b	110b390 <core_mmu_set_user_map+0x90>

000000000110b3e4 <core_mmu_get_fault_type>:

enum core_mmu_fault core_mmu_get_fault_type(uint32_t fault_descr)
{
	switch ((fault_descr >> ESR_EC_SHIFT) & ESR_EC_MASK) {
 110b3e4:	531a7c01 	lsr	w1, w0, #26
 110b3e8:	51008021 	sub	w1, w1, #0x20
 110b3ec:	7100183f 	cmp	w1, #0x6
 110b3f0:	54000228 	b.hi	110b434 <core_mmu_get_fault_type+0x50>  // b.pmore
 110b3f4:	f0000202 	adrp	x2, 114e000 <ldelf_data+0x8000>
 110b3f8:	91179042 	add	x2, x2, #0x5e4
 110b3fc:	38614841 	ldrb	w1, [x2, w1, uxtw]
 110b400:	10000062 	adr	x2, 110b40c <core_mmu_get_fault_type+0x28>
 110b404:	8b218841 	add	x1, x2, w1, sxtb #2
 110b408:	d61f0020 	br	x1
		return CORE_MMU_FAULT_ALIGNMENT;
	case ESR_EC_IABT_EL0:
	case ESR_EC_DABT_EL0:
	case ESR_EC_IABT_EL1:
	case ESR_EC_DABT_EL1:
		switch (fault_descr & ESR_FSC_MASK) {
 110b40c:	12001401 	and	w1, w0, #0x3f
 110b410:	721c041f 	tst	w0, #0x30
 110b414:	54000141 	b.ne	110b43c <core_mmu_get_fault_type+0x58>  // b.any
 110b418:	7100303f 	cmp	w1, #0xc
 110b41c:	54000188 	b.hi	110b44c <core_mmu_get_fault_type+0x68>  // b.pmore
 110b420:	721d081f 	tst	w0, #0x38
 110b424:	54000200 	b.eq	110b464 <core_mmu_get_fault_type+0x80>  // b.none
 110b428:	51002421 	sub	w1, w1, #0x9
 110b42c:	7100083f 	cmp	w1, #0x2
 110b430:	540000e9 	b.ls	110b44c <core_mmu_get_fault_type+0x68>  // b.plast
			else
				return CORE_MMU_FAULT_READ_PERMISSION;
		case ESR_FSC_ALIGN:
			return CORE_MMU_FAULT_ALIGNMENT;
		default:
			return CORE_MMU_FAULT_OTHER;
 110b434:	528000e0 	mov	w0, #0x7                   	// #7
 110b438:	14000004 	b	110b448 <core_mmu_get_fault_type+0x64>
			return CORE_MMU_FAULT_ALIGNMENT;
 110b43c:	7100843f 	cmp	w1, #0x21
 110b440:	528000e0 	mov	w0, #0x7                   	// #7
 110b444:	1a9f1000 	csel	w0, w0, wzr, ne  // ne = any
		}
	default:
		return CORE_MMU_FAULT_OTHER;
	}
}
 110b448:	d65f03c0 	ret
				return CORE_MMU_FAULT_READ_PERMISSION;
 110b44c:	f27a001f 	tst	x0, #0x40
 110b450:	1a9f17e0 	cset	w0, eq  // eq = none
 110b454:	11000c00 	add	w0, w0, #0x3
 110b458:	17fffffc 	b	110b448 <core_mmu_get_fault_type+0x64>
			return CORE_MMU_FAULT_ALIGNMENT;
 110b45c:	52800000 	mov	w0, #0x0                   	// #0
 110b460:	17fffffa 	b	110b448 <core_mmu_get_fault_type+0x64>
		switch (fault_descr & ESR_FSC_MASK) {
 110b464:	52800040 	mov	w0, #0x2                   	// #2
 110b468:	17fffff8 	b	110b448 <core_mmu_get_fault_type+0x64>

000000000110b46c <cpu_spin_lock_xsave_dldetect>:
{
 110b46c:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 110b470:	910003fd 	mov	x29, sp
 110b474:	a90153f3 	stp	x19, x20, [sp, #16]
 110b478:	a9025bf5 	stp	x21, x22, [sp, #32]
 110b47c:	aa0203f5 	mov	x21, x2
 110b480:	a90363f7 	stp	x23, x24, [sp, #48]
 110b484:	aa0003f7 	mov	x23, x0
 110b488:	2a0103f8 	mov	w24, w1
	uint32_t exceptions = thread_mask_exceptions(THREAD_EXCP_ALL);
 110b48c:	528000e0 	mov	w0, #0x7                   	// #7
{
 110b490:	a9046bf9 	stp	x25, x26, [sp, #64]
	uint32_t exceptions = thread_mask_exceptions(THREAD_EXCP_ALL);
 110b494:	97ffe729 	bl	1105138 <thread_mask_exceptions>
 110b498:	2a0003f4 	mov	w20, w0
 110b49c:	97ffe69e 	bl	1104f14 <thread_get_exceptions>
	assert(thread_foreign_intr_disabled());
 110b4a0:	36080220 	tbz	w0, #1, 110b4e4 <cpu_spin_lock_xsave_dldetect+0x78>
			trace_printf(func, line, TRACE_ERROR, true,
 110b4a4:	d0000239 	adrp	x25, 1151000 <small_prime+0x168>
 110b4a8:	91131739 	add	x25, x25, #0x4c5
 110b4ac:	52800013 	mov	w19, #0x0                   	// #0
		if (!retries) {
 110b4b0:	d2c0003a 	mov	x26, #0x100000000           	// #4294967296
	unsigned int reminder = 0;
 110b4b4:	d2800016 	mov	x22, #0x0                   	// #0
	while (__cpu_spin_trylock(lock)) {
 110b4b8:	aa1503e0 	mov	x0, x21
 110b4bc:	97ffe3fa 	bl	11044a4 <__cpu_spin_trylock>
 110b4c0:	35000240 	cbnz	w0, 110b508 <cpu_spin_lock_xsave_dldetect+0x9c>
	spinlock_count_incr();
 110b4c4:	97ffe401 	bl	11044c8 <spinlock_count_incr>
}
 110b4c8:	2a1403e0 	mov	w0, w20
 110b4cc:	a94153f3 	ldp	x19, x20, [sp, #16]
 110b4d0:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110b4d4:	a94363f7 	ldp	x23, x24, [sp, #48]
 110b4d8:	a9446bf9 	ldp	x25, x26, [sp, #64]
 110b4dc:	a8c57bfd 	ldp	x29, x30, [sp], #80
 110b4e0:	d65f03c0 	ret
	assert(thread_foreign_intr_disabled());
 110b4e4:	f0000223 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 110b4e8:	d0000221 	adrp	x1, 1151000 <small_prime+0x168>
 110b4ec:	913b9463 	add	x3, x3, #0xee5
 110b4f0:	9111f821 	add	x1, x1, #0x47e
 110b4f4:	d0000220 	adrp	x0, 1151000 <small_prime+0x168>
 110b4f8:	91129800 	add	x0, x0, #0x4a6
 110b4fc:	528006e2 	mov	w2, #0x37                  	// #55
 110b500:	94001b6b 	bl	11122ac <_assert_log>
 110b504:	94001b7b 	bl	11122f0 <_assert_break>
		if (!retries) {
 110b508:	910006d6 	add	x22, x22, #0x1
 110b50c:	eb1a02df 	cmp	x22, x26
 110b510:	54fffd41 	b.ne	110b4b8 <cpu_spin_lock_xsave_dldetect+0x4c>  // b.any
			trace_printf(func, line, TRACE_ERROR, true,
 110b514:	2a1303e5 	mov	w5, w19
 110b518:	aa1903e4 	mov	x4, x25
 110b51c:	2a1803e1 	mov	w1, w24
 110b520:	aa1703e0 	mov	x0, x23
 110b524:	52800023 	mov	w3, #0x1                   	// #1
 110b528:	52800022 	mov	w2, #0x1                   	// #1
 110b52c:	9400e606 	bl	1144d44 <trace_printf>
			if (reminder < UINT_MAX)
 110b530:	3100067f 	cmn	w19, #0x1
 110b534:	54fffc00 	b.eq	110b4b4 <cpu_spin_lock_xsave_dldetect+0x48>  // b.none
				reminder++;
 110b538:	11000673 	add	w19, w19, #0x1
 110b53c:	17ffffde 	b	110b4b4 <cpu_spin_lock_xsave_dldetect+0x48>

000000000110b540 <pfree.isra.0>:
		return nex_calloc(num_el, size);
	else
		return calloc(num_el, size);
}

static void pfree(tee_mm_pool_t *pool, void *ptr)
 110b540:	aa0103e0 	mov	x0, x1
{
	if (pool->flags & TEE_MM_POOL_NEX_MALLOC)
		nex_free(ptr);
 110b544:	1400e027 	b	11435e0 <free>

000000000110b548 <cpu_spin_unlock_xrestore>:
{
 110b548:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 110b54c:	910003fd 	mov	x29, sp
 110b550:	a90153f3 	stp	x19, x20, [sp, #16]
 110b554:	aa0003f4 	mov	x20, x0
 110b558:	2a0103f3 	mov	w19, w1
 110b55c:	97ffe66e 	bl	1104f14 <thread_get_exceptions>
	assert(thread_foreign_intr_disabled());
 110b560:	37080140 	tbnz	w0, #1, 110b588 <cpu_spin_unlock_xrestore+0x40>
 110b564:	f0000223 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 110b568:	d0000221 	adrp	x1, 1151000 <small_prime+0x168>
 110b56c:	913bf063 	add	x3, x3, #0xefc
 110b570:	9111f821 	add	x1, x1, #0x47e
 110b574:	d0000220 	adrp	x0, 1151000 <small_prime+0x168>
 110b578:	91129800 	add	x0, x0, #0x4a6
 110b57c:	52800b82 	mov	w2, #0x5c                  	// #92
 110b580:	94001b4b 	bl	11122ac <_assert_log>
 110b584:	94001b5b 	bl	11122f0 <_assert_break>
	__cpu_spin_unlock(lock);
 110b588:	aa1403e0 	mov	x0, x20
 110b58c:	97ffe3cd 	bl	11044c0 <__cpu_spin_unlock>
	spinlock_count_decr();
 110b590:	97ffe3e0 	bl	1104510 <spinlock_count_decr>
	thread_unmask_exceptions(exceptions);
 110b594:	2a1303e0 	mov	w0, w19
}
 110b598:	a94153f3 	ldp	x19, x20, [sp, #16]
 110b59c:	a8c27bfd 	ldp	x29, x30, [sp], #32
	thread_unmask_exceptions(exceptions);
 110b5a0:	17ffe6f3 	b	110516c <thread_unmask_exceptions>

000000000110b5a4 <update_max_allocated>:
static size_t tee_mm_stats_allocated(tee_mm_pool_t *pool)
{
	tee_mm_entry_t *entry;
	uint32_t sz = 0;

	if (!pool)
 110b5a4:	b4000140 	cbz	x0, 110b5cc <update_max_allocated+0x28>
		return 0;

	entry = pool->entry;
 110b5a8:	f9400002 	ldr	x2, [x0]
	uint32_t sz = 0;
 110b5ac:	52800001 	mov	w1, #0x0                   	// #0
	while (entry) {
 110b5b0:	b5000102 	cbnz	x2, 110b5d0 <update_max_allocated+0x2c>
		sz += entry->size;
		entry = entry->next;
	}

	return sz << pool->shift;
 110b5b4:	39407002 	ldrb	w2, [x0, #28]
 110b5b8:	1ac22021 	lsl	w1, w1, w2

static void update_max_allocated(tee_mm_pool_t *pool)
{
	size_t sz = tee_mm_stats_allocated(pool);

	if (sz > pool->max_allocated)
 110b5bc:	f9401402 	ldr	x2, [x0, #40]
 110b5c0:	eb01005f 	cmp	x2, x1
 110b5c4:	54000042 	b.cs	110b5cc <update_max_allocated+0x28>  // b.hs, b.nlast
		pool->max_allocated = sz;
 110b5c8:	f9001401 	str	x1, [x0, #40]
}
 110b5cc:	d65f03c0 	ret
		sz += entry->size;
 110b5d0:	b9401443 	ldr	w3, [x2, #20]
		entry = entry->next;
 110b5d4:	f9400442 	ldr	x2, [x2, #8]
		sz += entry->size;
 110b5d8:	0b030021 	add	w1, w1, w3
		entry = entry->next;
 110b5dc:	17fffff5 	b	110b5b0 <update_max_allocated+0xc>

000000000110b5e0 <tee_mm_init>:
	if (pool == NULL)
 110b5e0:	b5000100 	cbnz	x0, 110b600 <tee_mm_init+0x20>
		return false;
 110b5e4:	52800000 	mov	w0, #0x0                   	// #0
}
 110b5e8:	d65f03c0 	ret
		return false;
 110b5ec:	52800000 	mov	w0, #0x0                   	// #0
}
 110b5f0:	a94153f3 	ldp	x19, x20, [sp, #16]
 110b5f4:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110b5f8:	a8c37bfd 	ldp	x29, x30, [sp], #48
 110b5fc:	d65f03c0 	ret
{
 110b600:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	lo = ROUNDUP(lo, 1 << shift);
 110b604:	d1000421 	sub	x1, x1, #0x1
{
 110b608:	910003fd 	mov	x29, sp
 110b60c:	a9025bf5 	stp	x21, x22, [sp, #32]
 110b610:	12001c76 	and	w22, w3, #0xff
 110b614:	a90153f3 	stp	x19, x20, [sp, #16]
 110b618:	aa0003f3 	mov	x19, x0
	lo = ROUNDUP(lo, 1 << shift);
 110b61c:	52800020 	mov	w0, #0x1                   	// #1
 110b620:	1ad62000 	lsl	w0, w0, w22
 110b624:	93407c05 	sxtw	x5, w0
 110b628:	8b20c020 	add	x0, x1, w0, sxtw
 110b62c:	cb0503e1 	neg	x1, x5
 110b630:	8a010000 	and	x0, x0, x1
	hi = ROUNDDOWN(hi, 1 << shift);
 110b634:	8a020022 	and	x2, x1, x2
	assert(((uint64_t)(hi - lo) >> shift) < (uint64_t)UINT32_MAX);
 110b638:	cb000054 	sub	x20, x2, x0
 110b63c:	b27f7be1 	mov	x1, #0xfffffffe            	// #4294967294
 110b640:	9ad62683 	lsr	x3, x20, x22
 110b644:	eb01007f 	cmp	x3, x1
 110b648:	54000149 	b.ls	110b670 <tee_mm_init+0x90>  // b.plast
 110b64c:	f0000223 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 110b650:	f0000221 	adrp	x1, 1152000 <trace_ext_prefix+0x2e>
 110b654:	913c3063 	add	x3, x3, #0xf0c
 110b658:	9139dc21 	add	x1, x1, #0xe77
 110b65c:	f0000220 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 110b660:	913a4400 	add	x0, x0, #0xe91
 110b664:	528005e2 	mov	w2, #0x2f                  	// #47
 110b668:	94001b11 	bl	11122ac <_assert_log>
 110b66c:	94001b21 	bl	11122f0 <_assert_break>
	pool->hi = hi;
 110b670:	a9008a60 	stp	x0, x2, [x19, #8]
 110b674:	2a0403f5 	mov	w21, w4
		return nex_calloc(num_el, size);
 110b678:	d2800301 	mov	x1, #0x18                  	// #24
	pool->flags = flags;
 110b67c:	b9001a64 	str	w4, [x19, #24]
		return nex_calloc(num_el, size);
 110b680:	d2800020 	mov	x0, #0x1                   	// #1
	pool->shift = shift;
 110b684:	39007276 	strb	w22, [x19, #28]
		return calloc(num_el, size);
 110b688:	9400df92 	bl	11434d0 <calloc>
	pool->entry = pcalloc(pool, 1, sizeof(tee_mm_entry_t));
 110b68c:	f9000260 	str	x0, [x19]
	if (pool->entry == NULL)
 110b690:	b4fffae0 	cbz	x0, 110b5ec <tee_mm_init+0xc>
	if (pool->flags & TEE_MM_POOL_HI_ALLOC)
 110b694:	360000b5 	tbz	w21, #0, 110b6a8 <tee_mm_init+0xc8>
		pool->entry->offset = ((hi - lo - 1) >> shift) + 1;
 110b698:	d1000694 	sub	x20, x20, #0x1
 110b69c:	9ad62694 	lsr	x20, x20, x22
 110b6a0:	11000694 	add	w20, w20, #0x1
 110b6a4:	b9001014 	str	w20, [x0, #16]
	pool->entry->pool = pool;
 110b6a8:	f9000013 	str	x19, [x0]
	return true;
 110b6ac:	52800020 	mov	w0, #0x1                   	// #1
	pool->lock = SPINLOCK_UNLOCK;
 110b6b0:	b900227f 	str	wzr, [x19, #32]
	return true;
 110b6b4:	17ffffcf 	b	110b5f0 <tee_mm_init+0x10>

000000000110b6b8 <tee_mm_get_pool_stats>:
	if (!pool)
 110b6b8:	b4000520 	cbz	x0, 110b75c <tee_mm_get_pool_stats+0xa4>
{
 110b6bc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 110b6c0:	910003fd 	mov	x29, sp
 110b6c4:	a90153f3 	stp	x19, x20, [sp, #16]
 110b6c8:	aa0003f3 	mov	x19, x0
 110b6cc:	aa0103f4 	mov	x20, x1
	memset(stats, 0, sizeof(*stats));
 110b6d0:	aa1403e0 	mov	x0, x20
 110b6d4:	52800001 	mov	w1, #0x0                   	// #0
{
 110b6d8:	a9025bf5 	stp	x21, x22, [sp, #32]
 110b6dc:	12001c56 	and	w22, w2, #0xff
	exceptions = cpu_spin_lock_xsave(&pool->lock);
 110b6e0:	91008275 	add	x21, x19, #0x20
	memset(stats, 0, sizeof(*stats));
 110b6e4:	d2800702 	mov	x2, #0x38                  	// #56
 110b6e8:	9400e17e 	bl	1143ce0 <memset>
	exceptions = cpu_spin_lock_xsave(&pool->lock);
 110b6ec:	aa1503e2 	mov	x2, x21
 110b6f0:	52800e01 	mov	w1, #0x70                  	// #112
 110b6f4:	f0000220 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 110b6f8:	913c6000 	add	x0, x0, #0xf18
 110b6fc:	97ffff5c 	bl	110b46c <cpu_spin_lock_xsave_dldetect>
 110b700:	2a0003e1 	mov	w1, w0
	stats->size = pool->hi - pool->lo;
 110b704:	a9400a64 	ldp	x4, x2, [x19]
	uint32_t sz = 0;
 110b708:	52800003 	mov	w3, #0x0                   	// #0
	stats->size = pool->hi - pool->lo;
 110b70c:	f9400a60 	ldr	x0, [x19, #16]
 110b710:	4b020000 	sub	w0, w0, w2
 110b714:	b9002a80 	str	w0, [x20, #40]
	stats->max_allocated = pool->max_allocated;
 110b718:	f9401660 	ldr	x0, [x19, #40]
 110b71c:	b9002680 	str	w0, [x20, #36]
	while (entry) {
 110b720:	b5000164 	cbnz	x4, 110b74c <tee_mm_get_pool_stats+0x94>
	return sz << pool->shift;
 110b724:	39407260 	ldrb	w0, [x19, #28]
 110b728:	1ac02063 	lsl	w3, w3, w0
	stats->allocated = tee_mm_stats_allocated(pool);
 110b72c:	b9002283 	str	w3, [x20, #32]
	if (reset)
 110b730:	34000056 	cbz	w22, 110b738 <tee_mm_get_pool_stats+0x80>
		pool->max_allocated = 0;
 110b734:	f900167f 	str	xzr, [x19, #40]
	cpu_spin_unlock_xrestore(&pool->lock, exceptions);
 110b738:	aa1503e0 	mov	x0, x21
}
 110b73c:	a94153f3 	ldp	x19, x20, [sp, #16]
 110b740:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110b744:	a8c37bfd 	ldp	x29, x30, [sp], #48
	cpu_spin_unlock_xrestore(&pool->lock, exceptions);
 110b748:	17ffff80 	b	110b548 <cpu_spin_unlock_xrestore>
		sz += entry->size;
 110b74c:	b9401480 	ldr	w0, [x4, #20]
		entry = entry->next;
 110b750:	f9400484 	ldr	x4, [x4, #8]
		sz += entry->size;
 110b754:	0b000063 	add	w3, w3, w0
		entry = entry->next;
 110b758:	17fffff2 	b	110b720 <tee_mm_get_pool_stats+0x68>
 110b75c:	d65f03c0 	ret

000000000110b760 <tee_mm_alloc>:
{
}
#endif /* CFG_WITH_STATS */

tee_mm_entry_t *tee_mm_alloc(tee_mm_pool_t *pool, size_t size)
{
 110b760:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 110b764:	910003fd 	mov	x29, sp
 110b768:	a90153f3 	stp	x19, x20, [sp, #16]
 110b76c:	a9025bf5 	stp	x21, x22, [sp, #32]
 110b770:	f9001bf7 	str	x23, [sp, #48]
	tee_mm_entry_t *nn;
	size_t remaining;
	uint32_t exceptions;

	/* Check that pool is initialized */
	if (!pool || !pool->entry)
 110b774:	b5000100 	cbnz	x0, 110b794 <tee_mm_alloc+0x34>
		return NULL;
 110b778:	d2800016 	mov	x22, #0x0                   	// #0
	return nn;
err:
	cpu_spin_unlock_xrestore(&pool->lock, exceptions);
	pfree(pool, nn);
	return NULL;
}
 110b77c:	aa1603e0 	mov	x0, x22
 110b780:	a94153f3 	ldp	x19, x20, [sp, #16]
 110b784:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110b788:	f9401bf7 	ldr	x23, [sp, #48]
 110b78c:	a8c47bfd 	ldp	x29, x30, [sp], #64
 110b790:	d65f03c0 	ret
 110b794:	aa0003f3 	mov	x19, x0
	if (!pool || !pool->entry)
 110b798:	f9400000 	ldr	x0, [x0]
 110b79c:	b4fffee0 	cbz	x0, 110b778 <tee_mm_alloc+0x18>
 110b7a0:	aa0103f5 	mov	x21, x1
		return malloc(size);
 110b7a4:	d2800300 	mov	x0, #0x18                  	// #24
 110b7a8:	9400df2c 	bl	1143458 <malloc>
 110b7ac:	aa0003f4 	mov	x20, x0
	if (!nn)
 110b7b0:	b4fffe40 	cbz	x0, 110b778 <tee_mm_alloc+0x18>
	exceptions = cpu_spin_lock_xsave(&pool->lock);
 110b7b4:	91008277 	add	x23, x19, #0x20
 110b7b8:	f0000236 	adrp	x22, 1152000 <trace_ext_prefix+0x2e>
 110b7bc:	aa1703e2 	mov	x2, x23
 110b7c0:	913cbac0 	add	x0, x22, #0xf2e
 110b7c4:	52801301 	mov	w1, #0x98                  	// #152
 110b7c8:	97ffff29 	bl	110b46c <cpu_spin_lock_xsave_dldetect>
 110b7cc:	2a0003e7 	mov	w7, w0
	entry = pool->entry;
 110b7d0:	aa1603e0 	mov	x0, x22
 110b7d4:	f9400265 	ldr	x5, [x19]
	if (size == 0)
 110b7d8:	b4000415 	cbz	x21, 110b858 <tee_mm_alloc+0xf8>
		psize = ((size - 1) >> pool->shift) + 1;
 110b7dc:	39407261 	ldrb	w1, [x19, #28]
 110b7e0:	d10006a4 	sub	x4, x21, #0x1
 110b7e4:	9ac12484 	lsr	x4, x4, x1
 110b7e8:	91000484 	add	x4, x4, #0x1
	if (pool->flags & TEE_MM_POOL_HI_ALLOC) {
 110b7ec:	b9401a61 	ldr	w1, [x19, #24]
 110b7f0:	12000028 	and	w8, w1, #0x1
 110b7f4:	36000361 	tbz	w1, #0, 110b860 <tee_mm_alloc+0x100>
		while (entry->next != NULL && psize >
 110b7f8:	aa0503e3 	mov	x3, x5
 110b7fc:	f94004a5 	ldr	x5, [x5, #8]
 110b800:	b40000e5 	cbz	x5, 110b81c <tee_mm_alloc+0xbc>
		       (entry->offset - entry->next->offset -
 110b804:	294208a1 	ldp	w1, w2, [x5, #16]
 110b808:	0b020022 	add	w2, w1, w2
 110b80c:	b9401061 	ldr	w1, [x3, #16]
 110b810:	4b020021 	sub	w1, w1, w2
		while (entry->next != NULL && psize >
 110b814:	eb04003f 	cmp	x1, x4
 110b818:	54ffff03 	b.cc	110b7f8 <tee_mm_alloc+0x98>  // b.lo, b.ul, b.last
	if (entry->next == NULL) {
 110b81c:	f9400476 	ldr	x22, [x3, #8]
 110b820:	b50005b6 	cbnz	x22, 110b8d4 <tee_mm_alloc+0x174>
		if (pool->flags & TEE_MM_POOL_HI_ALLOC) {
 110b824:	34000348 	cbz	w8, 110b88c <tee_mm_alloc+0x12c>
			if ((entry->offset << pool->shift) < size) {
 110b828:	39407261 	ldrb	w1, [x19, #28]
 110b82c:	b9401060 	ldr	w0, [x3, #16]
 110b830:	1ac12000 	lsl	w0, w0, w1
 110b834:	eb15001f 	cmp	x0, x21
 110b838:	540004e2 	b.cs	110b8d4 <tee_mm_alloc+0x174>  // b.hs, b.nlast
	cpu_spin_unlock_xrestore(&pool->lock, exceptions);
 110b83c:	2a0703e1 	mov	w1, w7
 110b840:	aa1703e0 	mov	x0, x23
 110b844:	97ffff41 	bl	110b548 <cpu_spin_unlock_xrestore>
	pfree(pool, nn);
 110b848:	b9401a60 	ldr	w0, [x19, #24]
 110b84c:	aa1403e1 	mov	x1, x20
 110b850:	97ffff3c 	bl	110b540 <pfree.isra.0>
	return NULL;
 110b854:	17ffffca 	b	110b77c <tee_mm_alloc+0x1c>
		psize = 0;
 110b858:	d2800004 	mov	x4, #0x0                   	// #0
 110b85c:	17ffffe4 	b	110b7ec <tee_mm_alloc+0x8c>
		while (entry->next != NULL && psize >
 110b860:	aa0503e3 	mov	x3, x5
 110b864:	f94004a5 	ldr	x5, [x5, #8]
 110b868:	b4fffda5 	cbz	x5, 110b81c <tee_mm_alloc+0xbc>
		       (entry->next->offset - entry->size - entry->offset))
 110b86c:	b9401461 	ldr	w1, [x3, #20]
 110b870:	b94010a6 	ldr	w6, [x5, #16]
 110b874:	4b0100c6 	sub	w6, w6, w1
 110b878:	b9401061 	ldr	w1, [x3, #16]
 110b87c:	4b0100c6 	sub	w6, w6, w1
		while (entry->next != NULL && psize >
 110b880:	eb0400df 	cmp	x6, x4
 110b884:	54fffee3 	b.cc	110b860 <tee_mm_alloc+0x100>  // b.lo, b.ul, b.last
 110b888:	17ffffe5 	b	110b81c <tee_mm_alloc+0xbc>
			if (pool->hi <= pool->lo)
 110b88c:	a9409661 	ldp	x1, x5, [x19, #8]
 110b890:	eb0100bf 	cmp	x5, x1
 110b894:	54000108 	b.hi	110b8b4 <tee_mm_alloc+0x154>  // b.pmore
				panic("invalid pool");
 110b898:	913cb802 	add	x2, x0, #0xf2e
 110b89c:	f0000223 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 110b8a0:	f0000220 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 110b8a4:	913b1c63 	add	x3, x3, #0xec7
 110b8a8:	9139dc00 	add	x0, x0, #0xe77
 110b8ac:	528017c1 	mov	w1, #0xbe                  	// #190
 110b8b0:	94001eee 	bl	1113468 <__do_panic>
			remaining -= ((entry->offset + entry->size) <<
 110b8b4:	29420066 	ldp	w6, w0, [x3, #16]
			remaining = (pool->hi - pool->lo);
 110b8b8:	cb0100a5 	sub	x5, x5, x1
			remaining -= ((entry->offset + entry->size) <<
 110b8bc:	0b0000c6 	add	w6, w6, w0
				      pool->shift);
 110b8c0:	39407260 	ldrb	w0, [x19, #28]
			remaining -= ((entry->offset + entry->size) <<
 110b8c4:	1ac020c6 	lsl	w6, w6, w0
 110b8c8:	cb0600a5 	sub	x5, x5, x6
			if (remaining < size) {
 110b8cc:	eb0502bf 	cmp	x21, x5
 110b8d0:	54fffb68 	b.hi	110b83c <tee_mm_alloc+0xdc>  // b.pmore
	nn->next = p->next;
 110b8d4:	b9401065 	ldr	w5, [x3, #16]
 110b8d8:	2a0403e0 	mov	w0, w4
 110b8dc:	f9000696 	str	x22, [x20, #8]
	p->next = nn;
 110b8e0:	f9000474 	str	x20, [x3, #8]
	if (pool->flags & TEE_MM_POOL_HI_ALLOC)
 110b8e4:	34000168 	cbz	w8, 110b910 <tee_mm_alloc+0x1b0>
		nn->offset = entry->offset - psize;
 110b8e8:	4b0400a4 	sub	w4, w5, w4
	nn->pool = pool;
 110b8ec:	f9000293 	str	x19, [x20]
	return nn;
 110b8f0:	aa1403f6 	mov	x22, x20
	nn->size = psize;
 110b8f4:	29020284 	stp	w4, w0, [x20, #16]
	update_max_allocated(pool);
 110b8f8:	aa1303e0 	mov	x0, x19
 110b8fc:	97ffff2a 	bl	110b5a4 <update_max_allocated>
	cpu_spin_unlock_xrestore(&pool->lock, exceptions);
 110b900:	2a0703e1 	mov	w1, w7
 110b904:	aa1703e0 	mov	x0, x23
 110b908:	97ffff10 	bl	110b548 <cpu_spin_unlock_xrestore>
	return nn;
 110b90c:	17ffff9c 	b	110b77c <tee_mm_alloc+0x1c>
		nn->offset = entry->offset + entry->size;
 110b910:	b9401464 	ldr	w4, [x3, #20]
 110b914:	0b0400a4 	add	w4, w5, w4
 110b918:	17fffff5 	b	110b8ec <tee_mm_alloc+0x18c>

000000000110b91c <tee_mm_free>:
void tee_mm_free(tee_mm_entry_t *p)
{
	tee_mm_entry_t *entry;
	uint32_t exceptions;

	if (!p || !p->pool)
 110b91c:	b4000560 	cbz	x0, 110b9c8 <tee_mm_free+0xac>
{
 110b920:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 110b924:	910003fd 	mov	x29, sp
	if (!p || !p->pool)
 110b928:	f9400002 	ldr	x2, [x0]
{
 110b92c:	a90153f3 	stp	x19, x20, [sp, #16]
 110b930:	aa0003f4 	mov	x20, x0
 110b934:	f90013f5 	str	x21, [sp, #32]
	if (!p || !p->pool)
 110b938:	b4000402 	cbz	x2, 110b9b8 <tee_mm_free+0x9c>
		return;

	exceptions = cpu_spin_lock_xsave(&p->pool->lock);
 110b93c:	52802641 	mov	w1, #0x132                 	// #306
 110b940:	91008042 	add	x2, x2, #0x20
 110b944:	f0000235 	adrp	x21, 1152000 <trace_ext_prefix+0x2e>
 110b948:	913ceea0 	add	x0, x21, #0xf3b
 110b94c:	97fffec8 	bl	110b46c <cpu_spin_lock_xsave_dldetect>
 110b950:	2a0003e1 	mov	w1, w0
	entry = p->pool->entry;
 110b954:	f9400280 	ldr	x0, [x20]
 110b958:	f9400013 	ldr	x19, [x0]

	/* remove entry from list */
	while (entry->next != NULL && entry->next != p)
 110b95c:	aa1303e2 	mov	x2, x19
 110b960:	f9400673 	ldr	x19, [x19, #8]
 110b964:	b40001d3 	cbz	x19, 110b99c <tee_mm_free+0x80>
 110b968:	eb14027f 	cmp	x19, x20
 110b96c:	54ffff81 	b.ne	110b95c <tee_mm_free+0x40>  // b.any
		entry = entry->next;

	if (!entry->next)
		panic("invalid mm_entry");

	entry->next = entry->next->next;
 110b970:	f9400663 	ldr	x3, [x19, #8]
 110b974:	f9000443 	str	x3, [x2, #8]
	cpu_spin_unlock_xrestore(&p->pool->lock, exceptions);
 110b978:	91008000 	add	x0, x0, #0x20
 110b97c:	97fffef3 	bl	110b548 <cpu_spin_unlock_xrestore>

	pfree(p->pool, p);
 110b980:	f9400260 	ldr	x0, [x19]
 110b984:	aa1303e1 	mov	x1, x19
}
 110b988:	a94153f3 	ldp	x19, x20, [sp, #16]
 110b98c:	f94013f5 	ldr	x21, [sp, #32]
 110b990:	a8c37bfd 	ldp	x29, x30, [sp], #48
	pfree(p->pool, p);
 110b994:	b9401800 	ldr	w0, [x0, #24]
 110b998:	17fffeea 	b	110b540 <pfree.isra.0>
		panic("invalid mm_entry");
 110b99c:	f0000223 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 110b9a0:	f0000220 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 110b9a4:	913b5063 	add	x3, x3, #0xed4
 110b9a8:	913ceea2 	add	x2, x21, #0xf3b
 110b9ac:	9139dc00 	add	x0, x0, #0xe77
 110b9b0:	52802741 	mov	w1, #0x13a                 	// #314
 110b9b4:	94001ead 	bl	1113468 <__do_panic>
}
 110b9b8:	a94153f3 	ldp	x19, x20, [sp, #16]
 110b9bc:	f94013f5 	ldr	x21, [sp, #32]
 110b9c0:	a8c37bfd 	ldp	x29, x30, [sp], #48
 110b9c4:	d65f03c0 	ret
 110b9c8:	d65f03c0 	ret

000000000110b9cc <tee_mm_final>:
	if (pool == NULL || pool->entry == NULL)
 110b9cc:	b4000240 	cbz	x0, 110ba14 <tee_mm_final+0x48>
{
 110b9d0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 110b9d4:	910003fd 	mov	x29, sp
 110b9d8:	f9000bf3 	str	x19, [sp, #16]
 110b9dc:	aa0003f3 	mov	x19, x0
	if (pool == NULL || pool->entry == NULL)
 110b9e0:	f9400000 	ldr	x0, [x0]
 110b9e4:	b50000a0 	cbnz	x0, 110b9f8 <tee_mm_final+0x2c>
}
 110b9e8:	f9400bf3 	ldr	x19, [sp, #16]
 110b9ec:	a8c27bfd 	ldp	x29, x30, [sp], #32
 110b9f0:	d65f03c0 	ret
		tee_mm_free(pool->entry->next);
 110b9f4:	97ffffca 	bl	110b91c <tee_mm_free>
	while (pool->entry->next != NULL)
 110b9f8:	f9400261 	ldr	x1, [x19]
 110b9fc:	f9400420 	ldr	x0, [x1, #8]
 110ba00:	b5ffffa0 	cbnz	x0, 110b9f4 <tee_mm_final+0x28>
	pfree(pool, pool->entry);
 110ba04:	b9401a60 	ldr	w0, [x19, #24]
 110ba08:	97fffece 	bl	110b540 <pfree.isra.0>
	pool->entry = NULL;
 110ba0c:	f900027f 	str	xzr, [x19]
 110ba10:	17fffff6 	b	110b9e8 <tee_mm_final+0x1c>
 110ba14:	d65f03c0 	ret

000000000110ba18 <tee_mm_is_empty>:
{
	return (pool && ((addr >= pool->lo) && (addr <= pool->hi)));
}

bool tee_mm_is_empty(tee_mm_pool_t *pool)
{
 110ba18:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 110ba1c:	910003fd 	mov	x29, sp
 110ba20:	a90153f3 	stp	x19, x20, [sp, #16]
	bool ret;
	uint32_t exceptions;

	if (pool == NULL || pool->entry == NULL)
 110ba24:	b4000300 	cbz	x0, 110ba84 <tee_mm_is_empty+0x6c>
 110ba28:	aa0003f3 	mov	x19, x0
 110ba2c:	f9400000 	ldr	x0, [x0]
 110ba30:	b40002a0 	cbz	x0, 110ba84 <tee_mm_is_empty+0x6c>
		return true;

	exceptions = cpu_spin_lock_xsave(&pool->lock);
 110ba34:	91008274 	add	x20, x19, #0x20
 110ba38:	52802ae1 	mov	w1, #0x157                 	// #343
 110ba3c:	aa1403e2 	mov	x2, x20
 110ba40:	f0000220 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 110ba44:	913d1c00 	add	x0, x0, #0xf47
 110ba48:	97fffe89 	bl	110b46c <cpu_spin_lock_xsave_dldetect>
 110ba4c:	2a0003e1 	mov	w1, w0
	ret = pool->entry == NULL || pool->entry->next == NULL;
 110ba50:	f9400260 	ldr	x0, [x19]
 110ba54:	b4000140 	cbz	x0, 110ba7c <tee_mm_is_empty+0x64>
 110ba58:	f9400400 	ldr	x0, [x0, #8]
 110ba5c:	f100001f 	cmp	x0, #0x0
 110ba60:	1a9f17f3 	cset	w19, eq  // eq = none
	cpu_spin_unlock_xrestore(&pool->lock, exceptions);
 110ba64:	aa1403e0 	mov	x0, x20
 110ba68:	97fffeb8 	bl	110b548 <cpu_spin_unlock_xrestore>

	return ret;
}
 110ba6c:	2a1303e0 	mov	w0, w19
 110ba70:	a94153f3 	ldp	x19, x20, [sp, #16]
 110ba74:	a8c27bfd 	ldp	x29, x30, [sp], #32
 110ba78:	d65f03c0 	ret
	ret = pool->entry == NULL || pool->entry->next == NULL;
 110ba7c:	52800033 	mov	w19, #0x1                   	// #1
 110ba80:	17fffff9 	b	110ba64 <tee_mm_is_empty+0x4c>
		return true;
 110ba84:	52800033 	mov	w19, #0x1                   	// #1
 110ba88:	17fffff9 	b	110ba6c <tee_mm_is_empty+0x54>

000000000110ba8c <tee_mm_get_smem>:
	return NULL;
}

uintptr_t tee_mm_get_smem(const tee_mm_entry_t *mm)
{
	return (mm->offset << mm->pool->shift) + mm->pool->lo;
 110ba8c:	f9400001 	ldr	x1, [x0]
 110ba90:	b9401000 	ldr	w0, [x0, #16]
 110ba94:	39407022 	ldrb	w2, [x1, #28]
 110ba98:	f9400421 	ldr	x1, [x1, #8]
 110ba9c:	1ac22000 	lsl	w0, w0, w2
}
 110baa0:	8b010000 	add	x0, x0, x1
 110baa4:	d65f03c0 	ret

000000000110baa8 <pgt_free_unlocked.isra.0>:
	mutex_unlock(&pgt_mu);
}

#else /*!CFG_PAGED_USER_TA*/

static void pgt_free_unlocked(struct pgt_cache *pgt_cache,
 110baa8:	d0000281 	adrp	x1, 115d000 <_curve_names+0x590>
 110baac:	52800004 	mov	w4, #0x0                   	// #0
 110bab0:	f9477423 	ldr	x3, [x1, #3816]
			      bool save_ctx __unused)
{
	while (!SLIST_EMPTY(pgt_cache)) {
 110bab4:	f9400002 	ldr	x2, [x0]
 110bab8:	b5000082 	cbnz	x2, 110bac8 <pgt_free_unlocked.isra.0+0x20>
 110babc:	34000044 	cbz	w4, 110bac4 <pgt_free_unlocked.isra.0+0x1c>
 110bac0:	f9077423 	str	x3, [x1, #3816]
		struct pgt *p = SLIST_FIRST(pgt_cache);

		SLIST_REMOVE_HEAD(pgt_cache, link);
		push_to_free_list(p);
	}
}
 110bac4:	d65f03c0 	ret
		SLIST_REMOVE_HEAD(pgt_cache, link);
 110bac8:	f9400844 	ldr	x4, [x2, #16]
 110bacc:	f9000004 	str	x4, [x0]
}
 110bad0:	52800024 	mov	w4, #0x1                   	// #1
	SLIST_INSERT_HEAD(&pgt_free_list, p, link);
 110bad4:	f9000843 	str	x3, [x2, #16]
}
 110bad8:	aa0203e3 	mov	x3, x2
 110badc:	17fffff6 	b	110bab4 <pgt_free_unlocked.isra.0+0xc>

000000000110bae0 <pgt_init>:
		p->tbl = pgt_tables[n];
 110bae0:	d0000282 	adrp	x2, 115d000 <_curve_names+0x590>
 110bae4:	d00003c1 	adrp	x1, 1185000 <pgt_tables.3403>
 110bae8:	913a2040 	add	x0, x2, #0xe88
 110baec:	91000021 	add	x1, x1, #0x0
 110baf0:	f9074441 	str	x1, [x2, #3720]
		SLIST_INSERT_HEAD(&pgt_free_list, p, link);
 110baf4:	d0000282 	adrp	x2, 115d000 <_curve_names+0x590>
 110baf8:	f9477441 	ldr	x1, [x2, #3816]
 110bafc:	f9000801 	str	x1, [x0, #16]
		p->tbl = pgt_tables[n];
 110bb00:	f00003c1 	adrp	x1, 1186000 <pgt_tables.3403+0x1000>
 110bb04:	91000021 	add	x1, x1, #0x0
 110bb08:	f9000c01 	str	x1, [x0, #24]
 110bb0c:	900003e1 	adrp	x1, 1187000 <pgt_tables.3403+0x2000>
 110bb10:	91000021 	add	x1, x1, #0x0
 110bb14:	f9001801 	str	x1, [x0, #48]
		SLIST_INSERT_HEAD(&pgt_free_list, p, link);
 110bb18:	91006001 	add	x1, x0, #0x18
 110bb1c:	f9002001 	str	x1, [x0, #64]
		p->tbl = pgt_tables[n];
 110bb20:	b00003e1 	adrp	x1, 1188000 <pgt_tables.3403+0x3000>
 110bb24:	91000021 	add	x1, x1, #0x0
		SLIST_INSERT_HEAD(&pgt_free_list, p, link);
 110bb28:	f9001400 	str	x0, [x0, #40]
		p->tbl = pgt_tables[n];
 110bb2c:	f9002401 	str	x1, [x0, #72]
		SLIST_INSERT_HEAD(&pgt_free_list, p, link);
 110bb30:	9100c001 	add	x1, x0, #0x30
 110bb34:	91012000 	add	x0, x0, #0x48
 110bb38:	f9000801 	str	x1, [x0, #16]
 110bb3c:	f9077440 	str	x0, [x2, #3816]
}
 110bb40:	d65f03c0 	ret

000000000110bb44 <pgt_clear_ctx_range>:
	}
}

void pgt_clear_ctx_range(struct pgt_cache *pgt_cache, struct ts_ctx *ctx,
			 vaddr_t begin, vaddr_t end)
{
 110bb44:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 110bb48:	910003fd 	mov	x29, sp
 110bb4c:	a90153f3 	stp	x19, x20, [sp, #16]
 110bb50:	aa0203f4 	mov	x20, x2
 110bb54:	a9025bf5 	stp	x21, x22, [sp, #32]
	mutex_lock(&pgt_mu);
 110bb58:	d0000296 	adrp	x22, 115d000 <_curve_names+0x590>
{
 110bb5c:	aa0303f5 	mov	x21, x3
 110bb60:	f9001bf7 	str	x23, [sp, #48]
 110bb64:	aa0003f7 	mov	x23, x0
	mutex_lock(&pgt_mu);
 110bb68:	913bc2c0 	add	x0, x22, #0xef0
 110bb6c:	9400267a 	bl	1115554 <mutex_lock>

	if (pgt_cache)
 110bb70:	b50000f7 	cbnz	x23, 110bb8c <pgt_clear_ctx_range+0x48>
		clear_ctx_range_from_list(pgt_cache, ctx, begin, end);
#ifdef CFG_PAGED_USER_TA
	clear_ctx_range_from_list(&pgt_cache_list, ctx, begin, end);
#endif

	mutex_unlock(&pgt_mu);
 110bb74:	913bc2c0 	add	x0, x22, #0xef0
}
 110bb78:	a94153f3 	ldp	x19, x20, [sp, #16]
 110bb7c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110bb80:	f9401bf7 	ldr	x23, [sp, #48]
 110bb84:	a8c47bfd 	ldp	x29, x30, [sp], #64
	mutex_unlock(&pgt_mu);
 110bb88:	14002652 	b	11154d0 <mutex_unlock>
		clear_ctx_range_from_list(pgt_cache, ctx, begin, end);
 110bb8c:	f94002f3 	ldr	x19, [x23]
	SLIST_FOREACH(p, pgt_cache, link) {
 110bb90:	b4ffff33 	cbz	x19, 110bb74 <pgt_clear_ctx_range+0x30>
		vaddr_t b = MAX(p->vabase, begin);
 110bb94:	f9400662 	ldr	x2, [x19, #8]
 110bb98:	eb02029f 	cmp	x20, x2
		vaddr_t e = MIN(p->vabase + CORE_MMU_PGDIR_SIZE, end);
 110bb9c:	91480041 	add	x1, x2, #0x200, lsl #12
		vaddr_t b = MAX(p->vabase, begin);
 110bba0:	9a822280 	csel	x0, x20, x2, cs  // cs = hs, nlast
		vaddr_t e = MIN(p->vabase + CORE_MMU_PGDIR_SIZE, end);
 110bba4:	eb15003f 	cmp	x1, x21
 110bba8:	9a959021 	csel	x1, x1, x21, ls  // ls = plast
		if (b >= e)
 110bbac:	eb01001f 	cmp	x0, x1
 110bbb0:	54000142 	b.cs	110bbd8 <pgt_clear_ctx_range+0x94>  // b.hs, b.nlast
		n = (e - b) / SMALL_PAGE_SIZE;
 110bbb4:	cb000021 	sub	x1, x1, x0
		idx = (b - p->vabase) / SMALL_PAGE_SIZE;
 110bbb8:	cb020000 	sub	x0, x0, x2
		memset(tbl + idx, 0, n * sizeof(*tbl));
 110bbbc:	f9400263 	ldr	x3, [x19]
 110bbc0:	d34cac21 	ubfx	x1, x1, #12, #32
 110bbc4:	d34cac00 	ubfx	x0, x0, #12, #32
 110bbc8:	d37df022 	lsl	x2, x1, #3
 110bbcc:	52800001 	mov	w1, #0x0                   	// #0
 110bbd0:	8b000c60 	add	x0, x3, x0, lsl #3
 110bbd4:	9400e043 	bl	1143ce0 <memset>
	SLIST_FOREACH(p, pgt_cache, link) {
 110bbd8:	f9400a73 	ldr	x19, [x19, #16]
 110bbdc:	17ffffed 	b	110bb90 <pgt_clear_ctx_range+0x4c>

000000000110bbe0 <pgt_alloc>:
}

void pgt_alloc(struct pgt_cache *pgt_cache, struct ts_ctx *ctx,
	       vaddr_t begin, vaddr_t last)
{
	if (last <= begin)
 110bbe0:	eb02007f 	cmp	x3, x2
 110bbe4:	54000969 	b.ls	110bd10 <pgt_alloc+0x130>  // b.plast
{
 110bbe8:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
 110bbec:	910003fd 	mov	x29, sp
 110bbf0:	a9025bf5 	stp	x21, x22, [sp, #32]
 110bbf4:	aa0203f5 	mov	x21, x2
	const vaddr_t base = ROUNDDOWN(begin, CORE_MMU_PGDIR_SIZE);
 110bbf8:	926baab5 	and	x21, x21, #0xffffffffffe00000
{
 110bbfc:	a90153f3 	stp	x19, x20, [sp, #16]
 110bc00:	aa0303f4 	mov	x20, x3
	const size_t num_tbls = ((last - base) >> CORE_MMU_PGDIR_SHIFT) + 1;
 110bc04:	cb150294 	sub	x20, x20, x21
{
 110bc08:	a9046bf9 	stp	x25, x26, [sp, #64]

	mutex_lock(&pgt_mu);

	pgt_free_unlocked(pgt_cache, ctx);
	while (!pgt_alloc_unlocked(pgt_cache, ctx, begin, last)) {
		DMSG("Waiting for page tables");
 110bc0c:	f000023a 	adrp	x26, 1152000 <trace_ext_prefix+0x2e>
	const size_t num_tbls = ((last - base) >> CORE_MMU_PGDIR_SHIFT) + 1;
 110bc10:	d355fe94 	lsr	x20, x20, #21
		DMSG("Waiting for page tables");
 110bc14:	f0000239 	adrp	x25, 1152000 <trace_ext_prefix+0x2e>
	const size_t num_tbls = ((last - base) >> CORE_MMU_PGDIR_SHIFT) + 1;
 110bc18:	91000694 	add	x20, x20, #0x1
		DMSG("Waiting for page tables");
 110bc1c:	913d5f5a 	add	x26, x26, #0xf57
 110bc20:	913dbf39 	add	x25, x25, #0xf6f
 110bc24:	aa0003f6 	mov	x22, x0
{
 110bc28:	a90363f7 	stp	x23, x24, [sp, #48]
	mutex_lock(&pgt_mu);
 110bc2c:	d0000297 	adrp	x23, 115d000 <_curve_names+0x590>
 110bc30:	913bc2e0 	add	x0, x23, #0xef0
{
 110bc34:	a90573fb 	stp	x27, x28, [sp, #80]
	mutex_lock(&pgt_mu);
 110bc38:	94002647 	bl	1115554 <mutex_lock>
	pgt_free_unlocked(pgt_cache, ctx);
 110bc3c:	aa1603e0 	mov	x0, x22
 110bc40:	97ffff9a 	bl	110baa8 <pgt_free_unlocked.isra.0>
	struct pgt *pp = NULL;
 110bc44:	d2800013 	mov	x19, #0x0                   	// #0
	size_t n = 0;
 110bc48:	d2800018 	mov	x24, #0x0                   	// #0
	struct pgt *p = SLIST_FIRST(&pgt_free_list);
 110bc4c:	d000029c 	adrp	x28, 115d000 <_curve_names+0x590>
		p = pop_from_some_list(base + n * CORE_MMU_PGDIR_SIZE, ctx);
 110bc50:	aa1303fb 	mov	x27, x19
 110bc54:	8b1856a3 	add	x3, x21, x24, lsl #21
	struct pgt *p = SLIST_FIRST(&pgt_free_list);
 110bc58:	f9477793 	ldr	x19, [x28, #3816]
 110bc5c:	f90037e3 	str	x3, [sp, #104]
	if (p) {
 110bc60:	b4000393 	cbz	x19, 110bcd0 <pgt_alloc+0xf0>
		SLIST_REMOVE_HEAD(&pgt_free_list, link);
 110bc64:	f9400a60 	ldr	x0, [x19, #16]
 110bc68:	f9077780 	str	x0, [x28, #3816]
		memset(p->tbl, 0, PGT_SIZE);
 110bc6c:	f9400260 	ldr	x0, [x19]
 110bc70:	d2820002 	mov	x2, #0x1000                	// #4096
 110bc74:	52800001 	mov	w1, #0x0                   	// #0
 110bc78:	9400e01a 	bl	1143ce0 <memset>
		p->vabase = vabase;
 110bc7c:	f94037e3 	ldr	x3, [sp, #104]
 110bc80:	f9000663 	str	x3, [x19, #8]
		if (pp)
 110bc84:	b40001fb 	cbz	x27, 110bcc0 <pgt_alloc+0xe0>
			SLIST_INSERT_AFTER(pp, p, link);
 110bc88:	f9400b60 	ldr	x0, [x27, #16]
 110bc8c:	f9000a60 	str	x0, [x19, #16]
 110bc90:	f9000b73 	str	x19, [x27, #16]
		n++;
 110bc94:	91000718 	add	x24, x24, #0x1
	while (n < num_tbls) {
 110bc98:	eb18029f 	cmp	x20, x24
 110bc9c:	54fffda8 	b.hi	110bc50 <pgt_alloc+0x70>  // b.pmore
		condvar_broadcast(&pgt_cv);
		condvar_wait(&pgt_cv, &pgt_mu);
	}

	mutex_unlock(&pgt_mu);
 110bca0:	913bc2e0 	add	x0, x23, #0xef0
}
 110bca4:	a94153f3 	ldp	x19, x20, [sp, #16]
 110bca8:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110bcac:	a94363f7 	ldp	x23, x24, [sp, #48]
 110bcb0:	a9446bf9 	ldp	x25, x26, [sp, #64]
 110bcb4:	a94573fb 	ldp	x27, x28, [sp, #80]
 110bcb8:	a8c77bfd 	ldp	x29, x30, [sp], #112
	mutex_unlock(&pgt_mu);
 110bcbc:	14002605 	b	11154d0 <mutex_unlock>
			SLIST_INSERT_HEAD(pgt_cache, p, link);
 110bcc0:	f94002c0 	ldr	x0, [x22]
 110bcc4:	f9000a60 	str	x0, [x19, #16]
 110bcc8:	f90002d3 	str	x19, [x22]
 110bccc:	17fffff2 	b	110bc94 <pgt_alloc+0xb4>
			pgt_free_unlocked(pgt_cache, ctx);
 110bcd0:	aa1603e0 	mov	x0, x22
 110bcd4:	97ffff75 	bl	110baa8 <pgt_free_unlocked.isra.0>
		DMSG("Waiting for page tables");
 110bcd8:	aa1a03e4 	mov	x4, x26
 110bcdc:	52800023 	mov	w3, #0x1                   	// #1
 110bce0:	52800062 	mov	w2, #0x3                   	// #3
 110bce4:	52803fc1 	mov	w1, #0x1fe                 	// #510
 110bce8:	aa1903e0 	mov	x0, x25
		condvar_broadcast(&pgt_cv);
 110bcec:	d0000293 	adrp	x19, 115d000 <_curve_names+0x590>
		DMSG("Waiting for page tables");
 110bcf0:	9400e415 	bl	1144d44 <trace_printf>
		condvar_broadcast(&pgt_cv);
 110bcf4:	9139e273 	add	x19, x19, #0xe78
 110bcf8:	aa1303e0 	mov	x0, x19
 110bcfc:	94002731 	bl	11159c0 <condvar_broadcast>
		condvar_wait(&pgt_cv, &pgt_mu);
 110bd00:	913bc2e1 	add	x1, x23, #0xef0
 110bd04:	aa1303e0 	mov	x0, x19
 110bd08:	94002730 	bl	11159c8 <condvar_wait>
 110bd0c:	17ffffce 	b	110bc44 <pgt_alloc+0x64>
 110bd10:	d65f03c0 	ret

000000000110bd14 <pgt_free>:

void pgt_free(struct pgt_cache *pgt_cache, bool save_ctx)
{
 110bd14:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 110bd18:	910003fd 	mov	x29, sp
 110bd1c:	a90153f3 	stp	x19, x20, [sp, #16]
 110bd20:	aa0003f4 	mov	x20, x0
	if (SLIST_EMPTY(pgt_cache))
 110bd24:	f9400000 	ldr	x0, [x0]
 110bd28:	b40001c0 	cbz	x0, 110bd60 <pgt_free+0x4c>
		return;

	mutex_lock(&pgt_mu);
 110bd2c:	d0000293 	adrp	x19, 115d000 <_curve_names+0x590>
 110bd30:	913bc273 	add	x19, x19, #0xef0
 110bd34:	aa1303e0 	mov	x0, x19
 110bd38:	94002607 	bl	1115554 <mutex_lock>

	pgt_free_unlocked(pgt_cache, save_ctx);
 110bd3c:	aa1403e0 	mov	x0, x20
 110bd40:	97ffff5a 	bl	110baa8 <pgt_free_unlocked.isra.0>

	condvar_broadcast(&pgt_cv);
 110bd44:	d0000280 	adrp	x0, 115d000 <_curve_names+0x590>
 110bd48:	9139e000 	add	x0, x0, #0xe78
 110bd4c:	9400271d 	bl	11159c0 <condvar_broadcast>
	mutex_unlock(&pgt_mu);
 110bd50:	aa1303e0 	mov	x0, x19
}
 110bd54:	a94153f3 	ldp	x19, x20, [sp, #16]
 110bd58:	a8c27bfd 	ldp	x29, x30, [sp], #32
	mutex_unlock(&pgt_mu);
 110bd5c:	140025dd 	b	11154d0 <mutex_unlock>
}
 110bd60:	a94153f3 	ldp	x19, x20, [sp, #16]
 110bd64:	a8c27bfd 	ldp	x29, x30, [sp], #32
 110bd68:	d65f03c0 	ret

000000000110bd6c <mobj_reg_shm_get_cattr>:
}

static TEE_Result mobj_reg_shm_get_cattr(struct mobj *mobj __unused,
					 uint32_t *cattr)
{
	if (!cattr)
 110bd6c:	b40000a1 	cbz	x1, 110bd80 <mobj_reg_shm_get_cattr+0x14>
		return TEE_ERROR_GENERIC;

	*cattr = TEE_MATTR_CACHE_CACHED;
 110bd70:	52800020 	mov	w0, #0x1                   	// #1
 110bd74:	b9000020 	str	w0, [x1]

	return TEE_SUCCESS;
 110bd78:	52800000 	mov	w0, #0x0                   	// #0
}
 110bd7c:	d65f03c0 	ret
		return TEE_ERROR_GENERIC;
 110bd80:	52bfffe0 	mov	w0, #0xffff0000            	// #-65536
 110bd84:	17fffffe 	b	110bd7c <mobj_reg_shm_get_cattr+0x10>

000000000110bd88 <cpu_spin_lock_xsave_dldetect>:
{
 110bd88:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 110bd8c:	910003fd 	mov	x29, sp
 110bd90:	a90153f3 	stp	x19, x20, [sp, #16]
 110bd94:	a9025bf5 	stp	x21, x22, [sp, #32]
 110bd98:	aa0203f5 	mov	x21, x2
 110bd9c:	a90363f7 	stp	x23, x24, [sp, #48]
 110bda0:	aa0003f7 	mov	x23, x0
 110bda4:	2a0103f8 	mov	w24, w1
	uint32_t exceptions = thread_mask_exceptions(THREAD_EXCP_ALL);
 110bda8:	528000e0 	mov	w0, #0x7                   	// #7
{
 110bdac:	a9046bf9 	stp	x25, x26, [sp, #64]
	uint32_t exceptions = thread_mask_exceptions(THREAD_EXCP_ALL);
 110bdb0:	97ffe4e2 	bl	1105138 <thread_mask_exceptions>
 110bdb4:	2a0003f4 	mov	w20, w0
 110bdb8:	97ffe457 	bl	1104f14 <thread_get_exceptions>
	assert(thread_foreign_intr_disabled());
 110bdbc:	36080220 	tbz	w0, #1, 110be00 <cpu_spin_lock_xsave_dldetect+0x78>
			trace_printf(func, line, TRACE_ERROR, true,
 110bdc0:	d0000239 	adrp	x25, 1151000 <small_prime+0x168>
 110bdc4:	91131739 	add	x25, x25, #0x4c5
 110bdc8:	52800013 	mov	w19, #0x0                   	// #0
		if (!retries) {
 110bdcc:	d2c0003a 	mov	x26, #0x100000000           	// #4294967296
	unsigned int reminder = 0;
 110bdd0:	d2800016 	mov	x22, #0x0                   	// #0
	while (__cpu_spin_trylock(lock)) {
 110bdd4:	aa1503e0 	mov	x0, x21
 110bdd8:	97ffe1b3 	bl	11044a4 <__cpu_spin_trylock>
 110bddc:	35000240 	cbnz	w0, 110be24 <cpu_spin_lock_xsave_dldetect+0x9c>
	spinlock_count_incr();
 110bde0:	97ffe1ba 	bl	11044c8 <spinlock_count_incr>
}
 110bde4:	2a1403e0 	mov	w0, w20
 110bde8:	a94153f3 	ldp	x19, x20, [sp, #16]
 110bdec:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110bdf0:	a94363f7 	ldp	x23, x24, [sp, #48]
 110bdf4:	a9446bf9 	ldp	x25, x26, [sp, #64]
 110bdf8:	a8c57bfd 	ldp	x29, x30, [sp], #80
 110bdfc:	d65f03c0 	ret
	assert(thread_foreign_intr_disabled());
 110be00:	90000243 	adrp	x3, 1153000 <__func__.3477+0x91>
 110be04:	d0000221 	adrp	x1, 1151000 <small_prime+0x168>
 110be08:	91029c63 	add	x3, x3, #0xa7
 110be0c:	9111f821 	add	x1, x1, #0x47e
 110be10:	d0000220 	adrp	x0, 1151000 <small_prime+0x168>
 110be14:	91129800 	add	x0, x0, #0x4a6
 110be18:	528006e2 	mov	w2, #0x37                  	// #55
 110be1c:	94001924 	bl	11122ac <_assert_log>
 110be20:	94001934 	bl	11122f0 <_assert_break>
		if (!retries) {
 110be24:	910006d6 	add	x22, x22, #0x1
 110be28:	eb1a02df 	cmp	x22, x26
 110be2c:	54fffd41 	b.ne	110bdd4 <cpu_spin_lock_xsave_dldetect+0x4c>  // b.any
			trace_printf(func, line, TRACE_ERROR, true,
 110be30:	2a1303e5 	mov	w5, w19
 110be34:	aa1903e4 	mov	x4, x25
 110be38:	2a1803e1 	mov	w1, w24
 110be3c:	aa1703e0 	mov	x0, x23
 110be40:	52800023 	mov	w3, #0x1                   	// #1
 110be44:	52800022 	mov	w2, #0x1                   	// #1
 110be48:	9400e3bf 	bl	1144d44 <trace_printf>
			if (reminder < UINT_MAX)
 110be4c:	3100067f 	cmn	w19, #0x1
 110be50:	54fffc00 	b.eq	110bdd0 <cpu_spin_lock_xsave_dldetect+0x48>  // b.none
				reminder++;
 110be54:	11000673 	add	w19, w19, #0x1
 110be58:	17ffffde 	b	110bdd0 <cpu_spin_lock_xsave_dldetect+0x48>

000000000110be5c <to_mobj_reg_shm>:
	return attr == CORE_MEM_NON_SEC || attr == CORE_MEM_REG_SHM;
}

static struct mobj_reg_shm *to_mobj_reg_shm(struct mobj *mobj)
{
	assert(mobj->ops == &mobj_reg_shm_ops);
 110be5c:	f9400002 	ldr	x2, [x0]
 110be60:	f0000201 	adrp	x1, 114e000 <ldelf_data+0x8000>
 110be64:	91004021 	add	x1, x1, #0x10
 110be68:	eb01005f 	cmp	x2, x1
 110be6c:	54000180 	b.eq	110be9c <to_mobj_reg_shm+0x40>  // b.none
 110be70:	90000243 	adrp	x3, 1153000 <__func__.3477+0x91>
 110be74:	f0000221 	adrp	x1, 1152000 <trace_ext_prefix+0x2e>
 110be78:	9105b063 	add	x3, x3, #0x16c
 110be7c:	913de421 	add	x1, x1, #0xf79
 110be80:	f0000220 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 110be84:	913e6400 	add	x0, x0, #0xf99
{
 110be88:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	assert(mobj->ops == &mobj_reg_shm_ops);
 110be8c:	528020e2 	mov	w2, #0x107                 	// #263
{
 110be90:	910003fd 	mov	x29, sp
	assert(mobj->ops == &mobj_reg_shm_ops);
 110be94:	94001906 	bl	11122ac <_assert_log>
 110be98:	94001916 	bl	11122f0 <_assert_break>
	return container_of(mobj, struct mobj_reg_shm, mobj);
}
 110be9c:	d65f03c0 	ret

000000000110bea0 <mobj_reg_shm_get_pa>:
{
 110bea0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 110bea4:	910003fd 	mov	x29, sp
 110bea8:	a90153f3 	stp	x19, x20, [sp, #16]
 110beac:	aa0303f4 	mov	x20, x3
 110beb0:	aa0103f3 	mov	x19, x1
 110beb4:	a9025bf5 	stp	x21, x22, [sp, #32]
 110beb8:	aa0003f6 	mov	x22, x0
 110bebc:	aa0203f5 	mov	x21, x2
	struct mobj_reg_shm *mobj_reg_shm = to_mobj_reg_shm(mobj);
 110bec0:	97ffffe7 	bl	110be5c <to_mobj_reg_shm>
	if (!pa)
 110bec4:	b4000134 	cbz	x20, 110bee8 <mobj_reg_shm_get_pa+0x48>
	if (offst >= mobj->size)
 110bec8:	f94006c1 	ldr	x1, [x22, #8]
 110becc:	eb13003f 	cmp	x1, x19
 110bed0:	540000c9 	b.ls	110bee8 <mobj_reg_shm_get_pa+0x48>  // b.plast
	full_offset = offst + mobj_reg_shm->page_offset;
 110bed4:	f9401c01 	ldr	x1, [x0, #56]
 110bed8:	8b010261 	add	x1, x19, x1
	switch (granule) {
 110bedc:	b40000b5 	cbz	x21, 110bef0 <mobj_reg_shm_get_pa+0x50>
 110bee0:	f14006bf 	cmp	x21, #0x1, lsl #12
 110bee4:	540001c0 	b.eq	110bf1c <mobj_reg_shm_get_pa+0x7c>  // b.none
		return TEE_ERROR_GENERIC;
 110bee8:	52bfffe0 	mov	w0, #0xffff0000            	// #-65536
 110beec:	14000008 	b	110bf0c <mobj_reg_shm_get_pa+0x6c>
		p = mobj_reg_shm->pages[full_offset / SMALL_PAGE_SIZE] +
 110bef0:	d34cfc22 	lsr	x2, x1, #12
			(full_offset & SMALL_PAGE_MASK);
 110bef4:	92402c21 	and	x1, x1, #0xfff
		p = mobj_reg_shm->pages[full_offset / SMALL_PAGE_SIZE] +
 110bef8:	8b020c00 	add	x0, x0, x2, lsl #3
 110befc:	f9402400 	ldr	x0, [x0, #72]
 110bf00:	8b000021 	add	x1, x1, x0
	return TEE_SUCCESS;
 110bf04:	52800000 	mov	w0, #0x0                   	// #0
	*pa = p;
 110bf08:	f9000281 	str	x1, [x20]
}
 110bf0c:	a94153f3 	ldp	x19, x20, [sp, #16]
 110bf10:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110bf14:	a8c37bfd 	ldp	x29, x30, [sp], #48
 110bf18:	d65f03c0 	ret
		p = mobj_reg_shm->pages[full_offset / SMALL_PAGE_SIZE];
 110bf1c:	d34cfc21 	lsr	x1, x1, #12
 110bf20:	8b010c01 	add	x1, x0, x1, lsl #3
 110bf24:	f9402421 	ldr	x1, [x1, #72]
		break;
 110bf28:	17fffff7 	b	110bf04 <mobj_reg_shm_get_pa+0x64>

000000000110bf2c <mobj_reg_shm_get_cookie>:
{
 110bf2c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 110bf30:	910003fd 	mov	x29, sp
	return to_mobj_reg_shm(mobj)->cookie;
 110bf34:	97ffffca 	bl	110be5c <to_mobj_reg_shm>
}
 110bf38:	a8c17bfd 	ldp	x29, x30, [sp], #16
 110bf3c:	f9401400 	ldr	x0, [x0, #40]
 110bf40:	d65f03c0 	ret

000000000110bf44 <mobj_reg_shm_get_va>:
{
 110bf44:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 110bf48:	910003fd 	mov	x29, sp
 110bf4c:	a90153f3 	stp	x19, x20, [sp, #16]
 110bf50:	aa0103f3 	mov	x19, x1
 110bf54:	f90013f5 	str	x21, [sp, #32]
 110bf58:	aa0003f5 	mov	x21, x0
	struct mobj_reg_shm *mrs = to_mobj_reg_shm(mobj);
 110bf5c:	97ffffc0 	bl	110be5c <to_mobj_reg_shm>
 110bf60:	aa0003f4 	mov	x20, x0
	if (!mrs->mm || offst >= mobj->size)
 110bf64:	f9401800 	ldr	x0, [x0, #48]
 110bf68:	b4000100 	cbz	x0, 110bf88 <mobj_reg_shm_get_va+0x44>
 110bf6c:	f94006a1 	ldr	x1, [x21, #8]
 110bf70:	eb13003f 	cmp	x1, x19
 110bf74:	54000129 	b.ls	110bf98 <mobj_reg_shm_get_va+0x54>  // b.plast
	return (void *)(vaddr_t)(tee_mm_get_smem(mrs->mm) + offst +
 110bf78:	97fffec5 	bl	110ba8c <tee_mm_get_smem>
 110bf7c:	f9401e81 	ldr	x1, [x20, #56]
 110bf80:	8b010273 	add	x19, x19, x1
 110bf84:	8b000260 	add	x0, x19, x0
}
 110bf88:	a94153f3 	ldp	x19, x20, [sp, #16]
 110bf8c:	f94013f5 	ldr	x21, [sp, #32]
 110bf90:	a8c37bfd 	ldp	x29, x30, [sp], #48
 110bf94:	d65f03c0 	ret
		return NULL;
 110bf98:	d2800000 	mov	x0, #0x0                   	// #0
 110bf9c:	17fffffb 	b	110bf88 <mobj_reg_shm_get_va+0x44>

000000000110bfa0 <mobj_reg_shm_matches>:
	assert(mobj->ops == &mobj_reg_shm_ops);
 110bfa0:	f9400002 	ldr	x2, [x0]
 110bfa4:	f0000200 	adrp	x0, 114e000 <ldelf_data+0x8000>
 110bfa8:	91004000 	add	x0, x0, #0x10
 110bfac:	eb00005f 	cmp	x2, x0
 110bfb0:	54000180 	b.eq	110bfe0 <mobj_reg_shm_matches+0x40>  // b.none
 110bfb4:	90000243 	adrp	x3, 1153000 <__func__.3477+0x91>
 110bfb8:	f0000221 	adrp	x1, 1152000 <trace_ext_prefix+0x2e>
 110bfbc:	91055c63 	add	x3, x3, #0x157
 110bfc0:	913de421 	add	x1, x1, #0xf79
 110bfc4:	f0000220 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 110bfc8:	913e6400 	add	x0, x0, #0xf99
{
 110bfcc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	assert(mobj->ops == &mobj_reg_shm_ops);
 110bfd0:	52802002 	mov	w2, #0x100                 	// #256
{
 110bfd4:	910003fd 	mov	x29, sp
	assert(mobj->ops == &mobj_reg_shm_ops);
 110bfd8:	940018b5 	bl	11122ac <_assert_log>
 110bfdc:	940018c5 	bl	11122f0 <_assert_break>
	return attr == CORE_MEM_NON_SEC || attr == CORE_MEM_REG_SHM;
 110bfe0:	7100083f 	cmp	w1, #0x2
 110bfe4:	7a471824 	ccmp	w1, #0x7, #0x4, ne  // ne = any
}
 110bfe8:	1a9f17e0 	cset	w0, eq  // eq = none
 110bfec:	d65f03c0 	ret

000000000110bff0 <mobj_reg_shm_get_phys_offs>:
{
 110bff0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 110bff4:	910003fd 	mov	x29, sp
	assert(granule >= mobj->phys_granule);
 110bff8:	f9400802 	ldr	x2, [x0, #16]
 110bffc:	eb01005f 	cmp	x2, x1
 110c000:	54000149 	b.ls	110c028 <mobj_reg_shm_get_phys_offs+0x38>  // b.plast
 110c004:	f0000223 	adrp	x3, 1153000 <__func__.3477+0x91>
 110c008:	d0000221 	adrp	x1, 1152000 <trace_ext_prefix+0x2e>
 110c00c:	91035c63 	add	x3, x3, #0xd7
 110c010:	913de421 	add	x1, x1, #0xf79
 110c014:	d0000220 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 110c018:	913ee000 	add	x0, x0, #0xfb8
 110c01c:	52800c82 	mov	w2, #0x64                  	// #100
 110c020:	940018a3 	bl	11122ac <_assert_log>
 110c024:	940018b3 	bl	11122f0 <_assert_break>
	return to_mobj_reg_shm(mobj)->page_offset;
 110c028:	97ffff8d 	bl	110be5c <to_mobj_reg_shm>
}
 110c02c:	a8c17bfd 	ldp	x29, x30, [sp], #16
 110c030:	f9401c00 	ldr	x0, [x0, #56]
 110c034:	d65f03c0 	ret

000000000110c038 <mobj_put>:
	if (mobj && refcount_dec(&mobj->refc))
 110c038:	b4000260 	cbz	x0, 110c084 <mobj_put+0x4c>
{
 110c03c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 110c040:	910003fd 	mov	x29, sp
 110c044:	f9000bf3 	str	x19, [sp, #16]
 110c048:	aa0003f3 	mov	x19, x0
	if (mobj && refcount_dec(&mobj->refc))
 110c04c:	91006000 	add	x0, x0, #0x18
 110c050:	94001d57 	bl	11135ac <refcount_dec>
 110c054:	72001c1f 	tst	w0, #0xff
 110c058:	54000100 	b.eq	110c078 <mobj_put+0x40>  // b.none
		mobj->ops->free(mobj);
 110c05c:	f9400260 	ldr	x0, [x19]
 110c060:	f9401401 	ldr	x1, [x0, #40]
 110c064:	aa1303e0 	mov	x0, x19
}
 110c068:	f9400bf3 	ldr	x19, [sp, #16]
		mobj->ops->free(mobj);
 110c06c:	aa0103f0 	mov	x16, x1
}
 110c070:	a8c27bfd 	ldp	x29, x30, [sp], #32
		mobj->ops->free(mobj);
 110c074:	d61f0200 	br	x16
}
 110c078:	f9400bf3 	ldr	x19, [sp, #16]
 110c07c:	a8c27bfd 	ldp	x29, x30, [sp], #32
 110c080:	d65f03c0 	ret
 110c084:	d65f03c0 	ret

000000000110c088 <reg_shm_unmap_helper>:
{
 110c088:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 110c08c:	910003fd 	mov	x29, sp
 110c090:	f9000bf3 	str	x19, [sp, #16]
 110c094:	aa0003f3 	mov	x19, x0
	assert(r->mm->pool->shift == SMALL_PAGE_SHIFT);
 110c098:	f9401800 	ldr	x0, [x0, #48]
 110c09c:	f9400001 	ldr	x1, [x0]
 110c0a0:	39407021 	ldrb	w1, [x1, #28]
 110c0a4:	7100303f 	cmp	w1, #0xc
 110c0a8:	54000140 	b.eq	110c0d0 <reg_shm_unmap_helper+0x48>  // b.none
 110c0ac:	f0000223 	adrp	x3, 1153000 <__func__.3477+0x91>
 110c0b0:	d0000221 	adrp	x1, 1152000 <trace_ext_prefix+0x2e>
 110c0b4:	9103c863 	add	x3, x3, #0xf2
 110c0b8:	913de421 	add	x1, x1, #0xf79
 110c0bc:	d0000220 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 110c0c0:	913f5800 	add	x0, x0, #0xfd6
 110c0c4:	52800ea2 	mov	w2, #0x75                  	// #117
 110c0c8:	94001879 	bl	11122ac <_assert_log>
 110c0cc:	94001889 	bl	11122f0 <_assert_break>
	core_mmu_unmap_pages(tee_mm_get_smem(r->mm), r->mm->size);
 110c0d0:	97fffe6f 	bl	110ba8c <tee_mm_get_smem>
 110c0d4:	f9401a61 	ldr	x1, [x19, #48]
 110c0d8:	b9401421 	ldr	w1, [x1, #20]
 110c0dc:	97fff6de 	bl	1109c54 <core_mmu_unmap_pages>
	tee_mm_free(r->mm);
 110c0e0:	f9401a60 	ldr	x0, [x19, #48]
 110c0e4:	97fffe0e 	bl	110b91c <tee_mm_free>
	r->mm = NULL;
 110c0e8:	f9001a7f 	str	xzr, [x19, #48]
}
 110c0ec:	f9400bf3 	ldr	x19, [sp, #16]
 110c0f0:	a8c27bfd 	ldp	x29, x30, [sp], #32
 110c0f4:	d65f03c0 	ret

000000000110c0f8 <mobj_mapped_shm_init>:

	return mobj;
}

static TEE_Result mobj_mapped_shm_init(void)
{
 110c0f8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	vaddr_t pool_start = 0;
	vaddr_t pool_end = 0;

	core_mmu_get_mem_by_type(MEM_AREA_SHM_VASPACE, &pool_start, &pool_end);
 110c0fc:	52800220 	mov	w0, #0x11                  	// #17
{
 110c100:	910003fd 	mov	x29, sp
	core_mmu_get_mem_by_type(MEM_AREA_SHM_VASPACE, &pool_start, &pool_end);
 110c104:	910083e1 	add	x1, sp, #0x20
 110c108:	9100a3e2 	add	x2, sp, #0x28
{
 110c10c:	f9000bf3 	str	x19, [sp, #16]
 110c110:	f0000233 	adrp	x19, 1153000 <__func__.3477+0x91>
	vaddr_t pool_end = 0;
 110c114:	a9027fff 	stp	xzr, xzr, [sp, #32]
	core_mmu_get_mem_by_type(MEM_AREA_SHM_VASPACE, &pool_start, &pool_end);
 110c118:	97fff58d 	bl	110974c <core_mmu_get_mem_by_type>
	if (!pool_start || !pool_end)
 110c11c:	f94013e1 	ldr	x1, [sp, #32]
 110c120:	b4000061 	cbz	x1, 110c12c <mobj_mapped_shm_init+0x34>
 110c124:	f94017e2 	ldr	x2, [sp, #40]
 110c128:	b5000102 	cbnz	x2, 110c148 <mobj_mapped_shm_init+0x50>
		panic("Can't find region for shmem pool");
 110c12c:	d0000223 	adrp	x3, 1152000 <trace_ext_prefix+0x2e>
 110c130:	91077a62 	add	x2, x19, #0x1de
 110c134:	913ff463 	add	x3, x3, #0xffd
 110c138:	52803581 	mov	w1, #0x1ac                 	// #428

	if (!tee_mm_init(&tee_mm_shm, pool_start, pool_end, SMALL_PAGE_SHIFT,
		    TEE_MM_POOL_NO_FLAGS))
		panic("Could not create shmem pool");
 110c13c:	d0000220 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 110c140:	913de400 	add	x0, x0, #0xf79
 110c144:	94001cc9 	bl	1113468 <__do_panic>
	if (!tee_mm_init(&tee_mm_shm, pool_start, pool_end, SMALL_PAGE_SHIFT,
 110c148:	d0000260 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 110c14c:	52800004 	mov	w4, #0x0                   	// #0
 110c150:	52800183 	mov	w3, #0xc                   	// #12
 110c154:	f9416800 	ldr	x0, [x0, #720]
 110c158:	97fffd22 	bl	110b5e0 <tee_mm_init>
 110c15c:	72001c1f 	tst	w0, #0xff
 110c160:	540000c1 	b.ne	110c178 <mobj_mapped_shm_init+0x80>  // b.any
		panic("Could not create shmem pool");
 110c164:	f0000223 	adrp	x3, 1153000 <__func__.3477+0x91>
 110c168:	91077a62 	add	x2, x19, #0x1de
 110c16c:	91007863 	add	x3, x3, #0x1e
 110c170:	52803601 	mov	w1, #0x1b0                 	// #432
 110c174:	17fffff2 	b	110c13c <mobj_mapped_shm_init+0x44>

	DMSG("Shared memory address range: %" PRIxVA ", %" PRIxVA,
 110c178:	a9421be5 	ldp	x5, x6, [sp, #32]
 110c17c:	91077a60 	add	x0, x19, #0x1de
 110c180:	52800023 	mov	w3, #0x1                   	// #1
 110c184:	52800062 	mov	w2, #0x3                   	// #3
 110c188:	52803641 	mov	w1, #0x1b2                 	// #434
 110c18c:	f0000224 	adrp	x4, 1153000 <__func__.3477+0x91>
 110c190:	9100e884 	add	x4, x4, #0x3a
 110c194:	9400e2ec 	bl	1144d44 <trace_printf>
	     pool_start, pool_end);
	return TEE_SUCCESS;
}
 110c198:	52800000 	mov	w0, #0x0                   	// #0
 110c19c:	f9400bf3 	ldr	x19, [sp, #16]
 110c1a0:	a8c37bfd 	ldp	x29, x30, [sp], #48
 110c1a4:	d65f03c0 	ret

000000000110c1a8 <cpu_spin_unlock_xrestore>:
{
 110c1a8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 110c1ac:	910003fd 	mov	x29, sp
 110c1b0:	a90153f3 	stp	x19, x20, [sp, #16]
 110c1b4:	aa0003f4 	mov	x20, x0
 110c1b8:	2a0103f3 	mov	w19, w1
 110c1bc:	97ffe356 	bl	1104f14 <thread_get_exceptions>
	assert(thread_foreign_intr_disabled());
 110c1c0:	37080140 	tbnz	w0, #1, 110c1e8 <cpu_spin_unlock_xrestore+0x40>
 110c1c4:	f0000223 	adrp	x3, 1153000 <__func__.3477+0x91>
 110c1c8:	b0000221 	adrp	x1, 1151000 <small_prime+0x168>
 110c1cc:	9102f863 	add	x3, x3, #0xbe
 110c1d0:	9111f821 	add	x1, x1, #0x47e
 110c1d4:	b0000220 	adrp	x0, 1151000 <small_prime+0x168>
 110c1d8:	91129800 	add	x0, x0, #0x4a6
 110c1dc:	52800b82 	mov	w2, #0x5c                  	// #92
 110c1e0:	94001833 	bl	11122ac <_assert_log>
 110c1e4:	94001843 	bl	11122f0 <_assert_break>
	__cpu_spin_unlock(lock);
 110c1e8:	aa1403e0 	mov	x0, x20
 110c1ec:	97ffe0b5 	bl	11044c0 <__cpu_spin_unlock>
	spinlock_count_decr();
 110c1f0:	97ffe0c8 	bl	1104510 <spinlock_count_decr>
	thread_unmask_exceptions(exceptions);
 110c1f4:	2a1303e0 	mov	w0, w19
}
 110c1f8:	a94153f3 	ldp	x19, x20, [sp, #16]
 110c1fc:	a8c27bfd 	ldp	x29, x30, [sp], #32
	thread_unmask_exceptions(exceptions);
 110c200:	17ffe3db 	b	110516c <thread_unmask_exceptions>

000000000110c204 <mobj_reg_shm_inc_map>:
{
 110c204:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 110c208:	910003fd 	mov	x29, sp
 110c20c:	a90153f3 	stp	x19, x20, [sp, #16]
 110c210:	a9025bf5 	stp	x21, x22, [sp, #32]
 110c214:	a90363f7 	stp	x23, x24, [sp, #48]
 110c218:	aa0003f8 	mov	x24, x0
	struct mobj_reg_shm *r = to_mobj_reg_shm(mobj);
 110c21c:	97ffff10 	bl	110be5c <to_mobj_reg_shm>
	if (refcount_inc(&r->mapcount))
 110c220:	91010017 	add	x23, x0, #0x40
	struct mobj_reg_shm *r = to_mobj_reg_shm(mobj);
 110c224:	aa0003f3 	mov	x19, x0
	if (refcount_inc(&r->mapcount))
 110c228:	aa1703e0 	mov	x0, x23
 110c22c:	94001cd2 	bl	1113574 <refcount_inc>
 110c230:	72001c1f 	tst	w0, #0xff
 110c234:	54000721 	b.ne	110c318 <mobj_reg_shm_inc_map+0x114>  // b.any
	uint32_t exceptions = cpu_spin_lock_xsave(&reg_shm_map_lock);
 110c238:	f0000234 	adrp	x20, 1153000 <__func__.3477+0x91>
 110c23c:	9104b694 	add	x20, x20, #0x12d
 110c240:	aa1403e0 	mov	x0, x20
 110c244:	900002f5 	adrp	x21, 1168000 <data.5093+0x9e28>
 110c248:	52801781 	mov	w1, #0xbc                  	// #188
 110c24c:	9128d2a2 	add	x2, x21, #0xa34
 110c250:	97fffece 	bl	110bd88 <cpu_spin_lock_xsave_dldetect>
 110c254:	2a0003f6 	mov	w22, w0
	return __compiler_atomic_load(p);
}

static inline unsigned int atomic_load_uint(unsigned int *p)
{
	return __compiler_atomic_load(p);
 110c258:	b94002e0 	ldr	w0, [x23]
	if (refcount_val(&r->mapcount))
 110c25c:	35000560 	cbnz	w0, 110c308 <mobj_reg_shm_inc_map+0x104>
	assert(!r->mm);
 110c260:	f9401a60 	ldr	x0, [x19, #48]
 110c264:	b4000120 	cbz	x0, 110c288 <mobj_reg_shm_inc_map+0x84>
 110c268:	aa1403e3 	mov	x3, x20
 110c26c:	d0000221 	adrp	x1, 1152000 <trace_ext_prefix+0x2e>
 110c270:	f0000220 	adrp	x0, 1153000 <__func__.3477+0x91>
 110c274:	913de421 	add	x1, x1, #0xf79
 110c278:	91018000 	add	x0, x0, #0x60
 110c27c:	52801822 	mov	w2, #0xc1                  	// #193
 110c280:	9400180b 	bl	11122ac <_assert_log>
 110c284:	9400181b 	bl	11122f0 <_assert_break>
	sz = ROUNDUP(mobj->size + r->page_offset, SMALL_PAGE_SIZE);
 110c288:	f9400714 	ldr	x20, [x24, #8]
 110c28c:	f9401e60 	ldr	x0, [x19, #56]
 110c290:	913ffe94 	add	x20, x20, #0xfff
 110c294:	8b000294 	add	x20, x20, x0
	r->mm = tee_mm_alloc(&tee_mm_shm, sz);
 110c298:	d0000260 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 110c29c:	9274ce81 	and	x1, x20, #0xfffffffffffff000
 110c2a0:	f9416800 	ldr	x0, [x0, #720]
 110c2a4:	97fffd2f 	bl	110b760 <tee_mm_alloc>
 110c2a8:	f9001a60 	str	x0, [x19, #48]
	if (!r->mm) {
 110c2ac:	b4000320 	cbz	x0, 110c310 <mobj_reg_shm_inc_map+0x10c>
	res = core_mmu_map_pages(tee_mm_get_smem(r->mm), r->pages,
 110c2b0:	97fffdf7 	bl	110ba8c <tee_mm_get_smem>
 110c2b4:	d34cfe82 	lsr	x2, x20, #12
 110c2b8:	91012261 	add	x1, x19, #0x48
 110c2bc:	52800143 	mov	w3, #0xa                   	// #10
 110c2c0:	97fff6b5 	bl	1109d94 <core_mmu_map_pages>
 110c2c4:	2a0003f4 	mov	w20, w0
	if (res) {
 110c2c8:	340001a0 	cbz	w0, 110c2fc <mobj_reg_shm_inc_map+0xf8>
		tee_mm_free(r->mm);
 110c2cc:	f9401a60 	ldr	x0, [x19, #48]
 110c2d0:	97fffd93 	bl	110b91c <tee_mm_free>
		r->mm = NULL;
 110c2d4:	f9001a7f 	str	xzr, [x19, #48]
	cpu_spin_unlock_xrestore(&reg_shm_map_lock, exceptions);
 110c2d8:	2a1603e1 	mov	w1, w22
 110c2dc:	9128d2a0 	add	x0, x21, #0xa34
 110c2e0:	97ffffb2 	bl	110c1a8 <cpu_spin_unlock_xrestore>
}
 110c2e4:	2a1403e0 	mov	w0, w20
 110c2e8:	a94153f3 	ldp	x19, x20, [sp, #16]
 110c2ec:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110c2f0:	a94363f7 	ldp	x23, x24, [sp, #48]
 110c2f4:	a8c47bfd 	ldp	x29, x30, [sp], #64
 110c2f8:	d65f03c0 	ret
	__compiler_atomic_store(p, val);
}

static inline void atomic_store_uint(unsigned int *p, unsigned int val)
{
	__compiler_atomic_store(p, val);
 110c2fc:	52800020 	mov	w0, #0x1                   	// #1
 110c300:	b90002e0 	str	w0, [x23]
}
 110c304:	17fffff5 	b	110c2d8 <mobj_reg_shm_inc_map+0xd4>
	TEE_Result res = TEE_SUCCESS;
 110c308:	52800014 	mov	w20, #0x0                   	// #0
 110c30c:	17fffff3 	b	110c2d8 <mobj_reg_shm_inc_map+0xd4>
		res = TEE_ERROR_OUT_OF_MEMORY;
 110c310:	129ffe74 	mov	w20, #0xffff000c            	// #-65524
 110c314:	17fffff1 	b	110c2d8 <mobj_reg_shm_inc_map+0xd4>
		return TEE_SUCCESS;
 110c318:	52800014 	mov	w20, #0x0                   	// #0
 110c31c:	17fffff2 	b	110c2e4 <mobj_reg_shm_inc_map+0xe0>

000000000110c320 <reg_shm_free_helper>:
{
 110c320:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	uint32_t exceptions = cpu_spin_lock_xsave(&reg_shm_map_lock);
 110c324:	52800fa1 	mov	w1, #0x7d                  	// #125
{
 110c328:	910003fd 	mov	x29, sp
 110c32c:	a90153f3 	stp	x19, x20, [sp, #16]
 110c330:	aa0003f3 	mov	x19, x0
	uint32_t exceptions = cpu_spin_lock_xsave(&reg_shm_map_lock);
 110c334:	900002f4 	adrp	x20, 1168000 <data.5093+0x9e28>
 110c338:	f0000220 	adrp	x0, 1153000 <__func__.3477+0x91>
 110c33c:	9128d282 	add	x2, x20, #0xa34
 110c340:	91041c00 	add	x0, x0, #0x107
{
 110c344:	f90013f5 	str	x21, [sp, #32]
	uint32_t exceptions = cpu_spin_lock_xsave(&reg_shm_map_lock);
 110c348:	97fffe90 	bl	110bd88 <cpu_spin_lock_xsave_dldetect>
 110c34c:	2a0003f5 	mov	w21, w0
	if (mobj_reg_shm->mm)
 110c350:	f9401a60 	ldr	x0, [x19, #48]
 110c354:	b4000060 	cbz	x0, 110c360 <reg_shm_free_helper+0x40>
		reg_shm_unmap_helper(mobj_reg_shm);
 110c358:	aa1303e0 	mov	x0, x19
 110c35c:	97ffff4b 	bl	110c088 <reg_shm_unmap_helper>
	cpu_spin_unlock_xrestore(&reg_shm_map_lock, exceptions);
 110c360:	2a1503e1 	mov	w1, w21
 110c364:	9128d280 	add	x0, x20, #0xa34
 110c368:	97ffff90 	bl	110c1a8 <cpu_spin_unlock_xrestore>
	SLIST_REMOVE(&reg_shm_list, mobj_reg_shm, mobj_reg_shm, next);
 110c36c:	b0000281 	adrp	x1, 115d000 <_curve_names+0x590>
 110c370:	f9478420 	ldr	x0, [x1, #3848]
 110c374:	eb13001f 	cmp	x0, x19
 110c378:	54000101 	b.ne	110c398 <reg_shm_free_helper+0x78>  // b.any
 110c37c:	f9401260 	ldr	x0, [x19, #32]
 110c380:	f9078420 	str	x0, [x1, #3848]
	free(mobj_reg_shm);
 110c384:	aa1303e0 	mov	x0, x19
}
 110c388:	a94153f3 	ldp	x19, x20, [sp, #16]
 110c38c:	f94013f5 	ldr	x21, [sp, #32]
 110c390:	a8c37bfd 	ldp	x29, x30, [sp], #48
	free(mobj_reg_shm);
 110c394:	1400dc93 	b	11435e0 <free>
	SLIST_REMOVE(&reg_shm_list, mobj_reg_shm, mobj_reg_shm, next);
 110c398:	aa0003e1 	mov	x1, x0
 110c39c:	f9401000 	ldr	x0, [x0, #32]
 110c3a0:	eb13001f 	cmp	x0, x19
 110c3a4:	54ffffa1 	b.ne	110c398 <reg_shm_free_helper+0x78>  // b.any
 110c3a8:	f9401260 	ldr	x0, [x19, #32]
 110c3ac:	f9001020 	str	x0, [x1, #32]
 110c3b0:	17fffff5 	b	110c384 <reg_shm_free_helper+0x64>

000000000110c3b4 <mobj_reg_shm_free>:
{
 110c3b4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 110c3b8:	910003fd 	mov	x29, sp
 110c3bc:	a90153f3 	stp	x19, x20, [sp, #16]
 110c3c0:	900002f3 	adrp	x19, 1168000 <data.5093+0x9e28>
		exceptions = cpu_spin_lock_xsave(&reg_shm_slist_lock);
 110c3c4:	9128e273 	add	x19, x19, #0xa38
{
 110c3c8:	f90013f5 	str	x21, [sp, #32]
	struct mobj_reg_shm *r = to_mobj_reg_shm(mobj);
 110c3cc:	97fffea4 	bl	110be5c <to_mobj_reg_shm>
	if (r->guarded && !r->releasing) {
 110c3d0:	39411001 	ldrb	w1, [x0, #68]
	struct mobj_reg_shm *r = to_mobj_reg_shm(mobj);
 110c3d4:	aa0003f4 	mov	x20, x0
		exceptions = cpu_spin_lock_xsave(&reg_shm_slist_lock);
 110c3d8:	aa1303e2 	mov	x2, x19
 110c3dc:	f0000220 	adrp	x0, 1153000 <__func__.3477+0x91>
	if (r->guarded && !r->releasing) {
 110c3e0:	340001e1 	cbz	w1, 110c41c <mobj_reg_shm_free+0x68>
 110c3e4:	39411681 	ldrb	w1, [x20, #69]
 110c3e8:	350001a1 	cbnz	w1, 110c41c <mobj_reg_shm_free+0x68>
		exceptions = cpu_spin_lock_xsave(&reg_shm_slist_lock);
 110c3ec:	528012a1 	mov	w1, #0x95                  	// #149
 110c3f0:	91046c00 	add	x0, x0, #0x11b
 110c3f4:	97fffe65 	bl	110bd88 <cpu_spin_lock_xsave_dldetect>
 110c3f8:	2a0003f5 	mov	w21, w0
		reg_shm_free_helper(r);
 110c3fc:	aa1403e0 	mov	x0, x20
 110c400:	97ffffc8 	bl	110c320 <reg_shm_free_helper>
		cpu_spin_unlock_xrestore(&reg_shm_slist_lock, exceptions);
 110c404:	2a1503e1 	mov	w1, w21
 110c408:	aa1303e0 	mov	x0, x19
}
 110c40c:	a94153f3 	ldp	x19, x20, [sp, #16]
 110c410:	f94013f5 	ldr	x21, [sp, #32]
 110c414:	a8c37bfd 	ldp	x29, x30, [sp], #48
		cpu_spin_unlock_xrestore(&reg_shm_slist_lock, exceptions);
 110c418:	17ffff64 	b	110c1a8 <cpu_spin_unlock_xrestore>
		exceptions = cpu_spin_lock_xsave(&reg_shm_slist_lock);
 110c41c:	528013a1 	mov	w1, #0x9d                  	// #157
 110c420:	91046c00 	add	x0, x0, #0x11b
 110c424:	97fffe59 	bl	110bd88 <cpu_spin_lock_xsave_dldetect>
		r->release_frees = true;
 110c428:	52800021 	mov	w1, #0x1                   	// #1
 110c42c:	39011a81 	strb	w1, [x20, #70]
		cpu_spin_unlock_xrestore(&reg_shm_slist_lock, exceptions);
 110c430:	2a0003e1 	mov	w1, w0
 110c434:	aa1303e0 	mov	x0, x19
 110c438:	97ffff5c 	bl	110c1a8 <cpu_spin_unlock_xrestore>
		mutex_lock(&shm_mu);
 110c43c:	b0000293 	adrp	x19, 115d000 <_curve_names+0x590>
 110c440:	913c8260 	add	x0, x19, #0xf20
 110c444:	94002444 	bl	1115554 <mutex_lock>
		if (shm_release_waiters)
 110c448:	b0000280 	adrp	x0, 115d000 <_curve_names+0x590>
 110c44c:	f9479c00 	ldr	x0, [x0, #3896]
 110c450:	b4000080 	cbz	x0, 110c460 <mobj_reg_shm_free+0xac>
			condvar_broadcast(&shm_cv);
 110c454:	b0000280 	adrp	x0, 115d000 <_curve_names+0x590>
 110c458:	913c4000 	add	x0, x0, #0xf10
 110c45c:	94002559 	bl	11159c0 <condvar_broadcast>
		mutex_unlock(&shm_mu);
 110c460:	913c8260 	add	x0, x19, #0xf20
}
 110c464:	a94153f3 	ldp	x19, x20, [sp, #16]
 110c468:	f94013f5 	ldr	x21, [sp, #32]
 110c46c:	a8c37bfd 	ldp	x29, x30, [sp], #48
		mutex_unlock(&shm_mu);
 110c470:	14002418 	b	11154d0 <mutex_unlock>

000000000110c474 <mobj_reg_shm_dec_map>:
{
 110c474:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 110c478:	910003fd 	mov	x29, sp
 110c47c:	a90153f3 	stp	x19, x20, [sp, #16]
 110c480:	a9025bf5 	stp	x21, x22, [sp, #32]
	struct mobj_reg_shm *r = to_mobj_reg_shm(mobj);
 110c484:	97fffe76 	bl	110be5c <to_mobj_reg_shm>
	if (!refcount_dec(&r->mapcount))
 110c488:	91010016 	add	x22, x0, #0x40
	struct mobj_reg_shm *r = to_mobj_reg_shm(mobj);
 110c48c:	aa0003f4 	mov	x20, x0
	if (!refcount_dec(&r->mapcount))
 110c490:	aa1603e0 	mov	x0, x22
 110c494:	94001c46 	bl	11135ac <refcount_dec>
 110c498:	72001c1f 	tst	w0, #0xff
 110c49c:	540001e0 	b.eq	110c4d8 <mobj_reg_shm_dec_map+0x64>  // b.none
	exceptions = cpu_spin_lock_xsave(&reg_shm_map_lock);
 110c4a0:	900002f3 	adrp	x19, 1168000 <data.5093+0x9e28>
 110c4a4:	52801c01 	mov	w1, #0xe0                  	// #224
 110c4a8:	9128d262 	add	x2, x19, #0xa34
 110c4ac:	f0000220 	adrp	x0, 1153000 <__func__.3477+0x91>
 110c4b0:	91050800 	add	x0, x0, #0x142
 110c4b4:	97fffe35 	bl	110bd88 <cpu_spin_lock_xsave_dldetect>
 110c4b8:	2a0003f5 	mov	w21, w0
	return __compiler_atomic_load(p);
 110c4bc:	b94002c0 	ldr	w0, [x22]
	if (!refcount_val(&r->mapcount))
 110c4c0:	35000060 	cbnz	w0, 110c4cc <mobj_reg_shm_dec_map+0x58>
		reg_shm_unmap_helper(r);
 110c4c4:	aa1403e0 	mov	x0, x20
 110c4c8:	97fffef0 	bl	110c088 <reg_shm_unmap_helper>
	cpu_spin_unlock_xrestore(&reg_shm_map_lock, exceptions);
 110c4cc:	2a1503e1 	mov	w1, w21
 110c4d0:	9128d260 	add	x0, x19, #0xa34
 110c4d4:	97ffff35 	bl	110c1a8 <cpu_spin_unlock_xrestore>
}
 110c4d8:	52800000 	mov	w0, #0x0                   	// #0
 110c4dc:	a94153f3 	ldp	x19, x20, [sp, #16]
 110c4e0:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110c4e4:	a8c37bfd 	ldp	x29, x30, [sp], #48
 110c4e8:	d65f03c0 	ret

000000000110c4ec <mobj_reg_shm_alloc>:
	if (!num_pages || page_offset >= SMALL_PAGE_SIZE)
 110c4ec:	f13ffc5f 	cmp	x2, #0xfff
 110c4f0:	fa409824 	ccmp	x1, #0x0, #0x4, ls  // ls = plast
 110c4f4:	54000061 	b.ne	110c500 <mobj_reg_shm_alloc+0x14>  // b.any
		return NULL;
 110c4f8:	d2800000 	mov	x0, #0x0                   	// #0
}
 110c4fc:	d65f03c0 	ret
{
 110c500:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
	if (MUL_OVERFLOW(sizeof(paddr_t), nr_pages, &s))
 110c504:	eb41f7ff 	cmp	xzr, x1, lsr #61
{
 110c508:	910003fd 	mov	x29, sp
 110c50c:	a90153f3 	stp	x19, x20, [sp, #16]
 110c510:	aa0103f4 	mov	x20, x1
 110c514:	a9025bf5 	stp	x21, x22, [sp, #32]
 110c518:	a90363f7 	stp	x23, x24, [sp, #48]
	if (MUL_OVERFLOW(sizeof(paddr_t), nr_pages, &s))
 110c51c:	d37df038 	lsl	x24, x1, #3
{
 110c520:	f90023f9 	str	x25, [sp, #64]
	if (MUL_OVERFLOW(sizeof(paddr_t), nr_pages, &s))
 110c524:	54000841 	b.ne	110c62c <mobj_reg_shm_alloc+0x140>  // b.any
	if (ADD_OVERFLOW(sizeof(struct mobj_reg_shm), s, &s))
 110c528:	b1012301 	adds	x1, x24, #0x48
 110c52c:	9a9f37f6 	cset	x22, cs  // cs = hs, nlast
 110c530:	540007e2 	b.cs	110c62c <mobj_reg_shm_alloc+0x140>  // b.hs, b.nlast
	if (!s)
 110c534:	b40007c1 	cbz	x1, 110c62c <mobj_reg_shm_alloc+0x140>
 110c538:	aa0003f7 	mov	x23, x0
 110c53c:	aa0203f5 	mov	x21, x2
 110c540:	aa0303f9 	mov	x25, x3
	mobj_reg_shm = calloc(1, s);
 110c544:	d2800020 	mov	x0, #0x1                   	// #1
 110c548:	9400dbe2 	bl	11434d0 <calloc>
 110c54c:	aa0003f3 	mov	x19, x0
	if (!mobj_reg_shm)
 110c550:	b40006e0 	cbz	x0, 110c62c <mobj_reg_shm_alloc+0x140>
	mobj_reg_shm->mobj.ops = &mobj_reg_shm_ops;
 110c554:	d0000200 	adrp	x0, 114e000 <ldelf_data+0x8000>
 110c558:	91004000 	add	x0, x0, #0x10
 110c55c:	f9000260 	str	x0, [x19]
	mobj_reg_shm->mobj.size = num_pages * SMALL_PAGE_SIZE - page_offset;
 110c560:	d374ce80 	lsl	x0, x20, #12
 110c564:	cb150000 	sub	x0, x0, x21
 110c568:	f9000660 	str	x0, [x19, #8]
	mobj_reg_shm->mobj.phys_granule = SMALL_PAGE_SIZE;
 110c56c:	d2820000 	mov	x0, #0x1000                	// #4096
 110c570:	f9000a60 	str	x0, [x19, #16]
	__compiler_atomic_store(p, val);
 110c574:	52800021 	mov	w1, #0x1                   	// #1
 110c578:	91006260 	add	x0, x19, #0x18
 110c57c:	b9000001 	str	w1, [x0]
	mobj_reg_shm->page_offset = page_offset;
 110c580:	f9001e75 	str	x21, [x19, #56]
	mobj_reg_shm->guarded = true;
 110c584:	52800020 	mov	w0, #0x1                   	// #1
	memcpy(mobj_reg_shm->pages, pages, sizeof(*pages) * num_pages);
 110c588:	91012275 	add	x21, x19, #0x48
 110c58c:	aa1803e2 	mov	x2, x24
 110c590:	aa1703e1 	mov	x1, x23
	mobj_reg_shm->cookie = cookie;
 110c594:	f9001679 	str	x25, [x19, #40]
	mobj_reg_shm->guarded = true;
 110c598:	39011260 	strb	w0, [x19, #68]
	memcpy(mobj_reg_shm->pages, pages, sizeof(*pages) * num_pages);
 110c59c:	aa1503e0 	mov	x0, x21
 110c5a0:	97ffdb7c 	bl	1103390 <memcpy>
		if (mobj_reg_shm->pages[i] & SMALL_PAGE_MASK)
 110c5a4:	f8767aa1 	ldr	x1, [x21, x22, lsl #3]
 110c5a8:	f2402c3f 	tst	x1, #0xfff
 110c5ac:	540003c1 	b.ne	110c624 <mobj_reg_shm_alloc+0x138>  // b.any
		if (!core_pbuf_is(CORE_MEM_NON_SEC, mobj_reg_shm->pages[i],
 110c5b0:	d2820002 	mov	x2, #0x1000                	// #4096
 110c5b4:	52800040 	mov	w0, #0x2                   	// #2
 110c5b8:	97fff410 	bl	11095f8 <core_pbuf_is>
 110c5bc:	72001c1f 	tst	w0, #0xff
 110c5c0:	54000320 	b.eq	110c624 <mobj_reg_shm_alloc+0x138>  // b.none
	for (i = 0; i < num_pages; i++) {
 110c5c4:	910006d6 	add	x22, x22, #0x1
 110c5c8:	eb16029f 	cmp	x20, x22
 110c5cc:	54fffec1 	b.ne	110c5a4 <mobj_reg_shm_alloc+0xb8>  // b.any
	exceptions = cpu_spin_lock_xsave(&reg_shm_slist_lock);
 110c5d0:	900002f4 	adrp	x20, 1168000 <data.5093+0x9e28>
 110c5d4:	9128e294 	add	x20, x20, #0xa38
 110c5d8:	aa1403e2 	mov	x2, x20
 110c5dc:	52802621 	mov	w1, #0x131                 	// #305
 110c5e0:	f0000220 	adrp	x0, 1153000 <__func__.3477+0x91>
 110c5e4:	9105f000 	add	x0, x0, #0x17c
 110c5e8:	97fffde8 	bl	110bd88 <cpu_spin_lock_xsave_dldetect>
	SLIST_INSERT_HEAD(&reg_shm_list, mobj_reg_shm, next);
 110c5ec:	b0000282 	adrp	x2, 115d000 <_curve_names+0x590>
 110c5f0:	f9478441 	ldr	x1, [x2, #3848]
 110c5f4:	f9078453 	str	x19, [x2, #3848]
 110c5f8:	f9001261 	str	x1, [x19, #32]
	cpu_spin_unlock_xrestore(&reg_shm_slist_lock, exceptions);
 110c5fc:	2a0003e1 	mov	w1, w0
 110c600:	aa1403e0 	mov	x0, x20
 110c604:	97fffee9 	bl	110c1a8 <cpu_spin_unlock_xrestore>
	return &mobj_reg_shm->mobj;
 110c608:	aa1303e0 	mov	x0, x19
}
 110c60c:	a94153f3 	ldp	x19, x20, [sp, #16]
 110c610:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110c614:	a94363f7 	ldp	x23, x24, [sp, #48]
 110c618:	f94023f9 	ldr	x25, [sp, #64]
 110c61c:	a8c57bfd 	ldp	x29, x30, [sp], #80
 110c620:	d65f03c0 	ret
	free(mobj_reg_shm);
 110c624:	aa1303e0 	mov	x0, x19
 110c628:	9400dbee 	bl	11435e0 <free>
	return NULL;
 110c62c:	d2800000 	mov	x0, #0x0                   	// #0
 110c630:	17fffff7 	b	110c60c <mobj_reg_shm_alloc+0x120>

000000000110c634 <mobj_reg_shm_unguard>:
{
 110c634:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	uint32_t exceptions = cpu_spin_lock_xsave(&reg_shm_slist_lock);
 110c638:	528027a1 	mov	w1, #0x13d                 	// #317
{
 110c63c:	910003fd 	mov	x29, sp
 110c640:	a90153f3 	stp	x19, x20, [sp, #16]
	uint32_t exceptions = cpu_spin_lock_xsave(&reg_shm_slist_lock);
 110c644:	900002f3 	adrp	x19, 1168000 <data.5093+0x9e28>
 110c648:	9128e273 	add	x19, x19, #0xa38
 110c64c:	aa1303e2 	mov	x2, x19
{
 110c650:	f90013f5 	str	x21, [sp, #32]
 110c654:	aa0003f5 	mov	x21, x0
	uint32_t exceptions = cpu_spin_lock_xsave(&reg_shm_slist_lock);
 110c658:	f0000220 	adrp	x0, 1153000 <__func__.3477+0x91>
 110c65c:	91063c00 	add	x0, x0, #0x18f
 110c660:	97fffdca 	bl	110bd88 <cpu_spin_lock_xsave_dldetect>
 110c664:	2a0003f4 	mov	w20, w0
	to_mobj_reg_shm(mobj)->guarded = false;
 110c668:	aa1503e0 	mov	x0, x21
 110c66c:	97fffdfc 	bl	110be5c <to_mobj_reg_shm>
 110c670:	3901101f 	strb	wzr, [x0, #68]
	cpu_spin_unlock_xrestore(&reg_shm_slist_lock, exceptions);
 110c674:	2a1403e1 	mov	w1, w20
 110c678:	aa1303e0 	mov	x0, x19
}
 110c67c:	a94153f3 	ldp	x19, x20, [sp, #16]
 110c680:	f94013f5 	ldr	x21, [sp, #32]
 110c684:	a8c37bfd 	ldp	x29, x30, [sp], #48
	cpu_spin_unlock_xrestore(&reg_shm_slist_lock, exceptions);
 110c688:	17fffec8 	b	110c1a8 <cpu_spin_unlock_xrestore>

000000000110c68c <mobj_reg_shm_get_by_cookie>:
{
 110c68c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	uint32_t exceptions = cpu_spin_lock_xsave(&reg_shm_slist_lock);
 110c690:	52802a01 	mov	w1, #0x150                 	// #336
{
 110c694:	910003fd 	mov	x29, sp
 110c698:	a90153f3 	stp	x19, x20, [sp, #16]
	uint32_t exceptions = cpu_spin_lock_xsave(&reg_shm_slist_lock);
 110c69c:	900002f4 	adrp	x20, 1168000 <data.5093+0x9e28>
 110c6a0:	9128e282 	add	x2, x20, #0xa38
{
 110c6a4:	f90013f5 	str	x21, [sp, #32]
 110c6a8:	aa0003f5 	mov	x21, x0
	uint32_t exceptions = cpu_spin_lock_xsave(&reg_shm_slist_lock);
 110c6ac:	f0000220 	adrp	x0, 1153000 <__func__.3477+0x91>
 110c6b0:	91069000 	add	x0, x0, #0x1a4
 110c6b4:	97fffdb5 	bl	110bd88 <cpu_spin_lock_xsave_dldetect>
 110c6b8:	2a0003e1 	mov	w1, w0
	SLIST_FOREACH(mobj_reg_shm, &reg_shm_list, next)
 110c6bc:	b0000280 	adrp	x0, 115d000 <_curve_names+0x590>
 110c6c0:	f9478413 	ldr	x19, [x0, #3848]
 110c6c4:	b50001f3 	cbnz	x19, 110c700 <mobj_reg_shm_get_by_cookie+0x74>
	cpu_spin_unlock_xrestore(&reg_shm_slist_lock, exceptions);
 110c6c8:	9128e280 	add	x0, x20, #0xa38
 110c6cc:	97fffeb7 	bl	110c1a8 <cpu_spin_unlock_xrestore>
	if (!r)
 110c6d0:	b4000233 	cbz	x19, 110c714 <mobj_reg_shm_get_by_cookie+0x88>
	if (mobj && !refcount_inc(&mobj->refc))
 110c6d4:	91006260 	add	x0, x19, #0x18
 110c6d8:	94001ba7 	bl	1113574 <refcount_inc>
 110c6dc:	72001c1f 	tst	w0, #0xff
 110c6e0:	540001a1 	b.ne	110c714 <mobj_reg_shm_get_by_cookie+0x88>  // b.any
		panic();
 110c6e4:	f0000222 	adrp	x2, 1153000 <__func__.3477+0x91>
 110c6e8:	f0000220 	adrp	x0, 1153000 <__func__.3477+0x91>
 110c6ec:	91033842 	add	x2, x2, #0xce
 110c6f0:	91019c00 	add	x0, x0, #0x67
 110c6f4:	d2800003 	mov	x3, #0x0                   	// #0
 110c6f8:	52801041 	mov	w1, #0x82                  	// #130
 110c6fc:	94001b5b 	bl	1113468 <__do_panic>
		if (mobj_reg_shm->cookie == cookie)
 110c700:	f9401660 	ldr	x0, [x19, #40]
 110c704:	eb0002bf 	cmp	x21, x0
 110c708:	54fffe00 	b.eq	110c6c8 <mobj_reg_shm_get_by_cookie+0x3c>  // b.none
	SLIST_FOREACH(mobj_reg_shm, &reg_shm_list, next)
 110c70c:	f9401273 	ldr	x19, [x19, #32]
 110c710:	17ffffed 	b	110c6c4 <mobj_reg_shm_get_by_cookie+0x38>
}
 110c714:	aa1303e0 	mov	x0, x19
 110c718:	a94153f3 	ldp	x19, x20, [sp, #16]
 110c71c:	f94013f5 	ldr	x21, [sp, #32]
 110c720:	a8c37bfd 	ldp	x29, x30, [sp], #48
 110c724:	d65f03c0 	ret

000000000110c728 <mobj_reg_shm_release_by_cookie>:
{
 110c728:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
	exceptions = cpu_spin_lock_xsave(&reg_shm_slist_lock);
 110c72c:	52802ca1 	mov	w1, #0x165                 	// #357
{
 110c730:	910003fd 	mov	x29, sp
 110c734:	a90153f3 	stp	x19, x20, [sp, #16]
	exceptions = cpu_spin_lock_xsave(&reg_shm_slist_lock);
 110c738:	900002f4 	adrp	x20, 1168000 <data.5093+0x9e28>
 110c73c:	9128e282 	add	x2, x20, #0xa38
{
 110c740:	a9025bf5 	stp	x21, x22, [sp, #32]
 110c744:	aa0003f6 	mov	x22, x0
	exceptions = cpu_spin_lock_xsave(&reg_shm_slist_lock);
 110c748:	f0000235 	adrp	x21, 1153000 <__func__.3477+0x91>
 110c74c:	9106fea0 	add	x0, x21, #0x1bf
{
 110c750:	a90363f7 	stp	x23, x24, [sp, #48]
 110c754:	a9046bf9 	stp	x25, x26, [sp, #64]
	exceptions = cpu_spin_lock_xsave(&reg_shm_slist_lock);
 110c758:	97fffd8c 	bl	110bd88 <cpu_spin_lock_xsave_dldetect>
 110c75c:	2a0003e1 	mov	w1, w0
	SLIST_FOREACH(mobj_reg_shm, &reg_shm_list, next)
 110c760:	b0000280 	adrp	x0, 115d000 <_curve_names+0x590>
 110c764:	f9478413 	ldr	x19, [x0, #3848]
 110c768:	b5000493 	cbnz	x19, 110c7f8 <mobj_reg_shm_release_by_cookie+0xd0>
	cpu_spin_unlock_xrestore(&reg_shm_slist_lock, exceptions);
 110c76c:	9128e294 	add	x20, x20, #0xa38
 110c770:	aa1403e0 	mov	x0, x20
 110c774:	97fffe8d 	bl	110c1a8 <cpu_spin_unlock_xrestore>
	if (!r)
 110c778:	b40007f3 	cbz	x19, 110c874 <mobj_reg_shm_release_by_cookie+0x14c>
	mobj_put(&r->mobj);
 110c77c:	aa1303e0 	mov	x0, x19
	shm_release_waiters++;
 110c780:	b0000296 	adrp	x22, 115d000 <_curve_names+0x590>
	mobj_put(&r->mobj);
 110c784:	97fffe2d 	bl	110c038 <mobj_put>
	mutex_lock(&shm_mu);
 110c788:	b0000297 	adrp	x23, 115d000 <_curve_names+0x590>
 110c78c:	913c82e0 	add	x0, x23, #0xf20
 110c790:	94002371 	bl	1115554 <mutex_lock>
	shm_release_waiters++;
 110c794:	f9479ec0 	ldr	x0, [x22, #3896]
 110c798:	91000400 	add	x0, x0, #0x1
 110c79c:	f9079ec0 	str	x0, [x22, #3896]
	assert(shm_release_waiters);
 110c7a0:	b40003a0 	cbz	x0, 110c814 <mobj_reg_shm_release_by_cookie+0xec>
		condvar_wait(&shm_cv, &shm_mu);
 110c7a4:	b0000298 	adrp	x24, 115d000 <_curve_names+0x590>
		exceptions = cpu_spin_lock_xsave(&reg_shm_slist_lock);
 110c7a8:	9106feba 	add	x26, x21, #0x1bf
		condvar_wait(&shm_cv, &shm_mu);
 110c7ac:	913c4318 	add	x24, x24, #0xf10
		exceptions = cpu_spin_lock_xsave(&reg_shm_slist_lock);
 110c7b0:	aa1403e2 	mov	x2, x20
 110c7b4:	aa1a03e0 	mov	x0, x26
 110c7b8:	52803021 	mov	w1, #0x181                 	// #385
 110c7bc:	97fffd73 	bl	110bd88 <cpu_spin_lock_xsave_dldetect>
 110c7c0:	2a0003f9 	mov	w25, w0
		if (r->release_frees) {
 110c7c4:	39411a60 	ldrb	w0, [x19, #70]
 110c7c8:	34000080 	cbz	w0, 110c7d8 <mobj_reg_shm_release_by_cookie+0xb0>
			reg_shm_free_helper(r);
 110c7cc:	aa1303e0 	mov	x0, x19
			r = NULL;
 110c7d0:	d2800013 	mov	x19, #0x0                   	// #0
			reg_shm_free_helper(r);
 110c7d4:	97fffed3 	bl	110c320 <reg_shm_free_helper>
		cpu_spin_unlock_xrestore(&reg_shm_slist_lock, exceptions);
 110c7d8:	2a1903e1 	mov	w1, w25
 110c7dc:	aa1403e0 	mov	x0, x20
 110c7e0:	97fffe72 	bl	110c1a8 <cpu_spin_unlock_xrestore>
		if (!r)
 110c7e4:	b4000293 	cbz	x19, 110c834 <mobj_reg_shm_release_by_cookie+0x10c>
		condvar_wait(&shm_cv, &shm_mu);
 110c7e8:	913c82e1 	add	x1, x23, #0xf20
 110c7ec:	aa1803e0 	mov	x0, x24
 110c7f0:	94002476 	bl	11159c8 <condvar_wait>
		exceptions = cpu_spin_lock_xsave(&reg_shm_slist_lock);
 110c7f4:	17ffffef 	b	110c7b0 <mobj_reg_shm_release_by_cookie+0x88>
		if (mobj_reg_shm->cookie == cookie)
 110c7f8:	f9401660 	ldr	x0, [x19, #40]
 110c7fc:	eb0002df 	cmp	x22, x0
 110c800:	540003e0 	b.eq	110c87c <mobj_reg_shm_release_by_cookie+0x154>  // b.none
	SLIST_FOREACH(mobj_reg_shm, &reg_shm_list, next)
 110c804:	f9401273 	ldr	x19, [x19, #32]
 110c808:	17ffffd8 	b	110c768 <mobj_reg_shm_release_by_cookie+0x40>
		r = NULL;
 110c80c:	d2800013 	mov	x19, #0x0                   	// #0
 110c810:	17ffffd7 	b	110c76c <mobj_reg_shm_release_by_cookie+0x44>
	assert(shm_release_waiters);
 110c814:	9106fea3 	add	x3, x21, #0x1bf
 110c818:	52802fc2 	mov	w2, #0x17e                 	// #382
	assert(shm_release_waiters);
 110c81c:	d0000221 	adrp	x1, 1152000 <trace_ext_prefix+0x2e>
 110c820:	f0000220 	adrp	x0, 1153000 <__func__.3477+0x91>
 110c824:	913de421 	add	x1, x1, #0xf79
 110c828:	9101f800 	add	x0, x0, #0x7e
 110c82c:	940016a0 	bl	11122ac <_assert_log>
 110c830:	940016b0 	bl	11122f0 <_assert_break>
 110c834:	f9479ec0 	ldr	x0, [x22, #3896]
 110c838:	b5000080 	cbnz	x0, 110c848 <mobj_reg_shm_release_by_cookie+0x120>
 110c83c:	9106fea3 	add	x3, x21, #0x1bf
 110c840:	528031a2 	mov	w2, #0x18d                 	// #397
 110c844:	17fffff6 	b	110c81c <mobj_reg_shm_release_by_cookie+0xf4>
	shm_release_waiters--;
 110c848:	d1000400 	sub	x0, x0, #0x1
 110c84c:	f9079ec0 	str	x0, [x22, #3896]
	mutex_unlock(&shm_mu);
 110c850:	913c82e0 	add	x0, x23, #0xf20
 110c854:	9400231f 	bl	11154d0 <mutex_unlock>
	return TEE_SUCCESS;
 110c858:	52800000 	mov	w0, #0x0                   	// #0
}
 110c85c:	a94153f3 	ldp	x19, x20, [sp, #16]
 110c860:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110c864:	a94363f7 	ldp	x23, x24, [sp, #48]
 110c868:	a9446bf9 	ldp	x25, x26, [sp, #64]
 110c86c:	a8c57bfd 	ldp	x29, x30, [sp], #80
 110c870:	d65f03c0 	ret
		return TEE_ERROR_BAD_PARAMETERS;
 110c874:	129fff20 	mov	w0, #0xffff0006            	// #-65530
 110c878:	17fffff9 	b	110c85c <mobj_reg_shm_release_by_cookie+0x134>
	if (!r || r->guarded || r->releasing)
 110c87c:	79408a60 	ldrh	w0, [x19, #68]
 110c880:	35fffc60 	cbnz	w0, 110c80c <mobj_reg_shm_release_by_cookie+0xe4>
		r->releasing = true;
 110c884:	52800020 	mov	w0, #0x1                   	// #1
 110c888:	39011660 	strb	w0, [x19, #69]
 110c88c:	17ffffb8 	b	110c76c <mobj_reg_shm_release_by_cookie+0x44>

000000000110c890 <mobj_mapped_shm_alloc>:
{
 110c890:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 110c894:	910003fd 	mov	x29, sp
 110c898:	f9000bf3 	str	x19, [sp, #16]
	struct mobj *mobj = mobj_reg_shm_alloc(pages, num_pages,
 110c89c:	97ffff14 	bl	110c4ec <mobj_reg_shm_alloc>
 110c8a0:	aa0003f3 	mov	x19, x0
	if (!mobj)
 110c8a4:	b40000c0 	cbz	x0, 110c8bc <mobj_mapped_shm_alloc+0x2c>
	if (mobj && mobj->ops) {
 110c8a8:	f9400001 	ldr	x1, [x0]
 110c8ac:	b5000101 	cbnz	x1, 110c8cc <mobj_mapped_shm_alloc+0x3c>
		mobj_put(mobj);
 110c8b0:	aa1303e0 	mov	x0, x19
		return NULL;
 110c8b4:	d2800013 	mov	x19, #0x0                   	// #0
		mobj_put(mobj);
 110c8b8:	97fffde0 	bl	110c038 <mobj_put>
}
 110c8bc:	aa1303e0 	mov	x0, x19
 110c8c0:	f9400bf3 	ldr	x19, [sp, #16]
 110c8c4:	a8c27bfd 	ldp	x29, x30, [sp], #32
 110c8c8:	d65f03c0 	ret
		if (mobj->ops->inc_map)
 110c8cc:	f9402021 	ldr	x1, [x1, #64]
 110c8d0:	b4ffff61 	cbz	x1, 110c8bc <mobj_mapped_shm_alloc+0x2c>
			return mobj->ops->inc_map(mobj);
 110c8d4:	d63f0020 	blr	x1
	if (mobj_inc_map(mobj)) {
 110c8d8:	34ffff20 	cbz	w0, 110c8bc <mobj_mapped_shm_alloc+0x2c>
 110c8dc:	17fffff5 	b	110c8b0 <mobj_mapped_shm_alloc+0x20>

000000000110c8e0 <tee_svc_do_call>:
 * uint32_t tee_svc_do_call(struct thread_svc_regs *regs, tee_svc_func func);
 *
 * Called from user_ta_handle_svc()
 */
FUNC tee_svc_do_call , :
	sub	sp, sp, #SC_REC_SIZE
 110c8e0:	d10083ff 	sub	sp, sp, #0x20
	stp	x0, x1, [sp, #SC_REC_X0]
 110c8e4:	a90007e0 	stp	x0, x1, [sp]
	stp	x19, x30, [sp, #SC_REC_X19]
 110c8e8:	a9017bf3 	stp	x19, x30, [sp, #16]
	mov	x19, sp
 110c8ec:	910003f3 	mov	x19, sp

	ldr	x2, [x0, #THREAD_SVC_REG_SPSR]
 110c8f0:	f9400402 	ldr	x2, [x0, #8]
	tst	x2, #(SPSR_MODE_RW_32 << SPSR_MODE_RW_SHIFT)
 110c8f4:	f27c005f 	tst	x2, #0x10
	b.eq	.Lcall_a64
 110c8f8:	54000520 	b.eq	110c99c <tee_svc_do_call+0xbc>  // b.none

	ldp	x5, x6, [x0, #THREAD_SVC_REG_X5]
 110c8fc:	a9439805 	ldp	x5, x6, [x0, #56]
	cmp	x6, #0
 110c900:	f10000df 	cmp	x6, #0x0
	b.eq	.Lno_args_a32
 110c904:	54000380 	b.eq	110c974 <tee_svc_do_call+0x94>  // b.none
         * n32 = nargs_on_stack * 4
         * sp -= ROUNDUP(MAX(n32, n64), 16)
	 *
	 */
	/* n64 = (nargs_on_stack - 4) * 8 */
	sub	x1, x6, #0x4
 110c908:	d10010c1 	sub	x1, x6, #0x4
	lsl	x1, x1, #3
 110c90c:	d37df021 	lsl	x1, x1, #3
	/* n32 = nargs_on_stack * 4 */
	lsl	x0, x6, #2
 110c910:	d37ef4c0 	lsl	x0, x6, #2
	/* sp -= ROUNDUP(MAX(n32, n64), 16) */
	cmp	x1, x0
 110c914:	eb00003f 	cmp	x1, x0
	csel	x0, x1, x0, ge
 110c918:	9a80a020 	csel	x0, x1, x0, ge  // ge = tcont
	add	x0, x0, #0xf
 110c91c:	91003c00 	add	x0, x0, #0xf
	and	x0, x0, #0xfffffffffffffff0
 110c920:	927cec00 	and	x0, x0, #0xfffffffffffffff0
	sub	sp, sp, x0
 110c924:	cb2063ff 	sub	sp, sp, x0
	/*
	 * Find location on stack where to copy the Aarch32 arguments
	 * and do the copy.
	 * tee_svc_copy_from_user(sp, x5, nargs_on_stack * 4)
	 */
	mov	x0, sp
 110c928:	910003e0 	mov	x0, sp
	mov	x1, x5
 110c92c:	aa0503e1 	mov	x1, x5
	add	x2, xzr, x6, lsl #2
 110c930:	8b060be2 	add	x2, xzr, x6, lsl #2
	bl	copy_from_user
 110c934:	9400216f 	bl	1114ef0 <copy_from_user>
	/* If copy failed return the error */
	cmp	x0, #0
 110c938:	f100001f 	cmp	x0, #0x0
	bne	.Lret
 110c93c:	54000401 	b.ne	110c9bc <tee_svc_do_call+0xdc>  // b.any
	 * Load arguments into w4..w7, we're loading junk into unused
	 * registers, but it's quicker than trying to figure out how
	 * many registers to load into.
	 */
	/* x0 = nargs_on_stack */
	ldr	x0, [x19, #SC_REC_X0]
 110c940:	f9400260 	ldr	x0, [x19]
	ldr	x0, [x0, #THREAD_SVC_REG_X6]
 110c944:	f9402000 	ldr	x0, [x0, #64]
	load_wregs sp, 0, 4, 7
 110c948:	294017e4 	ldp	w4, w5, [sp]
 110c94c:	29411fe6 	ldp	w6, w7, [sp, #8]
	 *	x2 += 8
	 * }
	 * sp = x0
	 */
	/* n64 = (nargs_on_stack - 4) * 8 */
	subs	x2, x0, #0x4
 110c950:	f1001002 	subs	x2, x0, #0x4
	b.le	.Lno_args_a32
 110c954:	5400010d 	b.le	110c974 <tee_svc_do_call+0x94>
	lsl	x2, x2, #3
 110c958:	d37df042 	lsl	x2, x2, #3
	mov	x0, x2
 110c95c:	aa0203e0 	mov	x0, x2

.Lcpy_to_stack:
	ldr	w3, [x1], #4
 110c960:	b8404423 	ldr	w3, [x1], #4
	str	x3, [x2], #8
 110c964:	f8008443 	str	x3, [x2], #8
	cmp	x2, x19
 110c968:	eb13005f 	cmp	x2, x19
	b.ne	.Lcpy_to_stack
 110c96c:	54ffffa1 	b.ne	110c960 <tee_svc_do_call+0x80>  // b.any
	mov	sp, x0
 110c970:	9100001f 	mov	sp, x0


.Lno_args_a32: /* Load the first 4 arguments to function */
	ldr	x9, [x19, #SC_REC_X0]
 110c974:	f9400269 	ldr	x9, [x19]
	load_xregs x9, THREAD_SVC_REG_X0, 0, 3
 110c978:	a9410520 	ldp	x0, x1, [x9, #16]
 110c97c:	a9420d22 	ldp	x2, x3, [x9, #32]
	mov	w0, w0
 110c980:	2a0003e0 	mov	w0, w0
	mov	w1, w1
 110c984:	2a0103e1 	mov	w1, w1
	mov	w2, w2
 110c988:	2a0203e2 	mov	w2, w2
	mov	w3, w3
 110c98c:	2a0303e3 	mov	w3, w3

	/* Call the svc function */
	ldr	x16, [x19, #SC_REC_X1]
 110c990:	f9400670 	ldr	x16, [x19, #8]
	blr	x16
 110c994:	d63f0200 	blr	x16
	b	.Lret
 110c998:	14000009 	b	110c9bc <tee_svc_do_call+0xdc>

.Lcall_a64: /* Load the first 8 arguments to function */
	ldr	x9, [x19, #SC_REC_X0]
 110c99c:	f9400269 	ldr	x9, [x19]
	load_xregs x9, THREAD_SVC_REG_X0, 0, 8
 110c9a0:	a9410520 	ldp	x0, x1, [x9, #16]
 110c9a4:	a9420d22 	ldp	x2, x3, [x9, #32]
 110c9a8:	a9431524 	ldp	x4, x5, [x9, #48]
 110c9ac:	a9441d26 	ldp	x6, x7, [x9, #64]
 110c9b0:	f9402928 	ldr	x8, [x9, #80]

	/* Call the svc function */
	ldr	x16, [x19, #SC_REC_X1]
 110c9b4:	f9400670 	ldr	x16, [x19, #8]
	blr	x16
 110c9b8:	d63f0200 	blr	x16

.Lret:
	mov	sp, x19
 110c9bc:	9100027f 	mov	sp, x19
	ldp	x19, x30, [sp, #SC_REC_X19]
 110c9c0:	a9417bf3 	ldp	x19, x30, [sp, #16]
	add	sp, sp, #SC_REC_SIZE
 110c9c4:	910083ff 	add	sp, sp, #0x20
	ret
 110c9c8:	d65f03c0 	ret

000000000110c9cc <syscall_sys_return>:
 * The argument ret is already in x0 so we don't touch that and let it
 * propagate as return value of the called
 * tee_svc_unwind_enter_user_mode().
 */
FUNC syscall_sys_return , :
	mov	x1, #0  /* panic = false */
 110c9cc:	d2800001 	mov	x1, #0x0                   	// #0
	mov	x2, #0  /* panic_code = 0 */
 110c9d0:	d2800002 	mov	x2, #0x0                   	// #0
	ldr	x3, [x19, #SC_REC_X0] /* pointer to struct thread_svc_regs */
 110c9d4:	f9400263 	ldr	x3, [x19]
	b	tee_svc_sys_return_helper
 110c9d8:	14000088 	b	110cbf8 <tee_svc_sys_return_helper>

000000000110c9dc <syscall_panic>:
 * But internally the function depends on being called from
 * tee_svc_do_call() to be able to chase x19 in order to get hold of a
 * pointer to struct thread_svc_regs.
 */
FUNC syscall_panic , :
	mov	x1, #1  /* panic = true */
 110c9dc:	d2800021 	mov	x1, #0x1                   	// #1
	mov	x2, x0  /* code */
 110c9e0:	aa0003e2 	mov	x2, x0
	ldr	w0, =TEE_ERROR_TARGET_DEAD
 110c9e4:	18000060 	ldr	w0, 110c9f0 <syscall_panic+0x14>
	ldr	x3, [x19, #SC_REC_X0] /* pointer to struct thread_svc_regs */
 110c9e8:	f9400263 	ldr	x3, [x19]
	b	tee_svc_sys_return_helper
 110c9ec:	14000083 	b	110cbf8 <tee_svc_sys_return_helper>
 110c9f0:	ffff3024 	.word	0xffff3024

000000000110c9f4 <trace_syscall.part.0>:
#ifdef TRACE_SYSCALLS
static void trace_syscall(size_t num)
{
	if (num == TEE_SCN_RETURN || num == TEE_SCN_LOG || num > TEE_SCN_MAX)
		return;
	FMSG("syscall #%zu (%s)", num, tee_svc_syscall_table[num].name);
 110c9f4:	f0000261 	adrp	x1, 115b000 <__vcore_unpg_rw_start>
 110c9f8:	9106e021 	add	x1, x1, #0x1b8
 110c9fc:	8b001021 	add	x1, x1, x0, lsl #4
static void trace_syscall(size_t num)
 110ca00:	aa0003e5 	mov	x5, x0
	FMSG("syscall #%zu (%s)", num, tee_svc_syscall_table[num].name);
 110ca04:	f0000224 	adrp	x4, 1153000 <__func__.3477+0x91>
 110ca08:	52800023 	mov	w3, #0x1                   	// #1
 110ca0c:	9107cc84 	add	x4, x4, #0x1f3
 110ca10:	52800082 	mov	w2, #0x4                   	// #4
 110ca14:	f9400426 	ldr	x6, [x1, #8]
 110ca18:	f0000220 	adrp	x0, 1153000 <__func__.3477+0x91>
 110ca1c:	528012e1 	mov	w1, #0x97                  	// #151
 110ca20:	91223400 	add	x0, x0, #0x88d
 110ca24:	1400e0c8 	b	1144d44 <trace_printf>

000000000110ca28 <user_ta_handle_svc>:
	return load_no_speculate(&sc_table[num].fn, &sc_table[0].fn,
				 &sc_table[TEE_SCN_MAX].fn + 1);
}

bool user_ta_handle_svc(struct thread_svc_regs *regs)
{
 110ca28:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 110ca2c:	910003fd 	mov	x29, sp
 110ca30:	a90153f3 	stp	x19, x20, [sp, #16]
 110ca34:	aa0003f3 	mov	x19, x0
	if (((regs->spsr >> SPSR_MODE_RW_SHIFT) & SPSR_MODE_RW_MASK) ==
 110ca38:	f9400400 	ldr	x0, [x0, #8]
		*scn = regs->x8;
 110ca3c:	f9402a74 	ldr	x20, [x19, #80]
{
 110ca40:	f90013f5 	str	x21, [sp, #32]
	if (((regs->spsr >> SPSR_MODE_RW_SHIFT) & SPSR_MODE_RW_MASK) ==
 110ca44:	36200340 	tbz	w0, #4, 110caac <.ns131+0x24>
		*scn = regs->x7;
 110ca48:	a9445275 	ldp	x21, x20, [x19, #64]
	if (num == TEE_SCN_RETURN || num == TEE_SCN_LOG || num > TEE_SCN_MAX)
 110ca4c:	d1000a80 	sub	x0, x20, #0x2
 110ca50:	f101101f 	cmp	x0, #0x44
 110ca54:	54000528 	b.hi	110caf8 <.ns131+0x70>  // b.pmore
 110ca58:	aa1403e0 	mov	x0, x20
 110ca5c:	97ffffe6 	bl	110c9f4 <trace_syscall.part.0>

	get_scn_max_args(regs, &scn, &max_args);

	trace_syscall(scn);

	if (max_args > TEE_SVC_MAX_ARGS) {
 110ca60:	f10022bf 	cmp	x21, #0x8
 110ca64:	54000288 	b.hi	110cab4 <.ns131+0x2c>  // b.pmore
	return load_no_speculate(&sc_table[num].fn, &sc_table[0].fn,
 110ca68:	f0000260 	adrp	x0, 115b000 <__vcore_unpg_rw_start>
 110ca6c:	9106e000 	add	x0, x0, #0x1b8
 110ca70:	8b141002 	add	x2, x0, x20, lsl #4
 110ca74:	9111a003 	add	x3, x0, #0x468
 110ca78:	eb00005f 	cmp	x2, x0
 110ca7c:	fa432042 	ccmp	x2, x3, #0x2, cs  // cs = hs, nlast
 110ca80:	54000042 	b.cs	110ca88 <.ns131>  // b.hs, b.nlast
 110ca84:	f9400041 	ldr	x1, [x2]

000000000110ca88 <.ns131>:
 110ca88:	9a9f3021 	csel	x1, x1, xzr, cc  // cc = lo, ul, last
 110ca8c:	d503229f 	csdb

	scf = get_tee_syscall_func(scn);

	ftrace_syscall_enter(scn);

	set_svc_retval(regs, tee_svc_do_call(regs, scf));
 110ca90:	aa1303e0 	mov	x0, x19
 110ca94:	97ffff93 	bl	110c8e0 <tee_svc_do_call>

	/*
	 * Return true if we're to return to user mode,
	 * thread_svc_handler() will take care of the rest.
	 */
	return scn != TEE_SCN_RETURN && scn != TEE_SCN_PANIC;
 110ca98:	f27efa9f 	tst	x20, #0xfffffffffffffffd
	set_svc_retval(regs, tee_svc_do_call(regs, scf));
 110ca9c:	2a0003e0 	mov	w0, w0
 110caa0:	f9000a60 	str	x0, [x19, #16]
	return scn != TEE_SCN_RETURN && scn != TEE_SCN_PANIC;
 110caa4:	1a9f07e0 	cset	w0, ne  // ne = any
 110caa8:	14000010 	b	110cae8 <.ns131+0x60>
 110caac:	927c0015 	and	x21, x0, #0x10
 110cab0:	17ffffe7 	b	110ca4c <user_ta_handle_svc+0x24>
		DMSG("Too many arguments for SCN %zu (%zu)", scn, max_args);
 110cab4:	aa1503e6 	mov	x6, x21
 110cab8:	aa1403e5 	mov	x5, x20
 110cabc:	f0000224 	adrp	x4, 1153000 <__func__.3477+0x91>
 110cac0:	52800023 	mov	w3, #0x1                   	// #1
 110cac4:	91081484 	add	x4, x4, #0x205
 110cac8:	52800062 	mov	w2, #0x3                   	// #3
 110cacc:	52802081 	mov	w1, #0x104                 	// #260
 110cad0:	f0000220 	adrp	x0, 1153000 <__func__.3477+0x91>
 110cad4:	91226c00 	add	x0, x0, #0x89b
 110cad8:	9400e09b 	bl	1144d44 <trace_printf>
	regs->x0 = ret_val;
 110cadc:	d2bfffe0 	mov	x0, #0xffff0000            	// #4294901760
 110cae0:	f9000a60 	str	x0, [x19, #16]
		return true; /* return to user mode */
 110cae4:	52800020 	mov	w0, #0x1                   	// #1
}
 110cae8:	a94153f3 	ldp	x19, x20, [sp, #16]
 110caec:	f94013f5 	ldr	x21, [sp, #32]
 110caf0:	a8c37bfd 	ldp	x29, x30, [sp], #48
 110caf4:	d65f03c0 	ret
	if (max_args > TEE_SVC_MAX_ARGS) {
 110caf8:	f10022bf 	cmp	x21, #0x8
 110cafc:	54fffdc8 	b.hi	110cab4 <.ns131+0x2c>  // b.pmore
	if (num > TEE_SCN_MAX)
 110cb00:	f1011a9f 	cmp	x20, #0x46
 110cb04:	54fffb29 	b.ls	110ca68 <user_ta_handle_svc+0x40>  // b.plast
		return (syscall_t)syscall_not_supported;
 110cb08:	d0000261 	adrp	x1, 115a000 <__scattered_array_1phys_mem_map+0x8>
 110cb0c:	f941f021 	ldr	x1, [x1, #992]
 110cb10:	17ffffe0 	b	110ca90 <.ns131+0x8>

000000000110cb14 <ldelf_handle_svc>:
	return load_no_speculate(&sc_table[num].fn, &sc_table[0].fn,
				 &sc_table[LDELF_SCN_MAX].fn + 1);
}

bool ldelf_handle_svc(struct thread_svc_regs *regs)
{
 110cb14:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 110cb18:	910003fd 	mov	x29, sp
 110cb1c:	a90153f3 	stp	x19, x20, [sp, #16]
 110cb20:	aa0003f3 	mov	x19, x0
	if (((regs->spsr >> SPSR_MODE_RW_SHIFT) & SPSR_MODE_RW_MASK) ==
 110cb24:	f9400400 	ldr	x0, [x0, #8]
		*scn = regs->x8;
 110cb28:	f9402a74 	ldr	x20, [x19, #80]
{
 110cb2c:	f90013f5 	str	x21, [sp, #32]
	if (((regs->spsr >> SPSR_MODE_RW_SHIFT) & SPSR_MODE_RW_MASK) ==
 110cb30:	36200340 	tbz	w0, #4, 110cb98 <ldelf_handle_svc+0x84>
		*scn = regs->x7;
 110cb34:	a9445275 	ldp	x21, x20, [x19, #64]
	if (num == TEE_SCN_RETURN || num == TEE_SCN_LOG || num > TEE_SCN_MAX)
 110cb38:	d1000a80 	sub	x0, x20, #0x2
 110cb3c:	f101101f 	cmp	x0, #0x44
 110cb40:	54000068 	b.hi	110cb4c <ldelf_handle_svc+0x38>  // b.pmore
 110cb44:	aa1403e0 	mov	x0, x20
 110cb48:	97ffffab 	bl	110c9f4 <trace_syscall.part.0>

	get_scn_max_args(regs, &scn, &max_args);

	trace_syscall(scn);

	if (max_args > TEE_SVC_MAX_ARGS) {
 110cb4c:	f10022bf 	cmp	x21, #0x8
 110cb50:	54000289 	b.ls	110cba0 <ldelf_handle_svc+0x8c>  // b.plast
		DMSG("Too many arguments for SCN %zu (%zu)", scn, max_args);
 110cb54:	aa1503e6 	mov	x6, x21
 110cb58:	aa1403e5 	mov	x5, x20
 110cb5c:	f0000224 	adrp	x4, 1153000 <__func__.3477+0x91>
 110cb60:	52800023 	mov	w3, #0x1                   	// #1
 110cb64:	91081484 	add	x4, x4, #0x205
 110cb68:	52800062 	mov	w2, #0x3                   	// #3
 110cb6c:	52802641 	mov	w1, #0x132                 	// #306
 110cb70:	f0000220 	adrp	x0, 1153000 <__func__.3477+0x91>
 110cb74:	9122b800 	add	x0, x0, #0x8ae
 110cb78:	9400e073 	bl	1144d44 <trace_printf>
	regs->x0 = ret_val;
 110cb7c:	d2bfffe0 	mov	x0, #0xffff0000            	// #4294901760
 110cb80:	f9000a60 	str	x0, [x19, #16]
		set_svc_retval(regs, TEE_ERROR_GENERIC);
		return true; /* return to user mode */
 110cb84:	52800020 	mov	w0, #0x1                   	// #1
	/*
	 * Return true if we're to return to user mode,
	 * thread_svc_handler() will take care of the rest.
	 */
	return scn != LDELF_RETURN && scn != LDELF_PANIC;
}
 110cb88:	a94153f3 	ldp	x19, x20, [sp, #16]
 110cb8c:	f94013f5 	ldr	x21, [sp, #32]
 110cb90:	a8c37bfd 	ldp	x29, x30, [sp], #48
 110cb94:	d65f03c0 	ret
 110cb98:	927c0015 	and	x21, x0, #0x10
 110cb9c:	17ffffe7 	b	110cb38 <ldelf_handle_svc+0x24>
	if (num > LDELF_SCN_MAX)
 110cba0:	f1002e9f 	cmp	x20, #0xb
 110cba4:	54000248 	b.hi	110cbec <.ns475+0x24>  // b.pmore
	return load_no_speculate(&sc_table[num].fn, &sc_table[0].fn,
 110cba8:	f0000260 	adrp	x0, 115b000 <__vcore_unpg_rw_start>
 110cbac:	9103e000 	add	x0, x0, #0xf8
 110cbb0:	8b141002 	add	x2, x0, x20, lsl #4
 110cbb4:	9102e003 	add	x3, x0, #0xb8
 110cbb8:	eb00005f 	cmp	x2, x0
 110cbbc:	fa432042 	ccmp	x2, x3, #0x2, cs  // cs = hs, nlast
 110cbc0:	54000042 	b.cs	110cbc8 <.ns475>  // b.hs, b.nlast
 110cbc4:	f9400041 	ldr	x1, [x2]

000000000110cbc8 <.ns475>:
 110cbc8:	9a9f3021 	csel	x1, x1, xzr, cc  // cc = lo, ul, last
 110cbcc:	d503229f 	csdb
	set_svc_retval(regs, tee_svc_do_call(regs, scf));
 110cbd0:	aa1303e0 	mov	x0, x19
 110cbd4:	97ffff43 	bl	110c8e0 <tee_svc_do_call>
	return scn != LDELF_RETURN && scn != LDELF_PANIC;
 110cbd8:	f27efa9f 	tst	x20, #0xfffffffffffffffd
	set_svc_retval(regs, tee_svc_do_call(regs, scf));
 110cbdc:	2a0003e0 	mov	w0, w0
 110cbe0:	f9000a60 	str	x0, [x19, #16]
	return scn != LDELF_RETURN && scn != LDELF_PANIC;
 110cbe4:	1a9f07e0 	cset	w0, ne  // ne = any
 110cbe8:	17ffffe8 	b	110cb88 <ldelf_handle_svc+0x74>
		return (syscall_t)syscall_not_supported;
 110cbec:	d0000261 	adrp	x1, 115a000 <__scattered_array_1phys_mem_map+0x8>
 110cbf0:	f941f021 	ldr	x1, [x1, #992]
 110cbf4:	17fffff7 	b	110cbd0 <.ns475+0x8>

000000000110cbf8 <tee_svc_sys_return_helper>:
#endif /*ARM64*/

uint32_t tee_svc_sys_return_helper(uint32_t ret, bool panic,
				   uint32_t panic_code,
				   struct thread_svc_regs *regs)
{
 110cbf8:	a9b47bfd 	stp	x29, x30, [sp, #-192]!
 110cbfc:	910003fd 	mov	x29, sp
 110cc00:	a90153f3 	stp	x19, x20, [sp, #16]
 110cc04:	a9025bf5 	stp	x21, x22, [sp, #32]
 110cc08:	2a0203f6 	mov	w22, w2
 110cc0c:	aa0303f5 	mov	x21, x3
 110cc10:	a90363f7 	stp	x23, x24, [sp, #48]
 110cc14:	2a0003f8 	mov	w24, w0
 110cc18:	a9046bf9 	stp	x25, x26, [sp, #64]
	if (panic) {
 110cc1c:	72001c39 	ands	w25, w1, #0xff
{
 110cc20:	a90573fb 	stp	x27, x28, [sp, #80]
	if (panic) {
 110cc24:	54000740 	b.eq	110cd0c <tee_svc_sys_return_helper+0x114>  // b.none
		TAMSG_RAW("");
 110cc28:	d0000237 	adrp	x23, 1152000 <trace_ext_prefix+0x2e>
 110cc2c:	9104aaf7 	add	x23, x23, #0x12a
 110cc30:	aa1703e4 	mov	x4, x23
 110cc34:	52800023 	mov	w3, #0x1                   	// #1
 110cc38:	52800022 	mov	w2, #0x1                   	// #1
 110cc3c:	52800001 	mov	w1, #0x0                   	// #0
 110cc40:	d2800000 	mov	x0, #0x0                   	// #0
 110cc44:	9400e040 	bl	1144d44 <trace_printf>
		TAMSG_RAW("TA panicked with code 0x%" PRIx32, panic_code);
 110cc48:	2a1603e5 	mov	w5, w22
 110cc4c:	90000244 	adrp	x4, 1154000 <__func__.1786+0x8>
 110cc50:	91357c84 	add	x4, x4, #0xd5f
 110cc54:	52800023 	mov	w3, #0x1                   	// #1
 110cc58:	52800022 	mov	w2, #0x1                   	// #1
 110cc5c:	52800001 	mov	w1, #0x0                   	// #0
 110cc60:	d2800000 	mov	x0, #0x0                   	// #0
 110cc64:	9400e038 	bl	1144d44 <trace_printf>
	struct thread_specific_data *tsd = thread_get_tsd();
 110cc68:	97ffe3d6 	bl	1105bc0 <thread_get_tsd>
 110cc6c:	aa0003f3 	mov	x19, x0
	struct ts_session *s = ts_get_current_session();
 110cc70:	94001f5c 	bl	11149e0 <ts_get_current_session>
	struct user_ta_ctx *utc = to_user_ta_ctx(s->ctx);
 110cc74:	f9400814 	ldr	x20, [x0, #16]
 110cc78:	aa1403e0 	mov	x0, x20
 110cc7c:	9400255c 	bl	11161ec <is_user_ta_ctx>
 110cc80:	72001c1f 	tst	w0, #0xff
 110cc84:	54000141 	b.ne	110ccac <tee_svc_sys_return_helper+0xb4>  // b.any
 110cc88:	f0000223 	adrp	x3, 1153000 <__func__.3477+0x91>
 110cc8c:	b0000221 	adrp	x1, 1151000 <small_prime+0x168>
 110cc90:	9121f863 	add	x3, x3, #0x87e
 110cc94:	91081021 	add	x1, x1, #0x204
 110cc98:	b0000220 	adrp	x0, 1151000 <small_prime+0x168>
 110cc9c:	91088800 	add	x0, x0, #0x222
 110cca0:	52800702 	mov	w2, #0x38                  	// #56
 110cca4:	94001582 	bl	11122ac <_assert_log>
 110cca8:	94001592 	bl	11122f0 <_assert_break>
	if (vm_check_access_rights(&utc->uctx,
 110ccac:	385d0280 	ldurb	w0, [x20, #-48]
 110ccb0:	d280021a 	mov	x26, #0x10                  	// #16
 110ccb4:	f9400ea2 	ldr	x2, [x21, #24]
 110ccb8:	7100001f 	cmp	w0, #0x0
 110ccbc:	d2800703 	mov	x3, #0x38                  	// #56
 110ccc0:	d10a6280 	sub	x0, x20, #0x298
 110ccc4:	9a9a1063 	csel	x3, x3, x26, ne  // ne = any
 110ccc8:	52800061 	mov	w1, #0x3                   	// #3
 110cccc:	940032c8 	bl	11197ec <vm_check_access_rights>
 110ccd0:	34000320 	cbz	w0, 110cd34 <tee_svc_sys_return_helper+0x13c>
		TAMSG_RAW("");
 110ccd4:	aa1703e4 	mov	x4, x23
 110ccd8:	52800023 	mov	w3, #0x1                   	// #1
 110ccdc:	52800022 	mov	w2, #0x1                   	// #1
 110cce0:	52800001 	mov	w1, #0x0                   	// #0
 110cce4:	d2800000 	mov	x0, #0x0                   	// #0
 110cce8:	9400e017 	bl	1144d44 <trace_printf>
		TAMSG_RAW("Can't unwind invalid user stack 0x%" PRIxUA,
 110ccec:	f9400ea5 	ldr	x5, [x21, #24]
 110ccf0:	f0000224 	adrp	x4, 1153000 <__func__.3477+0x91>
 110ccf4:	52800023 	mov	w3, #0x1                   	// #1
 110ccf8:	9108a884 	add	x4, x4, #0x22a
 110ccfc:	52800022 	mov	w2, #0x1                   	// #1
 110cd00:	52800001 	mov	w1, #0x0                   	// #0
 110cd04:	d2800000 	mov	x0, #0x0                   	// #0
 110cd08:	9400e00f 	bl	1144d44 <trace_printf>
	regs->x1 = panic;
	regs->x2 = panic_code;
#endif

	return ret;
}
 110cd0c:	2a1803e0 	mov	w0, w24
	regs->x1 = panic;
 110cd10:	92401f39 	and	x25, x25, #0xff
}
 110cd14:	a94153f3 	ldp	x19, x20, [sp, #16]
 110cd18:	a94363f7 	ldp	x23, x24, [sp, #48]
 110cd1c:	a94573fb 	ldp	x27, x28, [sp, #80]
	regs->x2 = panic_code;
 110cd20:	a901dab9 	stp	x25, x22, [x21, #24]
}
 110cd24:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110cd28:	a9446bf9 	ldp	x25, x26, [sp, #64]
 110cd2c:	a8cc7bfd 	ldp	x29, x30, [sp], #192
 110cd30:	d65f03c0 	ret
	if (utc->uctx.is_32bit)
 110cd34:	385d0281 	ldurb	w1, [x20, #-48]
	tsd->abort_type = ABORT_TYPE_USER_MODE_PANIC;
 110cd38:	d2800060 	mov	x0, #0x3                   	// #3
	tsd->abort_va = 0;
 110cd3c:	a9027e60 	stp	x0, xzr, [x19, #32]
	if (utc->uctx.is_32bit)
 110cd40:	9100e260 	add	x0, x19, #0x38
 110cd44:	f9400eb4 	ldr	x20, [x21, #24]
 110cd48:	34000401 	cbz	w1, 110cdc8 <tee_svc_sys_return_helper+0x1d0>
		.x0 = pushed[1],
 110cd4c:	29403697 	ldp	w23, w13, [x20]
	tsd->abort_regs = (struct thread_abort_regs){
 110cd50:	d2802202 	mov	x2, #0x110                 	// #272
		.x2 = pushed[3],
 110cd54:	29412e8c 	ldp	w12, w11, [x20, #8]
	tsd->abort_regs = (struct thread_abort_regs){
 110cd58:	52800001 	mov	w1, #0x0                   	// #0
		.x4 = pushed[5],
 110cd5c:	2942268a 	ldp	w10, w9, [x20, #16]
		.x3 = pushed[4],
 110cd60:	a909abe9 	stp	x9, x10, [sp, #152]
		.x6 = pushed[7],
 110cd64:	29431e88 	ldp	w8, w7, [x20, #24]
		.x5 = pushed[6],
 110cd68:	a908a3e7 	stp	x7, x8, [sp, #136]
		.x8 = pushed[9],
 110cd6c:	29441686 	ldp	w6, w5, [x20, #32]
		.x7 = pushed[8],
 110cd70:	a9079be5 	stp	x5, x6, [sp, #120]
		.x10 = pushed[11],
 110cd74:	29450e84 	ldp	w4, w3, [x20, #40]
		.x9 = pushed[10],
 110cd78:	a90693e3 	stp	x3, x4, [sp, #104]
		.x14 = pushed[13],
 110cd7c:	29466e9c 	ldp	w28, w27, [x20, #48]
		.x1 = pushed[2],
 110cd80:	a90ab3eb 	stp	x11, x12, [sp, #168]
		.x0 = pushed[1],
 110cd84:	f9005fed 	str	x13, [sp, #184]
	tsd->abort_regs = (struct thread_abort_regs){
 110cd88:	9400dbd6 	bl	1143ce0 <memset>
 110cd8c:	a94693e3 	ldp	x3, x4, [sp, #104]
 110cd90:	a908f263 	stp	x3, x28, [x19, #136]
 110cd94:	a9479be5 	ldp	x5, x6, [sp, #120]
 110cd98:	a9079265 	stp	x5, x4, [x19, #120]
 110cd9c:	a948a3e7 	ldp	x7, x8, [sp, #136]
 110cda0:	a9069a67 	stp	x7, x6, [x19, #104]
 110cda4:	a949abe9 	ldp	x9, x10, [sp, #152]
 110cda8:	a905a269 	stp	x9, x8, [x19, #88]
 110cdac:	a94ab3eb 	ldp	x11, x12, [sp, #168]
 110cdb0:	a904aa6b 	stp	x11, x10, [x19, #72]
 110cdb4:	f9405fed 	ldr	x13, [sp, #184]
 110cdb8:	a903b26d 	stp	x13, x12, [x19, #56]
 110cdbc:	a90a6e74 	stp	x20, x27, [x19, #160]
 110cdc0:	a9136a77 	stp	x23, x26, [x19, #304]
}
 110cdc4:	17ffffd2 	b	110cd0c <tee_svc_sys_return_helper+0x114>
		.elr = pushed[1],
 110cdc8:	a9405297 	ldp	x23, x20, [x20]
	tsd->abort_regs = (struct thread_abort_regs){
 110cdcc:	d2802202 	mov	x2, #0x110                 	// #272
 110cdd0:	52800001 	mov	w1, #0x0                   	// #0
 110cdd4:	9400dbc3 	bl	1143ce0 <memset>
 110cdd8:	f9009277 	str	x23, [x19, #288]
 110cddc:	f9009a74 	str	x20, [x19, #304]
}
 110cde0:	17ffffcb 	b	110cd0c <tee_svc_sys_return_helper+0x114>

000000000110cde4 <tee_entry_get_api_call_count>:
	return ret;
}

void __weak tee_entry_get_api_call_count(struct thread_smc_args *args)
{
	args->a0 = tee_entry_generic_get_api_call_count();
 110cde4:	d2800181 	mov	x1, #0xc                   	// #12
 110cde8:	f9000001 	str	x1, [x0]
}
 110cdec:	d65f03c0 	ret

000000000110cdf0 <tee_entry_get_api_uuid>:

void __weak tee_entry_get_api_uuid(struct thread_smc_args *args)
{
	args->a0 = OPTEE_MSG_UID_0;
 110cdf0:	d2967c01 	mov	x1, #0xb3e0                	// #46048
 110cdf4:	f2a709e1 	movk	x1, #0x384f, lsl #16
 110cdf8:	f9000001 	str	x1, [x0]
	args->a1 = OPTEE_MSG_UID_1;
 110cdfc:	d2823c61 	mov	x1, #0x11e3                	// #4579
 110ce00:	f2bcff01 	movk	x1, #0xe7f8, lsl #16
 110ce04:	f9000401 	str	x1, [x0, #8]
	args->a2 = OPTEE_MSG_UID_2;
 110ce08:	d2800041 	mov	x1, #0x2                   	// #2
 110ce0c:	f2b5ec61 	movk	x1, #0xaf63, lsl #16
 110ce10:	f9000801 	str	x1, [x0, #16]
	args->a3 = OPTEE_MSG_UID_3;
 110ce14:	d298a361 	mov	x1, #0xc51b                	// #50459
 110ce18:	f2b4baa1 	movk	x1, #0xa5d5, lsl #16
 110ce1c:	f9000c01 	str	x1, [x0, #24]
}
 110ce20:	d65f03c0 	ret

000000000110ce24 <tee_entry_get_api_revision>:

void __weak tee_entry_get_api_revision(struct thread_smc_args *args)
{
	args->a0 = OPTEE_MSG_REVISION_MAJOR;
 110ce24:	d2800041 	mov	x1, #0x2                   	// #2
	args->a1 = OPTEE_MSG_REVISION_MINOR;
 110ce28:	a9007c01 	stp	x1, xzr, [x0]
}
 110ce2c:	d65f03c0 	ret

000000000110ce30 <tee_entry_get_os_uuid>:

void __weak tee_entry_get_os_uuid(struct thread_smc_args *args)
{
	args->a0 = OPTEE_MSG_OS_OPTEE_UUID_0;
 110ce30:	d28f1c01 	mov	x1, #0x78e0                	// #30944
 110ce34:	f2a90c21 	movk	x1, #0x4861, lsl #16
 110ce38:	f9000001 	str	x1, [x0]
	args->a1 = OPTEE_MSG_OS_OPTEE_UUID_1;
 110ce3c:	d2823c61 	mov	x1, #0x11e3                	// #4579
 110ce40:	f2bcff01 	movk	x1, #0xe7f8, lsl #16
 110ce44:	f9000401 	str	x1, [x0, #8]
	args->a2 = OPTEE_MSG_OS_OPTEE_UUID_2;
 110ce48:	d2800041 	mov	x1, #0x2                   	// #2
 110ce4c:	f2b78bc1 	movk	x1, #0xbc5e, lsl #16
 110ce50:	f9000801 	str	x1, [x0, #16]
	args->a3 = OPTEE_MSG_OS_OPTEE_UUID_3;
 110ce54:	d298a361 	mov	x1, #0xc51b                	// #50459
 110ce58:	f2b4baa1 	movk	x1, #0xa5d5, lsl #16
 110ce5c:	f9000c01 	str	x1, [x0, #24]
}
 110ce60:	d65f03c0 	ret

000000000110ce64 <tee_entry_get_os_revision>:

void __weak tee_entry_get_os_revision(struct thread_smc_args *args)
{
	args->a0 = CFG_OPTEE_REVISION_MAJOR;
 110ce64:	d2800061 	mov	x1, #0x3                   	// #3
 110ce68:	f9000001 	str	x1, [x0]
	args->a1 = CFG_OPTEE_REVISION_MINOR;
 110ce6c:	d28001a1 	mov	x1, #0xd                   	// #13
 110ce70:	f9000401 	str	x1, [x0, #8]
	args->a2 = TEE_IMPL_GIT_SHA1;
 110ce74:	f900081f 	str	xzr, [x0, #16]
}
 110ce78:	d65f03c0 	ret

000000000110ce7c <__tee_entry_fast>:
{
 110ce7c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	switch (args->a0) {
 110ce80:	d28001e2 	mov	x2, #0xf                   	// #15
 110ce84:	f2b64002 	movk	x2, #0xb200, lsl #16
{
 110ce88:	910003fd 	mov	x29, sp
	switch (args->a0) {
 110ce8c:	f9400001 	ldr	x1, [x0]
{
 110ce90:	f9000bf3 	str	x19, [sp, #16]
 110ce94:	aa0003f3 	mov	x19, x0
	switch (args->a0) {
 110ce98:	eb02003f 	cmp	x1, x2
 110ce9c:	54000228 	b.hi	110cee0 <__tee_entry_fast+0x64>  // b.pmore
 110cea0:	12a9c000 	mov	w0, #0xb1ffffff            	// #-1308622849
 110cea4:	eb00003f 	cmp	x1, x0
 110cea8:	54000c69 	b.ls	110d034 <__tee_entry_fast+0x1b8>  // b.plast
 110ceac:	929fffe0 	mov	x0, #0xffffffffffff0000    	// #-65536
 110ceb0:	f2a9c000 	movk	x0, #0x4e00, lsl #16
 110ceb4:	8b000021 	add	x1, x1, x0
 110ceb8:	f1003c3f 	cmp	x1, #0xf
 110cebc:	54000bc8 	b.hi	110d034 <__tee_entry_fast+0x1b8>  // b.pmore
 110cec0:	71003c3f 	cmp	w1, #0xf
 110cec4:	54000b88 	b.hi	110d034 <__tee_entry_fast+0x1b8>  // b.pmore
 110cec8:	d0000200 	adrp	x0, 114e000 <ldelf_data+0x8000>
 110cecc:	9117b000 	add	x0, x0, #0x5ec
 110ced0:	38614800 	ldrb	w0, [x0, w1, uxtw]
 110ced4:	10000061 	adr	x1, 110cee0 <__tee_entry_fast+0x64>
 110ced8:	8b208820 	add	x0, x1, w0, sxtb #2
 110cedc:	d61f0000 	br	x0
 110cee0:	d29fe022 	mov	x2, #0xff01                	// #65281
 110cee4:	f2b7e002 	movk	x2, #0xbf00, lsl #16
 110cee8:	eb02003f 	cmp	x1, x2
 110ceec:	54000180 	b.eq	110cf1c <__tee_entry_fast+0xa0>  // b.none
 110cef0:	91000842 	add	x2, x2, #0x2
 110cef4:	eb02003f 	cmp	x1, x2
 110cef8:	54000160 	b.eq	110cf24 <__tee_entry_fast+0xa8>  // b.none
 110cefc:	d29fe002 	mov	x2, #0xff00                	// #65280
 110cf00:	f2b7e002 	movk	x2, #0xbf00, lsl #16
 110cf04:	eb02003f 	cmp	x1, x2
 110cf08:	54000961 	b.ne	110d034 <__tee_entry_fast+0x1b8>  // b.any
		tee_entry_get_api_call_count(args);
 110cf0c:	97ffffb6 	bl	110cde4 <tee_entry_get_api_call_count>
}
 110cf10:	f9400bf3 	ldr	x19, [sp, #16]
 110cf14:	a8c37bfd 	ldp	x29, x30, [sp], #48
 110cf18:	d65f03c0 	ret
		tee_entry_get_api_uuid(args);
 110cf1c:	97ffffb5 	bl	110cdf0 <tee_entry_get_api_uuid>
		break;
 110cf20:	17fffffc 	b	110cf10 <__tee_entry_fast+0x94>
		tee_entry_get_api_revision(args);
 110cf24:	97ffffc0 	bl	110ce24 <tee_entry_get_api_revision>
		break;
 110cf28:	17fffffa 	b	110cf10 <__tee_entry_fast+0x94>
		tee_entry_get_os_uuid(args);
 110cf2c:	aa1303e0 	mov	x0, x19
 110cf30:	97ffffc0 	bl	110ce30 <tee_entry_get_os_uuid>
		break;
 110cf34:	17fffff7 	b	110cf10 <__tee_entry_fast+0x94>
		tee_entry_get_os_revision(args);
 110cf38:	aa1303e0 	mov	x0, x19
 110cf3c:	97ffffca 	bl	110ce64 <tee_entry_get_os_revision>
		break;
 110cf40:	17fffff4 	b	110cf10 <__tee_entry_fast+0x94>
	args->a1 = default_nsec_shm_paddr;
 110cf44:	d0000260 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 110cf48:	f9422001 	ldr	x1, [x0, #1088]
	args->a2 = default_nsec_shm_size;
 110cf4c:	f9418400 	ldr	x0, [x0, #776]
	args->a1 = default_nsec_shm_paddr;
 110cf50:	f9400021 	ldr	x1, [x1]
	args->a2 = default_nsec_shm_size;
 110cf54:	f9400000 	ldr	x0, [x0]
	args->a1 = default_nsec_shm_paddr;
 110cf58:	a900067f 	stp	xzr, x1, [x19]
	args->a2 = default_nsec_shm_size;
 110cf5c:	f9000a60 	str	x0, [x19, #16]
enum teecore_memtypes core_mmu_get_type_by_pa(paddr_t pa);

/* routines to retreive shared mem configuration */
static inline bool core_mmu_is_shm_cached(void)
{
	return core_mmu_type_to_attr(MEM_AREA_NSEC_SHM) &
 110cf60:	52800140 	mov	w0, #0xa                   	// #10
 110cf64:	97ffeefe 	bl	1108b5c <core_mmu_type_to_attr>
 110cf68:	d34c3000 	ubfx	x0, x0, #12, #1
	args->a3 = core_mmu_is_shm_cached();
 110cf6c:	f9000e60 	str	x0, [x19, #24]
}
 110cf70:	17ffffe8 	b	110cf10 <__tee_entry_fast+0x94>
	if (args->a1 & ~OPTEE_SMC_NSEC_CAP_UNIPROCESSOR) {
 110cf74:	f9400660 	ldr	x0, [x19, #8]
 110cf78:	f27ff81f 	tst	x0, #0xfffffffffffffffe
 110cf7c:	54000060 	b.eq	110cf88 <__tee_entry_fast+0x10c>  // b.none
	args->a0 = OPTEE_SMC_RETURN_ENOTAVAIL;
 110cf80:	d28000e0 	mov	x0, #0x7                   	// #7
 110cf84:	1400001c 	b	110cff4 <__tee_entry_fast+0x178>
	args->a1 |= OPTEE_SMC_SEC_CAP_MEMREF_NULL;
 110cf88:	d2800220 	mov	x0, #0x11                  	// #17
 110cf8c:	a900027f 	stp	xzr, x0, [x19]
	dyn_shm_en = core_mmu_nsec_ddr_is_defined();
 110cf90:	97ffeee9 	bl	1108b34 <core_mmu_nsec_ddr_is_defined>
	if (dyn_shm_en)
 110cf94:	72001c1f 	tst	w0, #0xff
 110cf98:	540001e0 	b.eq	110cfd4 <__tee_entry_fast+0x158>  // b.none
		args->a1 |= OPTEE_SMC_SEC_CAP_DYNAMIC_SHM;
 110cf9c:	f9400660 	ldr	x0, [x19, #8]
	DMSG("Dynamic shared memory is %sabled", dyn_shm_en ? "en" : "dis");
 110cfa0:	b0000245 	adrp	x5, 1155000 <__func__.3826+0xa8>
 110cfa4:	9139d4a5 	add	x5, x5, #0xe75
		args->a1 |= OPTEE_SMC_SEC_CAP_DYNAMIC_SHM;
 110cfa8:	b27e0000 	orr	x0, x0, #0x4
 110cfac:	f9000660 	str	x0, [x19, #8]
	DMSG("Dynamic shared memory is %sabled", dyn_shm_en ? "en" : "dis");
 110cfb0:	f0000224 	adrp	x4, 1153000 <__func__.3477+0x91>
 110cfb4:	52800023 	mov	w3, #0x1                   	// #1
 110cfb8:	91230c84 	add	x4, x4, #0x8c3
 110cfbc:	52800062 	mov	w2, #0x3                   	// #3
 110cfc0:	52800cc1 	mov	w1, #0x66                  	// #102
 110cfc4:	f0000220 	adrp	x0, 1153000 <__func__.3477+0x91>
 110cfc8:	91239000 	add	x0, x0, #0x8e4
 110cfcc:	9400df5e 	bl	1144d44 <trace_printf>
 110cfd0:	17ffffd0 	b	110cf10 <__tee_entry_fast+0x94>
 110cfd4:	f0000225 	adrp	x5, 1153000 <__func__.3477+0x91>
 110cfd8:	9122fca5 	add	x5, x5, #0x8bf
 110cfdc:	17fffff5 	b	110cfb0 <__tee_entry_fast+0x134>
	if (!thread_disable_prealloc_rpc_cache(&cookie)) {
 110cfe0:	9100a3e0 	add	x0, sp, #0x28
 110cfe4:	97ffe795 	bl	1106e38 <thread_disable_prealloc_rpc_cache>
 110cfe8:	72001c1f 	tst	w0, #0xff
 110cfec:	54000081 	b.ne	110cffc <__tee_entry_fast+0x180>  // b.any
		args->a0 = OPTEE_SMC_RETURN_EBUSY;
 110cff0:	d2800040 	mov	x0, #0x2                   	// #2
		args->a0 = OPTEE_SMC_RETURN_UNKNOWN_FUNCTION;
 110cff4:	f9000260 	str	x0, [x19]
}
 110cff8:	17ffffc6 	b	110cf10 <__tee_entry_fast+0x94>
	if (!cookie) {
 110cffc:	f94017e0 	ldr	x0, [sp, #40]
 110d000:	b4fffc00 	cbz	x0, 110cf80 <__tee_entry_fast+0x104>
	args->a1 = cookie >> 32;
 110d004:	d360fc01 	lsr	x1, x0, #32
 110d008:	a900067f 	stp	xzr, x1, [x19]
	args->a2 = cookie;
 110d00c:	f9000a60 	str	x0, [x19, #16]
 110d010:	17ffffc0 	b	110cf10 <__tee_entry_fast+0x94>
	if (thread_enable_prealloc_rpc_cache())
 110d014:	97ffe7b8 	bl	1106ef4 <thread_enable_prealloc_rpc_cache>
		args->a0 = OPTEE_SMC_RETURN_OK;
 110d018:	72001c1f 	tst	w0, #0xff
 110d01c:	d2800040 	mov	x0, #0x2                   	// #2
 110d020:	9a8013e0 	csel	x0, xzr, x0, ne  // ne = any
 110d024:	17fffff4 	b	110cff4 <__tee_entry_fast+0x178>
	args->a1 = CFG_NUM_THREADS;
 110d028:	d2800040 	mov	x0, #0x2                   	// #2
 110d02c:	a900027f 	stp	xzr, x0, [x19]
}
 110d030:	17ffffb8 	b	110cf10 <__tee_entry_fast+0x94>
		args->a0 = OPTEE_SMC_RETURN_UNKNOWN_FUNCTION;
 110d034:	b2407fe0 	mov	x0, #0xffffffff            	// #4294967295
 110d038:	17ffffef 	b	110cff4 <__tee_entry_fast+0x178>

000000000110d03c <tee_entry_fast>:
	__tee_entry_fast(args);
 110d03c:	17ffff90 	b	110ce7c <__tee_entry_fast>

000000000110d040 <main_init_gic>:
register_phys_mem_pgdir(MEM_AREA_IO_SEC, SP_GICC_BASE, SP_GICC_SIZE);
register_phys_mem_pgdir(MEM_AREA_IO_SEC, SP_GICD_BASE, SP_GICD_SIZE);
register_phys_mem_pgdir(MEM_AREA_IO_NSEC, CONSOLE_SP_UART_BASE,SP_UART_REG_SIZE);

void main_init_gic(void)
{
 110d040:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	vaddr_t gicc_base;
	vaddr_t gicd_base;

	gicc_base = (vaddr_t)phys_to_virt(SP_GICC_BASE, MEM_AREA_IO_SEC);
 110d044:	d2820000 	mov	x0, #0x1000                	// #4096
 110d048:	528001c1 	mov	w1, #0xe                   	// #14
{
 110d04c:	910003fd 	mov	x29, sp
	gicc_base = (vaddr_t)phys_to_virt(SP_GICC_BASE, MEM_AREA_IO_SEC);
 110d050:	f2bf4000 	movk	x0, #0xfa00, lsl #16
{
 110d054:	a90153f3 	stp	x19, x20, [sp, #16]
	gicc_base = (vaddr_t)phys_to_virt(SP_GICC_BASE, MEM_AREA_IO_SEC);
 110d058:	97fff5b7 	bl	110a734 <phys_to_virt>
 110d05c:	aa0003f4 	mov	x20, x0
	gicd_base = (vaddr_t)phys_to_virt(SP_GICD_BASE, MEM_AREA_IO_SEC);
 110d060:	d2840000 	mov	x0, #0x2000                	// #8192
 110d064:	528001c1 	mov	w1, #0xe                   	// #14
 110d068:	f2bf4000 	movk	x0, #0xfa00, lsl #16
 110d06c:	97fff5b2 	bl	110a734 <phys_to_virt>

	if (!gicc_base || !gicd_base)
 110d070:	f100029f 	cmp	x20, #0x0
 110d074:	fa401804 	ccmp	x0, #0x0, #0x4, ne  // ne = any
 110d078:	54000101 	b.ne	110d098 <main_init_gic+0x58>  // b.any
		panic();
 110d07c:	d0000222 	adrp	x2, 1153000 <__func__.3477+0x91>
 110d080:	d0000220 	adrp	x0, 1153000 <__func__.3477+0x91>
 110d084:	91268842 	add	x2, x2, #0x9a2
 110d088:	91241000 	add	x0, x0, #0x904
 110d08c:	d2800003 	mov	x3, #0x0                   	// #0
 110d090:	528003c1 	mov	w1, #0x1e                  	// #30
 110d094:	940018f5 	bl	1113468 <__do_panic>

	gic_init_base_addr(&gic_data, gicc_base, gicd_base);
 110d098:	90000293 	adrp	x19, 115d000 <_curve_names+0x590>
 110d09c:	913d6273 	add	x19, x19, #0xf58
 110d0a0:	aa0003e2 	mov	x2, x0
 110d0a4:	aa1403e1 	mov	x1, x20
 110d0a8:	aa1303e0 	mov	x0, x19
 110d0ac:	94001417 	bl	1112108 <gic_init_base_addr>
	itr_init(&gic_data.chip);
 110d0b0:	91006260 	add	x0, x19, #0x18
}
 110d0b4:	a94153f3 	ldp	x19, x20, [sp, #16]
 110d0b8:	a8c27bfd 	ldp	x29, x30, [sp], #32
	itr_init(&gic_data.chip);
 110d0bc:	1400152b 	b	1112568 <itr_init>

000000000110d0c0 <main_secondary_init_gic>:

void main_secondary_init_gic(void)
{
	gic_cpu_init(&gic_data);
 110d0c0:	90000280 	adrp	x0, 115d000 <_curve_names+0x590>
 110d0c4:	913d6000 	add	x0, x0, #0xf58
 110d0c8:	140013fa 	b	11120b0 <gic_cpu_init>

000000000110d0cc <itr_core_handler>:
}

void itr_core_handler(void)
{
	gic_it_handle(&gic_data);
 110d0cc:	90000280 	adrp	x0, 115d000 <_curve_names+0x590>
 110d0d0:	913d6000 	add	x0, x0, #0xf58
 110d0d4:	1400142b 	b	1112180 <gic_it_handle>

000000000110d0d8 <console_init>:
}

void console_init(void)
{
 110d0d8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	sp_uart_init(&console_data, CONSOLE_SP_UART_BASE);
 110d0dc:	d2812001 	mov	x1, #0x900                 	// #2304
 110d0e0:	f2bf0001 	movk	x1, #0xf800, lsl #16
{
 110d0e4:	910003fd 	mov	x29, sp
 110d0e8:	f9000bf3 	str	x19, [sp, #16]
	sp_uart_init(&console_data, CONSOLE_SP_UART_BASE);
 110d0ec:	90000293 	adrp	x19, 115d000 <_curve_names+0x590>
 110d0f0:	913d0273 	add	x19, x19, #0xf40
 110d0f4:	aa1303e0 	mov	x0, x19
 110d0f8:	94001468 	bl	1112298 <sp_uart_init>
	register_serial_console(&console_data.chip);
 110d0fc:	91004260 	add	x0, x19, #0x10
}
 110d100:	f9400bf3 	ldr	x19, [sp, #16]
 110d104:	a8c27bfd 	ldp	x29, x30, [sp], #32
	register_serial_console(&console_data.chip);
 110d108:	140014a4 	b	1112398 <register_serial_console>

000000000110d10c <hash_ops>:

static const struct crypto_hash_ops *hash_ops(void *ctx)
{
	struct crypto_hash_ctx *c = ctx;

	assert(c && c->ops);
 110d10c:	b4000060 	cbz	x0, 110d118 <hash_ops+0xc>
 110d110:	f9400000 	ldr	x0, [x0]
 110d114:	b5000180 	cbnz	x0, 110d144 <hash_ops+0x38>
 110d118:	d0000223 	adrp	x3, 1153000 <__func__.3477+0x91>
 110d11c:	d0000221 	adrp	x1, 1153000 <__func__.3477+0x91>
 110d120:	91287063 	add	x3, x3, #0xa1c
 110d124:	9126c021 	add	x1, x1, #0x9b0
 110d128:	d0000220 	adrp	x0, 1153000 <__func__.3477+0x91>
 110d12c:	91271400 	add	x0, x0, #0x9c5
{
 110d130:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	assert(c && c->ops);
 110d134:	52800842 	mov	w2, #0x42                  	// #66
{
 110d138:	910003fd 	mov	x29, sp
	assert(c && c->ops);
 110d13c:	9400145c 	bl	11122ac <_assert_log>
 110d140:	9400146c 	bl	11122f0 <_assert_break>

	return c->ops;
}
 110d144:	d65f03c0 	ret

000000000110d148 <cipher_ops>:

static const struct crypto_cipher_ops *cipher_ops(void *ctx)
{
	struct crypto_cipher_ctx *c = ctx;

	assert(c && c->ops);
 110d148:	b4000060 	cbz	x0, 110d154 <cipher_ops+0xc>
 110d14c:	f9400000 	ldr	x0, [x0]
 110d150:	b5000180 	cbnz	x0, 110d180 <cipher_ops+0x38>
 110d154:	d0000223 	adrp	x3, 1153000 <__func__.3477+0x91>
 110d158:	d0000221 	adrp	x1, 1153000 <__func__.3477+0x91>
 110d15c:	91289463 	add	x3, x3, #0xa25
 110d160:	9126c021 	add	x1, x1, #0x9b0
 110d164:	d0000220 	adrp	x0, 1153000 <__func__.3477+0x91>
 110d168:	91271400 	add	x0, x0, #0x9c5
{
 110d16c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	assert(c && c->ops);
 110d170:	52801422 	mov	w2, #0xa1                  	// #161
{
 110d174:	910003fd 	mov	x29, sp
	assert(c && c->ops);
 110d178:	9400144d 	bl	11122ac <_assert_log>
 110d17c:	9400145d 	bl	11122f0 <_assert_break>

	return c->ops;
}
 110d180:	d65f03c0 	ret

000000000110d184 <mac_ops>:

static const struct crypto_mac_ops *mac_ops(void *ctx)
{
	struct crypto_mac_ctx *c = ctx;

	assert(c && c->ops);
 110d184:	b4000060 	cbz	x0, 110d190 <mac_ops+0xc>
 110d188:	f9400000 	ldr	x0, [x0]
 110d18c:	b5000180 	cbnz	x0, 110d1bc <mac_ops+0x38>
 110d190:	d0000223 	adrp	x3, 1153000 <__func__.3477+0x91>
 110d194:	d0000221 	adrp	x1, 1153000 <__func__.3477+0x91>
 110d198:	9128c063 	add	x3, x3, #0xa30
 110d19c:	9126c021 	add	x1, x1, #0x9b0
 110d1a0:	d0000220 	adrp	x0, 1153000 <__func__.3477+0x91>
 110d1a4:	91271400 	add	x0, x0, #0x9c5
{
 110d1a8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	assert(c && c->ops);
 110d1ac:	52802542 	mov	w2, #0x12a                 	// #298
{
 110d1b0:	910003fd 	mov	x29, sp
	assert(c && c->ops);
 110d1b4:	9400143e 	bl	11122ac <_assert_log>
 110d1b8:	9400144e 	bl	11122f0 <_assert_break>

	return c->ops;
}
 110d1bc:	d65f03c0 	ret

000000000110d1c0 <ae_ops>:

static const struct crypto_authenc_ops *ae_ops(void *ctx)
{
	struct crypto_authenc_ctx *c = ctx;

	assert(c && c->ops);
 110d1c0:	b4000060 	cbz	x0, 110d1cc <ae_ops+0xc>
 110d1c4:	f9400000 	ldr	x0, [x0]
 110d1c8:	b5000180 	cbnz	x0, 110d1f8 <ae_ops+0x38>
 110d1cc:	d0000223 	adrp	x3, 1153000 <__func__.3477+0x91>
 110d1d0:	d0000221 	adrp	x1, 1153000 <__func__.3477+0x91>
 110d1d4:	9128e063 	add	x3, x3, #0xa38
 110d1d8:	9126c021 	add	x1, x1, #0x9b0
 110d1dc:	d0000220 	adrp	x0, 1153000 <__func__.3477+0x91>
 110d1e0:	91271400 	add	x0, x0, #0x9c5
{
 110d1e4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	assert(c && c->ops);
 110d1e8:	52802d42 	mov	w2, #0x16a                 	// #362
{
 110d1ec:	910003fd 	mov	x29, sp
	assert(c && c->ops);
 110d1f0:	9400142f 	bl	11122ac <_assert_log>
 110d1f4:	9400143f 	bl	11122f0 <_assert_break>

	return c->ops;
}
 110d1f8:	d65f03c0 	ret

000000000110d1fc <crypto_hash_alloc_ctx>:
{
 110d1fc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 110d200:	910003fd 	mov	x29, sp
 110d204:	f9000bf3 	str	x19, [sp, #16]
 110d208:	aa0003f3 	mov	x19, x0
	struct crypto_hash_ctx *c = NULL;
 110d20c:	f90017ff 	str	xzr, [sp, #40]
		switch (algo) {
 110d210:	12aa0000 	mov	w0, #0xafffffff            	// #-1342177281
 110d214:	0b000021 	add	w1, w1, w0
 110d218:	7100183f 	cmp	w1, #0x6
 110d21c:	54000368 	b.hi	110d288 <crypto_hash_alloc_ctx+0x8c>  // b.pmore
 110d220:	b0000202 	adrp	x2, 114e000 <ldelf_data+0x8000>
 110d224:	9100a3e0 	add	x0, sp, #0x28
 110d228:	9117f042 	add	x2, x2, #0x5fc
 110d22c:	38614841 	ldrb	w1, [x2, w1, uxtw]
 110d230:	10000062 	adr	x2, 110d23c <crypto_hash_alloc_ctx+0x40>
 110d234:	8b218841 	add	x1, x2, w1, sxtb #2
 110d238:	d61f0020 	br	x1
			res = crypto_md5_alloc_ctx(&c);
 110d23c:	94006c1d 	bl	11282b0 <crypto_md5_alloc_ctx>
	if (!res)
 110d240:	35000060 	cbnz	w0, 110d24c <crypto_hash_alloc_ctx+0x50>
		*ctx = c;
 110d244:	f94017e1 	ldr	x1, [sp, #40]
 110d248:	f9000261 	str	x1, [x19]
}
 110d24c:	f9400bf3 	ldr	x19, [sp, #16]
 110d250:	a8c37bfd 	ldp	x29, x30, [sp], #48
 110d254:	d65f03c0 	ret
			res = crypto_sha1_alloc_ctx(&c);
 110d258:	94006c22 	bl	11282e0 <crypto_sha1_alloc_ctx>
			break;
 110d25c:	17fffff9 	b	110d240 <crypto_hash_alloc_ctx+0x44>
			res = crypto_sha224_alloc_ctx(&c);
 110d260:	94006c2c 	bl	1128310 <crypto_sha224_alloc_ctx>
			break;
 110d264:	17fffff7 	b	110d240 <crypto_hash_alloc_ctx+0x44>
			res = crypto_sha256_alloc_ctx(&c);
 110d268:	94006c36 	bl	1128340 <crypto_sha256_alloc_ctx>
			break;
 110d26c:	17fffff5 	b	110d240 <crypto_hash_alloc_ctx+0x44>
			res = crypto_sha384_alloc_ctx(&c);
 110d270:	94006c40 	bl	1128370 <crypto_sha384_alloc_ctx>
			break;
 110d274:	17fffff3 	b	110d240 <crypto_hash_alloc_ctx+0x44>
			res = crypto_sha512_alloc_ctx(&c);
 110d278:	94006c4a 	bl	11283a0 <crypto_sha512_alloc_ctx>
			break;
 110d27c:	17fffff1 	b	110d240 <crypto_hash_alloc_ctx+0x44>
			res = crypto_sm3_alloc_ctx(&c);
 110d280:	94000eec 	bl	1110e30 <crypto_sm3_alloc_ctx>
			break;
 110d284:	17ffffef 	b	110d240 <crypto_hash_alloc_ctx+0x44>
	struct crypto_hash_ctx *c = NULL;
 110d288:	129ffec0 	mov	w0, #0xffff0009            	// #-65527
	return res;
 110d28c:	17fffff0 	b	110d24c <crypto_hash_alloc_ctx+0x50>

000000000110d290 <crypto_hash_free_ctx>:
	if (ctx)
 110d290:	b4000180 	cbz	x0, 110d2c0 <crypto_hash_free_ctx+0x30>
{
 110d294:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 110d298:	910003fd 	mov	x29, sp
 110d29c:	f9000bf3 	str	x19, [sp, #16]
 110d2a0:	aa0003f3 	mov	x19, x0
		hash_ops(ctx)->free_ctx(ctx);
 110d2a4:	97ffff9a 	bl	110d10c <hash_ops>
 110d2a8:	f9400c01 	ldr	x1, [x0, #24]
 110d2ac:	aa1303e0 	mov	x0, x19
}
 110d2b0:	f9400bf3 	ldr	x19, [sp, #16]
		hash_ops(ctx)->free_ctx(ctx);
 110d2b4:	aa0103f0 	mov	x16, x1
}
 110d2b8:	a8c27bfd 	ldp	x29, x30, [sp], #32
		hash_ops(ctx)->free_ctx(ctx);
 110d2bc:	d61f0200 	br	x16
 110d2c0:	d65f03c0 	ret

000000000110d2c4 <crypto_hash_copy_state>:
{
 110d2c4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 110d2c8:	910003fd 	mov	x29, sp
 110d2cc:	a90153f3 	stp	x19, x20, [sp, #16]
 110d2d0:	aa0003f3 	mov	x19, x0
 110d2d4:	aa0103f4 	mov	x20, x1
	hash_ops(dst_ctx)->copy_state(dst_ctx, src_ctx);
 110d2d8:	97ffff8d 	bl	110d10c <hash_ops>
 110d2dc:	aa1403e1 	mov	x1, x20
 110d2e0:	f9401002 	ldr	x2, [x0, #32]
 110d2e4:	aa1303e0 	mov	x0, x19
}
 110d2e8:	a94153f3 	ldp	x19, x20, [sp, #16]
	hash_ops(dst_ctx)->copy_state(dst_ctx, src_ctx);
 110d2ec:	aa0203f0 	mov	x16, x2
}
 110d2f0:	a8c27bfd 	ldp	x29, x30, [sp], #32
	hash_ops(dst_ctx)->copy_state(dst_ctx, src_ctx);
 110d2f4:	d61f0200 	br	x16

000000000110d2f8 <crypto_hash_init>:
{
 110d2f8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 110d2fc:	910003fd 	mov	x29, sp
 110d300:	f9000bf3 	str	x19, [sp, #16]
 110d304:	aa0003f3 	mov	x19, x0
	return hash_ops(ctx)->init(ctx);
 110d308:	97ffff81 	bl	110d10c <hash_ops>
 110d30c:	f9400001 	ldr	x1, [x0]
 110d310:	aa1303e0 	mov	x0, x19
}
 110d314:	f9400bf3 	ldr	x19, [sp, #16]
	return hash_ops(ctx)->init(ctx);
 110d318:	aa0103f0 	mov	x16, x1
}
 110d31c:	a8c27bfd 	ldp	x29, x30, [sp], #32
	return hash_ops(ctx)->init(ctx);
 110d320:	d61f0200 	br	x16

000000000110d324 <crypto_hash_update>:
{
 110d324:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 110d328:	910003fd 	mov	x29, sp
 110d32c:	a90153f3 	stp	x19, x20, [sp, #16]
 110d330:	aa0003f3 	mov	x19, x0
 110d334:	aa0103f4 	mov	x20, x1
 110d338:	f90013f5 	str	x21, [sp, #32]
 110d33c:	aa0203f5 	mov	x21, x2
	return hash_ops(ctx)->update(ctx, data, len);
 110d340:	97ffff73 	bl	110d10c <hash_ops>
 110d344:	aa1503e2 	mov	x2, x21
 110d348:	aa1403e1 	mov	x1, x20
 110d34c:	f9400403 	ldr	x3, [x0, #8]
 110d350:	aa1303e0 	mov	x0, x19
}
 110d354:	a94153f3 	ldp	x19, x20, [sp, #16]
	return hash_ops(ctx)->update(ctx, data, len);
 110d358:	aa0303f0 	mov	x16, x3
}
 110d35c:	f94013f5 	ldr	x21, [sp, #32]
 110d360:	a8c37bfd 	ldp	x29, x30, [sp], #48
	return hash_ops(ctx)->update(ctx, data, len);
 110d364:	d61f0200 	br	x16

000000000110d368 <crypto_hash_final>:
{
 110d368:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 110d36c:	910003fd 	mov	x29, sp
 110d370:	a90153f3 	stp	x19, x20, [sp, #16]
 110d374:	aa0003f3 	mov	x19, x0
 110d378:	aa0103f4 	mov	x20, x1
 110d37c:	f90013f5 	str	x21, [sp, #32]
 110d380:	aa0203f5 	mov	x21, x2
	return hash_ops(ctx)->final(ctx, digest, len);
 110d384:	97ffff62 	bl	110d10c <hash_ops>
 110d388:	aa1503e2 	mov	x2, x21
 110d38c:	aa1403e1 	mov	x1, x20
 110d390:	f9400803 	ldr	x3, [x0, #16]
 110d394:	aa1303e0 	mov	x0, x19
}
 110d398:	a94153f3 	ldp	x19, x20, [sp, #16]
	return hash_ops(ctx)->final(ctx, digest, len);
 110d39c:	aa0303f0 	mov	x16, x3
}
 110d3a0:	f94013f5 	ldr	x21, [sp, #32]
 110d3a4:	a8c37bfd 	ldp	x29, x30, [sp], #48
	return hash_ops(ctx)->final(ctx, digest, len);
 110d3a8:	d61f0200 	br	x16

000000000110d3ac <crypto_cipher_alloc_ctx>:
{
 110d3ac:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 110d3b0:	910003fd 	mov	x29, sp
 110d3b4:	f9000bf3 	str	x19, [sp, #16]
 110d3b8:	aa0003f3 	mov	x19, x0
	struct crypto_cipher_ctx *c = NULL;
 110d3bc:	f90017ff 	str	xzr, [sp, #40]
		switch (algo) {
 110d3c0:	52802280 	mov	w0, #0x114                 	// #276
 110d3c4:	72a20000 	movk	w0, #0x1000, lsl #16
 110d3c8:	6b00003f 	cmp	w1, w0
 110d3cc:	540003a8 	b.hi	110d440 <crypto_cipher_alloc_ctx+0x94>  // b.pmore
 110d3d0:	528021e0 	mov	w0, #0x10f                 	// #271
 110d3d4:	72a20000 	movk	w0, #0x1000, lsl #16
 110d3d8:	6b00003f 	cmp	w1, w0
 110d3dc:	54000108 	b.hi	110d3fc <crypto_cipher_alloc_ctx+0x50>  // b.pmore
 110d3e0:	529ffe00 	mov	w0, #0xfff0                	// #65520
 110d3e4:	72bdffe0 	movk	w0, #0xefff, lsl #16
 110d3e8:	0b000021 	add	w1, w1, w0
 110d3ec:	7100103f 	cmp	w1, #0x4
 110d3f0:	540001c9 	b.ls	110d428 <crypto_cipher_alloc_ctx+0x7c>  // b.plast
 110d3f4:	129ffec0 	mov	w0, #0xffff0009            	// #-65527
 110d3f8:	1400002d 	b	110d4ac <crypto_cipher_alloc_ctx+0x100>
 110d3fc:	529fde00 	mov	w0, #0xfef0                	// #65264
 110d400:	72bdffe0 	movk	w0, #0xefff, lsl #16
 110d404:	0b000021 	add	w1, w1, w0
 110d408:	7100103f 	cmp	w1, #0x4
 110d40c:	54ffff48 	b.hi	110d3f4 <crypto_cipher_alloc_ctx+0x48>  // b.pmore
 110d410:	b0000200 	adrp	x0, 114e000 <ldelf_data+0x8000>
 110d414:	91181000 	add	x0, x0, #0x604
 110d418:	38614800 	ldrb	w0, [x0, w1, uxtw]
 110d41c:	10000061 	adr	x1, 110d428 <crypto_cipher_alloc_ctx+0x7c>
 110d420:	8b208820 	add	x0, x1, w0, sxtb #2
 110d424:	d61f0000 	br	x0
 110d428:	b0000200 	adrp	x0, 114e000 <ldelf_data+0x8000>
 110d42c:	91183000 	add	x0, x0, #0x60c
 110d430:	38614800 	ldrb	w0, [x0, w1, uxtw]
 110d434:	10000061 	adr	x1, 110d440 <crypto_cipher_alloc_ctx+0x94>
 110d438:	8b208820 	add	x0, x1, w0, sxtb #2
 110d43c:	d61f0000 	br	x0
 110d440:	52806200 	mov	w0, #0x310                 	// #784
 110d444:	72a20000 	movk	w0, #0x1000, lsl #16
 110d448:	6b00003f 	cmp	w1, w0
 110d44c:	54000420 	b.eq	110d4d0 <crypto_cipher_alloc_ctx+0x124>  // b.none
 110d450:	54000168 	b.hi	110d47c <crypto_cipher_alloc_ctx+0xd0>  // b.pmore
 110d454:	52804200 	mov	w0, #0x210                 	// #528
 110d458:	72a20000 	movk	w0, #0x1000, lsl #16
 110d45c:	6b00003f 	cmp	w1, w0
 110d460:	54000320 	b.eq	110d4c4 <crypto_cipher_alloc_ctx+0x118>  // b.none
 110d464:	11001000 	add	w0, w0, #0x4
 110d468:	6b00003f 	cmp	w1, w0
 110d46c:	54fffc41 	b.ne	110d3f4 <crypto_cipher_alloc_ctx+0x48>  // b.any
			res = crypto_sm4_ctr_alloc_ctx(&c);
 110d470:	9100a3e0 	add	x0, sp, #0x28
 110d474:	940011e2 	bl	1111bfc <crypto_sm4_ctr_alloc_ctx>
			break;
 110d478:	1400000a 	b	110d4a0 <crypto_cipher_alloc_ctx+0xf4>
		switch (algo) {
 110d47c:	52808200 	mov	w0, #0x410                 	// #1040
 110d480:	72a20000 	movk	w0, #0x1000, lsl #16
 110d484:	6b00003f 	cmp	w1, w0
 110d488:	54fffb61 	b.ne	110d3f4 <crypto_cipher_alloc_ctx+0x48>  // b.any
			res = crypto_aes_xts_alloc_ctx(&c);
 110d48c:	9100a3e0 	add	x0, sp, #0x28
 110d490:	94006fd5 	bl	11293e4 <crypto_aes_xts_alloc_ctx>
			break;
 110d494:	14000003 	b	110d4a0 <crypto_cipher_alloc_ctx+0xf4>
			res = crypto_aes_ecb_alloc_ctx(&c);
 110d498:	9100a3e0 	add	x0, sp, #0x28
 110d49c:	94006db3 	bl	1128b68 <crypto_aes_ecb_alloc_ctx>
	if (!res)
 110d4a0:	35000060 	cbnz	w0, 110d4ac <crypto_cipher_alloc_ctx+0x100>
		*ctx = c;
 110d4a4:	f94017e1 	ldr	x1, [sp, #40]
 110d4a8:	f9000261 	str	x1, [x19]
}
 110d4ac:	f9400bf3 	ldr	x19, [sp, #16]
 110d4b0:	a8c37bfd 	ldp	x29, x30, [sp], #48
 110d4b4:	d65f03c0 	ret
			res = crypto_aes_cbc_alloc_ctx(&c);
 110d4b8:	9100a3e0 	add	x0, sp, #0x28
 110d4bc:	94006e7a 	bl	1128ea4 <crypto_aes_cbc_alloc_ctx>
			break;
 110d4c0:	17fffff8 	b	110d4a0 <crypto_cipher_alloc_ctx+0xf4>
			res = crypto_aes_ctr_alloc_ctx(&c);
 110d4c4:	9100a3e0 	add	x0, sp, #0x28
 110d4c8:	94006f1a 	bl	1129130 <crypto_aes_ctr_alloc_ctx>
			break;
 110d4cc:	17fffff5 	b	110d4a0 <crypto_cipher_alloc_ctx+0xf4>
			res = crypto_aes_cts_alloc_ctx(&c);
 110d4d0:	9100a3e0 	add	x0, sp, #0x28
 110d4d4:	94000b2f 	bl	1110190 <crypto_aes_cts_alloc_ctx>
			break;
 110d4d8:	17fffff2 	b	110d4a0 <crypto_cipher_alloc_ctx+0xf4>
			res = crypto_des_ecb_alloc_ctx(&c);
 110d4dc:	9100a3e0 	add	x0, sp, #0x28
 110d4e0:	94006daf 	bl	1128b9c <crypto_des_ecb_alloc_ctx>
			break;
 110d4e4:	17ffffef 	b	110d4a0 <crypto_cipher_alloc_ctx+0xf4>
			res = crypto_des3_ecb_alloc_ctx(&c);
 110d4e8:	9100a3e0 	add	x0, sp, #0x28
 110d4ec:	94006db9 	bl	1128bd0 <crypto_des3_ecb_alloc_ctx>
			break;
 110d4f0:	17ffffec 	b	110d4a0 <crypto_cipher_alloc_ctx+0xf4>
			res = crypto_des_cbc_alloc_ctx(&c);
 110d4f4:	9100a3e0 	add	x0, sp, #0x28
 110d4f8:	94006e78 	bl	1128ed8 <crypto_des_cbc_alloc_ctx>
			break;
 110d4fc:	17ffffe9 	b	110d4a0 <crypto_cipher_alloc_ctx+0xf4>
			res = crypto_des3_cbc_alloc_ctx(&c);
 110d500:	9100a3e0 	add	x0, sp, #0x28
 110d504:	94006e82 	bl	1128f0c <crypto_des3_cbc_alloc_ctx>
			break;
 110d508:	17ffffe6 	b	110d4a0 <crypto_cipher_alloc_ctx+0xf4>
			res = crypto_sm4_ecb_alloc_ctx(&c);
 110d50c:	9100a3e0 	add	x0, sp, #0x28
 110d510:	940010c3 	bl	111181c <crypto_sm4_ecb_alloc_ctx>
			break;
 110d514:	17ffffe3 	b	110d4a0 <crypto_cipher_alloc_ctx+0xf4>
			res = crypto_sm4_cbc_alloc_ctx(&c);
 110d518:	9100a3e0 	add	x0, sp, #0x28
 110d51c:	9400113e 	bl	1111a14 <crypto_sm4_cbc_alloc_ctx>
			break;
 110d520:	17ffffe0 	b	110d4a0 <crypto_cipher_alloc_ctx+0xf4>

000000000110d524 <crypto_cipher_free_ctx>:
	if (ctx)
 110d524:	b4000180 	cbz	x0, 110d554 <crypto_cipher_free_ctx+0x30>
{
 110d528:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 110d52c:	910003fd 	mov	x29, sp
 110d530:	f9000bf3 	str	x19, [sp, #16]
 110d534:	aa0003f3 	mov	x19, x0
		cipher_ops(ctx)->free_ctx(ctx);
 110d538:	97ffff04 	bl	110d148 <cipher_ops>
 110d53c:	f9400c01 	ldr	x1, [x0, #24]
 110d540:	aa1303e0 	mov	x0, x19
}
 110d544:	f9400bf3 	ldr	x19, [sp, #16]
		cipher_ops(ctx)->free_ctx(ctx);
 110d548:	aa0103f0 	mov	x16, x1
}
 110d54c:	a8c27bfd 	ldp	x29, x30, [sp], #32
		cipher_ops(ctx)->free_ctx(ctx);
 110d550:	d61f0200 	br	x16
 110d554:	d65f03c0 	ret

000000000110d558 <crypto_cipher_copy_state>:
{
 110d558:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 110d55c:	910003fd 	mov	x29, sp
 110d560:	a90153f3 	stp	x19, x20, [sp, #16]
 110d564:	aa0003f3 	mov	x19, x0
 110d568:	aa0103f4 	mov	x20, x1
	cipher_ops(dst_ctx)->copy_state(dst_ctx, src_ctx);
 110d56c:	97fffef7 	bl	110d148 <cipher_ops>
 110d570:	aa1403e1 	mov	x1, x20
 110d574:	f9401002 	ldr	x2, [x0, #32]
 110d578:	aa1303e0 	mov	x0, x19
}
 110d57c:	a94153f3 	ldp	x19, x20, [sp, #16]
	cipher_ops(dst_ctx)->copy_state(dst_ctx, src_ctx);
 110d580:	aa0203f0 	mov	x16, x2
}
 110d584:	a8c27bfd 	ldp	x29, x30, [sp], #32
	cipher_ops(dst_ctx)->copy_state(dst_ctx, src_ctx);
 110d588:	d61f0200 	br	x16

000000000110d58c <crypto_cipher_init>:
	if (mode != TEE_MODE_DECRYPT && mode != TEE_MODE_ENCRYPT)
 110d58c:	7100043f 	cmp	w1, #0x1
 110d590:	54000408 	b.hi	110d610 <crypto_cipher_init+0x84>  // b.pmore
{
 110d594:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 110d598:	910003fd 	mov	x29, sp
 110d59c:	a90153f3 	stp	x19, x20, [sp, #16]
 110d5a0:	aa0003f4 	mov	x20, x0
 110d5a4:	2a0103f3 	mov	w19, w1
 110d5a8:	a9025bf5 	stp	x21, x22, [sp, #32]
 110d5ac:	aa0203f5 	mov	x21, x2
 110d5b0:	aa0303f6 	mov	x22, x3
 110d5b4:	a90363f7 	stp	x23, x24, [sp, #48]
 110d5b8:	aa0403f7 	mov	x23, x4
 110d5bc:	aa0503f8 	mov	x24, x5
 110d5c0:	a9046bf9 	stp	x25, x26, [sp, #64]
 110d5c4:	aa0603f9 	mov	x25, x6
 110d5c8:	aa0703fa 	mov	x26, x7
	return cipher_ops(ctx)->init(ctx, mode, key1, key1_len, key2, key2_len,
 110d5cc:	97fffedf 	bl	110d148 <cipher_ops>
 110d5d0:	aa1a03e7 	mov	x7, x26
 110d5d4:	aa1903e6 	mov	x6, x25
 110d5d8:	aa1803e5 	mov	x5, x24
 110d5dc:	aa1703e4 	mov	x4, x23
 110d5e0:	aa1603e3 	mov	x3, x22
 110d5e4:	aa1503e2 	mov	x2, x21
 110d5e8:	2a1303e1 	mov	w1, w19
 110d5ec:	f9400008 	ldr	x8, [x0]
 110d5f0:	aa1403e0 	mov	x0, x20
}
 110d5f4:	a94153f3 	ldp	x19, x20, [sp, #16]
	return cipher_ops(ctx)->init(ctx, mode, key1, key1_len, key2, key2_len,
 110d5f8:	aa0803f0 	mov	x16, x8
}
 110d5fc:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110d600:	a94363f7 	ldp	x23, x24, [sp, #48]
 110d604:	a9446bf9 	ldp	x25, x26, [sp, #64]
 110d608:	a8c57bfd 	ldp	x29, x30, [sp], #80
	return cipher_ops(ctx)->init(ctx, mode, key1, key1_len, key2, key2_len,
 110d60c:	d61f0200 	br	x16
}
 110d610:	129fff20 	mov	w0, #0xffff0006            	// #-65530
 110d614:	d65f03c0 	ret

000000000110d618 <crypto_cipher_update>:
{
 110d618:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 110d61c:	910003fd 	mov	x29, sp
 110d620:	a90153f3 	stp	x19, x20, [sp, #16]
 110d624:	aa0303f4 	mov	x20, x3
 110d628:	aa0003f3 	mov	x19, x0
 110d62c:	a9025bf5 	stp	x21, x22, [sp, #32]
 110d630:	aa0403f5 	mov	x21, x4
 110d634:	aa0503f6 	mov	x22, x5
 110d638:	f9001bf7 	str	x23, [sp, #48]
 110d63c:	12001c57 	and	w23, w2, #0xff
	return cipher_ops(ctx)->update(ctx, last_block, data, len, dst);
 110d640:	97fffec2 	bl	110d148 <cipher_ops>
 110d644:	aa1603e4 	mov	x4, x22
 110d648:	aa1503e3 	mov	x3, x21
 110d64c:	aa1403e2 	mov	x2, x20
 110d650:	2a1703e1 	mov	w1, w23
 110d654:	f9400405 	ldr	x5, [x0, #8]
 110d658:	aa1303e0 	mov	x0, x19
}
 110d65c:	a94153f3 	ldp	x19, x20, [sp, #16]
	return cipher_ops(ctx)->update(ctx, last_block, data, len, dst);
 110d660:	aa0503f0 	mov	x16, x5
}
 110d664:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110d668:	f9401bf7 	ldr	x23, [sp, #48]
 110d66c:	a8c47bfd 	ldp	x29, x30, [sp], #64
	return cipher_ops(ctx)->update(ctx, last_block, data, len, dst);
 110d670:	d61f0200 	br	x16

000000000110d674 <crypto_cipher_final>:
{
 110d674:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 110d678:	910003fd 	mov	x29, sp
 110d67c:	f9000bf3 	str	x19, [sp, #16]
 110d680:	aa0003f3 	mov	x19, x0
	cipher_ops(ctx)->final(ctx);
 110d684:	97fffeb1 	bl	110d148 <cipher_ops>
 110d688:	f9400801 	ldr	x1, [x0, #16]
 110d68c:	aa1303e0 	mov	x0, x19
}
 110d690:	f9400bf3 	ldr	x19, [sp, #16]
	cipher_ops(ctx)->final(ctx);
 110d694:	aa0103f0 	mov	x16, x1
}
 110d698:	a8c27bfd 	ldp	x29, x30, [sp], #32
	cipher_ops(ctx)->final(ctx);
 110d69c:	d61f0200 	br	x16

000000000110d6a0 <crypto_cipher_get_block_size>:
#define TEE_CHAIN_MODE_PKCS1_PSS_MGF1   0x9	/* ??? */


static inline uint32_t __tee_alg_get_class(uint32_t algo)
{
	if (algo == TEE_ALG_SM2_PKE)
 110d6a0:	528008a2 	mov	w2, #0x45                  	// #69
 110d6a4:	72b00002 	movk	w2, #0x8000, lsl #16
 110d6a8:	6b02001f 	cmp	w0, w2
 110d6ac:	54000440 	b.eq	110d734 <crypto_cipher_get_block_size+0x94>  // b.none
		return TEE_OPERATION_ASYMMETRIC_CIPHER;
	if (algo == TEE_ALG_SM2_KEP)
 110d6b0:	528008a2 	mov	w2, #0x45                  	// #69
 110d6b4:	72ac0002 	movk	w2, #0x6000, lsl #16
 110d6b8:	6b02001f 	cmp	w0, w2
 110d6bc:	540003c0 	b.eq	110d734 <crypto_cipher_get_block_size+0x94>  // b.none
		return TEE_OPERATION_KEY_DERIVATION;
	if (algo == TEE_ALG_RSASSA_PKCS1_V1_5)
 110d6c0:	52810602 	mov	w2, #0x830                 	// #2096
 110d6c4:	72be0002 	movk	w2, #0xf000, lsl #16
 110d6c8:	6b02001f 	cmp	w0, w2
 110d6cc:	54000340 	b.eq	110d734 <crypto_cipher_get_block_size+0x94>  // b.none
		return TEE_OPERATION_ASYMMETRIC_SIGNATURE;
	if (algo == TEE_ALG_DES3_CMAC)
 110d6d0:	5280c262 	mov	w2, #0x613                 	// #1555
 110d6d4:	72be0002 	movk	w2, #0xf000, lsl #16
 110d6d8:	6b02001f 	cmp	w0, w2
 110d6dc:	540000c0 	b.eq	110d6f4 <crypto_cipher_get_block_size+0x54>  // b.none
		return TEE_OPERATION_MAC;

	return (algo >> 28) & 0xF; /* Bits [31:28] */
 110d6e0:	531c7c02 	lsr	w2, w0, #28
	if (class != TEE_OPERATION_CIPHER && class != TEE_OPERATION_MAC &&
 110d6e4:	51000c43 	sub	w3, w2, #0x3
 110d6e8:	7100047f 	cmp	w3, #0x1
 110d6ec:	7a418844 	ccmp	w2, #0x1, #0x4, hi  // hi = pmore
 110d6f0:	54000221 	b.ne	110d734 <crypto_cipher_get_block_size+0x94>  // b.any
		return TEE_MAIN_ALGO_SM2_KEP;
	default:
		break;
	}

	return algo & 0xff;
 110d6f4:	12001c00 	and	w0, w0, #0xff
 110d6f8:	51004000 	sub	w0, w0, #0x10
 110d6fc:	7100101f 	cmp	w0, #0x4
 110d700:	540001e8 	b.hi	110d73c <crypto_cipher_get_block_size+0x9c>  // b.pmore
 110d704:	b0000202 	adrp	x2, 114e000 <ldelf_data+0x8000>
 110d708:	91185042 	add	x2, x2, #0x614
 110d70c:	38604840 	ldrb	w0, [x2, w0, uxtw]
 110d710:	10000062 	adr	x2, 110d71c <crypto_cipher_get_block_size+0x7c>
 110d714:	8b208840 	add	x0, x2, w0, sxtb #2
 110d718:	d61f0000 	br	x0
		*size = TEE_AES_BLOCK_SIZE;
 110d71c:	d2800200 	mov	x0, #0x10                  	// #16
		*size = TEE_DES_BLOCK_SIZE;
 110d720:	f9000020 	str	x0, [x1]
		return TEE_SUCCESS;
 110d724:	52800000 	mov	w0, #0x0                   	// #0
}
 110d728:	d65f03c0 	ret
		*size = TEE_DES_BLOCK_SIZE;
 110d72c:	d2800100 	mov	x0, #0x8                   	// #8
 110d730:	17fffffc 	b	110d720 <crypto_cipher_get_block_size+0x80>
		return TEE_ERROR_BAD_PARAMETERS;
 110d734:	129fff20 	mov	w0, #0xffff0006            	// #-65530
 110d738:	17fffffc 	b	110d728 <crypto_cipher_get_block_size+0x88>
 110d73c:	129ffea0 	mov	w0, #0xffff000a            	// #-65526
 110d740:	17fffffa 	b	110d728 <crypto_cipher_get_block_size+0x88>

000000000110d744 <crypto_mac_alloc_ctx>:
{
 110d744:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 110d748:	910003fd 	mov	x29, sp
 110d74c:	f9000bf3 	str	x19, [sp, #16]
 110d750:	aa0003f3 	mov	x19, x0
	struct crypto_mac_ctx *c = NULL;
 110d754:	f90017ff 	str	xzr, [sp, #40]
		switch (algo) {
 110d758:	52802200 	mov	w0, #0x110                 	// #272
 110d75c:	72a60000 	movk	w0, #0x3000, lsl #16
 110d760:	6b00003f 	cmp	w1, w0
 110d764:	54000820 	b.eq	110d868 <crypto_mac_alloc_ctx+0x124>  // b.none
 110d768:	54000188 	b.hi	110d798 <crypto_mac_alloc_ctx+0x54>  // b.pmore
 110d76c:	12a60000 	mov	w0, #0xcfffffff            	// #-805306369
 110d770:	0b000021 	add	w1, w1, w0
 110d774:	7100183f 	cmp	w1, #0x6
 110d778:	54000308 	b.hi	110d7d8 <crypto_mac_alloc_ctx+0x94>  // b.pmore
 110d77c:	b0000202 	adrp	x2, 114e000 <ldelf_data+0x8000>
 110d780:	9100a3e0 	add	x0, sp, #0x28
 110d784:	91187042 	add	x2, x2, #0x61c
 110d788:	38614841 	ldrb	w1, [x2, w1, uxtw]
 110d78c:	10000062 	adr	x2, 110d798 <crypto_mac_alloc_ctx+0x54>
 110d790:	8b218841 	add	x1, x2, w1, sxtb #2
 110d794:	d61f0020 	br	x1
 110d798:	5280a220 	mov	w0, #0x511                 	// #1297
 110d79c:	72a60000 	movk	w0, #0x3000, lsl #16
 110d7a0:	6b00003f 	cmp	w1, w0
 110d7a4:	54000740 	b.eq	110d88c <crypto_mac_alloc_ctx+0x148>  // b.none
 110d7a8:	540001c8 	b.hi	110d7e0 <crypto_mac_alloc_ctx+0x9c>  // b.pmore
 110d7ac:	52802260 	mov	w0, #0x113                 	// #275
 110d7b0:	72a60000 	movk	w0, #0x3000, lsl #16
 110d7b4:	6b00003f 	cmp	w1, w0
 110d7b8:	54000700 	b.eq	110d898 <crypto_mac_alloc_ctx+0x154>  // b.none
 110d7bc:	110ff400 	add	w0, w0, #0x3fd
 110d7c0:	6b00003f 	cmp	w1, w0
 110d7c4:	54000580 	b.eq	110d874 <crypto_mac_alloc_ctx+0x130>  // b.none
 110d7c8:	52802220 	mov	w0, #0x111                 	// #273
 110d7cc:	72a60000 	movk	w0, #0x3000, lsl #16
 110d7d0:	6b00003f 	cmp	w1, w0
 110d7d4:	54000560 	b.eq	110d880 <crypto_mac_alloc_ctx+0x13c>  // b.none
 110d7d8:	129ffea0 	mov	w0, #0xffff000a            	// #-65526
 110d7dc:	14000014 	b	110d82c <crypto_mac_alloc_ctx+0xe8>
 110d7e0:	5280c200 	mov	w0, #0x610                 	// #1552
 110d7e4:	72a60000 	movk	w0, #0x3000, lsl #16
 110d7e8:	6b00003f 	cmp	w1, w0
 110d7ec:	54000620 	b.eq	110d8b0 <crypto_mac_alloc_ctx+0x16c>  // b.none
 110d7f0:	5280c260 	mov	w0, #0x613                 	// #1555
 110d7f4:	72be0000 	movk	w0, #0xf000, lsl #16
 110d7f8:	6b00003f 	cmp	w1, w0
 110d7fc:	54000540 	b.eq	110d8a4 <crypto_mac_alloc_ctx+0x160>  // b.none
 110d800:	5280a260 	mov	w0, #0x513                 	// #1299
 110d804:	72a60000 	movk	w0, #0x3000, lsl #16
 110d808:	6b00003f 	cmp	w1, w0
 110d80c:	54fffe61 	b.ne	110d7d8 <crypto_mac_alloc_ctx+0x94>  // b.any
			res = crypto_des3_cbc_mac_pkcs5_alloc_ctx(&c);
 110d810:	9100a3e0 	add	x0, sp, #0x28
 110d814:	9400094c 	bl	110fd44 <crypto_des3_cbc_mac_pkcs5_alloc_ctx>
			break;
 110d818:	14000002 	b	110d820 <crypto_mac_alloc_ctx+0xdc>
			res = crypto_hmac_md5_alloc_ctx(&c);
 110d81c:	94006b69 	bl	11285c0 <crypto_hmac_md5_alloc_ctx>
	if (!res)
 110d820:	35000060 	cbnz	w0, 110d82c <crypto_mac_alloc_ctx+0xe8>
		*ctx = c;
 110d824:	f94017e1 	ldr	x1, [sp, #40]
 110d828:	f9000261 	str	x1, [x19]
}
 110d82c:	f9400bf3 	ldr	x19, [sp, #16]
 110d830:	a8c37bfd 	ldp	x29, x30, [sp], #48
 110d834:	d65f03c0 	ret
			res = crypto_hmac_sha1_alloc_ctx(&c);
 110d838:	94006b6e 	bl	11285f0 <crypto_hmac_sha1_alloc_ctx>
			break;
 110d83c:	17fffff9 	b	110d820 <crypto_mac_alloc_ctx+0xdc>
			res = crypto_hmac_sha224_alloc_ctx(&c);
 110d840:	94006b78 	bl	1128620 <crypto_hmac_sha224_alloc_ctx>
			break;
 110d844:	17fffff7 	b	110d820 <crypto_mac_alloc_ctx+0xdc>
			res = crypto_hmac_sha256_alloc_ctx(&c);
 110d848:	94006b82 	bl	1128650 <crypto_hmac_sha256_alloc_ctx>
			break;
 110d84c:	17fffff5 	b	110d820 <crypto_mac_alloc_ctx+0xdc>
			res = crypto_hmac_sha384_alloc_ctx(&c);
 110d850:	94006b8c 	bl	1128680 <crypto_hmac_sha384_alloc_ctx>
			break;
 110d854:	17fffff3 	b	110d820 <crypto_mac_alloc_ctx+0xdc>
			res = crypto_hmac_sha512_alloc_ctx(&c);
 110d858:	94006b96 	bl	11286b0 <crypto_hmac_sha512_alloc_ctx>
			break;
 110d85c:	17fffff1 	b	110d820 <crypto_mac_alloc_ctx+0xdc>
			res = crypto_hmac_sm3_alloc_ctx(&c);
 110d860:	94000ded 	bl	1111014 <crypto_hmac_sm3_alloc_ctx>
			break;
 110d864:	17ffffef 	b	110d820 <crypto_mac_alloc_ctx+0xdc>
			res = crypto_aes_cbc_mac_nopad_alloc_ctx(&c);
 110d868:	9100a3e0 	add	x0, sp, #0x28
 110d86c:	94000922 	bl	110fcf4 <crypto_aes_cbc_mac_nopad_alloc_ctx>
			break;
 110d870:	17ffffec 	b	110d820 <crypto_mac_alloc_ctx+0xdc>
			res = crypto_aes_cbc_mac_pkcs5_alloc_ctx(&c);
 110d874:	9100a3e0 	add	x0, sp, #0x28
 110d878:	94000923 	bl	110fd04 <crypto_aes_cbc_mac_pkcs5_alloc_ctx>
			break;
 110d87c:	17ffffe9 	b	110d820 <crypto_mac_alloc_ctx+0xdc>
			res = crypto_des_cbc_mac_nopad_alloc_ctx(&c);
 110d880:	9100a3e0 	add	x0, sp, #0x28
 110d884:	94000924 	bl	110fd14 <crypto_des_cbc_mac_nopad_alloc_ctx>
			break;
 110d888:	17ffffe6 	b	110d820 <crypto_mac_alloc_ctx+0xdc>
			res = crypto_des_cbc_mac_pkcs5_alloc_ctx(&c);
 110d88c:	9100a3e0 	add	x0, sp, #0x28
 110d890:	94000925 	bl	110fd24 <crypto_des_cbc_mac_pkcs5_alloc_ctx>
			break;
 110d894:	17ffffe3 	b	110d820 <crypto_mac_alloc_ctx+0xdc>
			res = crypto_des3_cbc_mac_nopad_alloc_ctx(&c);
 110d898:	9100a3e0 	add	x0, sp, #0x28
 110d89c:	94000926 	bl	110fd34 <crypto_des3_cbc_mac_nopad_alloc_ctx>
			break;
 110d8a0:	17ffffe0 	b	110d820 <crypto_mac_alloc_ctx+0xdc>
			res = crypto_des3_cmac_alloc_ctx(&c);
 110d8a4:	9100a3e0 	add	x0, sp, #0x28
 110d8a8:	94006c12 	bl	11288f0 <crypto_des3_cmac_alloc_ctx>
			break;
 110d8ac:	17ffffdd 	b	110d820 <crypto_mac_alloc_ctx+0xdc>
			res = crypto_aes_cmac_alloc_ctx(&c);
 110d8b0:	9100a3e0 	add	x0, sp, #0x28
 110d8b4:	94006c0c 	bl	11288e4 <crypto_aes_cmac_alloc_ctx>
			break;
 110d8b8:	17ffffda 	b	110d820 <crypto_mac_alloc_ctx+0xdc>

000000000110d8bc <crypto_mac_free_ctx>:
	if (ctx)
 110d8bc:	b4000180 	cbz	x0, 110d8ec <crypto_mac_free_ctx+0x30>
{
 110d8c0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 110d8c4:	910003fd 	mov	x29, sp
 110d8c8:	f9000bf3 	str	x19, [sp, #16]
 110d8cc:	aa0003f3 	mov	x19, x0
		mac_ops(ctx)->free_ctx(ctx);
 110d8d0:	97fffe2d 	bl	110d184 <mac_ops>
 110d8d4:	f9400c01 	ldr	x1, [x0, #24]
 110d8d8:	aa1303e0 	mov	x0, x19
}
 110d8dc:	f9400bf3 	ldr	x19, [sp, #16]
		mac_ops(ctx)->free_ctx(ctx);
 110d8e0:	aa0103f0 	mov	x16, x1
}
 110d8e4:	a8c27bfd 	ldp	x29, x30, [sp], #32
		mac_ops(ctx)->free_ctx(ctx);
 110d8e8:	d61f0200 	br	x16
 110d8ec:	d65f03c0 	ret

000000000110d8f0 <crypto_mac_copy_state>:
{
 110d8f0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 110d8f4:	910003fd 	mov	x29, sp
 110d8f8:	a90153f3 	stp	x19, x20, [sp, #16]
 110d8fc:	aa0003f3 	mov	x19, x0
 110d900:	aa0103f4 	mov	x20, x1
	mac_ops(dst_ctx)->copy_state(dst_ctx, src_ctx);
 110d904:	97fffe20 	bl	110d184 <mac_ops>
 110d908:	aa1403e1 	mov	x1, x20
 110d90c:	f9401002 	ldr	x2, [x0, #32]
 110d910:	aa1303e0 	mov	x0, x19
}
 110d914:	a94153f3 	ldp	x19, x20, [sp, #16]
	mac_ops(dst_ctx)->copy_state(dst_ctx, src_ctx);
 110d918:	aa0203f0 	mov	x16, x2
}
 110d91c:	a8c27bfd 	ldp	x29, x30, [sp], #32
	mac_ops(dst_ctx)->copy_state(dst_ctx, src_ctx);
 110d920:	d61f0200 	br	x16

000000000110d924 <crypto_mac_init>:
{
 110d924:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 110d928:	910003fd 	mov	x29, sp
 110d92c:	a90153f3 	stp	x19, x20, [sp, #16]
 110d930:	aa0003f3 	mov	x19, x0
 110d934:	aa0103f4 	mov	x20, x1
 110d938:	f90013f5 	str	x21, [sp, #32]
 110d93c:	aa0203f5 	mov	x21, x2
	return mac_ops(ctx)->init(ctx, key, len);
 110d940:	97fffe11 	bl	110d184 <mac_ops>
 110d944:	aa1503e2 	mov	x2, x21
 110d948:	aa1403e1 	mov	x1, x20
 110d94c:	f9400003 	ldr	x3, [x0]
 110d950:	aa1303e0 	mov	x0, x19
}
 110d954:	a94153f3 	ldp	x19, x20, [sp, #16]
	return mac_ops(ctx)->init(ctx, key, len);
 110d958:	aa0303f0 	mov	x16, x3
}
 110d95c:	f94013f5 	ldr	x21, [sp, #32]
 110d960:	a8c37bfd 	ldp	x29, x30, [sp], #48
	return mac_ops(ctx)->init(ctx, key, len);
 110d964:	d61f0200 	br	x16

000000000110d968 <crypto_mac_update>:
	if (!len)
 110d968:	b4000242 	cbz	x2, 110d9b0 <crypto_mac_update+0x48>
{
 110d96c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 110d970:	910003fd 	mov	x29, sp
 110d974:	a90153f3 	stp	x19, x20, [sp, #16]
 110d978:	aa0003f4 	mov	x20, x0
 110d97c:	aa0203f3 	mov	x19, x2
 110d980:	f90013f5 	str	x21, [sp, #32]
 110d984:	aa0103f5 	mov	x21, x1
	return mac_ops(ctx)->update(ctx, data, len);
 110d988:	97fffdff 	bl	110d184 <mac_ops>
 110d98c:	aa1303e2 	mov	x2, x19
 110d990:	aa1503e1 	mov	x1, x21
 110d994:	f9400403 	ldr	x3, [x0, #8]
 110d998:	aa1403e0 	mov	x0, x20
}
 110d99c:	a94153f3 	ldp	x19, x20, [sp, #16]
	return mac_ops(ctx)->update(ctx, data, len);
 110d9a0:	aa0303f0 	mov	x16, x3
}
 110d9a4:	f94013f5 	ldr	x21, [sp, #32]
 110d9a8:	a8c37bfd 	ldp	x29, x30, [sp], #48
	return mac_ops(ctx)->update(ctx, data, len);
 110d9ac:	d61f0200 	br	x16
}
 110d9b0:	52800000 	mov	w0, #0x0                   	// #0
 110d9b4:	d65f03c0 	ret

000000000110d9b8 <crypto_mac_final>:
{
 110d9b8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 110d9bc:	910003fd 	mov	x29, sp
 110d9c0:	a90153f3 	stp	x19, x20, [sp, #16]
 110d9c4:	aa0003f3 	mov	x19, x0
 110d9c8:	aa0103f4 	mov	x20, x1
 110d9cc:	f90013f5 	str	x21, [sp, #32]
 110d9d0:	aa0203f5 	mov	x21, x2
	return mac_ops(ctx)->final(ctx, digest, digest_len);
 110d9d4:	97fffdec 	bl	110d184 <mac_ops>
 110d9d8:	aa1503e2 	mov	x2, x21
 110d9dc:	aa1403e1 	mov	x1, x20
 110d9e0:	f9400803 	ldr	x3, [x0, #16]
 110d9e4:	aa1303e0 	mov	x0, x19
}
 110d9e8:	a94153f3 	ldp	x19, x20, [sp, #16]
	return mac_ops(ctx)->final(ctx, digest, digest_len);
 110d9ec:	aa0303f0 	mov	x16, x3
}
 110d9f0:	f94013f5 	ldr	x21, [sp, #32]
 110d9f4:	a8c37bfd 	ldp	x29, x30, [sp], #48
	return mac_ops(ctx)->final(ctx, digest, digest_len);
 110d9f8:	d61f0200 	br	x16

000000000110d9fc <crypto_authenc_alloc_ctx>:
{
 110d9fc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 110da00:	910003fd 	mov	x29, sp
 110da04:	f9000bf3 	str	x19, [sp, #16]
 110da08:	aa0003f3 	mov	x19, x0
	struct crypto_authenc_ctx *c = NULL;
 110da0c:	f90017ff 	str	xzr, [sp, #40]
	switch (algo) {
 110da10:	5280e200 	mov	w0, #0x710                 	// #1808
 110da14:	72a80000 	movk	w0, #0x4000, lsl #16
 110da18:	6b00003f 	cmp	w1, w0
 110da1c:	54000100 	b.eq	110da3c <crypto_authenc_alloc_ctx+0x40>  // b.none
 110da20:	11040000 	add	w0, w0, #0x100
 110da24:	6b00003f 	cmp	w1, w0
 110da28:	54000160 	b.eq	110da54 <crypto_authenc_alloc_ctx+0x58>  // b.none
 110da2c:	129ffec0 	mov	w0, #0xffff0009            	// #-65527
}
 110da30:	f9400bf3 	ldr	x19, [sp, #16]
 110da34:	a8c37bfd 	ldp	x29, x30, [sp], #48
 110da38:	d65f03c0 	ret
		res = crypto_aes_ccm_alloc_ctx(&c);
 110da3c:	9100a3e0 	add	x0, sp, #0x28
 110da40:	94006f79 	bl	1129824 <crypto_aes_ccm_alloc_ctx>
	if (!res)
 110da44:	35ffff60 	cbnz	w0, 110da30 <crypto_authenc_alloc_ctx+0x34>
		*ctx = c;
 110da48:	f94017e1 	ldr	x1, [sp, #40]
 110da4c:	f9000261 	str	x1, [x19]
 110da50:	17fffff8 	b	110da30 <crypto_authenc_alloc_ctx+0x34>
		res = crypto_aes_gcm_alloc_ctx(&c);
 110da54:	9100a3e0 	add	x0, sp, #0x28
 110da58:	94000396 	bl	110e8b0 <crypto_aes_gcm_alloc_ctx>
		break;
 110da5c:	17fffffa 	b	110da44 <crypto_authenc_alloc_ctx+0x48>

000000000110da60 <crypto_authenc_init>:
TEE_Result crypto_authenc_init(void *ctx, TEE_OperationMode mode,
			       const uint8_t *key, size_t key_len,
			       const uint8_t *nonce, size_t nonce_len,
			       size_t tag_len, size_t aad_len,
			       size_t payload_len)
{
 110da60:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 110da64:	910003fd 	mov	x29, sp
 110da68:	a90153f3 	stp	x19, x20, [sp, #16]
 110da6c:	aa0003f3 	mov	x19, x0
 110da70:	2a0103f4 	mov	w20, w1
 110da74:	a9025bf5 	stp	x21, x22, [sp, #32]
 110da78:	aa0203f5 	mov	x21, x2
 110da7c:	aa0303f6 	mov	x22, x3
 110da80:	a90363f7 	stp	x23, x24, [sp, #48]
 110da84:	aa0403f7 	mov	x23, x4
 110da88:	aa0503f8 	mov	x24, x5
 110da8c:	a9046bf9 	stp	x25, x26, [sp, #64]
 110da90:	aa0603f9 	mov	x25, x6
 110da94:	aa0703fa 	mov	x26, x7
	return ae_ops(ctx)->init(ctx, mode, key, key_len, nonce, nonce_len,
 110da98:	97fffdca 	bl	110d1c0 <ae_ops>
 110da9c:	aa1a03e7 	mov	x7, x26
 110daa0:	aa1903e6 	mov	x6, x25
 110daa4:	aa1803e5 	mov	x5, x24
 110daa8:	aa1703e4 	mov	x4, x23
 110daac:	aa1603e3 	mov	x3, x22
 110dab0:	aa1503e2 	mov	x2, x21
 110dab4:	2a1403e1 	mov	w1, w20
 110dab8:	f9400008 	ldr	x8, [x0]
 110dabc:	aa1303e0 	mov	x0, x19
				 tag_len, aad_len, payload_len);
}
 110dac0:	a94153f3 	ldp	x19, x20, [sp, #16]
	return ae_ops(ctx)->init(ctx, mode, key, key_len, nonce, nonce_len,
 110dac4:	aa0803f0 	mov	x16, x8
}
 110dac8:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110dacc:	a94363f7 	ldp	x23, x24, [sp, #48]
 110dad0:	a9446bf9 	ldp	x25, x26, [sp, #64]
 110dad4:	a8c57bfd 	ldp	x29, x30, [sp], #80
	return ae_ops(ctx)->init(ctx, mode, key, key_len, nonce, nonce_len,
 110dad8:	d61f0200 	br	x16

000000000110dadc <crypto_authenc_update_aad>:

TEE_Result crypto_authenc_update_aad(void *ctx, TEE_OperationMode mode __unused,
				     const uint8_t *data, size_t len)
{
 110dadc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 110dae0:	910003fd 	mov	x29, sp
 110dae4:	a90153f3 	stp	x19, x20, [sp, #16]
 110dae8:	aa0203f4 	mov	x20, x2
 110daec:	aa0003f3 	mov	x19, x0
 110daf0:	f90013f5 	str	x21, [sp, #32]
 110daf4:	aa0303f5 	mov	x21, x3
	return ae_ops(ctx)->update_aad(ctx, data, len);
 110daf8:	97fffdb2 	bl	110d1c0 <ae_ops>
 110dafc:	aa1503e2 	mov	x2, x21
 110db00:	aa1403e1 	mov	x1, x20
 110db04:	f9400403 	ldr	x3, [x0, #8]
 110db08:	aa1303e0 	mov	x0, x19
}
 110db0c:	a94153f3 	ldp	x19, x20, [sp, #16]
	return ae_ops(ctx)->update_aad(ctx, data, len);
 110db10:	aa0303f0 	mov	x16, x3
}
 110db14:	f94013f5 	ldr	x21, [sp, #32]
 110db18:	a8c37bfd 	ldp	x29, x30, [sp], #48
	return ae_ops(ctx)->update_aad(ctx, data, len);
 110db1c:	d61f0200 	br	x16

000000000110db20 <crypto_authenc_update_payload>:

TEE_Result crypto_authenc_update_payload(void *ctx, TEE_OperationMode mode,
					 const uint8_t *src_data,
					 size_t src_len, uint8_t *dst_data,
					 size_t *dst_len)
{
 110db20:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 110db24:	910003fd 	mov	x29, sp
 110db28:	a9025bf5 	stp	x21, x22, [sp, #32]
 110db2c:	2a0103f5 	mov	w21, w1
	if (*dst_len < src_len)
 110db30:	f94000a1 	ldr	x1, [x5]
{
 110db34:	a90153f3 	stp	x19, x20, [sp, #16]
 110db38:	f9001bf7 	str	x23, [sp, #48]
	if (*dst_len < src_len)
 110db3c:	eb03003f 	cmp	x1, x3
 110db40:	54000263 	b.cc	110db8c <crypto_authenc_update_payload+0x6c>  // b.lo, b.ul, b.last
		return TEE_ERROR_SHORT_BUFFER;
	*dst_len = src_len;
 110db44:	f90000a3 	str	x3, [x5]
 110db48:	aa0003f4 	mov	x20, x0
 110db4c:	aa0203f6 	mov	x22, x2
 110db50:	aa0303f3 	mov	x19, x3
 110db54:	aa0403f7 	mov	x23, x4

	return ae_ops(ctx)->update_payload(ctx, mode, src_data, src_len,
 110db58:	97fffd9a 	bl	110d1c0 <ae_ops>
 110db5c:	aa1703e4 	mov	x4, x23
 110db60:	aa1303e3 	mov	x3, x19
 110db64:	aa1603e2 	mov	x2, x22
 110db68:	2a1503e1 	mov	w1, w21
 110db6c:	f9400805 	ldr	x5, [x0, #16]
 110db70:	aa1403e0 	mov	x0, x20
					   dst_data);
}
 110db74:	a94153f3 	ldp	x19, x20, [sp, #16]
	return ae_ops(ctx)->update_payload(ctx, mode, src_data, src_len,
 110db78:	aa0503f0 	mov	x16, x5
}
 110db7c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110db80:	f9401bf7 	ldr	x23, [sp, #48]
 110db84:	a8c47bfd 	ldp	x29, x30, [sp], #64
	return ae_ops(ctx)->update_payload(ctx, mode, src_data, src_len,
 110db88:	d61f0200 	br	x16
}
 110db8c:	129ffde0 	mov	w0, #0xffff0010            	// #-65520
 110db90:	a94153f3 	ldp	x19, x20, [sp, #16]
 110db94:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110db98:	f9401bf7 	ldr	x23, [sp, #48]
 110db9c:	a8c47bfd 	ldp	x29, x30, [sp], #64
 110dba0:	d65f03c0 	ret

000000000110dba4 <crypto_authenc_enc_final>:

TEE_Result crypto_authenc_enc_final(void *ctx, const uint8_t *src_data,
				    size_t src_len, uint8_t *dst_data,
				    size_t *dst_len, uint8_t *dst_tag,
				    size_t *dst_tag_len)
{
 110dba4:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 110dba8:	910003fd 	mov	x29, sp
 110dbac:	a9025bf5 	stp	x21, x22, [sp, #32]
 110dbb0:	aa0103f5 	mov	x21, x1
	if (*dst_len < src_len)
 110dbb4:	f9400081 	ldr	x1, [x4]
{
 110dbb8:	a90153f3 	stp	x19, x20, [sp, #16]
 110dbbc:	aa0203f3 	mov	x19, x2
 110dbc0:	a90363f7 	stp	x23, x24, [sp, #48]
	if (*dst_len < src_len)
 110dbc4:	eb02003f 	cmp	x1, x2
 110dbc8:	54000283 	b.cc	110dc18 <crypto_authenc_enc_final+0x74>  // b.lo, b.ul, b.last
		return TEE_ERROR_SHORT_BUFFER;
	*dst_len = src_len;
 110dbcc:	f9000082 	str	x2, [x4]
 110dbd0:	aa0503f7 	mov	x23, x5
 110dbd4:	aa0603f8 	mov	x24, x6

	return ae_ops(ctx)->enc_final(ctx, src_data, src_len, dst_data,
 110dbd8:	aa0003f4 	mov	x20, x0
 110dbdc:	aa0303f6 	mov	x22, x3
 110dbe0:	97fffd78 	bl	110d1c0 <ae_ops>
 110dbe4:	aa1803e5 	mov	x5, x24
 110dbe8:	aa1703e4 	mov	x4, x23
 110dbec:	aa1603e3 	mov	x3, x22
 110dbf0:	aa1303e2 	mov	x2, x19
 110dbf4:	aa1503e1 	mov	x1, x21
 110dbf8:	f9400c06 	ldr	x6, [x0, #24]
 110dbfc:	aa1403e0 	mov	x0, x20
				      dst_tag, dst_tag_len);
}
 110dc00:	a94153f3 	ldp	x19, x20, [sp, #16]
	return ae_ops(ctx)->enc_final(ctx, src_data, src_len, dst_data,
 110dc04:	aa0603f0 	mov	x16, x6
}
 110dc08:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110dc0c:	a94363f7 	ldp	x23, x24, [sp, #48]
 110dc10:	a8c47bfd 	ldp	x29, x30, [sp], #64
	return ae_ops(ctx)->enc_final(ctx, src_data, src_len, dst_data,
 110dc14:	d61f0200 	br	x16
}
 110dc18:	129ffde0 	mov	w0, #0xffff0010            	// #-65520
 110dc1c:	a94153f3 	ldp	x19, x20, [sp, #16]
 110dc20:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110dc24:	a94363f7 	ldp	x23, x24, [sp, #48]
 110dc28:	a8c47bfd 	ldp	x29, x30, [sp], #64
 110dc2c:	d65f03c0 	ret

000000000110dc30 <crypto_authenc_dec_final>:

TEE_Result crypto_authenc_dec_final(void *ctx, const uint8_t *src_data,
				    size_t src_len, uint8_t *dst_data,
				    size_t *dst_len, const uint8_t *tag,
				    size_t tag_len)
{
 110dc30:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 110dc34:	910003fd 	mov	x29, sp
 110dc38:	a9025bf5 	stp	x21, x22, [sp, #32]
 110dc3c:	aa0103f5 	mov	x21, x1
	if (*dst_len < src_len)
 110dc40:	f9400081 	ldr	x1, [x4]
{
 110dc44:	a90153f3 	stp	x19, x20, [sp, #16]
 110dc48:	aa0203f3 	mov	x19, x2
 110dc4c:	a90363f7 	stp	x23, x24, [sp, #48]
	if (*dst_len < src_len)
 110dc50:	eb02003f 	cmp	x1, x2
 110dc54:	54000283 	b.cc	110dca4 <crypto_authenc_dec_final+0x74>  // b.lo, b.ul, b.last
		return TEE_ERROR_SHORT_BUFFER;
	*dst_len = src_len;
 110dc58:	f9000082 	str	x2, [x4]
 110dc5c:	aa0503f7 	mov	x23, x5
 110dc60:	aa0603f8 	mov	x24, x6

	return ae_ops(ctx)->dec_final(ctx, src_data, src_len, dst_data, tag,
 110dc64:	aa0003f4 	mov	x20, x0
 110dc68:	aa0303f6 	mov	x22, x3
 110dc6c:	97fffd55 	bl	110d1c0 <ae_ops>
 110dc70:	aa1803e5 	mov	x5, x24
 110dc74:	aa1703e4 	mov	x4, x23
 110dc78:	aa1603e3 	mov	x3, x22
 110dc7c:	aa1303e2 	mov	x2, x19
 110dc80:	aa1503e1 	mov	x1, x21
 110dc84:	f9401006 	ldr	x6, [x0, #32]
 110dc88:	aa1403e0 	mov	x0, x20
				      tag_len);
}
 110dc8c:	a94153f3 	ldp	x19, x20, [sp, #16]
	return ae_ops(ctx)->dec_final(ctx, src_data, src_len, dst_data, tag,
 110dc90:	aa0603f0 	mov	x16, x6
}
 110dc94:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110dc98:	a94363f7 	ldp	x23, x24, [sp, #48]
 110dc9c:	a8c47bfd 	ldp	x29, x30, [sp], #64
	return ae_ops(ctx)->dec_final(ctx, src_data, src_len, dst_data, tag,
 110dca0:	d61f0200 	br	x16
}
 110dca4:	129ffde0 	mov	w0, #0xffff0010            	// #-65520
 110dca8:	a94153f3 	ldp	x19, x20, [sp, #16]
 110dcac:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110dcb0:	a94363f7 	ldp	x23, x24, [sp, #48]
 110dcb4:	a8c47bfd 	ldp	x29, x30, [sp], #64
 110dcb8:	d65f03c0 	ret

000000000110dcbc <crypto_authenc_final>:

void crypto_authenc_final(void *ctx)
{
 110dcbc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 110dcc0:	910003fd 	mov	x29, sp
 110dcc4:	f9000bf3 	str	x19, [sp, #16]
 110dcc8:	aa0003f3 	mov	x19, x0
	ae_ops(ctx)->final(ctx);
 110dccc:	97fffd3d 	bl	110d1c0 <ae_ops>
 110dcd0:	f9401401 	ldr	x1, [x0, #40]
 110dcd4:	aa1303e0 	mov	x0, x19
}
 110dcd8:	f9400bf3 	ldr	x19, [sp, #16]
	ae_ops(ctx)->final(ctx);
 110dcdc:	aa0103f0 	mov	x16, x1
}
 110dce0:	a8c27bfd 	ldp	x29, x30, [sp], #32
	ae_ops(ctx)->final(ctx);
 110dce4:	d61f0200 	br	x16

000000000110dce8 <crypto_authenc_free_ctx>:

void crypto_authenc_free_ctx(void *ctx)
{
	if (ctx)
 110dce8:	b4000180 	cbz	x0, 110dd18 <crypto_authenc_free_ctx+0x30>
{
 110dcec:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 110dcf0:	910003fd 	mov	x29, sp
 110dcf4:	f9000bf3 	str	x19, [sp, #16]
 110dcf8:	aa0003f3 	mov	x19, x0
		ae_ops(ctx)->free_ctx(ctx);
 110dcfc:	97fffd31 	bl	110d1c0 <ae_ops>
 110dd00:	f9401801 	ldr	x1, [x0, #48]
 110dd04:	aa1303e0 	mov	x0, x19
}
 110dd08:	f9400bf3 	ldr	x19, [sp, #16]
		ae_ops(ctx)->free_ctx(ctx);
 110dd0c:	aa0103f0 	mov	x16, x1
}
 110dd10:	a8c27bfd 	ldp	x29, x30, [sp], #32
		ae_ops(ctx)->free_ctx(ctx);
 110dd14:	d61f0200 	br	x16
 110dd18:	d65f03c0 	ret

000000000110dd1c <crypto_authenc_copy_state>:

void crypto_authenc_copy_state(void *dst_ctx, void *src_ctx)
{
 110dd1c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 110dd20:	910003fd 	mov	x29, sp
 110dd24:	a90153f3 	stp	x19, x20, [sp, #16]
 110dd28:	aa0003f3 	mov	x19, x0
 110dd2c:	aa0103f4 	mov	x20, x1
	ae_ops(dst_ctx)->copy_state(dst_ctx, src_ctx);
 110dd30:	97fffd24 	bl	110d1c0 <ae_ops>
 110dd34:	aa1403e1 	mov	x1, x20
 110dd38:	f9401c02 	ldr	x2, [x0, #56]
 110dd3c:	aa1303e0 	mov	x0, x19
}
 110dd40:	a94153f3 	ldp	x19, x20, [sp, #16]
	ae_ops(dst_ctx)->copy_state(dst_ctx, src_ctx);
 110dd44:	aa0203f0 	mov	x16, x2
}
 110dd48:	a8c27bfd 	ldp	x29, x30, [sp], #32
	ae_ops(dst_ctx)->copy_state(dst_ctx, src_ctx);
 110dd4c:	d61f0200 	br	x16

000000000110dd50 <crypto_acipher_alloc_ecc_public_key>:
	 * Use default cryptographic implementation if no matching
	 * drvcrypt device.
	 */
	res = drvcrypt_asym_alloc_ecc_public_key(key, key_type, key_size_bits);
	if (res == TEE_ERROR_NOT_IMPLEMENTED)
		res = crypto_asym_alloc_ecc_public_key(key, key_type,
 110dd50:	14007284 	b	112a760 <crypto_asym_alloc_ecc_public_key>

000000000110dd54 <crypto_acipher_alloc_ecc_keypair>:
	 * Use default cryptographic implementation if no matching
	 * drvcrypt device.
	 */
	res = drvcrypt_asym_alloc_ecc_keypair(key, key_type, key_size_bits);
	if (res == TEE_ERROR_NOT_IMPLEMENTED)
		res = crypto_asym_alloc_ecc_keypair(key, key_type,
 110dd54:	1400724b 	b	112a680 <crypto_asym_alloc_ecc_keypair>

000000000110dd58 <crypto_acipher_free_ecc_public_key>:
	return res;
}

void crypto_acipher_free_ecc_public_key(struct ecc_public_key *key)
{
	assert(key->ops && key->ops->free);
 110dd58:	f9400c01 	ldr	x1, [x0, #24]
 110dd5c:	b4000061 	cbz	x1, 110dd68 <crypto_acipher_free_ecc_public_key+0x10>
 110dd60:	f9400021 	ldr	x1, [x1]
 110dd64:	b5000181 	cbnz	x1, 110dd94 <crypto_acipher_free_ecc_public_key+0x3c>
 110dd68:	d0000223 	adrp	x3, 1153000 <__func__.3477+0x91>
 110dd6c:	d0000221 	adrp	x1, 1153000 <__func__.3477+0x91>
 110dd70:	9128fc63 	add	x3, x3, #0xa3f
 110dd74:	9126c021 	add	x1, x1, #0x9b0
 110dd78:	d0000220 	adrp	x0, 1153000 <__func__.3477+0x91>
 110dd7c:	91274400 	add	x0, x0, #0x9d1
{
 110dd80:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	assert(key->ops && key->ops->free);
 110dd84:	52805842 	mov	w2, #0x2c2                 	// #706
{
 110dd88:	910003fd 	mov	x29, sp
	assert(key->ops && key->ops->free);
 110dd8c:	94001148 	bl	11122ac <_assert_log>
 110dd90:	94001158 	bl	11122f0 <_assert_break>

	key->ops->free(key);
 110dd94:	aa0103f0 	mov	x16, x1
 110dd98:	d61f0200 	br	x16

000000000110dd9c <crypto_acipher_gen_ecc_key>:
}

TEE_Result crypto_acipher_gen_ecc_key(struct ecc_keypair *key,
				      size_t key_size_bits)
{
	assert(key->ops && key->ops->generate);
 110dd9c:	f9401002 	ldr	x2, [x0, #32]
 110dda0:	b4000062 	cbz	x2, 110ddac <crypto_acipher_gen_ecc_key+0x10>
 110dda4:	f9400042 	ldr	x2, [x2]
 110dda8:	b5000182 	cbnz	x2, 110ddd8 <crypto_acipher_gen_ecc_key+0x3c>
 110ddac:	d0000223 	adrp	x3, 1153000 <__func__.3477+0x91>
 110ddb0:	d0000221 	adrp	x1, 1153000 <__func__.3477+0x91>
 110ddb4:	91298863 	add	x3, x3, #0xa62
 110ddb8:	9126c021 	add	x1, x1, #0x9b0
 110ddbc:	d0000220 	adrp	x0, 1153000 <__func__.3477+0x91>
 110ddc0:	9127b000 	add	x0, x0, #0x9ec
{
 110ddc4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	assert(key->ops && key->ops->generate);
 110ddc8:	52805942 	mov	w2, #0x2ca                 	// #714
{
 110ddcc:	910003fd 	mov	x29, sp
	assert(key->ops && key->ops->generate);
 110ddd0:	94001137 	bl	11122ac <_assert_log>
 110ddd4:	94001147 	bl	11122f0 <_assert_break>

	return key->ops->generate(key, key_size_bits);
 110ddd8:	aa0203f0 	mov	x16, x2
 110dddc:	d61f0200 	br	x16

000000000110dde0 <crypto_acipher_ecc_sign>:

TEE_Result crypto_acipher_ecc_sign(uint32_t algo, struct ecc_keypair *key,
				   const uint8_t *msg, size_t msg_len,
				   uint8_t *sig, size_t *sig_len)
{
	assert(key->ops);
 110dde0:	f9401026 	ldr	x6, [x1, #32]
 110dde4:	b5000186 	cbnz	x6, 110de14 <crypto_acipher_ecc_sign+0x34>
 110dde8:	d0000223 	adrp	x3, 1153000 <__func__.3477+0x91>
 110ddec:	d0000221 	adrp	x1, 1153000 <__func__.3477+0x91>
 110ddf0:	9129f463 	add	x3, x3, #0xa7d
 110ddf4:	9126c021 	add	x1, x1, #0x9b0
 110ddf8:	d0000220 	adrp	x0, 1153000 <__func__.3477+0x91>
 110ddfc:	91284c00 	add	x0, x0, #0xa13
{
 110de00:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	assert(key->ops);
 110de04:	52805a62 	mov	w2, #0x2d3                 	// #723
{
 110de08:	910003fd 	mov	x29, sp
	assert(key->ops);
 110de0c:	94001128 	bl	11122ac <_assert_log>
 110de10:	94001138 	bl	11122f0 <_assert_break>

	if (!key->ops->sign)
 110de14:	f94004c6 	ldr	x6, [x6, #8]
 110de18:	b4000066 	cbz	x6, 110de24 <crypto_acipher_ecc_sign+0x44>
		return TEE_ERROR_NOT_IMPLEMENTED;

	return key->ops->sign(algo, key, msg, msg_len, sig, sig_len);
 110de1c:	aa0603f0 	mov	x16, x6
 110de20:	d61f0200 	br	x16
}
 110de24:	129ffec0 	mov	w0, #0xffff0009            	// #-65527
 110de28:	d65f03c0 	ret

000000000110de2c <crypto_acipher_ecc_verify>:

TEE_Result crypto_acipher_ecc_verify(uint32_t algo, struct ecc_public_key *key,
				     const uint8_t *msg, size_t msg_len,
				     const uint8_t *sig, size_t sig_len)
{
	assert(key->ops);
 110de2c:	f9400c26 	ldr	x6, [x1, #24]
 110de30:	b5000186 	cbnz	x6, 110de60 <crypto_acipher_ecc_verify+0x34>
 110de34:	d0000223 	adrp	x3, 1153000 <__func__.3477+0x91>
 110de38:	d0000221 	adrp	x1, 1153000 <__func__.3477+0x91>
 110de3c:	912a5463 	add	x3, x3, #0xa95
 110de40:	9126c021 	add	x1, x1, #0x9b0
 110de44:	d0000220 	adrp	x0, 1153000 <__func__.3477+0x91>
 110de48:	91284c00 	add	x0, x0, #0xa13
{
 110de4c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	assert(key->ops);
 110de50:	52805be2 	mov	w2, #0x2df                 	// #735
{
 110de54:	910003fd 	mov	x29, sp
	assert(key->ops);
 110de58:	94001115 	bl	11122ac <_assert_log>
 110de5c:	94001125 	bl	11122f0 <_assert_break>

	if (!key->ops->verify)
 110de60:	f94004c6 	ldr	x6, [x6, #8]
 110de64:	b4000066 	cbz	x6, 110de70 <crypto_acipher_ecc_verify+0x44>
		return TEE_ERROR_NOT_IMPLEMENTED;

	return key->ops->verify(algo, key, msg, msg_len, sig, sig_len);
 110de68:	aa0603f0 	mov	x16, x6
 110de6c:	d61f0200 	br	x16
}
 110de70:	129ffec0 	mov	w0, #0xffff0009            	// #-65527
 110de74:	d65f03c0 	ret

000000000110de78 <crypto_acipher_ecc_shared_secret>:
TEE_Result crypto_acipher_ecc_shared_secret(struct ecc_keypair *private_key,
					    struct ecc_public_key *public_key,
					    void *secret,
					    unsigned long *secret_len)
{
	assert(private_key->ops);
 110de78:	f9401004 	ldr	x4, [x0, #32]
 110de7c:	b5000184 	cbnz	x4, 110deac <crypto_acipher_ecc_shared_secret+0x34>
 110de80:	d0000223 	adrp	x3, 1153000 <__func__.3477+0x91>
 110de84:	d0000221 	adrp	x1, 1153000 <__func__.3477+0x91>
 110de88:	912abc63 	add	x3, x3, #0xaaf
 110de8c:	9126c021 	add	x1, x1, #0x9b0
 110de90:	d0000220 	adrp	x0, 1153000 <__func__.3477+0x91>
 110de94:	91282c00 	add	x0, x0, #0xa0b
{
 110de98:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	assert(private_key->ops);
 110de9c:	52805d82 	mov	w2, #0x2ec                 	// #748
{
 110dea0:	910003fd 	mov	x29, sp
	assert(private_key->ops);
 110dea4:	94001102 	bl	11122ac <_assert_log>
 110dea8:	94001112 	bl	11122f0 <_assert_break>

	if (!private_key->ops->shared_secret)
 110deac:	f9400884 	ldr	x4, [x4, #16]
 110deb0:	b4000064 	cbz	x4, 110debc <crypto_acipher_ecc_shared_secret+0x44>
		return TEE_ERROR_NOT_IMPLEMENTED;

	return private_key->ops->shared_secret(private_key, public_key, secret,
 110deb4:	aa0403f0 	mov	x16, x4
 110deb8:	d61f0200 	br	x16
					       secret_len);
}
 110debc:	129ffec0 	mov	w0, #0xffff0009            	// #-65527
 110dec0:	d65f03c0 	ret

000000000110dec4 <crypto_acipher_sm2_pke_decrypt>:

TEE_Result crypto_acipher_sm2_pke_decrypt(struct ecc_keypair *key,
					  const uint8_t *src, size_t src_len,
					  uint8_t *dst, size_t *dst_len)
{
	assert(key->ops);
 110dec4:	f9401005 	ldr	x5, [x0, #32]
 110dec8:	b5000185 	cbnz	x5, 110def8 <crypto_acipher_sm2_pke_decrypt+0x34>
 110decc:	d0000223 	adrp	x3, 1153000 <__func__.3477+0x91>
 110ded0:	d0000221 	adrp	x1, 1153000 <__func__.3477+0x91>
 110ded4:	912b4063 	add	x3, x3, #0xad0
 110ded8:	9126c021 	add	x1, x1, #0x9b0
 110dedc:	d0000220 	adrp	x0, 1153000 <__func__.3477+0x91>
 110dee0:	91284c00 	add	x0, x0, #0xa13
{
 110dee4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	assert(key->ops);
 110dee8:	52805f22 	mov	w2, #0x2f9                 	// #761
{
 110deec:	910003fd 	mov	x29, sp
	assert(key->ops);
 110def0:	940010ef 	bl	11122ac <_assert_log>
 110def4:	940010ff 	bl	11122f0 <_assert_break>

	if (!key->ops->decrypt)
 110def8:	f9400ca5 	ldr	x5, [x5, #24]
 110defc:	b4000065 	cbz	x5, 110df08 <crypto_acipher_sm2_pke_decrypt+0x44>
		return TEE_ERROR_NOT_IMPLEMENTED;

	return key->ops->decrypt(key, src, src_len, dst, dst_len);
 110df00:	aa0503f0 	mov	x16, x5
 110df04:	d61f0200 	br	x16
}
 110df08:	129ffec0 	mov	w0, #0xffff0009            	// #-65527
 110df0c:	d65f03c0 	ret

000000000110df10 <crypto_acipher_sm2_pke_encrypt>:

TEE_Result crypto_acipher_sm2_pke_encrypt(struct ecc_public_key *key,
					  const uint8_t *src, size_t src_len,
					  uint8_t *dst, size_t *dst_len)
{
	assert(key->ops);
 110df10:	f9400c05 	ldr	x5, [x0, #24]
 110df14:	b5000185 	cbnz	x5, 110df44 <crypto_acipher_sm2_pke_encrypt+0x34>
 110df18:	d0000223 	adrp	x3, 1153000 <__func__.3477+0x91>
 110df1c:	d0000221 	adrp	x1, 1153000 <__func__.3477+0x91>
 110df20:	912bbc63 	add	x3, x3, #0xaef
 110df24:	9126c021 	add	x1, x1, #0x9b0
 110df28:	d0000220 	adrp	x0, 1153000 <__func__.3477+0x91>
 110df2c:	91284c00 	add	x0, x0, #0xa13
{
 110df30:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	assert(key->ops);
 110df34:	528060a2 	mov	w2, #0x305                 	// #773
{
 110df38:	910003fd 	mov	x29, sp
	assert(key->ops);
 110df3c:	940010dc 	bl	11122ac <_assert_log>
 110df40:	940010ec 	bl	11122f0 <_assert_break>

	if (!key->ops->encrypt)
 110df44:	f94008a5 	ldr	x5, [x5, #16]
 110df48:	b4000065 	cbz	x5, 110df54 <crypto_acipher_sm2_pke_encrypt+0x44>
		return TEE_ERROR_NOT_IMPLEMENTED;

	return key->ops->encrypt(key, src, src_len, dst, dst_len);
 110df4c:	aa0503f0 	mov	x16, x5
 110df50:	d61f0200 	br	x16
}
 110df54:	129ffec0 	mov	w0, #0xffff0009            	// #-65527
 110df58:	d65f03c0 	ret

000000000110df5c <aes_gcm_final>:
					  dst, tag, tag_len);
}

static void aes_gcm_final(struct crypto_authenc_ctx *aec __unused)
{
}
 110df5c:	d65f03c0 	ret

000000000110df60 <__gcm_update_aad>:
{
 110df60:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 110df64:	910003fd 	mov	x29, sp
 110df68:	a9046bf9 	stp	x25, x26, [sp, #64]
	if (state->payload_bytes)
 110df6c:	b941581a 	ldr	w26, [x0, #344]
{
 110df70:	a90153f3 	stp	x19, x20, [sp, #16]
 110df74:	a9025bf5 	stp	x21, x22, [sp, #32]
 110df78:	a90363f7 	stp	x23, x24, [sp, #48]
	if (state->payload_bytes)
 110df7c:	350006ba 	cbnz	w26, 110e050 <__gcm_update_aad+0xf0>
 110df80:	aa0003f4 	mov	x20, x0
			memcpy(state->buf_hash + state->buf_pos, d, n);
 110df84:	9104c017 	add	x23, x0, #0x130
	state->aad_bytes += len;
 110df88:	b9415400 	ldr	w0, [x0, #340]
 110df8c:	aa0103f5 	mov	x21, x1
 110df90:	aa0203f3 	mov	x19, x2
	const uint8_t *head = NULL;
 110df94:	d2800019 	mov	x25, #0x0                   	// #0
	state->aad_bytes += len;
 110df98:	0b020000 	add	w0, w0, w2
			n = MIN(TEE_AES_BLOCK_SIZE - state->buf_pos, l);
 110df9c:	d2800218 	mov	x24, #0x10                  	// #16
	state->aad_bytes += len;
 110dfa0:	b9015680 	str	w0, [x20, #340]
	while (l) {
 110dfa4:	b4000293 	cbz	x19, 110dff4 <__gcm_update_aad+0x94>
		if (state->buf_pos ||
 110dfa8:	b9415e80 	ldr	w0, [x20, #348]
 110dfac:	350000a0 	cbnz	w0, 110dfc0 <__gcm_update_aad+0x60>
 110dfb0:	f2400ebf 	tst	x21, #0xf
 110dfb4:	54000061 	b.ne	110dfc0 <__gcm_update_aad+0x60>  // b.any
		    !internal_aes_gcm_ptr_is_block_aligned(d) ||
 110dfb8:	f1003e7f 	cmp	x19, #0xf
 110dfbc:	54000348 	b.hi	110e024 <__gcm_update_aad+0xc4>  // b.pmore
			n = MIN(TEE_AES_BLOCK_SIZE - state->buf_pos, l);
 110dfc0:	cb204316 	sub	x22, x24, w0, uxtw
			memcpy(state->buf_hash + state->buf_pos, d, n);
 110dfc4:	aa1503e1 	mov	x1, x21
			n = MIN(TEE_AES_BLOCK_SIZE - state->buf_pos, l);
 110dfc8:	eb1302df 	cmp	x22, x19
			memcpy(state->buf_hash + state->buf_pos, d, n);
 110dfcc:	8b2042e0 	add	x0, x23, w0, uxtw
			n = MIN(TEE_AES_BLOCK_SIZE - state->buf_pos, l);
 110dfd0:	9a9392d6 	csel	x22, x22, x19, ls  // ls = plast
			memcpy(state->buf_hash + state->buf_pos, d, n);
 110dfd4:	aa1703f9 	mov	x25, x23
 110dfd8:	aa1603e2 	mov	x2, x22
 110dfdc:	97ffd4ed 	bl	1103390 <memcpy>
			state->buf_pos += n;
 110dfe0:	b9415e80 	ldr	w0, [x20, #348]
 110dfe4:	0b160000 	add	w0, w0, w22
			if (state->buf_pos != TEE_AES_BLOCK_SIZE)
 110dfe8:	7100401f 	cmp	w0, #0x10
 110dfec:	54000120 	b.eq	110e010 <__gcm_update_aad+0xb0>  // b.none
			state->buf_pos += n;
 110dff0:	b9015e80 	str	w0, [x20, #348]
}
 110dff4:	2a1a03e0 	mov	w0, w26
 110dff8:	a94153f3 	ldp	x19, x20, [sp, #16]
 110dffc:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110e000:	a94363f7 	ldp	x23, x24, [sp, #48]
 110e004:	a9446bf9 	ldp	x25, x26, [sp, #64]
 110e008:	a8c57bfd 	ldp	x29, x30, [sp], #80
 110e00c:	d65f03c0 	ret
			d += n;
 110e010:	8b1602b5 	add	x21, x21, x22
			state->buf_pos = 0;
 110e014:	b9015e9f 	str	wzr, [x20, #348]
			l -= n;
 110e018:	cb160273 	sub	x19, x19, x22
		if (internal_aes_gcm_ptr_is_block_aligned(d))
 110e01c:	f2400ebf 	tst	x21, #0xf
 110e020:	54000141 	b.ne	110e048 <__gcm_update_aad+0xe8>  // b.any
			n = l / TEE_AES_BLOCK_SIZE;
 110e024:	d344fe76 	lsr	x22, x19, #4
		internal_aes_gcm_ghash_update(state, head, d, n);
 110e028:	aa1503e2 	mov	x2, x21
 110e02c:	aa1603e3 	mov	x3, x22
 110e030:	aa1903e1 	mov	x1, x25
 110e034:	aa1403e0 	mov	x0, x20
		l -= n * TEE_AES_BLOCK_SIZE;
 110e038:	cb161273 	sub	x19, x19, x22, lsl #4
		d += n * TEE_AES_BLOCK_SIZE;
 110e03c:	8b1612b5 	add	x21, x21, x22, lsl #4
		internal_aes_gcm_ghash_update(state, head, d, n);
 110e040:	94000299 	bl	110eaa4 <internal_aes_gcm_ghash_update>
		d += n * TEE_AES_BLOCK_SIZE;
 110e044:	17ffffd8 	b	110dfa4 <__gcm_update_aad+0x44>
			n = 0;
 110e048:	d2800016 	mov	x22, #0x0                   	// #0
 110e04c:	17fffff7 	b	110e028 <__gcm_update_aad+0xc8>
		return TEE_ERROR_BAD_PARAMETERS;
 110e050:	129fff3a 	mov	w26, #0xffff0006            	// #-65530
 110e054:	17ffffe8 	b	110dff4 <__gcm_update_aad+0x94>

000000000110e058 <to_aes_gcm_ctx>:
	assert(aec->ops == &aes_gcm_ops);
 110e058:	f9400002 	ldr	x2, [x0]
 110e05c:	b0000261 	adrp	x1, 115b000 <__vcore_unpg_rw_start>
 110e060:	9118a021 	add	x1, x1, #0x628
 110e064:	eb01005f 	cmp	x2, x1
 110e068:	54000180 	b.eq	110e098 <to_aes_gcm_ctx+0x40>  // b.none
 110e06c:	b0000223 	adrp	x3, 1153000 <__func__.3477+0x91>
 110e070:	b0000221 	adrp	x1, 1153000 <__func__.3477+0x91>
 110e074:	912cf463 	add	x3, x3, #0xb3d
 110e078:	912c3821 	add	x1, x1, #0xb0e
 110e07c:	b0000220 	adrp	x0, 1153000 <__func__.3477+0x91>
 110e080:	912c9000 	add	x0, x0, #0xb24
{
 110e084:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	assert(aec->ops == &aes_gcm_ops);
 110e088:	528035e2 	mov	w2, #0x1af                 	// #431
{
 110e08c:	910003fd 	mov	x29, sp
	assert(aec->ops == &aes_gcm_ops);
 110e090:	94001087 	bl	11122ac <_assert_log>
 110e094:	94001097 	bl	11122f0 <_assert_break>
}
 110e098:	d65f03c0 	ret

000000000110e09c <aes_gcm_copy_state>:
{
 110e09c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 110e0a0:	910003fd 	mov	x29, sp
 110e0a4:	a90153f3 	stp	x19, x20, [sp, #16]
 110e0a8:	aa0003f4 	mov	x20, x0
 110e0ac:	aa0103e0 	mov	x0, x1
	to_aes_gcm_ctx(dst_ctx)->ctx = to_aes_gcm_ctx(src_ctx)->ctx;
 110e0b0:	97ffffea 	bl	110e058 <to_aes_gcm_ctx>
 110e0b4:	aa0003f3 	mov	x19, x0
 110e0b8:	aa1403e0 	mov	x0, x20
 110e0bc:	97ffffe7 	bl	110e058 <to_aes_gcm_ctx>
 110e0c0:	91002261 	add	x1, x19, #0x8
 110e0c4:	d2804b02 	mov	x2, #0x258                 	// #600
 110e0c8:	91002000 	add	x0, x0, #0x8
 110e0cc:	97ffd4b1 	bl	1103390 <memcpy>
}
 110e0d0:	a94153f3 	ldp	x19, x20, [sp, #16]
 110e0d4:	a8c27bfd 	ldp	x29, x30, [sp], #32
 110e0d8:	d65f03c0 	ret

000000000110e0dc <aes_gcm_free_ctx>:
{
 110e0dc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 110e0e0:	910003fd 	mov	x29, sp
	free(to_aes_gcm_ctx(aec));
 110e0e4:	97ffffdd 	bl	110e058 <to_aes_gcm_ctx>
}
 110e0e8:	a8c17bfd 	ldp	x29, x30, [sp], #16
	free(to_aes_gcm_ctx(aec));
 110e0ec:	1400d53d 	b	11435e0 <free>

000000000110e0f0 <aes_gcm_update_aad>:
{
 110e0f0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 110e0f4:	910003fd 	mov	x29, sp
 110e0f8:	a90153f3 	stp	x19, x20, [sp, #16]
 110e0fc:	aa0103f3 	mov	x19, x1
 110e100:	aa0203f4 	mov	x20, x2
	return internal_aes_gcm_update_aad(&to_aes_gcm_ctx(aec)->ctx, data,
 110e104:	97ffffd5 	bl	110e058 <to_aes_gcm_ctx>
	return __gcm_update_aad(&ctx->state, data, len);
 110e108:	91002000 	add	x0, x0, #0x8
 110e10c:	aa1403e2 	mov	x2, x20
 110e110:	aa1303e1 	mov	x1, x19
}
 110e114:	a94153f3 	ldp	x19, x20, [sp, #16]
 110e118:	a8c27bfd 	ldp	x29, x30, [sp], #32
	return __gcm_update_aad(&ctx->state, data, len);
 110e11c:	17ffff91 	b	110df60 <__gcm_update_aad>

000000000110e120 <operation_final.part.0>:
static TEE_Result operation_final(struct internal_aes_gcm_state *state,
 110e120:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 110e124:	910003fd 	mov	x29, sp
 110e128:	a90153f3 	stp	x19, x20, [sp, #16]
 110e12c:	aa0003f3 	mov	x19, x0
	if (state->buf_pos) {
 110e130:	b9415c00 	ldr	w0, [x0, #348]
 110e134:	34000180 	cbz	w0, 110e164 <operation_final.part.0+0x44>
		memset(state->buf_hash + state->buf_pos, 0,
 110e138:	9104c274 	add	x20, x19, #0x130
 110e13c:	d2800202 	mov	x2, #0x10                  	// #16
 110e140:	cb204042 	sub	x2, x2, w0, uxtw
 110e144:	52800001 	mov	w1, #0x0                   	// #0
 110e148:	8b204280 	add	x0, x20, w0, uxtw
 110e14c:	9400d6e5 	bl	1143ce0 <memset>
		internal_aes_gcm_ghash_update(state, state->buf_hash, NULL, 0);
 110e150:	aa1403e1 	mov	x1, x20
 110e154:	aa1303e0 	mov	x0, x19
 110e158:	d2800003 	mov	x3, #0x0                   	// #0
 110e15c:	d2800002 	mov	x2, #0x0                   	// #0
 110e160:	94000251 	bl	110eaa4 <internal_aes_gcm_ghash_update>
		TEE_U64_TO_BIG_ENDIAN(l1 * 8),
 110e164:	b9415661 	ldr	w1, [x19, #340]
	internal_aes_gcm_ghash_update(state, (uint8_t *)len_fields, NULL, 0);
 110e168:	d2800003 	mov	x3, #0x0                   	// #0
	ghash_update_lengths(state, state->aad_bytes, state->payload_bytes);
 110e16c:	b9415a60 	ldr	w0, [x19, #344]
	internal_aes_gcm_ghash_update(state, (uint8_t *)len_fields, NULL, 0);
 110e170:	d2800002 	mov	x2, #0x0                   	// #0
		TEE_U64_TO_BIG_ENDIAN(l1 * 8),
 110e174:	531d7021 	lsl	w1, w1, #3
		TEE_U64_TO_BIG_ENDIAN(l2 * 8)
 110e178:	531d7000 	lsl	w0, w0, #3
		TEE_U64_TO_BIG_ENDIAN(l1 * 8),
 110e17c:	dac00c21 	rev	x1, x1
		TEE_U64_TO_BIG_ENDIAN(l2 * 8)
 110e180:	dac00c00 	rev	x0, x0
	uint64_t len_fields[2] = {
 110e184:	a90203e1 	stp	x1, x0, [sp, #32]
	internal_aes_gcm_ghash_update(state, (uint8_t *)len_fields, NULL, 0);
 110e188:	910083e1 	add	x1, sp, #0x20
 110e18c:	aa1303e0 	mov	x0, x19
 110e190:	94000245 	bl	110eaa4 <internal_aes_gcm_ghash_update>
	xor_buf(state->buf_tag, state->hash_state, state->tag_len);
 110e194:	b9415261 	ldr	w1, [x19, #336]
 110e198:	aa1303e0 	mov	x0, x19
 110e19c:	8b010261 	add	x1, x19, x1
	for (n = 0; n < len; n++)
 110e1a0:	eb00003f 	cmp	x1, x0
 110e1a4:	540000a1 	b.ne	110e1b8 <operation_final.part.0+0x98>  // b.any
}
 110e1a8:	52800000 	mov	w0, #0x0                   	// #0
 110e1ac:	a94153f3 	ldp	x19, x20, [sp, #16]
 110e1b0:	a8c37bfd 	ldp	x29, x30, [sp], #48
 110e1b4:	d65f03c0 	ret
		dst[n] ^= src[n];
 110e1b8:	39448002 	ldrb	w2, [x0, #288]
 110e1bc:	91000400 	add	x0, x0, #0x1
 110e1c0:	39443c03 	ldrb	w3, [x0, #271]
 110e1c4:	4a030042 	eor	w2, w2, w3
 110e1c8:	39047c02 	strb	w2, [x0, #287]
	for (n = 0; n < len; n++)
 110e1cc:	17fffff5 	b	110e1a0 <operation_final.part.0+0x80>

000000000110e1d0 <internal_aes_gcm_inc_ctr>:
	c = TEE_U64_FROM_BIG_ENDIAN(state->ctr[1]) + 1;
 110e1d0:	f9400401 	ldr	x1, [x0, #8]
 110e1d4:	dac00c21 	rev	x1, x1
 110e1d8:	91000421 	add	x1, x1, #0x1
	state->ctr[1] = TEE_U64_TO_BIG_ENDIAN(c);
 110e1dc:	dac00c22 	rev	x2, x1
 110e1e0:	f9000402 	str	x2, [x0, #8]
	if (!c) {
 110e1e4:	b50000c1 	cbnz	x1, 110e1fc <internal_aes_gcm_inc_ctr+0x2c>
		c = TEE_U64_FROM_BIG_ENDIAN(state->ctr[0]) + 1;
 110e1e8:	f9400001 	ldr	x1, [x0]
 110e1ec:	dac00c21 	rev	x1, x1
 110e1f0:	91000421 	add	x1, x1, #0x1
		state->ctr[0] = TEE_U64_TO_BIG_ENDIAN(c);
 110e1f4:	dac00c21 	rev	x1, x1
 110e1f8:	f9000001 	str	x1, [x0]
}
 110e1fc:	d65f03c0 	ret

000000000110e200 <__gcm_init.part.0>:
static TEE_Result __gcm_init(struct internal_aes_gcm_state *state,
 110e200:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
 110e204:	910003fd 	mov	x29, sp
 110e208:	a90153f3 	stp	x19, x20, [sp, #16]
 110e20c:	aa0003f3 	mov	x19, x0
 110e210:	aa0403f4 	mov	x20, x4
 110e214:	a9025bf5 	stp	x21, x22, [sp, #32]
 110e218:	aa0103f6 	mov	x22, x1
 110e21c:	aa0303f5 	mov	x21, x3
	memset(state, 0, sizeof(*state));
 110e220:	52800001 	mov	w1, #0x0                   	// #0
static TEE_Result __gcm_init(struct internal_aes_gcm_state *state,
 110e224:	a90363f7 	stp	x23, x24, [sp, #48]
 110e228:	aa0503f7 	mov	x23, x5
 110e22c:	2a0203f8 	mov	w24, w2
	memset(state, 0, sizeof(*state));
 110e230:	d2802c02 	mov	x2, #0x160                 	// #352
static TEE_Result __gcm_init(struct internal_aes_gcm_state *state,
 110e234:	a9046bf9 	stp	x25, x26, [sp, #64]
	memset(state, 0, sizeof(*state));
 110e238:	9400d6aa 	bl	1143ce0 <memset>
	internal_aes_gcm_set_key(state, ek);
 110e23c:	aa1603e1 	mov	x1, x22
	state->tag_len = tag_len;
 110e240:	b9015277 	str	w23, [x19, #336]
	internal_aes_gcm_set_key(state, ek);
 110e244:	aa1303e0 	mov	x0, x19
 110e248:	94000215 	bl	110ea9c <internal_aes_gcm_set_key>
	if (nonce_len == (96 / 8)) {
 110e24c:	f100329f 	cmp	x20, #0xc
 110e250:	540003e1 	b.ne	110e2cc <__gcm_init.part.0+0xcc>  // b.any
		memcpy(state->ctr, nonce, nonce_len);
 110e254:	aa1403e2 	mov	x2, x20
 110e258:	aa1503e1 	mov	x1, x21
 110e25c:	aa1303e0 	mov	x0, x19
 110e260:	97ffd44c 	bl	1103390 <memcpy>
		internal_aes_gcm_inc_ctr(state);
 110e264:	aa1303e0 	mov	x0, x19
 110e268:	97ffffda 	bl	110e1d0 <internal_aes_gcm_inc_ctr>
	crypto_aes_enc_block(ek->data, sizeof(ek->data), ek->rounds,
 110e26c:	b940f2c2 	ldr	w2, [x22, #240]
 110e270:	91048264 	add	x4, x19, #0x120
 110e274:	aa1303e3 	mov	x3, x19
 110e278:	d2801e01 	mov	x1, #0xf0                  	// #240
 110e27c:	aa1603e0 	mov	x0, x22
 110e280:	940075fd 	bl	112ba74 <crypto_aes_enc_block>
	internal_aes_gcm_inc_ctr(state);
 110e284:	aa1303e0 	mov	x0, x19
 110e288:	97ffffd2 	bl	110e1d0 <internal_aes_gcm_inc_ctr>
	if (mode == TEE_MODE_ENCRYPT) {
 110e28c:	35000138 	cbnz	w24, 110e2b0 <__gcm_init.part.0+0xb0>
		crypto_aes_enc_block(ek->data, sizeof(ek->data), ek->rounds,
 110e290:	b940f2c2 	ldr	w2, [x22, #240]
 110e294:	91050264 	add	x4, x19, #0x140
 110e298:	aa1303e3 	mov	x3, x19
 110e29c:	d2801e01 	mov	x1, #0xf0                  	// #240
 110e2a0:	aa1603e0 	mov	x0, x22
 110e2a4:	940075f4 	bl	112ba74 <crypto_aes_enc_block>
		internal_aes_gcm_inc_ctr(state);
 110e2a8:	aa1303e0 	mov	x0, x19
 110e2ac:	97ffffc9 	bl	110e1d0 <internal_aes_gcm_inc_ctr>
}
 110e2b0:	52800000 	mov	w0, #0x0                   	// #0
 110e2b4:	a94153f3 	ldp	x19, x20, [sp, #16]
 110e2b8:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110e2bc:	a94363f7 	ldp	x23, x24, [sp, #48]
 110e2c0:	a9446bf9 	ldp	x25, x26, [sp, #64]
 110e2c4:	a8c67bfd 	ldp	x29, x30, [sp], #96
 110e2c8:	d65f03c0 	ret
	if (n) {
 110e2cc:	f1003e9f 	cmp	x20, #0xf
 110e2d0:	910143f7 	add	x23, sp, #0x50
 110e2d4:	540002e9 	b.ls	110e330 <__gcm_init.part.0+0x130>  // b.plast
	size_t n = len / TEE_AES_BLOCK_SIZE;
 110e2d8:	d344fe83 	lsr	x3, x20, #4
	d[1] ^= s[1];
}

static inline bool internal_aes_gcm_ptr_is_block_aligned(const void *p)
{
	return !((vaddr_t)p & (TEE_AES_BLOCK_SIZE - 1));
 110e2dc:	aa1503fa 	mov	x26, x21
		if (internal_aes_gcm_ptr_is_block_aligned(data)) {
 110e2e0:	f2400ebf 	tst	x21, #0xf
 110e2e4:	540001e0 	b.eq	110e320 <__gcm_init.part.0+0x120>  // b.none
 110e2e8:	8b0312b9 	add	x25, x21, x3, lsl #4
			for (m = 0; m < n; m++) {
 110e2ec:	eb19035f 	cmp	x26, x25
 110e2f0:	54000200 	b.eq	110e330 <__gcm_init.part.0+0x130>  // b.none
				memcpy(block, data + m * sizeof(block),
 110e2f4:	aa1a03e1 	mov	x1, x26
 110e2f8:	d2800202 	mov	x2, #0x10                  	// #16
 110e2fc:	aa1703e0 	mov	x0, x23
 110e300:	97ffd424 	bl	1103390 <memcpy>
				internal_aes_gcm_ghash_update(state, NULL,
 110e304:	aa1703e2 	mov	x2, x23
 110e308:	aa1303e0 	mov	x0, x19
 110e30c:	d2800023 	mov	x3, #0x1                   	// #1
 110e310:	d2800001 	mov	x1, #0x0                   	// #0
 110e314:	9100435a 	add	x26, x26, #0x10
 110e318:	940001e3 	bl	110eaa4 <internal_aes_gcm_ghash_update>
			for (m = 0; m < n; m++) {
 110e31c:	17fffff4 	b	110e2ec <__gcm_init.part.0+0xec>
			internal_aes_gcm_ghash_update(state, NULL, data, n);
 110e320:	aa1503e2 	mov	x2, x21
 110e324:	aa1303e0 	mov	x0, x19
 110e328:	d2800001 	mov	x1, #0x0                   	// #0
 110e32c:	940001de 	bl	110eaa4 <internal_aes_gcm_ghash_update>
	if (len - n * TEE_AES_BLOCK_SIZE) {
 110e330:	927cee81 	and	x1, x20, #0xfffffffffffffff0
 110e334:	f2400e9f 	tst	x20, #0xf
 110e338:	54000160 	b.eq	110e364 <__gcm_init.part.0+0x164>  // b.none
		memcpy(block, data + n * TEE_AES_BLOCK_SIZE,
 110e33c:	92400e82 	and	x2, x20, #0xf
 110e340:	8b0102a1 	add	x1, x21, x1
 110e344:	aa1703e0 	mov	x0, x23
		memset(block, 0, sizeof(block));
 110e348:	a9057fff 	stp	xzr, xzr, [sp, #80]
		memcpy(block, data + n * TEE_AES_BLOCK_SIZE,
 110e34c:	97ffd411 	bl	1103390 <memcpy>
		internal_aes_gcm_ghash_update(state, block, NULL, 0);
 110e350:	aa1703e1 	mov	x1, x23
 110e354:	aa1303e0 	mov	x0, x19
 110e358:	d2800003 	mov	x3, #0x0                   	// #0
 110e35c:	d2800002 	mov	x2, #0x0                   	// #0
 110e360:	940001d1 	bl	110eaa4 <internal_aes_gcm_ghash_update>
		TEE_U64_TO_BIG_ENDIAN(l2 * 8)
 110e364:	531d7294 	lsl	w20, w20, #3
	internal_aes_gcm_ghash_update(state, (uint8_t *)len_fields, NULL, 0);
 110e368:	d2800003 	mov	x3, #0x0                   	// #0
		TEE_U64_TO_BIG_ENDIAN(l2 * 8)
 110e36c:	dac00e94 	rev	x20, x20
	internal_aes_gcm_ghash_update(state, (uint8_t *)len_fields, NULL, 0);
 110e370:	aa1703e1 	mov	x1, x23
 110e374:	aa1303e0 	mov	x0, x19
 110e378:	d2800002 	mov	x2, #0x0                   	// #0
	uint64_t len_fields[2] = {
 110e37c:	a90553ff 	stp	xzr, x20, [sp, #80]
	internal_aes_gcm_ghash_update(state, (uint8_t *)len_fields, NULL, 0);
 110e380:	940001c9 	bl	110eaa4 <internal_aes_gcm_ghash_update>
		memcpy(state->ctr, state->hash_state, sizeof(state->ctr));
 110e384:	91044274 	add	x20, x19, #0x110
 110e388:	aa1403e1 	mov	x1, x20
 110e38c:	aa1303e0 	mov	x0, x19
 110e390:	d2800202 	mov	x2, #0x10                  	// #16
 110e394:	97ffd3ff 	bl	1103390 <memcpy>
		memset(state->hash_state, 0, sizeof(state->hash_state));
 110e398:	aa1403e0 	mov	x0, x20
 110e39c:	d2800202 	mov	x2, #0x10                  	// #16
 110e3a0:	52800001 	mov	w1, #0x0                   	// #0
 110e3a4:	9400d64f 	bl	1143ce0 <memset>
 110e3a8:	17ffffb1 	b	110e26c <__gcm_init.part.0+0x6c>

000000000110e3ac <internal_aes_gcm_init>:
{
 110e3ac:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 110e3b0:	910003fd 	mov	x29, sp
 110e3b4:	a90153f3 	stp	x19, x20, [sp, #16]
 110e3b8:	aa0003f3 	mov	x19, x0
 110e3bc:	aa0603f4 	mov	x20, x6
 110e3c0:	a90363f7 	stp	x23, x24, [sp, #48]
	struct internal_aes_gcm_key *ek = &ctx->key;
 110e3c4:	91058278 	add	x24, x19, #0x160
{
 110e3c8:	aa0203e0 	mov	x0, x2
 110e3cc:	aa0503f7 	mov	x23, x5
	res = crypto_aes_expand_enc_key(key, key_len, ek->data,
 110e3d0:	aa1803e2 	mov	x2, x24
{
 110e3d4:	a9025bf5 	stp	x21, x22, [sp, #32]
 110e3d8:	2a0103f5 	mov	w21, w1
 110e3dc:	aa0403f6 	mov	x22, x4
 110e3e0:	aa0303e1 	mov	x1, x3
	res = crypto_aes_expand_enc_key(key, key_len, ek->data,
 110e3e4:	91094264 	add	x4, x19, #0x250
 110e3e8:	d2801e03 	mov	x3, #0xf0                  	// #240
 110e3ec:	94007584 	bl	112b9fc <crypto_aes_expand_enc_key>
	if (res)
 110e3f0:	350001e0 	cbnz	w0, 110e42c <internal_aes_gcm_init+0x80>
	if (tag_len > sizeof(state->buf_tag))
 110e3f4:	f100429f 	cmp	x20, #0x10
 110e3f8:	54000188 	b.hi	110e428 <internal_aes_gcm_init+0x7c>  // b.pmore
 110e3fc:	aa1403e5 	mov	x5, x20
 110e400:	aa1703e4 	mov	x4, x23
 110e404:	aa1603e3 	mov	x3, x22
 110e408:	2a1503e2 	mov	w2, w21
 110e40c:	aa1803e1 	mov	x1, x24
 110e410:	aa1303e0 	mov	x0, x19
}
 110e414:	a94153f3 	ldp	x19, x20, [sp, #16]
 110e418:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110e41c:	a94363f7 	ldp	x23, x24, [sp, #48]
 110e420:	a8c47bfd 	ldp	x29, x30, [sp], #64
 110e424:	17ffff77 	b	110e200 <__gcm_init.part.0>
		return TEE_ERROR_BAD_PARAMETERS;
 110e428:	129fff20 	mov	w0, #0xffff0006            	// #-65530
}
 110e42c:	a94153f3 	ldp	x19, x20, [sp, #16]
 110e430:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110e434:	a94363f7 	ldp	x23, x24, [sp, #48]
 110e438:	a8c47bfd 	ldp	x29, x30, [sp], #64
 110e43c:	d65f03c0 	ret

000000000110e440 <aes_gcm_init>:
{
 110e440:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 110e444:	910003fd 	mov	x29, sp
 110e448:	a90153f3 	stp	x19, x20, [sp, #16]
 110e44c:	2a0103f3 	mov	w19, w1
 110e450:	aa0203f4 	mov	x20, x2
 110e454:	a9025bf5 	stp	x21, x22, [sp, #32]
 110e458:	aa0303f5 	mov	x21, x3
 110e45c:	aa0403f6 	mov	x22, x4
 110e460:	a90363f7 	stp	x23, x24, [sp, #48]
 110e464:	aa0503f7 	mov	x23, x5
 110e468:	aa0603f8 	mov	x24, x6
	return internal_aes_gcm_init(&to_aes_gcm_ctx(aec)->ctx, mode, key,
 110e46c:	97fffefb 	bl	110e058 <to_aes_gcm_ctx>
 110e470:	91002000 	add	x0, x0, #0x8
 110e474:	aa1803e6 	mov	x6, x24
 110e478:	aa1703e5 	mov	x5, x23
 110e47c:	aa1603e4 	mov	x4, x22
 110e480:	aa1503e3 	mov	x3, x21
 110e484:	aa1403e2 	mov	x2, x20
 110e488:	2a1303e1 	mov	w1, w19
}
 110e48c:	a94153f3 	ldp	x19, x20, [sp, #16]
 110e490:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110e494:	a94363f7 	ldp	x23, x24, [sp, #48]
 110e498:	a8c47bfd 	ldp	x29, x30, [sp], #64
	return internal_aes_gcm_init(&to_aes_gcm_ctx(aec)->ctx, mode, key,
 110e49c:	17ffffc4 	b	110e3ac <internal_aes_gcm_init>

000000000110e4a0 <__gcm_update_payload>:
{
 110e4a0:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
 110e4a4:	910003fd 	mov	x29, sp
 110e4a8:	a90153f3 	stp	x19, x20, [sp, #16]
 110e4ac:	aa0003f3 	mov	x19, x0
	if (!state->payload_bytes && state->buf_pos) {
 110e4b0:	b9415800 	ldr	w0, [x0, #344]
{
 110e4b4:	a9025bf5 	stp	x21, x22, [sp, #32]
 110e4b8:	aa0403f4 	mov	x20, x4
 110e4bc:	aa0303f6 	mov	x22, x3
 110e4c0:	a90363f7 	stp	x23, x24, [sp, #48]
 110e4c4:	aa0103f8 	mov	x24, x1
 110e4c8:	aa0503f7 	mov	x23, x5
 110e4cc:	a9046bf9 	stp	x25, x26, [sp, #64]
 110e4d0:	2a0203f9 	mov	w25, w2
 110e4d4:	a90573fb 	stp	x27, x28, [sp, #80]
	if (!state->payload_bytes && state->buf_pos) {
 110e4d8:	350001e0 	cbnz	w0, 110e514 <__gcm_update_payload+0x74>
 110e4dc:	b9415e60 	ldr	w0, [x19, #348]
 110e4e0:	340001a0 	cbz	w0, 110e514 <__gcm_update_payload+0x74>
		memset(state->buf_hash + state->buf_pos, 0,
 110e4e4:	9104c275 	add	x21, x19, #0x130
 110e4e8:	d2800202 	mov	x2, #0x10                  	// #16
 110e4ec:	cb204042 	sub	x2, x2, w0, uxtw
 110e4f0:	52800001 	mov	w1, #0x0                   	// #0
 110e4f4:	8b2042a0 	add	x0, x21, w0, uxtw
 110e4f8:	9400d5fa 	bl	1143ce0 <memset>
		internal_aes_gcm_ghash_update(state, state->buf_hash, NULL, 0);
 110e4fc:	aa1503e1 	mov	x1, x21
 110e500:	aa1303e0 	mov	x0, x19
 110e504:	d2800003 	mov	x3, #0x0                   	// #0
 110e508:	d2800002 	mov	x2, #0x0                   	// #0
 110e50c:	94000166 	bl	110eaa4 <internal_aes_gcm_ghash_update>
		state->buf_pos = 0;
 110e510:	b9015e7f 	str	wzr, [x19, #348]
	state->payload_bytes += len;
 110e514:	b9415a60 	ldr	w0, [x19, #344]
 110e518:	9105027a 	add	x26, x19, #0x140
 110e51c:	9104c27b 	add	x27, x19, #0x130
			n = MIN(TEE_AES_BLOCK_SIZE - state->buf_pos, l);
 110e520:	d280021c 	mov	x28, #0x10                  	// #16
	state->payload_bytes += len;
 110e524:	0b140000 	add	w0, w0, w20
 110e528:	b9015a60 	str	w0, [x19, #344]
	while (l) {
 110e52c:	b5000134 	cbnz	x20, 110e550 <__gcm_update_payload+0xb0>
}
 110e530:	52800000 	mov	w0, #0x0                   	// #0
 110e534:	a94153f3 	ldp	x19, x20, [sp, #16]
 110e538:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110e53c:	a94363f7 	ldp	x23, x24, [sp, #48]
 110e540:	a9446bf9 	ldp	x25, x26, [sp, #64]
 110e544:	a94573fb 	ldp	x27, x28, [sp, #80]
 110e548:	a8c77bfd 	ldp	x29, x30, [sp], #112
 110e54c:	d65f03c0 	ret
		if (state->buf_pos || l < TEE_AES_BLOCK_SIZE) {
 110e550:	b9415e61 	ldr	w1, [x19, #348]
 110e554:	35000061 	cbnz	w1, 110e560 <__gcm_update_payload+0xc0>
 110e558:	f1003e9f 	cmp	x20, #0xf
 110e55c:	54000808 	b.hi	110e65c <__gcm_update_payload+0x1bc>  // b.pmore
			n = MIN(TEE_AES_BLOCK_SIZE - state->buf_pos, l);
 110e560:	cb214380 	sub	x0, x28, w1, uxtw
 110e564:	eb14001f 	cmp	x0, x20
 110e568:	9a949005 	csel	x5, x0, x20, ls  // ls = plast
			if (!state->buf_pos && mode == TEE_MODE_DECRYPT)
 110e56c:	35000161 	cbnz	w1, 110e598 <__gcm_update_payload+0xf8>
 110e570:	7100073f 	cmp	w25, #0x1
 110e574:	54000121 	b.ne	110e598 <__gcm_update_payload+0xf8>  // b.any
				crypto_aes_enc_block(ek->data, sizeof(ek->data),
 110e578:	b940f302 	ldr	w2, [x24, #240]
 110e57c:	aa1a03e4 	mov	x4, x26
 110e580:	aa1303e3 	mov	x3, x19
 110e584:	aa1803e0 	mov	x0, x24
 110e588:	d2801e01 	mov	x1, #0xf0                  	// #240
 110e58c:	f90037e5 	str	x5, [sp, #104]
 110e590:	94007539 	bl	112ba74 <crypto_aes_enc_block>
 110e594:	f94037e5 	ldr	x5, [sp, #104]
	for (n = 0; n < len; n++)
 110e598:	d2800015 	mov	x21, #0x0                   	// #0
			xor_buf(state->buf_cryp + state->buf_pos, s, n);
 110e59c:	b9415e60 	ldr	w0, [x19, #348]
 110e5a0:	8b000260 	add	x0, x19, x0
	for (n = 0; n < len; n++)
 110e5a4:	91000400 	add	x0, x0, #0x1
 110e5a8:	eb1500bf 	cmp	x5, x21
 110e5ac:	54000481 	b.ne	110e63c <__gcm_update_payload+0x19c>  // b.any
			memcpy(d, state->buf_cryp + state->buf_pos, n);
 110e5b0:	b9415e61 	ldr	w1, [x19, #348]
 110e5b4:	aa1503e2 	mov	x2, x21
 110e5b8:	aa1703e0 	mov	x0, x23
 110e5bc:	8b010341 	add	x1, x26, x1
 110e5c0:	97ffd374 	bl	1103390 <memcpy>
			if (mode == TEE_MODE_ENCRYPT)
 110e5c4:	b9415e60 	ldr	w0, [x19, #348]
				memcpy(state->buf_hash + state->buf_pos,
 110e5c8:	aa1503e2 	mov	x2, x21
			if (mode == TEE_MODE_ENCRYPT)
 110e5cc:	35000459 	cbnz	w25, 110e654 <__gcm_update_payload+0x1b4>
				memcpy(state->buf_hash + state->buf_pos,
 110e5d0:	8b000341 	add	x1, x26, x0
				memcpy(state->buf_hash + state->buf_pos, s, n);
 110e5d4:	8b000360 	add	x0, x27, x0
 110e5d8:	97ffd36e 	bl	1103390 <memcpy>
			state->buf_pos += n;
 110e5dc:	b9415e60 	ldr	w0, [x19, #348]
 110e5e0:	0b150000 	add	w0, w0, w21
 110e5e4:	b9015e60 	str	w0, [x19, #348]
			if (state->buf_pos != TEE_AES_BLOCK_SIZE)
 110e5e8:	7100401f 	cmp	w0, #0x10
 110e5ec:	54fffa21 	b.ne	110e530 <__gcm_update_payload+0x90>  // b.any
			internal_aes_gcm_ghash_update(state, state->buf_hash,
 110e5f0:	aa1b03e1 	mov	x1, x27
 110e5f4:	aa1303e0 	mov	x0, x19
 110e5f8:	d2800003 	mov	x3, #0x0                   	// #0
 110e5fc:	d2800002 	mov	x2, #0x0                   	// #0
 110e600:	94000129 	bl	110eaa4 <internal_aes_gcm_ghash_update>
			state->buf_pos = 0;
 110e604:	b9015e7f 	str	wzr, [x19, #348]
			d += n;
 110e608:	8b1502f7 	add	x23, x23, x21
			s += n;
 110e60c:	8b1502d6 	add	x22, x22, x21
			l -= n;
 110e610:	cb150294 	sub	x20, x20, x21
			if (mode == TEE_MODE_ENCRYPT)
 110e614:	350000f9 	cbnz	w25, 110e630 <__gcm_update_payload+0x190>
				crypto_aes_enc_block(ek->data, sizeof(ek->data),
 110e618:	b940f302 	ldr	w2, [x24, #240]
 110e61c:	aa1a03e4 	mov	x4, x26
 110e620:	aa1303e3 	mov	x3, x19
 110e624:	aa1803e0 	mov	x0, x24
 110e628:	d2801e01 	mov	x1, #0xf0                  	// #240
 110e62c:	94007512 	bl	112ba74 <crypto_aes_enc_block>
			internal_aes_gcm_inc_ctr(state);
 110e630:	aa1303e0 	mov	x0, x19
 110e634:	97fffee7 	bl	110e1d0 <internal_aes_gcm_inc_ctr>
 110e638:	17ffffbd 	b	110e52c <__gcm_update_payload+0x8c>
		dst[n] ^= src[n];
 110e63c:	38756ac2 	ldrb	w2, [x22, x21]
	for (n = 0; n < len; n++)
 110e640:	910006b5 	add	x21, x21, #0x1
		dst[n] ^= src[n];
 110e644:	3944fc01 	ldrb	w1, [x0, #319]
 110e648:	4a020021 	eor	w1, w1, w2
 110e64c:	3904fc01 	strb	w1, [x0, #319]
	for (n = 0; n < len; n++)
 110e650:	17ffffd5 	b	110e5a4 <__gcm_update_payload+0x104>
				memcpy(state->buf_hash + state->buf_pos, s, n);
 110e654:	aa1603e1 	mov	x1, x22
 110e658:	17ffffdf 	b	110e5d4 <__gcm_update_payload+0x134>
			internal_aes_gcm_update_payload_blocks(state, ek, mode,
 110e65c:	aa1703e5 	mov	x5, x23
 110e660:	d344fe84 	lsr	x4, x20, #4
 110e664:	aa1603e3 	mov	x3, x22
 110e668:	aa1303e0 	mov	x0, x19
 110e66c:	2a1903e2 	mov	w2, w25
 110e670:	aa1803e1 	mov	x1, x24
 110e674:	94000123 	bl	110eb00 <internal_aes_gcm_update_payload_blocks>
			s += n * TEE_AES_BLOCK_SIZE;
 110e678:	927cee80 	and	x0, x20, #0xfffffffffffffff0
 110e67c:	92400e94 	and	x20, x20, #0xf
 110e680:	8b0002d6 	add	x22, x22, x0
			d += n * TEE_AES_BLOCK_SIZE;
 110e684:	8b0002f7 	add	x23, x23, x0
			l -= n * TEE_AES_BLOCK_SIZE;
 110e688:	17ffffa9 	b	110e52c <__gcm_update_payload+0x8c>

000000000110e68c <internal_aes_gcm_update_payload>:
	return __gcm_update_payload(&ctx->state, &ctx->key, mode, src, len,
 110e68c:	aa0403e5 	mov	x5, x4
 110e690:	aa0303e4 	mov	x4, x3
 110e694:	aa0203e3 	mov	x3, x2
 110e698:	2a0103e2 	mov	w2, w1
 110e69c:	91058001 	add	x1, x0, #0x160
 110e6a0:	17ffff80 	b	110e4a0 <__gcm_update_payload>

000000000110e6a4 <aes_gcm_update_payload>:
{
 110e6a4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 110e6a8:	910003fd 	mov	x29, sp
 110e6ac:	a90153f3 	stp	x19, x20, [sp, #16]
 110e6b0:	2a0103f3 	mov	w19, w1
 110e6b4:	aa0203f4 	mov	x20, x2
 110e6b8:	a9025bf5 	stp	x21, x22, [sp, #32]
 110e6bc:	aa0303f5 	mov	x21, x3
 110e6c0:	aa0403f6 	mov	x22, x4
	return internal_aes_gcm_update_payload(&to_aes_gcm_ctx(aec)->ctx,
 110e6c4:	97fffe65 	bl	110e058 <to_aes_gcm_ctx>
 110e6c8:	91002000 	add	x0, x0, #0x8
 110e6cc:	aa1603e4 	mov	x4, x22
 110e6d0:	aa1503e3 	mov	x3, x21
 110e6d4:	aa1403e2 	mov	x2, x20
 110e6d8:	2a1303e1 	mov	w1, w19
}
 110e6dc:	a94153f3 	ldp	x19, x20, [sp, #16]
 110e6e0:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110e6e4:	a8c37bfd 	ldp	x29, x30, [sp], #48
	return internal_aes_gcm_update_payload(&to_aes_gcm_ctx(aec)->ctx,
 110e6e8:	17ffffe9 	b	110e68c <internal_aes_gcm_update_payload>

000000000110e6ec <internal_aes_gcm_dec_final>:
{
 110e6ec:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 110e6f0:	910003fd 	mov	x29, sp
 110e6f4:	a90153f3 	stp	x19, x20, [sp, #16]
 110e6f8:	a9025bf5 	stp	x21, x22, [sp, #32]
 110e6fc:	aa0403f6 	mov	x22, x4
	if (tag_len != state->tag_len)
 110e700:	b9415004 	ldr	w4, [x0, #336]
 110e704:	eb0400bf 	cmp	x5, x4
 110e708:	54000281 	b.ne	110e758 <internal_aes_gcm_dec_final+0x6c>  // b.any
	res = __gcm_update_payload(state, enc_key, m, src, len, dst);
 110e70c:	aa0203e4 	mov	x4, x2
 110e710:	aa0003f4 	mov	x20, x0
 110e714:	aa0503f5 	mov	x21, x5
 110e718:	52800022 	mov	w2, #0x1                   	// #1
 110e71c:	aa0303e5 	mov	x5, x3
 110e720:	aa0103e3 	mov	x3, x1
 110e724:	91058001 	add	x1, x0, #0x160
 110e728:	97ffff5e 	bl	110e4a0 <__gcm_update_payload>
 110e72c:	2a0003f3 	mov	w19, w0
	if (res)
 110e730:	35000160 	cbnz	w0, 110e75c <internal_aes_gcm_dec_final+0x70>
 110e734:	aa1403e0 	mov	x0, x20
 110e738:	97fffe7a 	bl	110e120 <operation_final.part.0>
 110e73c:	2a0003f3 	mov	w19, w0
	if (res)
 110e740:	350000e0 	cbnz	w0, 110e75c <internal_aes_gcm_dec_final+0x70>
	if (consttime_memcmp(state->buf_tag, tag, tag_len))
 110e744:	aa1503e2 	mov	x2, x21
 110e748:	aa1603e1 	mov	x1, x22
 110e74c:	91048280 	add	x0, x20, #0x120
 110e750:	9400da10 	bl	1144f90 <consttime_memcmp>
 110e754:	34000040 	cbz	w0, 110e75c <internal_aes_gcm_dec_final+0x70>
		return TEE_ERROR_MAC_INVALID;
 110e758:	1299f1d3 	mov	w19, #0xffff3071            	// #-53135
}
 110e75c:	2a1303e0 	mov	w0, w19
 110e760:	a94153f3 	ldp	x19, x20, [sp, #16]
 110e764:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110e768:	a8c37bfd 	ldp	x29, x30, [sp], #48
 110e76c:	d65f03c0 	ret

000000000110e770 <aes_gcm_dec_final>:
{
 110e770:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 110e774:	910003fd 	mov	x29, sp
 110e778:	a90153f3 	stp	x19, x20, [sp, #16]
 110e77c:	aa0103f3 	mov	x19, x1
 110e780:	aa0203f4 	mov	x20, x2
 110e784:	a9025bf5 	stp	x21, x22, [sp, #32]
 110e788:	aa0303f5 	mov	x21, x3
 110e78c:	aa0403f6 	mov	x22, x4
 110e790:	f9001bf7 	str	x23, [sp, #48]
 110e794:	aa0503f7 	mov	x23, x5
	return internal_aes_gcm_dec_final(&to_aes_gcm_ctx(aec)->ctx, src, len,
 110e798:	97fffe30 	bl	110e058 <to_aes_gcm_ctx>
 110e79c:	91002000 	add	x0, x0, #0x8
 110e7a0:	aa1703e5 	mov	x5, x23
 110e7a4:	aa1603e4 	mov	x4, x22
 110e7a8:	aa1503e3 	mov	x3, x21
 110e7ac:	aa1403e2 	mov	x2, x20
 110e7b0:	aa1303e1 	mov	x1, x19
}
 110e7b4:	a94153f3 	ldp	x19, x20, [sp, #16]
 110e7b8:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110e7bc:	f9401bf7 	ldr	x23, [sp, #48]
 110e7c0:	a8c47bfd 	ldp	x29, x30, [sp], #64
	return internal_aes_gcm_dec_final(&to_aes_gcm_ctx(aec)->ctx, src, len,
 110e7c4:	17ffffca 	b	110e6ec <internal_aes_gcm_dec_final>

000000000110e7c8 <internal_aes_gcm_enc_final>:
{
 110e7c8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 110e7cc:	910003fd 	mov	x29, sp
 110e7d0:	a9025bf5 	stp	x21, x22, [sp, #32]
 110e7d4:	aa0503f5 	mov	x21, x5
 110e7d8:	aa0403f6 	mov	x22, x4
	if (*tag_len < state->tag_len)
 110e7dc:	f94000a5 	ldr	x5, [x5]
{
 110e7e0:	a90153f3 	stp	x19, x20, [sp, #16]
	if (*tag_len < state->tag_len)
 110e7e4:	b9415004 	ldr	w4, [x0, #336]
 110e7e8:	eb0400bf 	cmp	x5, x4
 110e7ec:	54000323 	b.cc	110e850 <internal_aes_gcm_enc_final+0x88>  // b.lo, b.ul, b.last
	res = __gcm_update_payload(state, enc_key, m, src, len, dst);
 110e7f0:	aa0303e5 	mov	x5, x3
 110e7f4:	aa0203e4 	mov	x4, x2
 110e7f8:	aa0103e3 	mov	x3, x1
 110e7fc:	aa0003f4 	mov	x20, x0
 110e800:	91058001 	add	x1, x0, #0x160
 110e804:	52800002 	mov	w2, #0x0                   	// #0
 110e808:	97ffff26 	bl	110e4a0 <__gcm_update_payload>
 110e80c:	2a0003f3 	mov	w19, w0
	if (res)
 110e810:	35000160 	cbnz	w0, 110e83c <internal_aes_gcm_enc_final+0x74>
 110e814:	aa1403e0 	mov	x0, x20
 110e818:	97fffe42 	bl	110e120 <operation_final.part.0>
 110e81c:	2a0003f3 	mov	w19, w0
	if (res)
 110e820:	350000e0 	cbnz	w0, 110e83c <internal_aes_gcm_enc_final+0x74>
	memcpy(tag, state->buf_tag, state->tag_len);
 110e824:	b9415282 	ldr	w2, [x20, #336]
 110e828:	91048281 	add	x1, x20, #0x120
 110e82c:	aa1603e0 	mov	x0, x22
 110e830:	97ffd2d8 	bl	1103390 <memcpy>
	*tag_len = state->tag_len;
 110e834:	b9415280 	ldr	w0, [x20, #336]
 110e838:	f90002a0 	str	x0, [x21]
}
 110e83c:	2a1303e0 	mov	w0, w19
 110e840:	a94153f3 	ldp	x19, x20, [sp, #16]
 110e844:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110e848:	a8c37bfd 	ldp	x29, x30, [sp], #48
 110e84c:	d65f03c0 	ret
		return TEE_ERROR_SHORT_BUFFER;
 110e850:	129ffdf3 	mov	w19, #0xffff0010            	// #-65520
	return __gcm_enc_final(&ctx->state, &ctx->key, src, len, dst, tag,
 110e854:	17fffffa 	b	110e83c <internal_aes_gcm_enc_final+0x74>

000000000110e858 <aes_gcm_enc_final>:
{
 110e858:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 110e85c:	910003fd 	mov	x29, sp
 110e860:	a90153f3 	stp	x19, x20, [sp, #16]
 110e864:	aa0103f3 	mov	x19, x1
 110e868:	aa0203f4 	mov	x20, x2
 110e86c:	a9025bf5 	stp	x21, x22, [sp, #32]
 110e870:	aa0303f5 	mov	x21, x3
 110e874:	aa0403f6 	mov	x22, x4
 110e878:	f9001bf7 	str	x23, [sp, #48]
 110e87c:	aa0503f7 	mov	x23, x5
	return internal_aes_gcm_enc_final(&to_aes_gcm_ctx(aec)->ctx, src, len,
 110e880:	97fffdf6 	bl	110e058 <to_aes_gcm_ctx>
 110e884:	91002000 	add	x0, x0, #0x8
 110e888:	aa1703e5 	mov	x5, x23
 110e88c:	aa1603e4 	mov	x4, x22
 110e890:	aa1503e3 	mov	x3, x21
 110e894:	aa1403e2 	mov	x2, x20
 110e898:	aa1303e1 	mov	x1, x19
}
 110e89c:	a94153f3 	ldp	x19, x20, [sp, #16]
 110e8a0:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110e8a4:	f9401bf7 	ldr	x23, [sp, #48]
 110e8a8:	a8c47bfd 	ldp	x29, x30, [sp], #64
	return internal_aes_gcm_enc_final(&to_aes_gcm_ctx(aec)->ctx, src, len,
 110e8ac:	17ffffc7 	b	110e7c8 <internal_aes_gcm_enc_final>

000000000110e8b0 <crypto_aes_gcm_alloc_ctx>:
{
 110e8b0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	struct aes_gcm_ctx *ctx = calloc(1, sizeof(*ctx));
 110e8b4:	d2804c01 	mov	x1, #0x260                 	// #608
{
 110e8b8:	910003fd 	mov	x29, sp
 110e8bc:	f9000bf3 	str	x19, [sp, #16]
 110e8c0:	aa0003f3 	mov	x19, x0
	struct aes_gcm_ctx *ctx = calloc(1, sizeof(*ctx));
 110e8c4:	d2800020 	mov	x0, #0x1                   	// #1
 110e8c8:	9400d302 	bl	11434d0 <calloc>
	if (!ctx)
 110e8cc:	b4000120 	cbz	x0, 110e8f0 <crypto_aes_gcm_alloc_ctx+0x40>
	ctx->aec.ops = &aes_gcm_ops;
 110e8d0:	b0000261 	adrp	x1, 115b000 <__vcore_unpg_rw_start>
 110e8d4:	9118a021 	add	x1, x1, #0x628
	*ctx_ret = &ctx->aec;
 110e8d8:	f9000260 	str	x0, [x19]
	ctx->aec.ops = &aes_gcm_ops;
 110e8dc:	f9000001 	str	x1, [x0]
	return TEE_SUCCESS;
 110e8e0:	52800000 	mov	w0, #0x0                   	// #0
}
 110e8e4:	f9400bf3 	ldr	x19, [sp, #16]
 110e8e8:	a8c27bfd 	ldp	x29, x30, [sp], #32
 110e8ec:	d65f03c0 	ret
		return TEE_ERROR_OUT_OF_MEMORY;
 110e8f0:	129ffe60 	mov	w0, #0xffff000c            	// #-65524
 110e8f4:	17fffffc 	b	110e8e4 <crypto_aes_gcm_alloc_ctx+0x34>

000000000110e8f8 <internal_aes_gcm_xor_block>:
{
 110e8f8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	assert(ALIGNMENT_IS_OK(dst, uint64_t));
 110e8fc:	f240081f 	tst	x0, #0x7
{
 110e900:	910003fd 	mov	x29, sp
	assert(ALIGNMENT_IS_OK(dst, uint64_t));
 110e904:	54000140 	b.eq	110e92c <internal_aes_gcm_xor_block+0x34>  // b.none
 110e908:	b0000223 	adrp	x3, 1153000 <__func__.3477+0x91>
 110e90c:	b0000221 	adrp	x1, 1153000 <__func__.3477+0x91>
 110e910:	b0000220 	adrp	x0, 1153000 <__func__.3477+0x91>
 110e914:	912fa063 	add	x3, x3, #0xbe8
 110e918:	912d3021 	add	x1, x1, #0xb4c
 110e91c:	912dcc00 	add	x0, x0, #0xb73
 110e920:	52800be2 	mov	w2, #0x5f                  	// #95
	assert(ALIGNMENT_IS_OK(src, uint64_t));
 110e924:	94000e62 	bl	11122ac <_assert_log>
 110e928:	94000e72 	bl	11122f0 <_assert_break>
 110e92c:	f240083f 	tst	x1, #0x7
 110e930:	54000120 	b.eq	110e954 <internal_aes_gcm_xor_block+0x5c>  // b.none
 110e934:	b0000223 	adrp	x3, 1153000 <__func__.3477+0x91>
 110e938:	b0000221 	adrp	x1, 1153000 <__func__.3477+0x91>
 110e93c:	b0000220 	adrp	x0, 1153000 <__func__.3477+0x91>
 110e940:	912fa063 	add	x3, x3, #0xbe8
 110e944:	912d3021 	add	x1, x1, #0xb4c
 110e948:	912e4800 	add	x0, x0, #0xb92
 110e94c:	52800c02 	mov	w2, #0x60                  	// #96
 110e950:	17fffff5 	b	110e924 <internal_aes_gcm_xor_block+0x2c>
	d[0] ^= s[0];
 110e954:	f9400023 	ldr	x3, [x1]
 110e958:	f9400002 	ldr	x2, [x0]
 110e95c:	ca030042 	eor	x2, x2, x3
 110e960:	f9000002 	str	x2, [x0]
	d[1] ^= s[1];
 110e964:	f9400402 	ldr	x2, [x0, #8]
 110e968:	f9400421 	ldr	x1, [x1, #8]
 110e96c:	ca010041 	eor	x1, x2, x1
 110e970:	f9000401 	str	x1, [x0, #8]
}
 110e974:	a8c17bfd 	ldp	x29, x30, [sp], #16
 110e978:	d65f03c0 	ret

000000000110e97c <ghash_update_block>:
#endif
}

static void ghash_update_block(struct internal_aes_gcm_state *state,
			       const void *data)
{
 110e97c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 110e980:	910003fd 	mov	x29, sp
 110e984:	a90153f3 	stp	x19, x20, [sp, #16]
	void *y = state->hash_state;
 110e988:	91044014 	add	x20, x0, #0x110
{
 110e98c:	aa0003f3 	mov	x19, x0

	internal_aes_gcm_xor_block(y, data);
 110e990:	aa1403e0 	mov	x0, x20
 110e994:	97ffffd9 	bl	110e8f8 <internal_aes_gcm_xor_block>
#ifdef CFG_AES_GCM_TABLE_BASED
	internal_aes_gcm_ghash_mult_tbl(&state->ghash_key, y, y);
 110e998:	aa1403e2 	mov	x2, x20
 110e99c:	aa1403e1 	mov	x1, x20
 110e9a0:	91004260 	add	x0, x19, #0x10
#else
	internal_aes_gcm_gfmul(state->ghash_key.hash_subkey, y, y);
#endif
}
 110e9a4:	a94153f3 	ldp	x19, x20, [sp, #16]
 110e9a8:	a8c27bfd 	ldp	x29, x30, [sp], #32
	internal_aes_gcm_ghash_mult_tbl(&state->ghash_key, y, y);
 110e9ac:	140000df 	b	110ed28 <internal_aes_gcm_ghash_mult_tbl>

000000000110e9b0 <encrypt_block>:
}

static void encrypt_block(struct internal_aes_gcm_state *state,
			  const struct internal_aes_gcm_key *enc_key,
			  const uint64_t src[2], uint64_t dst[2])
{
 110e9b0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 110e9b4:	910003fd 	mov	x29, sp
 110e9b8:	a9025bf5 	stp	x21, x22, [sp, #32]
	void *buf_cryp = state->buf_cryp;
 110e9bc:	91050015 	add	x21, x0, #0x140
{
 110e9c0:	aa0303f6 	mov	x22, x3
 110e9c4:	a90153f3 	stp	x19, x20, [sp, #16]
 110e9c8:	aa0003f3 	mov	x19, x0
 110e9cc:	aa0103f4 	mov	x20, x1

	internal_aes_gcm_xor_block(buf_cryp, src);
 110e9d0:	aa1503e0 	mov	x0, x21
{
 110e9d4:	aa0203e1 	mov	x1, x2
	internal_aes_gcm_xor_block(buf_cryp, src);
 110e9d8:	97ffffc8 	bl	110e8f8 <internal_aes_gcm_xor_block>
		ghash_update_block(state, head);
 110e9dc:	aa1503e1 	mov	x1, x21
 110e9e0:	aa1303e0 	mov	x0, x19
 110e9e4:	97ffffe6 	bl	110e97c <ghash_update_block>
	internal_aes_gcm_ghash_update(state, buf_cryp, NULL, 0);
	memcpy(dst, buf_cryp, sizeof(state->buf_cryp));
 110e9e8:	aa1503e1 	mov	x1, x21
 110e9ec:	aa1603e0 	mov	x0, x22
 110e9f0:	d2800202 	mov	x2, #0x10                  	// #16
 110e9f4:	97ffd267 	bl	1103390 <memcpy>

	crypto_aes_enc_block(enc_key->data, sizeof(enc_key->data),
 110e9f8:	b940f282 	ldr	w2, [x20, #240]
 110e9fc:	aa1503e4 	mov	x4, x21
 110ea00:	aa1303e3 	mov	x3, x19
 110ea04:	aa1403e0 	mov	x0, x20
 110ea08:	d2801e01 	mov	x1, #0xf0                  	// #240
 110ea0c:	9400741a 	bl	112ba74 <crypto_aes_enc_block>
			     enc_key->rounds, state->ctr, state->buf_cryp);
	internal_aes_gcm_inc_ctr(state);
 110ea10:	aa1303e0 	mov	x0, x19
}
 110ea14:	a94153f3 	ldp	x19, x20, [sp, #16]
 110ea18:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110ea1c:	a8c37bfd 	ldp	x29, x30, [sp], #48
	internal_aes_gcm_inc_ctr(state);
 110ea20:	17fffdec 	b	110e1d0 <internal_aes_gcm_inc_ctr>

000000000110ea24 <decrypt_block>:
}

static void decrypt_block(struct internal_aes_gcm_state *state,
			  const struct internal_aes_gcm_key *enc_key,
			  const uint64_t src[2], uint64_t dst[2])
{
 110ea24:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 110ea28:	910003fd 	mov	x29, sp
 110ea2c:	a90153f3 	stp	x19, x20, [sp, #16]
 110ea30:	aa0003f3 	mov	x19, x0
 110ea34:	aa0203f4 	mov	x20, x2
	void *buf_cryp = state->buf_cryp;

	crypto_aes_enc_block(enc_key->data, sizeof(enc_key->data),
 110ea38:	b940f022 	ldr	w2, [x1, #240]
{
 110ea3c:	aa0103e0 	mov	x0, x1
 110ea40:	a9025bf5 	stp	x21, x22, [sp, #32]
	void *buf_cryp = state->buf_cryp;
 110ea44:	91050276 	add	x22, x19, #0x140
	crypto_aes_enc_block(enc_key->data, sizeof(enc_key->data),
 110ea48:	aa1603e4 	mov	x4, x22
{
 110ea4c:	aa0303f5 	mov	x21, x3
	crypto_aes_enc_block(enc_key->data, sizeof(enc_key->data),
 110ea50:	aa1303e3 	mov	x3, x19
 110ea54:	d2801e01 	mov	x1, #0xf0                  	// #240
 110ea58:	94007407 	bl	112ba74 <crypto_aes_enc_block>
			     enc_key->rounds, state->ctr, buf_cryp);
	internal_aes_gcm_inc_ctr(state);
 110ea5c:	aa1303e0 	mov	x0, x19
 110ea60:	97fffddc 	bl	110e1d0 <internal_aes_gcm_inc_ctr>

	internal_aes_gcm_xor_block(buf_cryp, src);
 110ea64:	aa1403e1 	mov	x1, x20
 110ea68:	aa1603e0 	mov	x0, x22
 110ea6c:	97ffffa3 	bl	110e8f8 <internal_aes_gcm_xor_block>
	if (head)
 110ea70:	b4000094 	cbz	x20, 110ea80 <decrypt_block+0x5c>
		ghash_update_block(state, head);
 110ea74:	aa1403e1 	mov	x1, x20
 110ea78:	aa1303e0 	mov	x0, x19
 110ea7c:	97ffffc0 	bl	110e97c <ghash_update_block>
	internal_aes_gcm_ghash_update(state, src, NULL, 0);
	memcpy(dst, buf_cryp, sizeof(state->buf_cryp));
 110ea80:	aa1603e1 	mov	x1, x22
 110ea84:	aa1503e0 	mov	x0, x21
}
 110ea88:	a94153f3 	ldp	x19, x20, [sp, #16]
	memcpy(dst, buf_cryp, sizeof(state->buf_cryp));
 110ea8c:	d2800202 	mov	x2, #0x10                  	// #16
}
 110ea90:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110ea94:	a8c37bfd 	ldp	x29, x30, [sp], #48
	memcpy(dst, buf_cryp, sizeof(state->buf_cryp));
 110ea98:	17ffd23e 	b	1103390 <memcpy>

000000000110ea9c <internal_aes_gcm_set_key>:
	internal_aes_gcm_ghash_gen_tbl(&state->ghash_key, ek);
 110ea9c:	91004000 	add	x0, x0, #0x10
 110eaa0:	1400006a 	b	110ec48 <internal_aes_gcm_ghash_gen_tbl>

000000000110eaa4 <internal_aes_gcm_ghash_update>:
{
 110eaa4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 110eaa8:	910003fd 	mov	x29, sp
 110eaac:	a90153f3 	stp	x19, x20, [sp, #16]
 110eab0:	aa0203f4 	mov	x20, x2
 110eab4:	a9025bf5 	stp	x21, x22, [sp, #32]
 110eab8:	aa0003f6 	mov	x22, x0
 110eabc:	aa0303f5 	mov	x21, x3
	if (head)
 110eac0:	b4000041 	cbz	x1, 110eac8 <internal_aes_gcm_ghash_update+0x24>
		ghash_update_block(state, head);
 110eac4:	97ffffae 	bl	110e97c <ghash_update_block>
	if (data)
 110eac8:	b5000194 	cbnz	x20, 110eaf8 <internal_aes_gcm_ghash_update+0x54>
}
 110eacc:	a94153f3 	ldp	x19, x20, [sp, #16]
 110ead0:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110ead4:	a8c37bfd 	ldp	x29, x30, [sp], #48
 110ead8:	d65f03c0 	ret
			ghash_update_block(state,
 110eadc:	8b131281 	add	x1, x20, x19, lsl #4
		for (n = 0; n < num_blocks; n++)
 110eae0:	91000673 	add	x19, x19, #0x1
			ghash_update_block(state,
 110eae4:	aa1603e0 	mov	x0, x22
 110eae8:	97ffffa5 	bl	110e97c <ghash_update_block>
		for (n = 0; n < num_blocks; n++)
 110eaec:	eb1302bf 	cmp	x21, x19
 110eaf0:	54ffff61 	b.ne	110eadc <internal_aes_gcm_ghash_update+0x38>  // b.any
 110eaf4:	17fffff6 	b	110eacc <internal_aes_gcm_ghash_update+0x28>
 110eaf8:	d2800013 	mov	x19, #0x0                   	// #0
 110eafc:	17fffffc 	b	110eaec <internal_aes_gcm_ghash_update+0x48>

000000000110eb00 <internal_aes_gcm_update_payload_blocks>:
void
internal_aes_gcm_update_payload_blocks(struct internal_aes_gcm_state *state,
				       const struct internal_aes_gcm_key *ek,
				       TEE_OperationMode m, const void *src,
				       size_t num_blocks, void *dst)
{
 110eb00:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
 110eb04:	910003fd 	mov	x29, sp
 110eb08:	a9025bf5 	stp	x21, x22, [sp, #32]
 110eb0c:	aa0003f5 	mov	x21, x0
	assert(!state->buf_pos && num_blocks);
 110eb10:	b9415c00 	ldr	w0, [x0, #348]
{
 110eb14:	a90153f3 	stp	x19, x20, [sp, #16]
 110eb18:	a90363f7 	stp	x23, x24, [sp, #48]
 110eb1c:	a9046bf9 	stp	x25, x26, [sp, #64]
	assert(!state->buf_pos && num_blocks);
 110eb20:	35000060 	cbnz	w0, 110eb2c <internal_aes_gcm_update_payload_blocks+0x2c>
 110eb24:	aa0403f4 	mov	x20, x4
 110eb28:	b5000144 	cbnz	x4, 110eb50 <internal_aes_gcm_update_payload_blocks+0x50>
 110eb2c:	b0000223 	adrp	x3, 1153000 <__func__.3477+0x91>
 110eb30:	b0000221 	adrp	x1, 1153000 <__func__.3477+0x91>
 110eb34:	91300c63 	add	x3, x3, #0xc03
 110eb38:	912ec421 	add	x1, x1, #0xbb1
 110eb3c:	b0000220 	adrp	x0, 1153000 <__func__.3477+0x91>
 110eb40:	912f2800 	add	x0, x0, #0xbca
 110eb44:	52801122 	mov	w2, #0x89                  	// #137
 110eb48:	94000dd9 	bl	11122ac <_assert_log>
 110eb4c:	94000de9 	bl	11122f0 <_assert_break>
 110eb50:	aa0103f7 	mov	x23, x1
 110eb54:	aa0303f6 	mov	x22, x3
 110eb58:	aa0503f8 	mov	x24, x5

	if (m == TEE_MODE_ENCRYPT)
 110eb5c:	92400873 	and	x19, x3, #0x7
 110eb60:	35000402 	cbnz	w2, 110ebe0 <internal_aes_gcm_update_payload_blocks+0xe0>
	if (ALIGNMENT_IS_OK(src, uint64_t)) {
 110eb64:	b50001f3 	cbnz	x19, 110eba0 <internal_aes_gcm_update_payload_blocks+0xa0>
			encrypt_block(state, ek, s, d);
 110eb68:	8b131303 	add	x3, x24, x19, lsl #4
 110eb6c:	8b1312c2 	add	x2, x22, x19, lsl #4
 110eb70:	aa1703e1 	mov	x1, x23
 110eb74:	aa1503e0 	mov	x0, x21
		for (n = 0; n < num_blocks; n++) {
 110eb78:	91000673 	add	x19, x19, #0x1
			encrypt_block(state, ek, s, d);
 110eb7c:	97ffff8d 	bl	110e9b0 <encrypt_block>
		for (n = 0; n < num_blocks; n++) {
 110eb80:	eb13029f 	cmp	x20, x19
 110eb84:	54ffff21 	b.ne	110eb68 <internal_aes_gcm_update_payload_blocks+0x68>  // b.any
		encrypt_pl(state, ek, src, num_blocks, dst);
	else
		decrypt_pl(state, ek, src, num_blocks, dst);
}
 110eb88:	a94153f3 	ldp	x19, x20, [sp, #16]
 110eb8c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110eb90:	a94363f7 	ldp	x23, x24, [sp, #48]
 110eb94:	a9446bf9 	ldp	x25, x26, [sp, #64]
 110eb98:	a8c67bfd 	ldp	x29, x30, [sp], #96
 110eb9c:	d65f03c0 	ret
			memcpy(tmp, src + n * TEE_AES_BLOCK_SIZE, sizeof(tmp));
 110eba0:	910143f9 	add	x25, sp, #0x50
		for (n = 0; n < num_blocks; n++) {
 110eba4:	d2800013 	mov	x19, #0x0                   	// #0
			memcpy(tmp, src + n * TEE_AES_BLOCK_SIZE, sizeof(tmp));
 110eba8:	8b1312c1 	add	x1, x22, x19, lsl #4
 110ebac:	d37cee7a 	lsl	x26, x19, #4
 110ebb0:	d2800202 	mov	x2, #0x10                  	// #16
 110ebb4:	aa1903e0 	mov	x0, x25
 110ebb8:	97ffd1f6 	bl	1103390 <memcpy>
		for (n = 0; n < num_blocks; n++) {
 110ebbc:	91000673 	add	x19, x19, #0x1
			encrypt_block(state, ek, tmp, d);
 110ebc0:	8b1a0303 	add	x3, x24, x26
 110ebc4:	aa1903e2 	mov	x2, x25
 110ebc8:	aa1703e1 	mov	x1, x23
 110ebcc:	aa1503e0 	mov	x0, x21
 110ebd0:	97ffff78 	bl	110e9b0 <encrypt_block>
		for (n = 0; n < num_blocks; n++) {
 110ebd4:	eb13029f 	cmp	x20, x19
 110ebd8:	54fffe81 	b.ne	110eba8 <internal_aes_gcm_update_payload_blocks+0xa8>  // b.any
 110ebdc:	17ffffeb 	b	110eb88 <internal_aes_gcm_update_payload_blocks+0x88>
	if (ALIGNMENT_IS_OK(src, uint64_t)) {
 110ebe0:	b5000153 	cbnz	x19, 110ec08 <internal_aes_gcm_update_payload_blocks+0x108>
			decrypt_block(state, ek, s, d);
 110ebe4:	8b131303 	add	x3, x24, x19, lsl #4
 110ebe8:	8b1312c2 	add	x2, x22, x19, lsl #4
 110ebec:	aa1703e1 	mov	x1, x23
 110ebf0:	aa1503e0 	mov	x0, x21
		for (n = 0; n < num_blocks; n++) {
 110ebf4:	91000673 	add	x19, x19, #0x1
			decrypt_block(state, ek, s, d);
 110ebf8:	97ffff8b 	bl	110ea24 <decrypt_block>
		for (n = 0; n < num_blocks; n++) {
 110ebfc:	eb13029f 	cmp	x20, x19
 110ec00:	54ffff21 	b.ne	110ebe4 <internal_aes_gcm_update_payload_blocks+0xe4>  // b.any
 110ec04:	17ffffe1 	b	110eb88 <internal_aes_gcm_update_payload_blocks+0x88>
			memcpy(tmp, src + n * TEE_AES_BLOCK_SIZE, sizeof(tmp));
 110ec08:	910143f9 	add	x25, sp, #0x50
		for (n = 0; n < num_blocks; n++) {
 110ec0c:	d2800013 	mov	x19, #0x0                   	// #0
			memcpy(tmp, src + n * TEE_AES_BLOCK_SIZE, sizeof(tmp));
 110ec10:	8b1312c1 	add	x1, x22, x19, lsl #4
 110ec14:	d37cee7a 	lsl	x26, x19, #4
 110ec18:	d2800202 	mov	x2, #0x10                  	// #16
 110ec1c:	aa1903e0 	mov	x0, x25
 110ec20:	97ffd1dc 	bl	1103390 <memcpy>
		for (n = 0; n < num_blocks; n++) {
 110ec24:	91000673 	add	x19, x19, #0x1
			decrypt_block(state, ek, tmp, d);
 110ec28:	8b1a0303 	add	x3, x24, x26
 110ec2c:	aa1903e2 	mov	x2, x25
 110ec30:	aa1703e1 	mov	x1, x23
 110ec34:	aa1503e0 	mov	x0, x21
 110ec38:	97ffff7b 	bl	110ea24 <decrypt_block>
		for (n = 0; n < num_blocks; n++) {
 110ec3c:	eb13029f 	cmp	x20, x19
 110ec40:	54fffe81 	b.ne	110ec10 <internal_aes_gcm_update_payload_blocks+0x110>  // b.any
 110ec44:	17ffffd1 	b	110eb88 <internal_aes_gcm_update_payload_blocks+0x88>

000000000110ec48 <internal_aes_gcm_ghash_gen_tbl>:
 * is the high-order bit of HH corresponds to P^0 and the low-order bit of HL
 * corresponds to P^127.
 */
void internal_aes_gcm_ghash_gen_tbl(struct internal_ghash_key *ghash_key,
				    const struct internal_aes_gcm_key *ek)
{
 110ec48:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 110ec4c:	910003fd 	mov	x29, sp
 110ec50:	f9000bf3 	str	x19, [sp, #16]
 110ec54:	aa0003f3 	mov	x19, x0
 110ec58:	aa0103e0 	mov	x0, x1
	int i, j;
	uint64_t vl, vh;
	unsigned char h[16];

	memset(h, 0, 16);
	crypto_aes_enc_block(ek->data, sizeof(ek->data), ek->rounds, h, h);
 110ec5c:	910083e4 	add	x4, sp, #0x20
 110ec60:	aa0403e3 	mov	x3, x4
 110ec64:	d2801e01 	mov	x1, #0xf0                  	// #240
	memset(h, 0, 16);
 110ec68:	a9027fff 	stp	xzr, xzr, [sp, #32]
	crypto_aes_enc_block(ek->data, sizeof(ek->data), ek->rounds, h, h);
 110ec6c:	b940f002 	ldr	w2, [x0, #240]
 110ec70:	94007381 	bl	112ba74 <crypto_aes_enc_block>
	ghash_key->HL[8] = vl;
	ghash_key->HH[8] = vh;

	/* 0 corresponds to 0 in GF(2^128) */
	ghash_key->HH[0] = 0;
	ghash_key->HL[0] = 0;
 110ec74:	f900027f 	str	xzr, [x19]
	io_write32(addr, (io_read32(addr) & ~mask) | (val & mask));
}

static inline uint64_t get_be64(const void *p)
{
	return TEE_U64_FROM_BIG_ENDIAN(*(const uint64_t *)p);
 110ec78:	a94207e0 	ldp	x0, x1, [sp, #32]
 110ec7c:	52800064 	mov	w4, #0x3                   	// #3

	for (i = 4; i > 0; i >>= 1) {
 110ec80:	52800083 	mov	w3, #0x4                   	// #4
		uint32_t T = (vl & 1) * 0xe1000000U;
 110ec84:	52bc2005 	mov	w5, #0xe1000000            	// #-520093696
	ghash_key->HH[0] = 0;
 110ec88:	f900427f 	str	xzr, [x19, #128]
 110ec8c:	dac00c00 	rev	x0, x0
 110ec90:	dac00c21 	rev	x1, x1
	ghash_key->HL[8] = vl;
 110ec94:	f9002261 	str	x1, [x19, #64]
	ghash_key->HH[8] = vh;
 110ec98:	f9006260 	str	x0, [x19, #192]
		uint32_t T = (vl & 1) * 0xe1000000U;
 110ec9c:	12000022 	and	w2, w1, #0x1

		vl  = (vh << 63) | (vl >> 1);
 110eca0:	93c10401 	extr	x1, x0, x1, #1
		vh  = (vh >> 1) ^ ((uint64_t)T << 32);

		ghash_key->HL[i] = vl;
 110eca4:	f823da61 	str	x1, [x19, w3, sxtw #3]
	for (i = 4; i > 0; i >>= 1) {
 110eca8:	71000484 	subs	w4, w4, #0x1
		uint32_t T = (vl & 1) * 0xe1000000U;
 110ecac:	1b057c42 	mul	w2, w2, w5
		vh  = (vh >> 1) ^ ((uint64_t)T << 32);
 110ecb0:	d3607c42 	lsl	x2, x2, #32
 110ecb4:	ca400440 	eor	x0, x2, x0, lsr #1
		ghash_key->HH[i] = vh;
 110ecb8:	8b23ce62 	add	x2, x19, w3, sxtw #3
	for (i = 4; i > 0; i >>= 1) {
 110ecbc:	13017c63 	asr	w3, w3, #1
		ghash_key->HH[i] = vh;
 110ecc0:	f9004040 	str	x0, [x2, #128]
	for (i = 4; i > 0; i >>= 1) {
 110ecc4:	54fffec1 	b.ne	110ec9c <internal_aes_gcm_ghash_gen_tbl+0x54>  // b.any
	}

	for (i = 2; i <= 8; i *= 2) {
		uint64_t *HiL = ghash_key->HL + i;
		uint64_t *HiH = ghash_key->HH + i;
 110ecc8:	91020263 	add	x3, x19, #0x80
 110eccc:	52800062 	mov	w2, #0x3                   	// #3
	for (i = 2; i <= 8; i *= 2) {
 110ecd0:	52800041 	mov	w1, #0x2                   	// #2
		uint64_t *HiL = ghash_key->HL + i;
 110ecd4:	937d7c20 	sbfiz	x0, x1, #3, #32
 110ecd8:	8b21ce65 	add	x5, x19, w1, sxtw #3
		uint64_t *HiH = ghash_key->HH + i;
 110ecdc:	8b21cc67 	add	x7, x3, w1, sxtw #3

		vh = *HiH;
 110ece0:	f8606868 	ldr	x8, [x3, x0]
		vl = *HiL;
 110ece4:	f8606a66 	ldr	x6, [x19, x0]
 110ece8:	d2800020 	mov	x0, #0x1                   	// #1
		for (j = 1; j < i; j++) {
			HiH[j] = vh ^ ghash_key->HH[j];
 110ecec:	f8607864 	ldr	x4, [x3, x0, lsl #3]
 110ecf0:	ca080084 	eor	x4, x4, x8
 110ecf4:	f82078e4 	str	x4, [x7, x0, lsl #3]
			HiL[j] = vl ^ ghash_key->HL[j];
 110ecf8:	f8607a64 	ldr	x4, [x19, x0, lsl #3]
 110ecfc:	ca060084 	eor	x4, x4, x6
 110ed00:	f82078a4 	str	x4, [x5, x0, lsl #3]
		for (j = 1; j < i; j++) {
 110ed04:	91000400 	add	x0, x0, #0x1
 110ed08:	6b00003f 	cmp	w1, w0
 110ed0c:	54ffff0c 	b.gt	110ecec <internal_aes_gcm_ghash_gen_tbl+0xa4>
	for (i = 2; i <= 8; i *= 2) {
 110ed10:	531f7821 	lsl	w1, w1, #1
 110ed14:	71000442 	subs	w2, w2, #0x1
 110ed18:	54fffde1 	b.ne	110ecd4 <internal_aes_gcm_ghash_gen_tbl+0x8c>  // b.any
		}
	}
}
 110ed1c:	f9400bf3 	ldr	x19, [sp, #16]
 110ed20:	a8c37bfd 	ldp	x29, x30, [sp], #48
 110ed24:	d65f03c0 	ret

000000000110ed28 <internal_aes_gcm_ghash_mult_tbl>:
{
	int i = 0;
	unsigned char lo = 0, hi = 0, rem = 0;
	uint64_t zh = 0, zl = 0;

	lo = x[15] & 0xf;
 110ed28:	39403c23 	ldrb	w3, [x1, #15]
 110ed2c:	90000207 	adrp	x7, 114e000 <ldelf_data+0x8000>
 110ed30:	910180e7 	add	x7, x7, #0x60

	zh = ghash_key->HH[lo];
	zl = ghash_key->HL[lo];
 110ed34:	d28001e6 	mov	x6, #0xf                   	// #15
		}

		rem = (unsigned char)zl & 0xf;
		zl = (zh << 60) | (zl >> 4);
		zh = (zh >> 4);
		zh ^= (uint64_t)last4[rem] << 48;
 110ed38:	aa0703eb 	mov	x11, x7
 110ed3c:	d37d0c63 	ubfiz	x3, x3, #3, #4
 110ed40:	8b030004 	add	x4, x0, x3
	zl = ghash_key->HL[lo];
 110ed44:	f8636803 	ldr	x3, [x0, x3]
	zh = ghash_key->HH[lo];
 110ed48:	f9404084 	ldr	x4, [x4, #128]
		lo = x[i] & 0xf;
 110ed4c:	92400c69 	and	x9, x3, #0xf
 110ed50:	38666825 	ldrb	w5, [x1, x6]
 110ed54:	93c3108c 	extr	x12, x4, x3, #4
 110ed58:	d344fc8a 	lsr	x10, x4, #4
		if (i != 15) {
 110ed5c:	f1003cdf 	cmp	x6, #0xf
 110ed60:	f86978e9 	ldr	x9, [x7, x9, lsl #3]
		lo = x[i] & 0xf;
 110ed64:	12000ca8 	and	w8, w5, #0xf
		hi = x[i] >> 4;
 110ed68:	53047ca5 	lsr	w5, w5, #4
		if (i != 15) {
 110ed6c:	d3503d29 	lsl	x9, x9, #48
 110ed70:	54000100 	b.eq	110ed90 <internal_aes_gcm_ghash_mult_tbl+0x68>  // b.none
			zh ^= ghash_key->HH[lo];
 110ed74:	d37d0d03 	ubfiz	x3, x8, #3, #4
 110ed78:	8b030004 	add	x4, x0, x3
			zl ^= ghash_key->HL[lo];
 110ed7c:	f8636803 	ldr	x3, [x0, x3]
			zh ^= ghash_key->HH[lo];
 110ed80:	f9404084 	ldr	x4, [x4, #128]
			zl ^= ghash_key->HL[lo];
 110ed84:	ca030183 	eor	x3, x12, x3
			zh ^= ghash_key->HH[lo];
 110ed88:	ca040144 	eor	x4, x10, x4
 110ed8c:	ca090084 	eor	x4, x4, x9
		zl = (zh << 60) | (zl >> 4);
 110ed90:	d37d0ca5 	ubfiz	x5, x5, #3, #4
 110ed94:	93c31088 	extr	x8, x4, x3, #4
		zh ^= ghash_key->HH[hi];
 110ed98:	8b050009 	add	x9, x0, x5
		zh ^= (uint64_t)last4[rem] << 48;
 110ed9c:	92400c63 	and	x3, x3, #0xf
 110eda0:	d10004c6 	sub	x6, x6, #0x1
	for (i = 15; i >= 0; i--) {
 110eda4:	b10004df 	cmn	x6, #0x1
 110eda8:	f9404129 	ldr	x9, [x9, #128]
		zh ^= (uint64_t)last4[rem] << 48;
 110edac:	f8637963 	ldr	x3, [x11, x3, lsl #3]
 110edb0:	ca441124 	eor	x4, x9, x4, lsr #4
		zh ^= ghash_key->HH[hi];
 110edb4:	ca03c084 	eor	x4, x4, x3, lsl #48
		zl ^= ghash_key->HL[hi];
 110edb8:	f8656803 	ldr	x3, [x0, x5]
 110edbc:	ca030103 	eor	x3, x8, x3
	for (i = 15; i >= 0; i--) {
 110edc0:	54fffc61 	b.ne	110ed4c <internal_aes_gcm_ghash_mult_tbl+0x24>  // b.any
}

static inline void put_be64(void *p, uint64_t val)
{
	*(uint64_t *)p = TEE_U64_TO_BIG_ENDIAN(val);
 110edc4:	dac00c84 	rev	x4, x4
 110edc8:	dac00c63 	rev	x3, x3
 110edcc:	a9000c44 	stp	x4, x3, [x2]
	}

	put_be64(output, zh);
	put_be64(output + 8, zl);
}
 110edd0:	d65f03c0 	ret

000000000110edd4 <shdr_alloc_and_copy>:
#include <tee/tee_cryp_utl.h>
#include <utee_defines.h>
#include <util.h>

struct shdr *shdr_alloc_and_copy(const struct shdr *img, size_t img_size)
{
 110edd4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	size_t shdr_size;
	struct shdr *shdr;
	vaddr_t img_va = (vaddr_t)img;
	vaddr_t tmp = 0;

	if (img_size < sizeof(struct shdr))
 110edd8:	f1004c3f 	cmp	x1, #0x13
{
 110eddc:	910003fd 	mov	x29, sp
 110ede0:	a90153f3 	stp	x19, x20, [sp, #16]
 110ede4:	a9025bf5 	stp	x21, x22, [sp, #32]
	if (img_size < sizeof(struct shdr))
 110ede8:	540000e8 	b.hi	110ee04 <shdr_alloc_and_copy+0x30>  // b.pmore
	memcpy(shdr, img, shdr_size);

	/* Check that the data wasn't modified before the copy was completed */
	if (shdr_size != SHDR_GET_SIZE(shdr)) {
		free(shdr);
		return NULL;
 110edec:	d2800013 	mov	x19, #0x0                   	// #0
	}

	return shdr;
}
 110edf0:	aa1303e0 	mov	x0, x19
 110edf4:	a94153f3 	ldp	x19, x20, [sp, #16]
 110edf8:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110edfc:	a8c37bfd 	ldp	x29, x30, [sp], #48
 110ee00:	d65f03c0 	ret
static inline size_t shdr_get_size(const struct shdr *shdr)
{
	size_t s = sizeof(*shdr);

	if (ADD_OVERFLOW(s, shdr->hash_size, &s) ||
	    ADD_OVERFLOW(s, shdr->sig_size, &s))
 110ee04:	79402416 	ldrh	w22, [x0, #18]
 110ee08:	aa0003f4 	mov	x20, x0
	if (ADD_OVERFLOW(s, shdr->hash_size, &s) ||
 110ee0c:	79402000 	ldrh	w0, [x0, #16]
 110ee10:	8b0002d6 	add	x22, x22, x0
	    ADD_OVERFLOW(s, shdr->sig_size, &s))
 110ee14:	910052d5 	add	x21, x22, #0x14
	if (img_size < shdr_size)
 110ee18:	eb15003f 	cmp	x1, x21
 110ee1c:	54fffe83 	b.cc	110edec <shdr_alloc_and_copy+0x18>  // b.lo, b.ul, b.last
	if (ADD_OVERFLOW(img_va, shdr_size, &tmp))
 110ee20:	ab150280 	adds	x0, x20, x21
 110ee24:	54fffe42 	b.cs	110edec <shdr_alloc_and_copy+0x18>  // b.hs, b.nlast
	shdr = malloc(shdr_size);
 110ee28:	aa1503e0 	mov	x0, x21
 110ee2c:	9400d18b 	bl	1143458 <malloc>
 110ee30:	aa0003f3 	mov	x19, x0
	if (!shdr)
 110ee34:	b4fffdc0 	cbz	x0, 110edec <shdr_alloc_and_copy+0x18>
	memcpy(shdr, img, shdr_size);
 110ee38:	aa1403e1 	mov	x1, x20
 110ee3c:	aa1503e2 	mov	x2, x21
 110ee40:	97ffd154 	bl	1103390 <memcpy>
	if (ADD_OVERFLOW(s, shdr->hash_size, &s) ||
 110ee44:	79402260 	ldrh	w0, [x19, #16]
	    ADD_OVERFLOW(s, shdr->sig_size, &s))
 110ee48:	79402661 	ldrh	w1, [x19, #18]
	if (shdr_size != SHDR_GET_SIZE(shdr)) {
 110ee4c:	8b010000 	add	x0, x0, x1
 110ee50:	eb16001f 	cmp	x0, x22
 110ee54:	54fffce0 	b.eq	110edf0 <shdr_alloc_and_copy+0x1c>  // b.none
		free(shdr);
 110ee58:	aa1303e0 	mov	x0, x19
 110ee5c:	9400d1e1 	bl	11435e0 <free>
 110ee60:	17ffffe3 	b	110edec <shdr_alloc_and_copy+0x18>

000000000110ee64 <shdr_verify_signature>:

TEE_Result shdr_verify_signature(const struct shdr *shdr)
{
 110ee64:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 110ee68:	910003fd 	mov	x29, sp
 110ee6c:	a90153f3 	stp	x19, x20, [sp, #16]
 110ee70:	aa0003f4 	mov	x20, x0
	struct rsa_public_key key;
	TEE_Result res;
	uint32_t e = TEE_U32_TO_BIG_ENDIAN(ta_pub_key_exponent);
 110ee74:	90000260 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
{
 110ee78:	a9025bf5 	stp	x21, x22, [sp, #32]
	size_t hash_size;

	if (shdr->magic != SHDR_MAGIC)
 110ee7c:	b9400282 	ldr	w2, [x20]
	uint32_t e = TEE_U32_TO_BIG_ENDIAN(ta_pub_key_exponent);
 110ee80:	f9412001 	ldr	x1, [x0, #576]
 110ee84:	b9400021 	ldr	w1, [x1]
 110ee88:	5ac00821 	rev	w1, w1
 110ee8c:	b90037e1 	str	w1, [sp, #52]
	if (shdr->magic != SHDR_MAGIC)
 110ee90:	528a6901 	mov	w1, #0x5348                	// #21320
 110ee94:	72a9ea81 	movk	w1, #0x4f54, lsl #16
 110ee98:	6b01005f 	cmp	w2, w1
 110ee9c:	540007e1 	b.ne	110ef98 <shdr_verify_signature+0x134>  // b.any
 110eea0:	aa0003f6 	mov	x22, x0
		return TEE_ERROR_SECURITY;

	if (TEE_ALG_GET_MAIN_ALG(shdr->algo) != TEE_MAIN_ALGO_RSA)
 110eea4:	b9400e80 	ldr	w0, [x20, #12]
	switch (algo) {
 110eea8:	528008a1 	mov	w1, #0x45                  	// #69
 110eeac:	72ac0001 	movk	w1, #0x6000, lsl #16
 110eeb0:	6b01001f 	cmp	w0, w1
 110eeb4:	54000720 	b.eq	110ef98 <shdr_verify_signature+0x134>  // b.none
 110eeb8:	528008a1 	mov	w1, #0x45                  	// #69
 110eebc:	72b00001 	movk	w1, #0x8000, lsl #16
 110eec0:	6b01001f 	cmp	w0, w1
 110eec4:	540006a0 	b.eq	110ef98 <shdr_verify_signature+0x134>  // b.none
	return algo & 0xff;
 110eec8:	12001c01 	and	w1, w0, #0xff
 110eecc:	7100c03f 	cmp	w1, #0x30
 110eed0:	54000641 	b.ne	110ef98 <shdr_verify_signature+0x134>  // b.any
 */
#define __TEE_MAIN_HASH_SM3 0x7

static inline uint32_t __tee_alg_get_digest_hash(uint32_t algo)
{
	if (algo == TEE_ALG_SM2_DSA_SM3)
 110eed4:	528c08a1 	mov	w1, #0x6045                	// #24645
 110eed8:	72ae0001 	movk	w1, #0x7000, lsl #16
 110eedc:	6b01001f 	cmp	w0, w1
 110eee0:	54000680 	b.eq	110efb0 <shdr_verify_signature+0x14c>  // b.none
		return __TEE_MAIN_HASH_SM3;

	/* Bits [15:12] */
	return (algo >> 12) & 0xF;
 110eee4:	d34c3c00 	ubfx	x0, x0, #12, #4
static inline uint32_t __tee_alg_hash_algo(uint32_t main_hash)
{
	if (main_hash == __TEE_MAIN_HASH_SM3)
		return TEE_ALG_SM3;

	return (TEE_OPERATION_DIGEST << 28) | main_hash;
 110eee8:	52aa0001 	mov	w1, #0x50000000            	// #1342177280
 110eeec:	71001c1f 	cmp	w0, #0x7
 110eef0:	2a010001 	orr	w1, w0, w1
 110eef4:	528000e0 	mov	w0, #0x7                   	// #7
 110eef8:	72aa0000 	movk	w0, #0x5000, lsl #16
 110eefc:	1a801020 	csel	w0, w1, w0, ne  // ne = any
		return TEE_ERROR_SECURITY;

	res = tee_alg_get_digest_size(TEE_DIGEST_HASH_TO_ALGO(shdr->algo),
 110ef00:	9100e3e1 	add	x1, sp, #0x38
 110ef04:	9400320d 	bl	111b738 <tee_alg_get_digest_size>
				      &hash_size);
	if (res)
 110ef08:	35000480 	cbnz	w0, 110ef98 <shdr_verify_signature+0x134>
		return TEE_ERROR_SECURITY;
	if (hash_size != shdr->hash_size)
 110ef0c:	f9401fe0 	ldr	x0, [sp, #56]
 110ef10:	79402281 	ldrh	w1, [x20, #16]
 110ef14:	eb00003f 	cmp	x1, x0
 110ef18:	54000401 	b.ne	110ef98 <shdr_verify_signature+0x134>  // b.any
		return TEE_ERROR_SECURITY;

	res = crypto_acipher_alloc_rsa_public_key(&key, shdr->sig_size);
 110ef1c:	79402681 	ldrh	w1, [x20, #18]
 110ef20:	910103f5 	add	x21, sp, #0x40
 110ef24:	aa1503e0 	mov	x0, x21
 110ef28:	94006f09 	bl	112ab4c <crypto_acipher_alloc_rsa_public_key>
	if (res)
 110ef2c:	35000360 	cbnz	w0, 110ef98 <shdr_verify_signature+0x134>
		return TEE_ERROR_SECURITY;

	res = crypto_bignum_bin2bn((uint8_t *)&e, sizeof(e), key.e);
 110ef30:	f94023e2 	ldr	x2, [sp, #64]
 110ef34:	9100d3e0 	add	x0, sp, #0x34
 110ef38:	d2800081 	mov	x1, #0x4                   	// #4
 110ef3c:	94007ca0 	bl	112e1bc <crypto_bignum_bin2bn>
 110ef40:	2a0003f3 	mov	w19, w0
	if (res)
 110ef44:	35000240 	cbnz	w0, 110ef8c <shdr_verify_signature+0x128>
		goto out;
	res = crypto_bignum_bin2bn(ta_pub_key_modulus, ta_pub_key_modulus_size,
 110ef48:	f94192c0 	ldr	x0, [x22, #800]
 110ef4c:	f94027e2 	ldr	x2, [sp, #72]
 110ef50:	f9400001 	ldr	x1, [x0]
 110ef54:	f941f6c0 	ldr	x0, [x22, #1000]
 110ef58:	94007c99 	bl	112e1bc <crypto_bignum_bin2bn>
 110ef5c:	2a0003f3 	mov	w19, w0
				   key.n);
	if (res)
 110ef60:	35000160 	cbnz	w0, 110ef8c <shdr_verify_signature+0x128>
		goto out;

	res = crypto_acipher_rsassa_verify(shdr->algo, &key, shdr->hash_size,
 110ef64:	79402284 	ldrh	w4, [x20, #16]
 110ef68:	91005283 	add	x3, x20, #0x14
 110ef6c:	79402686 	ldrh	w6, [x20, #18]
 110ef70:	aa1503e1 	mov	x1, x21
 110ef74:	79402282 	ldrh	w2, [x20, #16]
					   SHDR_GET_HASH(shdr), shdr->hash_size,
					   SHDR_GET_SIG(shdr), shdr->sig_size);
 110ef78:	91005085 	add	x5, x4, #0x14
	res = crypto_acipher_rsassa_verify(shdr->algo, &key, shdr->hash_size,
 110ef7c:	b9400e80 	ldr	w0, [x20, #12]
 110ef80:	8b050285 	add	x5, x20, x5
 110ef84:	94007186 	bl	112b59c <crypto_acipher_rsassa_verify>
 110ef88:	2a0003f3 	mov	w19, w0
out:
	crypto_acipher_free_rsa_public_key(&key);
 110ef8c:	aa1503e0 	mov	x0, x21
 110ef90:	94006f06 	bl	112aba8 <crypto_acipher_free_rsa_public_key>
	if (res)
 110ef94:	34000053 	cbz	w19, 110ef9c <shdr_verify_signature+0x138>
	switch (algo) {
 110ef98:	129ffe13 	mov	w19, #0xffff000f            	// #-65521
		return TEE_ERROR_SECURITY;
	return TEE_SUCCESS;
}
 110ef9c:	2a1303e0 	mov	w0, w19
 110efa0:	a94153f3 	ldp	x19, x20, [sp, #16]
 110efa4:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110efa8:	a8c57bfd 	ldp	x29, x30, [sp], #80
 110efac:	d65f03c0 	ret
		return TEE_ALG_SM3;
 110efb0:	528000e0 	mov	w0, #0x7                   	// #7
 110efb4:	72aa0000 	movk	w0, #0x5000, lsl #16
 110efb8:	17ffffd2 	b	110ef00 <shdr_verify_signature+0x9c>

000000000110efbc <add_event>:
	return dlen;
}

static TEE_Result add_event(uint8_t snum, uint8_t pnum,
			    const void *data, size_t dlen)
{
 110efbc:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
	TEE_Result res;
	size_t dl = MIN(MAX_EVENT_DATA_LEN, dlen);
 110efc0:	f100807f 	cmp	x3, #0x20
{
 110efc4:	910003fd 	mov	x29, sp
 110efc8:	a90153f3 	stp	x19, x20, [sp, #16]
	size_t dl = MIN(MAX_EVENT_DATA_LEN, dlen);
 110efcc:	d2800413 	mov	x19, #0x20                  	// #32
 110efd0:	9a939073 	csel	x19, x3, x19, ls  // ls = plast
{
 110efd4:	a9025bf5 	stp	x21, x22, [sp, #32]
 110efd8:	12001c36 	and	w22, w1, #0xff
	uint8_t v[] = { snum, dl };

	if (pnum >= NUM_POOLS)
 110efdc:	71007edf 	cmp	w22, #0x1f
{
 110efe0:	f9001bf7 	str	x23, [sp, #48]
	uint8_t v[] = { snum, dl };
 110efe4:	390123e0 	strb	w0, [sp, #72]
 110efe8:	390127f3 	strb	w19, [sp, #73]
	if (pnum >= NUM_POOLS)
 110efec:	54000348 	b.hi	110f054 <add_event+0x98>  // b.pmore
		return TEE_ERROR_BAD_PARAMETERS;

	res = hash_update(state.pool_ctx[pnum], v, sizeof(v));
 110eff0:	93407ed5 	sxtw	x21, w22
 110eff4:	f0000274 	adrp	x20, 115d000 <_curve_names+0x590>
 110eff8:	910012b5 	add	x21, x21, #0x4
 110effc:	913e0294 	add	x20, x20, #0xf80
 110f000:	aa0203f7 	mov	x23, x2
	return crypto_hash_update(ctx, data, dlen);
 110f004:	910123e1 	add	x1, sp, #0x48
 110f008:	d2800042 	mov	x2, #0x2                   	// #2
 110f00c:	f8757a80 	ldr	x0, [x20, x21, lsl #3]
 110f010:	97fff8c5 	bl	110d324 <crypto_hash_update>
	if (res)
 110f014:	35000160 	cbnz	w0, 110f040 <add_event+0x84>
	return crypto_hash_update(ctx, data, dlen);
 110f018:	f8757a80 	ldr	x0, [x20, x21, lsl #3]
 110f01c:	aa1303e2 	mov	x2, x19
 110f020:	aa1703e1 	mov	x1, x23
 110f024:	97fff8c0 	bl	110d324 <crypto_hash_update>
		return res;
	res = hash_update(state.pool_ctx[pnum], data, dl);
	if (res)
 110f028:	350000c0 	cbnz	w0, 110f040 <add_event+0x84>
		return res;
	if (!pnum) {
 110f02c:	350000b6 	cbnz	w22, 110f040 <add_event+0x84>
		unsigned int l;

		if (!ADD_OVERFLOW(state.pool0_length, dl, &l))
 110f030:	b9401a83 	ldr	w3, [x20, #24]
 110f034:	2b130073 	adds	w19, w3, w19
 110f038:	54000042 	b.cs	110f040 <add_event+0x84>  // b.hs, b.nlast
			state.pool0_length = l;
 110f03c:	b9001a93 	str	w19, [x20, #24]
	}

	return TEE_SUCCESS;
}
 110f040:	a94153f3 	ldp	x19, x20, [sp, #16]
 110f044:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110f048:	f9401bf7 	ldr	x23, [sp, #48]
 110f04c:	a8c57bfd 	ldp	x29, x30, [sp], #80
 110f050:	d65f03c0 	ret
		return TEE_ERROR_BAD_PARAMETERS;
 110f054:	129fff20 	mov	w0, #0xffff0006            	// #-65530
 110f058:	17fffffa 	b	110f040 <add_event+0x84>

000000000110f05c <fortuna_done>:
{
 110f05c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 110f060:	910003fd 	mov	x29, sp
 110f064:	a90153f3 	stp	x19, x20, [sp, #16]
 110f068:	d0000273 	adrp	x19, 115d000 <_curve_names+0x590>
 110f06c:	913e0274 	add	x20, x19, #0xf80
 110f070:	f90013f5 	str	x21, [sp, #32]
	for (n = 0; n < NUM_POOLS; n++) {
 110f074:	d2800015 	mov	x21, #0x0                   	// #0
		crypto_hash_free_ctx(state.pool_ctx[n]);
 110f078:	f9401280 	ldr	x0, [x20, #32]
	for (n = 0; n < NUM_POOLS; n++) {
 110f07c:	910006b5 	add	x21, x21, #0x1
 110f080:	91002294 	add	x20, x20, #0x8
		crypto_hash_free_ctx(state.pool_ctx[n]);
 110f084:	97fff883 	bl	110d290 <crypto_hash_free_ctx>
		state.pool_ctx[n] = NULL;
 110f088:	f9000e9f 	str	xzr, [x20, #24]
	for (n = 0; n < NUM_POOLS; n++) {
 110f08c:	f10082bf 	cmp	x21, #0x20
 110f090:	54ffff41 	b.ne	110f078 <fortuna_done+0x1c>  // b.any
	crypto_hash_free_ctx(state.reseed_ctx);
 110f094:	913e0274 	add	x20, x19, #0xf80
 110f098:	f9409280 	ldr	x0, [x20, #288]
 110f09c:	97fff87d 	bl	110d290 <crypto_hash_free_ctx>
	state.reseed_ctx = NULL;
 110f0a0:	f900929f 	str	xzr, [x20, #288]
	crypto_cipher_free_ctx(state.ctx);
 110f0a4:	f947c260 	ldr	x0, [x19, #3968]
 110f0a8:	97fff91f 	bl	110d524 <crypto_cipher_free_ctx>
	state.ctx = NULL;
 110f0ac:	f907c27f 	str	xzr, [x19, #3968]
}
 110f0b0:	a94153f3 	ldp	x19, x20, [sp, #16]
 110f0b4:	f94013f5 	ldr	x21, [sp, #32]
 110f0b8:	a8c37bfd 	ldp	x29, x30, [sp], #48
 110f0bc:	d65f03c0 	ret

000000000110f0c0 <inc_counter.constprop.0>:
	counter[0]++;
 110f0c0:	d0000260 	adrp	x0, 115d000 <_curve_names+0x590>
 110f0c4:	913e0000 	add	x0, x0, #0xf80
 110f0c8:	f9400401 	ldr	x1, [x0, #8]
 110f0cc:	91000421 	add	x1, x1, #0x1
 110f0d0:	f9000401 	str	x1, [x0, #8]
	if (!counter[0])
 110f0d4:	b5000081 	cbnz	x1, 110f0e4 <inc_counter.constprop.0+0x24>
		counter[1]++;
 110f0d8:	f9400801 	ldr	x1, [x0, #16]
 110f0dc:	91000421 	add	x1, x1, #0x1
 110f0e0:	f9000801 	str	x1, [x0, #16]
}
 110f0e4:	d65f03c0 	ret

000000000110f0e8 <generate_blocks>:
	}
}

/* GenerateBlocks */
static TEE_Result generate_blocks(void *block, size_t nblocks)
{
 110f0e8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 110f0ec:	910003fd 	mov	x29, sp
 110f0f0:	a90153f3 	stp	x19, x20, [sp, #16]
	uint8_t *b = block;
	size_t n;

	for (n = 0; n < nblocks; n++) {
		TEE_Result res = crypto_cipher_update(state.ctx,
 110f0f4:	d0000274 	adrp	x20, 115d000 <_curve_names+0x590>
 110f0f8:	913e0294 	add	x20, x20, #0xf80
 110f0fc:	aa0003f3 	mov	x19, x0
{
 110f100:	a9025bf5 	stp	x21, x22, [sp, #32]
 110f104:	8b011015 	add	x21, x0, x1, lsl #4
		TEE_Result res = crypto_cipher_update(state.ctx,
 110f108:	91002296 	add	x22, x20, #0x8
	for (n = 0; n < nblocks; n++) {
 110f10c:	eb15027f 	cmp	x19, x21
 110f110:	54000061 	b.ne	110f11c <generate_blocks+0x34>  // b.any
		inc_counter(state.counter);
		if (res)
			return res;
	}

	return TEE_SUCCESS;
 110f114:	52800002 	mov	w2, #0x0                   	// #0
 110f118:	1400000c 	b	110f148 <generate_blocks+0x60>
		TEE_Result res = crypto_cipher_update(state.ctx,
 110f11c:	f9400280 	ldr	x0, [x20]
 110f120:	52800002 	mov	w2, #0x0                   	// #0
 110f124:	aa1303e5 	mov	x5, x19
 110f128:	aa1603e3 	mov	x3, x22
 110f12c:	d2800204 	mov	x4, #0x10                  	// #16
 110f130:	52800001 	mov	w1, #0x0                   	// #0
 110f134:	97fff939 	bl	110d618 <crypto_cipher_update>
 110f138:	2a0003e2 	mov	w2, w0
		inc_counter(state.counter);
 110f13c:	91004273 	add	x19, x19, #0x10
 110f140:	97ffffe0 	bl	110f0c0 <inc_counter.constprop.0>
		if (res)
 110f144:	34fffe42 	cbz	w2, 110f10c <generate_blocks+0x24>
}
 110f148:	2a0203e0 	mov	w0, w2
 110f14c:	a94153f3 	ldp	x19, x20, [sp, #16]
 110f150:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110f154:	a8c37bfd 	ldp	x29, x30, [sp], #48
 110f158:	d65f03c0 	ret

000000000110f15c <drain_ring_buffer>:
{
 110f15c:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
 110f160:	910003fd 	mov	x29, sp
 110f164:	a90153f3 	stp	x19, x20, [sp, #16]
	return __compiler_atomic_load(p);
 110f168:	b00002d3 	adrp	x19, 1168000 <data.5093+0x9e28>
 110f16c:	9128f273 	add	x19, x19, #0xa3c
 110f170:	a9025bf5 	stp	x21, x22, [sp, #32]
 110f174:	9100e275 	add	x21, x19, #0x38
	*snum = ring_buffer.elem[ring_buffer.end].snum;
 110f178:	d28000f4 	mov	x20, #0x7                   	// #7
{
 110f17c:	a9046bf9 	stp	x25, x26, [sp, #64]
	memcpy(data, ring_buffer.elem[ring_buffer.end].data, dlen);
 110f180:	9101a3f9 	add	x25, sp, #0x68
	dlen = MIN(ring_buffer.elem[ring_buffer.end].dlen, RING_BUF_DATA_SIZE);
 110f184:	52800096 	mov	w22, #0x4                   	// #4
{
 110f188:	a90363f7 	stp	x23, x24, [sp, #48]
 110f18c:	f9002bfb 	str	x27, [sp, #80]
 110f190:	b94002a0 	ldr	w0, [x21]
	if (atomic_load_uint(&ring_buffer.begin) == ring_buffer.end)
 110f194:	b9403e61 	ldr	w1, [x19, #60]
 110f198:	6b00003f 	cmp	w1, w0
 110f19c:	540005a0 	b.eq	110f250 <drain_ring_buffer+0xf4>  // b.none
	*snum = ring_buffer.elem[ring_buffer.end].snum;
 110f1a0:	2a0103e0 	mov	w0, w1
	next_end = (ring_buffer.end + 1) % ARRAY_SIZE(ring_buffer.elem);
 110f1a4:	11000438 	add	w24, w1, #0x1
 110f1a8:	12000b18 	and	w24, w24, #0x7
	*snum = ring_buffer.elem[ring_buffer.end].snum;
 110f1ac:	9b147c00 	mul	x0, x0, x20
 110f1b0:	8b000262 	add	x2, x19, x0
 110f1b4:	38606a7a 	ldrb	w26, [x19, x0]
	dlen = MIN(ring_buffer.elem[ring_buffer.end].dlen, RING_BUF_DATA_SIZE);
 110f1b8:	39400840 	ldrb	w0, [x2, #2]
	*pnum = ring_buffer.elem[ring_buffer.end].pnum;
 110f1bc:	3940045b 	ldrb	w27, [x2, #1]
	dlen = MIN(ring_buffer.elem[ring_buffer.end].dlen, RING_BUF_DATA_SIZE);
 110f1c0:	7100101f 	cmp	w0, #0x4
 110f1c4:	1a969002 	csel	w2, w0, w22, ls  // ls = plast
 110f1c8:	2a0203f7 	mov	w23, w2
	assert(ring_buffer.elem[ring_buffer.end].dlen == dlen);
 110f1cc:	6b00005f 	cmp	w2, w0
 110f1d0:	54000140 	b.eq	110f1f8 <drain_ring_buffer+0x9c>  // b.none
 110f1d4:	90000223 	adrp	x3, 1153000 <__func__.3477+0x91>
 110f1d8:	90000221 	adrp	x1, 1153000 <__func__.3477+0x91>
 110f1dc:	9132ac63 	add	x3, x3, #0xcab
 110f1e0:	9130a821 	add	x1, x1, #0xc2a
 110f1e4:	90000220 	adrp	x0, 1153000 <__func__.3477+0x91>
 110f1e8:	91311000 	add	x0, x0, #0xc44
 110f1ec:	52801ac2 	mov	w2, #0xd6                  	// #214
 110f1f0:	94000c2f 	bl	11122ac <_assert_log>
 110f1f4:	94000c3f 	bl	11122f0 <_assert_break>
	memcpy(data, ring_buffer.elem[ring_buffer.end].data, dlen);
 110f1f8:	d2800060 	mov	x0, #0x3                   	// #3
 110f1fc:	aa1703e2 	mov	x2, x23
 110f200:	9bb40021 	umaddl	x1, w1, w20, x0
 110f204:	aa1903e0 	mov	x0, x25
 110f208:	8b010261 	add	x1, x19, x1
 110f20c:	97ffd061 	bl	1103390 <memcpy>
	__compiler_atomic_store(p, val);
 110f210:	9100f260 	add	x0, x19, #0x3c
 110f214:	b9000018 	str	w24, [x0]
		if (!dlen)
 110f218:	b40001d7 	cbz	x23, 110f250 <drain_ring_buffer+0xf4>
		res = add_event(snum, pnum, data, dlen);
 110f21c:	aa1703e3 	mov	x3, x23
 110f220:	aa1903e2 	mov	x2, x25
 110f224:	2a1b03e1 	mov	w1, w27
 110f228:	2a1a03e0 	mov	w0, w26
 110f22c:	97ffff64 	bl	110efbc <add_event>
		if (res)
 110f230:	34fffb00 	cbz	w0, 110f190 <drain_ring_buffer+0x34>
}
 110f234:	a94153f3 	ldp	x19, x20, [sp, #16]
 110f238:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110f23c:	a94363f7 	ldp	x23, x24, [sp, #48]
 110f240:	a9446bf9 	ldp	x25, x26, [sp, #64]
 110f244:	f9402bfb 	ldr	x27, [sp, #80]
 110f248:	a8c77bfd 	ldp	x29, x30, [sp], #112
 110f24c:	d65f03c0 	ret
			return TEE_SUCCESS;
 110f250:	52800000 	mov	w0, #0x0                   	// #0
 110f254:	17fffff8 	b	110f234 <drain_ring_buffer+0xd8>

000000000110f258 <crypto_rng_init>:
{
 110f258:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
 110f25c:	910003fd 	mov	x29, sp
 110f260:	a90153f3 	stp	x19, x20, [sp, #16]
	if (state.ctx)
 110f264:	d0000274 	adrp	x20, 115d000 <_curve_names+0x590>
{
 110f268:	a90363f7 	stp	x23, x24, [sp, #48]
 110f26c:	aa0003f7 	mov	x23, x0
	if (state.ctx)
 110f270:	f947c280 	ldr	x0, [x20, #3968]
{
 110f274:	a9025bf5 	stp	x21, x22, [sp, #32]
 110f278:	f90023f9 	str	x25, [sp, #64]
	if (state.ctx)
 110f27c:	b50009c0 	cbnz	x0, 110f3b4 <crypto_rng_init+0x15c>
 110f280:	913e0296 	add	x22, x20, #0xf80
		res = crypto_hash_alloc_ctx(&state.pool_ctx[n], HASH_ALGO);
 110f284:	52800099 	mov	w25, #0x4                   	// #4
	memset(&state, 0, sizeof(state));
 110f288:	aa1603e0 	mov	x0, x22
 110f28c:	910082d6 	add	x22, x22, #0x20
	for (n = 0; n < NUM_POOLS; n++) {
 110f290:	d2800015 	mov	x21, #0x0                   	// #0
		res = crypto_hash_alloc_ctx(&state.pool_ctx[n], HASH_ALGO);
 110f294:	72aa0019 	movk	w25, #0x5000, lsl #16
 110f298:	aa0103f8 	mov	x24, x1
	memset(&state, 0, sizeof(state));
 110f29c:	d2802702 	mov	x2, #0x138                 	// #312
 110f2a0:	52800001 	mov	w1, #0x0                   	// #0
 110f2a4:	9400d28f 	bl	1143ce0 <memset>
		res = crypto_hash_alloc_ctx(&state.pool_ctx[n], HASH_ALGO);
 110f2a8:	2a1903e1 	mov	w1, w25
 110f2ac:	aa1603e0 	mov	x0, x22
 110f2b0:	97fff7d3 	bl	110d1fc <crypto_hash_alloc_ctx>
 110f2b4:	2a0003f3 	mov	w19, w0
		if (res)
 110f2b8:	350007a0 	cbnz	w0, 110f3ac <crypto_rng_init+0x154>
		res = crypto_hash_init(state.pool_ctx[n]);
 110f2bc:	f94002c0 	ldr	x0, [x22]
 110f2c0:	97fff80e 	bl	110d2f8 <crypto_hash_init>
 110f2c4:	2a0003f3 	mov	w19, w0
		if (res)
 110f2c8:	35000720 	cbnz	w0, 110f3ac <crypto_rng_init+0x154>
	for (n = 0; n < NUM_POOLS; n++) {
 110f2cc:	910006b5 	add	x21, x21, #0x1
 110f2d0:	910022d6 	add	x22, x22, #0x8
 110f2d4:	f10082bf 	cmp	x21, #0x20
 110f2d8:	54fffe81 	b.ne	110f2a8 <crypto_rng_init+0x50>  // b.any
	res = crypto_hash_alloc_ctx(&state.reseed_ctx, HASH_ALGO);
 110f2dc:	913e0296 	add	x22, x20, #0xf80
 110f2e0:	52800081 	mov	w1, #0x4                   	// #4
 110f2e4:	910482c0 	add	x0, x22, #0x120
 110f2e8:	72aa0001 	movk	w1, #0x5000, lsl #16
 110f2ec:	97fff7c4 	bl	110d1fc <crypto_hash_alloc_ctx>
 110f2f0:	2a0003f3 	mov	w19, w0
	if (res)
 110f2f4:	350005c0 	cbnz	w0, 110f3ac <crypto_rng_init+0x154>
	res = key_from_data(state.reseed_ctx, data, dlen, key);
 110f2f8:	f94092d6 	ldr	x22, [x22, #288]
	return crypto_hash_init(ctx);
 110f2fc:	aa1603e0 	mov	x0, x22
 110f300:	97fff7fe 	bl	110d2f8 <crypto_hash_init>
 110f304:	2a0003f3 	mov	w19, w0
	if (res)
 110f308:	35000440 	cbnz	w0, 110f390 <crypto_rng_init+0x138>
	return crypto_hash_update(ctx, data, dlen);
 110f30c:	aa1803e2 	mov	x2, x24
 110f310:	aa1703e1 	mov	x1, x23
 110f314:	aa1603e0 	mov	x0, x22
 110f318:	97fff803 	bl	110d324 <crypto_hash_update>
 110f31c:	2a0003f3 	mov	w19, w0
	if (res)
 110f320:	35000380 	cbnz	w0, 110f390 <crypto_rng_init+0x138>
	return crypto_hash_final(ctx, digest, KEY_SIZE);
 110f324:	910183f7 	add	x23, sp, #0x60
 110f328:	aa1503e2 	mov	x2, x21
 110f32c:	aa1703e1 	mov	x1, x23
 110f330:	aa1603e0 	mov	x0, x22
 110f334:	97fff80d 	bl	110d368 <crypto_hash_final>
 110f338:	2a0003f3 	mov	w19, w0
	if (res)
 110f33c:	350002a0 	cbnz	w0, 110f390 <crypto_rng_init+0x138>
	res = crypto_cipher_alloc_ctx(&ctx, CIPHER_ALGO);
 110f340:	52800201 	mov	w1, #0x10                  	// #16
 110f344:	910163e0 	add	x0, sp, #0x58
 110f348:	72a20001 	movk	w1, #0x1000, lsl #16
 110f34c:	97fff818 	bl	110d3ac <crypto_cipher_alloc_ctx>
 110f350:	2a0003f3 	mov	w19, w0
	if (res)
 110f354:	350001e0 	cbnz	w0, 110f390 <crypto_rng_init+0x138>
	return crypto_cipher_init(ctx, TEE_MODE_ENCRYPT,
 110f358:	f9402fe0 	ldr	x0, [sp, #88]
 110f35c:	aa1503e3 	mov	x3, x21
 110f360:	aa1703e2 	mov	x2, x23
 110f364:	d2800007 	mov	x7, #0x0                   	// #0
 110f368:	d2800006 	mov	x6, #0x0                   	// #0
 110f36c:	d2800005 	mov	x5, #0x0                   	// #0
 110f370:	d2800004 	mov	x4, #0x0                   	// #0
 110f374:	52800001 	mov	w1, #0x0                   	// #0
 110f378:	97fff885 	bl	110d58c <crypto_cipher_init>
 110f37c:	2a0003f3 	mov	w19, w0
	if (res)
 110f380:	35000080 	cbnz	w0, 110f390 <crypto_rng_init+0x138>
	inc_counter(state.counter);
 110f384:	97ffff4f 	bl	110f0c0 <inc_counter.constprop.0>
	state.ctx = ctx;
 110f388:	f9402fe0 	ldr	x0, [sp, #88]
 110f38c:	f907c280 	str	x0, [x20, #3968]
}
 110f390:	2a1303e0 	mov	w0, w19
 110f394:	a94153f3 	ldp	x19, x20, [sp, #16]
 110f398:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110f39c:	a94363f7 	ldp	x23, x24, [sp, #48]
 110f3a0:	f94023f9 	ldr	x25, [sp, #64]
 110f3a4:	a8c87bfd 	ldp	x29, x30, [sp], #128
 110f3a8:	d65f03c0 	ret
	fortuna_done();
 110f3ac:	97ffff2c 	bl	110f05c <fortuna_done>
	return res;
 110f3b0:	17fffff8 	b	110f390 <crypto_rng_init+0x138>
		return TEE_ERROR_BAD_STATE;
 110f3b4:	129fff13 	mov	w19, #0xffff0007            	// #-65529
 110f3b8:	17fffff6 	b	110f390 <crypto_rng_init+0x138>

000000000110f3bc <crypto_rng_add_event>:
{
 110f3bc:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
 110f3c0:	910003fd 	mov	x29, sp
 110f3c4:	a90153f3 	stp	x19, x20, [sp, #16]
 110f3c8:	a9025bf5 	stp	x21, x22, [sp, #32]
 110f3cc:	aa0303f6 	mov	x22, x3
 110f3d0:	a90363f7 	stp	x23, x24, [sp, #48]
 110f3d4:	aa0203f7 	mov	x23, x2
 110f3d8:	a9046bf9 	stp	x25, x26, [sp, #64]
 110f3dc:	f9002bfb 	str	x27, [sp, #80]
	return __compiler_atomic_load(p);
 110f3e0:	b9400022 	ldr	w2, [x1]
		nval = (oval + 1) % NUM_POOLS;
 110f3e4:	11000454 	add	w20, w2, #0x1
 110f3e8:	12001294 	and	w20, w20, #0x1f
	return __compiler_compare_and_swap(p, oval, nval);
 110f3ec:	885ffc23 	ldaxr	w3, [x1]
 110f3f0:	6b02007f 	cmp	w3, w2
 110f3f4:	54000061 	b.ne	110f400 <crypto_rng_add_event+0x44>  // b.any
 110f3f8:	88047c34 	stxr	w4, w20, [x1]
 110f3fc:	7100009f 	cmp	w4, #0x0
 110f400:	2a0303e2 	mov	w2, w3
		if (atomic_cas_uint(pnum, &oval, nval)) {
 110f404:	54ffff01 	b.ne	110f3e4 <crypto_rng_add_event+0x28>  // b.any
			return (nval + NUM_POOLS - 1) % NUM_POOLS;
 110f408:	11007e94 	add	w20, w20, #0x1f
	uint8_t snum = sid >> 1;
 110f40c:	d3412019 	ubfx	x25, x0, #1, #8
	if (CRYPTO_RNG_SRC_IS_QUICK(sid)) {
 110f410:	12001294 	and	w20, w20, #0x1f
 110f414:	36000a80 	tbz	w0, #0, 110f564 <crypto_rng_add_event+0x1a8>
	uint32_t exceptions = thread_mask_exceptions(THREAD_EXCP_ALL);
 110f418:	528000e0 	mov	w0, #0x7                   	// #7
 110f41c:	97ffd747 	bl	1105138 <thread_mask_exceptions>
	unsigned int reminder = 0;
 110f420:	52800015 	mov	w21, #0x0                   	// #0
	uint32_t exceptions = thread_mask_exceptions(THREAD_EXCP_ALL);
 110f424:	2a0003f8 	mov	w24, w0
 110f428:	97ffd6bb 	bl	1104f14 <thread_get_exceptions>
	assert(thread_foreign_intr_disabled());
 110f42c:	36080520 	tbz	w0, #1, 110f4d0 <crypto_rng_add_event+0x114>
	while (__cpu_spin_trylock(lock)) {
 110f430:	f0000240 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
		if (!retries) {
 110f434:	d2c0003b 	mov	x27, #0x100000000           	// #4294967296
	while (__cpu_spin_trylock(lock)) {
 110f438:	f9414413 	ldr	x19, [x0, #648]
	unsigned int reminder = 0;
 110f43c:	d280001a 	mov	x26, #0x0                   	// #0
	while (__cpu_spin_trylock(lock)) {
 110f440:	aa1303e0 	mov	x0, x19
 110f444:	97ffd418 	bl	11044a4 <__cpu_spin_trylock>
 110f448:	35000560 	cbnz	w0, 110f4f4 <crypto_rng_add_event+0x138>
	next_begin = (ring_buffer.begin + 1) % ARRAY_SIZE(ring_buffer.elem);
 110f44c:	b00002d3 	adrp	x19, 1168000 <data.5093+0x9e28>
 110f450:	9128f273 	add	x19, x19, #0xa3c
	spinlock_count_incr();
 110f454:	97ffd41d 	bl	11044c8 <spinlock_count_incr>
	return __compiler_atomic_load(p);
 110f458:	9100f260 	add	x0, x19, #0x3c
 110f45c:	b9403a75 	ldr	w21, [x19, #56]
 110f460:	110006b5 	add	w21, w21, #0x1
 110f464:	12000ab5 	and	w21, w21, #0x7
 110f468:	b9400000 	ldr	w0, [x0]
	if (next_begin == atomic_load_uint(&ring_buffer.end))
 110f46c:	6b0002bf 	cmp	w21, w0
 110f470:	54000240 	b.eq	110f4b8 <crypto_rng_add_event+0xfc>  // b.none
	ring_buffer.elem[next_begin].snum = snum;
 110f474:	2a1503e1 	mov	w1, w21
 110f478:	d28000e0 	mov	x0, #0x7                   	// #7
	uint8_t dl = MIN(RING_BUF_DATA_SIZE, dlen);
 110f47c:	f10012df 	cmp	x22, #0x4
 110f480:	d2800082 	mov	x2, #0x4                   	// #4
 110f484:	9a8292c2 	csel	x2, x22, x2, ls  // ls = plast
	ring_buffer.elem[next_begin].snum = snum;
 110f488:	9b007c21 	mul	x1, x1, x0
 110f48c:	8b010263 	add	x3, x19, x1
 110f490:	38216a79 	strb	w25, [x19, x1]
	memcpy(ring_buffer.elem[next_begin].data, data, dl);
 110f494:	d2800061 	mov	x1, #0x3                   	// #3
	ring_buffer.elem[next_begin].pnum = pnum;
 110f498:	39000474 	strb	w20, [x3, #1]
	memcpy(ring_buffer.elem[next_begin].data, data, dl);
 110f49c:	9ba006a0 	umaddl	x0, w21, w0, x1
	uint8_t dl = MIN(RING_BUF_DATA_SIZE, dlen);
 110f4a0:	39000862 	strb	w2, [x3, #2]
	memcpy(ring_buffer.elem[next_begin].data, data, dl);
 110f4a4:	aa1703e1 	mov	x1, x23
 110f4a8:	8b000260 	add	x0, x19, x0
	__compiler_atomic_store(p, val);
 110f4ac:	9100e273 	add	x19, x19, #0x38
 110f4b0:	97ffcfb8 	bl	1103390 <memcpy>
 110f4b4:	b9000275 	str	w21, [x19]
 110f4b8:	97ffd697 	bl	1104f14 <thread_get_exceptions>
	assert(thread_foreign_intr_disabled());
 110f4bc:	370803c0 	tbnz	w0, #1, 110f534 <crypto_rng_add_event+0x178>
 110f4c0:	90000223 	adrp	x3, 1153000 <__func__.3477+0x91>
 110f4c4:	52800b82 	mov	w2, #0x5c                  	// #92
 110f4c8:	91322863 	add	x3, x3, #0xc8a
 110f4cc:	14000004 	b	110f4dc <crypto_rng_add_event+0x120>
	assert(thread_foreign_intr_disabled());
 110f4d0:	90000223 	adrp	x3, 1153000 <__func__.3477+0x91>
 110f4d4:	9131cc63 	add	x3, x3, #0xc73
 110f4d8:	528006e2 	mov	w2, #0x37                  	// #55
	assert(thread_foreign_intr_disabled());
 110f4dc:	d0000201 	adrp	x1, 1151000 <small_prime+0x168>
 110f4e0:	d0000200 	adrp	x0, 1151000 <small_prime+0x168>
 110f4e4:	9111f821 	add	x1, x1, #0x47e
 110f4e8:	91129800 	add	x0, x0, #0x4a6
 110f4ec:	94000b70 	bl	11122ac <_assert_log>
 110f4f0:	94000b80 	bl	11122f0 <_assert_break>
		if (!retries) {
 110f4f4:	9100075a 	add	x26, x26, #0x1
 110f4f8:	eb1b035f 	cmp	x26, x27
 110f4fc:	54fffa21 	b.ne	110f440 <crypto_rng_add_event+0x84>  // b.any
			trace_printf(func, line, TRACE_ERROR, true,
 110f500:	2a1503e5 	mov	w5, w21
 110f504:	d0000204 	adrp	x4, 1151000 <small_prime+0x168>
 110f508:	52800023 	mov	w3, #0x1                   	// #1
 110f50c:	91131484 	add	x4, x4, #0x4c5
 110f510:	52800022 	mov	w2, #0x1                   	// #1
 110f514:	528016e1 	mov	w1, #0xb7                  	// #183
 110f518:	90000220 	adrp	x0, 1153000 <__func__.3477+0x91>
 110f51c:	91326800 	add	x0, x0, #0xc9a
 110f520:	9400d609 	bl	1144d44 <trace_printf>
			if (reminder < UINT_MAX)
 110f524:	310006bf 	cmn	w21, #0x1
 110f528:	54fff8a0 	b.eq	110f43c <crypto_rng_add_event+0x80>  // b.none
				reminder++;
 110f52c:	110006b5 	add	w21, w21, #0x1
 110f530:	17ffffc3 	b	110f43c <crypto_rng_add_event+0x80>
	__cpu_spin_unlock(lock);
 110f534:	f0000240 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 110f538:	f9414400 	ldr	x0, [x0, #648]
 110f53c:	97ffd3e1 	bl	11044c0 <__cpu_spin_unlock>
	spinlock_count_decr();
 110f540:	97ffd3f4 	bl	1104510 <spinlock_count_decr>
	thread_unmask_exceptions(exceptions);
 110f544:	2a1803e0 	mov	w0, w24
}
 110f548:	a94153f3 	ldp	x19, x20, [sp, #16]
 110f54c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110f550:	a94363f7 	ldp	x23, x24, [sp, #48]
 110f554:	a9446bf9 	ldp	x25, x26, [sp, #64]
 110f558:	f9402bfb 	ldr	x27, [sp, #80]
 110f55c:	a8c67bfd 	ldp	x29, x30, [sp], #96
 110f560:	17ffd703 	b	110516c <thread_unmask_exceptions>
		mutex_lock(&state_mu);
 110f564:	f0000273 	adrp	x19, 115e000 <state+0x80>
 110f568:	9102e273 	add	x19, x19, #0xb8
 110f56c:	aa1303e0 	mov	x0, x19
 110f570:	940017f9 	bl	1115554 <mutex_lock>
		add_event(snum, pn, data, dlen);
 110f574:	aa1603e3 	mov	x3, x22
 110f578:	aa1703e2 	mov	x2, x23
 110f57c:	2a1403e1 	mov	w1, w20
 110f580:	2a1903e0 	mov	w0, w25
 110f584:	97fffe8e 	bl	110efbc <add_event>
		drain_ring_buffer();
 110f588:	97fffef5 	bl	110f15c <drain_ring_buffer>
		mutex_unlock(&state_mu);
 110f58c:	aa1303e0 	mov	x0, x19
}
 110f590:	a94153f3 	ldp	x19, x20, [sp, #16]
 110f594:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110f598:	a94363f7 	ldp	x23, x24, [sp, #48]
 110f59c:	a9446bf9 	ldp	x25, x26, [sp, #64]
 110f5a0:	f9402bfb 	ldr	x27, [sp, #80]
 110f5a4:	a8c67bfd 	ldp	x29, x30, [sp], #96
		mutex_unlock(&state_mu);
 110f5a8:	140017ca 	b	11154d0 <mutex_unlock>

000000000110f5ac <crypto_rng_read>:

	return res;
}

TEE_Result crypto_rng_read(void *buf, size_t blen)
{
 110f5ac:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
 110f5b0:	910003fd 	mov	x29, sp
 110f5b4:	a90153f3 	stp	x19, x20, [sp, #16]
 110f5b8:	a9025bf5 	stp	x21, x22, [sp, #32]
 110f5bc:	9101c3f5 	add	x21, sp, #0x70
 110f5c0:	a90363f7 	stp	x23, x24, [sp, #48]
 110f5c4:	aa0103f8 	mov	x24, x1
	size_t offs = 0;
 110f5c8:	d2800017 	mov	x23, #0x0                   	// #0
{
 110f5cc:	a90573fb 	stp	x27, x28, [sp, #80]
	if (!state.ctx)
 110f5d0:	d000027b 	adrp	x27, 115d000 <_curve_names+0x590>
		crypto_cipher_final(state.ctx);
 110f5d4:	913e0374 	add	x20, x27, #0xf80
{
 110f5d8:	a9046bf9 	stp	x25, x26, [sp, #64]
 110f5dc:	f90033e0 	str	x0, [sp, #96]
	while (true) {
		TEE_Result res;
		size_t n;

		/* Draw at most 1 MiB of random on a single key */
		n = MIN(blen - offs, SIZE_1M);
 110f5e0:	cb170316 	sub	x22, x24, x23
 110f5e4:	d2a00200 	mov	x0, #0x100000              	// #1048576
 110f5e8:	f14402df 	cmp	x22, #0x100, lsl #12
 110f5ec:	9a8092d6 	csel	x22, x22, x0, ls  // ls = plast
		if (!n)
 110f5f0:	eb1802ff 	cmp	x23, x24
 110f5f4:	540011a0 	b.eq	110f828 <crypto_rng_read+0x27c>  // b.none
	if (!state.ctx)
 110f5f8:	f947c360 	ldr	x0, [x27, #3968]
 110f5fc:	913e0373 	add	x19, x27, #0xf80
 110f600:	b4001260 	cbz	x0, 110f84c <crypto_rng_read+0x2a0>
	mutex_lock(&state_mu);
 110f604:	f0000279 	adrp	x25, 115e000 <state+0x80>
 110f608:	9102e320 	add	x0, x25, #0xb8
 110f60c:	940017d2 	bl	1115554 <mutex_lock>
	if (state.pool0_length < MIN_POOL_SIZE)
 110f610:	b9401a60 	ldr	w0, [x19, #24]
 110f614:	7100fc1f 	cmp	w0, #0x3f
 110f618:	54000a09 	b.ls	110f758 <crypto_rng_read+0x1ac>  // b.plast
	res = tee_time_get_sys_time(&time);
 110f61c:	aa1503e0 	mov	x0, x21
 110f620:	97ffd2e4 	bl	11041b0 <tee_time_get_sys_time>
	if (res)
 110f624:	35000280 	cbnz	w0, 110f674 <crypto_rng_read+0xc8>
	if (TEE_TIME_LT(time, state.next_reseed_time))
 110f628:	b9412e61 	ldr	w1, [x19, #300]
 110f62c:	b94073e0 	ldr	w0, [sp, #112]
 110f630:	6b01001f 	cmp	w0, w1
 110f634:	54000081 	b.ne	110f644 <crypto_rng_read+0x98>  // b.any
 110f638:	b9413261 	ldr	w1, [x19, #304]
 110f63c:	b94077e2 	ldr	w2, [sp, #116]
 110f640:	6b01005f 	cmp	w2, w1
 110f644:	1a9f27e1 	cset	w1, cc  // cc = lo, ul, last
 110f648:	35000881 	cbnz	w1, 110f758 <crypto_rng_read+0x1ac>
	TEE_TIME_ADD(time, time_100ms, state.next_reseed_time);
 110f64c:	b94077e1 	ldr	w1, [sp, #116]
 110f650:	b9012e80 	str	w0, [x20, #300]
 110f654:	11019022 	add	w2, w1, #0x64
 110f658:	b9013282 	str	w2, [x20, #304]
 110f65c:	710f9c5f 	cmp	w2, #0x3e7
 110f660:	540000a9 	b.ls	110f674 <crypto_rng_read+0xc8>  // b.plast
 110f664:	11000400 	add	w0, w0, #0x1
 110f668:	510e1021 	sub	w1, w1, #0x384
 110f66c:	b9012e80 	str	w0, [x20, #300]
 110f670:	b9013281 	str	w1, [x20, #304]
	state.reseed_count++;
 110f674:	b9412a80 	ldr	w0, [x20, #296]
 110f678:	11000400 	add	w0, w0, #0x1
 110f67c:	b9012a80 	str	w0, [x20, #296]
	return crypto_hash_init(ctx);
 110f680:	f9409280 	ldr	x0, [x20, #288]
 110f684:	97fff71d 	bl	110d2f8 <crypto_hash_init>
 110f688:	2a0003f3 	mov	w19, w0
	if (res)
 110f68c:	35000b80 	cbnz	w0, 110f7fc <crypto_rng_read+0x250>
	for (n = 0;
 110f690:	d280001c 	mov	x28, #0x0                   	// #0
		res = restart_pool(state.pool_ctx[n], pool_digest);
 110f694:	8b1c0e80 	add	x0, x20, x28, lsl #3
	return crypto_hash_final(ctx, digest, KEY_SIZE);
 110f698:	aa1503e1 	mov	x1, x21
 110f69c:	d2800402 	mov	x2, #0x20                  	// #32
		res = restart_pool(state.pool_ctx[n], pool_digest);
 110f6a0:	f940101a 	ldr	x26, [x0, #32]
	return crypto_hash_final(ctx, digest, KEY_SIZE);
 110f6a4:	aa1a03e0 	mov	x0, x26
 110f6a8:	97fff730 	bl	110d368 <crypto_hash_final>
 110f6ac:	2a0003f3 	mov	w19, w0
	if (res)
 110f6b0:	35000a60 	cbnz	w0, 110f7fc <crypto_rng_read+0x250>
	return crypto_hash_init(ctx);
 110f6b4:	aa1a03e0 	mov	x0, x26
 110f6b8:	97fff710 	bl	110d2f8 <crypto_hash_init>
 110f6bc:	2a0003f3 	mov	w19, w0
	if (res)
 110f6c0:	350009e0 	cbnz	w0, 110f7fc <crypto_rng_read+0x250>
	return crypto_hash_update(ctx, data, dlen);
 110f6c4:	aa1503e1 	mov	x1, x21
 110f6c8:	aa1a03e0 	mov	x0, x26
 110f6cc:	d2800402 	mov	x2, #0x20                  	// #32
 110f6d0:	97fff715 	bl	110d324 <crypto_hash_update>
 110f6d4:	2a0003f3 	mov	w19, w0
		if (res)
 110f6d8:	35000920 	cbnz	w0, 110f7fc <crypto_rng_read+0x250>
		if (!n)
 110f6dc:	b500005c 	cbnz	x28, 110f6e4 <crypto_rng_read+0x138>
			state.pool0_length = 0;
 110f6e0:	b9001a9f 	str	wzr, [x20, #24]
	return crypto_hash_update(ctx, data, dlen);
 110f6e4:	f9409280 	ldr	x0, [x20, #288]
 110f6e8:	aa1503e1 	mov	x1, x21
 110f6ec:	d2800402 	mov	x2, #0x20                  	// #32
 110f6f0:	97fff70d 	bl	110d324 <crypto_hash_update>
 110f6f4:	2a0003f3 	mov	w19, w0
		if (res)
 110f6f8:	35000820 	cbnz	w0, 110f7fc <crypto_rng_read+0x250>
	     n < NUM_POOLS && reseed_from_pool(state.reseed_count, n); n++) {
 110f6fc:	9100079c 	add	x28, x28, #0x1
	for (n = 0;
 110f700:	f100839f 	cmp	x28, #0x20
 110f704:	54000881 	b.ne	110f814 <crypto_rng_read+0x268>  // b.any
	return crypto_hash_final(ctx, digest, KEY_SIZE);
 110f708:	f9409280 	ldr	x0, [x20, #288]
 110f70c:	aa1503e1 	mov	x1, x21
 110f710:	d2800402 	mov	x2, #0x20                  	// #32
 110f714:	97fff715 	bl	110d368 <crypto_hash_final>
 110f718:	2a0003f3 	mov	w19, w0
	if (res)
 110f71c:	35000700 	cbnz	w0, 110f7fc <crypto_rng_read+0x250>
	crypto_cipher_final(state.ctx);
 110f720:	f9400280 	ldr	x0, [x20]
 110f724:	97fff7d4 	bl	110d674 <crypto_cipher_final>
	res = crypto_cipher_init(state.ctx, TEE_MODE_ENCRYPT,
 110f728:	f9400280 	ldr	x0, [x20]
 110f72c:	aa1503e2 	mov	x2, x21
 110f730:	d2800007 	mov	x7, #0x0                   	// #0
 110f734:	d2800006 	mov	x6, #0x0                   	// #0
 110f738:	d2800005 	mov	x5, #0x0                   	// #0
 110f73c:	d2800004 	mov	x4, #0x0                   	// #0
 110f740:	d2800403 	mov	x3, #0x20                  	// #32
 110f744:	52800001 	mov	w1, #0x0                   	// #0
 110f748:	97fff791 	bl	110d58c <crypto_cipher_init>
 110f74c:	2a0003f3 	mov	w19, w0
	if (res)
 110f750:	35000560 	cbnz	w0, 110f7fc <crypto_rng_read+0x250>
	inc_counter(state.counter);
 110f754:	97fffe5b 	bl	110f0c0 <inc_counter.constprop.0>
			return TEE_SUCCESS;
		res = fortuna_read((uint8_t *)buf + offs, n);
 110f758:	f94033e0 	ldr	x0, [sp, #96]
	res = generate_blocks(buf, blen / BLOCK_SIZE);
 110f75c:	d344fec1 	lsr	x1, x22, #4
		res = fortuna_read((uint8_t *)buf + offs, n);
 110f760:	8b17001c 	add	x28, x0, x23
	res = generate_blocks(buf, blen / BLOCK_SIZE);
 110f764:	aa1c03e0 	mov	x0, x28
 110f768:	97fffe60 	bl	110f0e8 <generate_blocks>
 110f76c:	2a0003f3 	mov	w19, w0
	if (res)
 110f770:	35000460 	cbnz	w0, 110f7fc <crypto_rng_read+0x250>
	if (blen % BLOCK_SIZE) {
 110f774:	f2400ec2 	ands	x2, x22, #0xf
 110f778:	54000180 	b.eq	110f7a8 <crypto_rng_read+0x1fc>  // b.none
		res = generate_blocks(block, 1);
 110f77c:	aa1503e0 	mov	x0, x21
 110f780:	d2800021 	mov	x1, #0x1                   	// #1
 110f784:	f90037e2 	str	x2, [sp, #104]
 110f788:	97fffe58 	bl	110f0e8 <generate_blocks>
 110f78c:	2a0003f3 	mov	w19, w0
		if (res)
 110f790:	35000360 	cbnz	w0, 110f7fc <crypto_rng_read+0x250>
		memcpy(b, block, blen % BLOCK_SIZE);
 110f794:	f94037e2 	ldr	x2, [sp, #104]
		uint8_t *b = (uint8_t *)buf + ROUNDDOWN(blen, BLOCK_SIZE);
 110f798:	927ceec0 	and	x0, x22, #0xfffffffffffffff0
		memcpy(b, block, blen % BLOCK_SIZE);
 110f79c:	aa1503e1 	mov	x1, x21
 110f7a0:	8b000380 	add	x0, x28, x0
 110f7a4:	97ffcefb 	bl	1103390 <memcpy>
		res = generate_blocks(new_key, KEY_SIZE / BLOCK_SIZE);
 110f7a8:	aa1503e0 	mov	x0, x21
 110f7ac:	d2800041 	mov	x1, #0x2                   	// #2
 110f7b0:	97fffe4e 	bl	110f0e8 <generate_blocks>
 110f7b4:	2a0003f3 	mov	w19, w0
		if (res)
 110f7b8:	35000220 	cbnz	w0, 110f7fc <crypto_rng_read+0x250>
		crypto_cipher_final(state.ctx);
 110f7bc:	f9400280 	ldr	x0, [x20]
 110f7c0:	97fff7ad 	bl	110d674 <crypto_cipher_final>
	return crypto_cipher_init(ctx, TEE_MODE_ENCRYPT,
 110f7c4:	f9400280 	ldr	x0, [x20]
 110f7c8:	aa1503e2 	mov	x2, x21
 110f7cc:	d2800007 	mov	x7, #0x0                   	// #0
 110f7d0:	d2800006 	mov	x6, #0x0                   	// #0
 110f7d4:	d2800005 	mov	x5, #0x0                   	// #0
 110f7d8:	d2800004 	mov	x4, #0x0                   	// #0
 110f7dc:	d2800403 	mov	x3, #0x20                  	// #32
 110f7e0:	52800001 	mov	w1, #0x0                   	// #0
 110f7e4:	97fff76a 	bl	110d58c <crypto_cipher_init>
 110f7e8:	2a0003f3 	mov	w19, w0
		if (res)
 110f7ec:	35000080 	cbnz	w0, 110f7fc <crypto_rng_read+0x250>
	res = drain_ring_buffer();
 110f7f0:	97fffe5b 	bl	110f15c <drain_ring_buffer>
 110f7f4:	2a0003f3 	mov	w19, w0
	if (res)
 110f7f8:	34000040 	cbz	w0, 110f800 <crypto_rng_read+0x254>
		fortuna_done();
 110f7fc:	97fffe18 	bl	110f05c <fortuna_done>
	mutex_unlock(&state_mu);
 110f800:	9102e320 	add	x0, x25, #0xb8
 110f804:	94001733 	bl	11154d0 <mutex_unlock>
		if (res)
 110f808:	35000133 	cbnz	w19, 110f82c <crypto_rng_read+0x280>
			return res;
		offs += n;
 110f80c:	8b1602f7 	add	x23, x23, x22
	while (true) {
 110f810:	17ffff74 	b	110f5e0 <crypto_rng_read+0x34>
	return !pool_num || !((reseed_count >> (pool_num - 1)) & 1);
 110f814:	b9412a81 	ldr	w1, [x20, #296]
 110f818:	51000780 	sub	w0, w28, #0x1
 110f81c:	1ac02420 	lsr	w0, w1, w0
	     n < NUM_POOLS && reseed_from_pool(state.reseed_count, n); n++) {
 110f820:	3607f3a0 	tbz	w0, #0, 110f694 <crypto_rng_read+0xe8>
 110f824:	17ffffb9 	b	110f708 <crypto_rng_read+0x15c>
			return TEE_SUCCESS;
 110f828:	52800013 	mov	w19, #0x0                   	// #0
	}
}
 110f82c:	2a1303e0 	mov	w0, w19
 110f830:	a94153f3 	ldp	x19, x20, [sp, #16]
 110f834:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110f838:	a94363f7 	ldp	x23, x24, [sp, #48]
 110f83c:	a9446bf9 	ldp	x25, x26, [sp, #64]
 110f840:	a94573fb 	ldp	x27, x28, [sp, #80]
 110f844:	a8c97bfd 	ldp	x29, x30, [sp], #144
 110f848:	d65f03c0 	ret
		return TEE_ERROR_BAD_STATE;
 110f84c:	129fff13 	mov	w19, #0xffff0007            	// #-65529
 110f850:	17fffff7 	b	110f82c <crypto_rng_read+0x280>

000000000110f854 <crypto_cbc_mac_alloc_ctx>:
	.copy_state = crypto_cbc_mac_copy_state,
};

static TEE_Result crypto_cbc_mac_alloc_ctx(struct crypto_mac_ctx **ctx_ret,
					   uint32_t cbc_algo, bool pkcs5_pad)
{
 110f854:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 110f858:	910003fd 	mov	x29, sp
 110f85c:	a90153f3 	stp	x19, x20, [sp, #16]
 110f860:	2a0103f4 	mov	w20, w1
	TEE_Result res;
	void *cbc_ctx = NULL;
	struct crypto_cbc_mac_ctx *ctx = NULL;
	size_t block_size = 0;

	res = crypto_cipher_get_block_size(cbc_algo, &block_size);
 110f864:	9100e3e1 	add	x1, sp, #0x38
{
 110f868:	a9025bf5 	stp	x21, x22, [sp, #32]
 110f86c:	aa0003f5 	mov	x21, x0
 110f870:	12001c56 	and	w22, w2, #0xff
	res = crypto_cipher_get_block_size(cbc_algo, &block_size);
 110f874:	2a1403e0 	mov	w0, w20
	size_t block_size = 0;
 110f878:	a9037fff 	stp	xzr, xzr, [sp, #48]
	res = crypto_cipher_get_block_size(cbc_algo, &block_size);
 110f87c:	97fff789 	bl	110d6a0 <crypto_cipher_get_block_size>
 110f880:	2a0003f3 	mov	w19, w0
	if (res)
 110f884:	350001c0 	cbnz	w0, 110f8bc <crypto_cbc_mac_alloc_ctx+0x68>
		return res;

	res = crypto_cipher_alloc_ctx(&cbc_ctx, cbc_algo);
 110f888:	2a1403e1 	mov	w1, w20
 110f88c:	9100c3e0 	add	x0, sp, #0x30
 110f890:	97fff6c7 	bl	110d3ac <crypto_cipher_alloc_ctx>
 110f894:	2a0003f3 	mov	w19, w0
	if (res)
 110f898:	35000120 	cbnz	w0, 110f8bc <crypto_cbc_mac_alloc_ctx+0x68>
		return res;

	ctx = calloc(1, sizeof(*ctx));
 110f89c:	d2800701 	mov	x1, #0x38                  	// #56
 110f8a0:	d2800020 	mov	x0, #0x1                   	// #1
 110f8a4:	9400cf0b 	bl	11434d0 <calloc>
 110f8a8:	aa0003e2 	mov	x2, x0
	if (!ctx) {
 110f8ac:	f9401be0 	ldr	x0, [sp, #48]
 110f8b0:	b5000102 	cbnz	x2, 110f8d0 <crypto_cbc_mac_alloc_ctx+0x7c>
		crypto_cipher_free_ctx(cbc_ctx);
		return TEE_ERROR_OUT_OF_MEMORY;
 110f8b4:	129ffe73 	mov	w19, #0xffff000c            	// #-65524
		crypto_cipher_free_ctx(cbc_ctx);
 110f8b8:	97fff71b 	bl	110d524 <crypto_cipher_free_ctx>
	ctx->block_len = block_size;
	ctx->ctx.ops = &crypto_cbc_mac_ops;
	*ctx_ret = &ctx->ctx;

	return TEE_SUCCESS;
}
 110f8bc:	2a1303e0 	mov	w0, w19
 110f8c0:	a94153f3 	ldp	x19, x20, [sp, #16]
 110f8c4:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110f8c8:	a8c47bfd 	ldp	x29, x30, [sp], #64
 110f8cc:	d65f03c0 	ret
	ctx->cbc_ctx = cbc_ctx;
 110f8d0:	f9000440 	str	x0, [x2, #8]
	ctx->block_len = block_size;
 110f8d4:	f9401fe0 	ldr	x0, [sp, #56]
	*ctx_ret = &ctx->ctx;
 110f8d8:	f90002a2 	str	x2, [x21]
	ctx->cbc_algo = cbc_algo;
 110f8dc:	b9001054 	str	w20, [x2, #16]
	ctx->block_len = block_size;
 110f8e0:	3900d440 	strb	w0, [x2, #53]
	ctx->ctx.ops = &crypto_cbc_mac_ops;
 110f8e4:	90000260 	adrp	x0, 115b000 <__vcore_unpg_rw_start>
 110f8e8:	9119a000 	add	x0, x0, #0x668
 110f8ec:	f9000040 	str	x0, [x2]
	ctx->pkcs5_pad = pkcs5_pad;
 110f8f0:	3900dc56 	strb	w22, [x2, #55]
	return TEE_SUCCESS;
 110f8f4:	17fffff2 	b	110f8bc <crypto_cbc_mac_alloc_ctx+0x68>

000000000110f8f8 <to_cbc_mac_ctx>:
	assert(ctx && ctx->ops == &crypto_cbc_mac_ops);
 110f8f8:	b40000c0 	cbz	x0, 110f910 <to_cbc_mac_ctx+0x18>
 110f8fc:	f9400002 	ldr	x2, [x0]
 110f900:	90000261 	adrp	x1, 115b000 <__vcore_unpg_rw_start>
 110f904:	9119a021 	add	x1, x1, #0x668
 110f908:	eb01005f 	cmp	x2, x1
 110f90c:	54000180 	b.eq	110f93c <to_cbc_mac_ctx+0x44>  // b.none
 110f910:	90000223 	adrp	x3, 1153000 <__func__.3477+0x91>
 110f914:	90000221 	adrp	x1, 1153000 <__func__.3477+0x91>
 110f918:	91361463 	add	x3, x3, #0xd85
 110f91c:	9132ec21 	add	x1, x1, #0xcbb
 110f920:	90000220 	adrp	x0, 1153000 <__func__.3477+0x91>
 110f924:	91334400 	add	x0, x0, #0xcd1
{
 110f928:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	assert(ctx && ctx->ops == &crypto_cbc_mac_ops);
 110f92c:	528004a2 	mov	w2, #0x25                  	// #37
{
 110f930:	910003fd 	mov	x29, sp
	assert(ctx && ctx->ops == &crypto_cbc_mac_ops);
 110f934:	94000a5e 	bl	11122ac <_assert_log>
 110f938:	94000a6e 	bl	11122f0 <_assert_break>
}
 110f93c:	d65f03c0 	ret

000000000110f940 <crypto_cbc_mac_copy_state>:
{
 110f940:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 110f944:	910003fd 	mov	x29, sp
 110f948:	a90153f3 	stp	x19, x20, [sp, #16]
 110f94c:	aa0103f4 	mov	x20, x1
	struct crypto_cbc_mac_ctx *dst = to_cbc_mac_ctx(dst_ctx);
 110f950:	97ffffea 	bl	110f8f8 <to_cbc_mac_ctx>
 110f954:	aa0003f3 	mov	x19, x0
	struct crypto_cbc_mac_ctx *src = to_cbc_mac_ctx(src_ctx);
 110f958:	aa1403e0 	mov	x0, x20
 110f95c:	97ffffe7 	bl	110f8f8 <to_cbc_mac_ctx>
 110f960:	aa0003f4 	mov	x20, x0
	assert(dst->block_len == src->block_len);
 110f964:	3940d400 	ldrb	w0, [x0, #53]
 110f968:	3940d661 	ldrb	w1, [x19, #53]
 110f96c:	6b00003f 	cmp	w1, w0
 110f970:	54000140 	b.eq	110f998 <crypto_cbc_mac_copy_state+0x58>  // b.none
 110f974:	90000223 	adrp	x3, 1153000 <__func__.3477+0x91>
 110f978:	90000221 	adrp	x1, 1153000 <__func__.3477+0x91>
 110f97c:	90000220 	adrp	x0, 1153000 <__func__.3477+0x91>
 110f980:	9136a863 	add	x3, x3, #0xdaa
 110f984:	9132ec21 	add	x1, x1, #0xcbb
 110f988:	9133e000 	add	x0, x0, #0xcf8
 110f98c:	528011a2 	mov	w2, #0x8d                  	// #141
	assert(dst->pkcs5_pad == src->pkcs5_pad);
 110f990:	94000a47 	bl	11122ac <_assert_log>
 110f994:	94000a57 	bl	11122f0 <_assert_break>
 110f998:	3940de61 	ldrb	w1, [x19, #55]
 110f99c:	3940de80 	ldrb	w0, [x20, #55]
 110f9a0:	6b00003f 	cmp	w1, w0
 110f9a4:	54000120 	b.eq	110f9c8 <crypto_cbc_mac_copy_state+0x88>  // b.none
 110f9a8:	90000223 	adrp	x3, 1153000 <__func__.3477+0x91>
 110f9ac:	90000221 	adrp	x1, 1153000 <__func__.3477+0x91>
 110f9b0:	90000220 	adrp	x0, 1153000 <__func__.3477+0x91>
 110f9b4:	9136a863 	add	x3, x3, #0xdaa
 110f9b8:	9132ec21 	add	x1, x1, #0xcbb
 110f9bc:	91346400 	add	x0, x0, #0xd19
 110f9c0:	528011c2 	mov	w2, #0x8e                  	// #142
 110f9c4:	17fffff3 	b	110f990 <crypto_cbc_mac_copy_state+0x50>
	assert(dst->cbc_algo == src->cbc_algo);
 110f9c8:	b9401261 	ldr	w1, [x19, #16]
 110f9cc:	b9401280 	ldr	w0, [x20, #16]
 110f9d0:	6b00003f 	cmp	w1, w0
 110f9d4:	54000120 	b.eq	110f9f8 <crypto_cbc_mac_copy_state+0xb8>  // b.none
 110f9d8:	90000223 	adrp	x3, 1153000 <__func__.3477+0x91>
 110f9dc:	90000221 	adrp	x1, 1153000 <__func__.3477+0x91>
 110f9e0:	90000220 	adrp	x0, 1153000 <__func__.3477+0x91>
 110f9e4:	9136a863 	add	x3, x3, #0xdaa
 110f9e8:	9132ec21 	add	x1, x1, #0xcbb
 110f9ec:	9134e800 	add	x0, x0, #0xd3a
 110f9f0:	528011e2 	mov	w2, #0x8f                  	// #143
 110f9f4:	17ffffe7 	b	110f990 <crypto_cbc_mac_copy_state+0x50>
	crypto_cipher_copy_state(dst->cbc_ctx, src->cbc_ctx);
 110f9f8:	f9400660 	ldr	x0, [x19, #8]
 110f9fc:	f9400681 	ldr	x1, [x20, #8]
 110fa00:	97fff6d6 	bl	110d558 <crypto_cipher_copy_state>
	memcpy(dst->block, src->block, sizeof(dst->block));
 110fa04:	91005281 	add	x1, x20, #0x14
 110fa08:	91005260 	add	x0, x19, #0x14
 110fa0c:	d2800202 	mov	x2, #0x10                  	// #16
 110fa10:	97ffce60 	bl	1103390 <memcpy>
	memcpy(dst->digest, src->digest, sizeof(dst->digest));
 110fa14:	91009281 	add	x1, x20, #0x24
 110fa18:	91009260 	add	x0, x19, #0x24
 110fa1c:	d2800202 	mov	x2, #0x10                  	// #16
 110fa20:	97ffce5c 	bl	1103390 <memcpy>
	dst->current_block_len = src->current_block_len;
 110fa24:	3940d280 	ldrb	w0, [x20, #52]
 110fa28:	3900d260 	strb	w0, [x19, #52]
	dst->is_computed = src->is_computed;
 110fa2c:	3940da80 	ldrb	w0, [x20, #54]
 110fa30:	3900da60 	strb	w0, [x19, #54]
}
 110fa34:	a94153f3 	ldp	x19, x20, [sp, #16]
 110fa38:	a8c27bfd 	ldp	x29, x30, [sp], #32
 110fa3c:	d65f03c0 	ret

000000000110fa40 <crypto_cbc_mac_free_ctx>:
{
 110fa40:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 110fa44:	910003fd 	mov	x29, sp
 110fa48:	f9000bf3 	str	x19, [sp, #16]
	struct crypto_cbc_mac_ctx *mc = to_cbc_mac_ctx(ctx);
 110fa4c:	97ffffab 	bl	110f8f8 <to_cbc_mac_ctx>
 110fa50:	aa0003f3 	mov	x19, x0
	crypto_cipher_free_ctx(mc->cbc_ctx);
 110fa54:	f9400400 	ldr	x0, [x0, #8]
 110fa58:	97fff6b3 	bl	110d524 <crypto_cipher_free_ctx>
	free(mc);
 110fa5c:	aa1303e0 	mov	x0, x19
}
 110fa60:	f9400bf3 	ldr	x19, [sp, #16]
 110fa64:	a8c27bfd 	ldp	x29, x30, [sp], #32
	free(mc);
 110fa68:	1400cede 	b	11435e0 <free>

000000000110fa6c <crypto_cbc_mac_update>:
{
 110fa6c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 110fa70:	910003fd 	mov	x29, sp
 110fa74:	a90153f3 	stp	x19, x20, [sp, #16]
 110fa78:	aa0203f4 	mov	x20, x2
 110fa7c:	a9025bf5 	stp	x21, x22, [sp, #32]
 110fa80:	aa0103f5 	mov	x21, x1
 110fa84:	f9001bf7 	str	x23, [sp, #48]
	struct crypto_cbc_mac_ctx *mc = to_cbc_mac_ctx(ctx);
 110fa88:	97ffff9c 	bl	110f8f8 <to_cbc_mac_ctx>
	if ((mc->current_block_len > 0) &&
 110fa8c:	3940d001 	ldrb	w1, [x0, #52]
	struct crypto_cbc_mac_ctx *mc = to_cbc_mac_ctx(ctx);
 110fa90:	aa0003f3 	mov	x19, x0
	if ((mc->current_block_len > 0) &&
 110fa94:	34000361 	cbz	w1, 110fb00 <crypto_cbc_mac_update+0x94>
	    (len + mc->current_block_len >= mc->block_len)) {
 110fa98:	3940d663 	ldrb	w3, [x19, #53]
 110fa9c:	8b210282 	add	x2, x20, w1, uxtb
 110faa0:	3940d676 	ldrb	w22, [x19, #53]
 110faa4:	92401c20 	and	x0, x1, #0xff
	if ((mc->current_block_len > 0) &&
 110faa8:	eb03005f 	cmp	x2, x3
 110faac:	540002a3 	b.cc	110fb00 <crypto_cbc_mac_update+0x94>  // b.lo, b.ul, b.last
		size_t pad_len = mc->block_len - mc->current_block_len;
 110fab0:	4b0102d6 	sub	w22, w22, w1
		memcpy(mc->block + mc->current_block_len, data, pad_len);
 110fab4:	91005277 	add	x23, x19, #0x14
 110fab8:	aa1503e1 	mov	x1, x21
 110fabc:	8b0002e0 	add	x0, x23, x0
		size_t pad_len = mc->block_len - mc->current_block_len;
 110fac0:	93407ed6 	sxtw	x22, w22
		memcpy(mc->block + mc->current_block_len, data, pad_len);
 110fac4:	aa1603e2 	mov	x2, x22
 110fac8:	97ffce32 	bl	1103390 <memcpy>
		res = crypto_cipher_update(mc->cbc_ctx, TEE_MODE_ENCRYPT,
 110facc:	3940d664 	ldrb	w4, [x19, #53]
 110fad0:	91009265 	add	x5, x19, #0x24
 110fad4:	f9400660 	ldr	x0, [x19, #8]
 110fad8:	aa1703e3 	mov	x3, x23
 110fadc:	52800002 	mov	w2, #0x0                   	// #0
 110fae0:	52800001 	mov	w1, #0x0                   	// #0
 110fae4:	97fff6cd 	bl	110d618 <crypto_cipher_update>
		if (res)
 110fae8:	350005c0 	cbnz	w0, 110fba0 <crypto_cbc_mac_update+0x134>
		data += pad_len;
 110faec:	8b1602b5 	add	x21, x21, x22
		len -= pad_len;
 110faf0:	cb160294 	sub	x20, x20, x22
		mc->is_computed = 1;
 110faf4:	52800020 	mov	w0, #0x1                   	// #1
		mc->current_block_len = 0;
 110faf8:	3900d27f 	strb	wzr, [x19, #52]
		mc->is_computed = 1;
 110fafc:	3900da60 	strb	w0, [x19, #54]
					   mc->digest);
 110fb00:	91009276 	add	x22, x19, #0x24
		mc->is_computed = 1;
 110fb04:	52800037 	mov	w23, #0x1                   	// #1
	while (len >= mc->block_len) {
 110fb08:	3940d664 	ldrb	w4, [x19, #53]
 110fb0c:	eb14009f 	cmp	x4, x20
 110fb10:	540001e9 	b.ls	110fb4c <crypto_cbc_mac_update+0xe0>  // b.plast
	if (len > 0) {
 110fb14:	b4000454 	cbz	x20, 110fb9c <crypto_cbc_mac_update+0x130>
		assert(mc->current_block_len + len < mc->block_len);
 110fb18:	3940d260 	ldrb	w0, [x19, #52]
 110fb1c:	8b140001 	add	x1, x0, x20
 110fb20:	eb01009f 	cmp	x4, x1
 110fb24:	540002c8 	b.hi	110fb7c <crypto_cbc_mac_update+0x110>  // b.pmore
 110fb28:	90000223 	adrp	x3, 1153000 <__func__.3477+0x91>
 110fb2c:	90000221 	adrp	x1, 1153000 <__func__.3477+0x91>
 110fb30:	91365063 	add	x3, x3, #0xd94
 110fb34:	9132ec21 	add	x1, x1, #0xcbb
 110fb38:	90000220 	adrp	x0, 1153000 <__func__.3477+0x91>
 110fb3c:	91356400 	add	x0, x0, #0xd59
 110fb40:	52800b62 	mov	w2, #0x5b                  	// #91
 110fb44:	940009da 	bl	11122ac <_assert_log>
 110fb48:	940009ea 	bl	11122f0 <_assert_break>
		res = crypto_cipher_update(mc->cbc_ctx, TEE_MODE_ENCRYPT,
 110fb4c:	f9400660 	ldr	x0, [x19, #8]
 110fb50:	aa1603e5 	mov	x5, x22
 110fb54:	aa1503e3 	mov	x3, x21
 110fb58:	52800002 	mov	w2, #0x0                   	// #0
 110fb5c:	52800001 	mov	w1, #0x0                   	// #0
 110fb60:	97fff6ae 	bl	110d618 <crypto_cipher_update>
		if (res)
 110fb64:	350001e0 	cbnz	w0, 110fba0 <crypto_cbc_mac_update+0x134>
		data += mc->block_len;
 110fb68:	3940d660 	ldrb	w0, [x19, #53]
		mc->is_computed = 1;
 110fb6c:	3900da77 	strb	w23, [x19, #54]
		data += mc->block_len;
 110fb70:	8b0002b5 	add	x21, x21, x0
		len -= mc->block_len;
 110fb74:	cb000294 	sub	x20, x20, x0
 110fb78:	17ffffe4 	b	110fb08 <crypto_cbc_mac_update+0x9c>
		memcpy(mc->block + mc->current_block_len, data, len);
 110fb7c:	91005263 	add	x3, x19, #0x14
 110fb80:	aa1403e2 	mov	x2, x20
 110fb84:	aa1503e1 	mov	x1, x21
 110fb88:	8b000060 	add	x0, x3, x0
 110fb8c:	97ffce01 	bl	1103390 <memcpy>
		mc->current_block_len += len;
 110fb90:	3940d262 	ldrb	w2, [x19, #52]
 110fb94:	0b140054 	add	w20, w2, w20
 110fb98:	3900d274 	strb	w20, [x19, #52]
	return TEE_SUCCESS;
 110fb9c:	52800000 	mov	w0, #0x0                   	// #0
}
 110fba0:	a94153f3 	ldp	x19, x20, [sp, #16]
 110fba4:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110fba8:	f9401bf7 	ldr	x23, [sp, #48]
 110fbac:	a8c47bfd 	ldp	x29, x30, [sp], #64
 110fbb0:	d65f03c0 	ret

000000000110fbb4 <crypto_cbc_mac_final>:
{
 110fbb4:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 110fbb8:	910003fd 	mov	x29, sp
 110fbbc:	a90153f3 	stp	x19, x20, [sp, #16]
 110fbc0:	aa0203f4 	mov	x20, x2
 110fbc4:	a9025bf5 	stp	x21, x22, [sp, #32]
 110fbc8:	aa0103f6 	mov	x22, x1
 110fbcc:	f9001bf7 	str	x23, [sp, #48]
 110fbd0:	aa0003f7 	mov	x23, x0
	struct crypto_cbc_mac_ctx *mc = to_cbc_mac_ctx(ctx);
 110fbd4:	97ffff49 	bl	110f8f8 <to_cbc_mac_ctx>
 110fbd8:	aa0003f3 	mov	x19, x0
	if (mc->pkcs5_pad) {
 110fbdc:	3940dc00 	ldrb	w0, [x0, #55]
 110fbe0:	35000120 	cbnz	w0, 110fc04 <crypto_cbc_mac_final+0x50>
	if (!mc->is_computed || mc->current_block_len)
 110fbe4:	3940da60 	ldrb	w0, [x19, #54]
 110fbe8:	350002a0 	cbnz	w0, 110fc3c <crypto_cbc_mac_final+0x88>
			return TEE_ERROR_BAD_STATE;
 110fbec:	129fff00 	mov	w0, #0xffff0007            	// #-65529
}
 110fbf0:	a94153f3 	ldp	x19, x20, [sp, #16]
 110fbf4:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110fbf8:	f9401bf7 	ldr	x23, [sp, #48]
 110fbfc:	a8c47bfd 	ldp	x29, x30, [sp], #64
 110fc00:	d65f03c0 	ret
		size_t pad_len = mc->block_len - mc->current_block_len;
 110fc04:	3940d260 	ldrb	w0, [x19, #52]
		memset(mc->block + mc->current_block_len, pad_len, pad_len);
 110fc08:	91005275 	add	x21, x19, #0x14
		size_t pad_len = mc->block_len - mc->current_block_len;
 110fc0c:	3940d662 	ldrb	w2, [x19, #53]
 110fc10:	4b000041 	sub	w1, w2, w0
		memset(mc->block + mc->current_block_len, pad_len, pad_len);
 110fc14:	8b2002a0 	add	x0, x21, w0, uxtb
 110fc18:	93407c22 	sxtw	x2, w1
 110fc1c:	9400d031 	bl	1143ce0 <memset>
		if (crypto_cbc_mac_update(ctx, mc->block, mc->block_len))
 110fc20:	3940d662 	ldrb	w2, [x19, #53]
 110fc24:	aa1503e1 	mov	x1, x21
		mc->current_block_len = 0;
 110fc28:	3900d27f 	strb	wzr, [x19, #52]
		if (crypto_cbc_mac_update(ctx, mc->block, mc->block_len))
 110fc2c:	aa1703e0 	mov	x0, x23
 110fc30:	97ffff8f 	bl	110fa6c <crypto_cbc_mac_update>
 110fc34:	34fffd80 	cbz	w0, 110fbe4 <crypto_cbc_mac_final+0x30>
 110fc38:	17ffffed 	b	110fbec <crypto_cbc_mac_final+0x38>
	if (!mc->is_computed || mc->current_block_len)
 110fc3c:	3940d260 	ldrb	w0, [x19, #52]
 110fc40:	35fffd60 	cbnz	w0, 110fbec <crypto_cbc_mac_final+0x38>
	memcpy(digest, mc->digest, MIN(digest_len, mc->block_len));
 110fc44:	3940d662 	ldrb	w2, [x19, #53]
 110fc48:	91009261 	add	x1, x19, #0x24
 110fc4c:	aa1603e0 	mov	x0, x22
 110fc50:	eb14005f 	cmp	x2, x20
 110fc54:	9a949042 	csel	x2, x2, x20, ls  // ls = plast
 110fc58:	97ffcdce 	bl	1103390 <memcpy>
	crypto_cipher_final(mc->cbc_ctx);
 110fc5c:	f9400660 	ldr	x0, [x19, #8]
 110fc60:	97fff685 	bl	110d674 <crypto_cipher_final>
	return TEE_SUCCESS;
 110fc64:	52800000 	mov	w0, #0x0                   	// #0
 110fc68:	17ffffe2 	b	110fbf0 <crypto_cbc_mac_final+0x3c>

000000000110fc6c <crypto_cbc_mac_init>:
{
 110fc6c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 110fc70:	910003fd 	mov	x29, sp
 110fc74:	a90153f3 	stp	x19, x20, [sp, #16]
 110fc78:	aa0103f4 	mov	x20, x1
 110fc7c:	a9025bf5 	stp	x21, x22, [sp, #32]
 110fc80:	aa0203f5 	mov	x21, x2
 110fc84:	f9001bf7 	str	x23, [sp, #48]
	struct crypto_cbc_mac_ctx *mc = to_cbc_mac_ctx(ctx);
 110fc88:	97ffff1c 	bl	110f8f8 <to_cbc_mac_ctx>
 110fc8c:	aa0003f3 	mov	x19, x0
	memset(mc->block, 0, sizeof(mc->block));
 110fc90:	91005016 	add	x22, x0, #0x14
 110fc94:	d2800217 	mov	x23, #0x10                  	// #16
 110fc98:	aa1603e0 	mov	x0, x22
 110fc9c:	aa1703e2 	mov	x2, x23
 110fca0:	52800001 	mov	w1, #0x0                   	// #0
 110fca4:	9400d00f 	bl	1143ce0 <memset>
	memset(mc->digest, 0, sizeof(mc->digest));
 110fca8:	aa1703e2 	mov	x2, x23
 110fcac:	91009260 	add	x0, x19, #0x24
 110fcb0:	52800001 	mov	w1, #0x0                   	// #0
 110fcb4:	9400d00b 	bl	1143ce0 <memset>
	mc->current_block_len = 0;
 110fcb8:	3900d27f 	strb	wzr, [x19, #52]
	return crypto_cipher_init(mc->cbc_ctx, TEE_MODE_ENCRYPT, key, len,
 110fcbc:	aa1603e6 	mov	x6, x22
	mc->is_computed = false;
 110fcc0:	3900da7f 	strb	wzr, [x19, #54]
	return crypto_cipher_init(mc->cbc_ctx, TEE_MODE_ENCRYPT, key, len,
 110fcc4:	aa1503e3 	mov	x3, x21
 110fcc8:	3940d667 	ldrb	w7, [x19, #53]
 110fccc:	aa1403e2 	mov	x2, x20
 110fcd0:	f9400660 	ldr	x0, [x19, #8]
 110fcd4:	d2800005 	mov	x5, #0x0                   	// #0
}
 110fcd8:	a94153f3 	ldp	x19, x20, [sp, #16]
	return crypto_cipher_init(mc->cbc_ctx, TEE_MODE_ENCRYPT, key, len,
 110fcdc:	d2800004 	mov	x4, #0x0                   	// #0
}
 110fce0:	a9425bf5 	ldp	x21, x22, [sp, #32]
	return crypto_cipher_init(mc->cbc_ctx, TEE_MODE_ENCRYPT, key, len,
 110fce4:	52800001 	mov	w1, #0x0                   	// #0
}
 110fce8:	f9401bf7 	ldr	x23, [sp, #48]
 110fcec:	a8c47bfd 	ldp	x29, x30, [sp], #64
	return crypto_cipher_init(mc->cbc_ctx, TEE_MODE_ENCRYPT, key, len,
 110fcf0:	17fff627 	b	110d58c <crypto_cipher_init>

000000000110fcf4 <crypto_aes_cbc_mac_nopad_alloc_ctx>:

TEE_Result crypto_aes_cbc_mac_nopad_alloc_ctx(struct crypto_mac_ctx **ctx)
{
	return crypto_cbc_mac_alloc_ctx(ctx, TEE_ALG_AES_CBC_NOPAD, false);
 110fcf4:	52802201 	mov	w1, #0x110                 	// #272
 110fcf8:	52800002 	mov	w2, #0x0                   	// #0
 110fcfc:	72a20001 	movk	w1, #0x1000, lsl #16
 110fd00:	17fffed5 	b	110f854 <crypto_cbc_mac_alloc_ctx>

000000000110fd04 <crypto_aes_cbc_mac_pkcs5_alloc_ctx>:
}

TEE_Result crypto_aes_cbc_mac_pkcs5_alloc_ctx(struct crypto_mac_ctx **ctx)
{
	return crypto_cbc_mac_alloc_ctx(ctx, TEE_ALG_AES_CBC_NOPAD, true);
 110fd04:	52802201 	mov	w1, #0x110                 	// #272
 110fd08:	52800022 	mov	w2, #0x1                   	// #1
 110fd0c:	72a20001 	movk	w1, #0x1000, lsl #16
 110fd10:	17fffed1 	b	110f854 <crypto_cbc_mac_alloc_ctx>

000000000110fd14 <crypto_des_cbc_mac_nopad_alloc_ctx>:
}

TEE_Result crypto_des_cbc_mac_nopad_alloc_ctx(struct crypto_mac_ctx **ctx)
{
	return crypto_cbc_mac_alloc_ctx(ctx, TEE_ALG_DES_CBC_NOPAD, false);
 110fd14:	52802221 	mov	w1, #0x111                 	// #273
 110fd18:	52800002 	mov	w2, #0x0                   	// #0
 110fd1c:	72a20001 	movk	w1, #0x1000, lsl #16
 110fd20:	17fffecd 	b	110f854 <crypto_cbc_mac_alloc_ctx>

000000000110fd24 <crypto_des_cbc_mac_pkcs5_alloc_ctx>:
}

TEE_Result crypto_des_cbc_mac_pkcs5_alloc_ctx(struct crypto_mac_ctx **ctx)
{
	return crypto_cbc_mac_alloc_ctx(ctx, TEE_ALG_DES_CBC_NOPAD, true);
 110fd24:	52802221 	mov	w1, #0x111                 	// #273
 110fd28:	52800022 	mov	w2, #0x1                   	// #1
 110fd2c:	72a20001 	movk	w1, #0x1000, lsl #16
 110fd30:	17fffec9 	b	110f854 <crypto_cbc_mac_alloc_ctx>

000000000110fd34 <crypto_des3_cbc_mac_nopad_alloc_ctx>:
}

TEE_Result crypto_des3_cbc_mac_nopad_alloc_ctx(struct crypto_mac_ctx **ctx)
{
	return crypto_cbc_mac_alloc_ctx(ctx, TEE_ALG_DES3_CBC_NOPAD, false);
 110fd34:	52802261 	mov	w1, #0x113                 	// #275
 110fd38:	52800002 	mov	w2, #0x0                   	// #0
 110fd3c:	72a20001 	movk	w1, #0x1000, lsl #16
 110fd40:	17fffec5 	b	110f854 <crypto_cbc_mac_alloc_ctx>

000000000110fd44 <crypto_des3_cbc_mac_pkcs5_alloc_ctx>:
}

TEE_Result crypto_des3_cbc_mac_pkcs5_alloc_ctx(struct crypto_mac_ctx **ctx)
{
	return crypto_cbc_mac_alloc_ctx(ctx, TEE_ALG_DES3_CBC_NOPAD, true);
 110fd44:	52802261 	mov	w1, #0x113                 	// #275
 110fd48:	52800022 	mov	w2, #0x1                   	// #1
 110fd4c:	72a20001 	movk	w1, #0x1000, lsl #16
 110fd50:	17fffec1 	b	110f854 <crypto_cbc_mac_alloc_ctx>

000000000110fd54 <to_cts_ctx>:

static const struct crypto_cipher_ops cts_ops;

static struct cts_ctx *to_cts_ctx(struct crypto_cipher_ctx *ctx)
{
	assert(ctx && ctx->ops == &cts_ops);
 110fd54:	b40000c0 	cbz	x0, 110fd6c <to_cts_ctx+0x18>
 110fd58:	f9400002 	ldr	x2, [x0]
 110fd5c:	90000261 	adrp	x1, 115b000 <__vcore_unpg_rw_start>
 110fd60:	911a4021 	add	x1, x1, #0x690
 110fd64:	eb01005f 	cmp	x2, x1
 110fd68:	54000180 	b.eq	110fd98 <to_cts_ctx+0x44>  // b.none
 110fd6c:	90000223 	adrp	x3, 1153000 <__func__.3477+0x91>
 110fd70:	90000221 	adrp	x1, 1153000 <__func__.3477+0x91>
 110fd74:	9137d863 	add	x3, x3, #0xdf6
 110fd78:	91371021 	add	x1, x1, #0xdc4
 110fd7c:	90000220 	adrp	x0, 1153000 <__func__.3477+0x91>
 110fd80:	91376800 	add	x0, x0, #0xdda
{
 110fd84:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	assert(ctx && ctx->ops == &cts_ops);
 110fd88:	52800582 	mov	w2, #0x2c                  	// #44
{
 110fd8c:	910003fd 	mov	x29, sp
	assert(ctx && ctx->ops == &cts_ops);
 110fd90:	94000947 	bl	11122ac <_assert_log>
 110fd94:	94000957 	bl	11122f0 <_assert_break>

	return container_of(ctx, struct cts_ctx, ctx);
}
 110fd98:	d65f03c0 	ret

000000000110fd9c <cts_copy_state>:
	free(c);
}

static void cts_copy_state(struct crypto_cipher_ctx *dst_ctx,
			   struct crypto_cipher_ctx *src_ctx)
{
 110fd9c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 110fda0:	910003fd 	mov	x29, sp
 110fda4:	a90153f3 	stp	x19, x20, [sp, #16]
 110fda8:	aa0003f3 	mov	x19, x0
 110fdac:	aa0103e0 	mov	x0, x1
	struct cts_ctx *src = to_cts_ctx(src_ctx);
 110fdb0:	97ffffe9 	bl	110fd54 <to_cts_ctx>
 110fdb4:	aa0003f4 	mov	x20, x0
	struct cts_ctx *dst = to_cts_ctx(dst_ctx);
 110fdb8:	aa1303e0 	mov	x0, x19
 110fdbc:	97ffffe6 	bl	110fd54 <to_cts_ctx>
 110fdc0:	aa0003f3 	mov	x19, x0

	crypto_cipher_copy_state(dst->cbc, src->cbc);
 110fdc4:	f9400a81 	ldr	x1, [x20, #16]
 110fdc8:	f9400800 	ldr	x0, [x0, #16]
 110fdcc:	97fff5e3 	bl	110d558 <crypto_cipher_copy_state>
	crypto_cipher_copy_state(dst->ecb, src->ecb);
 110fdd0:	f9400660 	ldr	x0, [x19, #8]
 110fdd4:	f9400681 	ldr	x1, [x20, #8]
 110fdd8:	97fff5e0 	bl	110d558 <crypto_cipher_copy_state>
	dst->mode = src->mode;
 110fddc:	b9401a80 	ldr	w0, [x20, #24]
 110fde0:	b9001a60 	str	w0, [x19, #24]
}
 110fde4:	a94153f3 	ldp	x19, x20, [sp, #16]
 110fde8:	a8c27bfd 	ldp	x29, x30, [sp], #32
 110fdec:	d65f03c0 	ret

000000000110fdf0 <cts_free_ctx>:
{
 110fdf0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 110fdf4:	910003fd 	mov	x29, sp
 110fdf8:	f9000bf3 	str	x19, [sp, #16]
	struct cts_ctx *c = to_cts_ctx(ctx);
 110fdfc:	97ffffd6 	bl	110fd54 <to_cts_ctx>
 110fe00:	aa0003f3 	mov	x19, x0
	crypto_cipher_free_ctx(c->cbc);
 110fe04:	f9400800 	ldr	x0, [x0, #16]
 110fe08:	97fff5c7 	bl	110d524 <crypto_cipher_free_ctx>
	crypto_cipher_free_ctx(c->ecb);
 110fe0c:	f9400660 	ldr	x0, [x19, #8]
 110fe10:	97fff5c5 	bl	110d524 <crypto_cipher_free_ctx>
	free(c);
 110fe14:	aa1303e0 	mov	x0, x19
}
 110fe18:	f9400bf3 	ldr	x19, [sp, #16]
 110fe1c:	a8c27bfd 	ldp	x29, x30, [sp], #32
	free(c);
 110fe20:	1400cdf0 	b	11435e0 <free>

000000000110fe24 <cts_final>:
{
 110fe24:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 110fe28:	910003fd 	mov	x29, sp
 110fe2c:	f9000bf3 	str	x19, [sp, #16]
	struct cts_ctx *c = to_cts_ctx(ctx);
 110fe30:	97ffffc9 	bl	110fd54 <to_cts_ctx>
 110fe34:	aa0003f3 	mov	x19, x0
	crypto_cipher_final(c->cbc);
 110fe38:	f9400800 	ldr	x0, [x0, #16]
 110fe3c:	97fff60e 	bl	110d674 <crypto_cipher_final>
	crypto_cipher_final(c->ecb);
 110fe40:	f9400660 	ldr	x0, [x19, #8]
}
 110fe44:	f9400bf3 	ldr	x19, [sp, #16]
 110fe48:	a8c27bfd 	ldp	x29, x30, [sp], #32
	crypto_cipher_final(c->ecb);
 110fe4c:	17fff60a 	b	110d674 <crypto_cipher_final>

000000000110fe50 <cts_update>:
{
 110fe50:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
 110fe54:	910003fd 	mov	x29, sp
 110fe58:	a90153f3 	stp	x19, x20, [sp, #16]
 110fe5c:	12001c33 	and	w19, w1, #0xff
 110fe60:	aa0303f4 	mov	x20, x3
 110fe64:	a9025bf5 	stp	x21, x22, [sp, #32]
 110fe68:	aa0403f5 	mov	x21, x4
 110fe6c:	a90363f7 	stp	x23, x24, [sp, #48]
 110fe70:	a9046bf9 	stp	x25, x26, [sp, #64]
 110fe74:	a90573fb 	stp	x27, x28, [sp, #80]
 110fe78:	aa0203fc 	mov	x28, x2
	struct cts_ctx *c = to_cts_ctx(ctx);
 110fe7c:	97ffffb6 	bl	110fd54 <to_cts_ctx>
	return cbc_cts_update(c->cbc, c->ecb, c->mode, last_block, data, len,
 110fe80:	b940181b 	ldr	w27, [x0, #24]
 110fe84:	f9400817 	ldr	x23, [x0, #16]
 110fe88:	f9400400 	ldr	x0, [x0, #8]
	uint8_t  tmp2_block[64] = { 0 };
 110fe8c:	a9087fff 	stp	xzr, xzr, [sp, #128]
 110fe90:	a9097fff 	stp	xzr, xzr, [sp, #144]
 110fe94:	a90a7fff 	stp	xzr, xzr, [sp, #160]
 110fe98:	a90b7fff 	stp	xzr, xzr, [sp, #176]
	uint8_t tmp_block[64] = { 0 };
 110fe9c:	a90c7fff 	stp	xzr, xzr, [sp, #192]
 110fea0:	a90d7fff 	stp	xzr, xzr, [sp, #208]
 110fea4:	a90e7fff 	stp	xzr, xzr, [sp, #224]
 110fea8:	a90f7fff 	stp	xzr, xzr, [sp, #240]
	if (!last_block)
 110feac:	35000273 	cbnz	w19, 110fef8 <cts_update+0xa8>
		return tee_do_cipher_update(cbc_ctx, TEE_ALG_AES_CBC_NOPAD,
 110feb0:	aa1503e6 	mov	x6, x21
 110feb4:	aa1403e5 	mov	x5, x20
 110feb8:	aa1c03e4 	mov	x4, x28
 110febc:	2a1b03e2 	mov	w2, w27
 110fec0:	52800003 	mov	w3, #0x0                   	// #0
		res = tee_do_cipher_update(cbc_ctx, TEE_ALG_AES_CBC_NOPAD,
 110fec4:	52802201 	mov	w1, #0x110                 	// #272
 110fec8:	aa1703e0 	mov	x0, x23
 110fecc:	72a20001 	movk	w1, #0x1000, lsl #16
 110fed0:	94002eeb 	bl	111ba7c <tee_do_cipher_update>
 110fed4:	2a0003f3 	mov	w19, w0
}
 110fed8:	2a1303e0 	mov	w0, w19
 110fedc:	a94153f3 	ldp	x19, x20, [sp, #16]
 110fee0:	a9425bf5 	ldp	x21, x22, [sp, #32]
 110fee4:	a94363f7 	ldp	x23, x24, [sp, #48]
 110fee8:	a9446bf9 	ldp	x25, x26, [sp, #64]
 110feec:	a94573fb 	ldp	x27, x28, [sp, #80]
 110fef0:	a8d07bfd 	ldp	x29, x30, [sp], #256
 110fef4:	d65f03c0 	ret
	nb_blocks = (len + block_size - 1) / block_size;
 110fef8:	91003e87 	add	x7, x20, #0xf
 110fefc:	d344fcfa 	lsr	x26, x7, #4
	if (nb_blocks < 2)
 110ff00:	7100075f 	cmp	w26, #0x1
 110ff04:	54000e6d 	b.le	11100d0 <cts_update+0x280>
	if (len_last_block == 0)
 110ff08:	f2400e94 	ands	x20, x20, #0xf
 110ff0c:	d2800216 	mov	x22, #0x10                  	// #16
 110ff10:	9a961294 	csel	x20, x20, x22, ne  // ne = any
 110ff14:	b9006bf4 	str	w20, [sp, #104]
	if (mode == TEE_MODE_ENCRYPT) {
 110ff18:	350004bb 	cbnz	w27, 110ffac <cts_update+0x15c>
		       data + ((nb_blocks - 1) * block_size),
 110ff1c:	51000747 	sub	w7, w26, #0x1
		memcpy(tmp_block,
 110ff20:	910303f9 	add	x25, sp, #0xc0
 110ff24:	aa1403e2 	mov	x2, x20
 110ff28:	aa1903e0 	mov	x0, x25
		       data + ((nb_blocks - 1) * block_size),
 110ff2c:	531c6cf8 	lsl	w24, w7, #4
		memcpy(tmp_block,
 110ff30:	8b38c381 	add	x1, x28, w24, sxtw
 110ff34:	97ffcd17 	bl	1103390 <memcpy>
		       block_size - len_last_block);
 110ff38:	4b1402c2 	sub	w2, w22, w20
		memset(tmp_block + len_last_block,
 110ff3c:	52800001 	mov	w1, #0x0                   	// #0
 110ff40:	8b140320 	add	x0, x25, x20
		       data + ((nb_blocks - 1) * block_size),
 110ff44:	93407f1a 	sxtw	x26, w24
		memset(tmp_block + len_last_block,
 110ff48:	93407c42 	sxtw	x2, w2
 110ff4c:	9400cf65 	bl	1143ce0 <memset>
		res = tee_do_cipher_update(cbc_ctx, TEE_ALG_AES_CBC_NOPAD,
 110ff50:	52802201 	mov	w1, #0x110                 	// #272
 110ff54:	aa1503e6 	mov	x6, x21
 110ff58:	aa1a03e5 	mov	x5, x26
 110ff5c:	aa1c03e4 	mov	x4, x28
 110ff60:	aa1703e0 	mov	x0, x23
 110ff64:	52800003 	mov	w3, #0x0                   	// #0
 110ff68:	52800002 	mov	w2, #0x0                   	// #0
 110ff6c:	72a20001 	movk	w1, #0x1000, lsl #16
 110ff70:	94002ec3 	bl	111ba7c <tee_do_cipher_update>
 110ff74:	2a0003f3 	mov	w19, w0
		if (res != TEE_SUCCESS)
 110ff78:	35fffb00 	cbnz	w0, 110fed8 <cts_update+0x88>
		       dst + (nb_blocks - 2) * block_size,
 110ff7c:	51004318 	sub	w24, w24, #0x10
		memcpy(dst + (nb_blocks - 1) * block_size,
 110ff80:	aa1403e2 	mov	x2, x20
 110ff84:	8b1a02a0 	add	x0, x21, x26
		       dst + (nb_blocks - 2) * block_size,
 110ff88:	8b38c2b8 	add	x24, x21, w24, sxtw
		memcpy(dst + (nb_blocks - 1) * block_size,
 110ff8c:	aa1803e1 	mov	x1, x24
 110ff90:	97ffcd00 	bl	1103390 <memcpy>
		res = tee_do_cipher_update(cbc_ctx, TEE_ALG_AES_CBC_NOPAD,
 110ff94:	aa1803e6 	mov	x6, x24
 110ff98:	aa1603e5 	mov	x5, x22
 110ff9c:	aa1903e4 	mov	x4, x25
 110ffa0:	52800003 	mov	w3, #0x0                   	// #0
 110ffa4:	52800002 	mov	w2, #0x0                   	// #0
 110ffa8:	17ffffc7 	b	110fec4 <cts_update+0x74>
					   data + (nb_blocks - 2) * block_size,
 110ffac:	51000b58 	sub	w24, w26, #0x2
		res = tee_do_cipher_update(ecb_ctx, TEE_ALG_AES_ECB_NOPAD,
 110ffb0:	910203e6 	add	x6, sp, #0x80
 110ffb4:	aa1603e5 	mov	x5, x22
 110ffb8:	2a1b03e2 	mov	w2, w27
					   data + (nb_blocks - 2) * block_size,
 110ffbc:	531c6f18 	lsl	w24, w24, #4
		res = tee_do_cipher_update(ecb_ctx, TEE_ALG_AES_ECB_NOPAD,
 110ffc0:	52800003 	mov	w3, #0x0                   	// #0
 110ffc4:	f9003fe6 	str	x6, [sp, #120]
					   data + (nb_blocks - 2) * block_size,
 110ffc8:	93407f01 	sxtw	x1, w24
		res = tee_do_cipher_update(ecb_ctx, TEE_ALG_AES_ECB_NOPAD,
 110ffcc:	8b38c399 	add	x25, x28, w24, sxtw
					   data + (nb_blocks - 2) * block_size,
 110ffd0:	f90037e1 	str	x1, [sp, #104]
		res = tee_do_cipher_update(ecb_ctx, TEE_ALG_AES_ECB_NOPAD,
 110ffd4:	52800201 	mov	w1, #0x10                  	// #16
 110ffd8:	aa1903e4 	mov	x4, x25
 110ffdc:	72a20001 	movk	w1, #0x1000, lsl #16
 110ffe0:	94002ea7 	bl	111ba7c <tee_do_cipher_update>
 110ffe4:	2a0003f3 	mov	w19, w0
		if (res != TEE_SUCCESS)
 110ffe8:	35fff780 	cbnz	w0, 110fed8 <cts_update+0x88>
		memcpy(tmp_block, data + ((nb_blocks - 1) * block_size),
 110ffec:	11004301 	add	w1, w24, #0x10
 110fff0:	910303f8 	add	x24, sp, #0xc0
 110fff4:	aa1403e2 	mov	x2, x20
 110fff8:	93407c20 	sxtw	x0, w1
 110fffc:	8b21c381 	add	x1, x28, w1, sxtw
 1110000:	f9003be0 	str	x0, [sp, #112]
 1110004:	aa1803e0 	mov	x0, x24
 1110008:	97ffcce2 	bl	1103390 <memcpy>
		memcpy(tmp_block + len_last_block, tmp2_block + len_last_block,
 111000c:	f9403fe6 	ldr	x6, [sp, #120]
		       block_size - len_last_block);
 1110010:	4b1402c2 	sub	w2, w22, w20
		memcpy(tmp_block + len_last_block, tmp2_block + len_last_block,
 1110014:	8b140300 	add	x0, x24, x20
 1110018:	93407c42 	sxtw	x2, w2
 111001c:	8b1400c1 	add	x1, x6, x20
 1110020:	97ffccdc 	bl	1103390 <memcpy>
		if (nb_blocks > 2) {
 1110024:	71000b5f 	cmp	w26, #0x2
 1110028:	540003c1 	b.ne	11100a0 <cts_update+0x250>  // b.any
		res = tee_do_cipher_update(cbc_ctx, TEE_ALG_AES_CBC_NOPAD,
 111002c:	f94037e0 	ldr	x0, [sp, #104]
 1110030:	52802201 	mov	w1, #0x110                 	// #272
 1110034:	aa1803e4 	mov	x4, x24
 1110038:	2a1b03e2 	mov	w2, w27
 111003c:	8b0002a6 	add	x6, x21, x0
 1110040:	d2800205 	mov	x5, #0x10                  	// #16
 1110044:	aa1703e0 	mov	x0, x23
 1110048:	52800003 	mov	w3, #0x0                   	// #0
 111004c:	72a20001 	movk	w1, #0x1000, lsl #16
 1110050:	94002e8b 	bl	111ba7c <tee_do_cipher_update>
 1110054:	2a0003f3 	mov	w19, w0
		if (res != TEE_SUCCESS)
 1110058:	35fff400 	cbnz	w0, 110fed8 <cts_update+0x88>
		res = tee_do_cipher_update(cbc_ctx, TEE_ALG_AES_CBC_NOPAD,
 111005c:	52802201 	mov	w1, #0x110                 	// #272
 1110060:	aa1803e6 	mov	x6, x24
 1110064:	aa1903e4 	mov	x4, x25
 1110068:	2a1b03e2 	mov	w2, w27
 111006c:	aa1703e0 	mov	x0, x23
 1110070:	d2800205 	mov	x5, #0x10                  	// #16
 1110074:	52800003 	mov	w3, #0x0                   	// #0
 1110078:	72a20001 	movk	w1, #0x1000, lsl #16
 111007c:	94002e80 	bl	111ba7c <tee_do_cipher_update>
 1110080:	2a0003f3 	mov	w19, w0
		if (res != TEE_SUCCESS)
 1110084:	35fff2a0 	cbnz	w0, 110fed8 <cts_update+0x88>
		memcpy(dst + (nb_blocks - 1) * block_size, tmp_block,
 1110088:	f9403be0 	ldr	x0, [sp, #112]
 111008c:	aa1403e2 	mov	x2, x20
 1110090:	aa1803e1 	mov	x1, x24
 1110094:	8b0002a0 	add	x0, x21, x0
 1110098:	97ffccbe 	bl	1103390 <memcpy>
 111009c:	17ffff8f 	b	110fed8 <cts_update+0x88>
			res = tee_do_cipher_update(cbc_ctx,
 11100a0:	f94037e5 	ldr	x5, [sp, #104]
 11100a4:	52802201 	mov	w1, #0x110                 	// #272
 11100a8:	aa1503e6 	mov	x6, x21
 11100ac:	aa1c03e4 	mov	x4, x28
 11100b0:	2a1b03e2 	mov	w2, w27
 11100b4:	aa1703e0 	mov	x0, x23
 11100b8:	52800003 	mov	w3, #0x0                   	// #0
 11100bc:	72a20001 	movk	w1, #0x1000, lsl #16
 11100c0:	94002e6f 	bl	111ba7c <tee_do_cipher_update>
 11100c4:	2a0003f3 	mov	w19, w0
			if (res != TEE_SUCCESS)
 11100c8:	34fffb20 	cbz	w0, 111002c <cts_update+0x1dc>
 11100cc:	17ffff83 	b	110fed8 <cts_update+0x88>
		return TEE_ERROR_BAD_STATE;
 11100d0:	129fff13 	mov	w19, #0xffff0007            	// #-65529
	return cbc_cts_update(c->cbc, c->ecb, c->mode, last_block, data, len,
 11100d4:	17ffff81 	b	110fed8 <cts_update+0x88>

00000000011100d8 <cts_init>:
{
 11100d8:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 11100dc:	910003fd 	mov	x29, sp
 11100e0:	a90153f3 	stp	x19, x20, [sp, #16]
 11100e4:	2a0103f4 	mov	w20, w1
 11100e8:	a9025bf5 	stp	x21, x22, [sp, #32]
 11100ec:	aa0203f5 	mov	x21, x2
 11100f0:	aa0303f6 	mov	x22, x3
 11100f4:	a90363f7 	stp	x23, x24, [sp, #48]
 11100f8:	aa0403f7 	mov	x23, x4
 11100fc:	aa0503f8 	mov	x24, x5
 1110100:	a9046bf9 	stp	x25, x26, [sp, #64]
 1110104:	aa0603f9 	mov	x25, x6
 1110108:	aa0703fa 	mov	x26, x7
	struct cts_ctx *c = to_cts_ctx(ctx);
 111010c:	97ffff12 	bl	110fd54 <to_cts_ctx>
 1110110:	aa0003f3 	mov	x19, x0
	c->mode = mode;
 1110114:	b9001814 	str	w20, [x0, #24]
	res = crypto_cipher_init(c->ecb, mode, key1, key1_len, key2, key2_len,
 1110118:	aa1a03e7 	mov	x7, x26
 111011c:	f9400400 	ldr	x0, [x0, #8]
 1110120:	aa1903e6 	mov	x6, x25
 1110124:	aa1803e5 	mov	x5, x24
 1110128:	aa1703e4 	mov	x4, x23
 111012c:	aa1603e3 	mov	x3, x22
 1110130:	aa1503e2 	mov	x2, x21
 1110134:	2a1403e1 	mov	w1, w20
 1110138:	97fff515 	bl	110d58c <crypto_cipher_init>
	if (res)
 111013c:	350001e0 	cbnz	w0, 1110178 <cts_init+0xa0>
	return crypto_cipher_init(c->cbc, mode, key1, key1_len, key2, key2_len,
 1110140:	aa1a03e7 	mov	x7, x26
 1110144:	aa1903e6 	mov	x6, x25
 1110148:	aa1803e5 	mov	x5, x24
 111014c:	aa1703e4 	mov	x4, x23
 1110150:	aa1603e3 	mov	x3, x22
 1110154:	aa1503e2 	mov	x2, x21
 1110158:	2a1403e1 	mov	w1, w20
 111015c:	f9400a60 	ldr	x0, [x19, #16]
}
 1110160:	a94153f3 	ldp	x19, x20, [sp, #16]
 1110164:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1110168:	a94363f7 	ldp	x23, x24, [sp, #48]
 111016c:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1110170:	a8c57bfd 	ldp	x29, x30, [sp], #80
	return crypto_cipher_init(c->cbc, mode, key1, key1_len, key2, key2_len,
 1110174:	17fff506 	b	110d58c <crypto_cipher_init>
}
 1110178:	a94153f3 	ldp	x19, x20, [sp, #16]
 111017c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1110180:	a94363f7 	ldp	x23, x24, [sp, #48]
 1110184:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1110188:	a8c57bfd 	ldp	x29, x30, [sp], #80
 111018c:	d65f03c0 	ret

0000000001110190 <crypto_aes_cts_alloc_ctx>:
	.free_ctx = cts_free_ctx,
	.copy_state = cts_copy_state,
};

TEE_Result crypto_aes_cts_alloc_ctx(struct crypto_cipher_ctx **ctx)
{
 1110190:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	TEE_Result res = TEE_SUCCESS;
	struct cts_ctx *c = calloc(1, sizeof(*c));
 1110194:	d2800401 	mov	x1, #0x20                  	// #32
{
 1110198:	910003fd 	mov	x29, sp
 111019c:	a90153f3 	stp	x19, x20, [sp, #16]
 11101a0:	f90013f5 	str	x21, [sp, #32]
 11101a4:	aa0003f5 	mov	x21, x0
	struct cts_ctx *c = calloc(1, sizeof(*c));
 11101a8:	d2800020 	mov	x0, #0x1                   	// #1
 11101ac:	9400ccc9 	bl	11434d0 <calloc>

	if (!c)
 11101b0:	b4000300 	cbz	x0, 1110210 <crypto_aes_cts_alloc_ctx+0x80>
 11101b4:	aa0003f4 	mov	x20, x0
		return TEE_ERROR_OUT_OF_MEMORY;

	res = crypto_aes_ecb_alloc_ctx(&c->ecb);
 11101b8:	91002000 	add	x0, x0, #0x8
 11101bc:	9400626b 	bl	1128b68 <crypto_aes_ecb_alloc_ctx>
 11101c0:	2a0003f3 	mov	w19, w0
	if (res)
 11101c4:	350001c0 	cbnz	w0, 11101fc <crypto_aes_cts_alloc_ctx+0x6c>
		goto err;
	res = crypto_aes_cbc_alloc_ctx(&c->cbc);
 11101c8:	91004280 	add	x0, x20, #0x10
 11101cc:	94006336 	bl	1128ea4 <crypto_aes_cbc_alloc_ctx>
 11101d0:	2a0003f3 	mov	w19, w0
	if (res)
 11101d4:	35000140 	cbnz	w0, 11101fc <crypto_aes_cts_alloc_ctx+0x6c>
		goto err;

	c->ctx.ops = &cts_ops;
 11101d8:	f0000240 	adrp	x0, 115b000 <__vcore_unpg_rw_start>
 11101dc:	911a4000 	add	x0, x0, #0x690
	*ctx = &c->ctx;
 11101e0:	f90002b4 	str	x20, [x21]
	c->ctx.ops = &cts_ops;
 11101e4:	f9000280 	str	x0, [x20]
err:
	crypto_cipher_free_ctx(c->ecb);
	free(c);

	return res;
}
 11101e8:	2a1303e0 	mov	w0, w19
 11101ec:	a94153f3 	ldp	x19, x20, [sp, #16]
 11101f0:	f94013f5 	ldr	x21, [sp, #32]
 11101f4:	a8c37bfd 	ldp	x29, x30, [sp], #48
 11101f8:	d65f03c0 	ret
	crypto_cipher_free_ctx(c->ecb);
 11101fc:	f9400680 	ldr	x0, [x20, #8]
 1110200:	97fff4c9 	bl	110d524 <crypto_cipher_free_ctx>
	free(c);
 1110204:	aa1403e0 	mov	x0, x20
 1110208:	9400ccf6 	bl	11435e0 <free>
	return res;
 111020c:	17fffff7 	b	11101e8 <crypto_aes_cts_alloc_ctx+0x58>
		return TEE_ERROR_OUT_OF_MEMORY;
 1110210:	129ffe73 	mov	w19, #0xffff000c            	// #-65524
 1110214:	17fffff5 	b	11101e8 <crypto_aes_cts_alloc_ctx+0x58>

0000000001110218 <sm2_kdf>:
 * GM/T 0003.12012 Part 4 Sections 5.4.2 and 5.4.3
 * GM/T 0003.12012 Part 5 Sections 5.4.2 and 5.4.3
 * Key derivation function based on the SM3 hash function
 */
TEE_Result sm2_kdf(const uint8_t *Z, size_t Z_len, uint8_t *t, size_t tlen)
{
 1110218:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
 111021c:	910003fd 	mov	x29, sp
 1110220:	a90363f7 	stp	x23, x24, [sp, #48]
 1110224:	aa0103f7 	mov	x23, x1
	uint32_t count = 1;
	uint32_t be_count = 0;
	void *ctx = NULL;
	uint8_t *out = t;

	res = crypto_hash_alloc_ctx(&ctx, TEE_ALG_SM3);
 1110228:	528000e1 	mov	w1, #0x7                   	// #7
 111022c:	72aa0001 	movk	w1, #0x5000, lsl #16
{
 1110230:	a90153f3 	stp	x19, x20, [sp, #16]
 1110234:	aa0203f4 	mov	x20, x2
 1110238:	a9025bf5 	stp	x21, x22, [sp, #32]
 111023c:	aa0003f6 	mov	x22, x0
	res = crypto_hash_alloc_ctx(&ctx, TEE_ALG_SM3);
 1110240:	9101a3e0 	add	x0, sp, #0x68
{
 1110244:	a9046bf9 	stp	x25, x26, [sp, #64]
 1110248:	a90573fb 	stp	x27, x28, [sp, #80]
 111024c:	aa0303fc 	mov	x28, x3
	uint32_t be_count = 0;
 1110250:	b90067ff 	str	wzr, [sp, #100]
	void *ctx = NULL;
 1110254:	f90037ff 	str	xzr, [sp, #104]
	res = crypto_hash_alloc_ctx(&ctx, TEE_ALG_SM3);
 1110258:	97fff3e9 	bl	110d1fc <crypto_hash_alloc_ctx>
 111025c:	2a0003f3 	mov	w19, w0
	if (res)
 1110260:	35000500 	cbnz	w0, 1110300 <sm2_kdf+0xe8>
 1110264:	8b1c0294 	add	x20, x20, x28

	while (remain) {
		uint8_t tmp[TEE_SM3_HASH_SIZE] = { };
		uint8_t *buf = NULL;

		if (remain >= TEE_SM3_HASH_SIZE)
 1110268:	9101c3f9 	add	x25, sp, #0x70
		if (res)
			goto out;
		res = crypto_hash_update(ctx, Z, Z_len);
		if (res)
			goto out;
		res = crypto_hash_update(ctx, (const uint8_t *)&be_count,
 111026c:	910193fa 	add	x26, sp, #0x64
	uint32_t count = 1;
 1110270:	52800035 	mov	w21, #0x1                   	// #1
 1110274:	cb1c0298 	sub	x24, x20, x28
	while (remain) {
 1110278:	b400041c 	cbz	x28, 11102f8 <sm2_kdf+0xe0>
	return TEE_U32_FROM_BIG_ENDIAN(*(const uint32_t *)p);
}

static inline void put_be32(void *p, uint32_t val)
{
	*(uint32_t *)p = TEE_U32_TO_BIG_ENDIAN(val);
 111027c:	5ac00aa0 	rev	w0, w21
 1110280:	b90067e0 	str	w0, [sp, #100]
		res = crypto_hash_init(ctx);
 1110284:	f94037e0 	ldr	x0, [sp, #104]
		if (remain >= TEE_SM3_HASH_SIZE)
 1110288:	f100839f 	cmp	x28, #0x20
 111028c:	9a98333b 	csel	x27, x25, x24, cc  // cc = lo, ul, last
		uint8_t tmp[TEE_SM3_HASH_SIZE] = { };
 1110290:	a9077fff 	stp	xzr, xzr, [sp, #112]
 1110294:	a9087fff 	stp	xzr, xzr, [sp, #128]
		res = crypto_hash_init(ctx);
 1110298:	97fff418 	bl	110d2f8 <crypto_hash_init>
		if (res)
 111029c:	35000480 	cbnz	w0, 111032c <sm2_kdf+0x114>
		res = crypto_hash_update(ctx, Z, Z_len);
 11102a0:	f94037e0 	ldr	x0, [sp, #104]
 11102a4:	aa1703e2 	mov	x2, x23
 11102a8:	aa1603e1 	mov	x1, x22
 11102ac:	97fff41e 	bl	110d324 <crypto_hash_update>
		if (res)
 11102b0:	350003e0 	cbnz	w0, 111032c <sm2_kdf+0x114>
		res = crypto_hash_update(ctx, (const uint8_t *)&be_count,
 11102b4:	f94037e0 	ldr	x0, [sp, #104]
 11102b8:	aa1a03e1 	mov	x1, x26
 11102bc:	d2800082 	mov	x2, #0x4                   	// #4
 11102c0:	97fff419 	bl	110d324 <crypto_hash_update>
					 sizeof(be_count));
		if (res)
 11102c4:	35000340 	cbnz	w0, 111032c <sm2_kdf+0x114>
			goto out;
		res = crypto_hash_final(ctx, buf, TEE_SM3_HASH_SIZE);
 11102c8:	f94037e0 	ldr	x0, [sp, #104]
 11102cc:	aa1b03e1 	mov	x1, x27
 11102d0:	d2800402 	mov	x2, #0x20                  	// #32
 11102d4:	97fff425 	bl	110d368 <crypto_hash_final>
		if (res)
 11102d8:	350002a0 	cbnz	w0, 111032c <sm2_kdf+0x114>
			goto out;

		if (remain < TEE_SM3_HASH_SIZE) {
 11102dc:	f1007f9f 	cmp	x28, #0x1f
 11102e0:	54000208 	b.hi	1110320 <sm2_kdf+0x108>  // b.pmore
		res = crypto_hash_final(ctx, buf, TEE_SM3_HASH_SIZE);
 11102e4:	52800013 	mov	w19, #0x0                   	// #0
			memcpy(out, tmp, remain);
 11102e8:	aa1c03e2 	mov	x2, x28
 11102ec:	9101c3e1 	add	x1, sp, #0x70
 11102f0:	aa1803e0 	mov	x0, x24
 11102f4:	97ffcc27 	bl	1103390 <memcpy>
		out += TEE_SM3_HASH_SIZE;
		remain -= TEE_SM3_HASH_SIZE;
		count++;
	}
out:
	crypto_hash_free_ctx(ctx);
 11102f8:	f94037e0 	ldr	x0, [sp, #104]
 11102fc:	97fff3e5 	bl	110d290 <crypto_hash_free_ctx>
	return res;
}
 1110300:	2a1303e0 	mov	w0, w19
 1110304:	a94153f3 	ldp	x19, x20, [sp, #16]
 1110308:	a9425bf5 	ldp	x21, x22, [sp, #32]
 111030c:	a94363f7 	ldp	x23, x24, [sp, #48]
 1110310:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1110314:	a94573fb 	ldp	x27, x28, [sp, #80]
 1110318:	a8c97bfd 	ldp	x29, x30, [sp], #144
 111031c:	d65f03c0 	ret
		remain -= TEE_SM3_HASH_SIZE;
 1110320:	d100839c 	sub	x28, x28, #0x20
		count++;
 1110324:	110006b5 	add	w21, w21, #0x1
 1110328:	17ffffd3 	b	1110274 <sm2_kdf+0x5c>
			goto out;
 111032c:	2a0003f3 	mov	w19, w0
 1110330:	17fffff2 	b	11102f8 <sm2_kdf+0xe0>

0000000001110334 <sm3_process>:
	ctx->state[6] = 0xE38DEE4D;
	ctx->state[7] = 0xB0FB0E4E;
}

static void sm3_process(struct sm3_context *ctx, const uint8_t data[64])
{
 1110334:	d10d83ff 	sub	sp, sp, #0x360
	uint32_t T[64];
	uint32_t Temp1, Temp2, Temp3, Temp4, Temp5;
	int j;

	for (j = 0; j < 16; j++)
		T[j] = 0x79CC4519;
 1110338:	5288a323 	mov	w3, #0x4519                	// #17689
{
 111033c:	d2800002 	mov	x2, #0x0                   	// #0
		T[j] = 0x79CC4519;
 1110340:	72af3983 	movk	w3, #0x79cc, lsl #16
{
 1110344:	a9007bfd 	stp	x29, x30, [sp]
 1110348:	910003fd 	mov	x29, sp
 111034c:	a90153f3 	stp	x19, x20, [sp, #16]
		T[j] = 0x79CC4519;
 1110350:	910543f3 	add	x19, sp, #0x150
{
 1110354:	a9025bf5 	stp	x21, x22, [sp, #32]
 1110358:	a90363f7 	stp	x23, x24, [sp, #48]
 111035c:	a9046bf9 	stp	x25, x26, [sp, #64]
		T[j] = 0x79CC4519;
 1110360:	b8227a63 	str	w3, [x19, x2, lsl #2]
	for (j = 0; j < 16; j++)
 1110364:	91000442 	add	x2, x2, #0x1
 1110368:	f100405f 	cmp	x2, #0x10
 111036c:	54ffffa1 	b.ne	1110360 <sm3_process+0x2c>  // b.any
	for (j = 16; j < 64; j++)
		T[j] = 0x7A879D8A;
 1110370:	5293b143 	mov	w3, #0x9d8a                	// #40330
 1110374:	72af50e3 	movk	w3, #0x7a87, lsl #16
 1110378:	b8227a63 	str	w3, [x19, x2, lsl #2]
	for (j = 16; j < 64; j++)
 111037c:	91000442 	add	x2, x2, #0x1
 1110380:	f101005f 	cmp	x2, #0x40
 1110384:	54ffffa1 	b.ne	1110378 <sm3_process+0x44>  // b.any

	GET_UINT32_BE(W[0], data,  0);
 1110388:	39400022 	ldrb	w2, [x1]
	GET_UINT32_BE(W[10], data, 40);
	GET_UINT32_BE(W[11], data, 44);
	GET_UINT32_BE(W[12], data, 48);
	GET_UINT32_BE(W[13], data, 52);
	GET_UINT32_BE(W[14], data, 56);
	GET_UINT32_BE(W[15], data, 60);
 111038c:	52800685 	mov	w5, #0x34                  	// #52
 1110390:	39400423 	ldrb	w3, [x1, #1]
 1110394:	aa032043 	orr	x3, x2, x3, lsl #8
 1110398:	39400822 	ldrb	w2, [x1, #2]
 111039c:	aa024063 	orr	x3, x3, x2, lsl #16
 11103a0:	39400c22 	ldrb	w2, [x1, #3]
 11103a4:	aa026062 	orr	x2, x3, x2, lsl #24
 11103a8:	39401423 	ldrb	w3, [x1, #5]
 11103ac:	5ac00842 	rev	w2, w2
	GET_UINT32_BE(W[0], data,  0);
 11103b0:	b90253e2 	str	w2, [sp, #592]
	GET_UINT32_BE(W[1], data,  4);
 11103b4:	39401022 	ldrb	w2, [x1, #4]
 11103b8:	aa032043 	orr	x3, x2, x3, lsl #8
 11103bc:	39401822 	ldrb	w2, [x1, #6]
 11103c0:	aa024063 	orr	x3, x3, x2, lsl #16
 11103c4:	39401c22 	ldrb	w2, [x1, #7]
 11103c8:	aa026062 	orr	x2, x3, x2, lsl #24
 11103cc:	39402423 	ldrb	w3, [x1, #9]
 11103d0:	5ac00842 	rev	w2, w2
 11103d4:	b90257e2 	str	w2, [sp, #596]
	GET_UINT32_BE(W[2], data,  8);
 11103d8:	39402022 	ldrb	w2, [x1, #8]
 11103dc:	aa032043 	orr	x3, x2, x3, lsl #8
 11103e0:	39402822 	ldrb	w2, [x1, #10]
 11103e4:	aa024063 	orr	x3, x3, x2, lsl #16
 11103e8:	39402c22 	ldrb	w2, [x1, #11]
 11103ec:	aa026062 	orr	x2, x3, x2, lsl #24
 11103f0:	39403423 	ldrb	w3, [x1, #13]
 11103f4:	5ac00842 	rev	w2, w2
 11103f8:	b9025be2 	str	w2, [sp, #600]
	GET_UINT32_BE(W[3], data, 12);
 11103fc:	39403022 	ldrb	w2, [x1, #12]
 1110400:	aa032043 	orr	x3, x2, x3, lsl #8
 1110404:	39403822 	ldrb	w2, [x1, #14]
 1110408:	aa024063 	orr	x3, x3, x2, lsl #16
 111040c:	39403c22 	ldrb	w2, [x1, #15]
 1110410:	aa026062 	orr	x2, x3, x2, lsl #24
 1110414:	39404423 	ldrb	w3, [x1, #17]
 1110418:	5ac00842 	rev	w2, w2
 111041c:	b9025fe2 	str	w2, [sp, #604]
	GET_UINT32_BE(W[4], data, 16);
 1110420:	39404022 	ldrb	w2, [x1, #16]
 1110424:	aa032043 	orr	x3, x2, x3, lsl #8
 1110428:	39404822 	ldrb	w2, [x1, #18]
 111042c:	aa024063 	orr	x3, x3, x2, lsl #16
 1110430:	39404c22 	ldrb	w2, [x1, #19]
 1110434:	aa026062 	orr	x2, x3, x2, lsl #24
 1110438:	39405423 	ldrb	w3, [x1, #21]
 111043c:	5ac00842 	rev	w2, w2
 1110440:	b90263e2 	str	w2, [sp, #608]
	GET_UINT32_BE(W[5], data, 20);
 1110444:	39405022 	ldrb	w2, [x1, #20]
 1110448:	aa032043 	orr	x3, x2, x3, lsl #8
 111044c:	39405822 	ldrb	w2, [x1, #22]
 1110450:	aa024063 	orr	x3, x3, x2, lsl #16
 1110454:	39405c22 	ldrb	w2, [x1, #23]
 1110458:	aa026062 	orr	x2, x3, x2, lsl #24
 111045c:	39406423 	ldrb	w3, [x1, #25]
 1110460:	5ac00842 	rev	w2, w2
 1110464:	b90267e2 	str	w2, [sp, #612]
	GET_UINT32_BE(W[6], data, 24);
 1110468:	39406022 	ldrb	w2, [x1, #24]
 111046c:	aa032043 	orr	x3, x2, x3, lsl #8
 1110470:	39406822 	ldrb	w2, [x1, #26]
 1110474:	aa024063 	orr	x3, x3, x2, lsl #16
 1110478:	39406c22 	ldrb	w2, [x1, #27]
 111047c:	aa026062 	orr	x2, x3, x2, lsl #24
 1110480:	39407423 	ldrb	w3, [x1, #29]
 1110484:	5ac00842 	rev	w2, w2
 1110488:	b9026be2 	str	w2, [sp, #616]
	GET_UINT32_BE(W[7], data, 28);
 111048c:	39407022 	ldrb	w2, [x1, #28]
 1110490:	aa032043 	orr	x3, x2, x3, lsl #8
 1110494:	39407822 	ldrb	w2, [x1, #30]
 1110498:	aa024063 	orr	x3, x3, x2, lsl #16
 111049c:	39407c22 	ldrb	w2, [x1, #31]
 11104a0:	aa026062 	orr	x2, x3, x2, lsl #24
 11104a4:	39408423 	ldrb	w3, [x1, #33]
 11104a8:	5ac00842 	rev	w2, w2
 11104ac:	b9026fe2 	str	w2, [sp, #620]
	GET_UINT32_BE(W[8], data, 32);
 11104b0:	39408022 	ldrb	w2, [x1, #32]
 11104b4:	aa032043 	orr	x3, x2, x3, lsl #8
 11104b8:	39408822 	ldrb	w2, [x1, #34]
 11104bc:	aa024063 	orr	x3, x3, x2, lsl #16
 11104c0:	39408c22 	ldrb	w2, [x1, #35]
 11104c4:	aa026062 	orr	x2, x3, x2, lsl #24
 11104c8:	39409423 	ldrb	w3, [x1, #37]
 11104cc:	5ac00842 	rev	w2, w2
 11104d0:	b90273e2 	str	w2, [sp, #624]
	GET_UINT32_BE(W[9], data, 36);
 11104d4:	39409022 	ldrb	w2, [x1, #36]
 11104d8:	aa032043 	orr	x3, x2, x3, lsl #8
 11104dc:	39409822 	ldrb	w2, [x1, #38]
 11104e0:	aa024063 	orr	x3, x3, x2, lsl #16
 11104e4:	39409c22 	ldrb	w2, [x1, #39]
 11104e8:	aa026062 	orr	x2, x3, x2, lsl #24
 11104ec:	3940a423 	ldrb	w3, [x1, #41]
 11104f0:	5ac00842 	rev	w2, w2
 11104f4:	b90277e2 	str	w2, [sp, #628]
	GET_UINT32_BE(W[10], data, 40);
 11104f8:	3940a022 	ldrb	w2, [x1, #40]
 11104fc:	aa032043 	orr	x3, x2, x3, lsl #8
 1110500:	3940a822 	ldrb	w2, [x1, #42]
 1110504:	aa024063 	orr	x3, x3, x2, lsl #16
 1110508:	3940ac22 	ldrb	w2, [x1, #43]
 111050c:	aa026062 	orr	x2, x3, x2, lsl #24
 1110510:	3940b423 	ldrb	w3, [x1, #45]
 1110514:	5ac00842 	rev	w2, w2
 1110518:	b9027be2 	str	w2, [sp, #632]
	GET_UINT32_BE(W[11], data, 44);
 111051c:	3940b022 	ldrb	w2, [x1, #44]
 1110520:	aa032043 	orr	x3, x2, x3, lsl #8
 1110524:	3940b822 	ldrb	w2, [x1, #46]
 1110528:	aa024063 	orr	x3, x3, x2, lsl #16
 111052c:	3940bc22 	ldrb	w2, [x1, #47]
 1110530:	aa026062 	orr	x2, x3, x2, lsl #24
 1110534:	3940c423 	ldrb	w3, [x1, #49]
 1110538:	5ac00842 	rev	w2, w2
 111053c:	b9027fe2 	str	w2, [sp, #636]
	GET_UINT32_BE(W[12], data, 48);
 1110540:	3940c022 	ldrb	w2, [x1, #48]
 1110544:	aa032043 	orr	x3, x2, x3, lsl #8
 1110548:	3940c822 	ldrb	w2, [x1, #50]
 111054c:	aa024063 	orr	x3, x3, x2, lsl #16
 1110550:	3940cc22 	ldrb	w2, [x1, #51]
 1110554:	aa026062 	orr	x2, x3, x2, lsl #24
 1110558:	5ac00842 	rev	w2, w2
 111055c:	b90283e2 	str	w2, [sp, #640]
	GET_UINT32_BE(W[13], data, 52);
 1110560:	3940d022 	ldrb	w2, [x1, #52]
 1110564:	3940d423 	ldrb	w3, [x1, #53]
 1110568:	aa032043 	orr	x3, x2, x3, lsl #8
 111056c:	3940d822 	ldrb	w2, [x1, #54]
 1110570:	aa024063 	orr	x3, x3, x2, lsl #16
 1110574:	3940dc22 	ldrb	w2, [x1, #55]
 1110578:	aa026062 	orr	x2, x3, x2, lsl #24
 111057c:	3940e423 	ldrb	w3, [x1, #57]
 1110580:	5ac00842 	rev	w2, w2
 1110584:	b90287e2 	str	w2, [sp, #644]
	GET_UINT32_BE(W[14], data, 56);
 1110588:	3940e022 	ldrb	w2, [x1, #56]
 111058c:	aa032043 	orr	x3, x2, x3, lsl #8
 1110590:	3940e822 	ldrb	w2, [x1, #58]
 1110594:	aa024063 	orr	x3, x3, x2, lsl #16
 1110598:	3940ec22 	ldrb	w2, [x1, #59]
 111059c:	aa026062 	orr	x2, x3, x2, lsl #24
 11105a0:	3940f023 	ldrb	w3, [x1, #60]
 11105a4:	5ac00842 	rev	w2, w2
 11105a8:	b9028be2 	str	w2, [sp, #648]
	GET_UINT32_BE(W[15], data, 60);
 11105ac:	3940f422 	ldrb	w2, [x1, #61]
 11105b0:	aa022063 	orr	x3, x3, x2, lsl #8
 11105b4:	3940f822 	ldrb	w2, [x1, #62]
 11105b8:	3940fc21 	ldrb	w1, [x1, #63]
 11105bc:	aa024062 	orr	x2, x3, x2, lsl #16
 11105c0:	910943e3 	add	x3, sp, #0x250
 11105c4:	aa016041 	orr	x1, x2, x1, lsl #24
 11105c8:	aa0303f5 	mov	x21, x3
 11105cc:	5ac00821 	rev	w1, w1
 11105d0:	b9028fe1 	str	w1, [sp, #652]
 11105d4:	aa0303e1 	mov	x1, x3
		/*
		 * W[j] = P1( W[j-16] ^ W[j-9] ^ ROTL(W[j-3],15)) ^
		 *        ROTL(W[j - 13],7 ) ^ W[j-6];
		 */

		Temp1 = W[j - 16] ^ W[j - 9];
 11105d8:	b9401c22 	ldr	w2, [x1, #28]
	for (j = 16; j < 68; j++) {
 11105dc:	710004a5 	subs	w5, w5, #0x1
		Temp1 = W[j - 16] ^ W[j - 9];
 11105e0:	b9400024 	ldr	w4, [x1]
 11105e4:	91001021 	add	x1, x1, #0x4
		Temp2 = ROTL(W[j - 3], 15);
		Temp3 = Temp1 ^ Temp2;
		Temp4 = P1(Temp3);
		Temp5 =  ROTL(W[j - 13], 7) ^ W[j - 6];
		W[j] = Temp4 ^ Temp5;
 11105e8:	b9402426 	ldr	w6, [x1, #36]
		Temp1 = W[j - 16] ^ W[j - 9];
 11105ec:	4a020084 	eor	w4, w4, w2
		Temp2 = ROTL(W[j - 3], 15);
 11105f0:	b9403022 	ldr	w2, [x1, #48]
		Temp3 = Temp1 ^ Temp2;
 11105f4:	4ac24484 	eor	w4, w4, w2, ror #17
		Temp5 =  ROTL(W[j - 13], 7) ^ W[j - 6];
 11105f8:	b9400822 	ldr	w2, [x1, #8]
		W[j] = Temp4 ^ Temp5;
 11105fc:	4ac264c2 	eor	w2, w6, w2, ror #25
		Temp4 = P1(Temp3);
 1110600:	13842486 	ror	w6, w4, #9
		W[j] = Temp4 ^ Temp5;
 1110604:	4ac444c6 	eor	w6, w6, w4, ror #17
 1110608:	4a060042 	eor	w2, w2, w6
 111060c:	4a040042 	eor	w2, w2, w4
 1110610:	b9003c22 	str	w2, [x1, #60]
	for (j = 16; j < 68; j++) {
 1110614:	54fffe21 	b.ne	11105d8 <sm3_process+0x2a4>  // b.any
	}

	for (j =  0; j < 64; j++)
		W1[j] = W[j] ^ W[j + 4];
 1110618:	910143f4 	add	x20, sp, #0x50
 111061c:	d2800001 	mov	x1, #0x0                   	// #0
 1110620:	b9400062 	ldr	w2, [x3]
 1110624:	91001063 	add	x3, x3, #0x4
 1110628:	b9400c64 	ldr	w4, [x3, #12]
 111062c:	4a040042 	eor	w2, w2, w4
 1110630:	b8346822 	str	w2, [x1, x20]
	for (j =  0; j < 64; j++)
 1110634:	91001021 	add	x1, x1, #0x4
 1110638:	f104003f 	cmp	x1, #0x100
 111063c:	54ffff21 	b.ne	1110620 <sm3_process+0x2ec>  // b.any

	A = ctx->state[0];
	B = ctx->state[1];
 1110640:	2941481e 	ldp	w30, w18, [x0, #8]
	C = ctx->state[2];
	D = ctx->state[3];
	E = ctx->state[4];
	F = ctx->state[5];
	G = ctx->state[6];
	H = ctx->state[7];
 1110644:	d2800002 	mov	x2, #0x0                   	// #0
	D = ctx->state[3];
 1110648:	29424011 	ldp	w17, w16, [x0, #16]
	B = ctx->state[1];
 111064c:	2a1203f8 	mov	w24, w18
	F = ctx->state[5];
 1110650:	2943380f 	ldp	w15, w14, [x0, #24]
	D = ctx->state[3];
 1110654:	2a1003fa 	mov	w26, w16
	H = ctx->state[7];
 1110658:	2944300d 	ldp	w13, w12, [x0, #32]
	F = ctx->state[5];
 111065c:	2a0e03e5 	mov	w5, w14
	E = ctx->state[4];
 1110660:	2a0f03e9 	mov	w9, w15
	C = ctx->state[2];
 1110664:	2a1103f7 	mov	w23, w17
	H = ctx->state[7];
 1110668:	2a0c03f9 	mov	w25, w12
	G = ctx->state[6];
 111066c:	2a0d03f6 	mov	w22, w13
	A = ctx->state[0];
 1110670:	2a1e03e8 	mov	w8, w30

	for (j = 0; j < 16; j++) {
		SS1 = ROTL(ROTL(A, 12) + E + ROTL(T[j], j), 7);
 1110674:	b8627a66 	ldr	w6, [x19, x2, lsl #2]
 1110678:	4b0203e4 	neg	w4, w2
 111067c:	b8627a87 	ldr	w7, [x20, x2, lsl #2]
 1110680:	13885101 	ror	w1, w8, #20
		SS2 = SS1 ^ ROTL(A, 12);
		TT1 = FF0(A, B, C) + D + SS2 + W1[j];
		TT2 = GG0(E, F, G) + H + SS1 + W[j];
		D = C;
		C = ROTL(B, 9);
 1110684:	13985f0b 	ror	w11, w24, #23
		SS1 = ROTL(ROTL(A, 12) + E + ROTL(T[j], j), 7);
 1110688:	1ac42cc6 	ror	w6, w6, w4
 111068c:	0b090024 	add	w4, w1, w9
 1110690:	0b0400c4 	add	w4, w6, w4
		TT1 = FF0(A, B, C) + D + SS2 + W1[j];
 1110694:	4a180106 	eor	w6, w8, w24
 1110698:	4a1700c6 	eor	w6, w6, w23
		B = A;
		A = TT1;
		H = G;
		G = ROTL(F, 19);
 111069c:	138534aa 	ror	w10, w5, #13
 11106a0:	0b0700c6 	add	w6, w6, w7
		SS1 = ROTL(ROTL(A, 12) + E + ROTL(T[j], j), 7);
 11106a4:	13846483 	ror	w3, w4, #25
		SS2 = SS1 ^ ROTL(A, 12);
 11106a8:	4ac46421 	eor	w1, w1, w4, ror #25
		TT2 = GG0(E, F, G) + H + SS1 + W[j];
 11106ac:	4a050127 	eor	w7, w9, w5
 11106b0:	b8627aa4 	ldr	w4, [x21, x2, lsl #2]
 11106b4:	4a1600e7 	eor	w7, w7, w22
 11106b8:	0b190063 	add	w3, w3, w25
		TT1 = FF0(A, B, C) + D + SS2 + W1[j];
 11106bc:	0b1a0021 	add	w1, w1, w26
		TT2 = GG0(E, F, G) + H + SS1 + W[j];
 11106c0:	0b0400e7 	add	w7, w7, w4
 11106c4:	91000442 	add	x2, x2, #0x1
 11106c8:	0b0300e3 	add	w3, w7, w3
		TT1 = FF0(A, B, C) + D + SS2 + W1[j];
 11106cc:	0b060021 	add	w1, w1, w6
		F = E;
		E = P0(TT2);
 11106d0:	2a0803f8 	mov	w24, w8
 11106d4:	2a1703fa 	mov	w26, w23
 11106d8:	2a0903e5 	mov	w5, w9
 11106dc:	13833c67 	ror	w7, w3, #15
 11106e0:	4ac35ce7 	eor	w7, w7, w3, ror #23
 11106e4:	2a1603f9 	mov	w25, w22
 11106e8:	4a0300e7 	eor	w7, w7, w3
	for (j = 0; j < 16; j++) {
 11106ec:	f100405f 	cmp	x2, #0x10
 11106f0:	540006e1 	b.ne	11107cc <sm3_process+0x498>  // b.any
	}

	for (j = 16; j < 64; j++) {
		SS1 = ROTL(ROTL(A, 12) + E + ROTL(T[j], j), 7);
 11106f4:	b8627a66 	ldr	w6, [x19, x2, lsl #2]
 11106f8:	4b0203e5 	neg	w5, w2
		SS2 = SS1 ^ ROTL(A, 12);
		TT1 = FF1(A, B, C) + D + SS2 + W1[j];
 11106fc:	2a0b0104 	orr	w4, w8, w11
		SS1 = ROTL(ROTL(A, 12) + E + ROTL(T[j], j), 7);
 1110700:	13815023 	ror	w3, w1, #20
		TT1 = FF1(A, B, C) + D + SS2 + W1[j];
 1110704:	0a0b0118 	and	w24, w8, w11
 1110708:	0a010084 	and	w4, w4, w1
		SS1 = ROTL(ROTL(A, 12) + E + ROTL(T[j], j), 7);
 111070c:	1ac52cc6 	ror	w6, w6, w5
 1110710:	0b070065 	add	w5, w3, w7
 1110714:	0b0500c5 	add	w5, w6, w5
		TT1 = FF1(A, B, C) + D + SS2 + W1[j];
 1110718:	2a180084 	orr	w4, w4, w24
 111071c:	b8627a98 	ldr	w24, [x20, x2, lsl #2]
		SS2 = SS1 ^ ROTL(A, 12);
 1110720:	4ac56463 	eor	w3, w3, w5, ror #25
		SS1 = ROTL(ROTL(A, 12) + E + ROTL(T[j], j), 7);
 1110724:	138564a6 	ror	w6, w5, #25
		TT1 = FF1(A, B, C) + D + SS2 + W1[j];
 1110728:	0b180084 	add	w4, w4, w24
 111072c:	0b170063 	add	w3, w3, w23
 1110730:	0b040063 	add	w3, w3, w4
		TT2 = GG1(E, F, G) + H + SS1 + W[j];
 1110734:	4a0a0124 	eor	w4, w9, w10
 1110738:	b8627aa5 	ldr	w5, [x21, x2, lsl #2]
 111073c:	0a070084 	and	w4, w4, w7
 1110740:	4a0a0084 	eor	w4, w4, w10
 1110744:	0b1600d6 	add	w22, w6, w22
 1110748:	0b050084 	add	w4, w4, w5
 111074c:	91000442 	add	x2, x2, #0x1
 1110750:	0b160084 	add	w4, w4, w22
		D = C;
		C = ROTL(B, 9);
 1110754:	13885d18 	ror	w24, w8, #23
		B = A;
		A = TT1;
		H = G;
		G = ROTL(F, 19);
 1110758:	2a0b03f7 	mov	w23, w11
 111075c:	13893526 	ror	w6, w9, #13
		F = E;
		E = P0(TT2);
 1110760:	2a0103e8 	mov	w8, w1
 1110764:	13843c85 	ror	w5, w4, #15
 1110768:	4ac45ca5 	eor	w5, w5, w4, ror #23
 111076c:	2a0703e9 	mov	w9, w7
 1110770:	4a0400a4 	eor	w4, w5, w4
	for (j = 16; j < 64; j++) {
 1110774:	2a0a03f6 	mov	w22, w10
 1110778:	f101005f 	cmp	x2, #0x40
 111077c:	54000321 	b.ne	11107e0 <sm3_process+0x4ac>  // b.any
	}

	ctx->state[0] ^= A;
 1110780:	4a0303c3 	eor	w3, w30, w3
	ctx->state[1] ^= B;
	ctx->state[2] ^= C;
 1110784:	4a180231 	eor	w17, w17, w24
	ctx->state[1] ^= B;
 1110788:	4a010241 	eor	w1, w18, w1
	ctx->state[3] ^= D;
 111078c:	4a0b020b 	eor	w11, w16, w11
	ctx->state[4] ^= E;
 1110790:	4a0401e4 	eor	w4, w15, w4
	ctx->state[5] ^= F;
 1110794:	4a0701c7 	eor	w7, w14, w7
	ctx->state[6] ^= G;
 1110798:	4a0601ad 	eor	w13, w13, w6
	ctx->state[7] ^= H;
 111079c:	4a0a018a 	eor	w10, w12, w10
	ctx->state[1] ^= B;
 11107a0:	29010403 	stp	w3, w1, [x0, #8]
	ctx->state[3] ^= D;
 11107a4:	29022c11 	stp	w17, w11, [x0, #16]
	ctx->state[5] ^= F;
 11107a8:	29031c04 	stp	w4, w7, [x0, #24]
	ctx->state[7] ^= H;
 11107ac:	2904280d 	stp	w13, w10, [x0, #32]
}
 11107b0:	a9407bfd 	ldp	x29, x30, [sp]
 11107b4:	a94153f3 	ldp	x19, x20, [sp, #16]
 11107b8:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11107bc:	a94363f7 	ldp	x23, x24, [sp, #48]
 11107c0:	a9446bf9 	ldp	x25, x26, [sp, #64]
 11107c4:	910d83ff 	add	sp, sp, #0x360
 11107c8:	d65f03c0 	ret
		G = ROTL(F, 19);
 11107cc:	2a0a03f6 	mov	w22, w10
		E = P0(TT2);
 11107d0:	2a0703e9 	mov	w9, w7
		C = ROTL(B, 9);
 11107d4:	2a0b03f7 	mov	w23, w11
		TT1 = FF0(A, B, C) + D + SS2 + W1[j];
 11107d8:	2a0103e8 	mov	w8, w1
 11107dc:	17ffffa6 	b	1110674 <sm3_process+0x340>
		G = ROTL(F, 19);
 11107e0:	2a0603ea 	mov	w10, w6
		E = P0(TT2);
 11107e4:	2a0403e7 	mov	w7, w4
		C = ROTL(B, 9);
 11107e8:	2a1803eb 	mov	w11, w24
		TT1 = FF1(A, B, C) + D + SS2 + W1[j];
 11107ec:	2a0303e1 	mov	w1, w3
 11107f0:	17ffffc1 	b	11106f4 <sm3_process+0x3c0>

00000000011107f4 <sm3_update.part.0>:

void sm3_update(struct sm3_context *ctx, const uint8_t *input, size_t ilen)
 11107f4:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 11107f8:	910003fd 	mov	x29, sp
 11107fc:	a90153f3 	stp	x19, x20, [sp, #16]
 1110800:	aa0003f4 	mov	x20, x0
	size_t left;

	if (!ilen)
		return;

	left = ctx->total[0] & 0x3F;
 1110804:	b9400000 	ldr	w0, [x0]
void sm3_update(struct sm3_context *ctx, const uint8_t *input, size_t ilen)
 1110808:	a9025bf5 	stp	x21, x22, [sp, #32]
 111080c:	aa0203f3 	mov	x19, x2
	left = ctx->total[0] & 0x3F;
 1110810:	92401416 	and	x22, x0, #0x3f
void sm3_update(struct sm3_context *ctx, const uint8_t *input, size_t ilen)
 1110814:	a90363f7 	stp	x23, x24, [sp, #48]
	fill = 64 - left;

	ctx->total[0] += ilen;
 1110818:	0b020000 	add	w0, w0, w2
	fill = 64 - left;
 111081c:	d2800817 	mov	x23, #0x40                  	// #64
	ctx->total[0] += ilen;
 1110820:	b9000280 	str	w0, [x20]
void sm3_update(struct sm3_context *ctx, const uint8_t *input, size_t ilen)
 1110824:	aa0103f5 	mov	x21, x1
	fill = 64 - left;
 1110828:	cb1602f7 	sub	x23, x23, x22

	if (ctx->total[0] < ilen)
 111082c:	eb20405f 	cmp	x2, w0, uxtw
 1110830:	54000089 	b.ls	1110840 <sm3_update.part.0+0x4c>  // b.plast
		ctx->total[1]++;
 1110834:	b9400680 	ldr	w0, [x20, #4]
 1110838:	11000400 	add	w0, w0, #0x1
 111083c:	b9000680 	str	w0, [x20, #4]

	if (left && ilen >= fill) {
 1110840:	f10002df 	cmp	x22, #0x0
 1110844:	fa5312e2 	ccmp	x23, x19, #0x2, ne  // ne = any
 1110848:	540001a8 	b.hi	111087c <sm3_update.part.0+0x88>  // b.pmore
		memcpy(ctx->buffer + left, input, fill);
 111084c:	aa1503e1 	mov	x1, x21
 1110850:	9100a298 	add	x24, x20, #0x28
 1110854:	aa1703e2 	mov	x2, x23
 1110858:	d1010273 	sub	x19, x19, #0x40
		sm3_process(ctx, ctx->buffer);
		input += fill;
 111085c:	8b1702b5 	add	x21, x21, x23
		memcpy(ctx->buffer + left, input, fill);
 1110860:	8b160300 	add	x0, x24, x22
		ilen -= fill;
 1110864:	8b1302d3 	add	x19, x22, x19
		left = 0;
 1110868:	d2800016 	mov	x22, #0x0                   	// #0
		memcpy(ctx->buffer + left, input, fill);
 111086c:	97ffcac9 	bl	1103390 <memcpy>
		sm3_process(ctx, ctx->buffer);
 1110870:	aa1803e1 	mov	x1, x24
 1110874:	aa1403e0 	mov	x0, x20
 1110878:	97fffeaf 	bl	1110334 <sm3_process>
		left = 0;
 111087c:	aa1303f7 	mov	x23, x19
 1110880:	8b1302b8 	add	x24, x21, x19
 1110884:	14000004 	b	1110894 <sm3_update.part.0+0xa0>
	}

	while (ilen >= 64) {
		sm3_process(ctx, input);
		input += 64;
		ilen -= 64;
 1110888:	d10102f7 	sub	x23, x23, #0x40
		sm3_process(ctx, input);
 111088c:	aa1403e0 	mov	x0, x20
 1110890:	97fffea9 	bl	1110334 <sm3_process>
		ilen -= 64;
 1110894:	cb170301 	sub	x1, x24, x23
	while (ilen >= 64) {
 1110898:	f100feff 	cmp	x23, #0x3f
 111089c:	54ffff68 	b.hi	1110888 <sm3_update.part.0+0x94>  // b.pmore
 11108a0:	d346fe62 	lsr	x2, x19, #6
 11108a4:	928007e0 	mov	x0, #0xffffffffffffffc0    	// #-64
 11108a8:	927ae661 	and	x1, x19, #0xffffffffffffffc0
 11108ac:	8b0102a1 	add	x1, x21, x1
 11108b0:	9b004c42 	madd	x2, x2, x0, x19
	}

	if (ilen > 0)
 11108b4:	b4000102 	cbz	x2, 11108d4 <sm3_update.part.0+0xe0>
		memcpy(ctx->buffer + left, input, ilen);
 11108b8:	9100a280 	add	x0, x20, #0x28
 11108bc:	8b160000 	add	x0, x0, x22
}
 11108c0:	a94153f3 	ldp	x19, x20, [sp, #16]
 11108c4:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11108c8:	a94363f7 	ldp	x23, x24, [sp, #48]
 11108cc:	a8c47bfd 	ldp	x29, x30, [sp], #64
		memcpy(ctx->buffer + left, input, ilen);
 11108d0:	17ffcab0 	b	1103390 <memcpy>
}
 11108d4:	a94153f3 	ldp	x19, x20, [sp, #16]
 11108d8:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11108dc:	a94363f7 	ldp	x23, x24, [sp, #48]
 11108e0:	a8c47bfd 	ldp	x29, x30, [sp], #64
 11108e4:	d65f03c0 	ret

00000000011108e8 <sm3_init>:
	ctx->state[0] = 0x7380166F;
 11108e8:	5282cde1 	mov	w1, #0x166f                	// #5743
	ctx->total[1] = 0;
 11108ec:	29007c1f 	stp	wzr, wzr, [x0]
	ctx->state[0] = 0x7380166F;
 11108f0:	72ae7001 	movk	w1, #0x7380, lsl #16
 11108f4:	b9000801 	str	w1, [x0, #8]
	ctx->state[1] = 0x4914B2B9;
 11108f8:	52965721 	mov	w1, #0xb2b9                	// #45753
 11108fc:	72a92281 	movk	w1, #0x4914, lsl #16
 1110900:	b9000c01 	str	w1, [x0, #12]
	ctx->state[2] = 0x172442D7;
 1110904:	52885ae1 	mov	w1, #0x42d7                	// #17111
 1110908:	72a2e481 	movk	w1, #0x1724, lsl #16
 111090c:	b9001001 	str	w1, [x0, #16]
	ctx->state[3] = 0xDA8A0600;
 1110910:	5280c001 	mov	w1, #0x600                 	// #1536
 1110914:	72bb5141 	movk	w1, #0xda8a, lsl #16
 1110918:	b9001401 	str	w1, [x0, #20]
	ctx->state[4] = 0xA96F30BC;
 111091c:	52861781 	mov	w1, #0x30bc                	// #12476
 1110920:	72b52de1 	movk	w1, #0xa96f, lsl #16
 1110924:	b9001801 	str	w1, [x0, #24]
	ctx->state[5] = 0x163138AA;
 1110928:	52871541 	mov	w1, #0x38aa                	// #14506
 111092c:	72a2c621 	movk	w1, #0x1631, lsl #16
 1110930:	b9001c01 	str	w1, [x0, #28]
	ctx->state[6] = 0xE38DEE4D;
 1110934:	529dc9a1 	mov	w1, #0xee4d                	// #61005
 1110938:	72bc71a1 	movk	w1, #0xe38d, lsl #16
 111093c:	b9002001 	str	w1, [x0, #32]
	ctx->state[7] = 0xB0FB0E4E;
 1110940:	5281c9c1 	mov	w1, #0xe4e                 	// #3662
 1110944:	72b61f61 	movk	w1, #0xb0fb, lsl #16
 1110948:	b9002401 	str	w1, [x0, #36]
}
 111094c:	d65f03c0 	ret

0000000001110950 <sm3_update>:
	if (!ilen)
 1110950:	b4000042 	cbz	x2, 1110958 <sm3_update+0x8>
 1110954:	17ffffa8 	b	11107f4 <sm3_update.part.0>
}
 1110958:	d65f03c0 	ret

000000000111095c <sm3_final>:
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

void sm3_final(struct sm3_context *ctx, uint8_t output[32])
{
 111095c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!

	PUT_UINT32_BE(high, msglen, 0);
	PUT_UINT32_BE(low,  msglen, 4);

	last = ctx->total[0] & 0x3F;
	padn = (last < 56) ? (56 - last) : (120 - last);
 1110960:	52800703 	mov	w3, #0x38                  	// #56
{
 1110964:	910003fd 	mov	x29, sp
 1110968:	a90153f3 	stp	x19, x20, [sp, #16]
 111096c:	aa0103f4 	mov	x20, x1
 1110970:	aa0003f3 	mov	x19, x0
	high = (ctx->total[0] >> 29) | (ctx->total[1] <<  3);
 1110974:	29400801 	ldp	w1, w2, [x0]
 1110978:	13817442 	extr	w2, w2, w1, #29
 111097c:	5ac00842 	rev	w2, w2
	PUT_UINT32_BE(high, msglen, 0);
 1110980:	b9002be2 	str	w2, [sp, #40]
	low  = ctx->total[0] << 3;
 1110984:	531d7022 	lsl	w2, w1, #3
	last = ctx->total[0] & 0x3F;
 1110988:	12001421 	and	w1, w1, #0x3f
	padn = (last < 56) ? (56 - last) : (120 - last);
 111098c:	4b010063 	sub	w3, w3, w1
 1110990:	7100dc3f 	cmp	w1, #0x37
 1110994:	5ac00842 	rev	w2, w2
	PUT_UINT32_BE(low,  msglen, 4);
 1110998:	b9002fe2 	str	w2, [sp, #44]
	padn = (last < 56) ? (56 - last) : (120 - last);
 111099c:	52800f02 	mov	w2, #0x78                  	// #120
 11109a0:	4b010042 	sub	w2, w2, w1

	sm3_update(ctx, sm3_padding, padn);
 11109a4:	1a838042 	csel	w2, w2, w3, hi  // hi = pmore
 11109a8:	f0000201 	adrp	x1, 1153000 <__func__.3477+0x91>
 11109ac:	91380421 	add	x1, x1, #0xe01
 11109b0:	97ffffe8 	bl	1110950 <sm3_update>
	if (!ilen)
 11109b4:	9100a3e1 	add	x1, sp, #0x28
 11109b8:	aa1303e0 	mov	x0, x19
 11109bc:	d2800102 	mov	x2, #0x8                   	// #8
 11109c0:	97ffff8d 	bl	11107f4 <sm3_update.part.0>
	sm3_update(ctx, msglen, 8);

	PUT_UINT32_BE(ctx->state[0], output,  0);
 11109c4:	39402e60 	ldrb	w0, [x19, #11]
 11109c8:	39000280 	strb	w0, [x20]
 11109cc:	79401660 	ldrh	w0, [x19, #10]
 11109d0:	39000680 	strb	w0, [x20, #1]
 11109d4:	b9400a60 	ldr	w0, [x19, #8]
 11109d8:	53087c00 	lsr	w0, w0, #8
 11109dc:	39000a80 	strb	w0, [x20, #2]
 11109e0:	b9400a60 	ldr	w0, [x19, #8]
 11109e4:	39000e80 	strb	w0, [x20, #3]
	PUT_UINT32_BE(ctx->state[1], output,  4);
 11109e8:	39403e60 	ldrb	w0, [x19, #15]
 11109ec:	39001280 	strb	w0, [x20, #4]
 11109f0:	79401e60 	ldrh	w0, [x19, #14]
 11109f4:	39001680 	strb	w0, [x20, #5]
 11109f8:	b9400e60 	ldr	w0, [x19, #12]
 11109fc:	53087c00 	lsr	w0, w0, #8
 1110a00:	39001a80 	strb	w0, [x20, #6]
 1110a04:	b9400e60 	ldr	w0, [x19, #12]
 1110a08:	39001e80 	strb	w0, [x20, #7]
	PUT_UINT32_BE(ctx->state[2], output,  8);
 1110a0c:	39404e60 	ldrb	w0, [x19, #19]
 1110a10:	39002280 	strb	w0, [x20, #8]
 1110a14:	79402660 	ldrh	w0, [x19, #18]
 1110a18:	39002680 	strb	w0, [x20, #9]
 1110a1c:	b9401260 	ldr	w0, [x19, #16]
 1110a20:	53087c00 	lsr	w0, w0, #8
 1110a24:	39002a80 	strb	w0, [x20, #10]
 1110a28:	b9401260 	ldr	w0, [x19, #16]
 1110a2c:	39002e80 	strb	w0, [x20, #11]
	PUT_UINT32_BE(ctx->state[3], output, 12);
 1110a30:	39405e60 	ldrb	w0, [x19, #23]
 1110a34:	39003280 	strb	w0, [x20, #12]
 1110a38:	79402e60 	ldrh	w0, [x19, #22]
 1110a3c:	39003680 	strb	w0, [x20, #13]
 1110a40:	b9401660 	ldr	w0, [x19, #20]
 1110a44:	53087c00 	lsr	w0, w0, #8
 1110a48:	39003a80 	strb	w0, [x20, #14]
 1110a4c:	b9401660 	ldr	w0, [x19, #20]
 1110a50:	39003e80 	strb	w0, [x20, #15]
	PUT_UINT32_BE(ctx->state[4], output, 16);
 1110a54:	39406e60 	ldrb	w0, [x19, #27]
 1110a58:	39004280 	strb	w0, [x20, #16]
 1110a5c:	79403660 	ldrh	w0, [x19, #26]
 1110a60:	39004680 	strb	w0, [x20, #17]
 1110a64:	b9401a60 	ldr	w0, [x19, #24]
 1110a68:	53087c00 	lsr	w0, w0, #8
 1110a6c:	39004a80 	strb	w0, [x20, #18]
 1110a70:	b9401a60 	ldr	w0, [x19, #24]
 1110a74:	39004e80 	strb	w0, [x20, #19]
	PUT_UINT32_BE(ctx->state[5], output, 20);
 1110a78:	39407e60 	ldrb	w0, [x19, #31]
 1110a7c:	39005280 	strb	w0, [x20, #20]
 1110a80:	79403e60 	ldrh	w0, [x19, #30]
 1110a84:	39005680 	strb	w0, [x20, #21]
 1110a88:	b9401e60 	ldr	w0, [x19, #28]
 1110a8c:	53087c00 	lsr	w0, w0, #8
 1110a90:	39005a80 	strb	w0, [x20, #22]
 1110a94:	b9401e60 	ldr	w0, [x19, #28]
 1110a98:	39005e80 	strb	w0, [x20, #23]
	PUT_UINT32_BE(ctx->state[6], output, 24);
 1110a9c:	39408e60 	ldrb	w0, [x19, #35]
 1110aa0:	39006280 	strb	w0, [x20, #24]
 1110aa4:	79404660 	ldrh	w0, [x19, #34]
 1110aa8:	39006680 	strb	w0, [x20, #25]
 1110aac:	b9402260 	ldr	w0, [x19, #32]
 1110ab0:	53087c00 	lsr	w0, w0, #8
 1110ab4:	39006a80 	strb	w0, [x20, #26]
 1110ab8:	b9402260 	ldr	w0, [x19, #32]
 1110abc:	39006e80 	strb	w0, [x20, #27]
	PUT_UINT32_BE(ctx->state[7], output, 28);
 1110ac0:	39409e60 	ldrb	w0, [x19, #39]
 1110ac4:	39007280 	strb	w0, [x20, #28]
 1110ac8:	79404e60 	ldrh	w0, [x19, #38]
 1110acc:	39007680 	strb	w0, [x20, #29]
 1110ad0:	b9402660 	ldr	w0, [x19, #36]
 1110ad4:	53087c00 	lsr	w0, w0, #8
 1110ad8:	39007a80 	strb	w0, [x20, #30]
 1110adc:	b9402660 	ldr	w0, [x19, #36]
 1110ae0:	39007e80 	strb	w0, [x20, #31]
}
 1110ae4:	a94153f3 	ldp	x19, x20, [sp, #16]
 1110ae8:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1110aec:	d65f03c0 	ret

0000000001110af0 <sm3>:

void sm3(const uint8_t *input, size_t ilen, uint8_t output[32])
{
 1110af0:	a9ad7bfd 	stp	x29, x30, [sp, #-304]!
 1110af4:	910003fd 	mov	x29, sp
 1110af8:	a90153f3 	stp	x19, x20, [sp, #16]
 1110afc:	aa0203f4 	mov	x20, x2
	struct sm3_context ctx = { };
 1110b00:	910123f3 	add	x19, sp, #0x48
{
 1110b04:	f9001bf7 	str	x23, [sp, #48]
	struct sm3_context ctx = { };
 1110b08:	d2801d17 	mov	x23, #0xe8                  	// #232
 1110b0c:	aa1703e2 	mov	x2, x23
{
 1110b10:	a9025bf5 	stp	x21, x22, [sp, #32]
 1110b14:	aa0103f6 	mov	x22, x1
	struct sm3_context ctx = { };
 1110b18:	52800001 	mov	w1, #0x0                   	// #0
{
 1110b1c:	aa0003f5 	mov	x21, x0
	struct sm3_context ctx = { };
 1110b20:	aa1303e0 	mov	x0, x19
 1110b24:	9400cc6f 	bl	1143ce0 <memset>

	sm3_init(&ctx);
 1110b28:	aa1303e0 	mov	x0, x19
 1110b2c:	97ffff6f 	bl	11108e8 <sm3_init>
	sm3_update(&ctx, input, ilen);
 1110b30:	aa1603e2 	mov	x2, x22
 1110b34:	aa1503e1 	mov	x1, x21
 1110b38:	97ffff86 	bl	1110950 <sm3_update>
	sm3_final(&ctx, output);
 1110b3c:	aa1403e1 	mov	x1, x20
 1110b40:	aa1303e0 	mov	x0, x19
 1110b44:	97ffff86 	bl	111095c <sm3_final>

	memzero_explicit(&ctx, sizeof(ctx));
 1110b48:	aa1703e1 	mov	x1, x23
 1110b4c:	aa1303e0 	mov	x0, x19
 1110b50:	9400d12c 	bl	1145000 <memzero_explicit>
}
 1110b54:	a94153f3 	ldp	x19, x20, [sp, #16]
 1110b58:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1110b5c:	f9401bf7 	ldr	x23, [sp, #48]
 1110b60:	a8d37bfd 	ldp	x29, x30, [sp], #304
 1110b64:	d65f03c0 	ret

0000000001110b68 <sm3_hmac_init>:

void sm3_hmac_init(struct sm3_context *ctx, const uint8_t *key, size_t keylen)
{
 1110b68:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
	size_t i;
	uint8_t sum[32];

	if (keylen > 64) {
 1110b6c:	f101005f 	cmp	x2, #0x40
{
 1110b70:	910003fd 	mov	x29, sp
 1110b74:	a90153f3 	stp	x19, x20, [sp, #16]
 1110b78:	aa0003f3 	mov	x19, x0
 1110b7c:	aa0203f4 	mov	x20, x2
 1110b80:	a9025bf5 	stp	x21, x22, [sp, #32]
 1110b84:	aa0103f5 	mov	x21, x1
	if (keylen > 64) {
 1110b88:	54000109 	b.ls	1110ba8 <sm3_hmac_init+0x40>  // b.plast
		sm3(key, keylen, sum);
 1110b8c:	9100c3f6 	add	x22, sp, #0x30
 1110b90:	aa1503e0 	mov	x0, x21
		keylen = 32;
		key = sum;
 1110b94:	aa1603f5 	mov	x21, x22
		sm3(key, keylen, sum);
 1110b98:	aa1403e1 	mov	x1, x20
		keylen = 32;
 1110b9c:	d2800414 	mov	x20, #0x20                  	// #32
		sm3(key, keylen, sum);
 1110ba0:	aa1603e2 	mov	x2, x22
 1110ba4:	97ffffd3 	bl	1110af0 <sm3>
	}

	memset(ctx->ipad, 0x36, 64);
 1110ba8:	9101a276 	add	x22, x19, #0x68
 1110bac:	d2800802 	mov	x2, #0x40                  	// #64
 1110bb0:	528006c1 	mov	w1, #0x36                  	// #54
 1110bb4:	aa1603e0 	mov	x0, x22
 1110bb8:	9400cc4a 	bl	1143ce0 <memset>
	memset(ctx->opad, 0x5C, 64);
 1110bbc:	52800b81 	mov	w1, #0x5c                  	// #92
 1110bc0:	9102a260 	add	x0, x19, #0xa8
 1110bc4:	d2800802 	mov	x2, #0x40                  	// #64
 1110bc8:	9400cc46 	bl	1143ce0 <memset>

	for (i = 0; i < keylen; i++) {
 1110bcc:	aa1603e0 	mov	x0, x22
 1110bd0:	d2800001 	mov	x1, #0x0                   	// #0
 1110bd4:	eb01029f 	cmp	x20, x1
 1110bd8:	540001a1 	b.ne	1110c0c <sm3_hmac_init+0xa4>  // b.any
		ctx->ipad[i] ^= key[i];
		ctx->opad[i] ^= key[i];
	}

	sm3_init(ctx);
 1110bdc:	aa1303e0 	mov	x0, x19
 1110be0:	97ffff42 	bl	11108e8 <sm3_init>
	if (!ilen)
 1110be4:	d2800802 	mov	x2, #0x40                  	// #64
 1110be8:	aa1603e1 	mov	x1, x22
 1110bec:	97ffff02 	bl	11107f4 <sm3_update.part.0>
	sm3_update(ctx, ctx->ipad, 64);

	memzero_explicit(sum, sizeof(sum));
 1110bf0:	9100c3e0 	add	x0, sp, #0x30
 1110bf4:	d2800401 	mov	x1, #0x20                  	// #32
 1110bf8:	9400d102 	bl	1145000 <memzero_explicit>
}
 1110bfc:	a94153f3 	ldp	x19, x20, [sp, #16]
 1110c00:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1110c04:	a8c57bfd 	ldp	x29, x30, [sp], #80
 1110c08:	d65f03c0 	ret
		ctx->ipad[i] ^= key[i];
 1110c0c:	38616aa3 	ldrb	w3, [x21, x1]
 1110c10:	91000400 	add	x0, x0, #0x1
 1110c14:	385ff002 	ldurb	w2, [x0, #-1]
 1110c18:	4a030042 	eor	w2, w2, w3
 1110c1c:	381ff002 	sturb	w2, [x0, #-1]
		ctx->opad[i] ^= key[i];
 1110c20:	3940fc02 	ldrb	w2, [x0, #63]
 1110c24:	38616aa3 	ldrb	w3, [x21, x1]
	for (i = 0; i < keylen; i++) {
 1110c28:	91000421 	add	x1, x1, #0x1
		ctx->opad[i] ^= key[i];
 1110c2c:	4a030042 	eor	w2, w2, w3
 1110c30:	3900fc02 	strb	w2, [x0, #63]
	for (i = 0; i < keylen; i++) {
 1110c34:	17ffffe8 	b	1110bd4 <sm3_hmac_init+0x6c>

0000000001110c38 <sm3_hmac_update>:

void sm3_hmac_update(struct sm3_context *ctx, const uint8_t *input, size_t ilen)
{
	sm3_update(ctx, input, ilen);
 1110c38:	17ffff46 	b	1110950 <sm3_update>

0000000001110c3c <sm3_hmac_final>:
}

void sm3_hmac_final(struct sm3_context *ctx, uint8_t output[32])
{
 1110c3c:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 1110c40:	910003fd 	mov	x29, sp
 1110c44:	a90153f3 	stp	x19, x20, [sp, #16]
	uint8_t tmpbuf[32];

	sm3_final(ctx, tmpbuf);
 1110c48:	9100c3f4 	add	x20, sp, #0x30
{
 1110c4c:	aa0003f3 	mov	x19, x0
 1110c50:	f90013f5 	str	x21, [sp, #32]
 1110c54:	aa0103f5 	mov	x21, x1
	sm3_final(ctx, tmpbuf);
 1110c58:	aa1403e1 	mov	x1, x20
 1110c5c:	97ffff40 	bl	111095c <sm3_final>
	sm3_init(ctx);
 1110c60:	aa1303e0 	mov	x0, x19
 1110c64:	97ffff21 	bl	11108e8 <sm3_init>
	if (!ilen)
 1110c68:	9102a261 	add	x1, x19, #0xa8
 1110c6c:	d2800802 	mov	x2, #0x40                  	// #64
 1110c70:	97fffee1 	bl	11107f4 <sm3_update.part.0>
 1110c74:	d2800402 	mov	x2, #0x20                  	// #32
 1110c78:	aa1403e1 	mov	x1, x20
 1110c7c:	aa1303e0 	mov	x0, x19
 1110c80:	97fffedd 	bl	11107f4 <sm3_update.part.0>
	sm3_update(ctx, ctx->opad, 64);
	sm3_update(ctx, tmpbuf, 32);
	sm3_final(ctx, output);
 1110c84:	aa1503e1 	mov	x1, x21
 1110c88:	aa1303e0 	mov	x0, x19
 1110c8c:	97ffff34 	bl	111095c <sm3_final>

	memzero_explicit(tmpbuf, sizeof(tmpbuf));
 1110c90:	aa1403e0 	mov	x0, x20
 1110c94:	d2800401 	mov	x1, #0x20                  	// #32
 1110c98:	9400d0da 	bl	1145000 <memzero_explicit>
}
 1110c9c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1110ca0:	f94013f5 	ldr	x21, [sp, #32]
 1110ca4:	a8c57bfd 	ldp	x29, x30, [sp], #80
 1110ca8:	d65f03c0 	ret

0000000001110cac <to_hash_ctx>:

static const struct crypto_hash_ops sm3_hash_ops;

static struct sm3_hash_ctx *to_hash_ctx(struct crypto_hash_ctx *ctx)
{
	assert(ctx && ctx->ops == &sm3_hash_ops);
 1110cac:	b40000c0 	cbz	x0, 1110cc4 <to_hash_ctx+0x18>
 1110cb0:	f9400002 	ldr	x2, [x0]
 1110cb4:	f0000241 	adrp	x1, 115b000 <__vcore_unpg_rw_start>
 1110cb8:	911ae021 	add	x1, x1, #0x6b8
 1110cbc:	eb01005f 	cmp	x2, x1
 1110cc0:	54000180 	b.eq	1110cf0 <to_hash_ctx+0x44>  // b.none
 1110cc4:	f0000203 	adrp	x3, 1153000 <__func__.3477+0x91>
 1110cc8:	f0000201 	adrp	x1, 1153000 <__func__.3477+0x91>
 1110ccc:	9139e463 	add	x3, x3, #0xe79
 1110cd0:	91390421 	add	x1, x1, #0xe41
 1110cd4:	f0000200 	adrp	x0, 1153000 <__func__.3477+0x91>
 1110cd8:	91396000 	add	x0, x0, #0xe58
{
 1110cdc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	assert(ctx && ctx->ops == &sm3_hash_ops);
 1110ce0:	528003c2 	mov	w2, #0x1e                  	// #30
{
 1110ce4:	910003fd 	mov	x29, sp
	assert(ctx && ctx->ops == &sm3_hash_ops);
 1110ce8:	94000571 	bl	11122ac <_assert_log>
 1110cec:	94000581 	bl	11122f0 <_assert_break>

	return container_of(ctx, struct sm3_hash_ctx, hash_ctx);
}
 1110cf0:	d65f03c0 	ret

0000000001110cf4 <op_sm3_hash_copy_state>:
	free(hc);
}

static void op_sm3_hash_copy_state(struct crypto_hash_ctx *dst_ctx,
				   struct crypto_hash_ctx *src_ctx)
{
 1110cf4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1110cf8:	910003fd 	mov	x29, sp
 1110cfc:	a90153f3 	stp	x19, x20, [sp, #16]
 1110d00:	aa0003f4 	mov	x20, x0
 1110d04:	aa0103e0 	mov	x0, x1
	struct sm3_hash_ctx *src = to_hash_ctx(src_ctx);
 1110d08:	97ffffe9 	bl	1110cac <to_hash_ctx>
 1110d0c:	aa0003f3 	mov	x19, x0
	struct sm3_hash_ctx *dst = to_hash_ctx(dst_ctx);
 1110d10:	aa1403e0 	mov	x0, x20
 1110d14:	97ffffe6 	bl	1110cac <to_hash_ctx>

	dst->sm3_ctx = src->sm3_ctx;
 1110d18:	91002261 	add	x1, x19, #0x8
 1110d1c:	d2801d02 	mov	x2, #0xe8                  	// #232
 1110d20:	91002000 	add	x0, x0, #0x8
 1110d24:	97ffc99b 	bl	1103390 <memcpy>
}
 1110d28:	a94153f3 	ldp	x19, x20, [sp, #16]
 1110d2c:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1110d30:	d65f03c0 	ret

0000000001110d34 <op_sm3_hash_free_ctx>:
{
 1110d34:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1110d38:	910003fd 	mov	x29, sp
 1110d3c:	f9000bf3 	str	x19, [sp, #16]
	struct sm3_hash_ctx *hc = to_hash_ctx(ctx);
 1110d40:	97ffffdb 	bl	1110cac <to_hash_ctx>
	memzero_explicit(&hc->sm3_ctx, sizeof(hc->sm3_ctx));
 1110d44:	d2801d01 	mov	x1, #0xe8                  	// #232
	struct sm3_hash_ctx *hc = to_hash_ctx(ctx);
 1110d48:	aa0003f3 	mov	x19, x0
	memzero_explicit(&hc->sm3_ctx, sizeof(hc->sm3_ctx));
 1110d4c:	91002000 	add	x0, x0, #0x8
 1110d50:	9400d0ac 	bl	1145000 <memzero_explicit>
	free(hc);
 1110d54:	aa1303e0 	mov	x0, x19
}
 1110d58:	f9400bf3 	ldr	x19, [sp, #16]
 1110d5c:	a8c27bfd 	ldp	x29, x30, [sp], #32
	free(hc);
 1110d60:	1400ca20 	b	11435e0 <free>

0000000001110d64 <op_sm3_hash_final>:
{
 1110d64:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 1110d68:	910003fd 	mov	x29, sp
 1110d6c:	a90153f3 	stp	x19, x20, [sp, #16]
 1110d70:	aa0103f4 	mov	x20, x1
 1110d74:	aa0203f3 	mov	x19, x2
 1110d78:	f90013f5 	str	x21, [sp, #32]
	struct sm3_hash_ctx *hc = to_hash_ctx(ctx);
 1110d7c:	97ffffcc 	bl	1110cac <to_hash_ctx>
	uint8_t block_digest[TEE_SM3_HASH_SIZE] = { 0 };
 1110d80:	a9037fff 	stp	xzr, xzr, [sp, #48]
 1110d84:	a9047fff 	stp	xzr, xzr, [sp, #64]
	if (len == 0)
 1110d88:	b40001f3 	cbz	x19, 1110dc4 <op_sm3_hash_final+0x60>
		tmp_digest = digest;
 1110d8c:	f100827f 	cmp	x19, #0x20
 1110d90:	9100c3f5 	add	x21, sp, #0x30
 1110d94:	9a9432b5 	csel	x21, x21, x20, cc  // cc = lo, ul, last
	sm3_final(&hc->sm3_ctx, tmp_digest);
 1110d98:	91002000 	add	x0, x0, #0x8
 1110d9c:	aa1503e1 	mov	x1, x21
 1110da0:	97fffeef 	bl	111095c <sm3_final>
	if (hash_size > len)
 1110da4:	f1007e7f 	cmp	x19, #0x1f
 1110da8:	540000a8 	b.hi	1110dbc <op_sm3_hash_final+0x58>  // b.pmore
		memcpy(digest, tmp_digest, len);
 1110dac:	aa1303e2 	mov	x2, x19
 1110db0:	aa1503e1 	mov	x1, x21
 1110db4:	aa1403e0 	mov	x0, x20
 1110db8:	97ffc976 	bl	1103390 <memcpy>
	return TEE_SUCCESS;
 1110dbc:	52800000 	mov	w0, #0x0                   	// #0
 1110dc0:	14000002 	b	1110dc8 <op_sm3_hash_final+0x64>
		return TEE_ERROR_BAD_PARAMETERS;
 1110dc4:	129fff20 	mov	w0, #0xffff0006            	// #-65530
}
 1110dc8:	a94153f3 	ldp	x19, x20, [sp, #16]
 1110dcc:	f94013f5 	ldr	x21, [sp, #32]
 1110dd0:	a8c57bfd 	ldp	x29, x30, [sp], #80
 1110dd4:	d65f03c0 	ret

0000000001110dd8 <op_sm3_hash_update>:
{
 1110dd8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1110ddc:	910003fd 	mov	x29, sp
 1110de0:	a90153f3 	stp	x19, x20, [sp, #16]
 1110de4:	aa0103f3 	mov	x19, x1
 1110de8:	aa0203f4 	mov	x20, x2
	sm3_update(&to_hash_ctx(ctx)->sm3_ctx, data, len);
 1110dec:	97ffffb0 	bl	1110cac <to_hash_ctx>
 1110df0:	91002000 	add	x0, x0, #0x8
 1110df4:	aa1403e2 	mov	x2, x20
 1110df8:	aa1303e1 	mov	x1, x19
 1110dfc:	97fffed5 	bl	1110950 <sm3_update>
}
 1110e00:	52800000 	mov	w0, #0x0                   	// #0
 1110e04:	a94153f3 	ldp	x19, x20, [sp, #16]
 1110e08:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1110e0c:	d65f03c0 	ret

0000000001110e10 <op_sm3_hash_init>:
{
 1110e10:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 1110e14:	910003fd 	mov	x29, sp
	sm3_init(&to_hash_ctx(ctx)->sm3_ctx);
 1110e18:	97ffffa5 	bl	1110cac <to_hash_ctx>
 1110e1c:	91002000 	add	x0, x0, #0x8
 1110e20:	97fffeb2 	bl	11108e8 <sm3_init>
}
 1110e24:	52800000 	mov	w0, #0x0                   	// #0
 1110e28:	a8c17bfd 	ldp	x29, x30, [sp], #16
 1110e2c:	d65f03c0 	ret

0000000001110e30 <crypto_sm3_alloc_ctx>:
	.free_ctx = op_sm3_hash_free_ctx,
	.copy_state = op_sm3_hash_copy_state,
};

TEE_Result crypto_sm3_alloc_ctx(struct crypto_hash_ctx **ctx)
{
 1110e30:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	struct sm3_hash_ctx *hc = NULL;

	hc = calloc(1, sizeof(*hc));
 1110e34:	d2801e01 	mov	x1, #0xf0                  	// #240
{
 1110e38:	910003fd 	mov	x29, sp
 1110e3c:	f9000bf3 	str	x19, [sp, #16]
 1110e40:	aa0003f3 	mov	x19, x0
	hc = calloc(1, sizeof(*hc));
 1110e44:	d2800020 	mov	x0, #0x1                   	// #1
 1110e48:	9400c9a2 	bl	11434d0 <calloc>
	if (!hc)
 1110e4c:	b4000120 	cbz	x0, 1110e70 <crypto_sm3_alloc_ctx+0x40>
		return TEE_ERROR_OUT_OF_MEMORY;

	hc->hash_ctx.ops = &sm3_hash_ops;
 1110e50:	f0000241 	adrp	x1, 115b000 <__vcore_unpg_rw_start>
 1110e54:	911ae021 	add	x1, x1, #0x6b8

	*ctx = &hc->hash_ctx;
 1110e58:	f9000260 	str	x0, [x19]
	hc->hash_ctx.ops = &sm3_hash_ops;
 1110e5c:	f9000001 	str	x1, [x0]

	return TEE_SUCCESS;
 1110e60:	52800000 	mov	w0, #0x0                   	// #0
}
 1110e64:	f9400bf3 	ldr	x19, [sp, #16]
 1110e68:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1110e6c:	d65f03c0 	ret
		return TEE_ERROR_OUT_OF_MEMORY;
 1110e70:	129ffe60 	mov	w0, #0xffff000c            	// #-65524
 1110e74:	17fffffc 	b	1110e64 <crypto_sm3_alloc_ctx+0x34>

0000000001110e78 <to_hmac_ctx>:

static const struct crypto_mac_ops sm3_hmac_ops;

static struct sm3_hmac_ctx *to_hmac_ctx(struct crypto_mac_ctx *ctx)
{
	assert(ctx && ctx->ops == &sm3_hmac_ops);
 1110e78:	b40000c0 	cbz	x0, 1110e90 <to_hmac_ctx+0x18>
 1110e7c:	f9400002 	ldr	x2, [x0]
 1110e80:	f0000241 	adrp	x1, 115b000 <__vcore_unpg_rw_start>
 1110e84:	911b8021 	add	x1, x1, #0x6e0
 1110e88:	eb01005f 	cmp	x2, x1
 1110e8c:	54000180 	b.eq	1110ebc <to_hmac_ctx+0x44>  // b.none
 1110e90:	f0000203 	adrp	x3, 1153000 <__func__.3477+0x91>
 1110e94:	f0000201 	adrp	x1, 1153000 <__func__.3477+0x91>
 1110e98:	913af463 	add	x3, x3, #0xebd
 1110e9c:	913a1421 	add	x1, x1, #0xe85
 1110ea0:	f0000200 	adrp	x0, 1153000 <__func__.3477+0x91>
 1110ea4:	913a7000 	add	x0, x0, #0xe9c
{
 1110ea8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	assert(ctx && ctx->ops == &sm3_hmac_ops);
 1110eac:	528003c2 	mov	w2, #0x1e                  	// #30
{
 1110eb0:	910003fd 	mov	x29, sp
	assert(ctx && ctx->ops == &sm3_hmac_ops);
 1110eb4:	940004fe 	bl	11122ac <_assert_log>
 1110eb8:	9400050e 	bl	11122f0 <_assert_break>

	return container_of(ctx, struct sm3_hmac_ctx, mac_ctx);
}
 1110ebc:	d65f03c0 	ret

0000000001110ec0 <op_sm3_hmac_copy_state>:
	free(c);
}

static void op_sm3_hmac_copy_state(struct crypto_mac_ctx *dst_ctx,
				 struct crypto_mac_ctx *src_ctx)
{
 1110ec0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1110ec4:	910003fd 	mov	x29, sp
 1110ec8:	a90153f3 	stp	x19, x20, [sp, #16]
 1110ecc:	aa0003f4 	mov	x20, x0
 1110ed0:	aa0103e0 	mov	x0, x1
	struct sm3_hmac_ctx *src = to_hmac_ctx(src_ctx);
 1110ed4:	97ffffe9 	bl	1110e78 <to_hmac_ctx>
 1110ed8:	aa0003f3 	mov	x19, x0
	struct sm3_hmac_ctx *dst = to_hmac_ctx(dst_ctx);
 1110edc:	aa1403e0 	mov	x0, x20
 1110ee0:	97ffffe6 	bl	1110e78 <to_hmac_ctx>

	dst->sm3_ctx = src->sm3_ctx;
 1110ee4:	91002261 	add	x1, x19, #0x8
 1110ee8:	d2801d02 	mov	x2, #0xe8                  	// #232
 1110eec:	91002000 	add	x0, x0, #0x8
 1110ef0:	97ffc928 	bl	1103390 <memcpy>
}
 1110ef4:	a94153f3 	ldp	x19, x20, [sp, #16]
 1110ef8:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1110efc:	d65f03c0 	ret

0000000001110f00 <op_sm3_hmac_free_ctx>:
{
 1110f00:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1110f04:	910003fd 	mov	x29, sp
 1110f08:	f9000bf3 	str	x19, [sp, #16]
	struct sm3_hmac_ctx *c = to_hmac_ctx(ctx);
 1110f0c:	97ffffdb 	bl	1110e78 <to_hmac_ctx>
	memzero_explicit(&c->sm3_ctx, sizeof(c->sm3_ctx));
 1110f10:	d2801d01 	mov	x1, #0xe8                  	// #232
	struct sm3_hmac_ctx *c = to_hmac_ctx(ctx);
 1110f14:	aa0003f3 	mov	x19, x0
	memzero_explicit(&c->sm3_ctx, sizeof(c->sm3_ctx));
 1110f18:	91002000 	add	x0, x0, #0x8
 1110f1c:	9400d039 	bl	1145000 <memzero_explicit>
	free(c);
 1110f20:	aa1303e0 	mov	x0, x19
}
 1110f24:	f9400bf3 	ldr	x19, [sp, #16]
 1110f28:	a8c27bfd 	ldp	x29, x30, [sp], #32
	free(c);
 1110f2c:	1400c9ad 	b	11435e0 <free>

0000000001110f30 <op_sm3_hmac_final>:
{
 1110f30:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 1110f34:	910003fd 	mov	x29, sp
 1110f38:	a90153f3 	stp	x19, x20, [sp, #16]
 1110f3c:	aa0103f4 	mov	x20, x1
 1110f40:	aa0203f3 	mov	x19, x2
 1110f44:	f90013f5 	str	x21, [sp, #32]
	struct sm3_hmac_ctx *c = to_hmac_ctx(ctx);
 1110f48:	97ffffcc 	bl	1110e78 <to_hmac_ctx>
	uint8_t block_digest[TEE_SM3_HASH_SIZE] = { 0 };
 1110f4c:	a9037fff 	stp	xzr, xzr, [sp, #48]
 1110f50:	a9047fff 	stp	xzr, xzr, [sp, #64]
	if (len == 0)
 1110f54:	b40001f3 	cbz	x19, 1110f90 <op_sm3_hmac_final+0x60>
		tmp_digest = digest;
 1110f58:	f100827f 	cmp	x19, #0x20
 1110f5c:	9100c3f5 	add	x21, sp, #0x30
 1110f60:	9a9432b5 	csel	x21, x21, x20, cc  // cc = lo, ul, last
	sm3_hmac_final(&c->sm3_ctx, tmp_digest);
 1110f64:	91002000 	add	x0, x0, #0x8
 1110f68:	aa1503e1 	mov	x1, x21
 1110f6c:	97ffff34 	bl	1110c3c <sm3_hmac_final>
	if (hmac_size > len)
 1110f70:	f1007e7f 	cmp	x19, #0x1f
 1110f74:	540000a8 	b.hi	1110f88 <op_sm3_hmac_final+0x58>  // b.pmore
		memcpy(digest, tmp_digest, len);
 1110f78:	aa1303e2 	mov	x2, x19
 1110f7c:	aa1503e1 	mov	x1, x21
 1110f80:	aa1403e0 	mov	x0, x20
 1110f84:	97ffc903 	bl	1103390 <memcpy>
	return TEE_SUCCESS;
 1110f88:	52800000 	mov	w0, #0x0                   	// #0
 1110f8c:	14000002 	b	1110f94 <op_sm3_hmac_final+0x64>
		return TEE_ERROR_BAD_PARAMETERS;
 1110f90:	129fff20 	mov	w0, #0xffff0006            	// #-65530
}
 1110f94:	a94153f3 	ldp	x19, x20, [sp, #16]
 1110f98:	f94013f5 	ldr	x21, [sp, #32]
 1110f9c:	a8c57bfd 	ldp	x29, x30, [sp], #80
 1110fa0:	d65f03c0 	ret

0000000001110fa4 <op_sm3_hmac_update>:
{
 1110fa4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1110fa8:	910003fd 	mov	x29, sp
 1110fac:	a90153f3 	stp	x19, x20, [sp, #16]
 1110fb0:	aa0103f3 	mov	x19, x1
 1110fb4:	aa0203f4 	mov	x20, x2
	sm3_hmac_update(&to_hmac_ctx(ctx)->sm3_ctx, data, len);
 1110fb8:	97ffffb0 	bl	1110e78 <to_hmac_ctx>
 1110fbc:	91002000 	add	x0, x0, #0x8
 1110fc0:	aa1403e2 	mov	x2, x20
 1110fc4:	aa1303e1 	mov	x1, x19
 1110fc8:	97ffff1c 	bl	1110c38 <sm3_hmac_update>
}
 1110fcc:	52800000 	mov	w0, #0x0                   	// #0
 1110fd0:	a94153f3 	ldp	x19, x20, [sp, #16]
 1110fd4:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1110fd8:	d65f03c0 	ret

0000000001110fdc <op_sm3_hmac_init>:
{
 1110fdc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1110fe0:	910003fd 	mov	x29, sp
 1110fe4:	a90153f3 	stp	x19, x20, [sp, #16]
 1110fe8:	aa0103f3 	mov	x19, x1
 1110fec:	aa0203f4 	mov	x20, x2
	sm3_hmac_init(&to_hmac_ctx(ctx)->sm3_ctx, key, len);
 1110ff0:	97ffffa2 	bl	1110e78 <to_hmac_ctx>
 1110ff4:	91002000 	add	x0, x0, #0x8
 1110ff8:	aa1403e2 	mov	x2, x20
 1110ffc:	aa1303e1 	mov	x1, x19
 1111000:	97fffeda 	bl	1110b68 <sm3_hmac_init>
}
 1111004:	52800000 	mov	w0, #0x0                   	// #0
 1111008:	a94153f3 	ldp	x19, x20, [sp, #16]
 111100c:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1111010:	d65f03c0 	ret

0000000001111014 <crypto_hmac_sm3_alloc_ctx>:
	.free_ctx = op_sm3_hmac_free_ctx,
	.copy_state = op_sm3_hmac_copy_state,
};

TEE_Result crypto_hmac_sm3_alloc_ctx(struct crypto_mac_ctx **ctx)
{
 1111014:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	struct sm3_hmac_ctx *c = NULL;

	c = calloc(1, sizeof(*c));
 1111018:	d2801e01 	mov	x1, #0xf0                  	// #240
{
 111101c:	910003fd 	mov	x29, sp
 1111020:	f9000bf3 	str	x19, [sp, #16]
 1111024:	aa0003f3 	mov	x19, x0
	c = calloc(1, sizeof(*c));
 1111028:	d2800020 	mov	x0, #0x1                   	// #1
 111102c:	9400c929 	bl	11434d0 <calloc>
	if (!c)
 1111030:	b4000120 	cbz	x0, 1111054 <crypto_hmac_sm3_alloc_ctx+0x40>
		return TEE_ERROR_OUT_OF_MEMORY;

	c->mac_ctx.ops = &sm3_hmac_ops;
 1111034:	d0000241 	adrp	x1, 115b000 <__vcore_unpg_rw_start>
 1111038:	911b8021 	add	x1, x1, #0x6e0

	*ctx = &c->mac_ctx;
 111103c:	f9000260 	str	x0, [x19]
	c->mac_ctx.ops = &sm3_hmac_ops;
 1111040:	f9000001 	str	x1, [x0]

	return TEE_SUCCESS;
 1111044:	52800000 	mov	w0, #0x0                   	// #0
}
 1111048:	f9400bf3 	ldr	x19, [sp, #16]
 111104c:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1111050:	d65f03c0 	ret
		return TEE_ERROR_OUT_OF_MEMORY;
 1111054:	129ffe60 	mov	w0, #0xffff000c            	// #-65524
 1111058:	17fffffc 	b	1111048 <crypto_hmac_sm3_alloc_ctx+0x34>

000000000111105c <sm4_setkey>:
{
	uint32_t MK[4];
	uint32_t k[36];
	uint32_t i = 0;

	GET_UINT32_BE(MK[0], key, 0);
 111105c:	39400024 	ldrb	w4, [x1]
{
 1111060:	d10243ff 	sub	sp, sp, #0x90
 1111064:	39400422 	ldrb	w2, [x1, #1]
	k[2] = MK[2] ^ FK[2];
	k[3] = MK[3] ^ FK[3];

	for (i = 0; i < 32; i++) {
		k[i + 4] = k[i] ^ sm4CalciRK(k[i + 1] ^ k[i + 2] ^ k[i + 3] ^
					     CK[i]);
 1111068:	b00001e7 	adrp	x7, 114e000 <ldelf_data+0x8000>
 111106c:	39401023 	ldrb	w3, [x1, #4]
 1111070:	911890e7 	add	x7, x7, #0x624
 1111074:	39402425 	ldrb	w5, [x1, #9]
 1111078:	aa022082 	orr	x2, x4, x2, lsl #8
 111107c:	39400824 	ldrb	w4, [x1, #2]
 1111080:	39403026 	ldrb	w6, [x1, #12]
 1111084:	aa044042 	orr	x2, x2, x4, lsl #16
 1111088:	39400c24 	ldrb	w4, [x1, #3]
 111108c:	aa046044 	orr	x4, x2, x4, lsl #24
 1111090:	39401422 	ldrb	w2, [x1, #5]
 1111094:	5ac00884 	rev	w4, w4
	GET_UINT32_BE(MK[1], key, 4);
 1111098:	aa022062 	orr	x2, x3, x2, lsl #8
 111109c:	39401823 	ldrb	w3, [x1, #6]
 11110a0:	aa034042 	orr	x2, x2, x3, lsl #16
 11110a4:	39401c23 	ldrb	w3, [x1, #7]
 11110a8:	aa036043 	orr	x3, x2, x3, lsl #24
 11110ac:	39402022 	ldrb	w2, [x1, #8]
 11110b0:	5ac00863 	rev	w3, w3
	GET_UINT32_BE(MK[2], key, 8);
 11110b4:	aa052045 	orr	x5, x2, x5, lsl #8
 11110b8:	39402822 	ldrb	w2, [x1, #10]
 11110bc:	aa0240a5 	orr	x5, x5, x2, lsl #16
 11110c0:	39402c22 	ldrb	w2, [x1, #11]
 11110c4:	aa0260a2 	orr	x2, x5, x2, lsl #24
 11110c8:	39403425 	ldrb	w5, [x1, #13]
 11110cc:	5ac00842 	rev	w2, w2
	GET_UINT32_BE(MK[3], key, 12);
 11110d0:	aa0520c6 	orr	x6, x6, x5, lsl #8
 11110d4:	39403825 	ldrb	w5, [x1, #14]
 11110d8:	39403c21 	ldrb	w1, [x1, #15]
 11110dc:	aa0540c5 	orr	x5, x6, x5, lsl #16
 11110e0:	aa0160a1 	orr	x1, x5, x1, lsl #24
	k[0] = MK[0] ^ FK[0];
 11110e4:	529758c5 	mov	w5, #0xbac6                	// #47814
 11110e8:	72b47625 	movk	w5, #0xa3b1, lsl #16
 11110ec:	4a050084 	eor	w4, w4, w5
 11110f0:	b90003e4 	str	w4, [sp]
	k[1] = MK[1] ^ FK[1];
 11110f4:	52866a04 	mov	w4, #0x3350                	// #13136
 11110f8:	72aad544 	movk	w4, #0x56aa, lsl #16
 11110fc:	4a040063 	eor	w3, w3, w4
 1111100:	b90007e3 	str	w3, [sp, #4]
	k[2] = MK[2] ^ FK[2];
 1111104:	529232e3 	mov	w3, #0x9197                	// #37271
 1111108:	72acefa3 	movk	w3, #0x677d, lsl #16
 111110c:	4a030042 	eor	w2, w2, w3
 1111110:	5ac00821 	rev	w1, w1
	return tab[inch];
 1111114:	d0000204 	adrp	x4, 1153000 <__func__.3477+0x91>
 1111118:	910003e3 	mov	x3, sp
 111111c:	913ba884 	add	x4, x4, #0xeea
	k[2] = MK[2] ^ FK[2];
 1111120:	b9000be2 	str	w2, [sp, #8]
	k[3] = MK[3] ^ FK[3];
 1111124:	52845b82 	mov	w2, #0x22dc                	// #8924
 1111128:	72b64e02 	movk	w2, #0xb270, lsl #16
 111112c:	d2800005 	mov	x5, #0x0                   	// #0
 1111130:	4a020021 	eor	w1, w1, w2
 1111134:	b9000fe1 	str	w1, [sp, #12]
		k[i + 4] = k[i] ^ sm4CalciRK(k[i + 1] ^ k[i + 2] ^ k[i + 3] ^
 1111138:	29408861 	ldp	w1, w2, [x3, #4]
 111113c:	91001063 	add	x3, x3, #0x4
 1111140:	b86768a6 	ldr	w6, [x5, x7]
 1111144:	4a020021 	eor	w1, w1, w2
 1111148:	b9400862 	ldr	w2, [x3, #8]
 111114c:	4a060042 	eor	w2, w2, w6
 1111150:	4a020021 	eor	w1, w1, w2
	return tab[inch];
 1111154:	d3483c26 	ubfx	x6, x1, #8, #8
 1111158:	d3505c22 	ubfx	x2, x1, #16, #8
	GET_UINT32_BE(bb, b, 0);
 111115c:	38666886 	ldrb	w6, [x4, x6]
 1111160:	38626882 	ldrb	w2, [x4, x2]
 1111164:	53185cc6 	lsl	w6, w6, #8
 1111168:	2a0240c2 	orr	w2, w6, w2, lsl #16
	return tab[inch];
 111116c:	53187c26 	lsr	w6, w1, #24
 1111170:	92401c21 	and	x1, x1, #0xff
	GET_UINT32_BE(bb, b, 0);
 1111174:	38666886 	ldrb	w6, [x4, x6]
 1111178:	38616881 	ldrb	w1, [x4, x1]
 111117c:	2a066021 	orr	w1, w1, w6, lsl #24
		k[i + 4] = k[i] ^ sm4CalciRK(k[i + 1] ^ k[i + 2] ^ k[i + 3] ^
 1111180:	b85fc066 	ldur	w6, [x3, #-4]
	GET_UINT32_BE(bb, b, 0);
 1111184:	2a010041 	orr	w1, w2, w1
	return bb ^ ROTL(bb, 13) ^ ROTL(bb, 23);
 1111188:	13812422 	ror	w2, w1, #9
		k[i + 4] = k[i] ^ sm4CalciRK(k[i + 1] ^ k[i + 2] ^ k[i + 3] ^
 111118c:	4ac14c42 	eor	w2, w2, w1, ror #19
 1111190:	4a060021 	eor	w1, w1, w6
 1111194:	4a010041 	eor	w1, w2, w1
		SK[i] = k[i + 4];
 1111198:	b8256801 	str	w1, [x0, x5]
		k[i + 4] = k[i] ^ sm4CalciRK(k[i + 1] ^ k[i + 2] ^ k[i + 3] ^
 111119c:	b9000c61 	str	w1, [x3, #12]
	for (i = 0; i < 32; i++) {
 11111a0:	910010a5 	add	x5, x5, #0x4
 11111a4:	f10200bf 	cmp	x5, #0x80
 11111a8:	54fffc81 	b.ne	1111138 <sm4_setkey+0xdc>  // b.any
	}
}
 11111ac:	910243ff 	add	sp, sp, #0x90
 11111b0:	d65f03c0 	ret

00000000011111b4 <sm4_one_round>:

static void sm4_one_round(uint32_t sk[32], const uint8_t input[16],
			  uint8_t output[16])
{
 11111b4:	a9b47bfd 	stp	x29, x30, [sp, #-192]!
	uint32_t i = 0;
	uint32_t ulbuf[36];

	memset(ulbuf, 0, sizeof(ulbuf));
 11111b8:	9100c3e3 	add	x3, sp, #0x30
{
 11111bc:	910003fd 	mov	x29, sp
 11111c0:	a90153f3 	stp	x19, x20, [sp, #16]
 11111c4:	aa0103f4 	mov	x20, x1
 11111c8:	aa0203f3 	mov	x19, x2
	memset(ulbuf, 0, sizeof(ulbuf));
 11111cc:	52800001 	mov	w1, #0x0                   	// #0
 11111d0:	d2801002 	mov	x2, #0x80                  	// #128
{
 11111d4:	a9025bf5 	stp	x21, x22, [sp, #32]
	memset(ulbuf, 0, sizeof(ulbuf));
 11111d8:	aa0303f5 	mov	x21, x3
{
 11111dc:	aa0003f6 	mov	x22, x0
	memset(ulbuf, 0, sizeof(ulbuf));
 11111e0:	91004060 	add	x0, x3, #0x10
 11111e4:	9400cabf 	bl	1143ce0 <memset>

	GET_UINT32_BE(ulbuf[0], input, 0);
 11111e8:	39400280 	ldrb	w0, [x20]
	return tab[inch];
 11111ec:	d0000204 	adrp	x4, 1153000 <__func__.3477+0x91>
 11111f0:	39400681 	ldrb	w1, [x20, #1]
 11111f4:	aa1503e3 	mov	x3, x21
 11111f8:	913ba884 	add	x4, x4, #0xeea
 11111fc:	aa012001 	orr	x1, x0, x1, lsl #8
 1111200:	39400a80 	ldrb	w0, [x20, #2]
 1111204:	aa004021 	orr	x1, x1, x0, lsl #16
 1111208:	39400e80 	ldrb	w0, [x20, #3]
 111120c:	aa006020 	orr	x0, x1, x0, lsl #24
 1111210:	39401681 	ldrb	w1, [x20, #5]
 1111214:	5ac00800 	rev	w0, w0
	GET_UINT32_BE(ulbuf[0], input, 0);
 1111218:	b90033e0 	str	w0, [sp, #48]
	GET_UINT32_BE(ulbuf[1], input, 4);
 111121c:	39401280 	ldrb	w0, [x20, #4]
 1111220:	aa012001 	orr	x1, x0, x1, lsl #8
 1111224:	39401a80 	ldrb	w0, [x20, #6]
 1111228:	aa004021 	orr	x1, x1, x0, lsl #16
 111122c:	39401e80 	ldrb	w0, [x20, #7]
 1111230:	aa006020 	orr	x0, x1, x0, lsl #24
 1111234:	39402281 	ldrb	w1, [x20, #8]
 1111238:	5ac00800 	rev	w0, w0
 111123c:	b90037e0 	str	w0, [sp, #52]
	GET_UINT32_BE(ulbuf[2], input, 8);
 1111240:	39402680 	ldrb	w0, [x20, #9]
 1111244:	aa002020 	orr	x0, x1, x0, lsl #8
 1111248:	39402a81 	ldrb	w1, [x20, #10]
 111124c:	aa014000 	orr	x0, x0, x1, lsl #16
 1111250:	39402e81 	ldrb	w1, [x20, #11]
 1111254:	aa016001 	orr	x1, x0, x1, lsl #24
 1111258:	39403680 	ldrb	w0, [x20, #13]
 111125c:	5ac00821 	rev	w1, w1
 1111260:	b9003be1 	str	w1, [sp, #56]
	GET_UINT32_BE(ulbuf[3], input, 12);
 1111264:	39403281 	ldrb	w1, [x20, #12]
 1111268:	aa002020 	orr	x0, x1, x0, lsl #8
 111126c:	39403a81 	ldrb	w1, [x20, #14]
 1111270:	aa014000 	orr	x0, x0, x1, lsl #16
 1111274:	39403e81 	ldrb	w1, [x20, #15]
 1111278:	aa016001 	orr	x1, x0, x1, lsl #24
 111127c:	d2800000 	mov	x0, #0x0                   	// #0
 1111280:	5ac00821 	rev	w1, w1
 1111284:	b9003fe1 	str	w1, [sp, #60]
	return x0 ^ sm4Lt(x1 ^ x2 ^ x3 ^ rk);
 1111288:	29408462 	ldp	w2, w1, [x3, #4]
 111128c:	91001063 	add	x3, x3, #0x4
 1111290:	b8606ac5 	ldr	w5, [x22, x0]
 1111294:	91001000 	add	x0, x0, #0x4
 1111298:	4a010042 	eor	w2, w2, w1
 111129c:	b9400861 	ldr	w1, [x3, #8]

	for (i = 0; i < 32; i++)
 11112a0:	f102001f 	cmp	x0, #0x80
	return x0 ^ sm4Lt(x1 ^ x2 ^ x3 ^ rk);
 11112a4:	4a050021 	eor	w1, w1, w5
 11112a8:	4a010042 	eor	w2, w2, w1
	return tab[inch];
 11112ac:	d3483c45 	ubfx	x5, x2, #8, #8
 11112b0:	d3505c41 	ubfx	x1, x2, #16, #8
	GET_UINT32_BE(bb, b, 0);
 11112b4:	38656885 	ldrb	w5, [x4, x5]
 11112b8:	38616881 	ldrb	w1, [x4, x1]
 11112bc:	53185ca5 	lsl	w5, w5, #8
 11112c0:	2a0140a1 	orr	w1, w5, w1, lsl #16
	return tab[inch];
 11112c4:	53187c45 	lsr	w5, w2, #24
 11112c8:	92401c42 	and	x2, x2, #0xff
	GET_UINT32_BE(bb, b, 0);
 11112cc:	38656885 	ldrb	w5, [x4, x5]
 11112d0:	38626882 	ldrb	w2, [x4, x2]
 11112d4:	2a056042 	orr	w2, w2, w5, lsl #24
	return x0 ^ sm4Lt(x1 ^ x2 ^ x3 ^ rk);
 11112d8:	b85fc065 	ldur	w5, [x3, #-4]
	GET_UINT32_BE(bb, b, 0);
 11112dc:	2a020021 	orr	w1, w1, w2
	return x0 ^ sm4Lt(x1 ^ x2 ^ x3 ^ rk);
 11112e0:	4a050025 	eor	w5, w1, w5
	return bb ^ ROTL(bb, 2) ^ ROTL(bb, 10) ^ ROTL(bb, 18) ^ ROTL(bb, 24);
 11112e4:	13815822 	ror	w2, w1, #22
	return x0 ^ sm4Lt(x1 ^ x2 ^ x3 ^ rk);
 11112e8:	4ac17842 	eor	w2, w2, w1, ror #30
 11112ec:	4a050042 	eor	w2, w2, w5
	return bb ^ ROTL(bb, 2) ^ ROTL(bb, 10) ^ ROTL(bb, 18) ^ ROTL(bb, 24);
 11112f0:	13812025 	ror	w5, w1, #8
	return x0 ^ sm4Lt(x1 ^ x2 ^ x3 ^ rk);
 11112f4:	4ac138a1 	eor	w1, w5, w1, ror #14
 11112f8:	4a010041 	eor	w1, w2, w1
		ulbuf[i + 4] = sm4F(ulbuf[i], ulbuf[i + 1], ulbuf[i + 2],
 11112fc:	b9000c61 	str	w1, [x3, #12]
	for (i = 0; i < 32; i++)
 1111300:	54fffc41 	b.ne	1111288 <sm4_one_round+0xd4>  // b.any
				    ulbuf[i + 3], sk[i]);

	PUT_UINT32_BE(ulbuf[35], output, 0);
 1111304:	b940bfe0 	ldr	w0, [sp, #188]
	PUT_UINT32_BE(ulbuf[34], output, 4);
	PUT_UINT32_BE(ulbuf[33], output, 8);
	PUT_UINT32_BE(ulbuf[32], output, 12);
}
 1111308:	a9425bf5 	ldp	x21, x22, [sp, #32]
	PUT_UINT32_BE(ulbuf[35], output, 0);
 111130c:	39000e60 	strb	w0, [x19, #3]
 1111310:	53187c01 	lsr	w1, w0, #24
 1111314:	39000261 	strb	w1, [x19]
 1111318:	53107c01 	lsr	w1, w0, #16
 111131c:	39000661 	strb	w1, [x19, #1]
 1111320:	53087c01 	lsr	w1, w0, #8
	PUT_UINT32_BE(ulbuf[34], output, 4);
 1111324:	b940bbe0 	ldr	w0, [sp, #184]
	PUT_UINT32_BE(ulbuf[35], output, 0);
 1111328:	39000a61 	strb	w1, [x19, #2]
	PUT_UINT32_BE(ulbuf[34], output, 4);
 111132c:	39001e60 	strb	w0, [x19, #7]
 1111330:	53187c01 	lsr	w1, w0, #24
 1111334:	39001261 	strb	w1, [x19, #4]
 1111338:	53107c01 	lsr	w1, w0, #16
 111133c:	39001661 	strb	w1, [x19, #5]
 1111340:	53087c01 	lsr	w1, w0, #8
	PUT_UINT32_BE(ulbuf[33], output, 8);
 1111344:	b940b7e0 	ldr	w0, [sp, #180]
	PUT_UINT32_BE(ulbuf[34], output, 4);
 1111348:	39001a61 	strb	w1, [x19, #6]
	PUT_UINT32_BE(ulbuf[33], output, 8);
 111134c:	39002e60 	strb	w0, [x19, #11]
 1111350:	53187c01 	lsr	w1, w0, #24
 1111354:	39002261 	strb	w1, [x19, #8]
 1111358:	53107c01 	lsr	w1, w0, #16
 111135c:	39002661 	strb	w1, [x19, #9]
 1111360:	53087c01 	lsr	w1, w0, #8
	PUT_UINT32_BE(ulbuf[32], output, 12);
 1111364:	b940b3e0 	ldr	w0, [sp, #176]
	PUT_UINT32_BE(ulbuf[33], output, 8);
 1111368:	39002a61 	strb	w1, [x19, #10]
	PUT_UINT32_BE(ulbuf[32], output, 12);
 111136c:	39003e60 	strb	w0, [x19, #15]
 1111370:	53187c01 	lsr	w1, w0, #24
 1111374:	39003261 	strb	w1, [x19, #12]
 1111378:	53107c01 	lsr	w1, w0, #16
 111137c:	39003661 	strb	w1, [x19, #13]
 1111380:	53087c01 	lsr	w1, w0, #8
 1111384:	39003a61 	strb	w1, [x19, #14]
}
 1111388:	a94153f3 	ldp	x19, x20, [sp, #16]
 111138c:	a8cc7bfd 	ldp	x29, x30, [sp], #192
 1111390:	d65f03c0 	ret

0000000001111394 <sm4_setkey_enc>:

void sm4_setkey_enc(struct sm4_context *ctx, const uint8_t key[16])
{
	ctx->mode = SM4_ENCRYPT;
 1111394:	52800022 	mov	w2, #0x1                   	// #1
 1111398:	b8004402 	str	w2, [x0], #4
	sm4_setkey(ctx->sk, key);
 111139c:	17ffff30 	b	111105c <sm4_setkey>

00000000011113a0 <sm4_setkey_dec>:
}

void sm4_setkey_dec(struct sm4_context *ctx, const uint8_t key[16])
{
 11113a0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 11113a4:	aa0003e8 	mov	x8, x0
 11113a8:	910003fd 	mov	x29, sp
	int i;

	ctx->mode = SM4_DECRYPT;
 11113ac:	b800441f 	str	wzr, [x0], #4
	sm4_setkey(ctx->sk, key);
 11113b0:	97ffff2b 	bl	111105c <sm4_setkey>

	for (i = 0; i < 16; i++)
 11113b4:	91020101 	add	x1, x8, #0x80
	sm4_setkey(ctx->sk, key);
 11113b8:	d2800020 	mov	x0, #0x1                   	// #1
		SWAP(ctx->sk[i], ctx->sk[31 - i]);
 11113bc:	b9400023 	ldr	w3, [x1]
 11113c0:	b8607902 	ldr	w2, [x8, x0, lsl #2]
 11113c4:	b8207903 	str	w3, [x8, x0, lsl #2]
 11113c8:	91000400 	add	x0, x0, #0x1
 11113cc:	b81fc422 	str	w2, [x1], #-4
	for (i = 0; i < 16; i++)
 11113d0:	f100441f 	cmp	x0, #0x11
 11113d4:	54ffff41 	b.ne	11113bc <sm4_setkey_dec+0x1c>  // b.any
}
 11113d8:	a8c17bfd 	ldp	x29, x30, [sp], #16
 11113dc:	d65f03c0 	ret

00000000011113e0 <sm4_crypt_ecb>:

void sm4_crypt_ecb(struct sm4_context *ctx, size_t length, const uint8_t *input,
		   uint8_t *output)
{
 11113e0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 11113e4:	910003fd 	mov	x29, sp
 11113e8:	a90153f3 	stp	x19, x20, [sp, #16]
	assert(!(length % 16));
 11113ec:	f2400c34 	ands	x20, x1, #0xf
{
 11113f0:	a9025bf5 	stp	x21, x22, [sp, #32]
 11113f4:	f9001bf7 	str	x23, [sp, #48]
	assert(!(length % 16));
 11113f8:	540001c1 	b.ne	1111430 <sm4_crypt_ecb+0x50>  // b.any
 11113fc:	aa0103f3 	mov	x19, x1
 1111400:	aa0203f6 	mov	x22, x2
 1111404:	aa0303f7 	mov	x23, x3

	while (length > 0) {
		sm4_one_round(ctx->sk, input, output);
 1111408:	91001015 	add	x21, x0, #0x4
 111140c:	cb1402e2 	sub	x2, x23, x20
 1111410:	cb1402c1 	sub	x1, x22, x20
	while (length > 0) {
 1111414:	ab14027f 	cmn	x19, x20
 1111418:	540001e1 	b.ne	1111454 <sm4_crypt_ecb+0x74>  // b.any
		input  += 16;
		output += 16;
		length -= 16;
	}
}
 111141c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1111420:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1111424:	f9401bf7 	ldr	x23, [sp, #48]
 1111428:	a8c47bfd 	ldp	x29, x30, [sp], #64
 111142c:	d65f03c0 	ret
	assert(!(length % 16));
 1111430:	d0000203 	adrp	x3, 1153000 <__func__.3477+0x91>
 1111434:	d0000201 	adrp	x1, 1153000 <__func__.3477+0x91>
 1111438:	913fa863 	add	x3, x3, #0xfea
 111143c:	913b2421 	add	x1, x1, #0xec9
 1111440:	d0000200 	adrp	x0, 1153000 <__func__.3477+0x91>
 1111444:	913b6c00 	add	x0, x0, #0xedb
 1111448:	528019c2 	mov	w2, #0xce                  	// #206
 111144c:	94000398 	bl	11122ac <_assert_log>
 1111450:	940003a8 	bl	11122f0 <_assert_break>
		sm4_one_round(ctx->sk, input, output);
 1111454:	aa1503e0 	mov	x0, x21
 1111458:	d1004294 	sub	x20, x20, #0x10
 111145c:	97ffff56 	bl	11111b4 <sm4_one_round>
		length -= 16;
 1111460:	17ffffeb 	b	111140c <sm4_crypt_ecb+0x2c>

0000000001111464 <sm4_crypt_cbc>:

void sm4_crypt_cbc(struct sm4_context *ctx, size_t length, uint8_t iv[16],
		   const uint8_t *input, uint8_t *output)
{
 1111464:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
	int i;
	uint8_t temp[16];

	assert(!(length % 16));
 1111468:	f2400c3f 	tst	x1, #0xf
{
 111146c:	910003fd 	mov	x29, sp
 1111470:	a90153f3 	stp	x19, x20, [sp, #16]
 1111474:	a9025bf5 	stp	x21, x22, [sp, #32]
 1111478:	a90363f7 	stp	x23, x24, [sp, #48]
 111147c:	a9046bf9 	stp	x25, x26, [sp, #64]
 1111480:	f9002bfb 	str	x27, [sp, #80]
	assert(!(length % 16));
 1111484:	54000140 	b.eq	11114ac <sm4_crypt_cbc+0x48>  // b.none
 1111488:	d0000203 	adrp	x3, 1153000 <__func__.3477+0x91>
 111148c:	d0000201 	adrp	x1, 1153000 <__func__.3477+0x91>
 1111490:	913fe063 	add	x3, x3, #0xff8
 1111494:	913b2421 	add	x1, x1, #0xec9
 1111498:	d0000200 	adrp	x0, 1153000 <__func__.3477+0x91>
 111149c:	913b6c00 	add	x0, x0, #0xedb
 11114a0:	52801bc2 	mov	w2, #0xde                  	// #222
 11114a4:	94000382 	bl	11122ac <_assert_log>
 11114a8:	94000392 	bl	11122f0 <_assert_break>
 11114ac:	aa0103f6 	mov	x22, x1

	if (ctx->mode == SM4_ENCRYPT) {
 11114b0:	b9400001 	ldr	w1, [x0]
 11114b4:	aa0203f5 	mov	x21, x2
 11114b8:	aa0303f8 	mov	x24, x3
 11114bc:	aa0403f7 	mov	x23, x4
 11114c0:	7100043f 	cmp	w1, #0x1
 11114c4:	54000720 	b.eq	11115a8 <sm4_crypt_cbc+0x144>  // b.none
			length -= 16;
		}
	} else {
		/* SM4_DECRYPT */
		while (length > 0) {
			memcpy(temp, input, 16);
 11114c8:	910183fb 	add	x27, sp, #0x60
			sm4_one_round(ctx->sk, input, output);
 11114cc:	91001013 	add	x19, x0, #0x4
 11114d0:	d2800014 	mov	x20, #0x0                   	// #0
 11114d4:	8b14031a 	add	x26, x24, x20
 11114d8:	8b1402f9 	add	x25, x23, x20
		while (length > 0) {
 11114dc:	eb1402df 	cmp	x22, x20
 11114e0:	54000560 	b.eq	111158c <sm4_crypt_cbc+0x128>  // b.none
			memcpy(temp, input, 16);
 11114e4:	aa1a03e1 	mov	x1, x26
 11114e8:	d2800202 	mov	x2, #0x10                  	// #16
 11114ec:	aa1b03e0 	mov	x0, x27
 11114f0:	97ffc7a8 	bl	1103390 <memcpy>
			sm4_one_round(ctx->sk, input, output);
 11114f4:	aa1903e2 	mov	x2, x25
 11114f8:	aa1a03e1 	mov	x1, x26
 11114fc:	aa1303e0 	mov	x0, x19
 1111500:	97ffff2d 	bl	11111b4 <sm4_one_round>
 1111504:	d2800002 	mov	x2, #0x0                   	// #0
			for (i = 0; i < 16; i++)
				output[i] = (uint8_t)(output[i] ^ iv[i]);
 1111508:	38626b20 	ldrb	w0, [x25, x2]
 111150c:	38626aa1 	ldrb	w1, [x21, x2]
 1111510:	4a010000 	eor	w0, w0, w1
 1111514:	38226b20 	strb	w0, [x25, x2]
			for (i = 0; i < 16; i++)
 1111518:	91000442 	add	x2, x2, #0x1
 111151c:	f100405f 	cmp	x2, #0x10
 1111520:	54ffff41 	b.ne	1111508 <sm4_crypt_cbc+0xa4>  // b.any
			memcpy(iv, temp, 16);
 1111524:	aa1b03e1 	mov	x1, x27
 1111528:	aa1503e0 	mov	x0, x21
 111152c:	91004294 	add	x20, x20, #0x10
 1111530:	97ffc798 	bl	1103390 <memcpy>
			input  += 16;
			output += 16;
			length -= 16;
 1111534:	17ffffe8 	b	11114d4 <sm4_crypt_cbc+0x70>
 1111538:	d2800014 	mov	x20, #0x0                   	// #0
				output[i] = (uint8_t)(input[i] ^ iv[i]);
 111153c:	38746820 	ldrb	w0, [x1, x20]
 1111540:	38746aa2 	ldrb	w2, [x21, x20]
 1111544:	4a020000 	eor	w0, w0, w2
 1111548:	38346b40 	strb	w0, [x26, x20]
			for (i = 0; i < 16; i++)
 111154c:	91000694 	add	x20, x20, #0x1
 1111550:	f100429f 	cmp	x20, #0x10
 1111554:	54ffff41 	b.ne	111153c <sm4_crypt_cbc+0xd8>  // b.any
			sm4_one_round(ctx->sk, output, output);
 1111558:	d1004339 	sub	x25, x25, #0x10
 111155c:	aa1a03e2 	mov	x2, x26
 1111560:	aa1a03e1 	mov	x1, x26
 1111564:	aa1303e0 	mov	x0, x19
 1111568:	97ffff13 	bl	11111b4 <sm4_one_round>
			memcpy(iv, output, 16);
 111156c:	aa1403e2 	mov	x2, x20
 1111570:	aa1a03e1 	mov	x1, x26
 1111574:	aa1503e0 	mov	x0, x21
 1111578:	97ffc786 	bl	1103390 <memcpy>
			length -= 16;
 111157c:	cb190301 	sub	x1, x24, x25
 1111580:	cb1902fa 	sub	x26, x23, x25
		while (length > 0) {
 1111584:	ab1902df 	cmn	x22, x25
 1111588:	54fffd81 	b.ne	1111538 <sm4_crypt_cbc+0xd4>  // b.any
		}
	}
}
 111158c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1111590:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1111594:	a94363f7 	ldp	x23, x24, [sp, #48]
 1111598:	a9446bf9 	ldp	x25, x26, [sp, #64]
 111159c:	f9402bfb 	ldr	x27, [sp, #80]
 11115a0:	a8c77bfd 	ldp	x29, x30, [sp], #112
 11115a4:	d65f03c0 	ret
			sm4_one_round(ctx->sk, output, output);
 11115a8:	91001013 	add	x19, x0, #0x4
 11115ac:	d2800019 	mov	x25, #0x0                   	// #0
 11115b0:	17fffff3 	b	111157c <sm4_crypt_cbc+0x118>

00000000011115b4 <sm4_crypt_ctr>:

void sm4_crypt_ctr(struct sm4_context *ctx, size_t length, uint8_t ctr[16],
		   const uint8_t *input, uint8_t *output)
{
 11115b4:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
	int i;
	uint8_t temp[16];

	assert(!(length % 16));
 11115b8:	f2400c3f 	tst	x1, #0xf
{
 11115bc:	910003fd 	mov	x29, sp
 11115c0:	a90153f3 	stp	x19, x20, [sp, #16]
 11115c4:	a9025bf5 	stp	x21, x22, [sp, #32]
 11115c8:	a90363f7 	stp	x23, x24, [sp, #48]
 11115cc:	a9046bf9 	stp	x25, x26, [sp, #64]
 11115d0:	f9002bfb 	str	x27, [sp, #80]
	assert(!(length % 16));
 11115d4:	54000261 	b.ne	1111620 <sm4_crypt_ctr+0x6c>  // b.any
 11115d8:	aa0103f6 	mov	x22, x1
 11115dc:	aa0203f3 	mov	x19, x2
 11115e0:	aa0303f7 	mov	x23, x3
 11115e4:	aa0403f8 	mov	x24, x4

	while (length > 0) {
		memcpy(temp, ctr, 16);
 11115e8:	910183f9 	add	x25, sp, #0x60
		sm4_one_round(ctx->sk, ctr, ctr);
 11115ec:	91001015 	add	x21, x0, #0x4
 11115f0:	d2800014 	mov	x20, #0x0                   	// #0
 11115f4:	cb14031b 	sub	x27, x24, x20
 11115f8:	cb1402fa 	sub	x26, x23, x20
	while (length > 0) {
 11115fc:	ab16029f 	cmn	x20, x22
 1111600:	54000221 	b.ne	1111644 <sm4_crypt_ctr+0x90>  // b.any
				break;
		input  += 16;
		output += 16;
		length -= 16;
	}
}
 1111604:	a94153f3 	ldp	x19, x20, [sp, #16]
 1111608:	a9425bf5 	ldp	x21, x22, [sp, #32]
 111160c:	a94363f7 	ldp	x23, x24, [sp, #48]
 1111610:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1111614:	f9402bfb 	ldr	x27, [sp, #80]
 1111618:	a8c77bfd 	ldp	x29, x30, [sp], #112
 111161c:	d65f03c0 	ret
	assert(!(length % 16));
 1111620:	f0000203 	adrp	x3, 1154000 <__func__.1786+0x8>
 1111624:	d0000201 	adrp	x1, 1153000 <__func__.3477+0x91>
 1111628:	91001863 	add	x3, x3, #0x6
 111162c:	913b2421 	add	x1, x1, #0xec9
 1111630:	d0000200 	adrp	x0, 1153000 <__func__.3477+0x91>
 1111634:	913b6c00 	add	x0, x0, #0xedb
 1111638:	52801fe2 	mov	w2, #0xff                  	// #255
 111163c:	9400031c 	bl	11122ac <_assert_log>
 1111640:	9400032c 	bl	11122f0 <_assert_break>
		memcpy(temp, ctr, 16);
 1111644:	aa1303e1 	mov	x1, x19
 1111648:	d2800202 	mov	x2, #0x10                  	// #16
 111164c:	aa1903e0 	mov	x0, x25
 1111650:	97ffc750 	bl	1103390 <memcpy>
		sm4_one_round(ctx->sk, ctr, ctr);
 1111654:	aa1303e2 	mov	x2, x19
 1111658:	aa1303e1 	mov	x1, x19
 111165c:	aa1503e0 	mov	x0, x21
 1111660:	97fffed5 	bl	11111b4 <sm4_one_round>
 1111664:	d2800002 	mov	x2, #0x0                   	// #0
			output[i] = (uint8_t)(input[i] ^ ctr[i]);
 1111668:	38626b40 	ldrb	w0, [x26, x2]
 111166c:	38626a61 	ldrb	w1, [x19, x2]
 1111670:	4a010000 	eor	w0, w0, w1
 1111674:	38226b60 	strb	w0, [x27, x2]
		for (i = 0; i < 16; i++)
 1111678:	91000442 	add	x2, x2, #0x1
 111167c:	f100405f 	cmp	x2, #0x10
 1111680:	54ffff41 	b.ne	1111668 <sm4_crypt_ctr+0xb4>  // b.any
		memcpy(ctr, temp, 16);
 1111684:	aa1903e1 	mov	x1, x25
 1111688:	aa1303e0 	mov	x0, x19
 111168c:	97ffc741 	bl	1103390 <memcpy>
 1111690:	d28001e1 	mov	x1, #0xf                   	// #15
			if (++ctr[i - 1])
 1111694:	38616a60 	ldrb	w0, [x19, x1]
 1111698:	11000400 	add	w0, w0, #0x1
 111169c:	12001c00 	and	w0, w0, #0xff
 11116a0:	38216a60 	strb	w0, [x19, x1]
 11116a4:	35000080 	cbnz	w0, 11116b4 <sm4_crypt_ctr+0x100>
		for (i = 16; i > 0; i--)
 11116a8:	d1000421 	sub	x1, x1, #0x1
 11116ac:	b100043f 	cmn	x1, #0x1
 11116b0:	54ffff21 	b.ne	1111694 <sm4_crypt_ctr+0xe0>  // b.any
		length -= 16;
 11116b4:	d1004294 	sub	x20, x20, #0x10
 11116b8:	17ffffcf 	b	11115f4 <sm4_crypt_ctr+0x40>

00000000011116bc <to_sm4_ecb_ctx>:

static const struct crypto_cipher_ops sm4_ecb_ops;

static struct sm4_ecb_ctx *to_sm4_ecb_ctx(struct crypto_cipher_ctx *ctx)
{
	assert(ctx && ctx->ops == &sm4_ecb_ops);
 11116bc:	b40000c0 	cbz	x0, 11116d4 <to_sm4_ecb_ctx+0x18>
 11116c0:	f9400002 	ldr	x2, [x0]
 11116c4:	d0000241 	adrp	x1, 115b000 <__vcore_unpg_rw_start>
 11116c8:	911c2021 	add	x1, x1, #0x708
 11116cc:	eb01005f 	cmp	x2, x1
 11116d0:	54000180 	b.eq	1111700 <to_sm4_ecb_ctx+0x44>  // b.none
 11116d4:	f0000203 	adrp	x3, 1154000 <__func__.1786+0x8>
 11116d8:	f0000201 	adrp	x1, 1154000 <__func__.1786+0x8>
 11116dc:	91012863 	add	x3, x3, #0x4a
 11116e0:	91005021 	add	x1, x1, #0x14
 11116e4:	f0000200 	adrp	x0, 1154000 <__func__.1786+0x8>
 11116e8:	9100a800 	add	x0, x0, #0x2a
{
 11116ec:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	assert(ctx && ctx->ops == &sm4_ecb_ops);
 11116f0:	52800322 	mov	w2, #0x19                  	// #25
{
 11116f4:	910003fd 	mov	x29, sp
	assert(ctx && ctx->ops == &sm4_ecb_ops);
 11116f8:	940002ed 	bl	11122ac <_assert_log>
 11116fc:	940002fd 	bl	11122f0 <_assert_break>

	return container_of(ctx, struct sm4_ecb_ctx, ctx);
}
 1111700:	d65f03c0 	ret

0000000001111704 <sm4_ecb_copy_state>:
	free(to_sm4_ecb_ctx(ctx));
}

static void sm4_ecb_copy_state(struct crypto_cipher_ctx *dst_ctx,
			       struct crypto_cipher_ctx *src_ctx)
{
 1111704:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1111708:	910003fd 	mov	x29, sp
 111170c:	a90153f3 	stp	x19, x20, [sp, #16]
 1111710:	aa0003f4 	mov	x20, x0
 1111714:	aa0103e0 	mov	x0, x1
	struct sm4_ecb_ctx *src = to_sm4_ecb_ctx(src_ctx);
 1111718:	97ffffe9 	bl	11116bc <to_sm4_ecb_ctx>
 111171c:	aa0003f3 	mov	x19, x0
	struct sm4_ecb_ctx *dst = to_sm4_ecb_ctx(dst_ctx);
 1111720:	aa1403e0 	mov	x0, x20
 1111724:	97ffffe6 	bl	11116bc <to_sm4_ecb_ctx>

	dst->state = src->state;
 1111728:	91002261 	add	x1, x19, #0x8
 111172c:	d2801082 	mov	x2, #0x84                  	// #132
 1111730:	91002000 	add	x0, x0, #0x8
 1111734:	97ffc717 	bl	1103390 <memcpy>
}
 1111738:	a94153f3 	ldp	x19, x20, [sp, #16]
 111173c:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1111740:	d65f03c0 	ret

0000000001111744 <sm4_ecb_free_ctx>:
{
 1111744:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 1111748:	910003fd 	mov	x29, sp
	free(to_sm4_ecb_ctx(ctx));
 111174c:	97ffffdc 	bl	11116bc <to_sm4_ecb_ctx>
}
 1111750:	a8c17bfd 	ldp	x29, x30, [sp], #16
	free(to_sm4_ecb_ctx(ctx));
 1111754:	1400c7a3 	b	11435e0 <free>

0000000001111758 <sm4_ecb_final>:
{
 1111758:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 111175c:	910003fd 	mov	x29, sp
	struct sm4_ecb_ctx *c = to_sm4_ecb_ctx(ctx);
 1111760:	97ffffd7 	bl	11116bc <to_sm4_ecb_ctx>
	memzero_explicit(&c->state, sizeof(c->state));
 1111764:	91002000 	add	x0, x0, #0x8
}
 1111768:	a8c17bfd 	ldp	x29, x30, [sp], #16
	memzero_explicit(&c->state, sizeof(c->state));
 111176c:	d2801081 	mov	x1, #0x84                  	// #132
 1111770:	1400ce24 	b	1145000 <memzero_explicit>

0000000001111774 <sm4_ecb_update>:
{
 1111774:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1111778:	910003fd 	mov	x29, sp
 111177c:	a90153f3 	stp	x19, x20, [sp, #16]
 1111780:	aa0303f3 	mov	x19, x3
 1111784:	aa0203f4 	mov	x20, x2
 1111788:	f90013f5 	str	x21, [sp, #32]
 111178c:	aa0403f5 	mov	x21, x4
	struct sm4_ecb_ctx *c = to_sm4_ecb_ctx(ctx);
 1111790:	97ffffcb 	bl	11116bc <to_sm4_ecb_ctx>
	sm4_crypt_ecb(&c->state, len, data, dst);
 1111794:	91002000 	add	x0, x0, #0x8
 1111798:	aa1503e3 	mov	x3, x21
 111179c:	aa1403e2 	mov	x2, x20
 11117a0:	aa1303e1 	mov	x1, x19
 11117a4:	97ffff0f 	bl	11113e0 <sm4_crypt_ecb>
}
 11117a8:	52800000 	mov	w0, #0x0                   	// #0
 11117ac:	a94153f3 	ldp	x19, x20, [sp, #16]
 11117b0:	f94013f5 	ldr	x21, [sp, #32]
 11117b4:	a8c37bfd 	ldp	x29, x30, [sp], #48
 11117b8:	d65f03c0 	ret

00000000011117bc <sm4_ecb_init>:
{
 11117bc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 11117c0:	910003fd 	mov	x29, sp
 11117c4:	a90153f3 	stp	x19, x20, [sp, #16]
 11117c8:	2a0103f3 	mov	w19, w1
 11117cc:	aa0203f4 	mov	x20, x2
 11117d0:	f90013f5 	str	x21, [sp, #32]
 11117d4:	aa0303f5 	mov	x21, x3
	struct sm4_ecb_ctx *c = to_sm4_ecb_ctx(ctx);
 11117d8:	97ffffb9 	bl	11116bc <to_sm4_ecb_ctx>
	if (key1_len != 16)
 11117dc:	f10042bf 	cmp	x21, #0x10
 11117e0:	540001a1 	b.ne	1111814 <sm4_ecb_init+0x58>  // b.any
	if (mode == TEE_MODE_ENCRYPT)
 11117e4:	91002000 	add	x0, x0, #0x8
		sm4_setkey_enc(&c->state, key1);
 11117e8:	aa1403e1 	mov	x1, x20
	if (mode == TEE_MODE_ENCRYPT)
 11117ec:	350000f3 	cbnz	w19, 1111808 <sm4_ecb_init+0x4c>
		sm4_setkey_enc(&c->state, key1);
 11117f0:	97fffee9 	bl	1111394 <sm4_setkey_enc>
}
 11117f4:	2a1303e0 	mov	w0, w19
 11117f8:	a94153f3 	ldp	x19, x20, [sp, #16]
 11117fc:	f94013f5 	ldr	x21, [sp, #32]
 1111800:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1111804:	d65f03c0 	ret
	return TEE_SUCCESS;
 1111808:	52800013 	mov	w19, #0x0                   	// #0
		sm4_setkey_dec(&c->state, key1);
 111180c:	97fffee5 	bl	11113a0 <sm4_setkey_dec>
 1111810:	17fffff9 	b	11117f4 <sm4_ecb_init+0x38>
		return TEE_ERROR_BAD_STATE;
 1111814:	129fff13 	mov	w19, #0xffff0007            	// #-65529
 1111818:	17fffff7 	b	11117f4 <sm4_ecb_init+0x38>

000000000111181c <crypto_sm4_ecb_alloc_ctx>:
	.free_ctx = sm4_ecb_free_ctx,
	.copy_state = sm4_ecb_copy_state,
};

TEE_Result crypto_sm4_ecb_alloc_ctx(struct crypto_cipher_ctx **ctx_ret)
{
 111181c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	struct sm4_ecb_ctx *c = NULL;

	c = calloc(1, sizeof(*c));
 1111820:	d2801201 	mov	x1, #0x90                  	// #144
{
 1111824:	910003fd 	mov	x29, sp
 1111828:	f9000bf3 	str	x19, [sp, #16]
 111182c:	aa0003f3 	mov	x19, x0
	c = calloc(1, sizeof(*c));
 1111830:	d2800020 	mov	x0, #0x1                   	// #1
 1111834:	9400c727 	bl	11434d0 <calloc>
	if (!c)
 1111838:	b4000120 	cbz	x0, 111185c <crypto_sm4_ecb_alloc_ctx+0x40>
		return TEE_ERROR_OUT_OF_MEMORY;

	c->ctx.ops = &sm4_ecb_ops;
 111183c:	d0000241 	adrp	x1, 115b000 <__vcore_unpg_rw_start>
 1111840:	911c2021 	add	x1, x1, #0x708
	*ctx_ret = &c->ctx;
 1111844:	f9000260 	str	x0, [x19]
	c->ctx.ops = &sm4_ecb_ops;
 1111848:	f9000001 	str	x1, [x0]

	return TEE_SUCCESS;
 111184c:	52800000 	mov	w0, #0x0                   	// #0
}
 1111850:	f9400bf3 	ldr	x19, [sp, #16]
 1111854:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1111858:	d65f03c0 	ret
		return TEE_ERROR_OUT_OF_MEMORY;
 111185c:	129ffe60 	mov	w0, #0xffff000c            	// #-65524
 1111860:	17fffffc 	b	1111850 <crypto_sm4_ecb_alloc_ctx+0x34>

0000000001111864 <to_sm4_cbc_ctx>:

static const struct crypto_cipher_ops sm4_cbc_ops;

static struct sm4_cbc_ctx *to_sm4_cbc_ctx(struct crypto_cipher_ctx *ctx)
{
	assert(ctx && ctx->ops == &sm4_cbc_ops);
 1111864:	b40000c0 	cbz	x0, 111187c <to_sm4_cbc_ctx+0x18>
 1111868:	f9400002 	ldr	x2, [x0]
 111186c:	d0000241 	adrp	x1, 115b000 <__vcore_unpg_rw_start>
 1111870:	911cc021 	add	x1, x1, #0x730
 1111874:	eb01005f 	cmp	x2, x1
 1111878:	54000180 	b.eq	11118a8 <to_sm4_cbc_ctx+0x44>  // b.none
 111187c:	f0000203 	adrp	x3, 1154000 <__func__.1786+0x8>
 1111880:	f0000201 	adrp	x1, 1154000 <__func__.1786+0x8>
 1111884:	91023c63 	add	x3, x3, #0x8f
 1111888:	91016421 	add	x1, x1, #0x59
 111188c:	f0000200 	adrp	x0, 1154000 <__func__.1786+0x8>
 1111890:	9101bc00 	add	x0, x0, #0x6f
{
 1111894:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	assert(ctx && ctx->ops == &sm4_cbc_ops);
 1111898:	52800362 	mov	w2, #0x1b                  	// #27
{
 111189c:	910003fd 	mov	x29, sp
	assert(ctx && ctx->ops == &sm4_cbc_ops);
 11118a0:	94000283 	bl	11122ac <_assert_log>
 11118a4:	94000293 	bl	11122f0 <_assert_break>

	return container_of(ctx, struct sm4_cbc_ctx, ctx);
}
 11118a8:	d65f03c0 	ret

00000000011118ac <sm4_cbc_copy_state>:
	free(to_sm4_cbc_ctx(ctx));
}

static void sm4_cbc_copy_state(struct crypto_cipher_ctx *dst_ctx,
			       struct crypto_cipher_ctx *src_ctx)
{
 11118ac:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 11118b0:	910003fd 	mov	x29, sp
 11118b4:	a90153f3 	stp	x19, x20, [sp, #16]
 11118b8:	aa0003f3 	mov	x19, x0
 11118bc:	aa0103e0 	mov	x0, x1
	struct sm4_cbc_ctx *src = to_sm4_cbc_ctx(src_ctx);
 11118c0:	97ffffe9 	bl	1111864 <to_sm4_cbc_ctx>
 11118c4:	aa0003f4 	mov	x20, x0
	struct sm4_cbc_ctx *dst = to_sm4_cbc_ctx(dst_ctx);
 11118c8:	aa1303e0 	mov	x0, x19
 11118cc:	97ffffe6 	bl	1111864 <to_sm4_cbc_ctx>

	dst->state = src->state;
 11118d0:	91002281 	add	x1, x20, #0x8
	struct sm4_cbc_ctx *dst = to_sm4_cbc_ctx(dst_ctx);
 11118d4:	aa0003f3 	mov	x19, x0
	dst->state = src->state;
 11118d8:	d2801082 	mov	x2, #0x84                  	// #132
 11118dc:	91002000 	add	x0, x0, #0x8
 11118e0:	97ffc6ac 	bl	1103390 <memcpy>
	memcpy(dst->iv, src->iv, sizeof(src->iv));
 11118e4:	91023281 	add	x1, x20, #0x8c
 11118e8:	91023260 	add	x0, x19, #0x8c
}
 11118ec:	a94153f3 	ldp	x19, x20, [sp, #16]
	memcpy(dst->iv, src->iv, sizeof(src->iv));
 11118f0:	d2800202 	mov	x2, #0x10                  	// #16
}
 11118f4:	a8c27bfd 	ldp	x29, x30, [sp], #32
	memcpy(dst->iv, src->iv, sizeof(src->iv));
 11118f8:	17ffc6a6 	b	1103390 <memcpy>

00000000011118fc <sm4_cbc_free_ctx>:
{
 11118fc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 1111900:	910003fd 	mov	x29, sp
	free(to_sm4_cbc_ctx(ctx));
 1111904:	97ffffd8 	bl	1111864 <to_sm4_cbc_ctx>
}
 1111908:	a8c17bfd 	ldp	x29, x30, [sp], #16
	free(to_sm4_cbc_ctx(ctx));
 111190c:	1400c735 	b	11435e0 <free>

0000000001111910 <sm4_cbc_final>:
{
 1111910:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1111914:	910003fd 	mov	x29, sp
 1111918:	f9000bf3 	str	x19, [sp, #16]
	struct sm4_cbc_ctx *c = to_sm4_cbc_ctx(ctx);
 111191c:	97ffffd2 	bl	1111864 <to_sm4_cbc_ctx>
	memzero_explicit(&c->state, sizeof(c->state));
 1111920:	d2801081 	mov	x1, #0x84                  	// #132
	struct sm4_cbc_ctx *c = to_sm4_cbc_ctx(ctx);
 1111924:	aa0003f3 	mov	x19, x0
	memzero_explicit(&c->state, sizeof(c->state));
 1111928:	91002000 	add	x0, x0, #0x8
 111192c:	9400cdb5 	bl	1145000 <memzero_explicit>
	memzero_explicit(&c->iv, sizeof(c->iv));
 1111930:	91023260 	add	x0, x19, #0x8c
 1111934:	d2800201 	mov	x1, #0x10                  	// #16
}
 1111938:	f9400bf3 	ldr	x19, [sp, #16]
 111193c:	a8c27bfd 	ldp	x29, x30, [sp], #32
	memzero_explicit(&c->iv, sizeof(c->iv));
 1111940:	1400cdb0 	b	1145000 <memzero_explicit>

0000000001111944 <sm4_cbc_update>:
{
 1111944:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1111948:	910003fd 	mov	x29, sp
 111194c:	a90153f3 	stp	x19, x20, [sp, #16]
 1111950:	aa0203f4 	mov	x20, x2
 1111954:	aa0303f3 	mov	x19, x3
 1111958:	f90013f5 	str	x21, [sp, #32]
 111195c:	aa0403f5 	mov	x21, x4
	struct sm4_cbc_ctx *c = to_sm4_cbc_ctx(ctx);
 1111960:	97ffffc1 	bl	1111864 <to_sm4_cbc_ctx>
	sm4_crypt_cbc(&c->state, len, c->iv, data, dst);
 1111964:	91023002 	add	x2, x0, #0x8c
 1111968:	aa1503e4 	mov	x4, x21
 111196c:	aa1403e3 	mov	x3, x20
 1111970:	aa1303e1 	mov	x1, x19
 1111974:	91002000 	add	x0, x0, #0x8
 1111978:	97fffebb 	bl	1111464 <sm4_crypt_cbc>
}
 111197c:	52800000 	mov	w0, #0x0                   	// #0
 1111980:	a94153f3 	ldp	x19, x20, [sp, #16]
 1111984:	f94013f5 	ldr	x21, [sp, #32]
 1111988:	a8c37bfd 	ldp	x29, x30, [sp], #48
 111198c:	d65f03c0 	ret

0000000001111990 <sm4_cbc_init>:
{
 1111990:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 1111994:	910003fd 	mov	x29, sp
 1111998:	a90153f3 	stp	x19, x20, [sp, #16]
 111199c:	aa0203f4 	mov	x20, x2
 11119a0:	a9025bf5 	stp	x21, x22, [sp, #32]
 11119a4:	2a0103f6 	mov	w22, w1
 11119a8:	aa0603f5 	mov	x21, x6
 11119ac:	a90363f7 	stp	x23, x24, [sp, #48]
 11119b0:	aa0303f8 	mov	x24, x3
 11119b4:	aa0703f7 	mov	x23, x7
	struct sm4_cbc_ctx *c = to_sm4_cbc_ctx(ctx);
 11119b8:	97ffffab 	bl	1111864 <to_sm4_cbc_ctx>
	if (key1_len != 16 || iv_len != sizeof(c->iv))
 11119bc:	f100431f 	cmp	x24, #0x10
 11119c0:	fa500ae0 	ccmp	x23, #0x10, #0x0, eq  // eq = none
 11119c4:	54000241 	b.ne	1111a0c <sm4_cbc_init+0x7c>  // b.any
 11119c8:	aa0003f3 	mov	x19, x0
		sm4_setkey_enc(&c->state, key1);
 11119cc:	aa1403e1 	mov	x1, x20
 11119d0:	91002000 	add	x0, x0, #0x8
	if (mode == TEE_MODE_ENCRYPT)
 11119d4:	35000196 	cbnz	w22, 1111a04 <sm4_cbc_init+0x74>
		sm4_setkey_enc(&c->state, key1);
 11119d8:	97fffe6f 	bl	1111394 <sm4_setkey_enc>
	memcpy(c->iv, iv, sizeof(c->iv));
 11119dc:	aa1503e1 	mov	x1, x21
 11119e0:	91023260 	add	x0, x19, #0x8c
 11119e4:	d2800202 	mov	x2, #0x10                  	// #16
 11119e8:	97ffc66a 	bl	1103390 <memcpy>
	return TEE_SUCCESS;
 11119ec:	52800000 	mov	w0, #0x0                   	// #0
}
 11119f0:	a94153f3 	ldp	x19, x20, [sp, #16]
 11119f4:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11119f8:	a94363f7 	ldp	x23, x24, [sp, #48]
 11119fc:	a8c47bfd 	ldp	x29, x30, [sp], #64
 1111a00:	d65f03c0 	ret
		sm4_setkey_dec(&c->state, key1);
 1111a04:	97fffe67 	bl	11113a0 <sm4_setkey_dec>
 1111a08:	17fffff5 	b	11119dc <sm4_cbc_init+0x4c>
		return TEE_ERROR_BAD_PARAMETERS;
 1111a0c:	129fff20 	mov	w0, #0xffff0006            	// #-65530
 1111a10:	17fffff8 	b	11119f0 <sm4_cbc_init+0x60>

0000000001111a14 <crypto_sm4_cbc_alloc_ctx>:
	.free_ctx = sm4_cbc_free_ctx,
	.copy_state = sm4_cbc_copy_state,
};

TEE_Result crypto_sm4_cbc_alloc_ctx(struct crypto_cipher_ctx **ctx_ret)
{
 1111a14:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	struct sm4_cbc_ctx *c = NULL;

	c = calloc(1, sizeof(*c));
 1111a18:	d2801401 	mov	x1, #0xa0                  	// #160
{
 1111a1c:	910003fd 	mov	x29, sp
 1111a20:	f9000bf3 	str	x19, [sp, #16]
 1111a24:	aa0003f3 	mov	x19, x0
	c = calloc(1, sizeof(*c));
 1111a28:	d2800020 	mov	x0, #0x1                   	// #1
 1111a2c:	9400c6a9 	bl	11434d0 <calloc>
	if (!c)
 1111a30:	b4000120 	cbz	x0, 1111a54 <crypto_sm4_cbc_alloc_ctx+0x40>
		return TEE_ERROR_OUT_OF_MEMORY;

	c->ctx.ops = &sm4_cbc_ops;
 1111a34:	d0000241 	adrp	x1, 115b000 <__vcore_unpg_rw_start>
 1111a38:	911cc021 	add	x1, x1, #0x730
	*ctx_ret = &c->ctx;
 1111a3c:	f9000260 	str	x0, [x19]
	c->ctx.ops = &sm4_cbc_ops;
 1111a40:	f9000001 	str	x1, [x0]

	return TEE_SUCCESS;
 1111a44:	52800000 	mov	w0, #0x0                   	// #0
}
 1111a48:	f9400bf3 	ldr	x19, [sp, #16]
 1111a4c:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1111a50:	d65f03c0 	ret
		return TEE_ERROR_OUT_OF_MEMORY;
 1111a54:	129ffe60 	mov	w0, #0xffff000c            	// #-65524
 1111a58:	17fffffc 	b	1111a48 <crypto_sm4_cbc_alloc_ctx+0x34>

0000000001111a5c <to_sm4_ctr_ctx>:

static const struct crypto_cipher_ops sm4_ctr_ops;

static struct sm4_ctr_ctx *to_sm4_ctr_ctx(struct crypto_cipher_ctx *ctx)
{
	assert(ctx && ctx->ops == &sm4_ctr_ops);
 1111a5c:	b40000c0 	cbz	x0, 1111a74 <to_sm4_ctr_ctx+0x18>
 1111a60:	f9400002 	ldr	x2, [x0]
 1111a64:	d0000241 	adrp	x1, 115b000 <__vcore_unpg_rw_start>
 1111a68:	911d6021 	add	x1, x1, #0x758
 1111a6c:	eb01005f 	cmp	x2, x1
 1111a70:	54000180 	b.eq	1111aa0 <to_sm4_ctr_ctx+0x44>  // b.none
 1111a74:	f0000203 	adrp	x3, 1154000 <__func__.1786+0x8>
 1111a78:	f0000201 	adrp	x1, 1154000 <__func__.1786+0x8>
 1111a7c:	91035063 	add	x3, x3, #0xd4
 1111a80:	91027821 	add	x1, x1, #0x9e
 1111a84:	f0000200 	adrp	x0, 1154000 <__func__.1786+0x8>
 1111a88:	9102d000 	add	x0, x0, #0xb4
{
 1111a8c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	assert(ctx && ctx->ops == &sm4_ctr_ops);
 1111a90:	52800362 	mov	w2, #0x1b                  	// #27
{
 1111a94:	910003fd 	mov	x29, sp
	assert(ctx && ctx->ops == &sm4_ctr_ops);
 1111a98:	94000205 	bl	11122ac <_assert_log>
 1111a9c:	94000215 	bl	11122f0 <_assert_break>

	return container_of(ctx, struct sm4_ctr_ctx, ctx);
}
 1111aa0:	d65f03c0 	ret

0000000001111aa4 <sm4_ctr_copy_state>:
	free(to_sm4_ctr_ctx(ctx));
}

static void sm4_ctr_copy_state(struct crypto_cipher_ctx *dst_ctx,
			       struct crypto_cipher_ctx *src_ctx)
{
 1111aa4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1111aa8:	910003fd 	mov	x29, sp
 1111aac:	a90153f3 	stp	x19, x20, [sp, #16]
 1111ab0:	aa0003f3 	mov	x19, x0
 1111ab4:	aa0103e0 	mov	x0, x1
	struct sm4_ctr_ctx *src = to_sm4_ctr_ctx(src_ctx);
 1111ab8:	97ffffe9 	bl	1111a5c <to_sm4_ctr_ctx>
 1111abc:	aa0003f4 	mov	x20, x0
	struct sm4_ctr_ctx *dst = to_sm4_ctr_ctx(dst_ctx);
 1111ac0:	aa1303e0 	mov	x0, x19
 1111ac4:	97ffffe6 	bl	1111a5c <to_sm4_ctr_ctx>

	dst->state = src->state;
 1111ac8:	91002281 	add	x1, x20, #0x8
	struct sm4_ctr_ctx *dst = to_sm4_ctr_ctx(dst_ctx);
 1111acc:	aa0003f3 	mov	x19, x0
	dst->state = src->state;
 1111ad0:	d2801082 	mov	x2, #0x84                  	// #132
 1111ad4:	91002000 	add	x0, x0, #0x8
 1111ad8:	97ffc62e 	bl	1103390 <memcpy>
	memcpy(dst->ctr, src->ctr, sizeof(src->ctr));
 1111adc:	91023281 	add	x1, x20, #0x8c
 1111ae0:	91023260 	add	x0, x19, #0x8c
}
 1111ae4:	a94153f3 	ldp	x19, x20, [sp, #16]
	memcpy(dst->ctr, src->ctr, sizeof(src->ctr));
 1111ae8:	d2800202 	mov	x2, #0x10                  	// #16
}
 1111aec:	a8c27bfd 	ldp	x29, x30, [sp], #32
	memcpy(dst->ctr, src->ctr, sizeof(src->ctr));
 1111af0:	17ffc628 	b	1103390 <memcpy>

0000000001111af4 <sm4_ctr_free_ctx>:
{
 1111af4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 1111af8:	910003fd 	mov	x29, sp
	free(to_sm4_ctr_ctx(ctx));
 1111afc:	97ffffd8 	bl	1111a5c <to_sm4_ctr_ctx>
}
 1111b00:	a8c17bfd 	ldp	x29, x30, [sp], #16
	free(to_sm4_ctr_ctx(ctx));
 1111b04:	1400c6b7 	b	11435e0 <free>

0000000001111b08 <sm4_ctr_final>:
{
 1111b08:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1111b0c:	910003fd 	mov	x29, sp
 1111b10:	f9000bf3 	str	x19, [sp, #16]
	struct sm4_ctr_ctx *c = to_sm4_ctr_ctx(ctx);
 1111b14:	97ffffd2 	bl	1111a5c <to_sm4_ctr_ctx>
	memzero_explicit(&c->state, sizeof(c->state));
 1111b18:	d2801081 	mov	x1, #0x84                  	// #132
	struct sm4_ctr_ctx *c = to_sm4_ctr_ctx(ctx);
 1111b1c:	aa0003f3 	mov	x19, x0
	memzero_explicit(&c->state, sizeof(c->state));
 1111b20:	91002000 	add	x0, x0, #0x8
 1111b24:	9400cd37 	bl	1145000 <memzero_explicit>
	memzero_explicit(&c->ctr, sizeof(c->ctr));
 1111b28:	91023260 	add	x0, x19, #0x8c
 1111b2c:	d2800201 	mov	x1, #0x10                  	// #16
}
 1111b30:	f9400bf3 	ldr	x19, [sp, #16]
 1111b34:	a8c27bfd 	ldp	x29, x30, [sp], #32
	memzero_explicit(&c->ctr, sizeof(c->ctr));
 1111b38:	1400cd32 	b	1145000 <memzero_explicit>

0000000001111b3c <sm4_ctr_update>:
{
 1111b3c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1111b40:	910003fd 	mov	x29, sp
 1111b44:	a90153f3 	stp	x19, x20, [sp, #16]
 1111b48:	aa0203f4 	mov	x20, x2
 1111b4c:	aa0303f3 	mov	x19, x3
 1111b50:	f90013f5 	str	x21, [sp, #32]
 1111b54:	aa0403f5 	mov	x21, x4
	struct sm4_ctr_ctx *c = to_sm4_ctr_ctx(ctx);
 1111b58:	97ffffc1 	bl	1111a5c <to_sm4_ctr_ctx>
	sm4_crypt_ctr(&c->state, len, c->ctr, data, dst);
 1111b5c:	91023002 	add	x2, x0, #0x8c
 1111b60:	aa1503e4 	mov	x4, x21
 1111b64:	aa1403e3 	mov	x3, x20
 1111b68:	aa1303e1 	mov	x1, x19
 1111b6c:	91002000 	add	x0, x0, #0x8
 1111b70:	97fffe91 	bl	11115b4 <sm4_crypt_ctr>
}
 1111b74:	52800000 	mov	w0, #0x0                   	// #0
 1111b78:	a94153f3 	ldp	x19, x20, [sp, #16]
 1111b7c:	f94013f5 	ldr	x21, [sp, #32]
 1111b80:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1111b84:	d65f03c0 	ret

0000000001111b88 <sm4_ctr_init>:
{
 1111b88:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 1111b8c:	910003fd 	mov	x29, sp
 1111b90:	a90153f3 	stp	x19, x20, [sp, #16]
 1111b94:	aa0603f4 	mov	x20, x6
 1111b98:	a9025bf5 	stp	x21, x22, [sp, #32]
 1111b9c:	aa0703f6 	mov	x22, x7
 1111ba0:	aa0203f5 	mov	x21, x2
 1111ba4:	f9001bf7 	str	x23, [sp, #48]
 1111ba8:	aa0303f7 	mov	x23, x3
	struct sm4_ctr_ctx *c = to_sm4_ctr_ctx(ctx);
 1111bac:	97ffffac 	bl	1111a5c <to_sm4_ctr_ctx>
	if (key1_len != 16 || iv_len != sizeof(c->ctr))
 1111bb0:	f10042ff 	cmp	x23, #0x10
 1111bb4:	fa500ac0 	ccmp	x22, #0x10, #0x0, eq  // eq = none
 1111bb8:	540001e1 	b.ne	1111bf4 <sm4_ctr_init+0x6c>  // b.any
 1111bbc:	aa0003f3 	mov	x19, x0
	sm4_setkey_enc(&c->state, key1);
 1111bc0:	aa1503e1 	mov	x1, x21
 1111bc4:	91002000 	add	x0, x0, #0x8
 1111bc8:	97fffdf3 	bl	1111394 <sm4_setkey_enc>
	memcpy(c->ctr, iv, sizeof(c->ctr));
 1111bcc:	aa1403e1 	mov	x1, x20
 1111bd0:	91023260 	add	x0, x19, #0x8c
 1111bd4:	d2800202 	mov	x2, #0x10                  	// #16
 1111bd8:	97ffc5ee 	bl	1103390 <memcpy>
	return TEE_SUCCESS;
 1111bdc:	52800000 	mov	w0, #0x0                   	// #0
}
 1111be0:	a94153f3 	ldp	x19, x20, [sp, #16]
 1111be4:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1111be8:	f9401bf7 	ldr	x23, [sp, #48]
 1111bec:	a8c47bfd 	ldp	x29, x30, [sp], #64
 1111bf0:	d65f03c0 	ret
		return TEE_ERROR_BAD_PARAMETERS;
 1111bf4:	129fff20 	mov	w0, #0xffff0006            	// #-65530
 1111bf8:	17fffffa 	b	1111be0 <sm4_ctr_init+0x58>

0000000001111bfc <crypto_sm4_ctr_alloc_ctx>:
	.free_ctx = sm4_ctr_free_ctx,
	.copy_state = sm4_ctr_copy_state,
};

TEE_Result crypto_sm4_ctr_alloc_ctx(struct crypto_cipher_ctx **ctx_ret)
{
 1111bfc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	struct sm4_ctr_ctx *c = NULL;

	c = calloc(1, sizeof(*c));
 1111c00:	d2801401 	mov	x1, #0xa0                  	// #160
{
 1111c04:	910003fd 	mov	x29, sp
 1111c08:	f9000bf3 	str	x19, [sp, #16]
 1111c0c:	aa0003f3 	mov	x19, x0
	c = calloc(1, sizeof(*c));
 1111c10:	d2800020 	mov	x0, #0x1                   	// #1
 1111c14:	9400c62f 	bl	11434d0 <calloc>
	if (!c)
 1111c18:	b4000120 	cbz	x0, 1111c3c <crypto_sm4_ctr_alloc_ctx+0x40>
		return TEE_ERROR_OUT_OF_MEMORY;

	c->ctx.ops = &sm4_ctr_ops;
 1111c1c:	d0000241 	adrp	x1, 115b000 <__vcore_unpg_rw_start>
 1111c20:	911d6021 	add	x1, x1, #0x758
	*ctx_ret = &c->ctx;
 1111c24:	f9000260 	str	x0, [x19]
	c->ctx.ops = &sm4_ctr_ops;
 1111c28:	f9000001 	str	x1, [x0]

	return TEE_SUCCESS;
 1111c2c:	52800000 	mov	w0, #0x0                   	// #0
}
 1111c30:	f9400bf3 	ldr	x19, [sp, #16]
 1111c34:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1111c38:	d65f03c0 	ret
		return TEE_ERROR_OUT_OF_MEMORY;
 1111c3c:	129ffe60 	mov	w0, #0xffff000c            	// #-65524
 1111c40:	17fffffc 	b	1111c30 <crypto_sm4_ctr_alloc_ctx+0x34>

0000000001111c44 <gic_it_raise_sgi.isra.0.part.0>:
	uint32_t mask_cpu = cpu_mask & 0xff;
	uint32_t mask = (mask_id | SHIFT_U32(mask_group, 15) |
		SHIFT_U32(mask_cpu, 16));

	/* Should be Software Generated Interrupt */
	assert(it < NUM_SGI);
 1111c44:	f0000203 	adrp	x3, 1154000 <__func__.1786+0x8>
 1111c48:	f0000201 	adrp	x1, 1154000 <__func__.1786+0x8>
 1111c4c:	910a1c63 	add	x3, x3, #0x287
 1111c50:	91038c21 	add	x1, x1, #0xe3
 1111c54:	f0000200 	adrp	x0, 1154000 <__func__.1786+0x8>
 1111c58:	9103d800 	add	x0, x0, #0xf6
static void gic_it_raise_sgi(struct gic_data *gd, size_t it,
 1111c5c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	assert(it < NUM_SGI);
 1111c60:	52802c22 	mov	w2, #0x161                 	// #353
static void gic_it_raise_sgi(struct gic_data *gd, size_t it,
 1111c64:	910003fd 	mov	x29, sp
	assert(it < NUM_SGI);
 1111c68:	94000191 	bl	11122ac <_assert_log>
 1111c6c:	940001a1 	bl	11122f0 <_assert_break>

0000000001111c70 <gic_op_raise_pi>:

	gic_it_disable(gd, it);
}

static void gic_op_raise_pi(struct itr_chip *chip, size_t it)
{
 1111c70:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 1111c74:	910003fd 	mov	x29, sp
	struct gic_data *gd = container_of(chip, struct gic_data, chip);

	if (it > gd->max_it)
 1111c78:	f85f8002 	ldur	x2, [x0, #-8]
 1111c7c:	eb01005f 	cmp	x2, x1
 1111c80:	54000102 	b.cs	1111ca0 <gic_op_raise_pi+0x30>  // b.hs, b.nlast
		panic();
 1111c84:	f0000202 	adrp	x2, 1154000 <__func__.1786+0x8>
 1111c88:	f0000200 	adrp	x0, 1154000 <__func__.1786+0x8>
 1111c8c:	910b3842 	add	x2, x2, #0x2ce
 1111c90:	91038c00 	add	x0, x0, #0xe3
 1111c94:	d2800003 	mov	x3, #0x0                   	// #0
 1111c98:	52803b81 	mov	w1, #0x1dc                 	// #476
 1111c9c:	940005f3 	bl	1113468 <__do_panic>
	uint32_t mask = BIT32(it % NUM_INTS_PER_REG);
 1111ca0:	52800023 	mov	w3, #0x1                   	// #1
	size_t idx = it / NUM_INTS_PER_REG;
 1111ca4:	d345fc22 	lsr	x2, x1, #5
	assert(it >= NUM_SGI);
 1111ca8:	f1003c3f 	cmp	x1, #0xf
	uint32_t mask = BIT32(it % NUM_INTS_PER_REG);
 1111cac:	1ac12063 	lsl	w3, w3, w1
	assert(it >= NUM_SGI);
 1111cb0:	54000148 	b.hi	1111cd8 <gic_op_raise_pi+0x68>  // b.pmore
 1111cb4:	f0000203 	adrp	x3, 1154000 <__func__.1786+0x8>
 1111cb8:	f0000201 	adrp	x1, 1154000 <__func__.1786+0x8>
 1111cbc:	9109d063 	add	x3, x3, #0x274
 1111cc0:	91038c21 	add	x1, x1, #0xe3
 1111cc4:	f0000200 	adrp	x0, 1154000 <__func__.1786+0x8>
 1111cc8:	91040c00 	add	x0, x0, #0x103
 1111ccc:	52802a22 	mov	w2, #0x151                 	// #337
 1111cd0:	94000177 	bl	11122ac <_assert_log>
 1111cd4:	94000187 	bl	11122f0 <_assert_break>
	io_write32(gd->gicd_base + GICD_ISPENDR(idx), mask);
 1111cd8:	91020041 	add	x1, x2, #0x80
 1111cdc:	f85f0000 	ldur	x0, [x0, #-16]
 1111ce0:	d37ef421 	lsl	x1, x1, #2
	*(volatile uint32_t *)addr = val;
 1111ce4:	b8206823 	str	w3, [x1, x0]

	gic_it_set_pending(gd, it);
}
 1111ce8:	a8c17bfd 	ldp	x29, x30, [sp], #16
 1111cec:	d65f03c0 	ret

0000000001111cf0 <gic_op_disable>:
{
 1111cf0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 1111cf4:	910003fd 	mov	x29, sp
	if (it > gd->max_it)
 1111cf8:	f85f8002 	ldur	x2, [x0, #-8]
 1111cfc:	eb01005f 	cmp	x2, x1
 1111d00:	54000102 	b.cs	1111d20 <gic_op_disable+0x30>  // b.hs, b.nlast
		panic();
 1111d04:	f0000202 	adrp	x2, 1154000 <__func__.1786+0x8>
 1111d08:	f0000200 	adrp	x0, 1154000 <__func__.1786+0x8>
 1111d0c:	910afc42 	add	x2, x2, #0x2bf
 1111d10:	91038c00 	add	x0, x0, #0xe3
 1111d14:	d2800003 	mov	x3, #0x0                   	// #0
 1111d18:	52803a41 	mov	w1, #0x1d2                 	// #466
 1111d1c:	940005d3 	bl	1113468 <__do_panic>
	gic_it_disable(gd, it);
 1111d20:	f85f0002 	ldur	x2, [x0, #-16]
	uint32_t mask = 1 << (it % NUM_INTS_PER_REG);
 1111d24:	52800020 	mov	w0, #0x1                   	// #1
 1111d28:	1ac12000 	lsl	w0, w0, w1
	size_t idx = it / NUM_INTS_PER_REG;
 1111d2c:	d345fc21 	lsr	x1, x1, #5
	assert(!(io_read32(gd->gicd_base + GICD_IGROUPR(idx)) & mask));
 1111d30:	91008021 	add	x1, x1, #0x20
 1111d34:	d37ef421 	lsl	x1, x1, #2
	return *(volatile uint32_t *)addr;
 1111d38:	b8616843 	ldr	w3, [x2, x1]
 1111d3c:	6a03001f 	tst	w0, w3
 1111d40:	54000140 	b.eq	1111d68 <gic_op_disable+0x78>  // b.none
 1111d44:	f0000203 	adrp	x3, 1154000 <__func__.1786+0x8>
 1111d48:	f0000201 	adrp	x1, 1154000 <__func__.1786+0x8>
 1111d4c:	91099463 	add	x3, x3, #0x265
 1111d50:	91038c21 	add	x1, x1, #0xe3
 1111d54:	f0000200 	adrp	x0, 1154000 <__func__.1786+0x8>
 1111d58:	91044400 	add	x0, x0, #0x111
 1111d5c:	528028a2 	mov	w2, #0x145                 	// #325
 1111d60:	94000153 	bl	11122ac <_assert_log>
 1111d64:	94000163 	bl	11122f0 <_assert_break>
	io_write32(gd->gicd_base + GICD_ICENABLER(idx), mask);
 1111d68:	91040021 	add	x1, x1, #0x100
	*(volatile uint32_t *)addr = val;
 1111d6c:	b8226820 	str	w0, [x1, x2]
}
 1111d70:	a8c17bfd 	ldp	x29, x30, [sp], #16
 1111d74:	d65f03c0 	ret

0000000001111d78 <gic_op_enable>:
{
 1111d78:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 1111d7c:	910003fd 	mov	x29, sp
	if (it > gd->max_it)
 1111d80:	f85f8002 	ldur	x2, [x0, #-8]
 1111d84:	eb01005f 	cmp	x2, x1
 1111d88:	54000102 	b.cs	1111da8 <gic_op_enable+0x30>  // b.hs, b.nlast
		panic();
 1111d8c:	f0000202 	adrp	x2, 1154000 <__func__.1786+0x8>
 1111d90:	f0000200 	adrp	x0, 1154000 <__func__.1786+0x8>
 1111d94:	910ac442 	add	x2, x2, #0x2b1
 1111d98:	91038c00 	add	x0, x0, #0xe3
 1111d9c:	d2800003 	mov	x3, #0x0                   	// #0
 1111da0:	52803901 	mov	w1, #0x1c8                 	// #456
 1111da4:	940005b1 	bl	1113468 <__do_panic>
	gic_it_enable(gd, it);
 1111da8:	f85f0003 	ldur	x3, [x0, #-16]
	size_t idx = it / NUM_INTS_PER_REG;
 1111dac:	d345fc20 	lsr	x0, x1, #5
	assert(!(io_read32(base + GICD_IGROUPR(idx)) & mask));
 1111db0:	91008000 	add	x0, x0, #0x20
	uint32_t mask = 1 << (it % NUM_INTS_PER_REG);
 1111db4:	52800022 	mov	w2, #0x1                   	// #1
 1111db8:	1ac12042 	lsl	w2, w2, w1
	assert(!(io_read32(base + GICD_IGROUPR(idx)) & mask));
 1111dbc:	d37ef400 	lsl	x0, x0, #2
	return *(volatile uint32_t *)addr;
 1111dc0:	b8606864 	ldr	w4, [x3, x0]
 1111dc4:	6a04005f 	tst	w2, w4
 1111dc8:	54000140 	b.eq	1111df0 <gic_op_enable+0x78>  // b.none
 1111dcc:	f0000203 	adrp	x3, 1154000 <__func__.1786+0x8>
 1111dd0:	f0000201 	adrp	x1, 1154000 <__func__.1786+0x8>
 1111dd4:	f0000200 	adrp	x0, 1154000 <__func__.1786+0x8>
 1111dd8:	91095c63 	add	x3, x3, #0x257
 1111ddc:	91038c21 	add	x1, x1, #0xe3
 1111de0:	91052000 	add	x0, x0, #0x148
 1111de4:	52802642 	mov	w2, #0x132                 	// #306
		assert(!(io_read32(base + GICD_ISENABLER(idx)) & mask));
 1111de8:	94000131 	bl	11122ac <_assert_log>
 1111dec:	94000141 	bl	11122f0 <_assert_break>
	if (it >= NUM_SGI) {
 1111df0:	91020000 	add	x0, x0, #0x80
 1111df4:	f1003c3f 	cmp	x1, #0xf
 1111df8:	54000189 	b.ls	1111e28 <gic_op_enable+0xb0>  // b.plast
 1111dfc:	b8636801 	ldr	w1, [x0, x3]
		assert(!(io_read32(base + GICD_ISENABLER(idx)) & mask));
 1111e00:	6a01005f 	tst	w2, w1
 1111e04:	54000120 	b.eq	1111e28 <gic_op_enable+0xb0>  // b.none
 1111e08:	f0000203 	adrp	x3, 1154000 <__func__.1786+0x8>
 1111e0c:	f0000201 	adrp	x1, 1154000 <__func__.1786+0x8>
 1111e10:	f0000200 	adrp	x0, 1154000 <__func__.1786+0x8>
 1111e14:	91095c63 	add	x3, x3, #0x257
 1111e18:	91038c21 	add	x1, x1, #0xe3
 1111e1c:	9105d800 	add	x0, x0, #0x176
 1111e20:	52802702 	mov	w2, #0x138                 	// #312
 1111e24:	17fffff1 	b	1111de8 <gic_op_enable+0x70>
	*(volatile uint32_t *)addr = val;
 1111e28:	b8236802 	str	w2, [x0, x3]
}
 1111e2c:	a8c17bfd 	ldp	x29, x30, [sp], #16
 1111e30:	d65f03c0 	ret

0000000001111e34 <gic_it_set_cpu_mask.isra.0>:
	size_t idx __maybe_unused = it / NUM_INTS_PER_REG;
 1111e34:	d345fc23 	lsr	x3, x1, #5
static void gic_it_set_cpu_mask(struct gic_data *gd, size_t it,
 1111e38:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
	assert(!(io_read32(gd->gicd_base + GICD_IGROUPR(idx)) & mask));
 1111e3c:	91008063 	add	x3, x3, #0x20
static void gic_it_set_cpu_mask(struct gic_data *gd, size_t it,
 1111e40:	910003fd 	mov	x29, sp
	assert(!(io_read32(gd->gicd_base + GICD_IGROUPR(idx)) & mask));
 1111e44:	d37ef463 	lsl	x3, x3, #2
static void gic_it_set_cpu_mask(struct gic_data *gd, size_t it,
 1111e48:	a9025bf5 	stp	x21, x22, [sp, #32]
	vaddr_t itargetsr = gd->gicd_base +
 1111e4c:	91200016 	add	x22, x0, #0x800
static void gic_it_set_cpu_mask(struct gic_data *gd, size_t it,
 1111e50:	a90153f3 	stp	x19, x20, [sp, #16]
	vaddr_t itargetsr = gd->gicd_base +
 1111e54:	927ef435 	and	x21, x1, #0xfffffffffffffffc
	return *(volatile uint32_t *)addr;
 1111e58:	b8606860 	ldr	w0, [x3, x0]
static void gic_it_set_cpu_mask(struct gic_data *gd, size_t it,
 1111e5c:	f9001bf7 	str	x23, [sp, #48]
	uint32_t mask __maybe_unused = 1 << (it % NUM_INTS_PER_REG);
 1111e60:	52800037 	mov	w23, #0x1                   	// #1
 1111e64:	1ac122e3 	lsl	w3, w23, w1
	vaddr_t itargetsr = gd->gicd_base +
 1111e68:	8b1502c6 	add	x6, x22, x21
	assert(!(io_read32(gd->gicd_base + GICD_IGROUPR(idx)) & mask));
 1111e6c:	6a00007f 	tst	w3, w0
 1111e70:	f0000203 	adrp	x3, 1154000 <__func__.1786+0x8>
 1111e74:	54000120 	b.eq	1111e98 <gic_it_set_cpu_mask.isra.0+0x64>  // b.none
 1111e78:	9108cc63 	add	x3, x3, #0x233
 1111e7c:	f0000201 	adrp	x1, 1154000 <__func__.1786+0x8>
 1111e80:	f0000200 	adrp	x0, 1154000 <__func__.1786+0x8>
 1111e84:	91038c21 	add	x1, x1, #0xe3
 1111e88:	91044400 	add	x0, x0, #0x111
 1111e8c:	52802222 	mov	w2, #0x111                 	// #273
 1111e90:	94000107 	bl	11122ac <_assert_log>
 1111e94:	94000117 	bl	11122f0 <_assert_break>
 1111e98:	b8756ac5 	ldr	w5, [x22, x21]
	target_shift = (it % NUM_TARGETS_PER_REG) * ITARGETSR_FIELD_BITS;
 1111e9c:	531d0421 	ubfiz	w1, w1, #3, #2
 1111ea0:	12001c42 	and	w2, w2, #0xff
	target &= ~(ITARGETSR_FIELD_MASK << target_shift);
 1111ea4:	52801ff3 	mov	w19, #0xff                  	// #255
 1111ea8:	1ac12273 	lsl	w19, w19, w1
 1111eac:	0a3300b3 	bic	w19, w5, w19
	DMSG("cpu_mask: writing 0x%x to 0x%" PRIxVA, target, itargetsr);
 1111eb0:	9108cc74 	add	x20, x3, #0x233
	target |= cpu_mask << target_shift;
 1111eb4:	1ac12041 	lsl	w1, w2, w1
 1111eb8:	2a130033 	orr	w19, w1, w19
	DMSG("cpu_mask: writing 0x%x to 0x%" PRIxVA, target, itargetsr);
 1111ebc:	2a1703e3 	mov	w3, w23
 1111ec0:	2a1303e5 	mov	w5, w19
 1111ec4:	aa1403e0 	mov	x0, x20
 1111ec8:	52800062 	mov	w2, #0x3                   	// #3
 1111ecc:	52802301 	mov	w1, #0x118                 	// #280
 1111ed0:	f0000204 	adrp	x4, 1154000 <__func__.1786+0x8>
 1111ed4:	91069884 	add	x4, x4, #0x1a6
 1111ed8:	9400cb9b 	bl	1144d44 <trace_printf>
	*(volatile uint32_t *)addr = val;
 1111edc:	b8356ad3 	str	w19, [x22, x21]
	DMSG("cpu_mask: 0x%x", io_read32(itargetsr));
 1111ee0:	2a1703e3 	mov	w3, w23
 1111ee4:	aa1403e0 	mov	x0, x20
	return *(volatile uint32_t *)addr;
 1111ee8:	b8756ac5 	ldr	w5, [x22, x21]
 1111eec:	f0000204 	adrp	x4, 1154000 <__func__.1786+0x8>
}
 1111ef0:	a94153f3 	ldp	x19, x20, [sp, #16]
	DMSG("cpu_mask: 0x%x", io_read32(itargetsr));
 1111ef4:	91071884 	add	x4, x4, #0x1c6
}
 1111ef8:	a9425bf5 	ldp	x21, x22, [sp, #32]
	DMSG("cpu_mask: 0x%x", io_read32(itargetsr));
 1111efc:	52800062 	mov	w2, #0x3                   	// #3
}
 1111f00:	f9401bf7 	ldr	x23, [sp, #48]
	DMSG("cpu_mask: 0x%x", io_read32(itargetsr));
 1111f04:	52802341 	mov	w1, #0x11a                 	// #282
}
 1111f08:	a8c47bfd 	ldp	x29, x30, [sp], #64
	DMSG("cpu_mask: 0x%x", io_read32(itargetsr));
 1111f0c:	1400cb8e 	b	1144d44 <trace_printf>

0000000001111f10 <gic_op_set_affinity>:
static void gic_op_set_affinity(struct itr_chip *chip, size_t it,
			uint8_t cpu_mask)
{
	struct gic_data *gd = container_of(chip, struct gic_data, chip);

	if (it > gd->max_it)
 1111f10:	f85f8003 	ldur	x3, [x0, #-8]
 1111f14:	eb01007f 	cmp	x3, x1
 1111f18:	54000142 	b.cs	1111f40 <gic_op_set_affinity+0x30>  // b.hs, b.nlast
{
 1111f1c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
		panic();
 1111f20:	f0000202 	adrp	x2, 1154000 <__func__.1786+0x8>
 1111f24:	f0000200 	adrp	x0, 1154000 <__func__.1786+0x8>
{
 1111f28:	910003fd 	mov	x29, sp
		panic();
 1111f2c:	910bbc42 	add	x2, x2, #0x2ef
 1111f30:	91038c00 	add	x0, x0, #0xe3
 1111f34:	d2800003 	mov	x3, #0x0                   	// #0
 1111f38:	52803e81 	mov	w1, #0x1f4                 	// #500
 1111f3c:	9400054b 	bl	1113468 <__do_panic>

	gic_it_set_cpu_mask(gd, it, cpu_mask);
 1111f40:	f85f0000 	ldur	x0, [x0, #-16]
 1111f44:	12001c42 	and	w2, w2, #0xff
 1111f48:	17ffffbb 	b	1111e34 <gic_it_set_cpu_mask.isra.0>

0000000001111f4c <gic_op_add>:
{
 1111f4c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 1111f50:	910003fd 	mov	x29, sp
 1111f54:	a9025bf5 	stp	x21, x22, [sp, #32]
 1111f58:	aa0003f5 	mov	x21, x0
	if (it > gd->max_it)
 1111f5c:	f85f8000 	ldur	x0, [x0, #-8]
{
 1111f60:	a90153f3 	stp	x19, x20, [sp, #16]
 1111f64:	f9001bf7 	str	x23, [sp, #48]
	if (it > gd->max_it)
 1111f68:	eb01001f 	cmp	x0, x1
 1111f6c:	54000102 	b.cs	1111f8c <gic_op_add+0x40>  // b.hs, b.nlast
		panic();
 1111f70:	f0000202 	adrp	x2, 1154000 <__func__.1786+0x8>
 1111f74:	f0000200 	adrp	x0, 1154000 <__func__.1786+0x8>
 1111f78:	910a9842 	add	x2, x2, #0x2a6
 1111f7c:	91038c00 	add	x0, x0, #0xe3
 1111f80:	d2800003 	mov	x3, #0x0                   	// #0
 1111f84:	52803761 	mov	w1, #0x1bb                 	// #443
 1111f88:	94000538 	bl	1113468 <__do_panic>
	size_t idx = it / NUM_INTS_PER_REG;
 1111f8c:	d345fc33 	lsr	x19, x1, #5
	uint32_t mask = 1 << (it % NUM_INTS_PER_REG);
 1111f90:	52800036 	mov	w22, #0x1                   	// #1
	io_write32(gd->gicd_base + GICD_ICENABLER(idx), mask);
 1111f94:	91018273 	add	x19, x19, #0x60
	uint32_t mask = 1 << (it % NUM_INTS_PER_REG);
 1111f98:	1ac122d7 	lsl	w23, w22, w1
	gic_it_add(gd, it);
 1111f9c:	f85f02a0 	ldur	x0, [x21, #-16]
	io_write32(gd->gicd_base + GICD_ICENABLER(idx), mask);
 1111fa0:	d37ef673 	lsl	x19, x19, #2
	io_write32(gd->gicd_base + GICD_ICPENDR(idx), mask);
 1111fa4:	91040262 	add	x2, x19, #0x100
 1111fa8:	aa0103f4 	mov	x20, x1
	*(volatile uint32_t *)addr = val;
 1111fac:	b8336817 	str	w23, [x0, x19]
	io_clrbits32(gd->gicd_base + GICD_IGROUPR(idx), mask);
 1111fb0:	d1040273 	sub	x19, x19, #0x100
 1111fb4:	b8206857 	str	w23, [x2, x0]
	return *(volatile uint32_t *)addr;
 1111fb8:	b8736802 	ldr	w2, [x0, x19]
	io_write32(addr, io_read32(addr) | set_mask);
}

static inline void io_clrbits32(vaddr_t addr, uint32_t clear_mask)
{
	io_write32(addr, io_read32(addr) & ~clear_mask);
 1111fbc:	0a370042 	bic	w2, w2, w23
	*(volatile uint32_t *)addr = val;
 1111fc0:	b8336802 	str	w2, [x0, x19]
	gic_it_set_cpu_mask(gd, it, 0xff);
 1111fc4:	12800002 	mov	w2, #0xffffffff            	// #-1
 1111fc8:	97ffff9b 	bl	1111e34 <gic_it_set_cpu_mask.isra.0>
	assert(!(io_read32(gd->gicd_base + GICD_IGROUPR(idx)) & mask));
 1111fcc:	f85f02a6 	ldur	x6, [x21, #-16]
	return *(volatile uint32_t *)addr;
 1111fd0:	b87368c0 	ldr	w0, [x6, x19]
 1111fd4:	6a17001f 	tst	w0, w23
 1111fd8:	f0000200 	adrp	x0, 1154000 <__func__.1786+0x8>
 1111fdc:	54000120 	b.eq	1112000 <gic_op_add+0xb4>  // b.none
 1111fe0:	91091c03 	add	x3, x0, #0x247
 1111fe4:	f0000201 	adrp	x1, 1154000 <__func__.1786+0x8>
 1111fe8:	f0000200 	adrp	x0, 1154000 <__func__.1786+0x8>
 1111fec:	91038c21 	add	x1, x1, #0xe3
 1111ff0:	91044400 	add	x0, x0, #0x111
 1111ff4:	52802462 	mov	w2, #0x123                 	// #291
 1111ff8:	940000ad 	bl	11122ac <_assert_log>
 1111ffc:	940000bd 	bl	11122f0 <_assert_break>
	DMSG("prio: writing 0x%x to 0x%" PRIxVA,
 1112000:	91100294 	add	x20, x20, #0x400
 1112004:	2a1603e5 	mov	w5, w22
 1112008:	8b060286 	add	x6, x20, x6
 111200c:	2a1603e3 	mov	w3, w22
 1112010:	91091c00 	add	x0, x0, #0x247
 1112014:	52800062 	mov	w2, #0x3                   	// #3
 1112018:	528024c1 	mov	w1, #0x126                 	// #294
 111201c:	d0000204 	adrp	x4, 1154000 <__func__.1786+0x8>
 1112020:	91075484 	add	x4, x4, #0x1d5
 1112024:	9400cb48 	bl	1144d44 <trace_printf>
	io_write8(gd->gicd_base + GICD_IPRIORITYR(0) + it, prio);
 1112028:	f85f02a0 	ldur	x0, [x21, #-16]
	*(volatile uint8_t *)addr = val;
 111202c:	38206a96 	strb	w22, [x20, x0]
}
 1112030:	a94153f3 	ldp	x19, x20, [sp, #16]
 1112034:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1112038:	f9401bf7 	ldr	x23, [sp, #48]
 111203c:	a8c47bfd 	ldp	x29, x30, [sp], #64
 1112040:	d65f03c0 	ret

0000000001112044 <gic_op_raise_sgi>:
{
 1112044:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 1112048:	910003fd 	mov	x29, sp
	if (it > gd->max_it)
 111204c:	f85f8003 	ldur	x3, [x0, #-8]
 1112050:	eb01007f 	cmp	x3, x1
 1112054:	54000102 	b.cs	1112074 <gic_op_raise_sgi+0x30>  // b.hs, b.nlast
		panic();
 1112058:	d0000202 	adrp	x2, 1154000 <__func__.1786+0x8>
 111205c:	d0000200 	adrp	x0, 1154000 <__func__.1786+0x8>
 1112060:	910b7842 	add	x2, x2, #0x2de
 1112064:	91038c00 	add	x0, x0, #0xe3
 1112068:	d2800003 	mov	x3, #0x0                   	// #0
 111206c:	52803ce1 	mov	w1, #0x1e7                 	// #487
 1112070:	940004fe 	bl	1113468 <__do_panic>
 1112074:	12001c42 	and	w2, w2, #0xff
	if (it < NUM_NS_SGI)
 1112078:	f1001c3f 	cmp	x1, #0x7
 111207c:	53103c42 	lsl	w2, w2, #16
 1112080:	540000e8 	b.hi	111209c <gic_op_raise_sgi+0x58>  // b.pmore
	uint32_t mask = (mask_id | SHIFT_U32(mask_group, 15) |
 1112084:	2a010042 	orr	w2, w2, w1
 1112088:	32110042 	orr	w2, w2, #0x8000
	io_write32(gd->gicd_base + GICD_SGIR, mask);
 111208c:	f85f0000 	ldur	x0, [x0, #-16]
	*(volatile uint32_t *)addr = val;
 1112090:	b90f0002 	str	w2, [x0, #3840]
}
 1112094:	a8c17bfd 	ldp	x29, x30, [sp], #16
 1112098:	d65f03c0 	ret
	uint32_t mask_id = it & 0xf;
 111209c:	12000c23 	and	w3, w1, #0xf
	assert(it < NUM_SGI);
 11120a0:	f1003c3f 	cmp	x1, #0xf
	uint32_t mask = (mask_id | SHIFT_U32(mask_group, 15) |
 11120a4:	2a020062 	orr	w2, w3, w2
	assert(it < NUM_SGI);
 11120a8:	54ffff29 	b.ls	111208c <gic_op_raise_sgi+0x48>  // b.plast
 11120ac:	97fffee6 	bl	1111c44 <gic_it_raise_sgi.isra.0.part.0>

00000000011120b0 <gic_cpu_init>:
	assert(gd->gicd_base && gd->gicc_base);
 11120b0:	f9400401 	ldr	x1, [x0, #8]
 11120b4:	b4000061 	cbz	x1, 11120c0 <gic_cpu_init+0x10>
 11120b8:	f9400000 	ldr	x0, [x0]
 11120bc:	b5000180 	cbnz	x0, 11120ec <gic_cpu_init+0x3c>
 11120c0:	d0000203 	adrp	x3, 1154000 <__func__.1786+0x8>
 11120c4:	d0000201 	adrp	x1, 1154000 <__func__.1786+0x8>
 11120c8:	91089863 	add	x3, x3, #0x226
 11120cc:	91038c21 	add	x1, x1, #0xe3
 11120d0:	d0000200 	adrp	x0, 1154000 <__func__.1786+0x8>
 11120d4:	9107c400 	add	x0, x0, #0x1f1
{
 11120d8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	assert(gd->gicd_base && gd->gicc_base);
 11120dc:	52801182 	mov	w2, #0x8c                  	// #140
{
 11120e0:	910003fd 	mov	x29, sp
	assert(gd->gicd_base && gd->gicc_base);
 11120e4:	94000072 	bl	11122ac <_assert_log>
 11120e8:	94000082 	bl	11122f0 <_assert_break>
 11120ec:	129fe002 	mov	w2, #0xffff00ff            	// #-65281
 11120f0:	b9008022 	str	w2, [x1, #128]
 11120f4:	52801001 	mov	w1, #0x80                  	// #128
 11120f8:	b9000401 	str	w1, [x0, #4]
 11120fc:	52800161 	mov	w1, #0xb                   	// #11
 1112100:	b9000001 	str	w1, [x0]
 1112104:	d65f03c0 	ret

0000000001112108 <gic_init_base_addr>:
	return *(volatile uint32_t *)addr;
 1112108:	b9400025 	ldr	w5, [x1]
	for (i = max_regs; i >= 0; i--) {
 111210c:	528003e3 	mov	w3, #0x1f                  	// #31
	gd->gicd_base = gicd_base;
 1112110:	a9000801 	stp	x1, x2, [x0]
	*(volatile uint32_t *)addr = val;
 1112114:	9105f042 	add	x2, x2, #0x17c
 1112118:	12800006 	mov	w6, #0xffffffff            	// #-1
 111211c:	b900003f 	str	wzr, [x1]
	return *(volatile uint32_t *)addr;
 1112120:	b9400044 	ldr	w4, [x2]
	*(volatile uint32_t *)addr = val;
 1112124:	b9000046 	str	w6, [x2]
		io_write32(gicd_base + GICD_ICENABLER(i), ~old_reg);
 1112128:	2a2403e4 	mvn	w4, w4
	return *(volatile uint32_t *)addr;
 111212c:	b9400047 	ldr	w7, [x2]
	*(volatile uint32_t *)addr = val;
 1112130:	b9008044 	str	w4, [x2, #128]
		for (b = NUM_INTS_PER_REG - 1; b >= 0; b--) {
 1112134:	528003e4 	mov	w4, #0x1f                  	// #31
			if (BIT32(b) & reg) {
 1112138:	1ac424e8 	lsr	w8, w7, w4
 111213c:	36000108 	tbz	w8, #0, 111215c <gic_init_base_addr+0x54>
				ret = i * NUM_INTS_PER_REG + b;
 1112140:	0b031483 	add	w3, w4, w3, lsl #5
 1112144:	93407c63 	sxtw	x3, w3
 1112148:	b9000025 	str	w5, [x1]
	gd->chip.ops = &gic_ops;
 111214c:	b0000241 	adrp	x1, 115b000 <__vcore_unpg_rw_start>
 1112150:	911e0021 	add	x1, x1, #0x780
 1112154:	a9010403 	stp	x3, x1, [x0, #16]
}
 1112158:	d65f03c0 	ret
		for (b = NUM_INTS_PER_REG - 1; b >= 0; b--) {
 111215c:	51000484 	sub	w4, w4, #0x1
 1112160:	3100049f 	cmn	w4, #0x1
 1112164:	54fffea1 	b.ne	1112138 <gic_init_base_addr+0x30>  // b.any
	for (i = max_regs; i >= 0; i--) {
 1112168:	51000463 	sub	w3, w3, #0x1
 111216c:	d1001042 	sub	x2, x2, #0x4
 1112170:	3100047f 	cmn	w3, #0x1
 1112174:	54fffd61 	b.ne	1112120 <gic_init_base_addr+0x18>  // b.any
	size_t ret = 0;
 1112178:	d2800003 	mov	x3, #0x0                   	// #0
 111217c:	17fffff3 	b	1112148 <gic_init_base_addr+0x40>

0000000001112180 <gic_it_handle>:
{
 1112180:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1112184:	910003fd 	mov	x29, sp
 1112188:	a90153f3 	stp	x19, x20, [sp, #16]
 111218c:	aa0003f3 	mov	x19, x0
	return io_read32(gd->gicc_base + GICC_IAR);
 1112190:	f9400000 	ldr	x0, [x0]
	if (id <= gd->max_it)
 1112194:	f9400a61 	ldr	x1, [x19, #16]
	return *(volatile uint32_t *)addr;
 1112198:	b9400c14 	ldr	w20, [x0, #12]
 111219c:	92402680 	and	x0, x20, #0x3ff
 11121a0:	eb01001f 	cmp	x0, x1
 11121a4:	540000e8 	b.hi	11121c0 <gic_it_handle+0x40>  // b.pmore
		itr_handle(id);
 11121a8:	940000f3 	bl	1112574 <itr_handle>
	io_write32(gd->gicc_base + GICC_EOIR, eoir);
 11121ac:	f9400260 	ldr	x0, [x19]
	*(volatile uint32_t *)addr = val;
 11121b0:	b9001014 	str	w20, [x0, #16]
}
 11121b4:	a94153f3 	ldp	x19, x20, [sp, #16]
 11121b8:	a8c27bfd 	ldp	x29, x30, [sp], #32
 11121bc:	d65f03c0 	ret
 11121c0:	12002685 	and	w5, w20, #0x3ff
		DMSG("ignoring interrupt %" PRIu32, id);
 11121c4:	d0000204 	adrp	x4, 1154000 <__func__.1786+0x8>
 11121c8:	52800023 	mov	w3, #0x1                   	// #1
 11121cc:	91084084 	add	x4, x4, #0x210
 11121d0:	52800062 	mov	w2, #0x3                   	// #3
 11121d4:	52803601 	mov	w1, #0x1b0                 	// #432
 11121d8:	d0000200 	adrp	x0, 1154000 <__func__.1786+0x8>
 11121dc:	910a6000 	add	x0, x0, #0x298
 11121e0:	9400cad9 	bl	1144d44 <trace_printf>
 11121e4:	17fffff2 	b	11121ac <gic_it_handle+0x2c>

00000000011121e8 <sp_uart_have_rx_data>:
	while (!(io_read32(base + SP_UART_LSR) & UART_TX_EMPTY))
		;
}

static bool sp_uart_have_rx_data(struct serial_chip *chip)
{
 11121e8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	return io_pa_or_va(&pd->base);
 11121ec:	d1004000 	sub	x0, x0, #0x10
{
 11121f0:	910003fd 	mov	x29, sp
	return io_pa_or_va(&pd->base);
 11121f4:	97ffe1a7 	bl	110a890 <io_pa_or_va>
	return *(volatile uint32_t *)addr;
 11121f8:	b9400400 	ldr	w0, [x0, #4]
	vaddr_t base = chip_to_base(chip);

	return (io_read32(base + SP_UART_LSR) & UART_LSR_RX_RDY);
}
 11121fc:	a8c17bfd 	ldp	x29, x30, [sp], #16
 1112200:	d3410400 	ubfx	x0, x0, #1, #1
 1112204:	d65f03c0 	ret

0000000001112208 <sp_uart_getchar>:
		;
	io_write32(base + SP_UART_DR, ch);
}

static int sp_uart_getchar(struct serial_chip *chip)
{
 1112208:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 111220c:	910003fd 	mov	x29, sp
 1112210:	a90153f3 	stp	x19, x20, [sp, #16]
 1112214:	aa0003f3 	mov	x19, x0
	return io_pa_or_va(&pd->base);
 1112218:	d1004000 	sub	x0, x0, #0x10
 111221c:	97ffe19d 	bl	110a890 <io_pa_or_va>
 1112220:	aa0003f4 	mov	x20, x0
	vaddr_t base = chip_to_base(chip);

	while (!sp_uart_have_rx_data(chip))
 1112224:	aa1303e0 	mov	x0, x19
 1112228:	97fffff0 	bl	11121e8 <sp_uart_have_rx_data>
 111222c:	72001c1f 	tst	w0, #0xff
 1112230:	54ffffa0 	b.eq	1112224 <sp_uart_getchar+0x1c>  // b.none
 1112234:	b9400280 	ldr	w0, [x20]
		;

	return io_read32(base + SP_UART_DR) & 0xff;
}
 1112238:	a94153f3 	ldp	x19, x20, [sp, #16]
 111223c:	12001c00 	and	w0, w0, #0xff
 1112240:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1112244:	d65f03c0 	ret

0000000001112248 <sp_uart_flush>:
{
 1112248:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	return io_pa_or_va(&pd->base);
 111224c:	d1004000 	sub	x0, x0, #0x10
{
 1112250:	910003fd 	mov	x29, sp
	return io_pa_or_va(&pd->base);
 1112254:	97ffe18f 	bl	110a890 <io_pa_or_va>
 1112258:	b9400401 	ldr	w1, [x0, #4]
	while (!(io_read32(base + SP_UART_LSR) & UART_TX_EMPTY))
 111225c:	3637ffe1 	tbz	w1, #6, 1112258 <sp_uart_flush+0x10>
}
 1112260:	a8c17bfd 	ldp	x29, x30, [sp], #16
 1112264:	d65f03c0 	ret

0000000001112268 <sp_uart_putc>:
{
 1112268:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	return io_pa_or_va(&pd->base);
 111226c:	d1004000 	sub	x0, x0, #0x10
{
 1112270:	910003fd 	mov	x29, sp
 1112274:	f9000bf3 	str	x19, [sp, #16]
 1112278:	2a0103f3 	mov	w19, w1
	return io_pa_or_va(&pd->base);
 111227c:	97ffe185 	bl	110a890 <io_pa_or_va>
 1112280:	b9400401 	ldr	w1, [x0, #4]
	while (!(io_read32(base + SP_UART_LSR) & UART_LSR_TX_RDY))
 1112284:	3607ffe1 	tbz	w1, #0, 1112280 <sp_uart_putc+0x18>
	*(volatile uint32_t *)addr = val;
 1112288:	b9000013 	str	w19, [x0]
}
 111228c:	f9400bf3 	ldr	x19, [sp, #16]
 1112290:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1112294:	d65f03c0 	ret

0000000001112298 <sp_uart_init>:
DECLARE_KEEP_PAGER(sp_uart_ops);

void sp_uart_init(struct sp_uart_data *pd, paddr_t base)
{
	pd->base.pa = base;
    pd->base.va = 0;
 1112298:	a9007c01 	stp	x1, xzr, [x0]
	pd->chip.ops = &sp_uart_ops;
 111229c:	b0000241 	adrp	x1, 115b000 <__vcore_unpg_rw_start>
 11122a0:	911ec021 	add	x1, x1, #0x7b0
 11122a4:	f9000801 	str	x1, [x0, #16]
}
 11122a8:	d65f03c0 	ret

00000000011122ac <_assert_log>:

void __nostackcheck _assert_log(const char *expr __maybe_unused,
				const char *file __maybe_unused,
				const int line __maybe_unused,
				const char *func __maybe_unused)
{
 11122ac:	d10083ff 	sub	sp, sp, #0x20
#if defined(CFG_TEE_CORE_DEBUG)
	EMSG_RAW("assertion '%s' failed at %s:%d <%s>",
 11122b0:	2a0203e7 	mov	w7, w2
 11122b4:	aa0103e6 	mov	x6, x1
 11122b8:	aa0003e5 	mov	x5, x0
 11122bc:	52800022 	mov	w2, #0x1                   	// #1
 11122c0:	52800001 	mov	w1, #0x0                   	// #0
{
 11122c4:	a9017bfd 	stp	x29, x30, [sp, #16]
 11122c8:	910043fd 	add	x29, sp, #0x10
	EMSG_RAW("assertion '%s' failed at %s:%d <%s>",
 11122cc:	d2800000 	mov	x0, #0x0                   	// #0
 11122d0:	d0000204 	adrp	x4, 1154000 <__func__.1786+0x8>
 11122d4:	f90003e3 	str	x3, [sp]
 11122d8:	910c0c84 	add	x4, x4, #0x303
 11122dc:	52800023 	mov	w3, #0x1                   	// #1
 11122e0:	9400ca99 	bl	1144d44 <trace_printf>
		 expr, file, line, func);
#else
	EMSG_RAW("assertion failed");
#endif
}
 11122e4:	a9417bfd 	ldp	x29, x30, [sp, #16]
 11122e8:	910083ff 	add	sp, sp, #0x20
 11122ec:	d65f03c0 	ret

00000000011122f0 <_assert_break>:

void __noreturn _assert_break(void)
{
 11122f0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	panic();
 11122f4:	d0000202 	adrp	x2, 1154000 <__func__.1786+0x8>
 11122f8:	d0000200 	adrp	x0, 1154000 <__func__.1786+0x8>
{
 11122fc:	910003fd 	mov	x29, sp
	panic();
 1112300:	910cf042 	add	x2, x2, #0x33c
 1112304:	910c9c00 	add	x0, x0, #0x327
 1112308:	d2800003 	mov	x3, #0x0                   	// #0
 111230c:	52800381 	mov	w1, #0x1c                  	// #28
 1112310:	94000456 	bl	1113468 <__do_panic>

0000000001112314 <console_putc>:
#include <string_ext.h>

static struct serial_chip *serial_console __nex_bss;

void __weak console_putc(int ch)
{
 1112314:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	if (!serial_console)
 1112318:	90000261 	adrp	x1, 115e000 <state+0x80>
{
 111231c:	910003fd 	mov	x29, sp
 1112320:	a90153f3 	stp	x19, x20, [sp, #16]
 1112324:	2a0003f3 	mov	w19, w0
	if (!serial_console)
 1112328:	f9406820 	ldr	x0, [x1, #208]
 111232c:	b4000200 	cbz	x0, 111236c <console_putc+0x58>
 1112330:	aa0103f4 	mov	x20, x1
		return;

	if (ch == '\n')
 1112334:	71002a7f 	cmp	w19, #0xa
 1112338:	540000a1 	b.ne	111234c <console_putc+0x38>  // b.any
		serial_console->ops->putc(serial_console, '\r');
 111233c:	f9400001 	ldr	x1, [x0]
 1112340:	f9400022 	ldr	x2, [x1]
 1112344:	528001a1 	mov	w1, #0xd                   	// #13
 1112348:	d63f0040 	blr	x2
	serial_console->ops->putc(serial_console, ch);
 111234c:	f9406a80 	ldr	x0, [x20, #208]
 1112350:	f9400001 	ldr	x1, [x0]
 1112354:	f9400022 	ldr	x2, [x1]
 1112358:	2a1303e1 	mov	w1, w19
}
 111235c:	a94153f3 	ldp	x19, x20, [sp, #16]
	serial_console->ops->putc(serial_console, ch);
 1112360:	aa0203f0 	mov	x16, x2
}
 1112364:	a8c27bfd 	ldp	x29, x30, [sp], #32
	serial_console->ops->putc(serial_console, ch);
 1112368:	d61f0200 	br	x16
}
 111236c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1112370:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1112374:	d65f03c0 	ret

0000000001112378 <console_flush>:

void __weak console_flush(void)
{
	if (!serial_console)
 1112378:	90000260 	adrp	x0, 115e000 <state+0x80>
 111237c:	f9406800 	ldr	x0, [x0, #208]
 1112380:	b40000a0 	cbz	x0, 1112394 <console_flush+0x1c>
		return;

	serial_console->ops->flush(serial_console);
 1112384:	f9400001 	ldr	x1, [x0]
 1112388:	f9400421 	ldr	x1, [x1, #8]
 111238c:	aa0103f0 	mov	x16, x1
 1112390:	d61f0200 	br	x16
}
 1112394:	d65f03c0 	ret

0000000001112398 <register_serial_console>:

void register_serial_console(struct serial_chip *chip)
{
	serial_console = chip;
 1112398:	90000261 	adrp	x1, 115e000 <state+0x80>
 111239c:	f9006820 	str	x0, [x1, #208]
}
 11123a0:	d65f03c0 	ret

00000000011123a4 <handle_db_destroy>:
 */
#define HANDLE_DB_INITIAL_MAX_PTRS	4

void handle_db_destroy(struct handle_db *db, void (*ptr_destructor)(void *ptr))
{
	if (db) {
 11123a4:	b4000320 	cbz	x0, 1112408 <handle_db_destroy+0x64>
{
 11123a8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 11123ac:	910003fd 	mov	x29, sp
 11123b0:	a90153f3 	stp	x19, x20, [sp, #16]
 11123b4:	aa0003f3 	mov	x19, x0
 11123b8:	f90013f5 	str	x21, [sp, #32]
 11123bc:	aa0103f5 	mov	x21, x1
		if (ptr_destructor) {
 11123c0:	b5000201 	cbnz	x1, 1112400 <handle_db_destroy+0x5c>

			for (n = 0; n < db->max_ptrs; n++)
				if (db->ptrs[n])
					ptr_destructor(db->ptrs[n]);
		}
		free(db->ptrs);
 11123c4:	f9400260 	ldr	x0, [x19]
 11123c8:	9400c486 	bl	11435e0 <free>
		db->ptrs = NULL;
		db->max_ptrs = 0;
	}
}
 11123cc:	f94013f5 	ldr	x21, [sp, #32]
		db->max_ptrs = 0;
 11123d0:	a9007e7f 	stp	xzr, xzr, [x19]
}
 11123d4:	a94153f3 	ldp	x19, x20, [sp, #16]
 11123d8:	a8c37bfd 	ldp	x29, x30, [sp], #48
 11123dc:	d65f03c0 	ret
				if (db->ptrs[n])
 11123e0:	f8747820 	ldr	x0, [x1, x20, lsl #3]
 11123e4:	b4000040 	cbz	x0, 11123ec <handle_db_destroy+0x48>
					ptr_destructor(db->ptrs[n]);
 11123e8:	d63f02a0 	blr	x21
			for (n = 0; n < db->max_ptrs; n++)
 11123ec:	91000694 	add	x20, x20, #0x1
 11123f0:	a9400261 	ldp	x1, x0, [x19]
 11123f4:	eb14001f 	cmp	x0, x20
 11123f8:	54ffff48 	b.hi	11123e0 <handle_db_destroy+0x3c>  // b.pmore
 11123fc:	17fffff2 	b	11123c4 <handle_db_destroy+0x20>
 1112400:	d2800014 	mov	x20, #0x0                   	// #0
 1112404:	17fffffb 	b	11123f0 <handle_db_destroy+0x4c>
 1112408:	d65f03c0 	ret

000000000111240c <handle_db_is_empty>:

bool handle_db_is_empty(struct handle_db *db)
{
	size_t n = 0;

	if (db) {
 111240c:	b40000a0 	cbz	x0, 1112420 <handle_db_is_empty+0x14>
		for (n = 0; n < db->max_ptrs; n++) {
 1112410:	f9400402 	ldr	x2, [x0, #8]
 1112414:	d2800001 	mov	x1, #0x0                   	// #0
 1112418:	eb01005f 	cmp	x2, x1
 111241c:	54000061 	b.ne	1112428 <handle_db_is_empty+0x1c>  // b.any
			if (db->ptrs[n])
				return false;
		}
	}
	return true;
 1112420:	52800020 	mov	w0, #0x1                   	// #1
}
 1112424:	d65f03c0 	ret
			if (db->ptrs[n])
 1112428:	f9400003 	ldr	x3, [x0]
 111242c:	f8617863 	ldr	x3, [x3, x1, lsl #3]
 1112430:	b5000063 	cbnz	x3, 111243c <handle_db_is_empty+0x30>
		for (n = 0; n < db->max_ptrs; n++) {
 1112434:	91000421 	add	x1, x1, #0x1
 1112438:	17fffff8 	b	1112418 <handle_db_is_empty+0xc>
				return false;
 111243c:	52800000 	mov	w0, #0x0                   	// #0
 1112440:	17fffff9 	b	1112424 <handle_db_is_empty+0x18>

0000000001112444 <handle_get>:
{
	size_t n;
	void *p;
	size_t new_max_ptrs;

	if (!db || !ptr)
 1112444:	f100001f 	cmp	x0, #0x0
 1112448:	fa401824 	ccmp	x1, #0x0, #0x4, ne  // ne = any
 111244c:	54000101 	b.ne	111246c <handle_get+0x28>  // b.any
		return -1;
 1112450:	12800000 	mov	w0, #0xffffffff            	// #-1
	db->max_ptrs = new_max_ptrs;

	/* Since n stopped at db->max_ptrs there is an empty location there */
	db->ptrs[n] = ptr;
	return n;
}
 1112454:	d65f03c0 	ret
		return -1;
 1112458:	12800000 	mov	w0, #0xffffffff            	// #-1
}
 111245c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1112460:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1112464:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1112468:	d65f03c0 	ret
{
 111246c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	for (n = 0; n < db->max_ptrs; n++) {
 1112470:	d2800002 	mov	x2, #0x0                   	// #0
{
 1112474:	910003fd 	mov	x29, sp
 1112478:	a90153f3 	stp	x19, x20, [sp, #16]
 111247c:	aa0003f4 	mov	x20, x0
	for (n = 0; n < db->max_ptrs; n++) {
 1112480:	a9404c00 	ldp	x0, x19, [x0]
{
 1112484:	a9025bf5 	stp	x21, x22, [sp, #32]
 1112488:	aa0103f6 	mov	x22, x1
	for (n = 0; n < db->max_ptrs; n++) {
 111248c:	eb02027f 	cmp	x19, x2
 1112490:	54000281 	b.ne	11124e0 <handle_get+0x9c>  // b.any
		new_max_ptrs = db->max_ptrs * 2;
 1112494:	d37ffa75 	lsl	x21, x19, #1
 1112498:	f100027f 	cmp	x19, #0x0
 111249c:	d2800081 	mov	x1, #0x4                   	// #4
 11124a0:	9a8112b5 	csel	x21, x21, x1, ne  // ne = any
	p = realloc(db->ptrs, new_max_ptrs * sizeof(void *));
 11124a4:	d37df2a1 	lsl	x1, x21, #3
 11124a8:	9400c42e 	bl	1143560 <realloc>
	if (!p)
 11124ac:	b4fffd60 	cbz	x0, 1112458 <handle_get+0x14>
	memset(db->ptrs + db->max_ptrs, 0,
 11124b0:	f9400683 	ldr	x3, [x20, #8]
	db->ptrs = p;
 11124b4:	f9000280 	str	x0, [x20]
	memset(db->ptrs + db->max_ptrs, 0,
 11124b8:	52800001 	mov	w1, #0x0                   	// #0
	       (new_max_ptrs - db->max_ptrs) * sizeof(void *));
 11124bc:	cb0302a2 	sub	x2, x21, x3
	memset(db->ptrs + db->max_ptrs, 0,
 11124c0:	8b030c00 	add	x0, x0, x3, lsl #3
 11124c4:	d37df042 	lsl	x2, x2, #3
 11124c8:	9400c606 	bl	1143ce0 <memset>
	db->ptrs[n] = ptr;
 11124cc:	f9400280 	ldr	x0, [x20]
	db->max_ptrs = new_max_ptrs;
 11124d0:	f9000695 	str	x21, [x20, #8]
	db->ptrs[n] = ptr;
 11124d4:	f8337816 	str	x22, [x0, x19, lsl #3]
	return n;
 11124d8:	2a1303e0 	mov	w0, w19
 11124dc:	17ffffe0 	b	111245c <handle_get+0x18>
		if (!db->ptrs[n]) {
 11124e0:	f8627803 	ldr	x3, [x0, x2, lsl #3]
 11124e4:	8b020c01 	add	x1, x0, x2, lsl #3
 11124e8:	b5000083 	cbnz	x3, 11124f8 <handle_get+0xb4>
			return n;
 11124ec:	2a0203e0 	mov	w0, w2
			db->ptrs[n] = ptr;
 11124f0:	f9000036 	str	x22, [x1]
			return n;
 11124f4:	17ffffda 	b	111245c <handle_get+0x18>
	for (n = 0; n < db->max_ptrs; n++) {
 11124f8:	91000442 	add	x2, x2, #0x1
 11124fc:	17ffffe4 	b	111248c <handle_get+0x48>

0000000001112500 <handle_put>:

void *handle_put(struct handle_db *db, int handle)
{
	void *p;

	if (!db || handle < 0 || (size_t)handle >= db->max_ptrs)
 1112500:	f100001f 	cmp	x0, #0x0
 1112504:	7a401821 	ccmp	w1, #0x0, #0x1, ne  // ne = any
 1112508:	5400014b 	b.lt	1112530 <handle_put+0x30>  // b.tstop
 111250c:	f9400403 	ldr	x3, [x0, #8]
 1112510:	93407c22 	sxtw	x2, w1
 1112514:	eb21c07f 	cmp	x3, w1, sxtw
 1112518:	540000c9 	b.ls	1112530 <handle_put+0x30>  // b.plast
		return NULL;

	p = db->ptrs[handle];
 111251c:	d37df041 	lsl	x1, x2, #3
 1112520:	f9400002 	ldr	x2, [x0]
 1112524:	f8616840 	ldr	x0, [x2, x1]
	db->ptrs[handle] = NULL;
 1112528:	f821685f 	str	xzr, [x2, x1]
	return p;
}
 111252c:	d65f03c0 	ret
		return NULL;
 1112530:	d2800000 	mov	x0, #0x0                   	// #0
 1112534:	17fffffe 	b	111252c <handle_put+0x2c>

0000000001112538 <handle_lookup>:

void *handle_lookup(struct handle_db *db, int handle)
{
	if (!db || handle < 0 || (size_t)handle >= db->max_ptrs)
 1112538:	f100001f 	cmp	x0, #0x0
 111253c:	7a401821 	ccmp	w1, #0x0, #0x1, ne  // ne = any
 1112540:	5400010b 	b.lt	1112560 <handle_lookup+0x28>  // b.tstop
 1112544:	f9400403 	ldr	x3, [x0, #8]
 1112548:	93407c22 	sxtw	x2, w1
 111254c:	eb21c07f 	cmp	x3, w1, sxtw
 1112550:	54000089 	b.ls	1112560 <handle_lookup+0x28>  // b.plast
		return NULL;

	return db->ptrs[handle];
 1112554:	f9400000 	ldr	x0, [x0]
 1112558:	f8627800 	ldr	x0, [x0, x2, lsl #3]
}
 111255c:	d65f03c0 	ret
		return NULL;
 1112560:	d2800000 	mov	x0, #0x0                   	// #0
 1112564:	17fffffe 	b	111255c <handle_lookup+0x24>

0000000001112568 <itr_init>:
static SLIST_HEAD(, itr_handler) handlers __nex_data =
	SLIST_HEAD_INITIALIZER(handlers);

void itr_init(struct itr_chip *chip)
{
	itr_chip = chip;
 1112568:	90000261 	adrp	x1, 115e000 <state+0x80>
 111256c:	f9007020 	str	x0, [x1, #224]
}
 1112570:	d65f03c0 	ret

0000000001112574 <itr_handle>:
	return itr_chip->dt_get_irq(prop, len);
}
#endif

void itr_handle(size_t it)
{
 1112574:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1112578:	910003fd 	mov	x29, sp
 111257c:	a90153f3 	stp	x19, x20, [sp, #16]
 1112580:	aa0003f4 	mov	x20, x0
	struct itr_handler *h = NULL;
	bool was_handled = false;

	SLIST_FOREACH(h, &handlers, link) {
 1112584:	90000260 	adrp	x0, 115e000 <state+0x80>
{
 1112588:	f90013f5 	str	x21, [sp, #32]
	bool was_handled = false;
 111258c:	52800015 	mov	w21, #0x0                   	// #0
	SLIST_FOREACH(h, &handlers, link) {
 1112590:	f9406c13 	ldr	x19, [x0, #216]
 1112594:	b4000173 	cbz	x19, 11125c0 <itr_handle+0x4c>
		if (h->it == it) {
 1112598:	f9400260 	ldr	x0, [x19]
 111259c:	eb14001f 	cmp	x0, x20
 11125a0:	540003a1 	b.ne	1112614 <itr_handle+0xa0>  // b.any
			if (h->handler(h) == ITRR_HANDLED)
 11125a4:	f9400a61 	ldr	x1, [x19, #16]
 11125a8:	aa1303e0 	mov	x0, x19
 11125ac:	d63f0020 	blr	x1
 11125b0:	7100041f 	cmp	w0, #0x1
 11125b4:	540002e0 	b.eq	1112610 <itr_handle+0x9c>  // b.none
				was_handled = true;
			else if (!(h->flags & ITRF_SHARED))
 11125b8:	b9400a60 	ldr	w0, [x19, #8]
 11125bc:	370802c0 	tbnz	w0, #1, 1112614 <itr_handle+0xa0>
				break;
		}
	}

	if (!was_handled) {
 11125c0:	350002f5 	cbnz	w21, 111261c <itr_handle+0xa8>
		EMSG("Disabling unhandled interrupt %zu", it);
 11125c4:	aa1403e5 	mov	x5, x20
 11125c8:	52800023 	mov	w3, #0x1                   	// #1
 11125cc:	52800022 	mov	w2, #0x1                   	// #1
 11125d0:	52800801 	mov	w1, #0x40                  	// #64
 11125d4:	d0000204 	adrp	x4, 1154000 <__func__.1786+0x8>
 11125d8:	d0000200 	adrp	x0, 1154000 <__func__.1786+0x8>
 11125dc:	910d2884 	add	x4, x4, #0x34a
 11125e0:	910db000 	add	x0, x0, #0x36c
 11125e4:	9400c9d8 	bl	1144d44 <trace_printf>
		itr_chip->ops->disable(itr_chip, it);
 11125e8:	90000260 	adrp	x0, 115e000 <state+0x80>
	}
}
 11125ec:	f94013f5 	ldr	x21, [sp, #32]
		itr_chip->ops->disable(itr_chip, it);
 11125f0:	f9407000 	ldr	x0, [x0, #224]
 11125f4:	f9400001 	ldr	x1, [x0]
 11125f8:	f9400822 	ldr	x2, [x1, #16]
 11125fc:	aa1403e1 	mov	x1, x20
}
 1112600:	a94153f3 	ldp	x19, x20, [sp, #16]
		itr_chip->ops->disable(itr_chip, it);
 1112604:	aa0203f0 	mov	x16, x2
}
 1112608:	a8c37bfd 	ldp	x29, x30, [sp], #48
		itr_chip->ops->disable(itr_chip, it);
 111260c:	d61f0200 	br	x16
				was_handled = true;
 1112610:	2a0003f5 	mov	w21, w0
	SLIST_FOREACH(h, &handlers, link) {
 1112614:	f9401273 	ldr	x19, [x19, #32]
 1112618:	17ffffdf 	b	1112594 <itr_handle+0x20>
}
 111261c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1112620:	f94013f5 	ldr	x21, [sp, #32]
 1112624:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1112628:	d65f03c0 	ret

000000000111262c <bin_close>:

	return vm_unmap(uctx, va, sz);
}

static void bin_close(void *ptr)
{
 111262c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1112630:	910003fd 	mov	x29, sp
 1112634:	f9000bf3 	str	x19, [sp, #16]
 1112638:	aa0003f3 	mov	x19, x0
	struct bin_handle *binh = ptr;

	if (binh) {
 111263c:	b4000120 	cbz	x0, 1112660 <bin_close+0x34>
		if (binh->op && binh->h)
 1112640:	f9400001 	ldr	x1, [x0]
 1112644:	b40000a1 	cbz	x1, 1112658 <bin_close+0x2c>
 1112648:	f9400400 	ldr	x0, [x0, #8]
 111264c:	b4000060 	cbz	x0, 1112658 <bin_close+0x2c>
			binh->op->close(binh->h);
 1112650:	f9401421 	ldr	x1, [x1, #40]
 1112654:	d63f0020 	blr	x1
		file_put(binh->f);
 1112658:	f9400a60 	ldr	x0, [x19, #16]
 111265c:	94001891 	bl	11188a0 <file_put>
	}
	free(binh);
 1112660:	aa1303e0 	mov	x0, x19
}
 1112664:	f9400bf3 	ldr	x19, [sp, #16]
 1112668:	a8c27bfd 	ldp	x29, x30, [sp], #32
	free(binh);
 111266c:	1400c3dd 	b	11435e0 <free>

0000000001112670 <binh_copy_to>:
	return res;
}

static TEE_Result binh_copy_to(struct bin_handle *binh, vaddr_t va,
			       size_t offs_bytes, size_t num_bytes)
{
 1112670:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 1112674:	910003fd 	mov	x29, sp
 1112678:	a9025bf5 	stp	x21, x22, [sp, #32]
 111267c:	aa0203f5 	mov	x21, x2
	TEE_Result res = TEE_SUCCESS;
	size_t next_offs = 0;

	if (offs_bytes < binh->offs_bytes)
 1112680:	f9400c02 	ldr	x2, [x0, #24]
{
 1112684:	a90153f3 	stp	x19, x20, [sp, #16]
 1112688:	a90363f7 	stp	x23, x24, [sp, #48]
	if (offs_bytes < binh->offs_bytes)
 111268c:	eb15005f 	cmp	x2, x21
{
 1112690:	f90023f9 	str	x25, [sp, #64]
	if (offs_bytes < binh->offs_bytes)
 1112694:	540006a8 	b.hi	1112768 <binh_copy_to+0xf8>  // b.pmore
 1112698:	aa0303f6 	mov	x22, x3
		return TEE_ERROR_BAD_STATE;

	if (ADD_OVERFLOW(offs_bytes, num_bytes, &next_offs))
 111269c:	ab0302b9 	adds	x25, x21, x3
 11126a0:	54000462 	b.cs	111272c <binh_copy_to+0xbc>  // b.hs, b.nlast
 11126a4:	aa0003f4 	mov	x20, x0
 11126a8:	aa0103f7 	mov	x23, x1
		return TEE_ERROR_BAD_PARAMETERS;

	if (offs_bytes > binh->offs_bytes) {
 11126ac:	eb15005f 	cmp	x2, x21
 11126b0:	54000142 	b.cs	11126d8 <binh_copy_to+0x68>  // b.hs, b.nlast
		res = binh->op->read(binh->h, NULL,
 11126b4:	f9400000 	ldr	x0, [x0]
 11126b8:	cb0202a2 	sub	x2, x21, x2
 11126bc:	d2800001 	mov	x1, #0x0                   	// #0
 11126c0:	f9401003 	ldr	x3, [x0, #32]
 11126c4:	f9400680 	ldr	x0, [x20, #8]
 11126c8:	d63f0060 	blr	x3
 11126cc:	2a0003f3 	mov	w19, w0
				     offs_bytes - binh->offs_bytes);
		if (res)
 11126d0:	35000300 	cbnz	w0, 1112730 <binh_copy_to+0xc0>
			return res;
		binh->offs_bytes = offs_bytes;
 11126d4:	f9000e95 	str	x21, [x20, #24]
	}

	if (next_offs > binh->size_bytes) {
 11126d8:	f9400280 	ldr	x0, [x20]
 11126dc:	f9401298 	ldr	x24, [x20, #32]
 11126e0:	f9401003 	ldr	x3, [x0, #32]
 11126e4:	eb18033f 	cmp	x25, x24
 11126e8:	f9400680 	ldr	x0, [x20, #8]
 11126ec:	54000309 	b.ls	111274c <binh_copy_to+0xdc>  // b.plast
		size_t rb = binh->size_bytes - binh->offs_bytes;
 11126f0:	f9400e95 	ldr	x21, [x20, #24]

		res = binh->op->read(binh->h, (void *)va, rb);
 11126f4:	aa1703e1 	mov	x1, x23
		size_t rb = binh->size_bytes - binh->offs_bytes;
 11126f8:	cb150319 	sub	x25, x24, x21
		res = binh->op->read(binh->h, (void *)va, rb);
 11126fc:	aa1903e2 	mov	x2, x25
 1112700:	d63f0060 	blr	x3
 1112704:	2a0003f3 	mov	w19, w0
		if (res)
 1112708:	35000140 	cbnz	w0, 1112730 <binh_copy_to+0xc0>
			return res;
		memset((uint8_t *)va + rb, 0, num_bytes - rb);
 111270c:	8b1602a2 	add	x2, x21, x22
 1112710:	8b1902e0 	add	x0, x23, x25
 1112714:	cb180042 	sub	x2, x2, x24
 1112718:	52800001 	mov	w1, #0x0                   	// #0
 111271c:	9400c571 	bl	1143ce0 <memset>
		binh->offs_bytes = binh->size_bytes;
 1112720:	f9401280 	ldr	x0, [x20, #32]
 1112724:	f9000e80 	str	x0, [x20, #24]
 1112728:	14000002 	b	1112730 <binh_copy_to+0xc0>
		return TEE_ERROR_BAD_PARAMETERS;
 111272c:	129fff33 	mov	w19, #0xffff0006            	// #-65530
			return res;
		binh->offs_bytes = next_offs;
	}

	return TEE_SUCCESS;
}
 1112730:	2a1303e0 	mov	w0, w19
 1112734:	a94153f3 	ldp	x19, x20, [sp, #16]
 1112738:	a9425bf5 	ldp	x21, x22, [sp, #32]
 111273c:	a94363f7 	ldp	x23, x24, [sp, #48]
 1112740:	f94023f9 	ldr	x25, [sp, #64]
 1112744:	a8c57bfd 	ldp	x29, x30, [sp], #80
 1112748:	d65f03c0 	ret
		res = binh->op->read(binh->h, (void *)va, num_bytes);
 111274c:	aa1603e2 	mov	x2, x22
 1112750:	aa1703e1 	mov	x1, x23
 1112754:	d63f0060 	blr	x3
 1112758:	2a0003f3 	mov	w19, w0
		if (res)
 111275c:	35fffea0 	cbnz	w0, 1112730 <binh_copy_to+0xc0>
		binh->offs_bytes = next_offs;
 1112760:	f9000e99 	str	x25, [x20, #24]
 1112764:	17fffff3 	b	1112730 <binh_copy_to+0xc0>
		return TEE_ERROR_BAD_STATE;
 1112768:	129fff13 	mov	w19, #0xffff0007            	// #-65529
 111276c:	17fffff1 	b	1112730 <binh_copy_to+0xc0>

0000000001112770 <to_user_mode_ctx>:
{
 1112770:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1112774:	910003fd 	mov	x29, sp
 1112778:	f9000bf3 	str	x19, [sp, #16]
 111277c:	aa0003f3 	mov	x19, x0
	if (is_user_ta_ctx(ctx))
 1112780:	94000e9b 	bl	11161ec <is_user_ta_ctx>
 1112784:	72001c1f 	tst	w0, #0xff
 1112788:	54000240 	b.eq	11127d0 <to_user_mode_ctx+0x60>  // b.none
 111278c:	aa1303e0 	mov	x0, x19
 1112790:	94000e97 	bl	11161ec <is_user_ta_ctx>
 1112794:	72001c1f 	tst	w0, #0xff
 1112798:	54000141 	b.ne	11127c0 <to_user_mode_ctx+0x50>  // b.any
 111279c:	d0000203 	adrp	x3, 1154000 <__func__.1786+0x8>
 11127a0:	f00001e1 	adrp	x1, 1151000 <small_prime+0x168>
 11127a4:	f00001e0 	adrp	x0, 1151000 <small_prime+0x168>
 11127a8:	910f1463 	add	x3, x3, #0x3c5
 11127ac:	91081021 	add	x1, x1, #0x204
 11127b0:	91088800 	add	x0, x0, #0x222
 11127b4:	52800702 	mov	w2, #0x38                  	// #56
 11127b8:	97fffebd 	bl	11122ac <_assert_log>
 11127bc:	97fffecd 	bl	11122f0 <_assert_break>
		return &to_user_ta_ctx(ctx)->uctx;
 11127c0:	d10a6260 	sub	x0, x19, #0x298
}
 11127c4:	f9400bf3 	ldr	x19, [sp, #16]
 11127c8:	a8c27bfd 	ldp	x29, x30, [sp], #32
 11127cc:	d65f03c0 	ret
 11127d0:	d0000203 	adrp	x3, 1154000 <__func__.1786+0x8>
 11127d4:	f00001e1 	adrp	x1, 1151000 <small_prime+0x168>
 11127d8:	f00001e0 	adrp	x0, 1151000 <small_prime+0x168>
 11127dc:	910ee463 	add	x3, x3, #0x3b9
 11127e0:	913a8421 	add	x1, x1, #0xea1
 11127e4:	913b2000 	add	x0, x0, #0xec8
 11127e8:	52801322 	mov	w2, #0x99                  	// #153
 11127ec:	17fffff3 	b	11127b8 <to_user_mode_ctx+0x48>

00000000011127f0 <fobj_put>:
	if (fobj && refcount_dec(&fobj->refc))
 11127f0:	b4000260 	cbz	x0, 111283c <fobj_put+0x4c>
{
 11127f4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 11127f8:	910003fd 	mov	x29, sp
 11127fc:	f9000bf3 	str	x19, [sp, #16]
 1112800:	aa0003f3 	mov	x19, x0
	if (fobj && refcount_dec(&fobj->refc))
 1112804:	91003000 	add	x0, x0, #0xc
 1112808:	94000369 	bl	11135ac <refcount_dec>
 111280c:	72001c1f 	tst	w0, #0xff
 1112810:	54000100 	b.eq	1112830 <fobj_put+0x40>  // b.none
		fobj->ops->free(fobj);
 1112814:	f9400260 	ldr	x0, [x19]
 1112818:	f9400001 	ldr	x1, [x0]
 111281c:	aa1303e0 	mov	x0, x19
}
 1112820:	f9400bf3 	ldr	x19, [sp, #16]
		fobj->ops->free(fobj);
 1112824:	aa0103f0 	mov	x16, x1
}
 1112828:	a8c27bfd 	ldp	x29, x30, [sp], #32
		fobj->ops->free(fobj);
 111282c:	d61f0200 	br	x16
}
 1112830:	f9400bf3 	ldr	x19, [sp, #16]
 1112834:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1112838:	d65f03c0 	ret
 111283c:	d65f03c0 	ret

0000000001112840 <mobj_put>:
	if (mobj && refcount_dec(&mobj->refc))
 1112840:	b4000260 	cbz	x0, 111288c <mobj_put+0x4c>
{
 1112844:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1112848:	910003fd 	mov	x29, sp
 111284c:	f9000bf3 	str	x19, [sp, #16]
 1112850:	aa0003f3 	mov	x19, x0
	if (mobj && refcount_dec(&mobj->refc))
 1112854:	91006000 	add	x0, x0, #0x18
 1112858:	94000355 	bl	11135ac <refcount_dec>
 111285c:	72001c1f 	tst	w0, #0xff
 1112860:	54000100 	b.eq	1112880 <mobj_put+0x40>  // b.none
		mobj->ops->free(mobj);
 1112864:	f9400260 	ldr	x0, [x19]
 1112868:	f9401401 	ldr	x1, [x0, #40]
 111286c:	aa1303e0 	mov	x0, x19
}
 1112870:	f9400bf3 	ldr	x19, [sp, #16]
		mobj->ops->free(mobj);
 1112874:	aa0103f0 	mov	x16, x1
}
 1112878:	a8c27bfd 	ldp	x29, x30, [sp], #32
		mobj->ops->free(mobj);
 111287c:	d61f0200 	br	x16
}
 1112880:	f9400bf3 	ldr	x19, [sp, #16]
 1112884:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1112888:	d65f03c0 	ret
 111288c:	d65f03c0 	ret

0000000001112890 <ldelf_syscall_map_zi>:
{
 1112890:	d10183ff 	sub	sp, sp, #0x60
 1112894:	a9017bfd 	stp	x29, x30, [sp, #16]
 1112898:	910043fd 	add	x29, sp, #0x10
 111289c:	a90253f3 	stp	x19, x20, [sp, #32]
 11128a0:	a9035bf5 	stp	x21, x22, [sp, #48]
 11128a4:	aa0103f5 	mov	x21, x1
 11128a8:	a90463f7 	stp	x23, x24, [sp, #64]
 11128ac:	aa0203f8 	mov	x24, x2
 11128b0:	aa0003f7 	mov	x23, x0
 11128b4:	a9056bf9 	stp	x25, x26, [sp, #80]
 11128b8:	aa0403fa 	mov	x26, x4
 11128bc:	aa0303f9 	mov	x25, x3
	struct ts_session *sess = ts_get_current_session();
 11128c0:	94000848 	bl	11149e0 <ts_get_current_session>
	struct user_mode_ctx *uctx = to_user_mode_ctx(sess->ctx);
 11128c4:	f9400800 	ldr	x0, [x0, #16]
 11128c8:	97ffffaa 	bl	1112770 <to_user_mode_ctx>
	if (flags & ~LDELF_MAP_FLAG_SHAREABLE)
 11128cc:	f27f7b5f 	tst	x26, #0xfffffffe
 11128d0:	540004c1 	b.ne	1112968 <ldelf_syscall_map_zi+0xd8>  // b.any
	f = fobj_ta_mem_alloc(ROUNDUP_DIV(num_bytes, SMALL_PAGE_SIZE));
 11128d4:	f2402ebf 	tst	x21, #0xfff
 11128d8:	aa0003f6 	mov	x22, x0
 11128dc:	d34cfea0 	lsr	x0, x21, #12
		vm_flags |= VM_FLAG_SHAREABLE;
 11128e0:	531e035a 	ubfiz	w26, w26, #2, #1
	f = fobj_ta_mem_alloc(ROUNDUP_DIV(num_bytes, SMALL_PAGE_SIZE));
 11128e4:	1a800400 	cinc	w0, w0, ne  // ne = any
 11128e8:	94001758 	bl	1118648 <fobj_sec_mem_alloc>
 11128ec:	aa0003f3 	mov	x19, x0
	if (!f)
 11128f0:	b5000140 	cbnz	x0, 1112918 <ldelf_syscall_map_zi+0x88>
		return TEE_ERROR_OUT_OF_MEMORY;
 11128f4:	129ffe73 	mov	w19, #0xffff000c            	// #-65524
}
 11128f8:	2a1303e0 	mov	w0, w19
 11128fc:	a9417bfd 	ldp	x29, x30, [sp, #16]
 1112900:	a94253f3 	ldp	x19, x20, [sp, #32]
 1112904:	a9435bf5 	ldp	x21, x22, [sp, #48]
 1112908:	a94463f7 	ldp	x23, x24, [sp, #64]
 111290c:	a9456bf9 	ldp	x25, x26, [sp, #80]
 1112910:	910183ff 	add	sp, sp, #0x60
 1112914:	d65f03c0 	ret
	mobj = mobj_with_fobj_alloc(f, NULL);
 1112918:	d2800001 	mov	x1, #0x0                   	// #0
 111291c:	940016d2 	bl	1118464 <mobj_with_fobj_alloc>
 1112920:	aa0003f4 	mov	x20, x0
	fobj_put(f);
 1112924:	aa1303e0 	mov	x0, x19
 1112928:	97ffffb2 	bl	11127f0 <fobj_put>
	if (!mobj)
 111292c:	b4fffe54 	cbz	x20, 11128f4 <ldelf_syscall_map_zi+0x64>
	res = vm_map_pad(uctx, va, num_bytes, prot, vm_flags,
 1112930:	aa1803e7 	mov	x7, x24
 1112934:	aa1403e5 	mov	x5, x20
 1112938:	2a1a03e4 	mov	w4, w26
 111293c:	aa1503e2 	mov	x2, x21
 1112940:	aa1703e1 	mov	x1, x23
 1112944:	a9007ff9 	stp	x25, xzr, [sp]
 1112948:	d2800006 	mov	x6, #0x0                   	// #0
 111294c:	52803603 	mov	w3, #0x1b0                 	// #432
 1112950:	aa1603e0 	mov	x0, x22
 1112954:	94001c79 	bl	1119b38 <vm_map_pad>
 1112958:	2a0003f3 	mov	w19, w0
	mobj_put(mobj);
 111295c:	aa1403e0 	mov	x0, x20
 1112960:	97ffffb8 	bl	1112840 <mobj_put>
	return res;
 1112964:	17ffffe5 	b	11128f8 <ldelf_syscall_map_zi+0x68>
		return TEE_ERROR_BAD_PARAMETERS;
 1112968:	129fff33 	mov	w19, #0xffff0006            	// #-65530
 111296c:	17ffffe3 	b	11128f8 <ldelf_syscall_map_zi+0x68>

0000000001112970 <ldelf_syscall_unmap>:
{
 1112970:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 1112974:	910003fd 	mov	x29, sp
 1112978:	a90153f3 	stp	x19, x20, [sp, #16]
	size_t sz = ROUNDUP(num_bytes, SMALL_PAGE_SIZE);
 111297c:	913ffc33 	add	x19, x1, #0xfff
{
 1112980:	aa0003f4 	mov	x20, x0
 1112984:	f90013f5 	str	x21, [sp, #32]
	struct ts_session *sess = ts_get_current_session();
 1112988:	94000816 	bl	11149e0 <ts_get_current_session>
	struct user_mode_ctx *uctx = to_user_mode_ctx(sess->ctx);
 111298c:	f9400800 	ldr	x0, [x0, #16]
	size_t sz = ROUNDUP(num_bytes, SMALL_PAGE_SIZE);
 1112990:	9274ce73 	and	x19, x19, #0xfffffffffffff000
	struct user_mode_ctx *uctx = to_user_mode_ctx(sess->ctx);
 1112994:	97ffff77 	bl	1112770 <to_user_mode_ctx>
	uint32_t vm_flags = 0;
 1112998:	b9003fff 	str	wzr, [sp, #60]
	if (ADD_OVERFLOW(va, sz, &end_va))
 111299c:	ab130281 	adds	x1, x20, x19
 11129a0:	54000162 	b.cs	11129cc <ldelf_syscall_unmap+0x5c>  // b.hs, b.nlast
 11129a4:	aa0003f5 	mov	x21, x0
	res = vm_get_flags(uctx, va, sz, &vm_flags);
 11129a8:	9100f3e3 	add	x3, sp, #0x3c
 11129ac:	aa1303e2 	mov	x2, x19
 11129b0:	aa1403e1 	mov	x1, x20
 11129b4:	94001a4a 	bl	11192dc <vm_get_flags>
	if (res)
 11129b8:	340000e0 	cbz	w0, 11129d4 <ldelf_syscall_unmap+0x64>
}
 11129bc:	a94153f3 	ldp	x19, x20, [sp, #16]
 11129c0:	f94013f5 	ldr	x21, [sp, #32]
 11129c4:	a8c47bfd 	ldp	x29, x30, [sp], #64
 11129c8:	d65f03c0 	ret
		return TEE_ERROR_BAD_PARAMETERS;
 11129cc:	129fff20 	mov	w0, #0xffff0006            	// #-65530
 11129d0:	17fffffb 	b	11129bc <ldelf_syscall_unmap+0x4c>
	if (vm_flags & VM_FLAG_PERMANENT)
 11129d4:	b9403fe0 	ldr	w0, [sp, #60]
 11129d8:	370800c0 	tbnz	w0, #1, 11129f0 <ldelf_syscall_unmap+0x80>
	return vm_unmap(uctx, va, sz);
 11129dc:	aa1303e2 	mov	x2, x19
 11129e0:	aa1403e1 	mov	x1, x20
 11129e4:	aa1503e0 	mov	x0, x21
 11129e8:	94001a5a 	bl	1119350 <vm_unmap>
 11129ec:	17fffff4 	b	11129bc <ldelf_syscall_unmap+0x4c>
		return TEE_ERROR_ACCESS_DENIED;
 11129f0:	129fffc0 	mov	w0, #0xffff0001            	// #-65535
 11129f4:	17fffff2 	b	11129bc <ldelf_syscall_unmap+0x4c>

00000000011129f8 <ldelf_syscall_open_bin>:
{
 11129f8:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
 11129fc:	910003fd 	mov	x29, sp
 1112a00:	a90153f3 	stp	x19, x20, [sp, #16]
 1112a04:	aa0103f4 	mov	x20, x1
 1112a08:	a9025bf5 	stp	x21, x22, [sp, #32]
 1112a0c:	a90363f7 	stp	x23, x24, [sp, #48]
 1112a10:	aa0203f8 	mov	x24, x2
 1112a14:	aa0003f7 	mov	x23, x0
 1112a18:	a9046bf9 	stp	x25, x26, [sp, #64]
	struct ts_session *sess = ts_get_current_session();
 1112a1c:	940007f1 	bl	11149e0 <ts_get_current_session>
 1112a20:	aa0003f6 	mov	x22, x0
	struct user_mode_ctx *uctx = to_user_mode_ctx(sess->ctx);
 1112a24:	f9400800 	ldr	x0, [x0, #16]
 1112a28:	97ffff52 	bl	1112770 <to_user_mode_ctx>
 1112a2c:	aa0003f9 	mov	x25, x0
	unsigned int tag_len = sizeof(tag);
 1112a30:	52800401 	mov	w1, #0x20                  	// #32
	res = vm_check_access_rights(uctx,
 1112a34:	aa1703e2 	mov	x2, x23
 1112a38:	d2800203 	mov	x3, #0x10                  	// #16
	unsigned int tag_len = sizeof(tag);
 1112a3c:	b9005fe1 	str	w1, [sp, #92]
	res = vm_check_access_rights(uctx,
 1112a40:	528000a1 	mov	w1, #0x5                   	// #5
	struct system_ctx *sys_ctx = sess->user_ctx;
 1112a44:	f9400ed5 	ldr	x21, [x22, #24]
	uint8_t tag[FILE_TAG_SIZE] = { 0 };
 1112a48:	a9067fff 	stp	xzr, xzr, [sp, #96]
 1112a4c:	a9077fff 	stp	xzr, xzr, [sp, #112]
	res = vm_check_access_rights(uctx,
 1112a50:	94001b67 	bl	11197ec <vm_check_access_rights>
 1112a54:	2a0003f3 	mov	w19, w0
	if (res)
 1112a58:	35000220 	cbnz	w0, 1112a9c <ldelf_syscall_open_bin+0xa4>
	res = vm_check_access_rights(uctx,
 1112a5c:	aa1803e2 	mov	x2, x24
 1112a60:	aa1903e0 	mov	x0, x25
 1112a64:	d2800083 	mov	x3, #0x4                   	// #4
 1112a68:	528000c1 	mov	w1, #0x6                   	// #6
 1112a6c:	94001b60 	bl	11197ec <vm_check_access_rights>
 1112a70:	2a0003f3 	mov	w19, w0
	if (res)
 1112a74:	35000140 	cbnz	w0, 1112a9c <ldelf_syscall_open_bin+0xa4>
	if (uuid_size != sizeof(*uuid))
 1112a78:	f100429f 	cmp	x20, #0x10
 1112a7c:	54000d01 	b.ne	1112c1c <ldelf_syscall_open_bin+0x224>  // b.any
	if (!sys_ctx) {
 1112a80:	b50001f5 	cbnz	x21, 1112abc <ldelf_syscall_open_bin+0xc4>
		sys_ctx = calloc(1, sizeof(*sys_ctx));
 1112a84:	d2800301 	mov	x1, #0x18                  	// #24
 1112a88:	d2800020 	mov	x0, #0x1                   	// #1
 1112a8c:	9400c291 	bl	11434d0 <calloc>
 1112a90:	aa0003f5 	mov	x21, x0
		if (!sys_ctx)
 1112a94:	b5000120 	cbnz	x0, 1112ab8 <ldelf_syscall_open_bin+0xc0>
			return TEE_ERROR_OUT_OF_MEMORY;
 1112a98:	129ffe73 	mov	w19, #0xffff000c            	// #-65524
}
 1112a9c:	2a1303e0 	mov	w0, w19
 1112aa0:	a94153f3 	ldp	x19, x20, [sp, #16]
 1112aa4:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1112aa8:	a94363f7 	ldp	x23, x24, [sp, #48]
 1112aac:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1112ab0:	a8c87bfd 	ldp	x29, x30, [sp], #128
 1112ab4:	d65f03c0 	ret
		sess->user_ctx = sys_ctx;
 1112ab8:	f9000ec0 	str	x0, [x22, #24]
	binh = calloc(1, sizeof(*binh));
 1112abc:	d2800501 	mov	x1, #0x28                  	// #40
 1112ac0:	d2800020 	mov	x0, #0x1                   	// #1
 1112ac4:	9400c283 	bl	11434d0 <calloc>
 1112ac8:	aa0003f4 	mov	x20, x0
	if (!binh)
 1112acc:	b4fffe60 	cbz	x0, 1112a98 <ldelf_syscall_open_bin+0xa0>
	if (is_user_ta_ctx(sess->ctx) || is_stmm_ctx(sess->ctx)) {
 1112ad0:	f9400ac0 	ldr	x0, [x22, #16]
 1112ad4:	94000dc6 	bl	11161ec <is_user_ta_ctx>
 1112ad8:	72001c1f 	tst	w0, #0xff
 1112adc:	540009c0 	b.eq	1112c14 <ldelf_syscall_open_bin+0x21c>  // b.none
		SCATTERED_ARRAY_FOREACH(binh->op, ta_stores,
 1112ae0:	90000259 	adrp	x25, 115a000 <__scattered_array_1phys_mem_map+0x8>
			DMSG("Lookup user TA ELF %pUl (%s)",
 1112ae4:	d000021a 	adrp	x26, 1154000 <__func__.1786+0x8>
 1112ae8:	d0000216 	adrp	x22, 1154000 <__func__.1786+0x8>
		SCATTERED_ARRAY_FOREACH(binh->op, ta_stores,
 1112aec:	91080339 	add	x25, x25, #0x200
			DMSG("Lookup user TA ELF %pUl (%s)",
 1112af0:	910ddf5a 	add	x26, x26, #0x377
 1112af4:	910f52d6 	add	x22, x22, #0x3d4
		SCATTERED_ARRAY_FOREACH(binh->op, ta_stores,
 1112af8:	90000240 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1112afc:	91068000 	add	x0, x0, #0x1a0
 1112b00:	940007cc 	bl	1114a30 <scattered_array_relax_ptr>
 1112b04:	f9000280 	str	x0, [x20]
 1112b08:	f9400280 	ldr	x0, [x20]
 1112b0c:	eb19001f 	cmp	x0, x25
 1112b10:	54000363 	b.cc	1112b7c <ldelf_syscall_open_bin+0x184>  // b.lo, b.ul, b.last
	if (res)
 1112b14:	350002f3 	cbnz	w19, 1112b70 <ldelf_syscall_open_bin+0x178>
	res = binh->op->get_size(binh->h, &binh->size_bytes);
 1112b18:	aa1403e1 	mov	x1, x20
 1112b1c:	f8420420 	ldr	x0, [x1], #32
 1112b20:	f9400802 	ldr	x2, [x0, #16]
 1112b24:	f9400680 	ldr	x0, [x20, #8]
 1112b28:	d63f0040 	blr	x2
 1112b2c:	2a0003f3 	mov	w19, w0
	if (res)
 1112b30:	35000200 	cbnz	w0, 1112b70 <ldelf_syscall_open_bin+0x178>
	res = binh->op->get_tag(binh->h, tag, &tag_len);
 1112b34:	f9400280 	ldr	x0, [x20]
 1112b38:	910183f6 	add	x22, sp, #0x60
 1112b3c:	910173e2 	add	x2, sp, #0x5c
 1112b40:	aa1603e1 	mov	x1, x22
 1112b44:	f9400c03 	ldr	x3, [x0, #24]
 1112b48:	f9400680 	ldr	x0, [x20, #8]
 1112b4c:	d63f0060 	blr	x3
 1112b50:	2a0003f3 	mov	w19, w0
	if (res)
 1112b54:	350000e0 	cbnz	w0, 1112b70 <ldelf_syscall_open_bin+0x178>
	binh->f = file_get_by_tag(tag, tag_len);
 1112b58:	b9405fe1 	ldr	w1, [sp, #92]
 1112b5c:	aa1603e0 	mov	x0, x22
 1112b60:	9400170d 	bl	1118794 <file_get_by_tag>
 1112b64:	f9000a80 	str	x0, [x20, #16]
	if (!binh->f)
 1112b68:	b50004a0 	cbnz	x0, 1112bfc <ldelf_syscall_open_bin+0x204>
	res = TEE_ERROR_OUT_OF_MEMORY;
 1112b6c:	129ffe73 	mov	w19, #0xffff000c            	// #-65524
	bin_close(binh);
 1112b70:	aa1403e0 	mov	x0, x20
 1112b74:	97fffeae 	bl	111262c <bin_close>
	return res;
 1112b78:	17ffffc9 	b	1112a9c <ldelf_syscall_open_bin+0xa4>
			DMSG("Lookup user TA ELF %pUl (%s)",
 1112b7c:	f9400006 	ldr	x6, [x0]
 1112b80:	aa1703e5 	mov	x5, x23
 1112b84:	aa1a03e4 	mov	x4, x26
 1112b88:	52800023 	mov	w3, #0x1                   	// #1
 1112b8c:	aa1603e0 	mov	x0, x22
 1112b90:	52800062 	mov	w2, #0x3                   	// #3
 1112b94:	528011c1 	mov	w1, #0x8e                  	// #142
 1112b98:	9400c86b 	bl	1144d44 <trace_printf>
			res = binh->op->open(uuid, &binh->h);
 1112b9c:	aa1403e1 	mov	x1, x20
 1112ba0:	f8408420 	ldr	x0, [x1], #8
 1112ba4:	f9400402 	ldr	x2, [x0, #8]
 1112ba8:	aa1703e0 	mov	x0, x23
 1112bac:	d63f0040 	blr	x2
 1112bb0:	2a0003f3 	mov	w19, w0
			DMSG("res=%#"PRIx32, res);
 1112bb4:	2a0003e5 	mov	w5, w0
 1112bb8:	d0000204 	adrp	x4, 1154000 <__func__.1786+0x8>
 1112bbc:	aa1603e0 	mov	x0, x22
 1112bc0:	910e5084 	add	x4, x4, #0x394
 1112bc4:	52800023 	mov	w3, #0x1                   	// #1
 1112bc8:	52800062 	mov	w2, #0x3                   	// #3
 1112bcc:	52801241 	mov	w1, #0x92                  	// #146
 1112bd0:	9400c85d 	bl	1144d44 <trace_printf>
			if (res != TEE_ERROR_ITEM_NOT_FOUND &&
 1112bd4:	129ffee0 	mov	w0, #0xffff0008            	// #-65528
 1112bd8:	6b00027f 	cmp	w19, w0
 1112bdc:	52800060 	mov	w0, #0x3                   	// #3
 1112be0:	72be0200 	movk	w0, #0xf010, lsl #16
 1112be4:	7a401264 	ccmp	w19, w0, #0x4, ne  // ne = any
 1112be8:	54fff961 	b.ne	1112b14 <ldelf_syscall_open_bin+0x11c>  // b.any
		SCATTERED_ARRAY_FOREACH(binh->op, ta_stores,
 1112bec:	f9400280 	ldr	x0, [x20]
 1112bf0:	9100c000 	add	x0, x0, #0x30
 1112bf4:	f9000280 	str	x0, [x20]
 1112bf8:	17ffffc4 	b	1112b08 <ldelf_syscall_open_bin+0x110>
	h = handle_get(&sys_ctx->db, binh);
 1112bfc:	aa1403e1 	mov	x1, x20
 1112c00:	aa1503e0 	mov	x0, x21
 1112c04:	97fffe10 	bl	1112444 <handle_get>
	if (h < 0)
 1112c08:	37fffb20 	tbnz	w0, #31, 1112b6c <ldelf_syscall_open_bin+0x174>
	*handle = h;
 1112c0c:	b9000300 	str	w0, [x24]
	return TEE_SUCCESS;
 1112c10:	17ffffa3 	b	1112a9c <ldelf_syscall_open_bin+0xa4>
		res = TEE_ERROR_ITEM_NOT_FOUND;
 1112c14:	129ffef3 	mov	w19, #0xffff0008            	// #-65528
 1112c18:	17ffffd6 	b	1112b70 <ldelf_syscall_open_bin+0x178>
		return TEE_ERROR_BAD_PARAMETERS;
 1112c1c:	129fff33 	mov	w19, #0xffff0006            	// #-65530
 1112c20:	17ffff9f 	b	1112a9c <ldelf_syscall_open_bin+0xa4>

0000000001112c24 <ldelf_syscall_close_bin>:
{
 1112c24:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1112c28:	910003fd 	mov	x29, sp
 1112c2c:	a90153f3 	stp	x19, x20, [sp, #16]
 1112c30:	aa0003f3 	mov	x19, x0
 1112c34:	a9025bf5 	stp	x21, x22, [sp, #32]
	struct ts_session *sess = ts_get_current_session();
 1112c38:	9400076a 	bl	11149e0 <ts_get_current_session>
	struct system_ctx *sys_ctx = sess->user_ctx;
 1112c3c:	f9400c15 	ldr	x21, [x0, #24]
	if (!sys_ctx)
 1112c40:	b50000f5 	cbnz	x21, 1112c5c <ldelf_syscall_close_bin+0x38>
		return TEE_ERROR_BAD_PARAMETERS;
 1112c44:	129fff34 	mov	w20, #0xffff0006            	// #-65530
}
 1112c48:	2a1403e0 	mov	w0, w20
 1112c4c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1112c50:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1112c54:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1112c58:	d65f03c0 	ret
	binh = handle_put(&sys_ctx->db, handle);
 1112c5c:	2a1303e1 	mov	w1, w19
 1112c60:	aa0003f6 	mov	x22, x0
 1112c64:	aa1503e0 	mov	x0, x21
 1112c68:	97fffe26 	bl	1112500 <handle_put>
 1112c6c:	aa0003f3 	mov	x19, x0
	if (!binh)
 1112c70:	b4fffea0 	cbz	x0, 1112c44 <ldelf_syscall_close_bin+0x20>
	if (binh->offs_bytes < binh->size_bytes)
 1112c74:	a9418800 	ldp	x0, x2, [x0, #24]
 1112c78:	eb02001f 	cmp	x0, x2
 1112c7c:	540002a2 	b.cs	1112cd0 <ldelf_syscall_close_bin+0xac>  // b.hs, b.nlast
		res = binh->op->read(binh->h, NULL,
 1112c80:	cb000042 	sub	x2, x2, x0
 1112c84:	a9400261 	ldp	x1, x0, [x19]
 1112c88:	f9401023 	ldr	x3, [x1, #32]
 1112c8c:	d2800001 	mov	x1, #0x0                   	// #0
 1112c90:	d63f0060 	blr	x3
 1112c94:	2a0003f4 	mov	w20, w0
	bin_close(binh);
 1112c98:	aa1303e0 	mov	x0, x19
 1112c9c:	97fffe64 	bl	111262c <bin_close>
	if (handle_db_is_empty(&sys_ctx->db)) {
 1112ca0:	aa1503e0 	mov	x0, x21
 1112ca4:	97fffdda 	bl	111240c <handle_db_is_empty>
 1112ca8:	72001c1f 	tst	w0, #0xff
 1112cac:	54fffce0 	b.eq	1112c48 <ldelf_syscall_close_bin+0x24>  // b.none
		handle_db_destroy(&sys_ctx->db, bin_close);
 1112cb0:	90000001 	adrp	x1, 1112000 <gic_op_add+0xb4>
 1112cb4:	9118b021 	add	x1, x1, #0x62c
 1112cb8:	aa1503e0 	mov	x0, x21
 1112cbc:	97fffdba 	bl	11123a4 <handle_db_destroy>
		free(sys_ctx);
 1112cc0:	aa1503e0 	mov	x0, x21
 1112cc4:	9400c247 	bl	11435e0 <free>
		sess->user_ctx = NULL;
 1112cc8:	f9000edf 	str	xzr, [x22, #24]
 1112ccc:	17ffffdf 	b	1112c48 <ldelf_syscall_close_bin+0x24>
	TEE_Result res = TEE_SUCCESS;
 1112cd0:	52800014 	mov	w20, #0x0                   	// #0
 1112cd4:	17fffff1 	b	1112c98 <ldelf_syscall_close_bin+0x74>

0000000001112cd8 <ldelf_syscall_map_bin>:

TEE_Result ldelf_syscall_map_bin(vaddr_t *va, size_t num_bytes,
				 unsigned long handle, size_t offs_bytes,
				 size_t pad_begin, size_t pad_end,
				 unsigned long flags)
{
 1112cd8:	d10243ff 	sub	sp, sp, #0x90
 1112cdc:	a9017bfd 	stp	x29, x30, [sp, #16]
 1112ce0:	910043fd 	add	x29, sp, #0x10
 1112ce4:	a90253f3 	stp	x19, x20, [sp, #32]
 1112ce8:	aa0203f4 	mov	x20, x2
 1112cec:	a9035bf5 	stp	x21, x22, [sp, #48]
 1112cf0:	aa0603f6 	mov	x22, x6
 1112cf4:	a90463f7 	stp	x23, x24, [sp, #64]
 1112cf8:	aa0003f7 	mov	x23, x0
 1112cfc:	a9056bf9 	stp	x25, x26, [sp, #80]
 1112d00:	aa0303fa 	mov	x26, x3
 1112d04:	a90673fb 	stp	x27, x28, [sp, #96]
 1112d08:	aa0403fb 	mov	x27, x4
 1112d0c:	a90797e1 	stp	x1, x5, [sp, #120]
	TEE_Result res = TEE_SUCCESS;
	struct ts_session *sess = ts_get_current_session();
 1112d10:	94000734 	bl	11149e0 <ts_get_current_session>
 1112d14:	aa0003f3 	mov	x19, x0
	struct user_mode_ctx *uctx = to_user_mode_ctx(sess->ctx);
 1112d18:	f9400800 	ldr	x0, [x0, #16]
 1112d1c:	97fffe95 	bl	1112770 <to_user_mode_ctx>
 1112d20:	aa0003f5 	mov	x21, x0
	struct system_ctx *sys_ctx = sess->user_ctx;
 1112d24:	f9400e60 	ldr	x0, [x19, #24]
	uint32_t prot = 0;
	const uint32_t accept_flags = LDELF_MAP_FLAG_SHAREABLE |
				      LDELF_MAP_FLAG_WRITEABLE |
				      LDELF_MAP_FLAG_EXECUTABLE;

	if (!sys_ctx)
 1112d28:	b5000160 	cbnz	x0, 1112d54 <ldelf_syscall_map_bin+0x7c>
		return TEE_ERROR_BAD_PARAMETERS;
 1112d2c:	129fff3b 	mov	w27, #0xffff0006            	// #-65530
err:
	if (file_is_locked)
		file_unlock(binh->f);

	return res;
}
 1112d30:	2a1b03e0 	mov	w0, w27
 1112d34:	a9417bfd 	ldp	x29, x30, [sp, #16]
 1112d38:	a94253f3 	ldp	x19, x20, [sp, #32]
 1112d3c:	a9435bf5 	ldp	x21, x22, [sp, #48]
 1112d40:	a94463f7 	ldp	x23, x24, [sp, #64]
 1112d44:	a9456bf9 	ldp	x25, x26, [sp, #80]
 1112d48:	a94673fb 	ldp	x27, x28, [sp, #96]
 1112d4c:	910243ff 	add	sp, sp, #0x90
 1112d50:	d65f03c0 	ret
	binh = handle_lookup(&sys_ctx->db, handle);
 1112d54:	2a1403e1 	mov	w1, w20
 1112d58:	97fffdf8 	bl	1112538 <handle_lookup>
 1112d5c:	aa0003f3 	mov	x19, x0
	if (!binh)
 1112d60:	b4fffe60 	cbz	x0, 1112d2c <ldelf_syscall_map_bin+0x54>
	if ((flags & accept_flags) != flags)
 1112d64:	f27df2df 	tst	x22, #0xfffffffffffffff8
 1112d68:	54fffe21 	b.ne	1112d2c <ldelf_syscall_map_bin+0x54>  // b.any
	if ((flags & LDELF_MAP_FLAG_SHAREABLE) &&
 1112d6c:	924006c0 	and	x0, x22, #0x3
 1112d70:	f1000c1f 	cmp	x0, #0x3
 1112d74:	54fffdc0 	b.eq	1112d2c <ldelf_syscall_map_bin+0x54>  // b.none
	if ((flags & LDELF_MAP_FLAG_EXECUTABLE) &&
 1112d78:	927f06c0 	and	x0, x22, #0x6
 1112d7c:	f100181f 	cmp	x0, #0x6
 1112d80:	54fffd60 	b.eq	1112d2c <ldelf_syscall_map_bin+0x54>  // b.none
	if (offs_bytes & SMALL_PAGE_MASK)
 1112d84:	f2402f5f 	tst	x26, #0xfff
 1112d88:	54fffd21 	b.ne	1112d2c <ldelf_syscall_map_bin+0x54>  // b.any
		prot |= TEE_MATTR_UW | TEE_MATTR_PW;
 1112d8c:	f27f02c0 	ands	x0, x22, #0x2
 1112d90:	f9003be0 	str	x0, [sp, #112]
 1112d94:	52801218 	mov	w24, #0x90                  	// #144
 1112d98:	52803600 	mov	w0, #0x1b0                 	// #432
 1112d9c:	1a800318 	csel	w24, w24, w0, eq  // eq = none
	if (flags & LDELF_MAP_FLAG_EXECUTABLE)
 1112da0:	36100056 	tbz	w22, #2, 1112da8 <ldelf_syscall_map_bin+0xd0>
		prot |= TEE_MATTR_UX;
 1112da4:	32170318 	orr	w24, w24, #0x200
	if (ROUNDUP_OVERFLOW(num_bytes, SMALL_PAGE_SIZE, &num_rounded_bytes))
 1112da8:	f9403fe0 	ldr	x0, [sp, #120]
	offs_pages = offs_bytes >> SMALL_PAGE_SHIFT;
 1112dac:	d34cff59 	lsr	x25, x26, #12
	if (ROUNDUP_OVERFLOW(num_bytes, SMALL_PAGE_SIZE, &num_rounded_bytes))
 1112db0:	b13ffc14 	adds	x20, x0, #0xfff
 1112db4:	1a9f37e0 	cset	w0, cs  // cs = hs, nlast
 1112db8:	f2607e9f 	tst	x20, #0xffffffff00000000
 1112dbc:	54000461 	b.ne	1112e48 <ldelf_syscall_map_bin+0x170>  // b.any
 1112dc0:	35000440 	cbnz	w0, 1112e48 <ldelf_syscall_map_bin+0x170>
 1112dc4:	12144e94 	and	w20, w20, #0xfffff000
	if (!file_trylock(binh->f)) {
 1112dc8:	f9400a60 	ldr	x0, [x19, #16]
	num_pages = num_rounded_bytes / SMALL_PAGE_SIZE;
 1112dcc:	530c7e9c 	lsr	w28, w20, #12
	if (!file_trylock(binh->f)) {
 1112dd0:	9400172a 	bl	1118a78 <file_trylock>
 1112dd4:	72001c1f 	tst	w0, #0xff
 1112dd8:	540000e1 	b.ne	1112df4 <ldelf_syscall_map_bin+0x11c>  // b.any
		vm_set_ctx(NULL);
 1112ddc:	d2800000 	mov	x0, #0x0                   	// #0
 1112de0:	94001abf 	bl	11198dc <vm_set_ctx>
		file_lock(binh->f);
 1112de4:	f9400a60 	ldr	x0, [x19, #16]
 1112de8:	94001722 	bl	1118a70 <file_lock>
		vm_set_ctx(uctx->ts_ctx);
 1112dec:	f94122a0 	ldr	x0, [x21, #576]
 1112df0:	94001abb 	bl	11198dc <vm_set_ctx>
	fs = file_find_slice(binh->f, offs_pages);
 1112df4:	f9400a60 	ldr	x0, [x19, #16]
 1112df8:	2a1903e1 	mov	w1, w25
 1112dfc:	940016d2 	bl	1118944 <file_find_slice>
 1112e00:	aa0003e1 	mov	x1, x0
	if (fs) {
 1112e04:	b40004c0 	cbz	x0, 1112e9c <ldelf_syscall_map_bin+0x1c4>
		if (fs->page_offset != offs_pages ||
 1112e08:	b9400800 	ldr	w0, [x0, #8]
 1112e0c:	6b19001f 	cmp	w0, w25
 1112e10:	54000d81 	b.ne	1112fc0 <ldelf_syscall_map_bin+0x2e8>  // b.any
		    num_pages > fs->fobj->num_pages) {
 1112e14:	f9400020 	ldr	x0, [x1]
		if (fs->page_offset != offs_pages ||
 1112e18:	b9400801 	ldr	w1, [x0, #8]
 1112e1c:	6b01039f 	cmp	w28, w1
 1112e20:	54000d08 	b.hi	1112fc0 <ldelf_syscall_map_bin+0x2e8>  // b.pmore
		if (!(flags & LDELF_MAP_FLAG_SHAREABLE)) {
 1112e24:	36000cf6 	tbz	w22, #0, 1112fc0 <ldelf_syscall_map_bin+0x2e8>
		mobj = mobj_with_fobj_alloc(fs->fobj, binh->f);
 1112e28:	f9400a61 	ldr	x1, [x19, #16]
 1112e2c:	9400158e 	bl	1118464 <mobj_with_fobj_alloc>
 1112e30:	aa0003f6 	mov	x22, x0
		if (!mobj) {
 1112e34:	b50000e0 	cbnz	x0, 1112e50 <ldelf_syscall_map_bin+0x178>
			res = TEE_ERROR_OUT_OF_MEMORY;
 1112e38:	129ffe7b 	mov	w27, #0xffff000c            	// #-65524
		file_unlock(binh->f);
 1112e3c:	f9400a60 	ldr	x0, [x19, #16]
 1112e40:	94001710 	bl	1118a80 <file_unlock>
	return res;
 1112e44:	17ffffbb 	b	1112d30 <ldelf_syscall_map_bin+0x58>
	uint32_t num_rounded_bytes = 0;
 1112e48:	d2800014 	mov	x20, #0x0                   	// #0
 1112e4c:	17ffffdf 	b	1112dc8 <ldelf_syscall_map_bin+0xf0>
		res = vm_map_pad(uctx, va, num_rounded_bytes,
 1112e50:	aa0003e5 	mov	x5, x0
 1112e54:	aa1b03e7 	mov	x7, x27
 1112e58:	f94043e0 	ldr	x0, [sp, #128]
 1112e5c:	2a1803e3 	mov	w3, w24
 1112e60:	2a1403e2 	mov	w2, w20
 1112e64:	aa1703e1 	mov	x1, x23
 1112e68:	a9007fe0 	stp	x0, xzr, [sp]
 1112e6c:	d2800006 	mov	x6, #0x0                   	// #0
 1112e70:	52800204 	mov	w4, #0x10                  	// #16
 1112e74:	aa1503e0 	mov	x0, x21
 1112e78:	94001b30 	bl	1119b38 <vm_map_pad>
 1112e7c:	2a0003fb 	mov	w27, w0
		mobj_put(mobj);
 1112e80:	aa1603e0 	mov	x0, x22
 1112e84:	97fffe6f 	bl	1112840 <mobj_put>
		if (res)
 1112e88:	35fffdbb 	cbnz	w27, 1112e3c <ldelf_syscall_map_bin+0x164>
	file_unlock(binh->f);
 1112e8c:	f9400a60 	ldr	x0, [x19, #16]
	return TEE_SUCCESS;
 1112e90:	5280001b 	mov	w27, #0x0                   	// #0
	file_unlock(binh->f);
 1112e94:	940016fb 	bl	1118a80 <file_unlock>
	return TEE_SUCCESS;
 1112e98:	17ffffa6 	b	1112d30 <ldelf_syscall_map_bin+0x58>
		struct fobj *f = fobj_ta_mem_alloc(num_pages);
 1112e9c:	2a1c03e0 	mov	w0, w28
 1112ea0:	f90047e1 	str	x1, [sp, #136]
 1112ea4:	940015e9 	bl	1118648 <fobj_sec_mem_alloc>
 1112ea8:	aa0003f6 	mov	x22, x0
		if (!f) {
 1112eac:	b4fffc60 	cbz	x0, 1112e38 <ldelf_syscall_map_bin+0x160>
		if (!(flags & LDELF_MAP_FLAG_WRITEABLE)) {
 1112eb0:	f9403be0 	ldr	x0, [sp, #112]
 1112eb4:	f94047e1 	ldr	x1, [sp, #136]
 1112eb8:	b50007a0 	cbnz	x0, 1112fac <ldelf_syscall_map_bin+0x2d4>
			file = binh->f;
 1112ebc:	f9400a61 	ldr	x1, [x19, #16]
			vm_flags |= VM_FLAG_READONLY;
 1112ec0:	52800204 	mov	w4, #0x10                  	// #16
		mobj = mobj_with_fobj_alloc(f, file);
 1112ec4:	aa1603e0 	mov	x0, x22
 1112ec8:	b9008be4 	str	w4, [sp, #136]
 1112ecc:	94001566 	bl	1118464 <mobj_with_fobj_alloc>
 1112ed0:	aa0003fc 	mov	x28, x0
		fobj_put(f);
 1112ed4:	aa1603e0 	mov	x0, x22
 1112ed8:	97fffe46 	bl	11127f0 <fobj_put>
		if (!mobj) {
 1112edc:	b4fffafc 	cbz	x28, 1112e38 <ldelf_syscall_map_bin+0x160>
		res = vm_map_pad(uctx, va, num_rounded_bytes,
 1112ee0:	b9408be4 	ldr	w4, [sp, #136]
 1112ee4:	aa1b03e7 	mov	x7, x27
 1112ee8:	f94043e0 	ldr	x0, [sp, #128]
 1112eec:	aa1c03e5 	mov	x5, x28
 1112ef0:	aa1403e2 	mov	x2, x20
 1112ef4:	aa1703e1 	mov	x1, x23
 1112ef8:	a9007fe0 	stp	x0, xzr, [sp]
 1112efc:	d2800006 	mov	x6, #0x0                   	// #0
 1112f00:	52800603 	mov	w3, #0x30                  	// #48
 1112f04:	aa1503e0 	mov	x0, x21
 1112f08:	94001b0c 	bl	1119b38 <vm_map_pad>
 1112f0c:	2a0003fb 	mov	w27, w0
		mobj_put(mobj);
 1112f10:	aa1c03e0 	mov	x0, x28
 1112f14:	97fffe4b 	bl	1112840 <mobj_put>
		if (res)
 1112f18:	35fff93b 	cbnz	w27, 1112e3c <ldelf_syscall_map_bin+0x164>
		res = binh_copy_to(binh, *va, offs_bytes, num_bytes);
 1112f1c:	f94002e1 	ldr	x1, [x23]
 1112f20:	aa1a03e2 	mov	x2, x26
 1112f24:	f9403fe3 	ldr	x3, [sp, #120]
 1112f28:	aa1303e0 	mov	x0, x19
 1112f2c:	97fffdd1 	bl	1112670 <binh_copy_to>
 1112f30:	2a0003fb 	mov	w27, w0
		if (res)
 1112f34:	35000240 	cbnz	w0, 1112f7c <ldelf_syscall_map_bin+0x2a4>
		res = vm_set_prot(uctx, *va, num_rounded_bytes,
 1112f38:	f94002e1 	ldr	x1, [x23]
 1112f3c:	2a1803e3 	mov	w3, w24
 1112f40:	aa1403e2 	mov	x2, x20
 1112f44:	aa1503e0 	mov	x0, x21
 1112f48:	94001ce2 	bl	111a2d0 <vm_set_prot>
 1112f4c:	2a0003fb 	mov	w27, w0
		if (res)
 1112f50:	35000160 	cbnz	w0, 1112f7c <ldelf_syscall_map_bin+0x2a4>
		vm_set_ctx(uctx->ts_ctx);
 1112f54:	f94122a0 	ldr	x0, [x21, #576]
 1112f58:	94001a61 	bl	11198dc <vm_set_ctx>
		if (!(flags & LDELF_MAP_FLAG_WRITEABLE)) {
 1112f5c:	f9403be0 	ldr	x0, [sp, #112]
 1112f60:	b5fff960 	cbnz	x0, 1112e8c <ldelf_syscall_map_bin+0x1b4>
			res = file_add_slice(binh->f, f, offs_pages);
 1112f64:	f9400a60 	ldr	x0, [x19, #16]
 1112f68:	2a1903e2 	mov	w2, w25
 1112f6c:	aa1603e1 	mov	x1, x22
 1112f70:	9400168f 	bl	11189ac <file_add_slice>
 1112f74:	2a0003fb 	mov	w27, w0
			if (res)
 1112f78:	34fff8a0 	cbz	w0, 1112e8c <ldelf_syscall_map_bin+0x1b4>
	if (vm_unmap(uctx, *va, num_rounded_bytes))
 1112f7c:	f94002e1 	ldr	x1, [x23]
 1112f80:	aa1403e2 	mov	x2, x20
 1112f84:	aa1503e0 	mov	x0, x21
 1112f88:	940018f2 	bl	1119350 <vm_unmap>
 1112f8c:	34000140 	cbz	w0, 1112fb4 <ldelf_syscall_map_bin+0x2dc>
		panic();
 1112f90:	d0000202 	adrp	x2, 1154000 <__func__.1786+0x8>
 1112f94:	d0000200 	adrp	x0, 1154000 <__func__.1786+0x8>
 1112f98:	910fac42 	add	x2, x2, #0x3eb
 1112f9c:	910e7000 	add	x0, x0, #0x39c
 1112fa0:	d2800003 	mov	x3, #0x0                   	// #0
 1112fa4:	52803281 	mov	w1, #0x194                 	// #404
 1112fa8:	94000130 	bl	1113468 <__do_panic>
		uint32_t vm_flags = 0;
 1112fac:	52800004 	mov	w4, #0x0                   	// #0
 1112fb0:	17ffffc5 	b	1112ec4 <ldelf_syscall_map_bin+0x1ec>
	vm_set_ctx(uctx->ts_ctx);
 1112fb4:	f94122a0 	ldr	x0, [x21, #576]
 1112fb8:	94001a49 	bl	11198dc <vm_set_ctx>
 1112fbc:	17ffffa0 	b	1112e3c <ldelf_syscall_map_bin+0x164>
			res = TEE_ERROR_BAD_PARAMETERS;
 1112fc0:	129fff3b 	mov	w27, #0xffff0006            	// #-65530
 1112fc4:	17ffff9e 	b	1112e3c <ldelf_syscall_map_bin+0x164>

0000000001112fc8 <ldelf_syscall_copy_from_bin>:

TEE_Result ldelf_syscall_copy_from_bin(void *dst, size_t offs, size_t num_bytes,
				       unsigned long handle)
{
 1112fc8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 1112fcc:	910003fd 	mov	x29, sp
 1112fd0:	a90153f3 	stp	x19, x20, [sp, #16]
 1112fd4:	aa0203f4 	mov	x20, x2
 1112fd8:	aa0003f3 	mov	x19, x0
 1112fdc:	a9025bf5 	stp	x21, x22, [sp, #32]
 1112fe0:	aa0103f6 	mov	x22, x1
 1112fe4:	f9001bf7 	str	x23, [sp, #48]
 1112fe8:	aa0303f7 	mov	x23, x3
	TEE_Result res = TEE_SUCCESS;
	struct ts_session *sess = ts_get_current_session();
 1112fec:	9400067d 	bl	11149e0 <ts_get_current_session>
 1112ff0:	aa0003f5 	mov	x21, x0
	struct user_mode_ctx *uctx = to_user_mode_ctx(sess->ctx);
 1112ff4:	f9400800 	ldr	x0, [x0, #16]
 1112ff8:	97fffdde 	bl	1112770 <to_user_mode_ctx>
	struct system_ctx *sys_ctx = sess->user_ctx;
	struct bin_handle *binh = NULL;

	res = vm_check_access_rights(uctx,
 1112ffc:	aa1403e3 	mov	x3, x20
 1113000:	aa1303e2 	mov	x2, x19
 1113004:	528000c1 	mov	w1, #0x6                   	// #6
	struct system_ctx *sys_ctx = sess->user_ctx;
 1113008:	f9400eb5 	ldr	x21, [x21, #24]
	res = vm_check_access_rights(uctx,
 111300c:	940019f8 	bl	11197ec <vm_check_access_rights>
				     TEE_MEMORY_ACCESS_WRITE |
				     TEE_MEMORY_ACCESS_ANY_OWNER,
				     (uaddr_t)dst, num_bytes);
	if (res)
 1113010:	35000060 	cbnz	w0, 111301c <ldelf_syscall_copy_from_bin+0x54>
		return res;

	if (!sys_ctx)
 1113014:	b50000f5 	cbnz	x21, 1113030 <ldelf_syscall_copy_from_bin+0x68>
		return TEE_ERROR_BAD_PARAMETERS;
 1113018:	129fff20 	mov	w0, #0xffff0006            	// #-65530
	binh = handle_lookup(&sys_ctx->db, handle);
	if (!binh)
		return TEE_ERROR_BAD_PARAMETERS;

	return binh_copy_to(binh, (vaddr_t)dst, offs, num_bytes);
}
 111301c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1113020:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1113024:	f9401bf7 	ldr	x23, [sp, #48]
 1113028:	a8c47bfd 	ldp	x29, x30, [sp], #64
 111302c:	d65f03c0 	ret
	binh = handle_lookup(&sys_ctx->db, handle);
 1113030:	2a1703e1 	mov	w1, w23
 1113034:	aa1503e0 	mov	x0, x21
 1113038:	97fffd40 	bl	1112538 <handle_lookup>
	if (!binh)
 111303c:	b4fffee0 	cbz	x0, 1113018 <ldelf_syscall_copy_from_bin+0x50>
	return binh_copy_to(binh, (vaddr_t)dst, offs, num_bytes);
 1113040:	aa1403e3 	mov	x3, x20
 1113044:	aa1603e2 	mov	x2, x22
 1113048:	aa1303e1 	mov	x1, x19
}
 111304c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1113050:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1113054:	f9401bf7 	ldr	x23, [sp, #48]
 1113058:	a8c47bfd 	ldp	x29, x30, [sp], #64
	return binh_copy_to(binh, (vaddr_t)dst, offs, num_bytes);
 111305c:	17fffd85 	b	1112670 <binh_copy_to>

0000000001113060 <ldelf_syscall_set_prot>:

TEE_Result ldelf_syscall_set_prot(unsigned long va, size_t num_bytes,
				  unsigned long flags)
{
 1113060:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 1113064:	910003fd 	mov	x29, sp
 1113068:	a90153f3 	stp	x19, x20, [sp, #16]
 111306c:	aa0103f3 	mov	x19, x1
 1113070:	aa0003f4 	mov	x20, x0
 1113074:	a9025bf5 	stp	x21, x22, [sp, #32]
 1113078:	aa0203f5 	mov	x21, x2
	TEE_Result res = TEE_SUCCESS;
	struct ts_session *sess = ts_get_current_session();
 111307c:	94000659 	bl	11149e0 <ts_get_current_session>
	struct user_mode_ctx *uctx = to_user_mode_ctx(sess->ctx);
 1113080:	f9400800 	ldr	x0, [x0, #16]
 1113084:	97fffdbb 	bl	1112770 <to_user_mode_ctx>
	size_t sz = ROUNDUP(num_bytes, SMALL_PAGE_SIZE);
	uint32_t prot = TEE_MATTR_UR | TEE_MATTR_PR;
	uint32_t vm_flags = 0;
 1113088:	b9003fff 	str	wzr, [sp, #60]
	vaddr_t end_va = 0;
	const uint32_t accept_flags = LDELF_MAP_FLAG_WRITEABLE |
				      LDELF_MAP_FLAG_EXECUTABLE;

	if ((flags & accept_flags) != flags)
 111308c:	f27df6bf 	tst	x21, #0xfffffffffffffff9
 1113090:	54000481 	b.ne	1113120 <ldelf_syscall_set_prot+0xc0>  // b.any
 1113094:	aa0003f6 	mov	x22, x0
 1113098:	927f06a0 	and	x0, x21, #0x6
		return TEE_ERROR_BAD_PARAMETERS;
	if (flags & LDELF_MAP_FLAG_WRITEABLE)
		prot |= TEE_MATTR_UW | TEE_MATTR_PW;
 111309c:	52803601 	mov	w1, #0x1b0                 	// #432
 11130a0:	52801215 	mov	w21, #0x90                  	// #144
 11130a4:	f27f001f 	tst	x0, #0x2
 11130a8:	1a8102b5 	csel	w21, w21, w1, eq  // eq = none
	if (flags & LDELF_MAP_FLAG_EXECUTABLE)
 11130ac:	f27e001f 	tst	x0, #0x4
 11130b0:	54000040 	b.eq	11130b8 <ldelf_syscall_set_prot+0x58>  // b.none
		prot |= TEE_MATTR_UX;
 11130b4:	321702b5 	orr	w21, w21, #0x200
	size_t sz = ROUNDUP(num_bytes, SMALL_PAGE_SIZE);
 11130b8:	913ffe73 	add	x19, x19, #0xfff
 11130bc:	9274ce73 	and	x19, x19, #0xfffffffffffff000
	 * The vm_get_flags() and vm_unmap() are supposed to detect or handle
	 * overflow directly or indirectly. However, since this function is an
	 * API function it's worth having an extra guard here. If nothing else,
	 * to increase code clarity.
	 */
	if (ADD_OVERFLOW(va, sz, &end_va))
 11130c0:	ab130280 	adds	x0, x20, x19
 11130c4:	540002e2 	b.cs	1113120 <ldelf_syscall_set_prot+0xc0>  // b.hs, b.nlast
		return TEE_ERROR_BAD_PARAMETERS;

	res = vm_get_flags(uctx, va, sz, &vm_flags);
 11130c8:	9100f3e3 	add	x3, sp, #0x3c
 11130cc:	aa1303e2 	mov	x2, x19
 11130d0:	aa1403e1 	mov	x1, x20
 11130d4:	aa1603e0 	mov	x0, x22
 11130d8:	94001881 	bl	11192dc <vm_get_flags>
	if (res)
 11130dc:	340000a0 	cbz	w0, 11130f0 <ldelf_syscall_set_prot+0x90>
	if ((vm_flags & VM_FLAG_READONLY) &&
	    (prot & (TEE_MATTR_UW | TEE_MATTR_PW)))
		return TEE_ERROR_ACCESS_DENIED;

	return vm_set_prot(uctx, va, sz, prot);
}
 11130e0:	a94153f3 	ldp	x19, x20, [sp, #16]
 11130e4:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11130e8:	a8c47bfd 	ldp	x29, x30, [sp], #64
 11130ec:	d65f03c0 	ret
	if (vm_flags & VM_FLAG_PERMANENT)
 11130f0:	b9403fe0 	ldr	w0, [sp, #60]
 11130f4:	370801a0 	tbnz	w0, #1, 1113128 <ldelf_syscall_set_prot+0xc8>
	if ((vm_flags & VM_FLAG_READONLY) &&
 11130f8:	36200080 	tbz	w0, #4, 1113108 <ldelf_syscall_set_prot+0xa8>
 11130fc:	52802400 	mov	w0, #0x120                 	// #288
 1113100:	6a0002bf 	tst	w21, w0
 1113104:	54000121 	b.ne	1113128 <ldelf_syscall_set_prot+0xc8>  // b.any
	return vm_set_prot(uctx, va, sz, prot);
 1113108:	2a1503e3 	mov	w3, w21
 111310c:	aa1303e2 	mov	x2, x19
 1113110:	aa1403e1 	mov	x1, x20
 1113114:	aa1603e0 	mov	x0, x22
 1113118:	94001c6e 	bl	111a2d0 <vm_set_prot>
 111311c:	17fffff1 	b	11130e0 <ldelf_syscall_set_prot+0x80>
		return TEE_ERROR_BAD_PARAMETERS;
 1113120:	129fff20 	mov	w0, #0xffff0006            	// #-65530
 1113124:	17ffffef 	b	11130e0 <ldelf_syscall_set_prot+0x80>
		return TEE_ERROR_ACCESS_DENIED;
 1113128:	129fffc0 	mov	w0, #0xffff0001            	// #-65535
 111312c:	17ffffed 	b	11130e0 <ldelf_syscall_set_prot+0x80>

0000000001113130 <ldelf_syscall_remap>:

TEE_Result ldelf_syscall_remap(unsigned long old_va, vaddr_t *new_va,
			       size_t num_bytes, size_t pad_begin,
			       size_t pad_end)
{
 1113130:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 1113134:	910003fd 	mov	x29, sp
 1113138:	a90153f3 	stp	x19, x20, [sp, #16]
 111313c:	aa0203f4 	mov	x20, x2
 1113140:	aa0003f3 	mov	x19, x0
 1113144:	a9025bf5 	stp	x21, x22, [sp, #32]
 1113148:	aa0103f6 	mov	x22, x1
 111314c:	a90363f7 	stp	x23, x24, [sp, #48]
 1113150:	aa0303f7 	mov	x23, x3
 1113154:	aa0403f8 	mov	x24, x4
	TEE_Result res = TEE_SUCCESS;
	struct ts_session *sess = ts_get_current_session();
 1113158:	94000622 	bl	11149e0 <ts_get_current_session>
	struct user_mode_ctx *uctx = to_user_mode_ctx(sess->ctx);
 111315c:	f9400800 	ldr	x0, [x0, #16]
 1113160:	97fffd84 	bl	1112770 <to_user_mode_ctx>
 1113164:	aa0003f5 	mov	x21, x0
	uint32_t vm_flags = 0;

	res = vm_get_flags(uctx, old_va, num_bytes, &vm_flags);
 1113168:	910133e3 	add	x3, sp, #0x4c
 111316c:	aa1403e2 	mov	x2, x20
 1113170:	aa1303e1 	mov	x1, x19
	uint32_t vm_flags = 0;
 1113174:	b9004fff 	str	wzr, [sp, #76]
	res = vm_get_flags(uctx, old_va, num_bytes, &vm_flags);
 1113178:	94001859 	bl	11192dc <vm_get_flags>
	if (res)
 111317c:	35000140 	cbnz	w0, 11131a4 <ldelf_syscall_remap+0x74>
		return res;
	if (vm_flags & VM_FLAG_PERMANENT)
 1113180:	b9404fe0 	ldr	w0, [sp, #76]
 1113184:	370801a0 	tbnz	w0, #1, 11131b8 <ldelf_syscall_remap+0x88>
		return TEE_ERROR_ACCESS_DENIED;

	res = vm_remap(uctx, new_va, old_va, num_bytes, pad_begin, pad_end);
 1113188:	aa1803e5 	mov	x5, x24
 111318c:	aa1703e4 	mov	x4, x23
 1113190:	aa1403e3 	mov	x3, x20
 1113194:	aa1303e2 	mov	x2, x19
 1113198:	aa1603e1 	mov	x1, x22
 111319c:	aa1503e0 	mov	x0, x21
 11131a0:	94001b77 	bl	1119f7c <vm_remap>

	return res;
}
 11131a4:	a94153f3 	ldp	x19, x20, [sp, #16]
 11131a8:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11131ac:	a94363f7 	ldp	x23, x24, [sp, #48]
 11131b0:	a8c57bfd 	ldp	x29, x30, [sp], #80
 11131b4:	d65f03c0 	ret
		return TEE_ERROR_ACCESS_DENIED;
 11131b8:	129fffc0 	mov	w0, #0xffff0001            	// #-65535
 11131bc:	17fffffa 	b	11131a4 <ldelf_syscall_remap+0x74>

00000000011131c0 <ldelf_syscall_gen_rnd_num>:

TEE_Result ldelf_syscall_gen_rnd_num(void *buf, size_t num_bytes)
{
 11131c0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 11131c4:	910003fd 	mov	x29, sp
 11131c8:	a90153f3 	stp	x19, x20, [sp, #16]
 11131cc:	aa0103f4 	mov	x20, x1
 11131d0:	aa0003f3 	mov	x19, x0
	TEE_Result res = TEE_SUCCESS;
	struct ts_session *sess = ts_get_current_session();
 11131d4:	94000603 	bl	11149e0 <ts_get_current_session>
	struct user_mode_ctx *uctx = to_user_mode_ctx(sess->ctx);
 11131d8:	f9400800 	ldr	x0, [x0, #16]
 11131dc:	97fffd65 	bl	1112770 <to_user_mode_ctx>

	res = vm_check_access_rights(uctx,
 11131e0:	aa1403e3 	mov	x3, x20
 11131e4:	aa1303e2 	mov	x2, x19
 11131e8:	528000c1 	mov	w1, #0x6                   	// #6
 11131ec:	94001980 	bl	11197ec <vm_check_access_rights>
				     TEE_MEMORY_ACCESS_WRITE |
				     TEE_MEMORY_ACCESS_ANY_OWNER,
				     (uaddr_t)buf, num_bytes);
	if (res)
 11131f0:	350000c0 	cbnz	w0, 1113208 <ldelf_syscall_gen_rnd_num+0x48>
		return res;

	return crypto_rng_read(buf, num_bytes);
 11131f4:	aa1403e1 	mov	x1, x20
 11131f8:	aa1303e0 	mov	x0, x19
}
 11131fc:	a94153f3 	ldp	x19, x20, [sp, #16]
 1113200:	a8c27bfd 	ldp	x29, x30, [sp], #32
	return crypto_rng_read(buf, num_bytes);
 1113204:	17fff0ea 	b	110f5ac <crypto_rng_read>
}
 1113208:	a94153f3 	ldp	x19, x20, [sp, #16]
 111320c:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1113210:	d65f03c0 	ret

0000000001113214 <ldelf_sess_cleanup>:
 * Should be called after returning from ldelf. If user_ctx is not NULL means
 * that ldelf crashed or otherwise didn't complete properly. This function will
 * close the remaining handles and free the context structs allocated by ldelf.
 */
void ldelf_sess_cleanup(struct ts_session *sess)
{
 1113214:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1113218:	910003fd 	mov	x29, sp
 111321c:	a90153f3 	stp	x19, x20, [sp, #16]
	struct system_ctx *sys_ctx = sess->user_ctx;
 1113220:	f9400c14 	ldr	x20, [x0, #24]

	if (sys_ctx) {
 1113224:	b4000134 	cbz	x20, 1113248 <ldelf_sess_cleanup+0x34>
 1113228:	aa0003f3 	mov	x19, x0
		handle_db_destroy(&sys_ctx->db, bin_close);
 111322c:	f0ffffe1 	adrp	x1, 1112000 <gic_op_add+0xb4>
 1113230:	9118b021 	add	x1, x1, #0x62c
 1113234:	aa1403e0 	mov	x0, x20
 1113238:	97fffc5b 	bl	11123a4 <handle_db_destroy>
		free(sys_ctx);
 111323c:	aa1403e0 	mov	x0, x20
 1113240:	9400c0e8 	bl	11435e0 <free>
		sess->user_ctx = NULL;
 1113244:	f9000e7f 	str	xzr, [x19, #24]
	}
}
 1113248:	a94153f3 	ldp	x19, x20, [sp, #16]
 111324c:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1113250:	d65f03c0 	ret

0000000001113254 <mobj_put>:
	if (mobj && refcount_dec(&mobj->refc))
 1113254:	b4000260 	cbz	x0, 11132a0 <mobj_put+0x4c>
{
 1113258:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 111325c:	910003fd 	mov	x29, sp
 1113260:	f9000bf3 	str	x19, [sp, #16]
 1113264:	aa0003f3 	mov	x19, x0
	if (mobj && refcount_dec(&mobj->refc))
 1113268:	91006000 	add	x0, x0, #0x18
 111326c:	940000d0 	bl	11135ac <refcount_dec>
 1113270:	72001c1f 	tst	w0, #0xff
 1113274:	54000100 	b.eq	1113294 <mobj_put+0x40>  // b.none
		mobj->ops->free(mobj);
 1113278:	f9400260 	ldr	x0, [x19]
 111327c:	f9401401 	ldr	x1, [x0, #40]
 1113280:	aa1303e0 	mov	x0, x19
}
 1113284:	f9400bf3 	ldr	x19, [sp, #16]
		mobj->ops->free(mobj);
 1113288:	aa0103f0 	mov	x16, x1
}
 111328c:	a8c27bfd 	ldp	x29, x30, [sp], #32
		mobj->ops->free(mobj);
 1113290:	d61f0200 	br	x16
}
 1113294:	f9400bf3 	ldr	x19, [sp, #16]
 1113298:	a8c27bfd 	ldp	x29, x30, [sp], #32
 111329c:	d65f03c0 	ret
 11132a0:	d65f03c0 	ret

00000000011132a4 <mobj_get_va.constprop.0>:
	if (mobj && mobj->ops && mobj->ops->get_va)
 11132a4:	b4000100 	cbz	x0, 11132c4 <mobj_get_va.constprop.0+0x20>
 11132a8:	f9400001 	ldr	x1, [x0]
 11132ac:	b40000c1 	cbz	x1, 11132c4 <mobj_get_va.constprop.0+0x20>
 11132b0:	f9400022 	ldr	x2, [x1]
 11132b4:	b4000082 	cbz	x2, 11132c4 <mobj_get_va.constprop.0+0x20>
		return mobj->ops->get_va(mobj, offset);
 11132b8:	aa0203f0 	mov	x16, x2
 11132bc:	d2800001 	mov	x1, #0x0                   	// #0
 11132c0:	d61f0200 	br	x16
}
 11132c4:	d2800000 	mov	x0, #0x0                   	// #0
 11132c8:	d65f03c0 	ret

00000000011132cc <msg_param_mobj_from_noncontig>:
	return ret;
}

struct mobj *msg_param_mobj_from_noncontig(paddr_t buf_ptr, size_t size,
					   uint64_t shm_ref, bool map_buffer)
{
 11132cc:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
 11132d0:	910003fd 	mov	x29, sp
 11132d4:	a90153f3 	stp	x19, x20, [sp, #16]
 11132d8:	a9025bf5 	stp	x21, x22, [sp, #32]
	paddr_t page_offset = 0;
	size_t num_pages = 0;
	size_t size_plus_offs = 0;
	size_t msize = 0;

	page_offset = buf_ptr & SMALL_PAGE_MASK;
 11132dc:	92402c16 	and	x22, x0, #0xfff
	if (ADD_OVERFLOW(size, page_offset, &size_plus_offs))
 11132e0:	ab160034 	adds	x20, x1, x22
{
 11132e4:	a90363f7 	stp	x23, x24, [sp, #48]
 11132e8:	a9046bf9 	stp	x25, x26, [sp, #64]
 11132ec:	f9002bfb 	str	x27, [sp, #80]
	if (ADD_OVERFLOW(size, page_offset, &size_plus_offs))
 11132f0:	54000182 	b.cs	1113320 <msg_param_mobj_from_noncontig+0x54>  // b.hs, b.nlast
		return NULL;
	num_pages = (size_plus_offs - 1) / SMALL_PAGE_SIZE + 1;
 11132f4:	d1000694 	sub	x20, x20, #0x1
 11132f8:	aa0003f3 	mov	x19, x0
 11132fc:	aa0203f7 	mov	x23, x2
 1113300:	12001c79 	and	w25, w3, #0xff
 1113304:	d34cfe94 	lsr	x20, x20, #12
 1113308:	91000694 	add	x20, x20, #0x1
	if (MUL_OVERFLOW(num_pages, sizeof(paddr_t), &msize))
 111330c:	d37df298 	lsl	x24, x20, #3
		return NULL;

	pages = malloc(msize);
 1113310:	aa1803e0 	mov	x0, x24
 1113314:	9400c051 	bl	1143458 <malloc>
 1113318:	aa0003f5 	mov	x21, x0
	if (!pages)
 111331c:	b5000140 	cbnz	x0, 1113344 <msg_param_mobj_from_noncontig+0x78>
		return NULL;
 1113320:	d2800013 	mov	x19, #0x0                   	// #0
		mobj = mobj_reg_shm_alloc(pages, num_pages, page_offset,
					  shm_ref);
out:
	free(pages);
	return mobj;
}
 1113324:	aa1303e0 	mov	x0, x19
 1113328:	a94153f3 	ldp	x19, x20, [sp, #16]
 111332c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1113330:	a94363f7 	ldp	x23, x24, [sp, #48]
 1113334:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1113338:	f9402bfb 	ldr	x27, [sp, #80]
 111333c:	a8c77bfd 	ldp	x29, x30, [sp], #112
 1113340:	d65f03c0 	ret
	if (!msg_param_extract_pages(buf_ptr & ~SMALL_PAGE_MASK,
 1113344:	9274ce73 	and	x19, x19, #0xfffffffffffff000
	mobj = mobj_mapped_shm_alloc(&buffer, 1, 0, 0);
 1113348:	910183e0 	add	x0, sp, #0x60
 111334c:	d2800003 	mov	x3, #0x0                   	// #0
 1113350:	d2800002 	mov	x2, #0x0                   	// #0
 1113354:	d2800021 	mov	x1, #0x1                   	// #1
 1113358:	f90033f3 	str	x19, [sp, #96]
 111335c:	97ffe54d 	bl	110c890 <mobj_mapped_shm_alloc>
 1113360:	aa0003f3 	mov	x19, x0
	if (!mobj)
 1113364:	b4000700 	cbz	x0, 1113444 <msg_param_mobj_from_noncontig+0x178>
	va = mobj_get_va(mobj, 0);
 1113368:	97ffffcf 	bl	11132a4 <mobj_get_va.constprop.0>
	assert(va);
 111336c:	b5000140 	cbnz	x0, 1113394 <msg_param_mobj_from_noncontig+0xc8>
 1113370:	b0000203 	adrp	x3, 1154000 <__func__.1786+0x8>
 1113374:	91106463 	add	x3, x3, #0x419
 1113378:	52800a62 	mov	w2, #0x53                  	// #83
			assert(va);
 111337c:	b0000201 	adrp	x1, 1154000 <__func__.1786+0x8>
 1113380:	f00001e0 	adrp	x0, 1152000 <trace_ext_prefix+0x2e>
 1113384:	91100421 	add	x1, x1, #0x401
 1113388:	91242000 	add	x0, x0, #0x908
 111338c:	97fffbc8 	bl	11122ac <_assert_log>
 1113390:	97fffbd8 	bl	11122f0 <_assert_break>
 1113394:	aa1503fb 	mov	x27, x21
 1113398:	8b150318 	add	x24, x24, x21
			mobj = mobj_mapped_shm_alloc(&page, 1, 0, 0);
 111339c:	9101a3fa 	add	x26, sp, #0x68
		if (!((vaddr_t)(va + 1) & SMALL_PAGE_MASK)) {
 11133a0:	91002001 	add	x1, x0, #0x8
 11133a4:	f2402c3f 	tst	x1, #0xfff
 11133a8:	54000281 	b.ne	11133f8 <msg_param_mobj_from_noncontig+0x12c>  // b.any
 11133ac:	f9400000 	ldr	x0, [x0]
			page = *va;
 11133b0:	f90037e0 	str	x0, [sp, #104]
			if (page & SMALL_PAGE_MASK)
 11133b4:	f2402c1f 	tst	x0, #0xfff
 11133b8:	540004c1 	b.ne	1113450 <msg_param_mobj_from_noncontig+0x184>  // b.any
			mobj_put(mobj);
 11133bc:	aa1303e0 	mov	x0, x19
 11133c0:	97ffffa5 	bl	1113254 <mobj_put>
			mobj = mobj_mapped_shm_alloc(&page, 1, 0, 0);
 11133c4:	aa1a03e0 	mov	x0, x26
 11133c8:	d2800003 	mov	x3, #0x0                   	// #0
 11133cc:	d2800002 	mov	x2, #0x0                   	// #0
 11133d0:	d2800021 	mov	x1, #0x1                   	// #1
 11133d4:	97ffe52f 	bl	110c890 <mobj_mapped_shm_alloc>
 11133d8:	aa0003f3 	mov	x19, x0
			if (!mobj)
 11133dc:	b40003a0 	cbz	x0, 1113450 <msg_param_mobj_from_noncontig+0x184>
			va = mobj_get_va(mobj, 0);
 11133e0:	97ffffb1 	bl	11132a4 <mobj_get_va.constprop.0>
			assert(va);
 11133e4:	b50000a0 	cbnz	x0, 11133f8 <msg_param_mobj_from_noncontig+0x12c>
 11133e8:	b0000203 	adrp	x3, 1154000 <__func__.1786+0x8>
 11133ec:	52800cc2 	mov	w2, #0x66                  	// #102
 11133f0:	91106463 	add	x3, x3, #0x419
 11133f4:	17ffffe2 	b	111337c <msg_param_mobj_from_noncontig+0xb0>
		pages[cnt] = *va;
 11133f8:	f9400001 	ldr	x1, [x0]
 11133fc:	f9000361 	str	x1, [x27]
		if (pages[cnt] & SMALL_PAGE_MASK)
 1113400:	f2402c3f 	tst	x1, #0xfff
 1113404:	54000261 	b.ne	1113450 <msg_param_mobj_from_noncontig+0x184>  // b.any
	for (cnt = 0; cnt < num_pages; cnt++, va++) {
 1113408:	9100237b 	add	x27, x27, #0x8
 111340c:	91002000 	add	x0, x0, #0x8
 1113410:	eb1b031f 	cmp	x24, x27
 1113414:	54fffc61 	b.ne	11133a0 <msg_param_mobj_from_noncontig+0xd4>  // b.any
	ret = true;
 1113418:	52800038 	mov	w24, #0x1                   	// #1
	mobj_put(mobj);
 111341c:	aa1303e0 	mov	x0, x19
 1113420:	97ffff8d 	bl	1113254 <mobj_put>
	if (!msg_param_extract_pages(buf_ptr & ~SMALL_PAGE_MASK,
 1113424:	340001f8 	cbz	w24, 1113460 <msg_param_mobj_from_noncontig+0x194>
		mobj = mobj_mapped_shm_alloc(pages, num_pages, page_offset,
 1113428:	aa1703e3 	mov	x3, x23
 111342c:	aa1603e2 	mov	x2, x22
 1113430:	aa1403e1 	mov	x1, x20
 1113434:	aa1503e0 	mov	x0, x21
	if (map_buffer)
 1113438:	34000119 	cbz	w25, 1113458 <msg_param_mobj_from_noncontig+0x18c>
		mobj = mobj_mapped_shm_alloc(pages, num_pages, page_offset,
 111343c:	97ffe515 	bl	110c890 <mobj_mapped_shm_alloc>
		mobj = mobj_reg_shm_alloc(pages, num_pages, page_offset,
 1113440:	aa0003f3 	mov	x19, x0
	free(pages);
 1113444:	aa1503e0 	mov	x0, x21
 1113448:	9400c066 	bl	11435e0 <free>
	return mobj;
 111344c:	17ffffb6 	b	1113324 <msg_param_mobj_from_noncontig+0x58>
	bool ret = false;
 1113450:	52800018 	mov	w24, #0x0                   	// #0
 1113454:	17fffff2 	b	111341c <msg_param_mobj_from_noncontig+0x150>
		mobj = mobj_reg_shm_alloc(pages, num_pages, page_offset,
 1113458:	97ffe425 	bl	110c4ec <mobj_reg_shm_alloc>
 111345c:	17fffff9 	b	1113440 <msg_param_mobj_from_noncontig+0x174>
	struct mobj *mobj = NULL;
 1113460:	d2800013 	mov	x19, #0x0                   	// #0
 1113464:	17fffff8 	b	1113444 <msg_param_mobj_from_noncontig+0x178>

0000000001113468 <__do_panic>:

void __do_panic(const char *file __maybe_unused,
		const int line __maybe_unused,
		const char *func __maybe_unused,
		const char *msg __maybe_unused)
{
 1113468:	d10183ff 	sub	sp, sp, #0x60
 111346c:	a9037bfd 	stp	x29, x30, [sp, #48]
 1113470:	9100c3fd 	add	x29, sp, #0x30
 1113474:	a90453f3 	stp	x19, x20, [sp, #64]
 1113478:	aa0003f3 	mov	x19, x0
 111347c:	aa0303f4 	mov	x20, x3
	/* disable prehemption */
	(void)thread_mask_exceptions(THREAD_EXCP_ALL);
 1113480:	528000e0 	mov	w0, #0x7                   	// #7
{
 1113484:	a9055bf5 	stp	x21, x22, [sp, #80]
 1113488:	aa0203f5 	mov	x21, x2
 111348c:	2a0103f6 	mov	w22, w1
	(void)thread_mask_exceptions(THREAD_EXCP_ALL);
 1113490:	97ffc72a 	bl	1105138 <thread_mask_exceptions>

	/* TODO: notify other cores */

	/* trace: Panic ['panic-string-message' ]at FILE:LINE [<FUNCTION>]" */
	if (!file && !func && !msg)
 1113494:	aa150260 	orr	x0, x19, x21
 1113498:	b5000140 	cbnz	x0, 11134c0 <__do_panic+0x58>
 111349c:	b5000534 	cbnz	x20, 1113540 <__do_panic+0xd8>
		EMSG_RAW("Panic");
 11134a0:	b0000204 	adrp	x4, 1154000 <__func__.1786+0x8>
 11134a4:	52800023 	mov	w3, #0x1                   	// #1
 11134a8:	9110e884 	add	x4, x4, #0x43a
 11134ac:	52800022 	mov	w2, #0x1                   	// #1
 11134b0:	52800001 	mov	w1, #0x0                   	// #0
 11134b4:	9400c624 	bl	1144d44 <trace_printf>
		EMSG_RAW("Panic %s%s%sat %s:%d %s%s%s",
			 msg ? "'" : "", msg ? msg : "", msg ? "' " : "",
			 file ? file : "?", file ? line : 0,
			 func ? "<" : "", func ? func : "", func ? ">" : "");

	print_kernel_stack();
 11134b8:	97ffd353 	bl	1108204 <print_kernel_stack>
	/* abort current execution */
	while (1)
 11134bc:	14000000 	b	11134bc <__do_panic+0x54>
		EMSG_RAW("Panic %s%s%sat %s:%d %s%s%s",
 11134c0:	b4000374 	cbz	x20, 111352c <__do_panic+0xc4>
 11134c4:	b0000205 	adrp	x5, 1154000 <__func__.1786+0x8>
 11134c8:	b0000207 	adrp	x7, 1154000 <__func__.1786+0x8>
 11134cc:	9110c4a5 	add	x5, x5, #0x431
 11134d0:	9110cce7 	add	x7, x7, #0x433
 11134d4:	b5000093 	cbnz	x19, 11134e4 <__do_panic+0x7c>
 11134d8:	b0000213 	adrp	x19, 1154000 <__func__.1786+0x8>
 11134dc:	9110da73 	add	x19, x19, #0x436
 11134e0:	52800016 	mov	w22, #0x0                   	// #0
 11134e4:	b50003f5 	cbnz	x21, 1113560 <__do_panic+0xf8>
 11134e8:	f00001f5 	adrp	x21, 1152000 <trace_ext_prefix+0x2e>
 11134ec:	9104aab5 	add	x21, x21, #0x12a
 11134f0:	aa1503e0 	mov	x0, x21
 11134f4:	aa1503e1 	mov	x1, x21
 11134f8:	f90003f3 	str	x19, [sp]
 11134fc:	aa1403e6 	mov	x6, x20
 1113500:	b9000bf6 	str	w22, [sp, #8]
 1113504:	b0000204 	adrp	x4, 1154000 <__func__.1786+0x8>
 1113508:	a90157e0 	stp	x0, x21, [sp, #16]
 111350c:	91110084 	add	x4, x4, #0x440
 1113510:	52800023 	mov	w3, #0x1                   	// #1
 1113514:	f90013e1 	str	x1, [sp, #32]
 1113518:	52800022 	mov	w2, #0x1                   	// #1
 111351c:	52800001 	mov	w1, #0x0                   	// #0
 1113520:	d2800000 	mov	x0, #0x0                   	// #0
 1113524:	9400c608 	bl	1144d44 <trace_printf>
 1113528:	17ffffe4 	b	11134b8 <__do_panic+0x50>
 111352c:	f00001f4 	adrp	x20, 1152000 <trace_ext_prefix+0x2e>
 1113530:	9104aa94 	add	x20, x20, #0x12a
 1113534:	aa1403e5 	mov	x5, x20
 1113538:	aa1403e7 	mov	x7, x20
 111353c:	17ffffe6 	b	11134d4 <__do_panic+0x6c>
 1113540:	b0000213 	adrp	x19, 1154000 <__func__.1786+0x8>
 1113544:	b0000205 	adrp	x5, 1154000 <__func__.1786+0x8>
 1113548:	b0000207 	adrp	x7, 1154000 <__func__.1786+0x8>
 111354c:	9110da73 	add	x19, x19, #0x436
 1113550:	9110c4a5 	add	x5, x5, #0x431
 1113554:	9110cce7 	add	x7, x7, #0x433
 1113558:	52800016 	mov	w22, #0x0                   	// #0
 111355c:	17ffffe3 	b	11134e8 <__do_panic+0x80>
 1113560:	b0000200 	adrp	x0, 1154000 <__func__.1786+0x8>
 1113564:	b0000201 	adrp	x1, 1154000 <__func__.1786+0x8>
 1113568:	9110e000 	add	x0, x0, #0x438
 111356c:	910c9421 	add	x1, x1, #0x325
 1113570:	17ffffe2 	b	11134f8 <__do_panic+0x90>

0000000001113574 <refcount_inc>:
	return __compiler_atomic_load(p);
 1113574:	b9400001 	ldr	w1, [x0]
{
	unsigned int nval;
	unsigned int oval = atomic_load_uint(&r->val);

	while (true) {
		nval = oval + 1;
 1113578:	11000423 	add	w3, w1, #0x1

		/* r->val is 0, we can't do anything more. */
		if (!oval)
 111357c:	34000141 	cbz	w1, 11135a4 <refcount_inc+0x30>
	return __compiler_compare_and_swap(p, oval, nval);
 1113580:	885ffc02 	ldaxr	w2, [x0]
 1113584:	6b01005f 	cmp	w2, w1
 1113588:	54000061 	b.ne	1113594 <refcount_inc+0x20>  // b.any
 111358c:	88047c03 	stxr	w4, w3, [x0]
 1113590:	7100009f 	cmp	w4, #0x0
 1113594:	2a0203e1 	mov	w1, w2
			return false;

		if (atomic_cas_uint(&r->val, &oval, nval))
 1113598:	54ffff01 	b.ne	1113578 <refcount_inc+0x4>  // b.any
			return true;
 111359c:	52800020 	mov	w0, #0x1                   	// #1
		/*
		 * At this point atomic_cas_uint() has updated oval to the
		 * current r->val.
		 */
	}
}
 11135a0:	d65f03c0 	ret
			return false;
 11135a4:	52800000 	mov	w0, #0x0                   	// #0
 11135a8:	17fffffe 	b	11135a0 <refcount_inc+0x2c>

00000000011135ac <refcount_dec>:
	return __compiler_atomic_load(p);
 11135ac:	b9400001 	ldr	w1, [x0]
{
	unsigned int nval;
	unsigned int oval = atomic_load_uint(&r->val);

	while (true) {
		assert(oval);
 11135b0:	35000181 	cbnz	w1, 11135e0 <refcount_dec+0x34>
 11135b4:	b0000203 	adrp	x3, 1154000 <__func__.1786+0x8>
 11135b8:	b0000201 	adrp	x1, 1154000 <__func__.1786+0x8>
 11135bc:	9111e063 	add	x3, x3, #0x478
 11135c0:	91117021 	add	x1, x1, #0x45c
 11135c4:	b0000200 	adrp	x0, 1154000 <__func__.1786+0x8>
 11135c8:	9111cc00 	add	x0, x0, #0x473
{
 11135cc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
		assert(oval);
 11135d0:	528004a2 	mov	w2, #0x25                  	// #37
{
 11135d4:	910003fd 	mov	x29, sp
		assert(oval);
 11135d8:	97fffb35 	bl	11122ac <_assert_log>
 11135dc:	97fffb45 	bl	11122f0 <_assert_break>
		nval = oval - 1;
 11135e0:	51000422 	sub	w2, w1, #0x1
	return __compiler_compare_and_swap(p, oval, nval);
 11135e4:	885ffc03 	ldaxr	w3, [x0]
 11135e8:	6b01007f 	cmp	w3, w1
 11135ec:	54000061 	b.ne	11135f8 <refcount_dec+0x4c>  // b.any
 11135f0:	88047c02 	stxr	w4, w2, [x0]
 11135f4:	7100009f 	cmp	w4, #0x0
 11135f8:	2a0303e1 	mov	w1, w3

		if (atomic_cas_uint(&r->val, &oval, nval)) {
 11135fc:	54fffda1 	b.ne	11135b0 <refcount_dec+0x4>  // b.any
			/*
			 * Value has been updated, if value was set to 0
			 * return true to indicate that.
			 */
			return !nval;
 1113600:	7100005f 	cmp	w2, #0x0
		/*
		 * At this point atomic_cas_uint() has updated oval to the
		 * current r->val.
		 */
	}
}
 1113604:	1a9f17e0 	cset	w0, eq  // eq = none
 1113608:	d65f03c0 	ret

000000000111360c <is_valid_conf_and_notnull_size>:

static bool is_valid_conf_and_notnull_size(paddr_t b, paddr_size_t bl,
					   paddr_t a, paddr_size_t al)
{
	/* invalid config return false */
	if ((b - 1 + bl < b) || (a - 1 + al < a))
 111360c:	d1000424 	sub	x4, x1, #0x1
 1113610:	ab00009f 	cmn	x4, x0
 1113614:	54000102 	b.cs	1113634 <is_valid_conf_and_notnull_size+0x28>  // b.hs, b.nlast
 1113618:	d1000460 	sub	x0, x3, #0x1
 111361c:	ab02001f 	cmn	x0, x2
 1113620:	540000a2 	b.cs	1113634 <is_valid_conf_and_notnull_size+0x28>  // b.hs, b.nlast
		return false;
	/* null sized areas are never inside / outside / overlap */
	if (!bl || !al)
 1113624:	f100003f 	cmp	x1, #0x0
 1113628:	fa401864 	ccmp	x3, #0x0, #0x4, ne  // ne = any
 111362c:	1a9f07e0 	cset	w0, ne  // ne = any
		return false;
	return true;
}
 1113630:	d65f03c0 	ret
		return false;
 1113634:	52800000 	mov	w0, #0x0                   	// #0
 1113638:	17fffffe 	b	1113630 <is_valid_conf_and_notnull_size+0x24>

000000000111363c <core_is_buffer_inside>:

/* Returns true when buffer 'b' is fully contained in area 'a' */
bool core_is_buffer_inside(paddr_t b, paddr_size_t bl,
			   paddr_t a, paddr_size_t al)
{
 111363c:	aa0003e8 	mov	x8, x0
 1113640:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 1113644:	910003fd 	mov	x29, sp
	/* invalid config or "null size" return false */
	if (!is_valid_conf_and_notnull_size(b, bl, a, al))
 1113648:	97fffff1 	bl	111360c <is_valid_conf_and_notnull_size>
 111364c:	72001c00 	ands	w0, w0, #0xff
 1113650:	54000120 	b.eq	1113674 <core_is_buffer_inside+0x38>  // b.none
		return false;

	if ((b >= a) && (b - 1 + bl <= a - 1 + al))
 1113654:	eb02011f 	cmp	x8, x2
 1113658:	54000123 	b.cc	111367c <core_is_buffer_inside+0x40>  // b.lo, b.ul, b.last
 111365c:	d1000426 	sub	x6, x1, #0x1
 1113660:	d1000465 	sub	x5, x3, #0x1
 1113664:	8b0800c6 	add	x6, x6, x8
 1113668:	8b0200a5 	add	x5, x5, x2
 111366c:	eb0500df 	cmp	x6, x5
 1113670:	1a9f87e0 	cset	w0, ls  // ls = plast
		return true;
	return false;
}
 1113674:	a8c17bfd 	ldp	x29, x30, [sp], #16
 1113678:	d65f03c0 	ret
		return false;
 111367c:	52800000 	mov	w0, #0x0                   	// #0
 1113680:	17fffffd 	b	1113674 <core_is_buffer_inside+0x38>

0000000001113684 <core_is_buffer_outside>:

/* Returns true when buffer 'b' is fully contained in area 'a' */
bool core_is_buffer_outside(paddr_t b, paddr_size_t bl,
			    paddr_t a, paddr_size_t al)
{
 1113684:	aa0003e7 	mov	x7, x0
 1113688:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 111368c:	910003fd 	mov	x29, sp
	/* invalid config or "null size" return false */
	if (!is_valid_conf_and_notnull_size(b, bl, a, al))
 1113690:	97ffffdf 	bl	111360c <is_valid_conf_and_notnull_size>
 1113694:	72001c00 	ands	w0, w0, #0xff
 1113698:	54000120 	b.eq	11136bc <core_is_buffer_outside+0x38>  // b.none
		return false;

	if ((b + bl - 1 < a) || (b > a + al - 1))
 111369c:	d1000426 	sub	x6, x1, #0x1
 11136a0:	8b0700c6 	add	x6, x6, x7
 11136a4:	eb0200df 	cmp	x6, x2
 11136a8:	540000a3 	b.cc	11136bc <core_is_buffer_outside+0x38>  // b.lo, b.ul, b.last
 11136ac:	d1000465 	sub	x5, x3, #0x1
 11136b0:	8b0200a5 	add	x5, x5, x2
 11136b4:	eb0700bf 	cmp	x5, x7
 11136b8:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
		return true;
	return false;
}
 11136bc:	a8c17bfd 	ldp	x29, x30, [sp], #16
 11136c0:	d65f03c0 	ret

00000000011136c4 <core_is_buffer_intersect>:

/* Returns true when buffer 'b' intersects area 'a' */
bool core_is_buffer_intersect(paddr_t b, paddr_size_t bl,
			      paddr_t a, paddr_size_t al)
{
 11136c4:	aa0003e7 	mov	x7, x0
 11136c8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 11136cc:	910003fd 	mov	x29, sp
	/* invalid config or "null size" return false */
	if (!is_valid_conf_and_notnull_size(b, bl, a, al))
 11136d0:	97ffffcf 	bl	111360c <is_valid_conf_and_notnull_size>
 11136d4:	72001c00 	ands	w0, w0, #0xff
 11136d8:	54000120 	b.eq	11136fc <core_is_buffer_intersect+0x38>  // b.none
		return false;

	if ((b + bl - 1 < a) || (b > a + al - 1))
 11136dc:	d1000426 	sub	x6, x1, #0x1
 11136e0:	8b0700c6 	add	x6, x6, x7
 11136e4:	eb0200df 	cmp	x6, x2
 11136e8:	540000e3 	b.cc	1113704 <core_is_buffer_intersect+0x40>  // b.lo, b.ul, b.last
 11136ec:	d1000465 	sub	x5, x3, #0x1
 11136f0:	8b0200a5 	add	x5, x5, x2
 11136f4:	eb0700bf 	cmp	x5, x7
 11136f8:	1a9f37e0 	cset	w0, cs  // cs = hs, nlast
		return false;
	return true;
}
 11136fc:	a8c17bfd 	ldp	x29, x30, [sp], #16
 1113700:	d65f03c0 	ret
		return false;
 1113704:	52800000 	mov	w0, #0x0                   	// #0
 1113708:	17fffffd 	b	11136fc <core_is_buffer_intersect+0x38>

000000000111370c <set_invoke_timeout>:
}
#endif

static void set_invoke_timeout(struct tee_ta_session *sess,
				      uint32_t cancel_req_to)
{
 111370c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	TEE_Time current_time;
	TEE_Time cancel_time;

	if (cancel_req_to == TEE_TIMEOUT_INFINITE)
 1113710:	3100043f 	cmn	w1, #0x1
{
 1113714:	910003fd 	mov	x29, sp
 1113718:	a90153f3 	stp	x19, x20, [sp, #16]
 111371c:	aa0003f3 	mov	x19, x0
	if (cancel_req_to == TEE_TIMEOUT_INFINITE)
 1113720:	54000320 	b.eq	1113784 <set_invoke_timeout+0x78>  // b.none
 1113724:	2a0103f4 	mov	w20, w1
		goto infinite;

	if (tee_time_get_sys_time(&current_time) != TEE_SUCCESS)
 1113728:	9100a3e0 	add	x0, sp, #0x28
 111372c:	97ffc2a1 	bl	11041b0 <tee_time_get_sys_time>
 1113730:	350002a0 	cbnz	w0, 1113784 <set_invoke_timeout+0x78>
		goto infinite;

	if (ADD_OVERFLOW(current_time.seconds, cancel_req_to / 1000,
 1113734:	52807d01 	mov	w1, #0x3e8                 	// #1000
 1113738:	b9402be4 	ldr	w4, [sp, #40]
 111373c:	1ac10a82 	udiv	w2, w20, w1
 1113740:	2b020083 	adds	w3, w4, w2
 1113744:	54000202 	b.cs	1113784 <set_invoke_timeout+0x78>  // b.hs, b.nlast
			 &cancel_time.seconds))
		goto infinite;

	cancel_time.millis = current_time.millis + cancel_req_to % 1000;
 1113748:	1b01d041 	msub	w1, w2, w1, w20
 111374c:	b9402fe0 	ldr	w0, [sp, #44]
 1113750:	0b000021 	add	w1, w1, w0
	if (cancel_time.millis > 1000) {
 1113754:	710fa03f 	cmp	w1, #0x3e8
 1113758:	540000c8 	b.hi	1113770 <set_invoke_timeout+0x64>  // b.pmore
	if (ADD_OVERFLOW(current_time.seconds, cancel_req_to / 1000,
 111375c:	2a0303e2 	mov	w2, w3

		cancel_time.seconds++;
		cancel_time.millis -= 1000;
	}

	sess->cancel_time = cancel_time;
 1113760:	290c0662 	stp	w2, w1, [x19, #96]
	return;

infinite:
	sess->cancel_time.seconds = UINT32_MAX;
	sess->cancel_time.millis = UINT32_MAX;
}
 1113764:	a94153f3 	ldp	x19, x20, [sp, #16]
 1113768:	a8c37bfd 	ldp	x29, x30, [sp], #48
 111376c:	d65f03c0 	ret
		if (ADD_OVERFLOW(current_time.seconds, 1,
 1113770:	31000482 	adds	w2, w4, #0x1
 1113774:	54000082 	b.cs	1113784 <set_invoke_timeout+0x78>  // b.hs, b.nlast
		cancel_time.seconds++;
 1113778:	11000442 	add	w2, w2, #0x1
		cancel_time.millis -= 1000;
 111377c:	510fa021 	sub	w1, w1, #0x3e8
 1113780:	17fffff8 	b	1113760 <set_invoke_timeout+0x54>
	sess->cancel_time.seconds = UINT32_MAX;
 1113784:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
 1113788:	f9003260 	str	x0, [x19, #96]
 111378c:	17fffff6 	b	1113764 <set_invoke_timeout+0x58>

0000000001113790 <destroy_context>:
{
 1113790:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	DMSG("Destroy TA ctx (0x%" PRIxVA ")",  (vaddr_t)ctx);
 1113794:	aa0003e5 	mov	x5, x0
 1113798:	b0000204 	adrp	x4, 1154000 <__func__.1786+0x8>
{
 111379c:	910003fd 	mov	x29, sp
	DMSG("Destroy TA ctx (0x%" PRIxVA ")",  (vaddr_t)ctx);
 11137a0:	91121484 	add	x4, x4, #0x485
 11137a4:	52800023 	mov	w3, #0x1                   	// #1
 11137a8:	52800062 	mov	w2, #0x3                   	// #3
 11137ac:	52802681 	mov	w1, #0x134                 	// #308
{
 11137b0:	f9000bf3 	str	x19, [sp, #16]
 11137b4:	aa0003f3 	mov	x19, x0
	DMSG("Destroy TA ctx (0x%" PRIxVA ")",  (vaddr_t)ctx);
 11137b8:	b0000200 	adrp	x0, 1154000 <__func__.1786+0x8>
 11137bc:	91205c00 	add	x0, x0, #0x817
 11137c0:	9400c561 	bl	1144d44 <trace_printf>
	condvar_destroy(&ctx->busy_cv);
 11137c4:	91010260 	add	x0, x19, #0x40
 11137c8:	94000866 	bl	1115960 <condvar_destroy>
	ctx->ts_ctx.ops->destroy(&ctx->ts_ctx);
 11137cc:	f9401660 	ldr	x0, [x19, #40]
 11137d0:	f9401401 	ldr	x1, [x0, #40]
 11137d4:	91006260 	add	x0, x19, #0x18
}
 11137d8:	f9400bf3 	ldr	x19, [sp, #16]
	ctx->ts_ctx.ops->destroy(&ctx->ts_ctx);
 11137dc:	aa0103f0 	mov	x16, x1
}
 11137e0:	a8c27bfd 	ldp	x29, x30, [sp], #32
	ctx->ts_ctx.ops->destroy(&ctx->ts_ctx);
 11137e4:	d61f0200 	br	x16

00000000011137e8 <dec_session_ref_count>:
	assert(s->ref_count > 0);
 11137e8:	b9406801 	ldr	w1, [x0, #104]
 11137ec:	35000181 	cbnz	w1, 111381c <dec_session_ref_count+0x34>
 11137f0:	b0000203 	adrp	x3, 1154000 <__func__.1786+0x8>
 11137f4:	b0000201 	adrp	x1, 1154000 <__func__.1786+0x8>
 11137f8:	911f6063 	add	x3, x3, #0x7d8
 11137fc:	91127021 	add	x1, x1, #0x49c
 1113800:	b0000200 	adrp	x0, 1154000 <__func__.1786+0x8>
 1113804:	9112e400 	add	x0, x0, #0x4b9
{
 1113808:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	assert(s->ref_count > 0);
 111380c:	52801682 	mov	w2, #0xb4                  	// #180
{
 1113810:	910003fd 	mov	x29, sp
	assert(s->ref_count > 0);
 1113814:	97fffaa6 	bl	11122ac <_assert_log>
 1113818:	97fffab6 	bl	11122f0 <_assert_break>
	s->ref_count--;
 111381c:	51000421 	sub	w1, w1, #0x1
 1113820:	b9006801 	str	w1, [x0, #104]
	if (s->ref_count == 1)
 1113824:	7100043f 	cmp	w1, #0x1
 1113828:	54000061 	b.ne	1113834 <dec_session_ref_count+0x4c>  // b.any
		condvar_signal(&s->refc_cv);
 111382c:	9101c000 	add	x0, x0, #0x70
 1113830:	14000862 	b	11159b8 <condvar_signal>
 1113834:	d65f03c0 	ret

0000000001113838 <unlock_single_instance>:
{
 1113838:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 111383c:	910003fd 	mov	x29, sp
	assert(tee_ta_single_instance_thread == thread_get_id());
 1113840:	97ffc709 	bl	1105464 <thread_get_id>
 1113844:	d0000241 	adrp	x1, 115d000 <_curve_names+0x590>
 1113848:	79d7d022 	ldrsh	w2, [x1, #3048]
 111384c:	6b20a05f 	cmp	w2, w0, sxth
 1113850:	54000140 	b.eq	1113878 <unlock_single_instance+0x40>  // b.none
 1113854:	b0000203 	adrp	x3, 1154000 <__func__.1786+0x8>
 1113858:	b0000201 	adrp	x1, 1154000 <__func__.1786+0x8>
 111385c:	b0000200 	adrp	x0, 1154000 <__func__.1786+0x8>
 1113860:	911e1063 	add	x3, x3, #0x784
 1113864:	91127021 	add	x1, x1, #0x49c
 1113868:	91132800 	add	x0, x0, #0x4ca
 111386c:	52800a42 	mov	w2, #0x52                  	// #82
	assert(tee_ta_single_instance_count > 0);
 1113870:	97fffa8f 	bl	11122ac <_assert_log>
 1113874:	97fffa9f 	bl	11122f0 <_assert_break>
 1113878:	f0000242 	adrp	x2, 115e000 <state+0x80>
 111387c:	f9409040 	ldr	x0, [x2, #288]
 1113880:	b5000120 	cbnz	x0, 11138a4 <unlock_single_instance+0x6c>
 1113884:	b0000203 	adrp	x3, 1154000 <__func__.1786+0x8>
 1113888:	b0000201 	adrp	x1, 1154000 <__func__.1786+0x8>
 111388c:	b0000200 	adrp	x0, 1154000 <__func__.1786+0x8>
 1113890:	911e1063 	add	x3, x3, #0x784
 1113894:	91127021 	add	x1, x1, #0x49c
 1113898:	9113ec00 	add	x0, x0, #0x4fb
 111389c:	52800a62 	mov	w2, #0x53                  	// #83
 11138a0:	17fffff4 	b	1113870 <unlock_single_instance+0x38>
	tee_ta_single_instance_count--;
 11138a4:	d1000400 	sub	x0, x0, #0x1
 11138a8:	f9009040 	str	x0, [x2, #288]
	if (tee_ta_single_instance_count == 0) {
 11138ac:	b50000e0 	cbnz	x0, 11138c8 <unlock_single_instance+0x90>
}
 11138b0:	a8c17bfd 	ldp	x29, x30, [sp], #16
		tee_ta_single_instance_thread = THREAD_ID_INVALID;
 11138b4:	12800000 	mov	w0, #0xffffffff            	// #-1
 11138b8:	7917d020 	strh	w0, [x1, #3048]
		condvar_signal(&tee_ta_cv);
 11138bc:	f0000240 	adrp	x0, 115e000 <state+0x80>
 11138c0:	9103a000 	add	x0, x0, #0xe8
 11138c4:	1400083d 	b	11159b8 <condvar_signal>
}
 11138c8:	a8c17bfd 	ldp	x29, x30, [sp], #16
 11138cc:	d65f03c0 	ret

00000000011138d0 <tee_ta_clear_busy>:
{
 11138d0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 11138d4:	910003fd 	mov	x29, sp
 11138d8:	a90153f3 	stp	x19, x20, [sp, #16]
 11138dc:	aa0003f3 	mov	x19, x0
	if (ctx->flags & TA_FLAG_CONCURRENT)
 11138e0:	b9400000 	ldr	w0, [x0]
 11138e4:	37400320 	tbnz	w0, #8, 1113948 <tee_ta_clear_busy+0x78>
	mutex_lock(&tee_ta_mutex);
 11138e8:	f0000254 	adrp	x20, 115e000 <state+0x80>
 11138ec:	91042280 	add	x0, x20, #0x108
 11138f0:	94000719 	bl	1115554 <mutex_lock>
	assert(ctx->busy);
 11138f4:	3940f260 	ldrb	w0, [x19, #60]
 11138f8:	35000140 	cbnz	w0, 1113920 <tee_ta_clear_busy+0x50>
 11138fc:	b0000203 	adrp	x3, 1154000 <__func__.1786+0x8>
 1113900:	b0000201 	adrp	x1, 1154000 <__func__.1786+0x8>
 1113904:	911f1863 	add	x3, x3, #0x7c6
 1113908:	91127021 	add	x1, x1, #0x49c
 111390c:	b0000200 	adrp	x0, 1154000 <__func__.1786+0x8>
 1113910:	91147000 	add	x0, x0, #0x51c
 1113914:	52801502 	mov	w2, #0xa8                  	// #168
 1113918:	97fffa65 	bl	11122ac <_assert_log>
 111391c:	97fffa75 	bl	11122f0 <_assert_break>
	ctx->busy = false;
 1113920:	3900f27f 	strb	wzr, [x19, #60]
	condvar_signal(&ctx->busy_cv);
 1113924:	91010260 	add	x0, x19, #0x40
 1113928:	94000824 	bl	11159b8 <condvar_signal>
	if (ctx->flags & TA_FLAG_SINGLE_INSTANCE)
 111392c:	b9400260 	ldr	w0, [x19]
 1113930:	36100040 	tbz	w0, #2, 1113938 <tee_ta_clear_busy+0x68>
		unlock_single_instance();
 1113934:	97ffffc1 	bl	1113838 <unlock_single_instance>
	mutex_unlock(&tee_ta_mutex);
 1113938:	91042280 	add	x0, x20, #0x108
}
 111393c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1113940:	a8c27bfd 	ldp	x29, x30, [sp], #32
	mutex_unlock(&tee_ta_mutex);
 1113944:	140006e3 	b	11154d0 <mutex_unlock>
}
 1113948:	a94153f3 	ldp	x19, x20, [sp, #16]
 111394c:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1113950:	d65f03c0 	ret

0000000001113954 <tee_ta_try_set_busy.part.0>:
static bool tee_ta_try_set_busy(struct tee_ta_ctx *ctx)
 1113954:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 1113958:	910003fd 	mov	x29, sp
 111395c:	a90153f3 	stp	x19, x20, [sp, #16]
 1113960:	aa0003f3 	mov	x19, x0
	mutex_lock(&tee_ta_mutex);
 1113964:	f0000254 	adrp	x20, 115e000 <state+0x80>
static bool tee_ta_try_set_busy(struct tee_ta_ctx *ctx)
 1113968:	a9025bf5 	stp	x21, x22, [sp, #32]
	mutex_lock(&tee_ta_mutex);
 111396c:	91042295 	add	x21, x20, #0x108
 1113970:	aa1503e0 	mov	x0, x21
static bool tee_ta_try_set_busy(struct tee_ta_ctx *ctx)
 1113974:	a90363f7 	stp	x23, x24, [sp, #48]
	mutex_lock(&tee_ta_mutex);
 1113978:	940006f7 	bl	1115554 <mutex_lock>
	if (ctx->flags & TA_FLAG_SINGLE_INSTANCE)
 111397c:	b9400260 	ldr	w0, [x19]
 1113980:	d0000256 	adrp	x22, 115d000 <_curve_names+0x590>
 1113984:	36100420 	tbz	w0, #2, 1113a08 <tee_ta_try_set_busy.part.0+0xb4>
	if (tee_ta_single_instance_thread != thread_get_id()) {
 1113988:	97ffc6b7 	bl	1105464 <thread_get_id>
 111398c:	79d7d2c1 	ldrsh	w1, [x22, #3048]
 1113990:	6b20a03f 	cmp	w1, w0, sxth
 1113994:	54000320 	b.eq	11139f8 <tee_ta_try_set_busy.part.0+0xa4>  // b.none
			condvar_wait(&tee_ta_cv, &tee_ta_mutex);
 1113998:	f0000257 	adrp	x23, 115e000 <state+0x80>
		while (tee_ta_single_instance_thread != THREAD_ID_INVALID)
 111399c:	912fa2d8 	add	x24, x22, #0xbe8
			condvar_wait(&tee_ta_cv, &tee_ta_mutex);
 11139a0:	9103a2f7 	add	x23, x23, #0xe8
		while (tee_ta_single_instance_thread != THREAD_ID_INVALID)
 11139a4:	79c00300 	ldrsh	w0, [x24]
 11139a8:	3100041f 	cmn	w0, #0x1
 11139ac:	540001e1 	b.ne	11139e8 <tee_ta_try_set_busy.part.0+0x94>  // b.any
		tee_ta_single_instance_thread = thread_get_id();
 11139b0:	97ffc6ad 	bl	1105464 <thread_get_id>
 11139b4:	79000300 	strh	w0, [x24]
		assert(tee_ta_single_instance_count == 0);
 11139b8:	f0000240 	adrp	x0, 115e000 <state+0x80>
 11139bc:	f9409000 	ldr	x0, [x0, #288]
 11139c0:	b40001c0 	cbz	x0, 11139f8 <tee_ta_try_set_busy.part.0+0xa4>
 11139c4:	b0000203 	adrp	x3, 1154000 <__func__.1786+0x8>
 11139c8:	b0000201 	adrp	x1, 1154000 <__func__.1786+0x8>
 11139cc:	911dbc63 	add	x3, x3, #0x76f
 11139d0:	91127021 	add	x1, x1, #0x49c
 11139d4:	b0000200 	adrp	x0, 1154000 <__func__.1786+0x8>
 11139d8:	91149800 	add	x0, x0, #0x526
 11139dc:	52800922 	mov	w2, #0x49                  	// #73
 11139e0:	97fffa33 	bl	11122ac <_assert_log>
 11139e4:	97fffa43 	bl	11122f0 <_assert_break>
			condvar_wait(&tee_ta_cv, &tee_ta_mutex);
 11139e8:	aa1503e1 	mov	x1, x21
 11139ec:	aa1703e0 	mov	x0, x23
 11139f0:	940007f6 	bl	11159c8 <condvar_wait>
 11139f4:	17ffffec 	b	11139a4 <tee_ta_try_set_busy.part.0+0x50>
	tee_ta_single_instance_count++;
 11139f8:	f0000241 	adrp	x1, 115e000 <state+0x80>
 11139fc:	f9409020 	ldr	x0, [x1, #288]
 1113a00:	91000400 	add	x0, x0, #0x1
 1113a04:	f9009020 	str	x0, [x1, #288]
	return tee_ta_single_instance_thread == thread_get_id();
 1113a08:	97ffc697 	bl	1105464 <thread_get_id>
	if (has_single_instance_lock()) {
 1113a0c:	79d7d2c1 	ldrsh	w1, [x22, #3048]
 1113a10:	6b20a03f 	cmp	w1, w0, sxth
 1113a14:	54000120 	b.eq	1113a38 <tee_ta_try_set_busy.part.0+0xe4>  // b.none
			condvar_wait(&ctx->busy_cv, &tee_ta_mutex);
 1113a18:	91042295 	add	x21, x20, #0x108
 1113a1c:	91010276 	add	x22, x19, #0x40
		while (ctx->busy)
 1113a20:	3940f262 	ldrb	w2, [x19, #60]
 1113a24:	340000e2 	cbz	w2, 1113a40 <tee_ta_try_set_busy.part.0+0xec>
			condvar_wait(&ctx->busy_cv, &tee_ta_mutex);
 1113a28:	aa1503e1 	mov	x1, x21
 1113a2c:	aa1603e0 	mov	x0, x22
 1113a30:	940007e6 	bl	11159c8 <condvar_wait>
 1113a34:	17fffffb 	b	1113a20 <tee_ta_try_set_busy.part.0+0xcc>
		if (ctx->busy) {
 1113a38:	3940f260 	ldrb	w0, [x19, #60]
 1113a3c:	35000180 	cbnz	w0, 1113a6c <tee_ta_try_set_busy.part.0+0x118>
	bool rc = true;
 1113a40:	52800035 	mov	w21, #0x1                   	// #1
	ctx->busy = true;
 1113a44:	52800020 	mov	w0, #0x1                   	// #1
 1113a48:	3900f260 	strb	w0, [x19, #60]
	mutex_unlock(&tee_ta_mutex);
 1113a4c:	91042280 	add	x0, x20, #0x108
 1113a50:	940006a0 	bl	11154d0 <mutex_unlock>
}
 1113a54:	2a1503e0 	mov	w0, w21
 1113a58:	a94153f3 	ldp	x19, x20, [sp, #16]
 1113a5c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1113a60:	a94363f7 	ldp	x23, x24, [sp, #48]
 1113a64:	a8c47bfd 	ldp	x29, x30, [sp], #64
 1113a68:	d65f03c0 	ret
			if (ctx->flags & TA_FLAG_SINGLE_INSTANCE)
 1113a6c:	b9400260 	ldr	w0, [x19]
 1113a70:	36100040 	tbz	w0, #2, 1113a78 <tee_ta_try_set_busy.part.0+0x124>
				unlock_single_instance();
 1113a74:	97ffff71 	bl	1113838 <unlock_single_instance>
			rc = false;
 1113a78:	52800015 	mov	w21, #0x0                   	// #0
 1113a7c:	17fffff2 	b	1113a44 <tee_ta_try_set_busy.part.0+0xf0>

0000000001113a80 <check_client>:
	if (id == KERN_IDENTITY)
 1113a80:	b100043f 	cmn	x1, #0x1
 1113a84:	54000400 	b.eq	1113b04 <check_client+0x84>  // b.none
{
 1113a88:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 1113a8c:	910003fd 	mov	x29, sp
	if (id == NSAPP_IDENTITY) {
 1113a90:	b5000221 	cbnz	x1, 1113ad4 <check_client+0x54>
		if (s->clnt_id.login == TEE_LOGIN_TRUSTED_APP) {
 1113a94:	b9403c02 	ldr	w2, [x0, #60]
 1113a98:	52be0001 	mov	w1, #0xf0000000            	// #-268435456
		return TEE_SUCCESS;
 1113a9c:	52800000 	mov	w0, #0x0                   	// #0
		if (s->clnt_id.login == TEE_LOGIN_TRUSTED_APP) {
 1113aa0:	6b01005f 	cmp	w2, w1
 1113aa4:	54000141 	b.ne	1113acc <check_client+0x4c>  // b.any
			DMSG("nsec tries to hijack TA session");
 1113aa8:	b0000204 	adrp	x4, 1154000 <__func__.1786+0x8>
 1113aac:	91152084 	add	x4, x4, #0x548
 1113ab0:	52800023 	mov	w3, #0x1                   	// #1
 1113ab4:	52800062 	mov	w2, #0x3                   	// #3
 1113ab8:	52803201 	mov	w1, #0x190                 	// #400
		DMSG("client id mismatch");
 1113abc:	b0000200 	adrp	x0, 1154000 <__func__.1786+0x8>
 1113ac0:	91210c00 	add	x0, x0, #0x843
 1113ac4:	9400c4a0 	bl	1144d44 <trace_printf>
		return TEE_ERROR_ACCESS_DENIED;
 1113ac8:	129fffc0 	mov	w0, #0xffff0001            	// #-65535
}
 1113acc:	a8c17bfd 	ldp	x29, x30, [sp], #16
 1113ad0:	d65f03c0 	ret
	if (memcmp(&s->clnt_id, id, sizeof(TEE_Identity)) != 0) {
 1113ad4:	9100f000 	add	x0, x0, #0x3c
 1113ad8:	d2800282 	mov	x2, #0x14                  	// #20
 1113adc:	9400c05d 	bl	1143c50 <memcmp>
 1113ae0:	2a0003e1 	mov	w1, w0
		return TEE_SUCCESS;
 1113ae4:	52800000 	mov	w0, #0x0                   	// #0
	if (memcmp(&s->clnt_id, id, sizeof(TEE_Identity)) != 0) {
 1113ae8:	34ffff21 	cbz	w1, 1113acc <check_client+0x4c>
		DMSG("client id mismatch");
 1113aec:	b0000204 	adrp	x4, 1154000 <__func__.1786+0x8>
 1113af0:	52800023 	mov	w3, #0x1                   	// #1
 1113af4:	9115a084 	add	x4, x4, #0x568
 1113af8:	52800062 	mov	w2, #0x3                   	// #3
 1113afc:	528032e1 	mov	w1, #0x197                 	// #407
 1113b00:	17ffffef 	b	1113abc <check_client+0x3c>
		return TEE_SUCCESS;
 1113b04:	52800000 	mov	w0, #0x0                   	// #0
}
 1113b08:	d65f03c0 	ret

0000000001113b0c <tee_ta_unlink_session.isra.0>:
static void tee_ta_unlink_session(struct tee_ta_session *s,
 1113b0c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 1113b10:	910003fd 	mov	x29, sp
 1113b14:	a90153f3 	stp	x19, x20, [sp, #16]
 1113b18:	aa0003f3 	mov	x19, x0
 1113b1c:	a9025bf5 	stp	x21, x22, [sp, #32]
	mutex_lock(&tee_ta_mutex);
 1113b20:	f0000255 	adrp	x21, 115e000 <state+0x80>
 1113b24:	910422b4 	add	x20, x21, #0x108
 1113b28:	aa1403e0 	mov	x0, x20
static void tee_ta_unlink_session(struct tee_ta_session *s,
 1113b2c:	aa0103f6 	mov	x22, x1
 1113b30:	f9001bf7 	str	x23, [sp, #48]
	mutex_lock(&tee_ta_mutex);
 1113b34:	94000688 	bl	1115554 <mutex_lock>
	assert(s->ref_count >= 1);
 1113b38:	b9406a60 	ldr	w0, [x19, #104]
 1113b3c:	35000140 	cbnz	w0, 1113b64 <tee_ta_unlink_session.isra.0+0x58>
 1113b40:	b0000203 	adrp	x3, 1154000 <__func__.1786+0x8>
 1113b44:	b0000201 	adrp	x1, 1154000 <__func__.1786+0x8>
 1113b48:	b0000200 	adrp	x0, 1154000 <__func__.1786+0x8>
 1113b4c:	91200463 	add	x3, x3, #0x801
 1113b50:	91127021 	add	x1, x1, #0x49c
 1113b54:	9115ec00 	add	x0, x0, #0x57b
 1113b58:	52802202 	mov	w2, #0x110                 	// #272
	assert(s->lock_thread == thread_get_id());
 1113b5c:	97fff9d4 	bl	11122ac <_assert_log>
 1113b60:	97fff9e4 	bl	11122f0 <_assert_break>
 1113b64:	79c12277 	ldrsh	w23, [x19, #144]
 1113b68:	97ffc63f 	bl	1105464 <thread_get_id>
 1113b6c:	6b20a2ff 	cmp	w23, w0, sxth
 1113b70:	54000120 	b.eq	1113b94 <tee_ta_unlink_session.isra.0+0x88>  // b.none
 1113b74:	b0000203 	adrp	x3, 1154000 <__func__.1786+0x8>
 1113b78:	b0000201 	adrp	x1, 1154000 <__func__.1786+0x8>
 1113b7c:	b0000200 	adrp	x0, 1154000 <__func__.1786+0x8>
 1113b80:	91200463 	add	x3, x3, #0x801
 1113b84:	91127021 	add	x1, x1, #0x49c
 1113b88:	91163400 	add	x0, x0, #0x58d
 1113b8c:	52802222 	mov	w2, #0x111                 	// #273
 1113b90:	17fffff3 	b	1113b5c <tee_ta_unlink_session.isra.0+0x50>
	assert(!s->unlink);
 1113b94:	39424a60 	ldrb	w0, [x19, #146]
 1113b98:	34000120 	cbz	w0, 1113bbc <tee_ta_unlink_session.isra.0+0xb0>
 1113b9c:	b0000203 	adrp	x3, 1154000 <__func__.1786+0x8>
 1113ba0:	b0000201 	adrp	x1, 1154000 <__func__.1786+0x8>
 1113ba4:	b0000200 	adrp	x0, 1154000 <__func__.1786+0x8>
 1113ba8:	91200463 	add	x3, x3, #0x801
 1113bac:	91127021 	add	x1, x1, #0x49c
 1113bb0:	9116bc00 	add	x0, x0, #0x5af
 1113bb4:	52802242 	mov	w2, #0x112                 	// #274
 1113bb8:	17ffffe9 	b	1113b5c <tee_ta_unlink_session.isra.0+0x50>
		condvar_wait(&s->refc_cv, &tee_ta_mutex);
 1113bbc:	9101c277 	add	x23, x19, #0x70
	s->unlink = true;
 1113bc0:	52800020 	mov	w0, #0x1                   	// #1
 1113bc4:	39024a60 	strb	w0, [x19, #146]
	condvar_broadcast(&s->lock_cv);
 1113bc8:	91020260 	add	x0, x19, #0x80
 1113bcc:	9400077d 	bl	11159c0 <condvar_broadcast>
	while (s->ref_count != 1)
 1113bd0:	b9406a61 	ldr	w1, [x19, #104]
 1113bd4:	7100043f 	cmp	w1, #0x1
 1113bd8:	54000181 	b.ne	1113c08 <tee_ta_unlink_session.isra.0+0xfc>  // b.any
	TAILQ_REMOVE(open_sessions, s, link);
 1113bdc:	a9400a60 	ldp	x0, x2, [x19]
 1113be0:	b40001c0 	cbz	x0, 1113c18 <tee_ta_unlink_session.isra.0+0x10c>
 1113be4:	f9000402 	str	x2, [x0, #8]
 1113be8:	f9400661 	ldr	x1, [x19, #8]
}
 1113bec:	a94153f3 	ldp	x19, x20, [sp, #16]
 1113bf0:	f9401bf7 	ldr	x23, [sp, #48]
	TAILQ_REMOVE(open_sessions, s, link);
 1113bf4:	f9000020 	str	x0, [x1]
	mutex_unlock(&tee_ta_mutex);
 1113bf8:	910422a0 	add	x0, x21, #0x108
}
 1113bfc:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1113c00:	a8c47bfd 	ldp	x29, x30, [sp], #64
	mutex_unlock(&tee_ta_mutex);
 1113c04:	14000633 	b	11154d0 <mutex_unlock>
		condvar_wait(&s->refc_cv, &tee_ta_mutex);
 1113c08:	aa1403e1 	mov	x1, x20
 1113c0c:	aa1703e0 	mov	x0, x23
 1113c10:	9400076e 	bl	11159c8 <condvar_wait>
 1113c14:	17ffffef 	b	1113bd0 <tee_ta_unlink_session.isra.0+0xc4>
	TAILQ_REMOVE(open_sessions, s, link);
 1113c18:	f90002c2 	str	x2, [x22]
 1113c1c:	17fffff3 	b	1113be8 <tee_ta_unlink_session.isra.0+0xdc>

0000000001113c20 <to_user_ta_ctx.part.0>:
 1113c20:	b0000203 	adrp	x3, 1154000 <__func__.1786+0x8>
 1113c24:	d00001e1 	adrp	x1, 1151000 <small_prime+0x168>
 1113c28:	911d8063 	add	x3, x3, #0x760
 1113c2c:	91081021 	add	x1, x1, #0x204
 1113c30:	d00001e0 	adrp	x0, 1151000 <small_prime+0x168>
 1113c34:	91088800 	add	x0, x0, #0x222
static inline struct user_ta_ctx *to_user_ta_ctx(struct ts_ctx *ctx)
 1113c38:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	assert(is_user_ta_ctx(ctx));
 1113c3c:	52800702 	mov	w2, #0x38                  	// #56
static inline struct user_ta_ctx *to_user_ta_ctx(struct ts_ctx *ctx)
 1113c40:	910003fd 	mov	x29, sp
	assert(is_user_ta_ctx(ctx));
 1113c44:	97fff99a 	bl	11122ac <_assert_log>
 1113c48:	97fff9aa 	bl	11122f0 <_assert_break>

0000000001113c4c <tee_ta_set_busy>:
	if (ctx->flags & TA_FLAG_CONCURRENT)
 1113c4c:	b9400001 	ldr	w1, [x0]
 1113c50:	374001e1 	tbnz	w1, #8, 1113c8c <tee_ta_set_busy+0x40>
{
 1113c54:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 1113c58:	910003fd 	mov	x29, sp
 1113c5c:	97ffff3e 	bl	1113954 <tee_ta_try_set_busy.part.0>
	if (!tee_ta_try_set_busy(ctx))
 1113c60:	72001c1f 	tst	w0, #0xff
 1113c64:	54000101 	b.ne	1113c84 <tee_ta_set_busy+0x38>  // b.any
		panic();
 1113c68:	b0000202 	adrp	x2, 1154000 <__func__.1786+0x8>
 1113c6c:	b0000200 	adrp	x0, 1154000 <__func__.1786+0x8>
 1113c70:	911ed842 	add	x2, x2, #0x7b6
 1113c74:	91127000 	add	x0, x0, #0x49c
 1113c78:	d2800003 	mov	x3, #0x0                   	// #0
 1113c7c:	528013c1 	mov	w1, #0x9e                  	// #158
 1113c80:	97fffdfa 	bl	1113468 <__do_panic>
}
 1113c84:	a8c17bfd 	ldp	x29, x30, [sp], #16
 1113c88:	d65f03c0 	ret
 1113c8c:	d65f03c0 	ret

0000000001113c90 <tee_ta_put_session>:
{
 1113c90:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1113c94:	910003fd 	mov	x29, sp
 1113c98:	a90153f3 	stp	x19, x20, [sp, #16]
 1113c9c:	aa0003f3 	mov	x19, x0
	mutex_lock(&tee_ta_mutex);
 1113ca0:	f0000254 	adrp	x20, 115e000 <state+0x80>
 1113ca4:	91042280 	add	x0, x20, #0x108
{
 1113ca8:	f90013f5 	str	x21, [sp, #32]
	mutex_lock(&tee_ta_mutex);
 1113cac:	9400062a 	bl	1115554 <mutex_lock>
	if (s->lock_thread == thread_get_id()) {
 1113cb0:	79c12275 	ldrsh	w21, [x19, #144]
 1113cb4:	97ffc5ec 	bl	1105464 <thread_get_id>
 1113cb8:	6b20a2bf 	cmp	w21, w0, sxth
 1113cbc:	540000a1 	b.ne	1113cd0 <tee_ta_put_session+0x40>  // b.any
		s->lock_thread = THREAD_ID_INVALID;
 1113cc0:	12800000 	mov	w0, #0xffffffff            	// #-1
 1113cc4:	79012260 	strh	w0, [x19, #144]
		condvar_signal(&s->lock_cv);
 1113cc8:	91020260 	add	x0, x19, #0x80
 1113ccc:	9400073b 	bl	11159b8 <condvar_signal>
	dec_session_ref_count(s);
 1113cd0:	aa1303e0 	mov	x0, x19
 1113cd4:	97fffec5 	bl	11137e8 <dec_session_ref_count>
	mutex_unlock(&tee_ta_mutex);
 1113cd8:	91042280 	add	x0, x20, #0x108
}
 1113cdc:	a94153f3 	ldp	x19, x20, [sp, #16]
 1113ce0:	f94013f5 	ldr	x21, [sp, #32]
 1113ce4:	a8c37bfd 	ldp	x29, x30, [sp], #48
	mutex_unlock(&tee_ta_mutex);
 1113ce8:	140005fa 	b	11154d0 <mutex_unlock>

0000000001113cec <tee_ta_find_session>:
{
 1113cec:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1113cf0:	910003fd 	mov	x29, sp
 1113cf4:	a90153f3 	stp	x19, x20, [sp, #16]
	mutex_lock(&tee_ta_mutex);
 1113cf8:	f0000254 	adrp	x20, 115e000 <state+0x80>
{
 1113cfc:	aa0103f3 	mov	x19, x1
 1113d00:	f90013f5 	str	x21, [sp, #32]
 1113d04:	2a0003f5 	mov	w21, w0
	mutex_lock(&tee_ta_mutex);
 1113d08:	91042280 	add	x0, x20, #0x108
 1113d0c:	94000612 	bl	1115554 <mutex_lock>
	TAILQ_FOREACH(s, open_sessions, link) {
 1113d10:	f9400273 	ldr	x19, [x19]
 1113d14:	b4000093 	cbz	x19, 1113d24 <tee_ta_find_session+0x38>
		if (s->id == id) {
 1113d18:	b9403a60 	ldr	w0, [x19, #56]
 1113d1c:	6b0002bf 	cmp	w21, w0
 1113d20:	54ffff81 	b.ne	1113d10 <tee_ta_find_session+0x24>  // b.any
	mutex_unlock(&tee_ta_mutex);
 1113d24:	91042280 	add	x0, x20, #0x108
 1113d28:	940005ea 	bl	11154d0 <mutex_unlock>
}
 1113d2c:	aa1303e0 	mov	x0, x19
 1113d30:	a94153f3 	ldp	x19, x20, [sp, #16]
 1113d34:	f94013f5 	ldr	x21, [sp, #32]
 1113d38:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1113d3c:	d65f03c0 	ret

0000000001113d40 <tee_ta_get_session>:
{
 1113d40:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1113d44:	910003fd 	mov	x29, sp
 1113d48:	a90153f3 	stp	x19, x20, [sp, #16]
	mutex_lock(&tee_ta_mutex);
 1113d4c:	f0000254 	adrp	x20, 115e000 <state+0x80>
{
 1113d50:	aa0203f3 	mov	x19, x2
 1113d54:	a9025bf5 	stp	x21, x22, [sp, #32]
 1113d58:	2a0003f5 	mov	w21, w0
 1113d5c:	12001c36 	and	w22, w1, #0xff
	mutex_lock(&tee_ta_mutex);
 1113d60:	91042280 	add	x0, x20, #0x108
 1113d64:	940005fc 	bl	1115554 <mutex_lock>
	TAILQ_FOREACH(s, open_sessions, link) {
 1113d68:	f9400273 	ldr	x19, [x19]
 1113d6c:	b5000113 	cbnz	x19, 1113d8c <tee_ta_get_session+0x4c>
	mutex_unlock(&tee_ta_mutex);
 1113d70:	91042280 	add	x0, x20, #0x108
 1113d74:	940005d7 	bl	11154d0 <mutex_unlock>
}
 1113d78:	aa1303e0 	mov	x0, x19
 1113d7c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1113d80:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1113d84:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1113d88:	d65f03c0 	ret
		if (s->id == id) {
 1113d8c:	b9403a60 	ldr	w0, [x19, #56]
 1113d90:	6b0002bf 	cmp	w21, w0
 1113d94:	54fffea1 	b.ne	1113d68 <tee_ta_get_session+0x28>  // b.any
		if (s->unlink) {
 1113d98:	39424a60 	ldrb	w0, [x19, #146]
 1113d9c:	35000240 	cbnz	w0, 1113de4 <tee_ta_get_session+0xa4>
		s->ref_count++;
 1113da0:	b9406a60 	ldr	w0, [x19, #104]
 1113da4:	11000400 	add	w0, w0, #0x1
 1113da8:	b9006a60 	str	w0, [x19, #104]
		if (!exclusive)
 1113dac:	34fffe36 	cbz	w22, 1113d70 <tee_ta_get_session+0x30>
		assert(s->lock_thread != thread_get_id());
 1113db0:	79c12275 	ldrsh	w21, [x19, #144]
 1113db4:	97ffc5ac 	bl	1105464 <thread_get_id>
 1113db8:	6b20a2bf 	cmp	w21, w0, sxth
 1113dbc:	54000180 	b.eq	1113dec <tee_ta_get_session+0xac>  // b.none
			condvar_wait(&s->lock_cv, &tee_ta_mutex);
 1113dc0:	91042295 	add	x21, x20, #0x108
 1113dc4:	91020276 	add	x22, x19, #0x80
		while (s->lock_thread != THREAD_ID_INVALID && !s->unlink)
 1113dc8:	79c12260 	ldrsh	w0, [x19, #144]
 1113dcc:	39424a62 	ldrb	w2, [x19, #146]
 1113dd0:	3100041f 	cmn	w0, #0x1
 1113dd4:	54000260 	b.eq	1113e20 <tee_ta_get_session+0xe0>  // b.none
 1113dd8:	340001c2 	cbz	w2, 1113e10 <tee_ta_get_session+0xd0>
			dec_session_ref_count(s);
 1113ddc:	aa1303e0 	mov	x0, x19
 1113de0:	97fffe82 	bl	11137e8 <dec_session_ref_count>
			break;
 1113de4:	d2800013 	mov	x19, #0x0                   	// #0
 1113de8:	17ffffe2 	b	1113d70 <tee_ta_get_session+0x30>
		assert(s->lock_thread != thread_get_id());
 1113dec:	b0000203 	adrp	x3, 1154000 <__func__.1786+0x8>
 1113df0:	b0000201 	adrp	x1, 1154000 <__func__.1786+0x8>
 1113df4:	911fb863 	add	x3, x3, #0x7ee
 1113df8:	91127021 	add	x1, x1, #0x49c
 1113dfc:	b0000200 	adrp	x0, 1154000 <__func__.1786+0x8>
 1113e00:	9116e800 	add	x0, x0, #0x5ba
 1113e04:	52801f02 	mov	w2, #0xf8                  	// #248
 1113e08:	97fff929 	bl	11122ac <_assert_log>
 1113e0c:	97fff939 	bl	11122f0 <_assert_break>
			condvar_wait(&s->lock_cv, &tee_ta_mutex);
 1113e10:	aa1503e1 	mov	x1, x21
 1113e14:	aa1603e0 	mov	x0, x22
 1113e18:	940006ec 	bl	11159c8 <condvar_wait>
 1113e1c:	17ffffeb 	b	1113dc8 <tee_ta_get_session+0x88>
		if (s->unlink) {
 1113e20:	35fffde2 	cbnz	w2, 1113ddc <tee_ta_get_session+0x9c>
		s->lock_thread = thread_get_id();
 1113e24:	97ffc590 	bl	1105464 <thread_get_id>
 1113e28:	79012260 	strh	w0, [x19, #144]
		break;
 1113e2c:	17ffffd1 	b	1113d70 <tee_ta_get_session+0x30>

0000000001113e30 <tee_ta_cancel_command>:
}

TEE_Result tee_ta_cancel_command(TEE_ErrorOrigin *err,
				 struct tee_ta_session *sess,
				 const TEE_Identity *clnt_id)
{
 1113e30:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1113e34:	910003fd 	mov	x29, sp
 1113e38:	f9000bf3 	str	x19, [sp, #16]
 1113e3c:	aa0103f3 	mov	x19, x1
 1113e40:	aa0203e1 	mov	x1, x2
	*err = TEE_ORIGIN_TEE;
 1113e44:	52800062 	mov	w2, #0x3                   	// #3
 1113e48:	b9000002 	str	w2, [x0]

	if (check_client(sess, clnt_id) != TEE_SUCCESS)
 1113e4c:	aa1303e0 	mov	x0, x19
 1113e50:	97ffff0c 	bl	1113a80 <check_client>
 1113e54:	350000c0 	cbnz	w0, 1113e6c <tee_ta_cancel_command+0x3c>
		return TEE_ERROR_BAD_PARAMETERS; /* intentional generic error */

	sess->cancel = true;
 1113e58:	52800021 	mov	w1, #0x1                   	// #1
 1113e5c:	39017261 	strb	w1, [x19, #92]
	return TEE_SUCCESS;
}
 1113e60:	f9400bf3 	ldr	x19, [sp, #16]
 1113e64:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1113e68:	d65f03c0 	ret
		return TEE_ERROR_BAD_PARAMETERS; /* intentional generic error */
 1113e6c:	129fff20 	mov	w0, #0xffff0006            	// #-65530
 1113e70:	17fffffc 	b	1113e60 <tee_ta_cancel_command+0x30>

0000000001113e74 <tee_ta_session_is_cancelled>:

bool tee_ta_session_is_cancelled(struct tee_ta_session *s, TEE_Time *curr_time)
{
 1113e74:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1113e78:	910003fd 	mov	x29, sp
 1113e7c:	f9000bf3 	str	x19, [sp, #16]
 1113e80:	aa0003f3 	mov	x19, x0
	TEE_Time current_time;

	if (s->cancel_mask)
 1113e84:	39417400 	ldrb	w0, [x0, #93]
 1113e88:	340000a0 	cbz	w0, 1113e9c <tee_ta_session_is_cancelled+0x28>
		return false;
 1113e8c:	52800000 	mov	w0, #0x0                   	// #0
	     current_time.millis >= s->cancel_time.millis)) {
		return true;
	}

	return false;
}
 1113e90:	f9400bf3 	ldr	x19, [sp, #16]
 1113e94:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1113e98:	d65f03c0 	ret
	if (s->cancel)
 1113e9c:	39417260 	ldrb	w0, [x19, #92]
 1113ea0:	35000240 	cbnz	w0, 1113ee8 <tee_ta_session_is_cancelled+0x74>
	if (s->cancel_time.seconds == UINT32_MAX)
 1113ea4:	b9406260 	ldr	w0, [x19, #96]
 1113ea8:	3100041f 	cmn	w0, #0x1
 1113eac:	54ffff00 	b.eq	1113e8c <tee_ta_session_is_cancelled+0x18>  // b.none
	if (curr_time != NULL)
 1113eb0:	b4000201 	cbz	x1, 1113ef0 <tee_ta_session_is_cancelled+0x7c>
		current_time = *curr_time;
 1113eb4:	b9400020 	ldr	w0, [x1]
 1113eb8:	b9002be0 	str	w0, [sp, #40]
 1113ebc:	b9400420 	ldr	w0, [x1, #4]
 1113ec0:	b9002fe0 	str	w0, [sp, #44]
	if (current_time.seconds > s->cancel_time.seconds ||
 1113ec4:	b9406260 	ldr	w0, [x19, #96]
 1113ec8:	b9402be1 	ldr	w1, [sp, #40]
 1113ecc:	6b00003f 	cmp	w1, w0
 1113ed0:	540000c8 	b.hi	1113ee8 <tee_ta_session_is_cancelled+0x74>  // b.pmore
 1113ed4:	54fffdc1 	b.ne	1113e8c <tee_ta_session_is_cancelled+0x18>  // b.any
	    (current_time.seconds == s->cancel_time.seconds &&
 1113ed8:	b9406660 	ldr	w0, [x19, #100]
 1113edc:	b9402fe1 	ldr	w1, [sp, #44]
 1113ee0:	6b00003f 	cmp	w1, w0
 1113ee4:	54fffd43 	b.cc	1113e8c <tee_ta_session_is_cancelled+0x18>  // b.lo, b.ul, b.last
		return true;
 1113ee8:	52800020 	mov	w0, #0x1                   	// #1
 1113eec:	17ffffe9 	b	1113e90 <tee_ta_session_is_cancelled+0x1c>
	else if (tee_time_get_sys_time(&current_time) != TEE_SUCCESS)
 1113ef0:	9100a3e0 	add	x0, sp, #0x28
 1113ef4:	97ffc0af 	bl	11041b0 <tee_time_get_sys_time>
 1113ef8:	34fffe60 	cbz	w0, 1113ec4 <tee_ta_session_is_cancelled+0x50>
 1113efc:	17ffffe4 	b	1113e8c <tee_ta_session_is_cancelled+0x18>

0000000001113f00 <is_ta_ctx>:
	ftrace_update_times(false);
}
#endif

bool is_ta_ctx(struct ts_ctx *ctx)
{
 1113f00:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1113f04:	910003fd 	mov	x29, sp
 1113f08:	f9000bf3 	str	x19, [sp, #16]
 1113f0c:	aa0003f3 	mov	x19, x0
	return is_user_ta_ctx(ctx) || is_pseudo_ta_ctx(ctx);
 1113f10:	940008b7 	bl	11161ec <is_user_ta_ctx>
 1113f14:	72001c1f 	tst	w0, #0xff
 1113f18:	54000101 	b.ne	1113f38 <is_ta_ctx+0x38>  // b.any
 1113f1c:	aa1303e0 	mov	x0, x19
 1113f20:	94000e36 	bl	11177f8 <is_pseudo_ta_ctx>
 1113f24:	12001c00 	and	w0, w0, #0xff
}
 1113f28:	12000000 	and	w0, w0, #0x1
 1113f2c:	f9400bf3 	ldr	x19, [sp, #16]
 1113f30:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1113f34:	d65f03c0 	ret
	return is_user_ta_ctx(ctx) || is_pseudo_ta_ctx(ctx);
 1113f38:	52800020 	mov	w0, #0x1                   	// #1
 1113f3c:	17fffffb 	b	1113f28 <is_ta_ctx+0x28>

0000000001113f40 <to_ta_session>:
{
 1113f40:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1113f44:	910003fd 	mov	x29, sp
 1113f48:	f9000bf3 	str	x19, [sp, #16]
 1113f4c:	aa0003f3 	mov	x19, x0
	assert(is_ta_ctx(sess->ctx) || is_stmm_ctx(sess->ctx));
 1113f50:	f9400800 	ldr	x0, [x0, #16]
 1113f54:	97ffffeb 	bl	1113f00 <is_ta_ctx>
 1113f58:	72001c1f 	tst	w0, #0xff
 1113f5c:	54000141 	b.ne	1113f84 <to_ta_session+0x44>  // b.any
 1113f60:	b0000203 	adrp	x3, 1154000 <__func__.1786+0x8>
 1113f64:	b0000201 	adrp	x1, 1154000 <__func__.1786+0x8>
 1113f68:	911e6c63 	add	x3, x3, #0x79b
 1113f6c:	91127021 	add	x1, x1, #0x49c
 1113f70:	b0000200 	adrp	x0, 1154000 <__func__.1786+0x8>
 1113f74:	91177000 	add	x0, x0, #0x5dc
 1113f78:	52800ca2 	mov	w2, #0x65                  	// #101
 1113f7c:	97fff8cc 	bl	11122ac <_assert_log>
 1113f80:	97fff8dc 	bl	11122f0 <_assert_break>
}
 1113f84:	d1004260 	sub	x0, x19, #0x10
 1113f88:	f9400bf3 	ldr	x19, [sp, #16]
 1113f8c:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1113f90:	d65f03c0 	ret

0000000001113f94 <ts_to_ta_ctx>:
{
 1113f94:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1113f98:	910003fd 	mov	x29, sp
 1113f9c:	f9000bf3 	str	x19, [sp, #16]
 1113fa0:	aa0003f3 	mov	x19, x0
	if (is_ta_ctx(ctx))
 1113fa4:	97ffffd7 	bl	1113f00 <is_ta_ctx>
 1113fa8:	72001c1f 	tst	w0, #0xff
 1113fac:	54000240 	b.eq	1113ff4 <ts_to_ta_ctx+0x60>  // b.none

struct tee_ta_session *to_ta_session(struct ts_session *sess);

static inline struct tee_ta_ctx *to_ta_ctx(struct ts_ctx *ctx)
{
	assert(is_ta_ctx(ctx));
 1113fb0:	aa1303e0 	mov	x0, x19
 1113fb4:	97ffffd3 	bl	1113f00 <is_ta_ctx>
 1113fb8:	72001c1f 	tst	w0, #0xff
 1113fbc:	54000141 	b.ne	1113fe4 <ts_to_ta_ctx+0x50>  // b.any
 1113fc0:	b0000203 	adrp	x3, 1154000 <__func__.1786+0x8>
 1113fc4:	b0000201 	adrp	x1, 1154000 <__func__.1786+0x8>
 1113fc8:	911d5863 	add	x3, x3, #0x756
 1113fcc:	91182c21 	add	x1, x1, #0x60b
 1113fd0:	b0000200 	adrp	x0, 1154000 <__func__.1786+0x8>
 1113fd4:	9118c000 	add	x0, x0, #0x630
 1113fd8:	528014c2 	mov	w2, #0xa6                  	// #166
 1113fdc:	97fff8b4 	bl	11122ac <_assert_log>
 1113fe0:	97fff8c4 	bl	11122f0 <_assert_break>
	return container_of(ctx, struct tee_ta_ctx, ts_ctx);
 1113fe4:	d1006260 	sub	x0, x19, #0x18
}
 1113fe8:	f9400bf3 	ldr	x19, [sp, #16]
 1113fec:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1113ff0:	d65f03c0 	ret
	panic("bad context");
 1113ff4:	b0000203 	adrp	x3, 1154000 <__func__.1786+0x8>
 1113ff8:	b0000202 	adrp	x2, 1154000 <__func__.1786+0x8>
 1113ffc:	b0000200 	adrp	x0, 1154000 <__func__.1786+0x8>
 1114000:	9118fc63 	add	x3, x3, #0x63f
 1114004:	911ea442 	add	x2, x2, #0x7a9
 1114008:	91127000 	add	x0, x0, #0x49c
 111400c:	52800e21 	mov	w1, #0x71                  	// #113
 1114010:	97fffd16 	bl	1113468 <__do_panic>

0000000001114014 <tee_ta_close_session>:
{
 1114014:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 1114018:	910003fd 	mov	x29, sp
 111401c:	a90153f3 	stp	x19, x20, [sp, #16]
 1114020:	aa0003f4 	mov	x20, x0
 1114024:	a9025bf5 	stp	x21, x22, [sp, #32]
 1114028:	aa0103f6 	mov	x22, x1
 111402c:	aa0203f5 	mov	x21, x2
 1114030:	a90363f7 	stp	x23, x24, [sp, #48]
	DMSG("csess 0x%" PRIxVA " id %u",
 1114034:	b40003a0 	cbz	x0, 11140a8 <tee_ta_close_session+0x94>
 1114038:	b9403806 	ldr	w6, [x0, #56]
 111403c:	90000217 	adrp	x23, 1154000 <__func__.1786+0x8>
 1114040:	912142f8 	add	x24, x23, #0x850
 1114044:	90000204 	adrp	x4, 1154000 <__func__.1786+0x8>
 1114048:	aa1403e5 	mov	x5, x20
 111404c:	91192c84 	add	x4, x4, #0x64b
 1114050:	aa1803e0 	mov	x0, x24
 1114054:	52800023 	mov	w3, #0x1                   	// #1
 1114058:	52800062 	mov	w2, #0x3                   	// #3
 111405c:	52804001 	mov	w1, #0x200                 	// #512
 1114060:	9400c339 	bl	1144d44 <trace_printf>
	if (!csess)
 1114064:	b40001f4 	cbz	x20, 11140a0 <tee_ta_close_session+0x8c>
	sess = tee_ta_get_session(csess->id, true, open_sessions);
 1114068:	b9403a80 	ldr	w0, [x20, #56]
 111406c:	aa1603e2 	mov	x2, x22
 1114070:	52800021 	mov	w1, #0x1                   	// #1
 1114074:	97ffff33 	bl	1113d40 <tee_ta_get_session>
 1114078:	aa0003f3 	mov	x19, x0
	if (!sess) {
 111407c:	b50001a0 	cbnz	x0, 11140b0 <tee_ta_close_session+0x9c>
		EMSG("session 0x%" PRIxVA " to be removed is not found",
 1114080:	90000204 	adrp	x4, 1154000 <__func__.1786+0x8>
 1114084:	aa1403e5 	mov	x5, x20
 1114088:	91197484 	add	x4, x4, #0x65d
 111408c:	aa1803e0 	mov	x0, x24
 1114090:	52800023 	mov	w3, #0x1                   	// #1
 1114094:	52800022 	mov	w2, #0x1                   	// #1
 1114098:	52804121 	mov	w1, #0x209                 	// #521
 111409c:	9400c32a 	bl	1144d44 <trace_printf>
		return TEE_ERROR_ITEM_NOT_FOUND;
 11140a0:	129ffef5 	mov	w21, #0xffff0008            	// #-65528
 11140a4:	1400000a 	b	11140cc <tee_ta_close_session+0xb8>
	DMSG("csess 0x%" PRIxVA " id %u",
 11140a8:	12800006 	mov	w6, #0xffffffff            	// #-1
 11140ac:	17ffffe4 	b	111403c <tee_ta_close_session+0x28>
	if (check_client(sess, clnt_id) != TEE_SUCCESS) {
 11140b0:	aa1503e1 	mov	x1, x21
 11140b4:	97fffe73 	bl	1113a80 <check_client>
 11140b8:	2a0003f5 	mov	w21, w0
 11140bc:	34000140 	cbz	w0, 11140e4 <tee_ta_close_session+0xd0>
		return TEE_ERROR_BAD_PARAMETERS; /* intentional generic error */
 11140c0:	129fff35 	mov	w21, #0xffff0006            	// #-65530
		tee_ta_put_session(sess);
 11140c4:	aa1303e0 	mov	x0, x19
 11140c8:	97fffef2 	bl	1113c90 <tee_ta_put_session>
}
 11140cc:	2a1503e0 	mov	w0, w21
 11140d0:	a94153f3 	ldp	x19, x20, [sp, #16]
 11140d4:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11140d8:	a94363f7 	ldp	x23, x24, [sp, #48]
 11140dc:	a8c47bfd 	ldp	x29, x30, [sp], #64
 11140e0:	d65f03c0 	ret
	DMSG("Destroy session");
 11140e4:	aa1803e0 	mov	x0, x24
 11140e8:	90000204 	adrp	x4, 1154000 <__func__.1786+0x8>
 11140ec:	52800023 	mov	w3, #0x1                   	// #1
 11140f0:	911a1884 	add	x4, x4, #0x686
 11140f4:	52800062 	mov	w2, #0x3                   	// #3
 11140f8:	52804261 	mov	w1, #0x213                 	// #531
 11140fc:	9400c312 	bl	1144d44 <trace_printf>
	ts_ctx = sess->ts_sess.ctx;
 1114100:	910022d6 	add	x22, x22, #0x8
 1114104:	f9401278 	ldr	x24, [x19, #32]
	if (!ts_ctx) {
 1114108:	b50000f8 	cbnz	x24, 1114124 <tee_ta_close_session+0x110>
	tee_ta_unlink_session(s, open_sessions);
 111410c:	aa1603e1 	mov	x1, x22
 1114110:	aa1303e0 	mov	x0, x19
 1114114:	97fffe7e 	bl	1113b0c <tee_ta_unlink_session.isra.0>
	free(s);
 1114118:	aa1303e0 	mov	x0, x19
 111411c:	9400bd31 	bl	11435e0 <free>
}
 1114120:	17ffffeb 	b	11140cc <tee_ta_close_session+0xb8>
	ctx = ts_to_ta_ctx(ts_ctx);
 1114124:	aa1803e0 	mov	x0, x24
 1114128:	97ffff9b 	bl	1113f94 <ts_to_ta_ctx>
	if (ctx->panicked) {
 111412c:	b9403001 	ldr	w1, [x0, #48]
	ctx = ts_to_ta_ctx(ts_ctx);
 1114130:	aa0003f4 	mov	x20, x0
	if (ctx->panicked) {
 1114134:	34000221 	cbz	w1, 1114178 <tee_ta_close_session+0x164>
	tee_ta_unlink_session(s, open_sessions);
 1114138:	aa1603e1 	mov	x1, x22
 111413c:	aa1303e0 	mov	x0, x19
 1114140:	97fffe73 	bl	1113b0c <tee_ta_unlink_session.isra.0>
	free(s);
 1114144:	aa1303e0 	mov	x0, x19
 1114148:	9400bd26 	bl	11435e0 <free>
	mutex_lock(&tee_ta_mutex);
 111414c:	d0000253 	adrp	x19, 115e000 <state+0x80>
 1114150:	91042260 	add	x0, x19, #0x108
 1114154:	94000500 	bl	1115554 <mutex_lock>
	if (ctx->ref_count <= 0)
 1114158:	b9403a80 	ldr	w0, [x20, #56]
 111415c:	350002c0 	cbnz	w0, 11141b4 <tee_ta_close_session+0x1a0>
		panic();
 1114160:	90000200 	adrp	x0, 1154000 <__func__.1786+0x8>
 1114164:	912142e2 	add	x2, x23, #0x850
 1114168:	91127000 	add	x0, x0, #0x49c
 111416c:	d2800003 	mov	x3, #0x0                   	// #0
 1114170:	52804521 	mov	w1, #0x229                 	// #553
 1114174:	97fffcbd 	bl	1113468 <__do_panic>
		tee_ta_set_busy(ctx);
 1114178:	97fffeb5 	bl	1113c4c <tee_ta_set_busy>
	sess->cancel_time.seconds = UINT32_MAX;
 111417c:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
 1114180:	f9003260 	str	x0, [x19, #96]
		ts_ctx->ops->enter_close_session(&sess->ts_sess);
 1114184:	f9400b00 	ldr	x0, [x24, #16]
 1114188:	f9400801 	ldr	x1, [x0, #16]
 111418c:	91004260 	add	x0, x19, #0x10
 1114190:	d63f0020 	blr	x1
	tee_ta_unlink_session(s, open_sessions);
 1114194:	aa1603e1 	mov	x1, x22
 1114198:	aa1303e0 	mov	x0, x19
 111419c:	97fffe5c 	bl	1113b0c <tee_ta_unlink_session.isra.0>
	free(s);
 11141a0:	aa1303e0 	mov	x0, x19
 11141a4:	9400bd0f 	bl	11435e0 <free>
		tee_ta_clear_busy(ctx);
 11141a8:	aa1403e0 	mov	x0, x20
 11141ac:	97fffdc9 	bl	11138d0 <tee_ta_clear_busy>
 11141b0:	17ffffe7 	b	111414c <tee_ta_close_session+0x138>
	ctx->ref_count--;
 11141b4:	51000400 	sub	w0, w0, #0x1
 11141b8:	b9003a80 	str	w0, [x20, #56]
	if (!ctx->ref_count && !keep_alive) {
 11141bc:	35000280 	cbnz	w0, 111420c <tee_ta_close_session+0x1f8>
	keep_alive = (ctx->flags & TA_FLAG_INSTANCE_KEEP_ALIVE) &&
 11141c0:	b9400280 	ldr	w0, [x20]
 11141c4:	52800281 	mov	w1, #0x14                  	// #20
 11141c8:	0a010000 	and	w0, w0, w1
	if (!ctx->ref_count && !keep_alive) {
 11141cc:	6b01001f 	cmp	w0, w1
 11141d0:	540001e0 	b.eq	111420c <tee_ta_close_session+0x1f8>  // b.none
		TAILQ_REMOVE(&tee_ctxes, ctx, link);
 11141d4:	a9408680 	ldp	x0, x1, [x20, #8]
 11141d8:	b4000140 	cbz	x0, 1114200 <tee_ta_close_session+0x1ec>
 11141dc:	f9000801 	str	x1, [x0, #16]
 11141e0:	f9400a81 	ldr	x1, [x20, #16]
	return TEE_SUCCESS;
 11141e4:	52800015 	mov	w21, #0x0                   	// #0
		TAILQ_REMOVE(&tee_ctxes, ctx, link);
 11141e8:	f9000020 	str	x0, [x1]
		mutex_unlock(&tee_ta_mutex);
 11141ec:	91042260 	add	x0, x19, #0x108
 11141f0:	940004b8 	bl	11154d0 <mutex_unlock>
		destroy_context(ctx);
 11141f4:	aa1403e0 	mov	x0, x20
 11141f8:	97fffd66 	bl	1113790 <destroy_context>
 11141fc:	17ffffb4 	b	11140cc <tee_ta_close_session+0xb8>
		TAILQ_REMOVE(&tee_ctxes, ctx, link);
 1114200:	f0000222 	adrp	x2, 115b000 <__vcore_unpg_rw_start>
 1114204:	f903ec41 	str	x1, [x2, #2008]
 1114208:	17fffff6 	b	11141e0 <tee_ta_close_session+0x1cc>
		mutex_unlock(&tee_ta_mutex);
 111420c:	91042260 	add	x0, x19, #0x108
 1114210:	940004b0 	bl	11154d0 <mutex_unlock>
 1114214:	17ffffae 	b	11140cc <tee_ta_close_session+0xb8>

0000000001114218 <tee_ta_open_session>:
{
 1114218:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
 111421c:	910003fd 	mov	x29, sp
 1114220:	a9025bf5 	stp	x21, x22, [sp, #32]
 1114224:	aa0003f6 	mov	x22, x0
	struct tee_ta_session *s = calloc(1, sizeof(struct tee_ta_session));
 1114228:	d2800020 	mov	x0, #0x1                   	// #1
{
 111422c:	a90153f3 	stp	x19, x20, [sp, #16]
 1114230:	aa0203f4 	mov	x20, x2
 1114234:	a90363f7 	stp	x23, x24, [sp, #48]
 1114238:	aa0303f7 	mov	x23, x3
 111423c:	a9046bf9 	stp	x25, x26, [sp, #64]
 1114240:	2a0503f9 	mov	w25, w5
 1114244:	a90573fb 	stp	x27, x28, [sp, #80]
 1114248:	a90613e1 	stp	x1, x4, [sp, #96]
	struct tee_ta_session *s = calloc(1, sizeof(struct tee_ta_session));
 111424c:	d2801301 	mov	x1, #0x98                  	// #152
{
 1114250:	f9003be6 	str	x6, [sp, #112]
	struct tee_ta_session *s = calloc(1, sizeof(struct tee_ta_session));
 1114254:	9400bc9f 	bl	11434d0 <calloc>
 1114258:	aa0003f3 	mov	x19, x0
	*err = TEE_ORIGIN_TEE;
 111425c:	52800060 	mov	w0, #0x3                   	// #3
 1114260:	b90002c0 	str	w0, [x22]
	if (!s)
 1114264:	b40010d3 	cbz	x19, 111447c <tee_ta_open_session+0x264>
	s->cancel_mask = true;
 1114268:	52800020 	mov	w0, #0x1                   	// #1
 111426c:	39017660 	strb	w0, [x19, #93]
	condvar_init(&s->refc_cv);
 1114270:	9101c260 	add	x0, x19, #0x70
 1114274:	940005b9 	bl	1115958 <condvar_init>
	condvar_init(&s->lock_cv);
 1114278:	91020260 	add	x0, x19, #0x80
 111427c:	940005b7 	bl	1115958 <condvar_init>
	s->lock_thread = THREAD_ID_INVALID;
 1114280:	12800000 	mov	w0, #0xffffffff            	// #-1
	s->ref_count = 1;
 1114284:	5280003a 	mov	w26, #0x1                   	// #1
	mutex_lock(&tee_ta_mutex);
 1114288:	d0000255 	adrp	x21, 115e000 <state+0x80>
	s->ref_count = 1;
 111428c:	b9006a7a 	str	w26, [x19, #104]
	s->lock_thread = THREAD_ID_INVALID;
 1114290:	79012260 	strh	w0, [x19, #144]
	mutex_lock(&tee_ta_mutex);
 1114294:	910422a0 	add	x0, x21, #0x108
 1114298:	940004af 	bl	1115554 <mutex_lock>
	last = TAILQ_LAST(open_sessions, tee_ta_session_head);
 111429c:	f9400683 	ldr	x3, [x20, #8]
 11142a0:	f9400460 	ldr	x0, [x3, #8]
 11142a4:	f9400000 	ldr	x0, [x0]
	if (last) {
 11142a8:	b4000800 	cbz	x0, 11143a8 <tee_ta_open_session+0x190>
		id = last->id + 1;
 11142ac:	b9403801 	ldr	w1, [x0, #56]
 11142b0:	2b1a0021 	adds	w1, w1, w26
 11142b4:	1a9a1021 	csel	w1, w1, w26, ne  // ne = any
		if (!tee_ta_find_session_nolock(id, open_sessions))
 11142b8:	f9400285 	ldr	x5, [x20]
 11142bc:	2a0103e0 	mov	w0, w1
 11142c0:	52800024 	mov	w4, #0x1                   	// #1
	TAILQ_FOREACH(s, open_sessions, link) {
 11142c4:	aa0503e2 	mov	x2, x5
 11142c8:	b5000742 	cbnz	x2, 11143b0 <tee_ta_open_session+0x198>
	s->id = new_session_id(open_sessions);
 11142cc:	b9003a60 	str	w0, [x19, #56]
	if (!s->id) {
 11142d0:	34000d20 	cbz	w0, 1114474 <tee_ta_open_session+0x25c>
	TAILQ_INSERT_TAIL(open_sessions, s, link);
 11142d4:	a9000e7f 	stp	xzr, x3, [x19]
		condvar_wait(&tee_ta_init_cv, &tee_ta_mutex);
 11142d8:	d000025a 	adrp	x26, 115e000 <state+0x80>
 11142dc:	910422bc 	add	x28, x21, #0x108
 11142e0:	9103e35a 	add	x26, x26, #0xf8
	TAILQ_INSERT_TAIL(open_sessions, s, link);
 11142e4:	f9000073 	str	x19, [x3]
	TAILQ_FOREACH(ctx, &tee_ctxes, link) {
 11142e8:	f0000220 	adrp	x0, 115b000 <__vcore_unpg_rw_start>
	TAILQ_INSERT_TAIL(open_sessions, s, link);
 11142ec:	f9000693 	str	x19, [x20, #8]
	TAILQ_FOREACH(ctx, &tee_ctxes, link) {
 11142f0:	f9003fe0 	str	x0, [sp, #120]
 11142f4:	f9403fe0 	ldr	x0, [sp, #120]
 11142f8:	f943e81b 	ldr	x27, [x0, #2000]
 11142fc:	b500065b 	cbnz	x27, 11143c4 <tee_ta_open_session+0x1ac>
			return TEE_ERROR_ITEM_NOT_FOUND;
 1114300:	129ffefa 	mov	w26, #0xffff0008            	// #-65528
	mutex_unlock(&tee_ta_mutex);
 1114304:	910422a0 	add	x0, x21, #0x108
 1114308:	94000472 	bl	11154d0 <mutex_unlock>
	if (res == TEE_SUCCESS || res != TEE_ERROR_ITEM_NOT_FOUND)
 111430c:	129ffefb 	mov	w27, #0xffff0008            	// #-65528
 1114310:	6b1b035f 	cmp	w26, w27
 1114314:	54000161 	b.ne	1114340 <tee_ta_open_session+0x128>  // b.any
	res = tee_ta_init_pseudo_ta_session(uuid, s);
 1114318:	aa1303e1 	mov	x1, x19
 111431c:	aa1703e0 	mov	x0, x23
 1114320:	94000d3c 	bl	1117810 <tee_ta_init_pseudo_ta_session>
 1114324:	2a0003fa 	mov	w26, w0
	if (res == TEE_SUCCESS || res != TEE_ERROR_ITEM_NOT_FOUND)
 1114328:	6b1b001f 	cmp	w0, w27
 111432c:	540000a1 	b.ne	1114340 <tee_ta_open_session+0x128>  // b.any
	res = tee_ta_init_user_ta_session(uuid, s);
 1114330:	aa1303e1 	mov	x1, x19
 1114334:	aa1703e0 	mov	x0, x23
 1114338:	940008b1 	bl	11165fc <tee_ta_init_user_ta_session>
 111433c:	2a0003fa 	mov	w26, w0
	if (!res) {
 1114340:	350006da 	cbnz	w26, 1114418 <tee_ta_open_session+0x200>
	ts_ctx = s->ts_sess.ctx;
 1114344:	f9401277 	ldr	x23, [x19, #32]
	if (ts_ctx)
 1114348:	b50009f7 	cbnz	x23, 1114484 <tee_ta_open_session+0x26c>
		DMSG("panicked, call tee_ta_close_session()");
 111434c:	90000204 	adrp	x4, 1154000 <__func__.1786+0x8>
 1114350:	911a9884 	add	x4, x4, #0x6a6
 1114354:	52800023 	mov	w3, #0x1                   	// #1
 1114358:	52800062 	mov	w2, #0x3                   	// #3
 111435c:	52805b41 	mov	w1, #0x2da                 	// #730
 1114360:	90000200 	adrp	x0, 1154000 <__func__.1786+0x8>
 1114364:	91221800 	add	x0, x0, #0x886
 1114368:	9400c277 	bl	1144d44 <trace_printf>
		tee_ta_close_session(s, open_sessions, KERN_IDENTITY);
 111436c:	aa1403e1 	mov	x1, x20
 1114370:	aa1303e0 	mov	x0, x19
 1114374:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
 1114378:	97ffff27 	bl	1114014 <tee_ta_close_session>
		*err = TEE_ORIGIN_TEE;
 111437c:	52800060 	mov	w0, #0x3                   	// #3
		return TEE_ERROR_TARGET_DEAD;
 1114380:	1299fb7a 	mov	w26, #0xffff3024            	// #-53212
		*err = TEE_ORIGIN_TEE;
 1114384:	b90002c0 	str	w0, [x22]
}
 1114388:	2a1a03e0 	mov	w0, w26
 111438c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1114390:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1114394:	a94363f7 	ldp	x23, x24, [sp, #48]
 1114398:	a9446bf9 	ldp	x25, x26, [sp, #64]
 111439c:	a94573fb 	ldp	x27, x28, [sp, #80]
 11143a0:	a8c87bfd 	ldp	x29, x30, [sp], #128
 11143a4:	d65f03c0 	ret
	uint32_t id = 1;
 11143a8:	2a1a03e1 	mov	w1, w26
 11143ac:	17ffffc3 	b	11142b8 <tee_ta_open_session+0xa0>
		if (s->id == id) {
 11143b0:	b9403846 	ldr	w6, [x2, #56]
 11143b4:	6b06001f 	cmp	w0, w6
 11143b8:	54001140 	b.eq	11145e0 <tee_ta_open_session+0x3c8>  // b.none
	TAILQ_FOREACH(s, open_sessions, link) {
 11143bc:	f9400042 	ldr	x2, [x2]
 11143c0:	17ffffc2 	b	11142c8 <tee_ta_open_session+0xb0>
		if (memcmp(&ctx->ts_ctx.uuid, uuid, sizeof(TEE_UUID)) == 0)
 11143c4:	91006378 	add	x24, x27, #0x18
 11143c8:	aa1703e1 	mov	x1, x23
 11143cc:	aa1803e0 	mov	x0, x24
 11143d0:	d2800202 	mov	x2, #0x10                  	// #16
 11143d4:	9400be1f 	bl	1143c50 <memcmp>
 11143d8:	34000ce0 	cbz	w0, 1114574 <tee_ta_open_session+0x35c>
	TAILQ_FOREACH(ctx, &tee_ctxes, link) {
 11143dc:	f940077b 	ldr	x27, [x27, #8]
 11143e0:	17ffffc7 	b	11142fc <tee_ta_open_session+0xe4>
 11143e4:	aa1803e0 	mov	x0, x24
 11143e8:	94000781 	bl	11161ec <is_user_ta_ctx>
 11143ec:	72001c1f 	tst	w0, #0xff
 11143f0:	54000041 	b.ne	11143f8 <tee_ta_open_session+0x1e0>  // b.any
 11143f4:	97fffe0b 	bl	1113c20 <to_user_ta_ctx.part.0>
		if (!is_user_ta_ctx(&ctx->ts_ctx) ||
 11143f8:	385e9360 	ldurb	w0, [x27, #-23]
 11143fc:	34000c40 	cbz	w0, 1114584 <tee_ta_open_session+0x36c>
		condvar_wait(&tee_ta_init_cv, &tee_ta_mutex);
 1114400:	aa1c03e1 	mov	x1, x28
 1114404:	aa1a03e0 	mov	x0, x26
 1114408:	94000570 	bl	11159c8 <condvar_wait>
		ctx = tee_ta_context_find(uuid);
 111440c:	17ffffba 	b	11142f4 <tee_ta_open_session+0xdc>
		return TEE_ERROR_BUSY;
 1114410:	129ffe5a 	mov	w26, #0xffff000d            	// #-65523
 1114414:	17ffffbc 	b	1114304 <tee_ta_open_session+0xec>
	mutex_lock(&tee_ta_mutex);
 1114418:	910422a0 	add	x0, x21, #0x108
 111441c:	9400044e 	bl	1115554 <mutex_lock>
	TAILQ_REMOVE(open_sessions, s, link);
 1114420:	a9400660 	ldp	x0, x1, [x19]
 1114424:	b4000240 	cbz	x0, 111446c <tee_ta_open_session+0x254>
 1114428:	f9000401 	str	x1, [x0, #8]
 111442c:	f9400661 	ldr	x1, [x19, #8]
 1114430:	f9000020 	str	x0, [x1]
	mutex_unlock(&tee_ta_mutex);
 1114434:	910422a0 	add	x0, x21, #0x108
 1114438:	94000426 	bl	11154d0 <mutex_unlock>
	free(s);
 111443c:	aa1303e0 	mov	x0, x19
 1114440:	9400bc68 	bl	11435e0 <free>
		DMSG("init session failed 0x%x", res);
 1114444:	90000204 	adrp	x4, 1154000 <__func__.1786+0x8>
 1114448:	2a1a03e5 	mov	w5, w26
 111444c:	911b3084 	add	x4, x4, #0x6cc
 1114450:	52800023 	mov	w3, #0x1                   	// #1
 1114454:	52800062 	mov	w2, #0x3                   	// #3
 1114458:	528059c1 	mov	w1, #0x2ce                 	// #718
		EMSG("Failed. Return error 0x%x", res);
 111445c:	90000200 	adrp	x0, 1154000 <__func__.1786+0x8>
 1114460:	91221800 	add	x0, x0, #0x886
 1114464:	9400c238 	bl	1144d44 <trace_printf>
 1114468:	17ffffc8 	b	1114388 <tee_ta_open_session+0x170>
	TAILQ_REMOVE(open_sessions, s, link);
 111446c:	f9000681 	str	x1, [x20, #8]
 1114470:	17ffffef 	b	111442c <tee_ta_open_session+0x214>
		res = TEE_ERROR_OVERFLOW;
 1114474:	1299fe1a 	mov	w26, #0xffff300f            	// #-53233
 1114478:	17ffffef 	b	1114434 <tee_ta_open_session+0x21c>
		return TEE_ERROR_OUT_OF_MEMORY;
 111447c:	129ffe7a 	mov	w26, #0xffff000c            	// #-65524
 1114480:	17fffff1 	b	1114444 <tee_ta_open_session+0x22c>
		ctx = ts_to_ta_ctx(ts_ctx);
 1114484:	aa1703e0 	mov	x0, x23
 1114488:	97fffec3 	bl	1113f94 <ts_to_ta_ctx>
 111448c:	aa0003f5 	mov	x21, x0
	if (!ctx || ctx->panicked) {
 1114490:	b4fff5e0 	cbz	x0, 111434c <tee_ta_open_session+0x134>
 1114494:	b9403000 	ldr	w0, [x0, #48]
 1114498:	35fff5a0 	cbnz	w0, 111434c <tee_ta_open_session+0x134>
	s->clnt_id = *clnt_id;
 111449c:	a94607e0 	ldp	x0, x1, [sp, #96]
	*sess = s;
 11144a0:	f9000013 	str	x19, [x0]
	s->clnt_id = *clnt_id;
 11144a4:	d2800282 	mov	x2, #0x14                  	// #20
 11144a8:	9100f260 	add	x0, x19, #0x3c
 11144ac:	97ffbbb9 	bl	1103390 <memcpy>
	if (ctx->flags & TA_FLAG_CONCURRENT)
 11144b0:	b94002a0 	ldr	w0, [x21]
 11144b4:	364004e0 	tbz	w0, #8, 1114550 <tee_ta_open_session+0x338>
		s->param = param;
 11144b8:	f9403be0 	ldr	x0, [sp, #112]
		set_invoke_timeout(s, cancel_req_to);
 11144bc:	2a1903e1 	mov	w1, w25
		s->param = param;
 11144c0:	f9002a60 	str	x0, [x19, #80]
		set_invoke_timeout(s, cancel_req_to);
 11144c4:	aa1303e0 	mov	x0, x19
 11144c8:	97fffc91 	bl	111370c <set_invoke_timeout>
		res = ts_ctx->ops->enter_open_session(&s->ts_sess);
 11144cc:	f9400ae0 	ldr	x0, [x23, #16]
	bool was_busy = false;
 11144d0:	52800017 	mov	w23, #0x0                   	// #0
		res = ts_ctx->ops->enter_open_session(&s->ts_sess);
 11144d4:	f9400001 	ldr	x1, [x0]
 11144d8:	91004260 	add	x0, x19, #0x10
 11144dc:	d63f0020 	blr	x1
 11144e0:	2a0003fa 	mov	w26, w0
		tee_ta_clear_busy(ctx);
 11144e4:	aa1503e0 	mov	x0, x21
 11144e8:	97fffcfa 	bl	11138d0 <tee_ta_clear_busy>
	panicked = ctx->panicked;
 11144ec:	b94032b5 	ldr	w21, [x21, #48]
	tee_ta_put_session(s);
 11144f0:	aa1303e0 	mov	x0, x19
	s->param = NULL;
 11144f4:	f9002a7f 	str	xzr, [x19, #80]
	panicked = ctx->panicked;
 11144f8:	710002bf 	cmp	w21, #0x0
	if (panicked || (res != TEE_SUCCESS))
 11144fc:	2a1a02b5 	orr	w21, w21, w26
	panicked = ctx->panicked;
 1114500:	1a9f07f8 	cset	w24, ne  // ne = any
	tee_ta_put_session(s);
 1114504:	97fffde3 	bl	1113c90 <tee_ta_put_session>
	if (panicked || (res != TEE_SUCCESS))
 1114508:	340000b5 	cbz	w21, 111451c <tee_ta_open_session+0x304>
		tee_ta_close_session(s, open_sessions, KERN_IDENTITY);
 111450c:	aa1403e1 	mov	x1, x20
 1114510:	aa1303e0 	mov	x0, x19
 1114514:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
 1114518:	97fffebf 	bl	1114014 <tee_ta_close_session>
	if (panicked || was_busy)
 111451c:	710002ff 	cmp	w23, #0x0
 1114520:	7a400b00 	ccmp	w24, #0x0, #0x0, eq  // eq = none
 1114524:	54000241 	b.ne	111456c <tee_ta_open_session+0x354>  // b.any
		*err = s->err_origin;
 1114528:	b9405a60 	ldr	w0, [x19, #88]
 111452c:	b90002c0 	str	w0, [x22]
	if (res != TEE_SUCCESS)
 1114530:	34fff2da 	cbz	w26, 1114388 <tee_ta_open_session+0x170>
		EMSG("Failed. Return error 0x%x", res);
 1114534:	90000204 	adrp	x4, 1154000 <__func__.1786+0x8>
 1114538:	2a1a03e5 	mov	w5, w26
 111453c:	911b9484 	add	x4, x4, #0x6e5
 1114540:	52800023 	mov	w3, #0x1                   	// #1
 1114544:	52800022 	mov	w2, #0x1                   	// #1
 1114548:	52806001 	mov	w1, #0x300                 	// #768
 111454c:	17ffffc4 	b	111445c <tee_ta_open_session+0x244>
 1114550:	aa1503e0 	mov	x0, x21
 1114554:	97fffd00 	bl	1113954 <tee_ta_try_set_busy.part.0>
	if (tee_ta_try_set_busy(ctx)) {
 1114558:	72001c1f 	tst	w0, #0xff
 111455c:	54fffae1 	b.ne	11144b8 <tee_ta_open_session+0x2a0>  // b.any
		was_busy = true;
 1114560:	52800037 	mov	w23, #0x1                   	// #1
		res = TEE_ERROR_BUSY;
 1114564:	129ffe5a 	mov	w26, #0xffff000d            	// #-65523
 1114568:	17ffffe1 	b	11144ec <tee_ta_open_session+0x2d4>
		*err = TEE_ORIGIN_TEE;
 111456c:	52800060 	mov	w0, #0x3                   	// #3
 1114570:	17ffffef 	b	111452c <tee_ta_open_session+0x314>
		if (!is_user_ta_ctx(&ctx->ts_ctx) ||
 1114574:	aa1803e0 	mov	x0, x24
 1114578:	9400071d 	bl	11161ec <is_user_ta_ctx>
 111457c:	72001c1f 	tst	w0, #0xff
 1114580:	54fff321 	b.ne	11143e4 <tee_ta_open_session+0x1cc>  // b.any
	if ((ctx->flags & TA_FLAG_SINGLE_INSTANCE) == 0)
 1114584:	b9400360 	ldr	w0, [x27]
 1114588:	3617ebc0 	tbz	w0, #2, 1114300 <tee_ta_open_session+0xe8>
	if (!(ctx->flags & TA_FLAG_MULTI_SESSION) && ctx->ref_count)
 111458c:	37180060 	tbnz	w0, #3, 1114598 <tee_ta_open_session+0x380>
 1114590:	b9403b60 	ldr	w0, [x27, #56]
 1114594:	35fff3e0 	cbnz	w0, 1114410 <tee_ta_open_session+0x1f8>
	DMSG("Re-open TA %pUl", (void *)&ctx->ts_ctx.uuid);
 1114598:	aa1803e5 	mov	x5, x24
 111459c:	90000204 	adrp	x4, 1154000 <__func__.1786+0x8>
 11145a0:	52800023 	mov	w3, #0x1                   	// #1
 11145a4:	911a5884 	add	x4, x4, #0x696
 11145a8:	52800062 	mov	w2, #0x3                   	// #3
 11145ac:	52804be1 	mov	w1, #0x25f                 	// #607
 11145b0:	90000200 	adrp	x0, 1154000 <__func__.1786+0x8>
 11145b4:	91219400 	add	x0, x0, #0x865
 11145b8:	9400c1e3 	bl	1144d44 <trace_printf>
	return TEE_SUCCESS;
 11145bc:	5280001a 	mov	w26, #0x0                   	// #0
	ctx->ref_count++;
 11145c0:	b9403b60 	ldr	w0, [x27, #56]
 11145c4:	11000400 	add	w0, w0, #0x1
 11145c8:	b9003b60 	str	w0, [x27, #56]
	s->ts_sess.handle_svc = s->ts_sess.ctx->ops->handle_svc;
 11145cc:	f9400b00 	ldr	x0, [x24, #16]
 11145d0:	f9401c00 	ldr	x0, [x0, #56]
	s->ts_sess.ctx = &ctx->ts_ctx;
 11145d4:	f9001278 	str	x24, [x19, #32]
	s->ts_sess.handle_svc = s->ts_sess.ctx->ops->handle_svc;
 11145d8:	f9001a60 	str	x0, [x19, #48]
	return TEE_SUCCESS;
 11145dc:	17ffff4a 	b	1114304 <tee_ta_open_session+0xec>
		if (!id)
 11145e0:	31000400 	adds	w0, w0, #0x1
 11145e4:	1a841000 	csel	w0, w0, w4, ne  // ne = any
	} while (id != saved);
 11145e8:	6b01001f 	cmp	w0, w1
 11145ec:	54ffe6c1 	b.ne	11142c4 <tee_ta_open_session+0xac>  // b.any
	return 0;
 11145f0:	52800000 	mov	w0, #0x0                   	// #0
 11145f4:	17ffff36 	b	11142cc <tee_ta_open_session+0xb4>

00000000011145f8 <destroy_ta_ctx_from_session>:
{
 11145f8:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
	DMSG("Remove references to context (%#"PRIxVA")", (vaddr_t)ts_ctx);
 11145fc:	90000204 	adrp	x4, 1154000 <__func__.1786+0x8>
 1114600:	911bfc84 	add	x4, x4, #0x6ff
{
 1114604:	910003fd 	mov	x29, sp
 1114608:	a9046bf9 	stp	x25, x26, [sp, #64]
	DMSG("Remove references to context (%#"PRIxVA")", (vaddr_t)ts_ctx);
 111460c:	52802881 	mov	w1, #0x144                 	// #324
 1114610:	52800023 	mov	w3, #0x1                   	// #1
	struct ts_ctx *ts_ctx = s->ts_sess.ctx;
 1114614:	f9401019 	ldr	x25, [x0, #32]
	DMSG("Remove references to context (%#"PRIxVA")", (vaddr_t)ts_ctx);
 1114618:	52800062 	mov	w2, #0x3                   	// #3
{
 111461c:	a90153f3 	stp	x19, x20, [sp, #16]
 1114620:	aa0003f4 	mov	x20, x0
	DMSG("Remove references to context (%#"PRIxVA")", (vaddr_t)ts_ctx);
 1114624:	aa1903e5 	mov	x5, x25
{
 1114628:	a9025bf5 	stp	x21, x22, [sp, #32]
	size_t count = 1; /* start counting the references to the context */
 111462c:	d2800036 	mov	x22, #0x1                   	// #1
{
 1114630:	a90363f7 	stp	x23, x24, [sp, #48]
	DMSG("Remove references to context (%#"PRIxVA")", (vaddr_t)ts_ctx);
 1114634:	90000218 	adrp	x24, 1154000 <__func__.1786+0x8>
 1114638:	91209f00 	add	x0, x24, #0x827
	struct tee_ta_session_head *open_sessions = NULL;
 111463c:	f9002fff 	str	xzr, [sp, #88]
	DMSG("Remove references to context (%#"PRIxVA")", (vaddr_t)ts_ctx);
 1114640:	9400c1c1 	bl	1144d44 <trace_printf>
	mutex_lock(&tee_ta_mutex);
 1114644:	d0000257 	adrp	x23, 115e000 <state+0x80>
 1114648:	910422e0 	add	x0, x23, #0x108
 111464c:	940003c2 	bl	1115554 <mutex_lock>
	nsec_sessions_list_head(&open_sessions);
 1114650:	910163e0 	add	x0, sp, #0x58
 1114654:	94001b43 	bl	111b360 <nsec_sessions_list_head>
	TAILQ_FOREACH(sess, open_sessions, link) {
 1114658:	f9402fe0 	ldr	x0, [sp, #88]
 111465c:	f9400001 	ldr	x1, [x0]
 1114660:	b5000241 	cbnz	x1, 11146a8 <destroy_ta_ctx_from_session+0xb0>
	TAILQ_FOREACH(ctx, &tee_ctxes, link) {
 1114664:	f0000235 	adrp	x21, 115b000 <__vcore_unpg_rw_start>
 1114668:	f943eab3 	ldr	x19, [x21, #2000]
 111466c:	b5000313 	cbnz	x19, 11146cc <destroy_ta_ctx_from_session+0xd4>
	ctx = ts_to_ta_ctx(ts_ctx);
 1114670:	aa1903e0 	mov	x0, x25
 1114674:	97fffe48 	bl	1113f94 <ts_to_ta_ctx>
 1114678:	aa0003f3 	mov	x19, x0
	assert(count == ctx->ref_count);
 111467c:	b9403800 	ldr	w0, [x0, #56]
 1114680:	eb16001f 	cmp	x0, x22
 1114684:	54000540 	b.eq	111472c <destroy_ta_ctx_from_session+0x134>  // b.none
 1114688:	91209f03 	add	x3, x24, #0x827
 111468c:	90000201 	adrp	x1, 1154000 <__func__.1786+0x8>
 1114690:	90000200 	adrp	x0, 1154000 <__func__.1786+0x8>
 1114694:	91127021 	add	x1, x1, #0x49c
 1114698:	911c8c00 	add	x0, x0, #0x723
 111469c:	52802de2 	mov	w2, #0x16f                 	// #367
 11146a0:	97fff703 	bl	11122ac <_assert_log>
 11146a4:	97fff713 	bl	11122f0 <_assert_break>
		if (sess->ts_sess.ctx == ts_ctx && sess != s) {
 11146a8:	f9401020 	ldr	x0, [x1, #32]
 11146ac:	eb19001f 	cmp	x0, x25
 11146b0:	540000a1 	b.ne	11146c4 <destroy_ta_ctx_from_session+0xcc>  // b.any
 11146b4:	eb14003f 	cmp	x1, x20
 11146b8:	54000060 	b.eq	11146c4 <destroy_ta_ctx_from_session+0xcc>  // b.none
			count++;
 11146bc:	910006d6 	add	x22, x22, #0x1
			sess->ts_sess.ctx = NULL;
 11146c0:	f900103f 	str	xzr, [x1, #32]
	TAILQ_FOREACH(sess, open_sessions, link) {
 11146c4:	f9400021 	ldr	x1, [x1]
 11146c8:	17ffffe6 	b	1114660 <destroy_ta_ctx_from_session+0x68>
		if (is_user_ta_ctx(&ctx->ts_ctx)) {
 11146cc:	9100627a 	add	x26, x19, #0x18
 11146d0:	aa1a03e0 	mov	x0, x26
 11146d4:	940006c6 	bl	11161ec <is_user_ta_ctx>
 11146d8:	72001c1f 	tst	w0, #0xff
 11146dc:	54000120 	b.eq	1114700 <destroy_ta_ctx_from_session+0x108>  // b.none
 11146e0:	aa1a03e0 	mov	x0, x26
 11146e4:	940006c2 	bl	11161ec <is_user_ta_ctx>
 11146e8:	72001c1f 	tst	w0, #0xff
 11146ec:	54000041 	b.ne	11146f4 <destroy_ta_ctx_from_session+0xfc>  // b.any
 11146f0:	97fffd4c 	bl	1113c20 <to_user_ta_ctx.part.0>
			TAILQ_FOREACH(sess, &utc->open_sessions, link) {
 11146f4:	d10fa260 	sub	x0, x19, #0x3e8
 11146f8:	f9408c00 	ldr	x0, [x0, #280]
 11146fc:	b5000060 	cbnz	x0, 1114708 <destroy_ta_ctx_from_session+0x110>
	TAILQ_FOREACH(ctx, &tee_ctxes, link) {
 1114700:	f9400673 	ldr	x19, [x19, #8]
 1114704:	17ffffda 	b	111466c <destroy_ta_ctx_from_session+0x74>
				if (sess->ts_sess.ctx == ts_ctx &&
 1114708:	f9401001 	ldr	x1, [x0, #32]
 111470c:	eb19003f 	cmp	x1, x25
 1114710:	540000a1 	b.ne	1114724 <destroy_ta_ctx_from_session+0x12c>  // b.any
 1114714:	eb14001f 	cmp	x0, x20
 1114718:	54000060 	b.eq	1114724 <destroy_ta_ctx_from_session+0x12c>  // b.none
					count++;
 111471c:	910006d6 	add	x22, x22, #0x1
					sess->ts_sess.ctx = NULL;
 1114720:	f900101f 	str	xzr, [x0, #32]
			TAILQ_FOREACH(sess, &utc->open_sessions, link) {
 1114724:	f9400000 	ldr	x0, [x0]
 1114728:	17fffff5 	b	11146fc <destroy_ta_ctx_from_session+0x104>
	TAILQ_REMOVE(&tee_ctxes, ctx, link);
 111472c:	a9408660 	ldp	x0, x1, [x19, #8]
 1114730:	b40001e0 	cbz	x0, 111476c <destroy_ta_ctx_from_session+0x174>
 1114734:	f9000801 	str	x1, [x0, #16]
 1114738:	f9400a61 	ldr	x1, [x19, #16]
 111473c:	f9000020 	str	x0, [x1]
	mutex_unlock(&tee_ta_mutex);
 1114740:	910422e0 	add	x0, x23, #0x108
 1114744:	94000363 	bl	11154d0 <mutex_unlock>
	destroy_context(ctx);
 1114748:	aa1303e0 	mov	x0, x19
 111474c:	97fffc11 	bl	1113790 <destroy_context>
}
 1114750:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1114754:	a94363f7 	ldp	x23, x24, [sp, #48]
 1114758:	a9446bf9 	ldp	x25, x26, [sp, #64]
	s->ts_sess.ctx = NULL;
 111475c:	f900129f 	str	xzr, [x20, #32]
}
 1114760:	a94153f3 	ldp	x19, x20, [sp, #16]
 1114764:	a8c67bfd 	ldp	x29, x30, [sp], #96
 1114768:	d65f03c0 	ret
	TAILQ_REMOVE(&tee_ctxes, ctx, link);
 111476c:	911f42b5 	add	x21, x21, #0x7d0
 1114770:	f90006a1 	str	x1, [x21, #8]
 1114774:	17fffff1 	b	1114738 <destroy_ta_ctx_from_session+0x140>

0000000001114778 <tee_ta_invoke_command>:
{
 1114778:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 111477c:	910003fd 	mov	x29, sp
 1114780:	a90153f3 	stp	x19, x20, [sp, #16]
 1114784:	aa0103f3 	mov	x19, x1
 1114788:	2a0403f4 	mov	w20, w4
 111478c:	aa0203e1 	mov	x1, x2
 1114790:	a9025bf5 	stp	x21, x22, [sp, #32]
 1114794:	aa0003f5 	mov	x21, x0
	if (check_client(sess, clnt_id) != TEE_SUCCESS)
 1114798:	aa1303e0 	mov	x0, x19
{
 111479c:	a90363f7 	stp	x23, x24, [sp, #48]
 11147a0:	2a0303f8 	mov	w24, w3
 11147a4:	f90023f9 	str	x25, [sp, #64]
 11147a8:	aa0503f9 	mov	x25, x5
	if (check_client(sess, clnt_id) != TEE_SUCCESS)
 11147ac:	97fffcb5 	bl	1113a80 <check_client>
 11147b0:	350007a0 	cbnz	w0, 11148a4 <tee_ta_invoke_command+0x12c>
	ts_ctx = sess->ts_sess.ctx;
 11147b4:	f9401277 	ldr	x23, [x19, #32]
	if (!ts_ctx) {
 11147b8:	b5000177 	cbnz	x23, 11147e4 <tee_ta_invoke_command+0x6c>
		*err = TEE_ORIGIN_TEE;
 11147bc:	52800060 	mov	w0, #0x3                   	// #3
		return TEE_ERROR_TARGET_DEAD;
 11147c0:	1299fb74 	mov	w20, #0xffff3024            	// #-53212
		*err = TEE_ORIGIN_TEE;
 11147c4:	b90002a0 	str	w0, [x21]
}
 11147c8:	2a1403e0 	mov	w0, w20
 11147cc:	a94153f3 	ldp	x19, x20, [sp, #16]
 11147d0:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11147d4:	a94363f7 	ldp	x23, x24, [sp, #48]
 11147d8:	f94023f9 	ldr	x25, [sp, #64]
 11147dc:	a8c57bfd 	ldp	x29, x30, [sp], #80
 11147e0:	d65f03c0 	ret
	ta_ctx = ts_to_ta_ctx(ts_ctx);
 11147e4:	aa1703e0 	mov	x0, x23
 11147e8:	97fffdeb 	bl	1113f94 <ts_to_ta_ctx>
	if (ta_ctx->panicked) {
 11147ec:	b9403001 	ldr	w1, [x0, #48]
	ta_ctx = ts_to_ta_ctx(ts_ctx);
 11147f0:	aa0003f6 	mov	x22, x0
	if (ta_ctx->panicked) {
 11147f4:	34000181 	cbz	w1, 1114824 <tee_ta_invoke_command+0xac>
		DMSG("Panicked !");
 11147f8:	90000204 	adrp	x4, 1154000 <__func__.1786+0x8>
 11147fc:	90000200 	adrp	x0, 1154000 <__func__.1786+0x8>
 1114800:	911cec84 	add	x4, x4, #0x73b
 1114804:	91226800 	add	x0, x0, #0x89a
 1114808:	52800023 	mov	w3, #0x1                   	// #1
 111480c:	52800062 	mov	w2, #0x3                   	// #3
 1114810:	528063c1 	mov	w1, #0x31e                 	// #798
 1114814:	9400c14c 	bl	1144d44 <trace_printf>
		destroy_ta_ctx_from_session(sess);
 1114818:	aa1303e0 	mov	x0, x19
 111481c:	97ffff77 	bl	11145f8 <destroy_ta_ctx_from_session>
 1114820:	17ffffe7 	b	11147bc <tee_ta_invoke_command+0x44>
	tee_ta_set_busy(ta_ctx);
 1114824:	97fffd0a 	bl	1113c4c <tee_ta_set_busy>
	sess->param = param;
 1114828:	f9002a79 	str	x25, [x19, #80]
	set_invoke_timeout(sess, cancel_req_to);
 111482c:	2a1803e1 	mov	w1, w24
 1114830:	aa1303e0 	mov	x0, x19
 1114834:	97fffbb6 	bl	111370c <set_invoke_timeout>
	res = ts_ctx->ops->enter_invoke_cmd(&sess->ts_sess, cmd);
 1114838:	f9400ae0 	ldr	x0, [x23, #16]
 111483c:	2a1403e1 	mov	w1, w20
 1114840:	f9400402 	ldr	x2, [x0, #8]
 1114844:	91004260 	add	x0, x19, #0x10
 1114848:	d63f0040 	blr	x2
	sess->param = NULL;
 111484c:	f9002a7f 	str	xzr, [x19, #80]
	res = ts_ctx->ops->enter_invoke_cmd(&sess->ts_sess, cmd);
 1114850:	2a0003f4 	mov	w20, w0
	tee_ta_clear_busy(ta_ctx);
 1114854:	aa1603e0 	mov	x0, x22
 1114858:	97fffc1e 	bl	11138d0 <tee_ta_clear_busy>
	if (ta_ctx->panicked) {
 111485c:	b94032c0 	ldr	w0, [x22, #48]
 1114860:	35fffdc0 	cbnz	w0, 1114818 <tee_ta_invoke_command+0xa0>
	*err = sess->err_origin;
 1114864:	b9405a66 	ldr	w6, [x19, #88]
	if (res != TEE_SUCCESS && res != TEE_ERROR_SHORT_BUFFER)
 1114868:	7100029f 	cmp	w20, #0x0
	*err = sess->err_origin;
 111486c:	b90002a6 	str	w6, [x21]
	if (res != TEE_SUCCESS && res != TEE_ERROR_SHORT_BUFFER)
 1114870:	129ffde0 	mov	w0, #0xffff0010            	// #-65520
 1114874:	7a401284 	ccmp	w20, w0, #0x4, ne  // ne = any
 1114878:	54fffa80 	b.eq	11147c8 <tee_ta_invoke_command+0x50>  // b.none
		DMSG("Error: %x of %d", res, *err);
 111487c:	2a1403e5 	mov	w5, w20
 1114880:	90000204 	adrp	x4, 1154000 <__func__.1786+0x8>
 1114884:	52800023 	mov	w3, #0x1                   	// #1
 1114888:	911d1884 	add	x4, x4, #0x746
 111488c:	52800062 	mov	w2, #0x3                   	// #3
 1114890:	528066e1 	mov	w1, #0x337                 	// #823
 1114894:	90000200 	adrp	x0, 1154000 <__func__.1786+0x8>
 1114898:	91226800 	add	x0, x0, #0x89a
 111489c:	9400c12a 	bl	1144d44 <trace_printf>
 11148a0:	17ffffca 	b	11147c8 <tee_ta_invoke_command+0x50>
		return TEE_ERROR_BAD_PARAMETERS; /* intentional generic error */
 11148a4:	129fff34 	mov	w20, #0xffff0006            	// #-65530
 11148a8:	17ffffc8 	b	11147c8 <tee_ta_invoke_command+0x50>

00000000011148ac <update_current_ctx>:
#include <kernel/user_mode_ctx.h>
#include <mm/core_mmu.h>
#include <mm/vm.h>

static void update_current_ctx(struct thread_specific_data *tsd)
{
 11148ac:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 11148b0:	910003fd 	mov	x29, sp
 11148b4:	a90153f3 	stp	x19, x20, [sp, #16]
 11148b8:	aa0003f4 	mov	x20, x0
	struct ts_ctx *ctx = NULL;
	struct ts_session *s = TAILQ_FIRST(&tsd->sess_stack);
 11148bc:	f9400013 	ldr	x19, [x0]

	if (s) {
 11148c0:	b50002b3 	cbnz	x19, 1114914 <update_current_ctx+0x68>
	struct ts_ctx *ctx = NULL;
 11148c4:	d2800013 	mov	x19, #0x0                   	// #0

		if (s)
			ctx = s->ctx;
	}

	if (tsd->ctx != ctx)
 11148c8:	f9400a80 	ldr	x0, [x20, #16]
 11148cc:	eb13001f 	cmp	x0, x19
 11148d0:	54000060 	b.eq	11148dc <update_current_ctx+0x30>  // b.none
		vm_set_ctx(ctx);
 11148d4:	aa1303e0 	mov	x0, x19
 11148d8:	94001401 	bl	11198dc <vm_set_ctx>
	return is_user_ta_ctx(ctx) || is_stmm_ctx(ctx) || is_sp_ctx(ctx);
 11148dc:	aa1303e0 	mov	x0, x19
 11148e0:	94000643 	bl	11161ec <is_user_ta_ctx>
 11148e4:	12001c13 	and	w19, w0, #0xff
	/*
	 * If current context is of user mode, then it has to be active too.
	 */
	if (is_user_mode_ctx(ctx) != core_mmu_user_mapping_is_active())
 11148e8:	97ffda40 	bl	110b1e8 <core_mmu_user_mapping_is_active>
 11148ec:	6b20027f 	cmp	w19, w0, uxtb
 11148f0:	54000220 	b.eq	1114934 <update_current_ctx+0x88>  // b.none
		panic("unexpected active mapping");
 11148f4:	90000203 	adrp	x3, 1154000 <__func__.1786+0x8>
 11148f8:	90000202 	adrp	x2, 1154000 <__func__.1786+0x8>
 11148fc:	90000200 	adrp	x0, 1154000 <__func__.1786+0x8>
 1114900:	9122c063 	add	x3, x3, #0x8b0
 1114904:	91238c42 	add	x2, x2, #0x8e3
 1114908:	91232800 	add	x0, x0, #0x8ca
 111490c:	52800461 	mov	w1, #0x23                  	// #35
 1114910:	97fffad6 	bl	1113468 <__do_panic>
		if (is_pseudo_ta_ctx(s->ctx))
 1114914:	f9400a60 	ldr	x0, [x19, #16]
 1114918:	94000bb8 	bl	11177f8 <is_pseudo_ta_ctx>
 111491c:	72001c1f 	tst	w0, #0xff
 1114920:	54000060 	b.eq	111492c <update_current_ctx+0x80>  // b.none
			s = TAILQ_NEXT(s, link_tsd);
 1114924:	f9400273 	ldr	x19, [x19]
		if (s)
 1114928:	b4fffcf3 	cbz	x19, 11148c4 <update_current_ctx+0x18>
			ctx = s->ctx;
 111492c:	f9400a73 	ldr	x19, [x19, #16]
 1114930:	17ffffe6 	b	11148c8 <update_current_ctx+0x1c>
}
 1114934:	a94153f3 	ldp	x19, x20, [sp, #16]
 1114938:	a8c27bfd 	ldp	x29, x30, [sp], #32
 111493c:	d65f03c0 	ret

0000000001114940 <ts_push_current_session>:

void ts_push_current_session(struct ts_session *s)
{
 1114940:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1114944:	910003fd 	mov	x29, sp
 1114948:	f9000bf3 	str	x19, [sp, #16]
 111494c:	aa0003f3 	mov	x19, x0
	struct thread_specific_data *tsd = thread_get_tsd();
 1114950:	97ffc49c 	bl	1105bc0 <thread_get_tsd>

	TAILQ_INSERT_HEAD(&tsd->sess_stack, s, link_tsd);
 1114954:	f9400001 	ldr	x1, [x0]
 1114958:	f9000261 	str	x1, [x19]
 111495c:	b40000e1 	cbz	x1, 1114978 <ts_push_current_session+0x38>
 1114960:	f9000433 	str	x19, [x1, #8]
 1114964:	f9000013 	str	x19, [x0]
 1114968:	f9000660 	str	x0, [x19, #8]
	update_current_ctx(tsd);
}
 111496c:	f9400bf3 	ldr	x19, [sp, #16]
 1114970:	a8c27bfd 	ldp	x29, x30, [sp], #32
	update_current_ctx(tsd);
 1114974:	17ffffce 	b	11148ac <update_current_ctx>
	TAILQ_INSERT_HEAD(&tsd->sess_stack, s, link_tsd);
 1114978:	f9000413 	str	x19, [x0, #8]
 111497c:	17fffffa 	b	1114964 <ts_push_current_session+0x24>

0000000001114980 <ts_pop_current_session>:

struct ts_session *ts_pop_current_session(void)
{
 1114980:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1114984:	910003fd 	mov	x29, sp
 1114988:	f9000bf3 	str	x19, [sp, #16]
	struct thread_specific_data *tsd = thread_get_tsd();
 111498c:	97ffc48d 	bl	1105bc0 <thread_get_tsd>
	struct ts_session *s = TAILQ_FIRST(&tsd->sess_stack);
 1114990:	f9400013 	ldr	x19, [x0]

	if (s) {
 1114994:	b40000f3 	cbz	x19, 11149b0 <ts_pop_current_session+0x30>
		TAILQ_REMOVE(&tsd->sess_stack, s, link_tsd);
 1114998:	a9400a61 	ldp	x1, x2, [x19]
 111499c:	b4000121 	cbz	x1, 11149c0 <ts_pop_current_session+0x40>
 11149a0:	f9000422 	str	x2, [x1, #8]
 11149a4:	f9400662 	ldr	x2, [x19, #8]
 11149a8:	f9000041 	str	x1, [x2]
		update_current_ctx(tsd);
 11149ac:	97ffffc0 	bl	11148ac <update_current_ctx>
	}
	return s;
}
 11149b0:	aa1303e0 	mov	x0, x19
 11149b4:	f9400bf3 	ldr	x19, [sp, #16]
 11149b8:	a8c27bfd 	ldp	x29, x30, [sp], #32
 11149bc:	d65f03c0 	ret
		TAILQ_REMOVE(&tsd->sess_stack, s, link_tsd);
 11149c0:	f9000402 	str	x2, [x0, #8]
 11149c4:	17fffff8 	b	11149a4 <ts_pop_current_session+0x24>

00000000011149c8 <ts_get_current_session_may_fail>:
		s = TAILQ_NEXT(s, link_tsd);
	return s;
}

struct ts_session *ts_get_current_session_may_fail(void)
{
 11149c8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 11149cc:	910003fd 	mov	x29, sp
	return TAILQ_FIRST(&thread_get_tsd()->sess_stack);
 11149d0:	97ffc47c 	bl	1105bc0 <thread_get_tsd>
}
 11149d4:	a8c17bfd 	ldp	x29, x30, [sp], #16
 11149d8:	f9400000 	ldr	x0, [x0]
 11149dc:	d65f03c0 	ret

00000000011149e0 <ts_get_current_session>:

struct ts_session *ts_get_current_session(void)
{
 11149e0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 11149e4:	910003fd 	mov	x29, sp
	struct ts_session *s = ts_get_current_session_may_fail();
 11149e8:	97fffff8 	bl	11149c8 <ts_get_current_session_may_fail>

	if (!s)
 11149ec:	b5000100 	cbnz	x0, 1114a0c <ts_get_current_session+0x2c>
		panic();
 11149f0:	90000202 	adrp	x2, 1154000 <__func__.1786+0x8>
 11149f4:	90000200 	adrp	x0, 1154000 <__func__.1786+0x8>
 11149f8:	9123d842 	add	x2, x2, #0x8f6
 11149fc:	91232800 	add	x0, x0, #0x8ca
 1114a00:	d2800003 	mov	x3, #0x0                   	// #0
 1114a04:	528009a1 	mov	w1, #0x4d                  	// #77
 1114a08:	97fffa98 	bl	1113468 <__do_panic>
	return s;
}
 1114a0c:	a8c17bfd 	ldp	x29, x30, [sp], #16
 1114a10:	d65f03c0 	ret

0000000001114a14 <ts_get_calling_session>:
{
 1114a14:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 1114a18:	910003fd 	mov	x29, sp
	struct ts_session *s = ts_get_current_session();
 1114a1c:	97fffff1 	bl	11149e0 <ts_get_current_session>
	if (s)
 1114a20:	b4000040 	cbz	x0, 1114a28 <ts_get_calling_session+0x14>
		s = TAILQ_NEXT(s, link_tsd);
 1114a24:	f9400000 	ldr	x0, [x0]
}
 1114a28:	a8c17bfd 	ldp	x29, x30, [sp], #16
 1114a2c:	d65f03c0 	ret

0000000001114a30 <scattered_array_relax_ptr>:
#include <scattered_array.h>

const void *scattered_array_relax_ptr(const void *p)
{
	return p;
}
 1114a30:	d65f03c0 	ret

0000000001114a34 <huk_subkey_derive>:
#endif /*CFG_CORE_HUK_SUBKEY_COMPAT*/

TEE_Result huk_subkey_derive(enum huk_subkey_usage usage,
			     const void *const_data, size_t const_data_len,
			     uint8_t *subkey, size_t subkey_len)
{
 1114a34:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
	void *ctx = NULL;
	struct tee_hw_unique_key huk = { };
	TEE_Result res = TEE_SUCCESS;

	if (subkey_len > HUK_SUBKEY_MAX_LEN)
 1114a38:	f100809f 	cmp	x4, #0x20
{
 1114a3c:	910003fd 	mov	x29, sp
 1114a40:	a90153f3 	stp	x19, x20, [sp, #16]
 1114a44:	a9025bf5 	stp	x21, x22, [sp, #32]
 1114a48:	a90363f7 	stp	x23, x24, [sp, #48]
 1114a4c:	a9046bf9 	stp	x25, x26, [sp, #64]
	void *ctx = NULL;
 1114a50:	f9002fff 	str	xzr, [sp, #88]
	struct tee_hw_unique_key huk = { };
 1114a54:	a9067fff 	stp	xzr, xzr, [sp, #96]
	if (subkey_len > HUK_SUBKEY_MAX_LEN)
 1114a58:	54000ac8 	b.hi	1114bb0 <huk_subkey_derive+0x17c>  // b.pmore
		return TEE_ERROR_BAD_PARAMETERS;
	if (!const_data && const_data_len)
 1114a5c:	f100003f 	cmp	x1, #0x0
 1114a60:	aa0103f7 	mov	x23, x1
 1114a64:	aa0203f8 	mov	x24, x2
 1114a68:	fa400844 	ccmp	x2, #0x0, #0x4, eq  // eq = none
 1114a6c:	54000a21 	b.ne	1114bb0 <huk_subkey_derive+0x17c>  // b.any
		return TEE_ERROR_BAD_PARAMETERS;

	res = crypto_mac_alloc_ctx(&ctx, TEE_ALG_HMAC_SHA256);
 1114a70:	52800081 	mov	w1, #0x4                   	// #4
 1114a74:	2a0003f9 	mov	w25, w0
 1114a78:	aa0303f5 	mov	x21, x3
 1114a7c:	aa0403f4 	mov	x20, x4
 1114a80:	910163e0 	add	x0, sp, #0x58
 1114a84:	72a60001 	movk	w1, #0x3000, lsl #16
 1114a88:	97ffe32f 	bl	110d744 <crypto_mac_alloc_ctx>
 1114a8c:	2a0003f3 	mov	w19, w0
	if (res)
 1114a90:	350006c0 	cbnz	w0, 1114b68 <huk_subkey_derive+0x134>
		return res;

	res = tee_otp_get_hw_unique_key(&huk);
 1114a94:	910183f6 	add	x22, sp, #0x60
 1114a98:	aa1603e0 	mov	x0, x22
 1114a9c:	97ffbdf5 	bl	1104270 <tee_otp_get_hw_unique_key>
 1114aa0:	2a0003f3 	mov	w19, w0
	if (res)
 1114aa4:	35000520 	cbnz	w0, 1114b48 <huk_subkey_derive+0x114>
		goto out;

	res = crypto_mac_init(ctx, huk.data, sizeof(huk.data));
 1114aa8:	f9402fe0 	ldr	x0, [sp, #88]
 1114aac:	aa1603e1 	mov	x1, x22
 1114ab0:	d2800202 	mov	x2, #0x10                  	// #16
 1114ab4:	97ffe39c 	bl	110d924 <crypto_mac_init>
 1114ab8:	2a0003f3 	mov	w19, w0
	if (res)
 1114abc:	35000460 	cbnz	w0, 1114b48 <huk_subkey_derive+0x114>
	uint8_t chip_id[TEE_FS_KM_CHIP_ID_LENGTH] = { 0 };
 1114ac0:	a9077fff 	stp	xzr, xzr, [sp, #112]
 1114ac4:	a9087fff 	stp	xzr, xzr, [sp, #128]
		goto out;

#ifdef CFG_CORE_HUK_SUBKEY_COMPAT
	res = huk_compat(ctx, usage);
 1114ac8:	f9402ffa 	ldr	x26, [sp, #88]
	switch (usage) {
 1114acc:	34000319 	cbz	w25, 1114b2c <huk_subkey_derive+0xf8>
 1114ad0:	7100073f 	cmp	w25, #0x1
 1114ad4:	54000581 	b.ne	1114b84 <huk_subkey_derive+0x150>  // b.any
		buffer[i] = pattern[i % 4];
 1114ad8:	90000200 	adrp	x0, 1154000 <__func__.1786+0x8>
 1114adc:	9101c3e1 	add	x1, sp, #0x70
 1114ae0:	91243400 	add	x0, x0, #0x90d
	switch (usage) {
 1114ae4:	d2800002 	mov	x2, #0x0                   	// #0
		buffer[i] = pattern[i % 4];
 1114ae8:	92400443 	and	x3, x2, #0x3
 1114aec:	38636803 	ldrb	w3, [x0, x3]
 1114af0:	38216843 	strb	w3, [x2, x1]
	for (i = 0; i < len; i++)
 1114af4:	91000442 	add	x2, x2, #0x1
 1114af8:	f100805f 	cmp	x2, #0x20
 1114afc:	54ffff61 	b.ne	1114ae8 <huk_subkey_derive+0xb4>  // b.any
		res = crypto_mac_update(ctx, chip_id, sizeof(chip_id));
 1114b00:	aa1a03e0 	mov	x0, x26
 1114b04:	97ffe399 	bl	110d968 <crypto_mac_update>
 1114b08:	2a0003f3 	mov	w19, w0
		if (res)
 1114b0c:	350001e0 	cbnz	w0, 1114b48 <huk_subkey_derive+0x114>
		return crypto_mac_update(ctx, ssk_str, sizeof(ssk_str));
 1114b10:	b0000241 	adrp	x1, 115d000 <_curve_names+0x590>
 1114b14:	912fa821 	add	x1, x1, #0xbea
 1114b18:	d2800282 	mov	x2, #0x14                  	// #20
	return crypto_mac_update(ctx, (const void *)&usage, sizeof(usage));
 1114b1c:	aa1a03e0 	mov	x0, x26
 1114b20:	97ffe392 	bl	110d968 <crypto_mac_update>
 1114b24:	2a0003f3 	mov	w19, w0
#else
	res = mac_usage(ctx, usage);
#endif
	if (res)
 1114b28:	35000100 	cbnz	w0, 1114b48 <huk_subkey_derive+0x114>
		goto out;

	if (const_data) {
 1114b2c:	b5000357 	cbnz	x23, 1114b94 <huk_subkey_derive+0x160>
		res = crypto_mac_update(ctx, const_data, const_data_len);
		if (res)
			goto out;
	}

	res = crypto_mac_final(ctx, subkey, subkey_len);
 1114b30:	f9402fe0 	ldr	x0, [sp, #88]
 1114b34:	aa1403e2 	mov	x2, x20
 1114b38:	aa1503e1 	mov	x1, x21
 1114b3c:	97ffe39f 	bl	110d9b8 <crypto_mac_final>
 1114b40:	2a0003f3 	mov	w19, w0
out:
	if (res)
 1114b44:	34000080 	cbz	w0, 1114b54 <huk_subkey_derive+0x120>
		memzero_explicit(subkey, subkey_len);
 1114b48:	aa1403e1 	mov	x1, x20
 1114b4c:	aa1503e0 	mov	x0, x21
 1114b50:	9400c12c 	bl	1145000 <memzero_explicit>
	memzero_explicit(&huk, sizeof(huk));
 1114b54:	aa1603e0 	mov	x0, x22
 1114b58:	d2800201 	mov	x1, #0x10                  	// #16
 1114b5c:	9400c129 	bl	1145000 <memzero_explicit>
	crypto_mac_free_ctx(ctx);
 1114b60:	f9402fe0 	ldr	x0, [sp, #88]
 1114b64:	97ffe356 	bl	110d8bc <crypto_mac_free_ctx>
	return res;
}
 1114b68:	2a1303e0 	mov	w0, w19
 1114b6c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1114b70:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1114b74:	a94363f7 	ldp	x23, x24, [sp, #48]
 1114b78:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1114b7c:	a8c97bfd 	ldp	x29, x30, [sp], #144
 1114b80:	d65f03c0 	ret
	return crypto_mac_update(ctx, (const void *)&usage, sizeof(usage));
 1114b84:	910153e1 	add	x1, sp, #0x54
 1114b88:	d2800082 	mov	x2, #0x4                   	// #4
 1114b8c:	b90057f9 	str	w25, [sp, #84]
 1114b90:	17ffffe3 	b	1114b1c <huk_subkey_derive+0xe8>
		res = crypto_mac_update(ctx, const_data, const_data_len);
 1114b94:	f9402fe0 	ldr	x0, [sp, #88]
 1114b98:	aa1803e2 	mov	x2, x24
 1114b9c:	aa1703e1 	mov	x1, x23
 1114ba0:	97ffe372 	bl	110d968 <crypto_mac_update>
 1114ba4:	2a0003f3 	mov	w19, w0
		if (res)
 1114ba8:	34fffc40 	cbz	w0, 1114b30 <huk_subkey_derive+0xfc>
 1114bac:	17ffffe7 	b	1114b48 <huk_subkey_derive+0x114>
		return TEE_ERROR_BAD_PARAMETERS;
 1114bb0:	129fff33 	mov	w19, #0xffff0006            	// #-65530
 1114bb4:	17ffffed 	b	1114b68 <huk_subkey_derive+0x134>

0000000001114bb8 <user_mode_ctx_print_mappings>:
#include <kernel/user_mode_ctx.h>
#include <trace.h>
#include <mm/mobj.h>

void user_mode_ctx_print_mappings(struct user_mode_ctx *uctx)
{
 1114bb8:	d101c3ff 	sub	sp, sp, #0x70
 1114bbc:	a9027bfd 	stp	x29, x30, [sp, #32]
 1114bc0:	910083fd 	add	x29, sp, #0x20
 1114bc4:	a90353f3 	stp	x19, x20, [sp, #48]
	struct vm_region *r = NULL;
	char flags[7] = { '\0', };
	size_t n = 0;
 1114bc8:	d2800014 	mov	x20, #0x0                   	// #0

	TAILQ_FOREACH(r, &uctx->vm_info.regions, link) {
 1114bcc:	f9400013 	ldr	x19, [x0]
{
 1114bd0:	a9045bf5 	stp	x21, x22, [sp, #64]

		if (r->mobj)
			mobj_get_pa(r->mobj, r->offset, 0, &pa);

		mattr_perm_to_str(flags, sizeof(flags), r->attr);
		EMSG_RAW(" region %2zu: va 0x%0*" PRIxVA " pa 0x%0*" PRIxPA
 1114bd4:	90000215 	adrp	x21, 1154000 <__func__.1786+0x8>
		return mobj->ops->get_pa(mobj, offs, granule, pa);
 1114bd8:	9101a3f6 	add	x22, sp, #0x68
 1114bdc:	912446b5 	add	x21, x21, #0x911
{
 1114be0:	a90563f7 	stp	x23, x24, [sp, #80]
		EMSG_RAW(" region %2zu: va 0x%0*" PRIxVA " pa 0x%0*" PRIxPA
 1114be4:	910183f8 	add	x24, sp, #0x60
static inline void mattr_perm_to_str(char *str, size_t size, uint32_t attr)
{
	if (size < 7)
		return;

	str[0] = (attr & TEE_MATTR_UR) ? 'r' : '-';
 1114be8:	52800e57 	mov	w23, #0x72                  	// #114
	char flags[7] = { '\0', };
 1114bec:	b90063ff 	str	wzr, [sp, #96]
 1114bf0:	7900cbff 	strh	wzr, [sp, #100]
 1114bf4:	39019bff 	strb	wzr, [sp, #102]
	TAILQ_FOREACH(r, &uctx->vm_info.regions, link) {
 1114bf8:	b50000f3 	cbnz	x19, 1114c14 <user_mode_ctx_print_mappings+0x5c>
			 " size 0x%06zx flags %s",
			 n, PRIxVA_WIDTH, r->va, PRIxPA_WIDTH, pa, r->size,
			 flags);
		n++;
	}
}
 1114bfc:	a9427bfd 	ldp	x29, x30, [sp, #32]
 1114c00:	a94353f3 	ldp	x19, x20, [sp, #48]
 1114c04:	a9445bf5 	ldp	x21, x22, [sp, #64]
 1114c08:	a94563f7 	ldp	x23, x24, [sp, #80]
 1114c0c:	9101c3ff 	add	sp, sp, #0x70
 1114c10:	d65f03c0 	ret
		if (r->mobj)
 1114c14:	f9400260 	ldr	x0, [x19]
		paddr_t pa = 0;
 1114c18:	f90037ff 	str	xzr, [sp, #104]
		if (r->mobj)
 1114c1c:	b4000120 	cbz	x0, 1114c40 <user_mode_ctx_print_mappings+0x88>
	if (mobj && mobj->ops && mobj->ops->get_pa)
 1114c20:	f9400001 	ldr	x1, [x0]
 1114c24:	b40000e1 	cbz	x1, 1114c40 <user_mode_ctx_print_mappings+0x88>
 1114c28:	f9400424 	ldr	x4, [x1, #8]
 1114c2c:	b40000a4 	cbz	x4, 1114c40 <user_mode_ctx_print_mappings+0x88>
		return mobj->ops->get_pa(mobj, offs, granule, pa);
 1114c30:	f9400661 	ldr	x1, [x19, #8]
 1114c34:	aa1603e3 	mov	x3, x22
 1114c38:	d2800002 	mov	x2, #0x0                   	// #0
 1114c3c:	d63f0080 	blr	x4
		mattr_perm_to_str(flags, sizeof(flags), r->attr);
 1114c40:	79404261 	ldrh	w1, [x19, #32]
 1114c44:	528005a0 	mov	w0, #0x2d                  	// #45
		EMSG_RAW(" region %2zu: va 0x%0*" PRIxVA " pa 0x%0*" PRIxPA
 1114c48:	f9000ff8 	str	x24, [sp, #24]
 1114c4c:	52800206 	mov	w6, #0x10                  	// #16
 1114c50:	aa1403e5 	mov	x5, x20
 1114c54:	aa1503e4 	mov	x4, x21
 1114c58:	f279003f 	tst	x1, #0x80
 1114c5c:	52800023 	mov	w3, #0x1                   	// #1
 1114c60:	1a8012e2 	csel	w2, w23, w0, ne  // ne = any
	str[1] = (attr & TEE_MATTR_UW) ? 'w' : '-';
 1114c64:	f278003f 	tst	x1, #0x100
	str[0] = (attr & TEE_MATTR_UR) ? 'r' : '-';
 1114c68:	390183e2 	strb	w2, [sp, #96]
	str[1] = (attr & TEE_MATTR_UW) ? 'w' : '-';
 1114c6c:	52800ee2 	mov	w2, #0x77                  	// #119
 1114c70:	1a801042 	csel	w2, w2, w0, ne  // ne = any
	str[2] = (attr & TEE_MATTR_UX) ? 'x' : '-';
 1114c74:	f277003f 	tst	x1, #0x200
	str[1] = (attr & TEE_MATTR_UW) ? 'w' : '-';
 1114c78:	390187e2 	strb	w2, [sp, #97]
	str[2] = (attr & TEE_MATTR_UX) ? 'x' : '-';
 1114c7c:	52800f02 	mov	w2, #0x78                  	// #120
 1114c80:	1a801042 	csel	w2, w2, w0, ne  // ne = any
	str[3] = (attr & TEE_MATTR_PR) ? 'R' : '-';
 1114c84:	f27c003f 	tst	x1, #0x10
	str[2] = (attr & TEE_MATTR_UX) ? 'x' : '-';
 1114c88:	39018be2 	strb	w2, [sp, #98]
	str[3] = (attr & TEE_MATTR_PR) ? 'R' : '-';
 1114c8c:	52800a42 	mov	w2, #0x52                  	// #82
 1114c90:	1a801042 	csel	w2, w2, w0, ne  // ne = any
	str[4] = (attr & TEE_MATTR_PW) ? 'W' : '-';
 1114c94:	f27b003f 	tst	x1, #0x20
	str[3] = (attr & TEE_MATTR_PR) ? 'R' : '-';
 1114c98:	39018fe2 	strb	w2, [sp, #99]
	str[4] = (attr & TEE_MATTR_PW) ? 'W' : '-';
 1114c9c:	52800ae2 	mov	w2, #0x57                  	// #87
 1114ca0:	1a801042 	csel	w2, w2, w0, ne  // ne = any
	str[5] = (attr & TEE_MATTR_PX) ? 'X' : '-';
 1114ca4:	f27a003f 	tst	x1, #0x40
 1114ca8:	52800b01 	mov	w1, #0x58                  	// #88
 1114cac:	1a801020 	csel	w0, w1, w0, ne  // ne = any
 1114cb0:	390197e0 	strb	w0, [sp, #101]
 1114cb4:	52800001 	mov	w1, #0x0                   	// #0
 1114cb8:	f9400e60 	ldr	x0, [x19, #24]
 1114cbc:	f9000be0 	str	x0, [sp, #16]
 1114cc0:	f94037e0 	ldr	x0, [sp, #104]
 1114cc4:	b90003e6 	str	w6, [sp]
 1114cc8:	f90007e0 	str	x0, [sp, #8]
		n++;
 1114ccc:	91000694 	add	x20, x20, #0x1
		EMSG_RAW(" region %2zu: va 0x%0*" PRIxVA " pa 0x%0*" PRIxPA
 1114cd0:	d2800000 	mov	x0, #0x0                   	// #0
	str[4] = (attr & TEE_MATTR_PW) ? 'W' : '-';
 1114cd4:	390193e2 	strb	w2, [sp, #100]
 1114cd8:	f9400a67 	ldr	x7, [x19, #16]
 1114cdc:	52800022 	mov	w2, #0x1                   	// #1
	str[6] = '\0';
 1114ce0:	39019bff 	strb	wzr, [sp, #102]
 1114ce4:	9400c018 	bl	1144d44 <trace_printf>
	TAILQ_FOREACH(r, &uctx->vm_info.regions, link) {
 1114ce8:	f9401673 	ldr	x19, [x19, #40]
 1114cec:	17ffffc3 	b	1114bf8 <user_mode_ctx_print_mappings+0x40>

0000000001114cf0 <call_initcalls>:
/*
 * Note: this function is weak just to make it possible to exclude it from
 * the unpaged area.
 */
void __weak call_initcalls(void)
{
 1114cf0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	const struct initcall *call = NULL;
	TEE_Result ret = TEE_SUCCESS;

	for (call = initcall_begin; call < initcall_end; call++) {
 1114cf4:	b0000220 	adrp	x0, 1159000 <Worder+0x2854>
 1114cf8:	9138a000 	add	x0, x0, #0xe28
{
 1114cfc:	910003fd 	mov	x29, sp
 1114d00:	a90153f3 	stp	x19, x20, [sp, #16]
		DMSG("level %d %s()", call->level, call->func_name);
 1114d04:	90000214 	adrp	x20, 1154000 <__func__.1786+0x8>
 1114d08:	9126a294 	add	x20, x20, #0x9a8
{
 1114d0c:	a9025bf5 	stp	x21, x22, [sp, #32]
	for (call = initcall_begin; call < initcall_end; call++) {
 1114d10:	b0000235 	adrp	x21, 1159000 <Worder+0x2854>
		DMSG("level %d %s()", call->level, call->func_name);
 1114d14:	90000216 	adrp	x22, 1154000 <__func__.1786+0x8>
	for (call = initcall_begin; call < initcall_end; call++) {
 1114d18:	97ffff46 	bl	1114a30 <scattered_array_relax_ptr>
 1114d1c:	913c62b5 	add	x21, x21, #0xf18
 1114d20:	aa0003f3 	mov	x19, x0
		DMSG("level %d %s()", call->level, call->func_name);
 1114d24:	91252ed6 	add	x22, x22, #0x94b
	for (call = initcall_begin; call < initcall_end; call++) {
 1114d28:	eb15027f 	cmp	x19, x21
 1114d2c:	540000a3 	b.cc	1114d40 <call_initcalls+0x50>  // b.lo, b.ul, b.last
		if (ret != TEE_SUCCESS) {
			EMSG("Initcall __text_start + 0x%08" PRIxVA
			     " failed", (vaddr_t)call - VCORE_START_VA);
		}
	}
}
 1114d30:	a94153f3 	ldp	x19, x20, [sp, #16]
 1114d34:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1114d38:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1114d3c:	d65f03c0 	ret
		DMSG("level %d %s()", call->level, call->func_name);
 1114d40:	b9400a65 	ldr	w5, [x19, #8]
 1114d44:	aa1403e0 	mov	x0, x20
 1114d48:	f9400a66 	ldr	x6, [x19, #16]
 1114d4c:	aa1603e4 	mov	x4, x22
 1114d50:	52800023 	mov	w3, #0x1                   	// #1
 1114d54:	52800062 	mov	w2, #0x3                   	// #3
 1114d58:	528002a1 	mov	w1, #0x15                  	// #21
 1114d5c:	9400bffa 	bl	1144d44 <trace_printf>
		ret = call->func();
 1114d60:	f9400260 	ldr	x0, [x19]
 1114d64:	d63f0000 	blr	x0
		if (ret != TEE_SUCCESS) {
 1114d68:	34000160 	cbz	w0, 1114d94 <call_initcalls+0xa4>
			EMSG("Initcall __text_start + 0x%08" PRIxVA
 1114d6c:	d0000225 	adrp	x5, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1114d70:	90000204 	adrp	x4, 1154000 <__func__.1786+0x8>
 1114d74:	aa1403e0 	mov	x0, x20
 1114d78:	91256484 	add	x4, x4, #0x959
 1114d7c:	f94140a5 	ldr	x5, [x5, #640]
 1114d80:	52800023 	mov	w3, #0x1                   	// #1
 1114d84:	52800022 	mov	w2, #0x1                   	// #1
 1114d88:	52800301 	mov	w1, #0x18                  	// #24
 1114d8c:	cb050265 	sub	x5, x19, x5
 1114d90:	9400bfed 	bl	1144d44 <trace_printf>
	for (call = initcall_begin; call < initcall_end; call++) {
 1114d94:	91006273 	add	x19, x19, #0x18
 1114d98:	17ffffe4 	b	1114d28 <call_initcalls+0x38>

0000000001114d9c <call_finalcalls>:
/*
 * Note: this function is weak just to make it possible to exclude it from
 * the unpaged area.
 */
void __weak call_finalcalls(void)
{
 1114d9c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	const struct initcall *call = NULL;
	TEE_Result ret = TEE_SUCCESS;

	for (call = finalcall_begin; call < finalcall_end; call++) {
 1114da0:	b0000220 	adrp	x0, 1159000 <Worder+0x2854>
 1114da4:	9138a000 	add	x0, x0, #0xe28
{
 1114da8:	910003fd 	mov	x29, sp
 1114dac:	a90153f3 	stp	x19, x20, [sp, #16]
		DMSG("level %d %s()", call->level, call->func_name);
 1114db0:	90000214 	adrp	x20, 1154000 <__func__.1786+0x8>
 1114db4:	9126de94 	add	x20, x20, #0x9b7
{
 1114db8:	a9025bf5 	stp	x21, x22, [sp, #32]
	for (call = finalcall_begin; call < finalcall_end; call++) {
 1114dbc:	b0000235 	adrp	x21, 1159000 <Worder+0x2854>
		DMSG("level %d %s()", call->level, call->func_name);
 1114dc0:	90000216 	adrp	x22, 1154000 <__func__.1786+0x8>
	for (call = finalcall_begin; call < finalcall_end; call++) {
 1114dc4:	97ffff1b 	bl	1114a30 <scattered_array_relax_ptr>
 1114dc8:	9138a2b5 	add	x21, x21, #0xe28
 1114dcc:	aa0003f3 	mov	x19, x0
		DMSG("level %d %s()", call->level, call->func_name);
 1114dd0:	91252ed6 	add	x22, x22, #0x94b
	for (call = finalcall_begin; call < finalcall_end; call++) {
 1114dd4:	eb15027f 	cmp	x19, x21
 1114dd8:	540000a3 	b.cc	1114dec <call_finalcalls+0x50>  // b.lo, b.ul, b.last
		if (ret != TEE_SUCCESS) {
			EMSG("Finalcall __text_start + 0x%08" PRIxVA
			     " failed", (vaddr_t)call - VCORE_START_VA);
		}
	}
}
 1114ddc:	a94153f3 	ldp	x19, x20, [sp, #16]
 1114de0:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1114de4:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1114de8:	d65f03c0 	ret
		DMSG("level %d %s()", call->level, call->func_name);
 1114dec:	b9400a65 	ldr	w5, [x19, #8]
 1114df0:	aa1403e0 	mov	x0, x20
 1114df4:	f9400a66 	ldr	x6, [x19, #16]
 1114df8:	aa1603e4 	mov	x4, x22
 1114dfc:	52800023 	mov	w3, #0x1                   	// #1
 1114e00:	52800062 	mov	w2, #0x3                   	// #3
 1114e04:	52800501 	mov	w1, #0x28                  	// #40
 1114e08:	9400bfcf 	bl	1144d44 <trace_printf>
		ret = call->func();
 1114e0c:	f9400260 	ldr	x0, [x19]
 1114e10:	d63f0000 	blr	x0
		if (ret != TEE_SUCCESS) {
 1114e14:	34000160 	cbz	w0, 1114e40 <call_finalcalls+0xa4>
			EMSG("Finalcall __text_start + 0x%08" PRIxVA
 1114e18:	d0000225 	adrp	x5, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1114e1c:	90000204 	adrp	x4, 1154000 <__func__.1786+0x8>
 1114e20:	aa1403e0 	mov	x0, x20
 1114e24:	91260084 	add	x4, x4, #0x980
 1114e28:	f94140a5 	ldr	x5, [x5, #640]
 1114e2c:	52800023 	mov	w3, #0x1                   	// #1
 1114e30:	52800022 	mov	w2, #0x1                   	// #1
 1114e34:	52800561 	mov	w1, #0x2b                  	// #43
 1114e38:	cb050265 	sub	x5, x19, x5
 1114e3c:	9400bfc2 	bl	1144d44 <trace_printf>
	for (call = finalcall_begin; call < finalcall_end; call++) {
 1114e40:	91006273 	add	x19, x19, #0x18
 1114e44:	17ffffe4 	b	1114dd4 <call_finalcalls+0x38>

0000000001114e48 <check_access>:
#include <string.h>
#include <tee_api_types.h>
#include <types_ext.h>

static TEE_Result check_access(uint32_t flags, vaddr_t va, size_t len)
{
 1114e48:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1114e4c:	910003fd 	mov	x29, sp
 1114e50:	a90153f3 	stp	x19, x20, [sp, #16]
 1114e54:	2a0003f4 	mov	w20, w0
 1114e58:	a9025bf5 	stp	x21, x22, [sp, #32]
 1114e5c:	aa0103f5 	mov	x21, x1
 1114e60:	aa0203f6 	mov	x22, x2
	struct ts_session *s = ts_get_current_session();
 1114e64:	97fffedf 	bl	11149e0 <ts_get_current_session>

	return vm_check_access_rights(to_user_mode_ctx(s->ctx), flags, va, len);
 1114e68:	f9400813 	ldr	x19, [x0, #16]
	if (is_user_ta_ctx(ctx))
 1114e6c:	aa1303e0 	mov	x0, x19
 1114e70:	940004df 	bl	11161ec <is_user_ta_ctx>
 1114e74:	72001c1f 	tst	w0, #0xff
 1114e78:	540002c0 	b.eq	1114ed0 <check_access+0x88>  // b.none
 1114e7c:	aa1303e0 	mov	x0, x19
 1114e80:	940004db 	bl	11161ec <is_user_ta_ctx>
 1114e84:	72001c1f 	tst	w0, #0xff
 1114e88:	54000141 	b.ne	1114eb0 <check_access+0x68>  // b.any
 1114e8c:	90000203 	adrp	x3, 1154000 <__func__.1786+0x8>
 1114e90:	b00001e1 	adrp	x1, 1151000 <small_prime+0x168>
 1114e94:	b00001e0 	adrp	x0, 1151000 <small_prime+0x168>
 1114e98:	91287063 	add	x3, x3, #0xa1c
 1114e9c:	91081021 	add	x1, x1, #0x204
 1114ea0:	91088800 	add	x0, x0, #0x222
 1114ea4:	52800702 	mov	w2, #0x38                  	// #56
 1114ea8:	97fff501 	bl	11122ac <_assert_log>
 1114eac:	97fff511 	bl	11122f0 <_assert_break>
 1114eb0:	aa1603e3 	mov	x3, x22
 1114eb4:	aa1503e2 	mov	x2, x21
 1114eb8:	2a1403e1 	mov	w1, w20
 1114ebc:	d10a6260 	sub	x0, x19, #0x298
}
 1114ec0:	a94153f3 	ldp	x19, x20, [sp, #16]
 1114ec4:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1114ec8:	a8c37bfd 	ldp	x29, x30, [sp], #48
	return vm_check_access_rights(to_user_mode_ctx(s->ctx), flags, va, len);
 1114ecc:	14001248 	b	11197ec <vm_check_access_rights>
 1114ed0:	90000203 	adrp	x3, 1154000 <__func__.1786+0x8>
 1114ed4:	b00001e1 	adrp	x1, 1151000 <small_prime+0x168>
 1114ed8:	b00001e0 	adrp	x0, 1151000 <small_prime+0x168>
 1114edc:	91284063 	add	x3, x3, #0xa10
 1114ee0:	913a8421 	add	x1, x1, #0xea1
 1114ee4:	913b2000 	add	x0, x0, #0xec8
 1114ee8:	52801322 	mov	w2, #0x99                  	// #153
 1114eec:	17ffffef 	b	1114ea8 <check_access+0x60>

0000000001114ef0 <copy_from_user>:

TEE_Result copy_from_user(void *kaddr, const void *uaddr, size_t len)
{
 1114ef0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1114ef4:	910003fd 	mov	x29, sp
 1114ef8:	a90153f3 	stp	x19, x20, [sp, #16]
 1114efc:	aa0003f4 	mov	x20, x0
	uint32_t flags = TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER;
	TEE_Result res = check_access(flags, (vaddr_t)uaddr, len);
 1114f00:	528000a0 	mov	w0, #0x5                   	// #5
{
 1114f04:	a9025bf5 	stp	x21, x22, [sp, #32]
 1114f08:	aa0103f5 	mov	x21, x1
 1114f0c:	aa0203f6 	mov	x22, x2
	TEE_Result res = check_access(flags, (vaddr_t)uaddr, len);
 1114f10:	97ffffce 	bl	1114e48 <check_access>
 1114f14:	2a0003f3 	mov	w19, w0

	if (!res)
 1114f18:	350000a0 	cbnz	w0, 1114f2c <copy_from_user+0x3c>
		memcpy(kaddr, uaddr, len);
 1114f1c:	aa1603e2 	mov	x2, x22
 1114f20:	aa1503e1 	mov	x1, x21
 1114f24:	aa1403e0 	mov	x0, x20
 1114f28:	97ffb91a 	bl	1103390 <memcpy>

	return res;
}
 1114f2c:	2a1303e0 	mov	w0, w19
 1114f30:	a94153f3 	ldp	x19, x20, [sp, #16]
 1114f34:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1114f38:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1114f3c:	d65f03c0 	ret

0000000001114f40 <copy_to_user>:

TEE_Result copy_to_user(void *uaddr, const void *kaddr, size_t len)
{
 1114f40:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1114f44:	910003fd 	mov	x29, sp
 1114f48:	a90153f3 	stp	x19, x20, [sp, #16]
 1114f4c:	aa0003f4 	mov	x20, x0
 1114f50:	a9025bf5 	stp	x21, x22, [sp, #32]
 1114f54:	aa0103f5 	mov	x21, x1
 1114f58:	aa0203f6 	mov	x22, x2
	uint32_t flags = TEE_MEMORY_ACCESS_WRITE | TEE_MEMORY_ACCESS_ANY_OWNER;
	TEE_Result res = check_access(flags, (vaddr_t)uaddr, len);
 1114f5c:	aa0003e1 	mov	x1, x0
 1114f60:	528000c0 	mov	w0, #0x6                   	// #6
 1114f64:	97ffffb9 	bl	1114e48 <check_access>
 1114f68:	2a0003f3 	mov	w19, w0

	if (!res)
 1114f6c:	350000a0 	cbnz	w0, 1114f80 <copy_to_user+0x40>
		memcpy(uaddr, kaddr, len);
 1114f70:	aa1603e2 	mov	x2, x22
 1114f74:	aa1503e1 	mov	x1, x21
 1114f78:	aa1403e0 	mov	x0, x20
 1114f7c:	97ffb905 	bl	1103390 <memcpy>

	return res;
}
 1114f80:	2a1303e0 	mov	w0, w19
 1114f84:	a94153f3 	ldp	x19, x20, [sp, #16]
 1114f88:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1114f8c:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1114f90:	d65f03c0 	ret

0000000001114f94 <copy_from_user_private>:

TEE_Result copy_from_user_private(void *kaddr, const void *uaddr, size_t len)
{
 1114f94:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1114f98:	910003fd 	mov	x29, sp
 1114f9c:	a90153f3 	stp	x19, x20, [sp, #16]
 1114fa0:	aa0003f4 	mov	x20, x0
	uint32_t flags = TEE_MEMORY_ACCESS_READ;
	TEE_Result res = check_access(flags, (vaddr_t)uaddr, len);
 1114fa4:	52800020 	mov	w0, #0x1                   	// #1
{
 1114fa8:	a9025bf5 	stp	x21, x22, [sp, #32]
 1114fac:	aa0103f5 	mov	x21, x1
 1114fb0:	aa0203f6 	mov	x22, x2
	TEE_Result res = check_access(flags, (vaddr_t)uaddr, len);
 1114fb4:	97ffffa5 	bl	1114e48 <check_access>
 1114fb8:	2a0003f3 	mov	w19, w0

	if (!res)
 1114fbc:	350000a0 	cbnz	w0, 1114fd0 <copy_from_user_private+0x3c>
		memcpy(kaddr, uaddr, len);
 1114fc0:	aa1603e2 	mov	x2, x22
 1114fc4:	aa1503e1 	mov	x1, x21
 1114fc8:	aa1403e0 	mov	x0, x20
 1114fcc:	97ffb8f1 	bl	1103390 <memcpy>

	return res;
}
 1114fd0:	2a1303e0 	mov	w0, w19
 1114fd4:	a94153f3 	ldp	x19, x20, [sp, #16]
 1114fd8:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1114fdc:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1114fe0:	d65f03c0 	ret

0000000001114fe4 <copy_to_user_private>:

TEE_Result copy_to_user_private(void *uaddr, const void *kaddr, size_t len)
{
 1114fe4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1114fe8:	910003fd 	mov	x29, sp
 1114fec:	a90153f3 	stp	x19, x20, [sp, #16]
 1114ff0:	aa0003f4 	mov	x20, x0
 1114ff4:	a9025bf5 	stp	x21, x22, [sp, #32]
 1114ff8:	aa0103f5 	mov	x21, x1
 1114ffc:	aa0203f6 	mov	x22, x2
	uint32_t flags = TEE_MEMORY_ACCESS_WRITE;
	TEE_Result res = check_access(flags, (vaddr_t)uaddr, len);
 1115000:	aa0003e1 	mov	x1, x0
 1115004:	52800040 	mov	w0, #0x2                   	// #2
 1115008:	97ffff90 	bl	1114e48 <check_access>
 111500c:	2a0003f3 	mov	w19, w0

	if (!res)
 1115010:	350000a0 	cbnz	w0, 1115024 <copy_to_user_private+0x40>
		memcpy(uaddr, kaddr, len);
 1115014:	aa1603e2 	mov	x2, x22
 1115018:	aa1503e1 	mov	x1, x21
 111501c:	aa1403e0 	mov	x0, x20
 1115020:	97ffb8dc 	bl	1103390 <memcpy>

	return res;
}
 1115024:	2a1303e0 	mov	w0, w19
 1115028:	a94153f3 	ldp	x19, x20, [sp, #16]
 111502c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1115030:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1115034:	d65f03c0 	ret

0000000001115038 <kaddr_to_uref>:
	return copy_to_user_private(uref, &ref, sizeof(ref));
}

uint32_t kaddr_to_uref(void *kaddr)
{
	assert(((vaddr_t)kaddr - VCORE_START_VA) < UINT32_MAX);
 1115038:	b0000221 	adrp	x1, 115a000 <__scattered_array_1phys_mem_map+0x8>
 111503c:	f9414021 	ldr	x1, [x1, #640]
 1115040:	cb010000 	sub	x0, x0, x1
 1115044:	b27f7be1 	mov	x1, #0xfffffffe            	// #4294967294
 1115048:	eb01001f 	cmp	x0, x1
 111504c:	54000189 	b.ls	111507c <kaddr_to_uref+0x44>  // b.plast
 1115050:	f00001e3 	adrp	x3, 1154000 <__func__.1786+0x8>
 1115054:	f00001e1 	adrp	x1, 1154000 <__func__.1786+0x8>
 1115058:	9128ac63 	add	x3, x3, #0xa2b
 111505c:	91271c21 	add	x1, x1, #0x9c7
 1115060:	f00001e0 	adrp	x0, 1154000 <__func__.1786+0x8>
 1115064:	91278400 	add	x0, x0, #0x9e1
{
 1115068:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	assert(((vaddr_t)kaddr - VCORE_START_VA) < UINT32_MAX);
 111506c:	52800982 	mov	w2, #0x4c                  	// #76
{
 1115070:	910003fd 	mov	x29, sp
	assert(((vaddr_t)kaddr - VCORE_START_VA) < UINT32_MAX);
 1115074:	97fff48e 	bl	11122ac <_assert_log>
 1115078:	97fff49e 	bl	11122f0 <_assert_break>
	return (vaddr_t)kaddr - VCORE_START_VA;
}
 111507c:	d65f03c0 	ret

0000000001115080 <copy_kaddr_to_uref>:
{
 1115080:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1115084:	910003fd 	mov	x29, sp
 1115088:	f9000bf3 	str	x19, [sp, #16]
 111508c:	aa0003f3 	mov	x19, x0
 1115090:	aa0103e0 	mov	x0, x1
	uint32_t ref = kaddr_to_uref(kaddr);
 1115094:	97ffffe9 	bl	1115038 <kaddr_to_uref>
	return copy_to_user_private(uref, &ref, sizeof(ref));
 1115098:	9100b3e1 	add	x1, sp, #0x2c
 111509c:	d2800082 	mov	x2, #0x4                   	// #4
	uint32_t ref = kaddr_to_uref(kaddr);
 11150a0:	b9002fe0 	str	w0, [sp, #44]
	return copy_to_user_private(uref, &ref, sizeof(ref));
 11150a4:	aa1303e0 	mov	x0, x19
 11150a8:	97ffffcf 	bl	1114fe4 <copy_to_user_private>
}
 11150ac:	f9400bf3 	ldr	x19, [sp, #16]
 11150b0:	a8c37bfd 	ldp	x29, x30, [sp], #48
 11150b4:	d65f03c0 	ret

00000000011150b8 <uref_to_vaddr>:

vaddr_t uref_to_vaddr(uint32_t uref)
{
	return VCORE_START_VA + uref;
 11150b8:	b0000221 	adrp	x1, 115a000 <__scattered_array_1phys_mem_map+0x8>
}
 11150bc:	f9414021 	ldr	x1, [x1, #640]
 11150c0:	8b204020 	add	x0, x1, w0, uxtw
 11150c4:	d65f03c0 	ret

00000000011150c8 <assert_have_no_spinlock>:
{
 11150c8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 11150cc:	910003fd 	mov	x29, sp
	assert(!have_spinlock());
 11150d0:	97ffbd22 	bl	1104558 <have_spinlock>
 11150d4:	72001c1f 	tst	w0, #0xff
 11150d8:	54000140 	b.eq	1115100 <assert_have_no_spinlock+0x38>  // b.none
 11150dc:	f00001e3 	adrp	x3, 1154000 <__func__.1786+0x8>
 11150e0:	900001e1 	adrp	x1, 1151000 <small_prime+0x168>
 11150e4:	912bc863 	add	x3, x3, #0xaf2
 11150e8:	9111f821 	add	x1, x1, #0x47e
 11150ec:	900001e0 	adrp	x0, 1151000 <small_prime+0x168>
 11150f0:	91157800 	add	x0, x0, #0x55e
 11150f4:	52800322 	mov	w2, #0x19                  	// #25
 11150f8:	97fff46d 	bl	11122ac <_assert_log>
 11150fc:	97fff47d 	bl	11122f0 <_assert_break>
}
 1115100:	a8c17bfd 	ldp	x29, x30, [sp], #16
 1115104:	d65f03c0 	ret

0000000001115108 <cpu_spin_lock_dldetect>:
{
 1115108:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 111510c:	910003fd 	mov	x29, sp
 1115110:	a90153f3 	stp	x19, x20, [sp, #16]
 1115114:	aa0203f4 	mov	x20, x2
 1115118:	a9025bf5 	stp	x21, x22, [sp, #32]
 111511c:	aa0003f6 	mov	x22, x0
 1115120:	a90363f7 	stp	x23, x24, [sp, #48]
 1115124:	2a0103f7 	mov	w23, w1
 1115128:	f90023f9 	str	x25, [sp, #64]
 111512c:	97ffbf7a 	bl	1104f14 <thread_get_exceptions>
	assert(thread_foreign_intr_disabled());
 1115130:	360801e0 	tbz	w0, #1, 111516c <cpu_spin_lock_dldetect+0x64>
			trace_printf(func, line, TRACE_ERROR, true,
 1115134:	900001f8 	adrp	x24, 1151000 <small_prime+0x168>
 1115138:	91131718 	add	x24, x24, #0x4c5
 111513c:	52800013 	mov	w19, #0x0                   	// #0
		if (!retries) {
 1115140:	d2c00039 	mov	x25, #0x100000000           	// #4294967296
	unsigned int reminder = 0;
 1115144:	d2800015 	mov	x21, #0x0                   	// #0
	while (__cpu_spin_trylock(lock)) {
 1115148:	aa1403e0 	mov	x0, x20
 111514c:	97ffbcd6 	bl	11044a4 <__cpu_spin_trylock>
 1115150:	35000200 	cbnz	w0, 1115190 <cpu_spin_lock_dldetect+0x88>
}
 1115154:	a94153f3 	ldp	x19, x20, [sp, #16]
 1115158:	a9425bf5 	ldp	x21, x22, [sp, #32]
 111515c:	a94363f7 	ldp	x23, x24, [sp, #48]
 1115160:	f94023f9 	ldr	x25, [sp, #64]
 1115164:	a8c57bfd 	ldp	x29, x30, [sp], #80
	spinlock_count_incr();
 1115168:	17ffbcd8 	b	11044c8 <spinlock_count_incr>
	assert(thread_foreign_intr_disabled());
 111516c:	f00001e3 	adrp	x3, 1154000 <__func__.1786+0x8>
 1115170:	900001e1 	adrp	x1, 1151000 <small_prime+0x168>
 1115174:	912c2863 	add	x3, x3, #0xb0a
 1115178:	9111f821 	add	x1, x1, #0x47e
 111517c:	900001e0 	adrp	x0, 1151000 <small_prime+0x168>
 1115180:	91129800 	add	x0, x0, #0x4a6
 1115184:	528006e2 	mov	w2, #0x37                  	// #55
 1115188:	97fff449 	bl	11122ac <_assert_log>
 111518c:	97fff459 	bl	11122f0 <_assert_break>
		if (!retries) {
 1115190:	910006b5 	add	x21, x21, #0x1
 1115194:	eb1902bf 	cmp	x21, x25
 1115198:	54fffd81 	b.ne	1115148 <cpu_spin_lock_dldetect+0x40>  // b.any
			trace_printf(func, line, TRACE_ERROR, true,
 111519c:	2a1303e5 	mov	w5, w19
 11151a0:	aa1803e4 	mov	x4, x24
 11151a4:	2a1703e1 	mov	w1, w23
 11151a8:	aa1603e0 	mov	x0, x22
 11151ac:	52800023 	mov	w3, #0x1                   	// #1
 11151b0:	52800022 	mov	w2, #0x1                   	// #1
 11151b4:	9400bee4 	bl	1144d44 <trace_printf>
			if (reminder < UINT_MAX)
 11151b8:	3100067f 	cmn	w19, #0x1
 11151bc:	54fffc40 	b.eq	1115144 <cpu_spin_lock_dldetect+0x3c>  // b.none
				reminder++;
 11151c0:	11000673 	add	w19, w19, #0x1
 11151c4:	17ffffe0 	b	1115144 <cpu_spin_lock_dldetect+0x3c>

00000000011151c8 <cpu_spin_lock_xsave_dldetect>:
{
 11151c8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 11151cc:	910003fd 	mov	x29, sp
 11151d0:	a90153f3 	stp	x19, x20, [sp, #16]
 11151d4:	aa0003f4 	mov	x20, x0
	uint32_t exceptions = thread_mask_exceptions(THREAD_EXCP_ALL);
 11151d8:	528000e0 	mov	w0, #0x7                   	// #7
{
 11151dc:	a9025bf5 	stp	x21, x22, [sp, #32]
 11151e0:	2a0103f5 	mov	w21, w1
 11151e4:	aa0203f6 	mov	x22, x2
	uint32_t exceptions = thread_mask_exceptions(THREAD_EXCP_ALL);
 11151e8:	97ffbfd4 	bl	1105138 <thread_mask_exceptions>
 11151ec:	2a0003f3 	mov	w19, w0
	cpu_spin_lock_dldetect(func, line, lock);
 11151f0:	aa1603e2 	mov	x2, x22
 11151f4:	2a1503e1 	mov	w1, w21
 11151f8:	aa1403e0 	mov	x0, x20
 11151fc:	97ffffc3 	bl	1115108 <cpu_spin_lock_dldetect>
}
 1115200:	2a1303e0 	mov	w0, w19
 1115204:	a94153f3 	ldp	x19, x20, [sp, #16]
 1115208:	a9425bf5 	ldp	x21, x22, [sp, #32]
 111520c:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1115210:	d65f03c0 	ret

0000000001115214 <cpu_spin_unlock>:
{
 1115214:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1115218:	910003fd 	mov	x29, sp
 111521c:	f9000bf3 	str	x19, [sp, #16]
 1115220:	aa0003f3 	mov	x19, x0
 1115224:	97ffbf3c 	bl	1104f14 <thread_get_exceptions>
	assert(thread_foreign_intr_disabled());
 1115228:	37080140 	tbnz	w0, #1, 1115250 <cpu_spin_unlock+0x3c>
 111522c:	f00001e3 	adrp	x3, 1154000 <__func__.1786+0x8>
 1115230:	900001e1 	adrp	x1, 1151000 <small_prime+0x168>
 1115234:	912c8463 	add	x3, x3, #0xb21
 1115238:	9111f821 	add	x1, x1, #0x47e
 111523c:	900001e0 	adrp	x0, 1151000 <small_prime+0x168>
 1115240:	91129800 	add	x0, x0, #0x4a6
 1115244:	52800b82 	mov	w2, #0x5c                  	// #92
 1115248:	97fff419 	bl	11122ac <_assert_log>
 111524c:	97fff429 	bl	11122f0 <_assert_break>
	__cpu_spin_unlock(lock);
 1115250:	aa1303e0 	mov	x0, x19
 1115254:	97ffbc9b 	bl	11044c0 <__cpu_spin_unlock>
}
 1115258:	f9400bf3 	ldr	x19, [sp, #16]
 111525c:	a8c27bfd 	ldp	x29, x30, [sp], #32
	spinlock_count_decr();
 1115260:	17ffbcac 	b	1104510 <spinlock_count_decr>

0000000001115264 <cpu_spin_unlock_xrestore>:
{
 1115264:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1115268:	910003fd 	mov	x29, sp
 111526c:	f9000bf3 	str	x19, [sp, #16]
 1115270:	2a0103f3 	mov	w19, w1
	cpu_spin_unlock(lock);
 1115274:	97ffffe8 	bl	1115214 <cpu_spin_unlock>
	thread_unmask_exceptions(exceptions);
 1115278:	2a1303e0 	mov	w0, w19
}
 111527c:	f9400bf3 	ldr	x19, [sp, #16]
 1115280:	a8c27bfd 	ldp	x29, x30, [sp], #32
	thread_unmask_exceptions(exceptions);
 1115284:	17ffbfba 	b	110516c <thread_unmask_exceptions>

0000000001115288 <cv_signal.constprop.0>:
		panic();

	condvar_init(cv);
}

static void cv_signal(struct condvar *cv, bool only_one, const char *fname,
 1115288:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
			int lineno)
{
	uint32_t old_itr_status;
	struct mutex *m;

	old_itr_status = cpu_spin_lock_xsave(&cv->spin_lock);
 111528c:	aa0003e2 	mov	x2, x0
static void cv_signal(struct condvar *cv, bool only_one, const char *fname,
 1115290:	910003fd 	mov	x29, sp
 1115294:	a90153f3 	stp	x19, x20, [sp, #16]
 1115298:	aa0003f3 	mov	x19, x0
	old_itr_status = cpu_spin_lock_xsave(&cv->spin_lock);
 111529c:	f00001e0 	adrp	x0, 1154000 <__func__.1786+0x8>
 11152a0:	912fc000 	add	x0, x0, #0xbf0
static void cv_signal(struct condvar *cv, bool only_one, const char *fname,
 11152a4:	f90013f5 	str	x21, [sp, #32]
 11152a8:	12001c35 	and	w21, w1, #0xff
	old_itr_status = cpu_spin_lock_xsave(&cv->spin_lock);
 11152ac:	52802d81 	mov	w1, #0x16c                 	// #364
 11152b0:	97ffffc6 	bl	11151c8 <cpu_spin_lock_xsave_dldetect>
	m = cv->m;
	cpu_spin_unlock_xrestore(&cv->spin_lock, old_itr_status);
 11152b4:	2a0003e1 	mov	w1, w0
	m = cv->m;
 11152b8:	f9400674 	ldr	x20, [x19, #8]
	cpu_spin_unlock_xrestore(&cv->spin_lock, old_itr_status);
 11152bc:	aa1303e0 	mov	x0, x19
 11152c0:	97ffffe9 	bl	1115264 <cpu_spin_unlock_xrestore>

	if (m)
 11152c4:	b4000174 	cbz	x20, 11152f0 <cv_signal.constprop.0+0x68>
		wq_promote_condvar(&m->wq, cv, only_one, m, fname, lineno);
 11152c8:	aa1403e3 	mov	x3, x20
 11152cc:	2a1503e2 	mov	w2, w21
 11152d0:	aa1303e1 	mov	x1, x19
 11152d4:	91002280 	add	x0, x20, #0x8

}
 11152d8:	a94153f3 	ldp	x19, x20, [sp, #16]
		wq_promote_condvar(&m->wq, cv, only_one, m, fname, lineno);
 11152dc:	12800005 	mov	w5, #0xffffffff            	// #-1
}
 11152e0:	f94013f5 	ldr	x21, [sp, #32]
		wq_promote_condvar(&m->wq, cv, only_one, m, fname, lineno);
 11152e4:	d2800004 	mov	x4, #0x0                   	// #0
}
 11152e8:	a8c37bfd 	ldp	x29, x30, [sp], #48
		wq_promote_condvar(&m->wq, cv, only_one, m, fname, lineno);
 11152ec:	14000318 	b	1115f4c <wq_promote_condvar>
}
 11152f0:	a94153f3 	ldp	x19, x20, [sp, #16]
 11152f4:	f94013f5 	ldr	x21, [sp, #32]
 11152f8:	a8c37bfd 	ldp	x29, x30, [sp], #48
 11152fc:	d65f03c0 	ret

0000000001115300 <__mutex_unlock.constprop.0>:
static void __mutex_unlock(struct mutex *m, const char *fname, int lineno)
 1115300:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1115304:	910003fd 	mov	x29, sp
 1115308:	a90153f3 	stp	x19, x20, [sp, #16]
 111530c:	aa0003f3 	mov	x19, x0
	assert_have_no_spinlock();
 1115310:	97ffff6e 	bl	11150c8 <assert_have_no_spinlock>
	assert(thread_get_id_may_fail() != THREAD_ID_INVALID);
 1115314:	97ffc036 	bl	11053ec <thread_get_id_may_fail>
 1115318:	13003c00 	sxth	w0, w0
 111531c:	3100041f 	cmn	w0, #0x1
 1115320:	f00001e3 	adrp	x3, 1154000 <__func__.1786+0x8>
 1115324:	54000121 	b.ne	1115348 <__mutex_unlock.constprop.0+0x48>  // b.any
 1115328:	912d5463 	add	x3, x3, #0xb55
 111532c:	f00001e1 	adrp	x1, 1154000 <__func__.1786+0x8>
 1115330:	f00001e0 	adrp	x0, 1154000 <__func__.1786+0x8>
 1115334:	9128e421 	add	x1, x1, #0xa39
 1115338:	91293400 	add	x0, x0, #0xa4d
 111533c:	52800be2 	mov	w2, #0x5f                  	// #95
 1115340:	97fff3db 	bl	11122ac <_assert_log>
 1115344:	97fff3eb 	bl	11122f0 <_assert_break>
	old_itr_status = cpu_spin_lock_xsave(&m->spin_lock);
 1115348:	912d5474 	add	x20, x3, #0xb55
 111534c:	52800c61 	mov	w1, #0x63                  	// #99
 1115350:	aa1303e2 	mov	x2, x19
 1115354:	aa1403e0 	mov	x0, x20
 1115358:	97ffff9c 	bl	11151c8 <cpu_spin_lock_xsave_dldetect>
 111535c:	2a0003e1 	mov	w1, w0
	if (!m->state)
 1115360:	79c02260 	ldrsh	w0, [x19, #16]
 1115364:	350000e0 	cbnz	w0, 1115380 <__mutex_unlock.constprop.0+0x80>
		panic();
 1115368:	f00001e0 	adrp	x0, 1154000 <__func__.1786+0x8>
 111536c:	aa1403e2 	mov	x2, x20
 1115370:	9128e400 	add	x0, x0, #0xa39
 1115374:	d2800003 	mov	x3, #0x0                   	// #0
 1115378:	52800cc1 	mov	w1, #0x66                  	// #102
 111537c:	97fff83b 	bl	1113468 <__do_panic>
	m->state = 0;
 1115380:	7900227f 	strh	wzr, [x19, #16]
	cpu_spin_unlock_xrestore(&m->spin_lock, old_itr_status);
 1115384:	aa1303e0 	mov	x0, x19
 1115388:	97ffffb7 	bl	1115264 <cpu_spin_unlock_xrestore>
	wq_wake_next(&m->wq, m, fname, lineno);
 111538c:	aa1303e1 	mov	x1, x19
 1115390:	91002260 	add	x0, x19, #0x8
}
 1115394:	a94153f3 	ldp	x19, x20, [sp, #16]
	wq_wake_next(&m->wq, m, fname, lineno);
 1115398:	12800003 	mov	w3, #0xffffffff            	// #-1
}
 111539c:	a8c27bfd 	ldp	x29, x30, [sp], #32
	wq_wake_next(&m->wq, m, fname, lineno);
 11153a0:	d2800002 	mov	x2, #0x0                   	// #0
 11153a4:	140002b0 	b	1115e64 <wq_wake_next>

00000000011153a8 <__mutex_lock.constprop.0>:
static void __mutex_lock(struct mutex *m, const char *fname, int lineno)
 11153a8:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
 11153ac:	910003fd 	mov	x29, sp
 11153b0:	a90153f3 	stp	x19, x20, [sp, #16]
 11153b4:	aa0003f3 	mov	x19, x0
 11153b8:	f00001f4 	adrp	x20, 1154000 <__func__.1786+0x8>
 11153bc:	a9025bf5 	stp	x21, x22, [sp, #32]
 11153c0:	a90363f7 	stp	x23, x24, [sp, #48]
 11153c4:	f90023f9 	str	x25, [sp, #64]
	assert_have_no_spinlock();
 11153c8:	97ffff40 	bl	11150c8 <assert_have_no_spinlock>
	assert(thread_get_id_may_fail() != THREAD_ID_INVALID);
 11153cc:	97ffc008 	bl	11053ec <thread_get_id_may_fail>
 11153d0:	13003c00 	sxth	w0, w0
 11153d4:	3100041f 	cmn	w0, #0x1
 11153d8:	54000121 	b.ne	11153fc <__mutex_lock.constprop.0+0x54>  // b.any
 11153dc:	f00001e1 	adrp	x1, 1154000 <__func__.1786+0x8>
 11153e0:	f00001e0 	adrp	x0, 1154000 <__func__.1786+0x8>
 11153e4:	912cc683 	add	x3, x20, #0xb31
 11153e8:	9128e421 	add	x1, x1, #0xa39
 11153ec:	91293400 	add	x0, x0, #0xa4d
 11153f0:	52800382 	mov	w2, #0x1c                  	// #28
	assert(thread_is_in_normal_mode());
 11153f4:	97fff3ae 	bl	11122ac <_assert_log>
 11153f8:	97fff3be 	bl	11122f0 <_assert_break>
 11153fc:	97ffbfe7 	bl	1105398 <thread_is_in_normal_mode>
 1115400:	72001c1f 	tst	w0, #0xff
 1115404:	54000380 	b.eq	1115474 <__mutex_lock.constprop.0+0xcc>  // b.none
		old_itr_status = cpu_spin_lock_xsave(&m->spin_lock);
 1115408:	912cc694 	add	x20, x20, #0xb31
			struct condvar *cv, bool wait_read);

static inline void wq_wait_init(struct wait_queue *wq,
			struct wait_queue_elem *wqe, bool wait_read)
{
	wq_wait_init_condvar(wq, wqe, NULL, wait_read);
 111540c:	910163f7 	add	x23, sp, #0x58
			wq_wait_init(&m->wq, &wqe, false /* wait_read */);
 1115410:	91002276 	add	x22, x19, #0x8
			m->state = -1; /* write locked */
 1115414:	12800019 	mov	w25, #0xffffffff            	// #-1
		old_itr_status = cpu_spin_lock_xsave(&m->spin_lock);
 1115418:	aa1303e2 	mov	x2, x19
 111541c:	aa1403e0 	mov	x0, x20
 1115420:	528005e1 	mov	w1, #0x2f                  	// #47
 1115424:	97ffff69 	bl	11151c8 <cpu_spin_lock_xsave_dldetect>
		can_lock = !m->state;
 1115428:	79c02278 	ldrsh	w24, [x19, #16]
		old_itr_status = cpu_spin_lock_xsave(&m->spin_lock);
 111542c:	2a0003f5 	mov	w21, w0
		if (!can_lock) {
 1115430:	34000318 	cbz	w24, 1115490 <__mutex_lock.constprop.0+0xe8>
 1115434:	aa1703e1 	mov	x1, x23
 1115438:	aa1603e0 	mov	x0, x22
 111543c:	52800003 	mov	w3, #0x0                   	// #0
 1115440:	d2800002 	mov	x2, #0x0                   	// #0
 1115444:	94000238 	bl	1115d24 <wq_wait_init_condvar>
		cpu_spin_unlock_xrestore(&m->spin_lock, old_itr_status);
 1115448:	2a1503e1 	mov	w1, w21
 111544c:	aa1303e0 	mov	x0, x19
 1115450:	97ffff85 	bl	1115264 <cpu_spin_unlock_xrestore>
		if (!can_lock) {
 1115454:	34000238 	cbz	w24, 1115498 <__mutex_lock.constprop.0+0xf0>
			wq_wait_final(&m->wq, &wqe, m, fname, lineno);
 1115458:	aa1303e2 	mov	x2, x19
 111545c:	aa1703e1 	mov	x1, x23
 1115460:	aa1603e0 	mov	x0, x22
 1115464:	12800004 	mov	w4, #0xffffffff            	// #-1
 1115468:	d2800003 	mov	x3, #0x0                   	// #0
 111546c:	94000250 	bl	1115dac <wq_wait_final>
 1115470:	17ffffea 	b	1115418 <__mutex_lock.constprop.0+0x70>
	assert(thread_is_in_normal_mode());
 1115474:	f00001e1 	adrp	x1, 1154000 <__func__.1786+0x8>
 1115478:	f00001e0 	adrp	x0, 1154000 <__func__.1786+0x8>
 111547c:	912cc683 	add	x3, x20, #0xb31
 1115480:	9128e421 	add	x1, x1, #0xa39
 1115484:	9129ec00 	add	x0, x0, #0xa7b
 1115488:	528003a2 	mov	w2, #0x1d                  	// #29
 111548c:	17ffffda 	b	11153f4 <__mutex_lock.constprop.0+0x4c>
			m->state = -1; /* write locked */
 1115490:	79002279 	strh	w25, [x19, #16]
 1115494:	17ffffed 	b	1115448 <__mutex_lock.constprop.0+0xa0>
}
 1115498:	a94153f3 	ldp	x19, x20, [sp, #16]
 111549c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11154a0:	a94363f7 	ldp	x23, x24, [sp, #48]
 11154a4:	f94023f9 	ldr	x25, [sp, #64]
 11154a8:	a8c77bfd 	ldp	x29, x30, [sp], #112
 11154ac:	d65f03c0 	ret

00000000011154b0 <mutex_init>:
	*m = (struct mutex)MUTEX_INITIALIZER;
 11154b0:	a9007c1f 	stp	xzr, xzr, [x0]
 11154b4:	f900081f 	str	xzr, [x0, #16]
}
 11154b8:	d65f03c0 	ret

00000000011154bc <mutex_init_recursive>:
	*m = (struct recursive_mutex)RECURSIVE_MUTEX_INITIALIZER;
 11154bc:	a9017c1f 	stp	xzr, xzr, [x0, #16]
 11154c0:	12800001 	mov	w1, #0xffffffff            	// #-1
 11154c4:	a9007c1f 	stp	xzr, xzr, [x0]
 11154c8:	79003001 	strh	w1, [x0, #24]
}
 11154cc:	d65f03c0 	ret

00000000011154d0 <mutex_unlock>:
	__mutex_unlock(m, NULL, -1);
 11154d0:	17ffff8c 	b	1115300 <__mutex_unlock.constprop.0>

00000000011154d4 <mutex_unlock_recursive>:
{
 11154d4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 11154d8:	910003fd 	mov	x29, sp
 11154dc:	a90153f3 	stp	x19, x20, [sp, #16]
 11154e0:	aa0003f3 	mov	x19, x0
	assert_have_no_spinlock();
 11154e4:	97fffef9 	bl	11150c8 <assert_have_no_spinlock>
	assert(m->owner == thread_get_id());
 11154e8:	79c03274 	ldrsh	w20, [x19, #24]
 11154ec:	97ffbfde 	bl	1105464 <thread_get_id>
 11154f0:	6b20a29f 	cmp	w20, w0, sxth
 11154f4:	54000140 	b.eq	111551c <mutex_unlock_recursive+0x48>  // b.none
 11154f8:	f00001e3 	adrp	x3, 1154000 <__func__.1786+0x8>
 11154fc:	f00001e1 	adrp	x1, 1154000 <__func__.1786+0x8>
 1115500:	912d9063 	add	x3, x3, #0xb64
 1115504:	9128e421 	add	x1, x1, #0xa39
 1115508:	f00001e0 	adrp	x0, 1154000 <__func__.1786+0x8>
 111550c:	912a5800 	add	x0, x0, #0xa96
 1115510:	52800e62 	mov	w2, #0x73                  	// #115
 1115514:	97fff366 	bl	11122ac <_assert_log>
 1115518:	97fff376 	bl	11122f0 <_assert_break>
	if (refcount_dec(&m->lock_depth)) {
 111551c:	91007260 	add	x0, x19, #0x1c
 1115520:	97fff823 	bl	11135ac <refcount_dec>
 1115524:	72001c1f 	tst	w0, #0xff
 1115528:	54000100 	b.eq	1115548 <mutex_unlock_recursive+0x74>  // b.none
	__compiler_atomic_store(p, val);
 111552c:	91006260 	add	x0, x19, #0x18
 1115530:	12800001 	mov	w1, #0xffffffff            	// #-1
 1115534:	79000001 	strh	w1, [x0]
		__mutex_unlock(&m->m, fname, lineno);
 1115538:	aa1303e0 	mov	x0, x19
}
 111553c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1115540:	a8c27bfd 	ldp	x29, x30, [sp], #32
		__mutex_unlock(&m->m, fname, lineno);
 1115544:	17ffff6f 	b	1115300 <__mutex_unlock.constprop.0>
}
 1115548:	a94153f3 	ldp	x19, x20, [sp, #16]
 111554c:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1115550:	d65f03c0 	ret

0000000001115554 <mutex_lock>:
	__mutex_lock(m, NULL, -1);
 1115554:	17ffff95 	b	11153a8 <__mutex_lock.constprop.0>

0000000001115558 <mutex_lock_recursive>:
{
 1115558:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 111555c:	910003fd 	mov	x29, sp
 1115560:	a90153f3 	stp	x19, x20, [sp, #16]
 1115564:	aa0003f3 	mov	x19, x0
 1115568:	a9025bf5 	stp	x21, x22, [sp, #32]
	short int ct = thread_get_id();
 111556c:	97ffbfbe 	bl	1105464 <thread_get_id>
 1115570:	13003c15 	sxth	w21, w0
	assert_have_no_spinlock();
 1115574:	97fffed5 	bl	11150c8 <assert_have_no_spinlock>
	assert(thread_is_in_normal_mode());
 1115578:	97ffbf88 	bl	1105398 <thread_is_in_normal_mode>
 111557c:	72001c1f 	tst	w0, #0xff
 1115580:	54000141 	b.ne	11155a8 <mutex_lock_recursive+0x50>  // b.any
 1115584:	f00001e3 	adrp	x3, 1154000 <__func__.1786+0x8>
 1115588:	f00001e1 	adrp	x1, 1154000 <__func__.1786+0x8>
 111558c:	f00001e0 	adrp	x0, 1154000 <__func__.1786+0x8>
 1115590:	912cf863 	add	x3, x3, #0xb3e
 1115594:	9128e421 	add	x1, x1, #0xa39
 1115598:	9129ec00 	add	x0, x0, #0xa7b
 111559c:	52800962 	mov	w2, #0x4b                  	// #75
	assert(m->owner == THREAD_ID_INVALID);
 11155a0:	97fff343 	bl	11122ac <_assert_log>
 11155a4:	97fff353 	bl	11122f0 <_assert_break>
 11155a8:	2a1503f4 	mov	w20, w21
	if (atomic_load_short(&m->owner) == ct) {
 11155ac:	91006276 	add	x22, x19, #0x18
	return __compiler_atomic_load(p);
 11155b0:	794002c0 	ldrh	w0, [x22]
 11155b4:	6b20a2bf 	cmp	w21, w0, sxth
 11155b8:	91007275 	add	x21, x19, #0x1c
 11155bc:	54000181 	b.ne	11155ec <mutex_lock_recursive+0x94>  // b.any
		if (!refcount_inc(&m->lock_depth))
 11155c0:	aa1503e0 	mov	x0, x21
 11155c4:	97fff7ec 	bl	1113574 <refcount_inc>
 11155c8:	72001c1f 	tst	w0, #0xff
 11155cc:	54000301 	b.ne	111562c <mutex_lock_recursive+0xd4>  // b.any
			panic();
 11155d0:	f00001e2 	adrp	x2, 1154000 <__func__.1786+0x8>
 11155d4:	f00001e0 	adrp	x0, 1154000 <__func__.1786+0x8>
 11155d8:	912cf842 	add	x2, x2, #0xb3e
 11155dc:	9128e400 	add	x0, x0, #0xa39
 11155e0:	d2800003 	mov	x3, #0x0                   	// #0
 11155e4:	528009e1 	mov	w1, #0x4f                  	// #79
 11155e8:	97fff7a0 	bl	1113468 <__do_panic>
	__mutex_lock(&m->m, fname, lineno);
 11155ec:	aa1303e0 	mov	x0, x19
 11155f0:	97ffff6e 	bl	11153a8 <__mutex_lock.constprop.0>
	assert(m->owner == THREAD_ID_INVALID);
 11155f4:	79c03260 	ldrsh	w0, [x19, #24]
 11155f8:	3100041f 	cmn	w0, #0x1
 11155fc:	54000120 	b.eq	1115620 <mutex_lock_recursive+0xc8>  // b.none
 1115600:	f00001e3 	adrp	x3, 1154000 <__func__.1786+0x8>
 1115604:	f00001e1 	adrp	x1, 1154000 <__func__.1786+0x8>
 1115608:	f00001e0 	adrp	x0, 1154000 <__func__.1786+0x8>
 111560c:	912cf863 	add	x3, x3, #0xb3e
 1115610:	9128e421 	add	x1, x1, #0xa39
 1115614:	912ac800 	add	x0, x0, #0xab2
 1115618:	52800aa2 	mov	w2, #0x55                  	// #85
 111561c:	17ffffe1 	b	11155a0 <mutex_lock_recursive+0x48>
	__compiler_atomic_store(p, val);
 1115620:	790002d4 	strh	w20, [x22]
	__compiler_atomic_store(p, val);
 1115624:	52800020 	mov	w0, #0x1                   	// #1
 1115628:	b90002a0 	str	w0, [x21]
}
 111562c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1115630:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1115634:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1115638:	d65f03c0 	ret

000000000111563c <mutex_trylock>:
{
 111563c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1115640:	910003fd 	mov	x29, sp
 1115644:	a90153f3 	stp	x19, x20, [sp, #16]
 1115648:	aa0003f3 	mov	x19, x0
	assert_have_no_spinlock();
 111564c:	97fffe9f 	bl	11150c8 <assert_have_no_spinlock>
	assert(thread_get_id_may_fail() != THREAD_ID_INVALID);
 1115650:	97ffbf67 	bl	11053ec <thread_get_id_may_fail>
 1115654:	13003c00 	sxth	w0, w0
 1115658:	3100041f 	cmn	w0, #0x1
 111565c:	f00001e0 	adrp	x0, 1154000 <__func__.1786+0x8>
 1115660:	54000121 	b.ne	1115684 <mutex_trylock+0x48>  // b.any
 1115664:	912df403 	add	x3, x0, #0xb7d
 1115668:	f00001e1 	adrp	x1, 1154000 <__func__.1786+0x8>
 111566c:	f00001e0 	adrp	x0, 1154000 <__func__.1786+0x8>
 1115670:	9128e421 	add	x1, x1, #0xa39
 1115674:	91293400 	add	x0, x0, #0xa4d
 1115678:	528010c2 	mov	w2, #0x86                  	// #134
 111567c:	97fff30c 	bl	11122ac <_assert_log>
 1115680:	97fff31c 	bl	11122f0 <_assert_break>
	old_itr_status = cpu_spin_lock_xsave(&m->spin_lock);
 1115684:	52801101 	mov	w1, #0x88                  	// #136
 1115688:	aa1303e2 	mov	x2, x19
 111568c:	912df400 	add	x0, x0, #0xb7d
 1115690:	97fffece 	bl	11151c8 <cpu_spin_lock_xsave_dldetect>
 1115694:	2a0003e1 	mov	w1, w0
	can_lock_write = !m->state;
 1115698:	79c02260 	ldrsh	w0, [x19, #16]
 111569c:	7100001f 	cmp	w0, #0x0
 11156a0:	1a9f17f4 	cset	w20, eq  // eq = none
	if (can_lock_write)
 11156a4:	35000060 	cbnz	w0, 11156b0 <mutex_trylock+0x74>
		m->state = -1;
 11156a8:	12800000 	mov	w0, #0xffffffff            	// #-1
 11156ac:	79002260 	strh	w0, [x19, #16]
	cpu_spin_unlock_xrestore(&m->spin_lock, old_itr_status);
 11156b0:	aa1303e0 	mov	x0, x19
 11156b4:	97fffeec 	bl	1115264 <cpu_spin_unlock_xrestore>
}
 11156b8:	2a1403e0 	mov	w0, w20
 11156bc:	a94153f3 	ldp	x19, x20, [sp, #16]
 11156c0:	a8c27bfd 	ldp	x29, x30, [sp], #32
 11156c4:	d65f03c0 	ret

00000000011156c8 <mutex_read_unlock>:
{
 11156c8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 11156cc:	910003fd 	mov	x29, sp
 11156d0:	a90153f3 	stp	x19, x20, [sp, #16]
 11156d4:	aa0003f3 	mov	x19, x0
 11156d8:	f90013f5 	str	x21, [sp, #32]
	assert_have_no_spinlock();
 11156dc:	97fffe7b 	bl	11150c8 <assert_have_no_spinlock>
	assert(thread_get_id_may_fail() != THREAD_ID_INVALID);
 11156e0:	97ffbf43 	bl	11053ec <thread_get_id_may_fail>
 11156e4:	13003c00 	sxth	w0, w0
 11156e8:	3100041f 	cmn	w0, #0x1
 11156ec:	f00001e3 	adrp	x3, 1154000 <__func__.1786+0x8>
 11156f0:	54000121 	b.ne	1115714 <mutex_read_unlock+0x4c>  // b.any
 11156f4:	912e3463 	add	x3, x3, #0xb8d
 11156f8:	f00001e1 	adrp	x1, 1154000 <__func__.1786+0x8>
 11156fc:	f00001e0 	adrp	x0, 1154000 <__func__.1786+0x8>
 1115700:	9128e421 	add	x1, x1, #0xa39
 1115704:	91293400 	add	x0, x0, #0xa4d
 1115708:	52801382 	mov	w2, #0x9c                  	// #156
 111570c:	97fff2e8 	bl	11122ac <_assert_log>
 1115710:	97fff2f8 	bl	11122f0 <_assert_break>
	old_itr_status = cpu_spin_lock_xsave(&m->spin_lock);
 1115714:	912e3475 	add	x21, x3, #0xb8d
 1115718:	528013c1 	mov	w1, #0x9e                  	// #158
 111571c:	aa1303e2 	mov	x2, x19
 1115720:	aa1503e0 	mov	x0, x21
 1115724:	97fffea9 	bl	11151c8 <cpu_spin_lock_xsave_dldetect>
	if (m->state <= 0)
 1115728:	79c02274 	ldrsh	w20, [x19, #16]
	old_itr_status = cpu_spin_lock_xsave(&m->spin_lock);
 111572c:	2a0003e1 	mov	w1, w0
	if (m->state <= 0)
 1115730:	7100029f 	cmp	w20, #0x0
 1115734:	540000ec 	b.gt	1115750 <mutex_read_unlock+0x88>
		panic();
 1115738:	f00001e0 	adrp	x0, 1154000 <__func__.1786+0x8>
 111573c:	aa1503e2 	mov	x2, x21
 1115740:	9128e400 	add	x0, x0, #0xa39
 1115744:	d2800003 	mov	x3, #0x0                   	// #0
 1115748:	52801421 	mov	w1, #0xa1                  	// #161
 111574c:	97fff747 	bl	1113468 <__do_panic>
	m->state--;
 1115750:	51000694 	sub	w20, w20, #0x1
	cpu_spin_unlock_xrestore(&m->spin_lock, old_itr_status);
 1115754:	aa1303e0 	mov	x0, x19
	m->state--;
 1115758:	12003e94 	and	w20, w20, #0xffff
 111575c:	79002274 	strh	w20, [x19, #16]
	cpu_spin_unlock_xrestore(&m->spin_lock, old_itr_status);
 1115760:	97fffec1 	bl	1115264 <cpu_spin_unlock_xrestore>
	if (!new_state)
 1115764:	35000134 	cbnz	w20, 1115788 <mutex_read_unlock+0xc0>
		wq_wake_next(&m->wq, m, fname, lineno);
 1115768:	aa1303e1 	mov	x1, x19
 111576c:	91002260 	add	x0, x19, #0x8
}
 1115770:	a94153f3 	ldp	x19, x20, [sp, #16]
		wq_wake_next(&m->wq, m, fname, lineno);
 1115774:	12800003 	mov	w3, #0xffffffff            	// #-1
}
 1115778:	f94013f5 	ldr	x21, [sp, #32]
		wq_wake_next(&m->wq, m, fname, lineno);
 111577c:	d2800002 	mov	x2, #0x0                   	// #0
}
 1115780:	a8c37bfd 	ldp	x29, x30, [sp], #48
		wq_wake_next(&m->wq, m, fname, lineno);
 1115784:	140001b8 	b	1115e64 <wq_wake_next>
}
 1115788:	a94153f3 	ldp	x19, x20, [sp, #16]
 111578c:	f94013f5 	ldr	x21, [sp, #32]
 1115790:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1115794:	d65f03c0 	ret

0000000001115798 <mutex_read_lock>:
{
 1115798:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
 111579c:	910003fd 	mov	x29, sp
 11157a0:	a90153f3 	stp	x19, x20, [sp, #16]
 11157a4:	aa0003f3 	mov	x19, x0
	assert_have_no_spinlock();
 11157a8:	f00001f4 	adrp	x20, 1154000 <__func__.1786+0x8>
{
 11157ac:	a9025bf5 	stp	x21, x22, [sp, #32]
 11157b0:	a90363f7 	stp	x23, x24, [sp, #48]
	assert_have_no_spinlock();
 11157b4:	97fffe45 	bl	11150c8 <assert_have_no_spinlock>
	assert(thread_get_id_may_fail() != THREAD_ID_INVALID);
 11157b8:	97ffbf0d 	bl	11053ec <thread_get_id_may_fail>
 11157bc:	13003c00 	sxth	w0, w0
 11157c0:	3100041f 	cmn	w0, #0x1
 11157c4:	54000121 	b.ne	11157e8 <mutex_read_lock+0x50>  // b.any
 11157c8:	f00001e1 	adrp	x1, 1154000 <__func__.1786+0x8>
 11157cc:	f00001e0 	adrp	x0, 1154000 <__func__.1786+0x8>
 11157d0:	912e8683 	add	x3, x20, #0xba1
 11157d4:	9128e421 	add	x1, x1, #0xa39
 11157d8:	91293400 	add	x0, x0, #0xa4d
 11157dc:	528015e2 	mov	w2, #0xaf                  	// #175
	assert(thread_is_in_normal_mode());
 11157e0:	97fff2b3 	bl	11122ac <_assert_log>
 11157e4:	97fff2c3 	bl	11122f0 <_assert_break>
 11157e8:	97ffbeec 	bl	1105398 <thread_is_in_normal_mode>
 11157ec:	72001c1f 	tst	w0, #0xff
 11157f0:	540003a0 	b.eq	1115864 <mutex_read_lock+0xcc>  // b.none
		old_itr_status = cpu_spin_lock_xsave(&m->spin_lock);
 11157f4:	912e8694 	add	x20, x20, #0xba1
 11157f8:	910123f8 	add	x24, sp, #0x48
			wq_wait_init(&m->wq, &wqe, true /* wait_read */);
 11157fc:	91002277 	add	x23, x19, #0x8
		old_itr_status = cpu_spin_lock_xsave(&m->spin_lock);
 1115800:	aa1303e2 	mov	x2, x19
 1115804:	aa1403e0 	mov	x0, x20
 1115808:	52801801 	mov	w1, #0xc0                  	// #192
 111580c:	97fffe6f 	bl	11151c8 <cpu_spin_lock_xsave_dldetect>
		can_lock = m->state != -1;
 1115810:	79c02275 	ldrsh	w21, [x19, #16]
		old_itr_status = cpu_spin_lock_xsave(&m->spin_lock);
 1115814:	2a0003f6 	mov	w22, w0
		if (!can_lock) {
 1115818:	310006bf 	cmn	w21, #0x1
 111581c:	54000321 	b.ne	1115880 <mutex_read_lock+0xe8>  // b.any
 1115820:	aa1803e1 	mov	x1, x24
 1115824:	aa1703e0 	mov	x0, x23
 1115828:	52800023 	mov	w3, #0x1                   	// #1
 111582c:	d2800002 	mov	x2, #0x0                   	// #0
 1115830:	9400013d 	bl	1115d24 <wq_wait_init_condvar>
		cpu_spin_unlock_xrestore(&m->spin_lock, old_itr_status);
 1115834:	2a1603e1 	mov	w1, w22
 1115838:	aa1303e0 	mov	x0, x19
 111583c:	97fffe8a 	bl	1115264 <cpu_spin_unlock_xrestore>
		if (!can_lock) {
 1115840:	310006bf 	cmn	w21, #0x1
 1115844:	54000241 	b.ne	111588c <mutex_read_lock+0xf4>  // b.any
			wq_wait_final(&m->wq, &wqe, m, fname, lineno);
 1115848:	2a1503e4 	mov	w4, w21
 111584c:	aa1303e2 	mov	x2, x19
 1115850:	aa1803e1 	mov	x1, x24
 1115854:	aa1703e0 	mov	x0, x23
 1115858:	d2800003 	mov	x3, #0x0                   	// #0
 111585c:	94000154 	bl	1115dac <wq_wait_final>
 1115860:	17ffffe8 	b	1115800 <mutex_read_lock+0x68>
	assert(thread_is_in_normal_mode());
 1115864:	f00001e1 	adrp	x1, 1154000 <__func__.1786+0x8>
 1115868:	f00001e0 	adrp	x0, 1154000 <__func__.1786+0x8>
 111586c:	912e8683 	add	x3, x20, #0xba1
 1115870:	9128e421 	add	x1, x1, #0xa39
 1115874:	9129ec00 	add	x0, x0, #0xa7b
 1115878:	52801602 	mov	w2, #0xb0                  	// #176
 111587c:	17ffffd9 	b	11157e0 <mutex_read_lock+0x48>
			m->state++; /* read_locked */
 1115880:	110006a0 	add	w0, w21, #0x1
 1115884:	79002260 	strh	w0, [x19, #16]
 1115888:	17ffffeb 	b	1115834 <mutex_read_lock+0x9c>
}
 111588c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1115890:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1115894:	a94363f7 	ldp	x23, x24, [sp, #48]
 1115898:	a8c67bfd 	ldp	x29, x30, [sp], #96
 111589c:	d65f03c0 	ret

00000000011158a0 <mutex_destroy>:
{
 11158a0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 11158a4:	910003fd 	mov	x29, sp
	if (m->state)
 11158a8:	79c02001 	ldrsh	w1, [x0, #16]
 11158ac:	34000101 	cbz	w1, 11158cc <mutex_destroy+0x2c>
		panic();
 11158b0:	f00001e2 	adrp	x2, 1154000 <__func__.1786+0x8>
 11158b4:	912ecc42 	add	x2, x2, #0xbb3
 11158b8:	d2800003 	mov	x3, #0x0                   	// #0
 11158bc:	528028c1 	mov	w1, #0x146                 	// #326
		panic("waitqueue not empty");
 11158c0:	f00001e0 	adrp	x0, 1154000 <__func__.1786+0x8>
 11158c4:	9128e400 	add	x0, x0, #0xa39
 11158c8:	97fff6e8 	bl	1113468 <__do_panic>
	if (!wq_is_empty(&m->wq))
 11158cc:	91002000 	add	x0, x0, #0x8
 11158d0:	940001fa 	bl	11160b8 <wq_is_empty>
 11158d4:	72001c1f 	tst	w0, #0xff
 11158d8:	540000e1 	b.ne	11158f4 <mutex_destroy+0x54>  // b.any
		panic("waitqueue not empty");
 11158dc:	f00001e3 	adrp	x3, 1154000 <__func__.1786+0x8>
 11158e0:	f00001e2 	adrp	x2, 1154000 <__func__.1786+0x8>
 11158e4:	912b4063 	add	x3, x3, #0xad0
 11158e8:	912ecc42 	add	x2, x2, #0xbb3
 11158ec:	52802901 	mov	w1, #0x148                 	// #328
 11158f0:	17fffff4 	b	11158c0 <mutex_destroy+0x20>
}
 11158f4:	a8c17bfd 	ldp	x29, x30, [sp], #16
 11158f8:	d65f03c0 	ret

00000000011158fc <mutex_get_recursive_lock_depth>:
{
 11158fc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1115900:	910003fd 	mov	x29, sp
 1115904:	a90153f3 	stp	x19, x20, [sp, #16]
 1115908:	aa0003f3 	mov	x19, x0
	assert_have_no_spinlock();
 111590c:	97fffdef 	bl	11150c8 <assert_have_no_spinlock>
	assert(m->owner == thread_get_id());
 1115910:	79c03274 	ldrsh	w20, [x19, #24]
 1115914:	97ffbed4 	bl	1105464 <thread_get_id>
 1115918:	6b20a29f 	cmp	w20, w0, sxth
 111591c:	54000140 	b.eq	1115944 <mutex_get_recursive_lock_depth+0x48>  // b.none
 1115920:	f00001e3 	adrp	x3, 1154000 <__func__.1786+0x8>
 1115924:	f00001e1 	adrp	x1, 1154000 <__func__.1786+0x8>
 1115928:	912f0463 	add	x3, x3, #0xbc1
 111592c:	9128e421 	add	x1, x1, #0xa39
 1115930:	f00001e0 	adrp	x0, 1154000 <__func__.1786+0x8>
 1115934:	912a5800 	add	x0, x0, #0xa96
 1115938:	52802a82 	mov	w2, #0x154                 	// #340
 111593c:	97fff25c 	bl	11122ac <_assert_log>
 1115940:	97fff26c 	bl	11122f0 <_assert_break>
	return __compiler_atomic_load(p);
 1115944:	91007273 	add	x19, x19, #0x1c
 1115948:	b9400260 	ldr	w0, [x19]
}
 111594c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1115950:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1115954:	d65f03c0 	ret

0000000001115958 <condvar_init>:
	*cv = (struct condvar)CONDVAR_INITIALIZER;
 1115958:	a9007c1f 	stp	xzr, xzr, [x0]
}
 111595c:	d65f03c0 	ret

0000000001115960 <condvar_destroy>:
{
 1115960:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1115964:	910003fd 	mov	x29, sp
 1115968:	f9000bf3 	str	x19, [sp, #16]
 111596c:	aa0003f3 	mov	x19, x0
	if (cv->m && wq_have_condvar(&cv->m->wq, cv))
 1115970:	f9400400 	ldr	x0, [x0, #8]
 1115974:	b40001a0 	cbz	x0, 11159a8 <condvar_destroy+0x48>
 1115978:	aa1303e1 	mov	x1, x19
 111597c:	91002000 	add	x0, x0, #0x8
 1115980:	940001b1 	bl	1116044 <wq_have_condvar>
 1115984:	72001c1f 	tst	w0, #0xff
 1115988:	54000100 	b.eq	11159a8 <condvar_destroy+0x48>  // b.none
		panic();
 111598c:	f00001e2 	adrp	x2, 1154000 <__func__.1786+0x8>
 1115990:	f00001e0 	adrp	x0, 1154000 <__func__.1786+0x8>
 1115994:	912f8042 	add	x2, x2, #0xbe0
 1115998:	9128e400 	add	x0, x0, #0xa39
 111599c:	d2800003 	mov	x3, #0x0                   	// #0
 11159a0:	52802c21 	mov	w1, #0x161                 	// #353
 11159a4:	97fff6b1 	bl	1113468 <__do_panic>
	*cv = (struct condvar)CONDVAR_INITIALIZER;
 11159a8:	a9007e7f 	stp	xzr, xzr, [x19]
}
 11159ac:	f9400bf3 	ldr	x19, [sp, #16]
 11159b0:	a8c27bfd 	ldp	x29, x30, [sp], #32
 11159b4:	d65f03c0 	ret

00000000011159b8 <condvar_signal>:
}

#else
void condvar_signal(struct condvar *cv)
{
	cv_signal(cv, true /* only one */, NULL, -1);
 11159b8:	52800021 	mov	w1, #0x1                   	// #1
 11159bc:	17fffe33 	b	1115288 <cv_signal.constprop.0>

00000000011159c0 <condvar_broadcast>:
}

void condvar_broadcast(struct condvar *cv)
{
	cv_signal(cv, false /* all */, NULL, -1);
 11159c0:	52800001 	mov	w1, #0x0                   	// #0
 11159c4:	17fffe31 	b	1115288 <cv_signal.constprop.0>

00000000011159c8 <condvar_wait>:
{
	__condvar_wait(cv, m, fname, lineno);
}
#else
void condvar_wait(struct condvar *cv, struct mutex *m)
{
 11159c8:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
	old_itr_status = cpu_spin_lock_xsave(&cv->spin_lock);
 11159cc:	aa0003e2 	mov	x2, x0
{
 11159d0:	910003fd 	mov	x29, sp
 11159d4:	a90153f3 	stp	x19, x20, [sp, #16]
 11159d8:	aa0003f4 	mov	x20, x0
 11159dc:	aa0103f3 	mov	x19, x1
 11159e0:	a9025bf5 	stp	x21, x22, [sp, #32]
	old_itr_status = cpu_spin_lock_xsave(&cv->spin_lock);
 11159e4:	f00001f5 	adrp	x21, 1154000 <__func__.1786+0x8>
 11159e8:	912feab6 	add	x22, x21, #0xbfa
 11159ec:	aa1603e0 	mov	x0, x22
 11159f0:	528032e1 	mov	w1, #0x197                 	// #407
{
 11159f4:	a90363f7 	stp	x23, x24, [sp, #48]
	old_itr_status = cpu_spin_lock_xsave(&cv->spin_lock);
 11159f8:	97fffdf4 	bl	11151c8 <cpu_spin_lock_xsave_dldetect>
 11159fc:	2a0003f7 	mov	w23, w0
	if (cv->m && cv->m != m)
 1115a00:	f9400680 	ldr	x0, [x20, #8]
 1115a04:	b4000140 	cbz	x0, 1115a2c <condvar_wait+0x64>
 1115a08:	eb00027f 	cmp	x19, x0
 1115a0c:	54000100 	b.eq	1115a2c <condvar_wait+0x64>  // b.none
		panic("invalid mutex");
 1115a10:	f00001e3 	adrp	x3, 1154000 <__func__.1786+0x8>
 1115a14:	aa1603e2 	mov	x2, x22
 1115a18:	912b9063 	add	x3, x3, #0xae4
 1115a1c:	52803321 	mov	w1, #0x199                 	// #409
		panic();
 1115a20:	f00001e0 	adrp	x0, 1154000 <__func__.1786+0x8>
 1115a24:	9128e400 	add	x0, x0, #0xa39
 1115a28:	97fff690 	bl	1113468 <__do_panic>
	cv->m = m;
 1115a2c:	f9000693 	str	x19, [x20, #8]
	cpu_spin_unlock(&cv->spin_lock);
 1115a30:	aa1403e0 	mov	x0, x20
	cpu_spin_lock(&m->spin_lock);
 1115a34:	912feab5 	add	x21, x21, #0xbfa
	cpu_spin_unlock(&cv->spin_lock);
 1115a38:	97fffdf7 	bl	1115214 <cpu_spin_unlock>
	cpu_spin_lock(&m->spin_lock);
 1115a3c:	aa1303e2 	mov	x2, x19
 1115a40:	aa1503e0 	mov	x0, x21
 1115a44:	528033c1 	mov	w1, #0x19e                 	// #414
 1115a48:	97fffdb0 	bl	1115108 <cpu_spin_lock_dldetect>
	if (!m->state)
 1115a4c:	79c02276 	ldrsh	w22, [x19, #16]
 1115a50:	710002df 	cmp	w22, #0x0
 1115a54:	350000b6 	cbnz	w22, 1115a68 <condvar_wait+0xa0>
		panic();
 1115a58:	aa1503e2 	mov	x2, x21
 1115a5c:	d2800003 	mov	x3, #0x0                   	// #0
 1115a60:	52803421 	mov	w1, #0x1a1                 	// #417
 1115a64:	17ffffef 	b	1115a20 <condvar_wait+0x58>
	wq_wait_init_condvar(&m->wq, &wqe, cv, m->state > 0);
 1115a68:	91002275 	add	x21, x19, #0x8
 1115a6c:	910123f8 	add	x24, sp, #0x48
 1115a70:	1a9fd7e3 	cset	w3, gt
 1115a74:	aa1403e2 	mov	x2, x20
 1115a78:	aa1803e1 	mov	x1, x24
 1115a7c:	aa1503e0 	mov	x0, x21
 1115a80:	940000a9 	bl	1115d24 <wq_wait_init_condvar>
	if (m->state > 1) {
 1115a84:	79c02260 	ldrsh	w0, [x19, #16]
	cpu_spin_unlock_xrestore(&m->spin_lock, old_itr_status);
 1115a88:	2a1703e1 	mov	w1, w23
		m->state--;
 1115a8c:	51000414 	sub	w20, w0, #0x1
 1115a90:	7100041f 	cmp	w0, #0x1
	cpu_spin_unlock_xrestore(&m->spin_lock, old_itr_status);
 1115a94:	aa1303e0 	mov	x0, x19
		m->state--;
 1115a98:	13003e94 	sxth	w20, w20
 1115a9c:	1a9fc294 	csel	w20, w20, wzr, gt
 1115aa0:	79002274 	strh	w20, [x19, #16]
	cpu_spin_unlock_xrestore(&m->spin_lock, old_itr_status);
 1115aa4:	97fffdf0 	bl	1115264 <cpu_spin_unlock_xrestore>
	if (!new_state)
 1115aa8:	350000d4 	cbnz	w20, 1115ac0 <condvar_wait+0xf8>
		wq_wake_next(&m->wq, m, fname, lineno);
 1115aac:	aa1303e1 	mov	x1, x19
 1115ab0:	aa1503e0 	mov	x0, x21
 1115ab4:	12800003 	mov	w3, #0xffffffff            	// #-1
 1115ab8:	d2800002 	mov	x2, #0x0                   	// #0
 1115abc:	940000ea 	bl	1115e64 <wq_wake_next>
	wq_wait_final(&m->wq, &wqe, m, fname, lineno);
 1115ac0:	aa1503e0 	mov	x0, x21
 1115ac4:	aa1303e2 	mov	x2, x19
 1115ac8:	aa1803e1 	mov	x1, x24
 1115acc:	12800004 	mov	w4, #0xffffffff            	// #-1
 1115ad0:	d2800003 	mov	x3, #0x0                   	// #0
 1115ad4:	940000b6 	bl	1115dac <wq_wait_final>
		mutex_read_lock(m);
 1115ad8:	aa1303e0 	mov	x0, x19
	if (old_state > 0)
 1115adc:	710002df 	cmp	w22, #0x0
 1115ae0:	540000ed 	b.le	1115afc <condvar_wait+0x134>
		mutex_read_lock(m);
 1115ae4:	97ffff2d 	bl	1115798 <mutex_read_lock>
	__condvar_wait(cv, m, NULL, -1);
}
 1115ae8:	a94153f3 	ldp	x19, x20, [sp, #16]
 1115aec:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1115af0:	a94363f7 	ldp	x23, x24, [sp, #48]
 1115af4:	a8c67bfd 	ldp	x29, x30, [sp], #96
 1115af8:	d65f03c0 	ret
		mutex_lock(m);
 1115afc:	97fffe96 	bl	1115554 <mutex_lock>
}
 1115b00:	17fffffa 	b	1115ae8 <condvar_wait+0x120>

0000000001115b04 <cpu_spin_lock_xsave_dldetect.constprop.0>:
static inline uint32_t cpu_spin_lock_xsave_dldetect(const char *func,
 1115b04:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 1115b08:	910003fd 	mov	x29, sp
 1115b0c:	a90153f3 	stp	x19, x20, [sp, #16]
 1115b10:	a9025bf5 	stp	x21, x22, [sp, #32]
 1115b14:	a90363f7 	stp	x23, x24, [sp, #48]
 1115b18:	aa0003f7 	mov	x23, x0
 1115b1c:	2a0103f8 	mov	w24, w1
	uint32_t exceptions = thread_mask_exceptions(THREAD_EXCP_ALL);
 1115b20:	528000e0 	mov	w0, #0x7                   	// #7
static inline uint32_t cpu_spin_lock_xsave_dldetect(const char *func,
 1115b24:	a9046bf9 	stp	x25, x26, [sp, #64]
	uint32_t exceptions = thread_mask_exceptions(THREAD_EXCP_ALL);
 1115b28:	97ffbd84 	bl	1105138 <thread_mask_exceptions>
 1115b2c:	2a0003f4 	mov	w20, w0
 1115b30:	97ffbcf9 	bl	1104f14 <thread_get_exceptions>
	assert(thread_foreign_intr_disabled());
 1115b34:	36080260 	tbz	w0, #1, 1115b80 <cpu_spin_lock_xsave_dldetect.constprop.0+0x7c>
	while (__cpu_spin_trylock(lock)) {
 1115b38:	f0000295 	adrp	x21, 1168000 <data.5093+0x9e28>
			trace_printf(func, line, TRACE_ERROR, true,
 1115b3c:	900001f9 	adrp	x25, 1151000 <small_prime+0x168>
	while (__cpu_spin_trylock(lock)) {
 1115b40:	9129f2b5 	add	x21, x21, #0xa7c
			trace_printf(func, line, TRACE_ERROR, true,
 1115b44:	91131739 	add	x25, x25, #0x4c5
 1115b48:	52800013 	mov	w19, #0x0                   	// #0
		if (!retries) {
 1115b4c:	d2c0003a 	mov	x26, #0x100000000           	// #4294967296
	unsigned int reminder = 0;
 1115b50:	d2800016 	mov	x22, #0x0                   	// #0
	while (__cpu_spin_trylock(lock)) {
 1115b54:	aa1503e0 	mov	x0, x21
 1115b58:	97ffba53 	bl	11044a4 <__cpu_spin_trylock>
 1115b5c:	35000240 	cbnz	w0, 1115ba4 <cpu_spin_lock_xsave_dldetect.constprop.0+0xa0>
	spinlock_count_incr();
 1115b60:	97ffba5a 	bl	11044c8 <spinlock_count_incr>
}
 1115b64:	2a1403e0 	mov	w0, w20
 1115b68:	a94153f3 	ldp	x19, x20, [sp, #16]
 1115b6c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1115b70:	a94363f7 	ldp	x23, x24, [sp, #48]
 1115b74:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1115b78:	a8c57bfd 	ldp	x29, x30, [sp], #80
 1115b7c:	d65f03c0 	ret
	assert(thread_foreign_intr_disabled());
 1115b80:	f00001e3 	adrp	x3, 1154000 <__func__.1786+0x8>
 1115b84:	900001e1 	adrp	x1, 1151000 <small_prime+0x168>
 1115b88:	91320463 	add	x3, x3, #0xc81
 1115b8c:	9111f821 	add	x1, x1, #0x47e
 1115b90:	900001e0 	adrp	x0, 1151000 <small_prime+0x168>
 1115b94:	91129800 	add	x0, x0, #0x4a6
 1115b98:	528006e2 	mov	w2, #0x37                  	// #55
 1115b9c:	97fff1c4 	bl	11122ac <_assert_log>
 1115ba0:	97fff1d4 	bl	11122f0 <_assert_break>
		if (!retries) {
 1115ba4:	910006d6 	add	x22, x22, #0x1
 1115ba8:	eb1a02df 	cmp	x22, x26
 1115bac:	54fffd41 	b.ne	1115b54 <cpu_spin_lock_xsave_dldetect.constprop.0+0x50>  // b.any
			trace_printf(func, line, TRACE_ERROR, true,
 1115bb0:	2a1303e5 	mov	w5, w19
 1115bb4:	aa1903e4 	mov	x4, x25
 1115bb8:	2a1803e1 	mov	w1, w24
 1115bbc:	aa1703e0 	mov	x0, x23
 1115bc0:	52800023 	mov	w3, #0x1                   	// #1
 1115bc4:	52800022 	mov	w2, #0x1                   	// #1
 1115bc8:	9400bc5f 	bl	1144d44 <trace_printf>
			if (reminder < UINT_MAX)
 1115bcc:	3100067f 	cmn	w19, #0x1
 1115bd0:	54fffc00 	b.eq	1115b50 <cpu_spin_lock_xsave_dldetect.constprop.0+0x4c>  // b.none
				reminder++;
 1115bd4:	11000673 	add	w19, w19, #0x1
 1115bd8:	17ffffde 	b	1115b50 <cpu_spin_lock_xsave_dldetect.constprop.0+0x4c>

0000000001115bdc <cpu_spin_unlock.constprop.0>:
static inline void cpu_spin_unlock(unsigned int *lock)
 1115bdc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 1115be0:	910003fd 	mov	x29, sp
 1115be4:	97ffbccc 	bl	1104f14 <thread_get_exceptions>
	assert(thread_foreign_intr_disabled());
 1115be8:	37080140 	tbnz	w0, #1, 1115c10 <cpu_spin_unlock.constprop.0+0x34>
 1115bec:	f00001e3 	adrp	x3, 1154000 <__func__.1786+0x8>
 1115bf0:	900001e1 	adrp	x1, 1151000 <small_prime+0x168>
 1115bf4:	91326063 	add	x3, x3, #0xc98
 1115bf8:	9111f821 	add	x1, x1, #0x47e
 1115bfc:	900001e0 	adrp	x0, 1151000 <small_prime+0x168>
 1115c00:	91129800 	add	x0, x0, #0x4a6
 1115c04:	52800b82 	mov	w2, #0x5c                  	// #92
 1115c08:	97fff1a9 	bl	11122ac <_assert_log>
 1115c0c:	97fff1b9 	bl	11122f0 <_assert_break>
	__cpu_spin_unlock(lock);
 1115c10:	f0000280 	adrp	x0, 1168000 <data.5093+0x9e28>
 1115c14:	9129f000 	add	x0, x0, #0xa7c
 1115c18:	97ffba2a 	bl	11044c0 <__cpu_spin_unlock>
}
 1115c1c:	a8c17bfd 	ldp	x29, x30, [sp], #16
	spinlock_count_decr();
 1115c20:	17ffba3c 	b	1104510 <spinlock_count_decr>

0000000001115c24 <__wq_rpc>:
 * Note: this function is weak just to make it possible to exclude it from
 * the unpaged area.
 */
void __weak __wq_rpc(uint32_t func, int id, const void *sync_obj __maybe_unused,
		     const char *fname, int lineno __maybe_unused)
{
 1115c24:	d101c3ff 	sub	sp, sp, #0x70
	uint32_t ret;
	const char *cmd_str __maybe_unused =
	     func == OPTEE_RPC_WAIT_QUEUE_SLEEP ? "sleep" : "wake ";
 1115c28:	f00001e5 	adrp	x5, 1154000 <__func__.1786+0x8>
 1115c2c:	91303ca5 	add	x5, x5, #0xc0f
{
 1115c30:	aa0203e7 	mov	x7, x2
 1115c34:	a9017bfd 	stp	x29, x30, [sp, #16]
 1115c38:	910043fd 	add	x29, sp, #0x10
 1115c3c:	a90253f3 	stp	x19, x20, [sp, #32]
	     func == OPTEE_RPC_WAIT_QUEUE_SLEEP ? "sleep" : "wake ";
 1115c40:	f00001f3 	adrp	x19, 1154000 <__func__.1786+0x8>
 1115c44:	91302673 	add	x19, x19, #0xc09
{
 1115c48:	a9035bf5 	stp	x21, x22, [sp, #48]
 1115c4c:	2a0003f5 	mov	w21, w0
	     func == OPTEE_RPC_WAIT_QUEUE_SLEEP ? "sleep" : "wake ";
 1115c50:	710002bf 	cmp	w21, #0x0
{
 1115c54:	f90023f7 	str	x23, [sp, #64]
 1115c58:	2a0103f4 	mov	w20, w1
	     func == OPTEE_RPC_WAIT_QUEUE_SLEEP ? "sleep" : "wake ";
 1115c5c:	9a850273 	csel	x19, x19, x5, eq  // eq = none

	if (fname)
 1115c60:	f00001f6 	adrp	x22, 1154000 <__func__.1786+0x8>
 1115c64:	b40004c3 	cbz	x3, 1115cfc <__wq_rpc+0xd8>
		DMSG("%s thread %u %p %s:%d", cmd_str, id,
 1115c68:	f90003e3 	str	x3, [sp]
 1115c6c:	2a0103e6 	mov	w6, w1
 1115c70:	b9000be4 	str	w4, [sp, #8]
 1115c74:	aa1303e5 	mov	x5, x19
 1115c78:	f00001e4 	adrp	x4, 1154000 <__func__.1786+0x8>
 1115c7c:	9132a2c0 	add	x0, x22, #0xca8
 1115c80:	91305484 	add	x4, x4, #0xc15
 1115c84:	52800062 	mov	w2, #0x3                   	// #3
 1115c88:	52800461 	mov	w1, #0x23                  	// #35
 1115c8c:	52800023 	mov	w3, #0x1                   	// #1
 1115c90:	9400bc2d 	bl	1144d44 <trace_printf>
		     sync_obj, fname, lineno);
	else
		DMSG("%s thread %u %p", cmd_str, id, sync_obj);

	struct thread_param params = THREAD_PARAM_VALUE(IN, func, id, 0);
 1115c94:	93407e80 	sxtw	x0, w20

	ret = thread_rpc_cmd(OPTEE_RPC_CMD_WAIT_QUEUE, 1, &params);
 1115c98:	910143e2 	add	x2, sp, #0x50
	struct thread_param params = THREAD_PARAM_VALUE(IN, func, id, 0);
 1115c9c:	52800037 	mov	w23, #0x1                   	// #1
	ret = thread_rpc_cmd(OPTEE_RPC_CMD_WAIT_QUEUE, 1, &params);
 1115ca0:	d2800021 	mov	x1, #0x1                   	// #1
	struct thread_param params = THREAD_PARAM_VALUE(IN, func, id, 0);
 1115ca4:	b90053f7 	str	w23, [sp, #80]
 1115ca8:	a90583f5 	stp	x21, x0, [sp, #88]
	ret = thread_rpc_cmd(OPTEE_RPC_CMD_WAIT_QUEUE, 1, &params);
 1115cac:	52800080 	mov	w0, #0x4                   	// #4
	struct thread_param params = THREAD_PARAM_VALUE(IN, func, id, 0);
 1115cb0:	f90037ff 	str	xzr, [sp, #104]
	ret = thread_rpc_cmd(OPTEE_RPC_CMD_WAIT_QUEUE, 1, &params);
 1115cb4:	97ffc4aa 	bl	1106f5c <thread_rpc_cmd>
 1115cb8:	2a0003e7 	mov	w7, w0
	if (ret != TEE_SUCCESS)
 1115cbc:	34000140 	cbz	w0, 1115ce4 <__wq_rpc+0xc0>
		DMSG("%s thread %u ret 0x%x", cmd_str, id, ret);
 1115cc0:	f00001e4 	adrp	x4, 1154000 <__func__.1786+0x8>
 1115cc4:	2a1403e6 	mov	w6, w20
 1115cc8:	aa1303e5 	mov	x5, x19
 1115ccc:	9130ec84 	add	x4, x4, #0xc3b
 1115cd0:	2a1703e3 	mov	w3, w23
 1115cd4:	9132a2c0 	add	x0, x22, #0xca8
 1115cd8:	52800062 	mov	w2, #0x3                   	// #3
 1115cdc:	52800581 	mov	w1, #0x2c                  	// #44
 1115ce0:	9400bc19 	bl	1144d44 <trace_printf>
}
 1115ce4:	a9417bfd 	ldp	x29, x30, [sp, #16]
 1115ce8:	a94253f3 	ldp	x19, x20, [sp, #32]
 1115cec:	a9435bf5 	ldp	x21, x22, [sp, #48]
 1115cf0:	f94023f7 	ldr	x23, [sp, #64]
 1115cf4:	9101c3ff 	add	sp, sp, #0x70
 1115cf8:	d65f03c0 	ret
		DMSG("%s thread %u %p", cmd_str, id, sync_obj);
 1115cfc:	2a0103e6 	mov	w6, w1
 1115d00:	aa1303e5 	mov	x5, x19
 1115d04:	9132a2c0 	add	x0, x22, #0xca8
 1115d08:	f00001e4 	adrp	x4, 1154000 <__func__.1786+0x8>
 1115d0c:	52800023 	mov	w3, #0x1                   	// #1
 1115d10:	9130ac84 	add	x4, x4, #0xc2b
 1115d14:	52800062 	mov	w2, #0x3                   	// #3
 1115d18:	528004c1 	mov	w1, #0x26                  	// #38
 1115d1c:	9400bc0a 	bl	1144d44 <trace_printf>
 1115d20:	17ffffdd 	b	1115c94 <__wq_rpc+0x70>

0000000001115d24 <wq_wait_init_condvar>:
		SLIST_INSERT_HEAD(wq, wqe, link);
}

void wq_wait_init_condvar(struct wait_queue *wq, struct wait_queue_elem *wqe,
		struct condvar *cv, bool wait_read)
{
 1115d24:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1115d28:	910003fd 	mov	x29, sp
 1115d2c:	a90153f3 	stp	x19, x20, [sp, #16]
 1115d30:	aa0103f3 	mov	x19, x1
 1115d34:	aa0003f4 	mov	x20, x0
 1115d38:	a9025bf5 	stp	x21, x22, [sp, #32]
 1115d3c:	aa0203f5 	mov	x21, x2
 1115d40:	12001c76 	and	w22, w3, #0xff
	uint32_t old_itr_status;

	wqe->handle = thread_get_id();
 1115d44:	97ffbdc8 	bl	1105464 <thread_get_id>
 1115d48:	79000260 	strh	w0, [x19]
	wqe->done = false;
 1115d4c:	39000a7f 	strb	wzr, [x19, #2]
	wqe->wait_read = wait_read;
	wqe->cv = cv;

	old_itr_status = cpu_spin_lock_xsave(&wq_spin_lock);
 1115d50:	528008e1 	mov	w1, #0x47                  	// #71
	wqe->wait_read = wait_read;
 1115d54:	39000e76 	strb	w22, [x19, #3]
	old_itr_status = cpu_spin_lock_xsave(&wq_spin_lock);
 1115d58:	f00001e0 	adrp	x0, 1154000 <__func__.1786+0x8>
	wqe->cv = cv;
 1115d5c:	f9000675 	str	x21, [x19, #8]
	old_itr_status = cpu_spin_lock_xsave(&wq_spin_lock);
 1115d60:	9132c400 	add	x0, x0, #0xcb1
 1115d64:	97ffff68 	bl	1115b04 <cpu_spin_lock_xsave_dldetect.constprop.0>
 1115d68:	2a0003f5 	mov	w21, w0
	wqe_iter = SLIST_FIRST(wq);
 1115d6c:	f9400281 	ldr	x1, [x20]
	if (wqe_iter) {
 1115d70:	b4000181 	cbz	x1, 1115da0 <wq_wait_init_condvar+0x7c>
		while (SLIST_NEXT(wqe_iter, link))
 1115d74:	aa0103e0 	mov	x0, x1
 1115d78:	f9400821 	ldr	x1, [x1, #16]
 1115d7c:	b5ffffc1 	cbnz	x1, 1115d74 <wq_wait_init_condvar+0x50>
		SLIST_INSERT_AFTER(wqe_iter, wqe, link);
 1115d80:	f9000a7f 	str	xzr, [x19, #16]
 1115d84:	f9000813 	str	x19, [x0, #16]
	cpu_spin_unlock(lock);
 1115d88:	97ffff95 	bl	1115bdc <cpu_spin_unlock.constprop.0>
	thread_unmask_exceptions(exceptions);
 1115d8c:	2a1503e0 	mov	w0, w21

	slist_add_tail(wq, wqe);

	cpu_spin_unlock_xrestore(&wq_spin_lock, old_itr_status);
}
 1115d90:	a94153f3 	ldp	x19, x20, [sp, #16]
 1115d94:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1115d98:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1115d9c:	17ffbcf4 	b	110516c <thread_unmask_exceptions>
		SLIST_INSERT_HEAD(wq, wqe, link);
 1115da0:	f9000a7f 	str	xzr, [x19, #16]
 1115da4:	f9000293 	str	x19, [x20]
 1115da8:	17fffff8 	b	1115d88 <wq_wait_init_condvar+0x64>

0000000001115dac <wq_wait_final>:

void wq_wait_final(struct wait_queue *wq, struct wait_queue_elem *wqe,
		   const void *sync_obj, const char *fname, int lineno)
{
 1115dac:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 1115db0:	910003fd 	mov	x29, sp
 1115db4:	a90153f3 	stp	x19, x20, [sp, #16]
 1115db8:	aa0003f4 	mov	x20, x0
 1115dbc:	aa0103f3 	mov	x19, x1
 1115dc0:	a9025bf5 	stp	x21, x22, [sp, #32]
 1115dc4:	aa0203f6 	mov	x22, x2
 1115dc8:	a90363f7 	stp	x23, x24, [sp, #48]
 1115dcc:	aa0303f7 	mov	x23, x3
 1115dd0:	2a0403f8 	mov	w24, w4
 1115dd4:	a9046bf9 	stp	x25, x26, [sp, #64]

	do {
		__wq_rpc(OPTEE_RPC_WAIT_QUEUE_SLEEP, wqe->handle,
			 sync_obj, fname, lineno);

		old_itr_status = cpu_spin_lock_xsave(&wq_spin_lock);
 1115dd8:	f00001f9 	adrp	x25, 1154000 <__func__.1786+0x8>
 1115ddc:	91331b39 	add	x25, x25, #0xcc6
		__wq_rpc(OPTEE_RPC_WAIT_QUEUE_SLEEP, wqe->handle,
 1115de0:	79c00261 	ldrsh	w1, [x19]
 1115de4:	2a1803e4 	mov	w4, w24
 1115de8:	aa1703e3 	mov	x3, x23
 1115dec:	aa1603e2 	mov	x2, x22
 1115df0:	52800000 	mov	w0, #0x0                   	// #0
 1115df4:	97ffff8c 	bl	1115c24 <__wq_rpc>
		old_itr_status = cpu_spin_lock_xsave(&wq_spin_lock);
 1115df8:	aa1903e0 	mov	x0, x25
 1115dfc:	52800b01 	mov	w1, #0x58                  	// #88
 1115e00:	97ffff41 	bl	1115b04 <cpu_spin_lock_xsave_dldetect.constprop.0>

		done = wqe->done;
 1115e04:	39400a7a 	ldrb	w26, [x19, #2]
		old_itr_status = cpu_spin_lock_xsave(&wq_spin_lock);
 1115e08:	2a0003f5 	mov	w21, w0
		if (done)
 1115e0c:	340000da 	cbz	w26, 1115e24 <wq_wait_final+0x78>
			SLIST_REMOVE(wq, wqe, wait_queue_elem, link);
 1115e10:	f9400281 	ldr	x1, [x20]
 1115e14:	f9400a60 	ldr	x0, [x19, #16]
 1115e18:	eb13003f 	cmp	x1, x19
 1115e1c:	54000181 	b.ne	1115e4c <wq_wait_final+0xa0>  // b.any
 1115e20:	f9000280 	str	x0, [x20]
	cpu_spin_unlock(lock);
 1115e24:	97ffff6e 	bl	1115bdc <cpu_spin_unlock.constprop.0>
	thread_unmask_exceptions(exceptions);
 1115e28:	2a1503e0 	mov	w0, w21
 1115e2c:	97ffbcd0 	bl	110516c <thread_unmask_exceptions>

		cpu_spin_unlock_xrestore(&wq_spin_lock, old_itr_status);
	} while (!done);
 1115e30:	34fffd9a 	cbz	w26, 1115de0 <wq_wait_final+0x34>
}
 1115e34:	a94153f3 	ldp	x19, x20, [sp, #16]
 1115e38:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1115e3c:	a94363f7 	ldp	x23, x24, [sp, #48]
 1115e40:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1115e44:	a8c57bfd 	ldp	x29, x30, [sp], #80
 1115e48:	d65f03c0 	ret
			SLIST_REMOVE(wq, wqe, wait_queue_elem, link);
 1115e4c:	aa0103e2 	mov	x2, x1
 1115e50:	f9400821 	ldr	x1, [x1, #16]
 1115e54:	eb13003f 	cmp	x1, x19
 1115e58:	54ffffa1 	b.ne	1115e4c <wq_wait_final+0xa0>  // b.any
 1115e5c:	f9000840 	str	x0, [x2, #16]
 1115e60:	17fffff1 	b	1115e24 <wq_wait_final+0x78>

0000000001115e64 <wq_wake_next>:

void wq_wake_next(struct wait_queue *wq, const void *sync_obj,
			const char *fname, int lineno)
{
 1115e64:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
 1115e68:	910003fd 	mov	x29, sp
 1115e6c:	a90153f3 	stp	x19, x20, [sp, #16]
 1115e70:	aa0103f4 	mov	x20, x1
	uint32_t old_itr_status;
	struct wait_queue_elem *wqe;
	int handle = -1;
	bool do_wakeup = false;
	bool wake_type_assigned = false;
	bool wake_read = false; /* avoid gcc warning */
 1115e74:	52800013 	mov	w19, #0x0                   	// #0
{
 1115e78:	a9025bf5 	stp	x21, x22, [sp, #32]
 1115e7c:	aa0203f5 	mov	x21, x2
 1115e80:	2a0303f6 	mov	w22, w3
 1115e84:	a90363f7 	stp	x23, x24, [sp, #48]
 1115e88:	aa0003f8 	mov	x24, x0
	bool wake_type_assigned = false;
 1115e8c:	52800017 	mov	w23, #0x0                   	// #0
{
 1115e90:	a9046bf9 	stp	x25, x26, [sp, #64]
	 * If next type isn't wait_read wakeup only the first wqe which isn't
	 * done.
	 */

	while (true) {
		old_itr_status = cpu_spin_lock_xsave(&wq_spin_lock);
 1115e94:	f00001f9 	adrp	x25, 1154000 <__func__.1786+0x8>
 1115e98:	91335339 	add	x25, x25, #0xcd4
{
 1115e9c:	a90573fb 	stp	x27, x28, [sp, #80]
	int handle = -1;
 1115ea0:	1280001b 	mov	w27, #0xffffffff            	// #-1
		old_itr_status = cpu_spin_lock_xsave(&wq_spin_lock);
 1115ea4:	aa1903e0 	mov	x0, x25
 1115ea8:	52800e61 	mov	w1, #0x73                  	// #115
 1115eac:	97ffff16 	bl	1115b04 <cpu_spin_lock_xsave_dldetect.constprop.0>

		SLIST_FOREACH(wqe, wq, link) {
 1115eb0:	f9400304 	ldr	x4, [x24]
		old_itr_status = cpu_spin_lock_xsave(&wq_spin_lock);
 1115eb4:	2a0003fa 	mov	w26, w0
		SLIST_FOREACH(wqe, wq, link) {
 1115eb8:	b5000064 	cbnz	x4, 1115ec4 <wq_wake_next+0x60>
 1115ebc:	5280001c 	mov	w28, #0x0                   	// #0
 1115ec0:	1400000f 	b	1115efc <wq_wake_next+0x98>
			if (wqe->cv)
 1115ec4:	f9400480 	ldr	x0, [x4, #8]
 1115ec8:	b50003e0 	cbnz	x0, 1115f44 <wq_wake_next+0xe0>
				continue;
			if (wqe->done)
 1115ecc:	39400880 	ldrb	w0, [x4, #2]
 1115ed0:	350003a0 	cbnz	w0, 1115f44 <wq_wake_next+0xe0>
				continue;
			if (!wake_type_assigned) {
 1115ed4:	39400c80 	ldrb	w0, [x4, #3]
 1115ed8:	34000077 	cbz	w23, 1115ee4 <wq_wake_next+0x80>
				wake_read = wqe->wait_read;
				wake_type_assigned = true;
			}

			if (wqe->wait_read != wake_read)
 1115edc:	6b00027f 	cmp	w19, w0
 1115ee0:	54000321 	b.ne	1115f44 <wq_wake_next+0xe0>  // b.any
				continue;

			wqe->done = true;
			handle = wqe->handle;
 1115ee4:	79c0009b 	ldrsh	w27, [x4]
			do_wakeup = true;
			break;
 1115ee8:	52800037 	mov	w23, #0x1                   	// #1
 1115eec:	2a0003f3 	mov	w19, w0
			do_wakeup = true;
 1115ef0:	2a1703fc 	mov	w28, w23
			wqe->done = true;
 1115ef4:	52800021 	mov	w1, #0x1                   	// #1
 1115ef8:	39000881 	strb	w1, [x4, #2]
	cpu_spin_unlock(lock);
 1115efc:	97ffff38 	bl	1115bdc <cpu_spin_unlock.constprop.0>
	thread_unmask_exceptions(exceptions);
 1115f00:	2a1a03e0 	mov	w0, w26
 1115f04:	97ffbc9a 	bl	110516c <thread_unmask_exceptions>
		}

		cpu_spin_unlock_xrestore(&wq_spin_lock, old_itr_status);

		if (do_wakeup)
 1115f08:	3400011c 	cbz	w28, 1115f28 <wq_wake_next+0xc4>
			__wq_rpc(OPTEE_RPC_WAIT_QUEUE_WAKEUP, handle,
 1115f0c:	2a1603e4 	mov	w4, w22
 1115f10:	aa1503e3 	mov	x3, x21
 1115f14:	aa1403e2 	mov	x2, x20
 1115f18:	2a1b03e1 	mov	w1, w27
 1115f1c:	52800020 	mov	w0, #0x1                   	// #1
 1115f20:	97ffff41 	bl	1115c24 <__wq_rpc>
				 sync_obj, fname, lineno);

		if (!do_wakeup || !wake_read)
 1115f24:	35fffc13 	cbnz	w19, 1115ea4 <wq_wake_next+0x40>
			break;
		do_wakeup = false;
	}
}
 1115f28:	a94153f3 	ldp	x19, x20, [sp, #16]
 1115f2c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1115f30:	a94363f7 	ldp	x23, x24, [sp, #48]
 1115f34:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1115f38:	a94573fb 	ldp	x27, x28, [sp, #80]
 1115f3c:	a8c67bfd 	ldp	x29, x30, [sp], #96
 1115f40:	d65f03c0 	ret
		SLIST_FOREACH(wqe, wq, link) {
 1115f44:	f9400884 	ldr	x4, [x4, #16]
 1115f48:	17ffffdc 	b	1115eb8 <wq_wake_next+0x54>

0000000001115f4c <wq_promote_condvar>:
			const char *fname, int lineno __maybe_unused)
{
	uint32_t old_itr_status;
	struct wait_queue_elem *wqe;

	if (!cv)
 1115f4c:	b40007a1 	cbz	x1, 1116040 <wq_promote_condvar+0xf4>
{
 1115f50:	d101c3ff 	sub	sp, sp, #0x70
 1115f54:	a9017bfd 	stp	x29, x30, [sp, #16]
 1115f58:	910043fd 	add	x29, sp, #0x10
 1115f5c:	a90253f3 	stp	x19, x20, [sp, #32]
 1115f60:	aa0003f4 	mov	x20, x0
		return;

	old_itr_status = cpu_spin_lock_xsave(&wq_spin_lock);
 1115f64:	f00001f3 	adrp	x19, 1154000 <__func__.1786+0x8>
 1115f68:	91338673 	add	x19, x19, #0xce1
{
 1115f6c:	a9035bf5 	stp	x21, x22, [sp, #48]
	old_itr_status = cpu_spin_lock_xsave(&wq_spin_lock);
 1115f70:	aa1303e0 	mov	x0, x19
 1115f74:	aa0103f5 	mov	x21, x1
 1115f78:	aa0403f6 	mov	x22, x4
 1115f7c:	528013c1 	mov	w1, #0x9e                  	// #158
{
 1115f80:	a90463f7 	stp	x23, x24, [sp, #64]
 1115f84:	2a0503f8 	mov	w24, w5
 1115f88:	a9056bf9 	stp	x25, x26, [sp, #80]
 1115f8c:	12001c5a 	and	w26, w2, #0xff
		if (wqe->cv == cv) {
			if (fname)
				FMSG("promote thread %u %p %s:%d",
				     wqe->handle, (void *)cv->m, fname, lineno);
			else
				FMSG("promote thread %u %p",
 1115f90:	f00001f9 	adrp	x25, 1154000 <__func__.1786+0x8>
{
 1115f94:	f90033fb 	str	x27, [sp, #96]
	old_itr_status = cpu_spin_lock_xsave(&wq_spin_lock);
 1115f98:	97fffedb 	bl	1115b04 <cpu_spin_lock_xsave_dldetect.constprop.0>
	SLIST_FOREACH(wqe, wq, link) {
 1115f9c:	f9400294 	ldr	x20, [x20]
				FMSG("promote thread %u %p %s:%d",
 1115fa0:	f00001fb 	adrp	x27, 1154000 <__func__.1786+0x8>
				FMSG("promote thread %u %p",
 1115fa4:	9131b339 	add	x25, x25, #0xc6c
	old_itr_status = cpu_spin_lock_xsave(&wq_spin_lock);
 1115fa8:	2a0003f7 	mov	w23, w0
				FMSG("promote thread %u %p %s:%d",
 1115fac:	9131477b 	add	x27, x27, #0xc51
	SLIST_FOREACH(wqe, wq, link) {
 1115fb0:	b4000274 	cbz	x20, 1115ffc <wq_promote_condvar+0xb0>
		if (wqe->cv == cv) {
 1115fb4:	f9400680 	ldr	x0, [x20, #8]
 1115fb8:	eb15001f 	cmp	x0, x21
 1115fbc:	54000060 	b.eq	1115fc8 <wq_promote_condvar+0x7c>  // b.none
	SLIST_FOREACH(wqe, wq, link) {
 1115fc0:	f9400a94 	ldr	x20, [x20, #16]
 1115fc4:	17fffffb 	b	1115fb0 <wq_promote_condvar+0x64>
			if (fname)
 1115fc8:	79c00285 	ldrsh	w5, [x20]
 1115fcc:	f94006a6 	ldr	x6, [x21, #8]
 1115fd0:	b40002b6 	cbz	x22, 1116024 <wq_promote_condvar+0xd8>
				FMSG("promote thread %u %p %s:%d",
 1115fd4:	b90003f8 	str	w24, [sp]
 1115fd8:	aa1603e7 	mov	x7, x22
 1115fdc:	aa1b03e4 	mov	x4, x27
 1115fe0:	aa1303e0 	mov	x0, x19
 1115fe4:	52800023 	mov	w3, #0x1                   	// #1
 1115fe8:	52800082 	mov	w2, #0x4                   	// #4
 1115fec:	52801521 	mov	w1, #0xa9                  	// #169
 1115ff0:	9400bb55 	bl	1144d44 <trace_printf>
				     wqe->handle, (void *)cv->m);

			wqe->cv = NULL;
 1115ff4:	f900069f 	str	xzr, [x20, #8]
			if (only_one)
 1115ff8:	34fffe5a 	cbz	w26, 1115fc0 <wq_promote_condvar+0x74>
	cpu_spin_unlock(lock);
 1115ffc:	97fffef8 	bl	1115bdc <cpu_spin_unlock.constprop.0>
	thread_unmask_exceptions(exceptions);
 1116000:	2a1703e0 	mov	w0, w23
				break;
		}
	}

	cpu_spin_unlock_xrestore(&wq_spin_lock, old_itr_status);
}
 1116004:	a9417bfd 	ldp	x29, x30, [sp, #16]
 1116008:	a94253f3 	ldp	x19, x20, [sp, #32]
 111600c:	a9435bf5 	ldp	x21, x22, [sp, #48]
 1116010:	a94463f7 	ldp	x23, x24, [sp, #64]
 1116014:	a9456bf9 	ldp	x25, x26, [sp, #80]
 1116018:	f94033fb 	ldr	x27, [sp, #96]
 111601c:	9101c3ff 	add	sp, sp, #0x70
 1116020:	17ffbc53 	b	110516c <thread_unmask_exceptions>
				FMSG("promote thread %u %p",
 1116024:	aa1903e4 	mov	x4, x25
 1116028:	aa1303e0 	mov	x0, x19
 111602c:	52800023 	mov	w3, #0x1                   	// #1
 1116030:	52800082 	mov	w2, #0x4                   	// #4
 1116034:	52801581 	mov	w1, #0xac                  	// #172
 1116038:	9400bb43 	bl	1144d44 <trace_printf>
 111603c:	17ffffee 	b	1115ff4 <wq_promote_condvar+0xa8>
 1116040:	d65f03c0 	ret

0000000001116044 <wq_have_condvar>:

bool wq_have_condvar(struct wait_queue *wq, struct condvar *cv)
{
 1116044:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1116048:	910003fd 	mov	x29, sp
 111604c:	f90013f5 	str	x21, [sp, #32]
 1116050:	aa0003f5 	mov	x21, x0
	uint32_t old_itr_status;
	struct wait_queue_elem *wqe;
	bool rc = false;

	old_itr_status = cpu_spin_lock_xsave(&wq_spin_lock);
 1116054:	d00001e0 	adrp	x0, 1154000 <__func__.1786+0x8>
 1116058:	9133d000 	add	x0, x0, #0xcf4
{
 111605c:	a90153f3 	stp	x19, x20, [sp, #16]
 1116060:	aa0103f4 	mov	x20, x1
	old_itr_status = cpu_spin_lock_xsave(&wq_spin_lock);
 1116064:	528017c1 	mov	w1, #0xbe                  	// #190
 1116068:	97fffea7 	bl	1115b04 <cpu_spin_lock_xsave_dldetect.constprop.0>
 111606c:	2a0003f3 	mov	w19, w0

	SLIST_FOREACH(wqe, wq, link) {
 1116070:	f94002a2 	ldr	x2, [x21]
 1116074:	b5000142 	cbnz	x2, 111609c <wq_have_condvar+0x58>
	bool rc = false;
 1116078:	52800014 	mov	w20, #0x0                   	// #0
	cpu_spin_unlock(lock);
 111607c:	97fffed8 	bl	1115bdc <cpu_spin_unlock.constprop.0>
	thread_unmask_exceptions(exceptions);
 1116080:	2a1303e0 	mov	w0, w19
 1116084:	97ffbc3a 	bl	110516c <thread_unmask_exceptions>
	}

	cpu_spin_unlock_xrestore(&wq_spin_lock, old_itr_status);

	return rc;
}
 1116088:	2a1403e0 	mov	w0, w20
 111608c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1116090:	f94013f5 	ldr	x21, [sp, #32]
 1116094:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1116098:	d65f03c0 	ret
		if (wqe->cv == cv) {
 111609c:	f9400440 	ldr	x0, [x2, #8]
 11160a0:	eb14001f 	cmp	x0, x20
 11160a4:	54000060 	b.eq	11160b0 <wq_have_condvar+0x6c>  // b.none
	SLIST_FOREACH(wqe, wq, link) {
 11160a8:	f9400842 	ldr	x2, [x2, #16]
 11160ac:	17fffff2 	b	1116074 <wq_have_condvar+0x30>
			rc = true;
 11160b0:	52800034 	mov	w20, #0x1                   	// #1
 11160b4:	17fffff2 	b	111607c <wq_have_condvar+0x38>

00000000011160b8 <wq_is_empty>:

bool wq_is_empty(struct wait_queue *wq)
{
 11160b8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	uint32_t old_itr_status;
	bool ret;

	old_itr_status = cpu_spin_lock_xsave(&wq_spin_lock);
 11160bc:	52801a21 	mov	w1, #0xd1                  	// #209
{
 11160c0:	910003fd 	mov	x29, sp
 11160c4:	a90153f3 	stp	x19, x20, [sp, #16]
 11160c8:	aa0003f4 	mov	x20, x0
	old_itr_status = cpu_spin_lock_xsave(&wq_spin_lock);
 11160cc:	d00001e0 	adrp	x0, 1154000 <__func__.1786+0x8>
 11160d0:	91341000 	add	x0, x0, #0xd04
 11160d4:	97fffe8c 	bl	1115b04 <cpu_spin_lock_xsave_dldetect.constprop.0>
 11160d8:	2a0003f3 	mov	w19, w0

	ret = SLIST_EMPTY(wq);
 11160dc:	f9400280 	ldr	x0, [x20]
 11160e0:	f100001f 	cmp	x0, #0x0
 11160e4:	1a9f17f4 	cset	w20, eq  // eq = none
	cpu_spin_unlock(lock);
 11160e8:	97fffebd 	bl	1115bdc <cpu_spin_unlock.constprop.0>
	thread_unmask_exceptions(exceptions);
 11160ec:	2a1303e0 	mov	w0, w19
 11160f0:	97ffbc1f 	bl	110516c <thread_unmask_exceptions>

	cpu_spin_unlock_xrestore(&wq_spin_lock, old_itr_status);

	return ret;
}
 11160f4:	2a1403e0 	mov	w0, w20
 11160f8:	a94153f3 	ldp	x19, x20, [sp, #16]
 11160fc:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1116100:	d65f03c0 	ret

0000000001116104 <init_user_ta>:
 */
static const struct ts_ops *_user_ta_ops;

static TEE_Result init_user_ta(void)
{
	_user_ta_ops = &user_ta_ops;
 1116104:	90000241 	adrp	x1, 115e000 <state+0x80>
 1116108:	900001c0 	adrp	x0, 114e000 <ldelf_data+0x8000>
 111610c:	91038000 	add	x0, x0, #0xe0
 1116110:	f9009420 	str	x0, [x1, #296]

	return TEE_SUCCESS;
}
 1116114:	52800000 	mov	w0, #0x0                   	// #0
 1116118:	d65f03c0 	ret

000000000111611c <free_utc>:
{
 111611c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1116120:	910003fd 	mov	x29, sp
 1116124:	a90153f3 	stp	x19, x20, [sp, #16]
 1116128:	aa0003f3 	mov	x19, x0
	tee_pager_rem_um_areas(&utc->uctx);
 111612c:	91014014 	add	x20, x0, #0x50
	while (!TAILQ_EMPTY(&utc->open_sessions)) {
 1116130:	f9400260 	ldr	x0, [x19]
 1116134:	b50001a0 	cbnz	x0, 1116168 <free_utc+0x4c>
	vm_info_final(&utc->uctx);
 1116138:	aa1403e0 	mov	x0, x20
 111613c:	94000cd9 	bl	11194a0 <vm_info_final>
	tee_svc_cryp_free_states(utc);
 1116140:	aa1303e0 	mov	x0, x19
 1116144:	94002693 	bl	111fb90 <tee_svc_cryp_free_states>
	tee_obj_close_all(utc);
 1116148:	aa1303e0 	mov	x0, x19
 111614c:	94003fc0 	bl	112604c <tee_obj_close_all>
	tee_svc_storage_close_all_enum(utc);
 1116150:	aa1303e0 	mov	x0, x19
 1116154:	9400328a 	bl	1122b7c <tee_svc_storage_close_all_enum>
	free(utc);
 1116158:	aa1303e0 	mov	x0, x19
}
 111615c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1116160:	a8c27bfd 	ldp	x29, x30, [sp], #32
	free(utc);
 1116164:	1400b51f 	b	11435e0 <free>
		tee_ta_close_session(TAILQ_FIRST(&utc->open_sessions),
 1116168:	aa1303e1 	mov	x1, x19
 111616c:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
 1116170:	97fff7a9 	bl	1114014 <tee_ta_close_session>
 1116174:	17ffffef 	b	1116130 <free_utc+0x14>

0000000001116178 <check_ta_store>:
{
	return ctx && ctx->ops == _user_ta_ops;
}

static TEE_Result check_ta_store(void)
{
 1116178:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	const struct ts_store_ops *op = NULL;

	SCATTERED_ARRAY_FOREACH(op, ta_stores, struct ts_store_ops)
 111617c:	90000220 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1116180:	91068000 	add	x0, x0, #0x1a0
{
 1116184:	910003fd 	mov	x29, sp
 1116188:	a90153f3 	stp	x19, x20, [sp, #16]
	SCATTERED_ARRAY_FOREACH(op, ta_stores, struct ts_store_ops)
 111618c:	90000234 	adrp	x20, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1116190:	91080294 	add	x20, x20, #0x200
{
 1116194:	a9025bf5 	stp	x21, x22, [sp, #32]
		DMSG("TA store: \"%s\"", op->description);
 1116198:	d00001f5 	adrp	x21, 1154000 <__func__.1786+0x8>
 111619c:	d00001f6 	adrp	x22, 1154000 <__func__.1786+0x8>
	SCATTERED_ARRAY_FOREACH(op, ta_stores, struct ts_store_ops)
 11161a0:	97fffa24 	bl	1114a30 <scattered_array_relax_ptr>
		DMSG("TA store: \"%s\"", op->description);
 11161a4:	913442b5 	add	x21, x21, #0xd10
	SCATTERED_ARRAY_FOREACH(op, ta_stores, struct ts_store_ops)
 11161a8:	aa0003f3 	mov	x19, x0
		DMSG("TA store: \"%s\"", op->description);
 11161ac:	91383ed6 	add	x22, x22, #0xe0f
	SCATTERED_ARRAY_FOREACH(op, ta_stores, struct ts_store_ops)
 11161b0:	eb14027f 	cmp	x19, x20
 11161b4:	540000c3 	b.cc	11161cc <check_ta_store+0x54>  // b.lo, b.ul, b.last

	return TEE_SUCCESS;
}
 11161b8:	52800000 	mov	w0, #0x0                   	// #0
 11161bc:	a94153f3 	ldp	x19, x20, [sp, #16]
 11161c0:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11161c4:	a8c37bfd 	ldp	x29, x30, [sp], #48
 11161c8:	d65f03c0 	ret
		DMSG("TA store: \"%s\"", op->description);
 11161cc:	f8430665 	ldr	x5, [x19], #48
 11161d0:	aa1503e4 	mov	x4, x21
 11161d4:	aa1603e0 	mov	x0, x22
 11161d8:	52800023 	mov	w3, #0x1                   	// #1
 11161dc:	52800062 	mov	w2, #0x3                   	// #3
 11161e0:	52803441 	mov	w1, #0x1a2                 	// #418
 11161e4:	9400bad8 	bl	1144d44 <trace_printf>
	SCATTERED_ARRAY_FOREACH(op, ta_stores, struct ts_store_ops)
 11161e8:	17fffff2 	b	11161b0 <check_ta_store+0x38>

00000000011161ec <is_user_ta_ctx>:
	return ctx && ctx->ops == _user_ta_ops;
 11161ec:	b40000e0 	cbz	x0, 1116208 <is_user_ta_ctx+0x1c>
 11161f0:	f9400801 	ldr	x1, [x0, #16]
 11161f4:	90000240 	adrp	x0, 115e000 <state+0x80>
 11161f8:	f9409400 	ldr	x0, [x0, #296]
 11161fc:	eb00003f 	cmp	x1, x0
 1116200:	1a9f17e0 	cset	w0, eq  // eq = none
}
 1116204:	d65f03c0 	ret
	return ctx && ctx->ops == _user_ta_ops;
 1116208:	52800000 	mov	w0, #0x0                   	// #0
 111620c:	17fffffe 	b	1116204 <is_user_ta_ctx+0x18>

0000000001116210 <to_user_ta_ctx>:
{
 1116210:	aa0003e2 	mov	x2, x0
 1116214:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 1116218:	910003fd 	mov	x29, sp
	assert(is_user_ta_ctx(ctx));
 111621c:	97fffff4 	bl	11161ec <is_user_ta_ctx>
 1116220:	72001c1f 	tst	w0, #0xff
 1116224:	54000141 	b.ne	111624c <to_user_ta_ctx+0x3c>  // b.any
 1116228:	d00001e3 	adrp	x3, 1154000 <__func__.1786+0x8>
 111622c:	f00001c1 	adrp	x1, 1151000 <small_prime+0x168>
 1116230:	91375863 	add	x3, x3, #0xdd6
 1116234:	91081021 	add	x1, x1, #0x204
 1116238:	f00001c0 	adrp	x0, 1151000 <small_prime+0x168>
 111623c:	91088800 	add	x0, x0, #0x222
 1116240:	52800702 	mov	w2, #0x38                  	// #56
 1116244:	97fff01a 	bl	11122ac <_assert_log>
 1116248:	97fff02a 	bl	11122f0 <_assert_break>
	return container_of(ctx, struct user_ta_ctx, ta_ctx.ts_ctx);
}
 111624c:	d10ba040 	sub	x0, x2, #0x2e8
 1116250:	a8c17bfd 	ldp	x29, x30, [sp], #16
 1116254:	d65f03c0 	ret

0000000001116258 <user_ta_get_instance_id>:
{
 1116258:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 111625c:	910003fd 	mov	x29, sp
	return to_user_ta_ctx(ctx)->uctx.vm_info.asid;
 1116260:	97ffffec 	bl	1116210 <to_user_ta_ctx>
}
 1116264:	b9406000 	ldr	w0, [x0, #96]
 1116268:	a8c17bfd 	ldp	x29, x30, [sp], #16
 111626c:	d65f03c0 	ret

0000000001116270 <user_ta_ctx_destroy>:
{
 1116270:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 1116274:	910003fd 	mov	x29, sp
	free_utc(to_user_ta_ctx(ctx));
 1116278:	97ffffe6 	bl	1116210 <to_user_ta_ctx>
}
 111627c:	a8c17bfd 	ldp	x29, x30, [sp], #16
	free_utc(to_user_ta_ctx(ctx));
 1116280:	17ffffa7 	b	111611c <free_utc>

0000000001116284 <user_ta_dump_state>:
{
 1116284:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1116288:	910003fd 	mov	x29, sp
 111628c:	f9000bf3 	str	x19, [sp, #16]
	struct user_ta_ctx *utc = to_user_ta_ctx(ctx);
 1116290:	97ffffe0 	bl	1116210 <to_user_ta_ctx>
	if (utc->uctx.dump_entry_func) {
 1116294:	f9415001 	ldr	x1, [x0, #672]
 1116298:	91014013 	add	x19, x0, #0x50
 111629c:	b50000a1 	cbnz	x1, 11162b0 <user_ta_dump_state+0x2c>
	user_mode_ctx_print_mappings(&utc->uctx);
 11162a0:	aa1303e0 	mov	x0, x19
}
 11162a4:	f9400bf3 	ldr	x19, [sp, #16]
 11162a8:	a8c27bfd 	ldp	x29, x30, [sp], #32
	user_mode_ctx_print_mappings(&utc->uctx);
 11162ac:	17fffa43 	b	1114bb8 <user_mode_ctx_print_mappings>
		TEE_Result res = ldelf_dump_state(&utc->uctx);
 11162b0:	aa1303e0 	mov	x0, x19
 11162b4:	97ffb63d 	bl	1103ba8 <ldelf_dump_state>
		if (!res || res == TEE_ERROR_TARGET_DEAD)
 11162b8:	7100001f 	cmp	w0, #0x0
 11162bc:	1299fb61 	mov	w1, #0xffff3024            	// #-53212
 11162c0:	7a411004 	ccmp	w0, w1, #0x4, ne  // ne = any
 11162c4:	54fffee1 	b.ne	11162a0 <user_ta_dump_state+0x1c>  // b.any
}
 11162c8:	f9400bf3 	ldr	x19, [sp, #16]
 11162cc:	a8c27bfd 	ldp	x29, x30, [sp], #32
 11162d0:	d65f03c0 	ret

00000000011162d4 <user_ta_enter>:
{
 11162d4:	d10203ff 	sub	sp, sp, #0x80
 11162d8:	a9017bfd 	stp	x29, x30, [sp, #16]
 11162dc:	910043fd 	add	x29, sp, #0x10
 11162e0:	a9035bf5 	stp	x21, x22, [sp, #48]
 11162e4:	aa0003f6 	mov	x22, x0
	struct user_ta_ctx *utc = to_user_ta_ctx(session->ctx);
 11162e8:	f9400800 	ldr	x0, [x0, #16]
{
 11162ec:	a90253f3 	stp	x19, x20, [sp, #32]
 11162f0:	a90463f7 	stp	x23, x24, [sp, #64]
 11162f4:	a9056bf9 	stp	x25, x26, [sp, #80]
 11162f8:	2a0103f9 	mov	w25, w1
 11162fc:	2a0203fa 	mov	w26, w2
	struct user_ta_ctx *utc = to_user_ta_ctx(session->ctx);
 1116300:	97ffffc4 	bl	1116210 <to_user_ta_ctx>
 1116304:	aa0003f4 	mov	x20, x0
	struct tee_ta_session *ta_sess = to_ta_session(session);
 1116308:	aa1603e0 	mov	x0, x22
 111630c:	97fff70d 	bl	1113f40 <to_ta_session>
 1116310:	aa0003f5 	mov	x21, x0
	void *param_va[TEE_NUM_PARAMS] = { NULL };
 1116314:	a9067fff 	stp	xzr, xzr, [sp, #96]
 1116318:	a9077fff 	stp	xzr, xzr, [sp, #112]
	struct thread_specific_data *tsd = thread_get_tsd();
 111631c:	97ffbe29 	bl	1105bc0 <thread_get_tsd>
	if (tsd->syscall_recursion >= CFG_CORE_MAX_SYSCALL_RECURSION) {
 1116320:	b9414801 	ldr	w1, [x0, #328]
 1116324:	71000c3f 	cmp	w1, #0x3
 1116328:	54000289 	b.ls	1116378 <user_ta_enter+0xa4>  // b.plast
		res = TEE_ERROR_OUT_OF_MEMORY;
 111632c:	129ffe78 	mov	w24, #0xffff000c            	// #-65524
		DMSG("Maximum allowed recursion depth reached (%u)",
 1116330:	52800085 	mov	w5, #0x4                   	// #4
 1116334:	d00001e4 	adrp	x4, 1154000 <__func__.1786+0x8>
 1116338:	52800023 	mov	w3, #0x1                   	// #1
 111633c:	91347c84 	add	x4, x4, #0xd1f
 1116340:	52800062 	mov	w2, #0x3                   	// #3
 1116344:	52800e41 	mov	w1, #0x72                  	// #114
 1116348:	d00001e0 	adrp	x0, 1154000 <__func__.1786+0x8>
 111634c:	91379400 	add	x0, x0, #0xde5
 1116350:	9400ba7d 	bl	1144d44 <trace_printf>
	ta_sess->cancel = false;
 1116354:	390172bf 	strb	wzr, [x21, #92]
}
 1116358:	2a1803e0 	mov	w0, w24
 111635c:	a9417bfd 	ldp	x29, x30, [sp, #16]
 1116360:	a94253f3 	ldp	x19, x20, [sp, #32]
 1116364:	a9435bf5 	ldp	x21, x22, [sp, #48]
 1116368:	a94463f7 	ldp	x23, x24, [sp, #64]
 111636c:	a9456bf9 	ldp	x25, x26, [sp, #80]
 1116370:	910203ff 	add	sp, sp, #0x80
 1116374:	d65f03c0 	ret
	tsd->syscall_recursion++;
 1116378:	11000421 	add	w1, w1, #0x1
 111637c:	b9014801 	str	w1, [x0, #328]
	if (ta_sess->param) {
 1116380:	f9402aa1 	ldr	x1, [x21, #80]
 1116384:	91014297 	add	x23, x20, #0x50
 1116388:	b5000181 	cbnz	x1, 11163b8 <user_ta_enter+0xe4>
	ts_push_current_session(session);
 111638c:	aa1603e0 	mov	x0, x22
 1116390:	97fff96c 	bl	1114940 <ts_push_current_session>
	if (ta_sess->param)
 1116394:	f9402aa3 	ldr	x3, [x21, #80]
	usr_stack = utc->uctx.stack_ptr;
 1116398:	f9416280 	ldr	x0, [x20, #704]
	usr_stack -= ROUNDUP(sizeof(struct utee_params), STACK_ALIGNMENT);
 111639c:	d1020013 	sub	x19, x0, #0x80
	if (ta_sess->param)
 11163a0:	b50002c3 	cbnz	x3, 11163f8 <user_ta_enter+0x124>
		memset(usr_params, 0, sizeof(*usr_params));
 11163a4:	aa1303e0 	mov	x0, x19
 11163a8:	d2800902 	mov	x2, #0x48                  	// #72
 11163ac:	52800001 	mov	w1, #0x0                   	// #0
 11163b0:	9400b64c 	bl	1143ce0 <memset>
 11163b4:	1400002e 	b	111646c <user_ta_enter+0x198>
		res = vm_map_param(&utc->uctx, ta_sess->param, param_va);
 11163b8:	910183e2 	add	x2, sp, #0x60
 11163bc:	aa1703e0 	mov	x0, x23
 11163c0:	94000de3 	bl	1119b4c <vm_map_param>
 11163c4:	2a0003f8 	mov	w24, w0
		if (res != TEE_SUCCESS)
 11163c8:	34fffe20 	cbz	w0, 111638c <user_ta_enter+0xb8>
	struct thread_specific_data *tsd = thread_get_tsd();
 11163cc:	97ffbdfd 	bl	1105bc0 <thread_get_tsd>
	assert(tsd->syscall_recursion);
 11163d0:	b9414801 	ldr	w1, [x0, #328]
 11163d4:	35000e01 	cbnz	w1, 1116594 <user_ta_enter+0x2c0>
 11163d8:	d00001e3 	adrp	x3, 1154000 <__func__.1786+0x8>
 11163dc:	d00001e1 	adrp	x1, 1154000 <__func__.1786+0x8>
 11163e0:	d00001e0 	adrp	x0, 1154000 <__func__.1786+0x8>
 11163e4:	9137cc63 	add	x3, x3, #0xdf3
 11163e8:	9135e821 	add	x1, x1, #0xd7a
 11163ec:	91368c00 	add	x0, x0, #0xda3
 11163f0:	52800fe2 	mov	w2, #0x7f                  	// #127
 11163f4:	14000066 	b	111658c <user_ta_enter+0x2b8>
	up->types = p->types;
 11163f8:	b8408465 	ldr	w5, [x3], #8
 11163fc:	91002262 	add	x2, x19, #0x8
			a = (uintptr_t)va[n];
 1116400:	910183e6 	add	x6, sp, #0x60
	up->types = p->types;
 1116404:	2a0503e1 	mov	w1, w5
 1116408:	f8180001 	stur	x1, [x0, #-128]
	for (n = 0; n < TEE_NUM_PARAMS; n++) {
 111640c:	d2800000 	mov	x0, #0x0                   	// #0
		switch (TEE_PARAM_TYPE_GET(p->types, n)) {
 1116410:	531e7404 	lsl	w4, w0, #2
 1116414:	1ac424a4 	lsr	w4, w5, w4
 1116418:	12000c81 	and	w1, w4, #0xf
 111641c:	71000c3f 	cmp	w1, #0x3
 1116420:	54000800 	b.eq	1116520 <user_ta_enter+0x24c>  // b.none
 1116424:	721e049f 	tst	w4, #0xc
 1116428:	540000c1 	b.ne	1116440 <user_ta_enter+0x16c>  // b.any
 111642c:	7100043f 	cmp	w1, #0x1
 1116430:	54000780 	b.eq	1116520 <user_ta_enter+0x24c>  // b.none
 1116434:	d2800001 	mov	x1, #0x0                   	// #0
 1116438:	d2800004 	mov	x4, #0x0                   	// #0
 111643c:	14000006 	b	1116454 <user_ta_enter+0x180>
 1116440:	51001421 	sub	w1, w1, #0x5
 1116444:	7100083f 	cmp	w1, #0x2
 1116448:	54ffff68 	b.hi	1116434 <user_ta_enter+0x160>  // b.pmore
			a = (uintptr_t)va[n];
 111644c:	f86078c4 	ldr	x4, [x6, x0, lsl #3]
			b = p->u[n].mem.size;
 1116450:	f9400461 	ldr	x1, [x3, #8]
		up->vals[n * 2 + 1] = b;
 1116454:	a9000444 	stp	x4, x1, [x2]
	for (n = 0; n < TEE_NUM_PARAMS; n++) {
 1116458:	91000400 	add	x0, x0, #0x1
 111645c:	91006063 	add	x3, x3, #0x18
 1116460:	f100101f 	cmp	x0, #0x4
 1116464:	91004042 	add	x2, x2, #0x10
 1116468:	54fffd41 	b.ne	1116410 <user_ta_enter+0x13c>  // b.any
	res = thread_enter_user_mode(func, kaddr_to_uref(session),
 111646c:	aa1603e0 	mov	x0, x22
 1116470:	97fffaf2 	bl	1115038 <kaddr_to_uref>
 1116474:	910c1281 	add	x1, x20, #0x304
 1116478:	f90003e1 	str	x1, [sp]
 111647c:	910c0287 	add	x7, x20, #0x300
 1116480:	2a0003e1 	mov	w1, w0
 1116484:	394ae286 	ldrb	w6, [x20, #696]
 1116488:	aa1303e4 	mov	x4, x19
 111648c:	f9414e85 	ldr	x5, [x20, #664]
 1116490:	2a1a03e3 	mov	w3, w26
 1116494:	aa1303e2 	mov	x2, x19
 1116498:	2a1903e0 	mov	w0, w25
 111649c:	97ffbf3d 	bl	1106190 <thread_enter_user_mode>
 11164a0:	2a0003f8 	mov	w24, w0
	thread_user_clear_vfp(&utc->uctx);
 11164a4:	aa1703e0 	mov	x0, x23
 11164a8:	97ffbf27 	bl	1106144 <thread_user_clear_vfp>
	if (utc->ta_ctx.panicked) {
 11164ac:	b9430280 	ldr	w0, [x20, #768]
 11164b0:	340003c0 	cbz	w0, 1116528 <user_ta_enter+0x254>
		abort_print_current_ts();
 11164b4:	97ffc48c 	bl	11076e4 <abort_print_current_ts>
		res = TEE_ERROR_TARGET_DEAD;
 11164b8:	1299fb78 	mov	w24, #0xffff3024            	// #-53212
		DMSG("tee_user_ta_enter: TA panicked with code 0x%x",
 11164bc:	b9430685 	ldr	w5, [x20, #772]
 11164c0:	d00001e4 	adrp	x4, 1154000 <__func__.1786+0x8>
 11164c4:	d00001e0 	adrp	x0, 1154000 <__func__.1786+0x8>
 11164c8:	91353084 	add	x4, x4, #0xd4c
 11164cc:	91380400 	add	x0, x0, #0xe01
 11164d0:	52800023 	mov	w3, #0x1                   	// #1
 11164d4:	52800062 	mov	w2, #0x3                   	// #3
 11164d8:	52801601 	mov	w1, #0xb0                  	// #176
 11164dc:	9400ba1a 	bl	1144d44 <trace_printf>
	if (ta_sess->param) {
 11164e0:	f9402aa1 	ldr	x1, [x21, #80]
 11164e4:	b4000401 	cbz	x1, 1116564 <user_ta_enter+0x290>
		switch (TEE_PARAM_TYPE_GET(p->types, n)) {
 11164e8:	b8408424 	ldr	w4, [x1], #8
 11164ec:	91002273 	add	x19, x19, #0x8
 11164f0:	52800000 	mov	w0, #0x0                   	// #0
 11164f4:	1ac02483 	lsr	w3, w4, w0
 11164f8:	12000c62 	and	w2, w3, #0xf
 11164fc:	721e047f 	tst	w3, #0xc
 1116500:	540001a1 	b.ne	1116534 <user_ta_enter+0x260>  // b.any
 1116504:	721f087f 	tst	w3, #0xe
 1116508:	54000200 	b.eq	1116548 <user_ta_enter+0x274>  // b.none
			p->u[n].val.a = up->vals[n * 2];
 111650c:	f9400262 	ldr	x2, [x19]
 1116510:	b9000022 	str	w2, [x1]
			p->u[n].val.b = up->vals[n * 2 + 1];
 1116514:	f9400662 	ldr	x2, [x19, #8]
 1116518:	b9000422 	str	w2, [x1, #4]
			break;
 111651c:	1400000b 	b	1116548 <user_ta_enter+0x274>
			b = p->u[n].val.b;
 1116520:	29400464 	ldp	w4, w1, [x3]
			break;
 1116524:	17ffffcc 	b	1116454 <user_ta_enter+0x180>
		ta_sess->err_origin = TEE_ORIGIN_TRUSTED_APP;
 1116528:	52800080 	mov	w0, #0x4                   	// #4
 111652c:	b9005aa0 	str	w0, [x21, #88]
 1116530:	17ffffec 	b	11164e0 <user_ta_enter+0x20c>
		switch (TEE_PARAM_TYPE_GET(p->types, n)) {
 1116534:	51001842 	sub	w2, w2, #0x6
 1116538:	7100045f 	cmp	w2, #0x1
 111653c:	54000068 	b.hi	1116548 <user_ta_enter+0x274>  // b.pmore
			p->u[n].mem.size = up->vals[n * 2 + 1];
 1116540:	f9400662 	ldr	x2, [x19, #8]
 1116544:	f9000422 	str	x2, [x1, #8]
	for (n = 0; n < TEE_NUM_PARAMS; n++) {
 1116548:	11001000 	add	w0, w0, #0x4
 111654c:	91004273 	add	x19, x19, #0x10
 1116550:	91006021 	add	x1, x1, #0x18
 1116554:	7100401f 	cmp	w0, #0x10
 1116558:	54fffce1 	b.ne	11164f4 <user_ta_enter+0x220>  // b.any
		vm_clean_param(&utc->uctx);
 111655c:	aa1703e0 	mov	x0, x23
 1116560:	94000bb9 	bl	1119444 <vm_clean_param>
	ts_sess = ts_pop_current_session();
 1116564:	97fff907 	bl	1114980 <ts_pop_current_session>
	assert(ts_sess == session);
 1116568:	eb0002df 	cmp	x22, x0
 111656c:	54fff300 	b.eq	11163cc <user_ta_enter+0xf8>  // b.none
 1116570:	d00001e3 	adrp	x3, 1154000 <__func__.1786+0x8>
 1116574:	d00001e1 	adrp	x1, 1154000 <__func__.1786+0x8>
 1116578:	d00001e0 	adrp	x0, 1154000 <__func__.1786+0x8>
 111657c:	91380463 	add	x3, x3, #0xe01
 1116580:	9135e821 	add	x1, x1, #0xd7a
 1116584:	91364000 	add	x0, x0, #0xd90
 1116588:	52801902 	mov	w2, #0xc8                  	// #200
	assert(tsd->syscall_recursion);
 111658c:	97ffef48 	bl	11122ac <_assert_log>
 1116590:	97ffef58 	bl	11122f0 <_assert_break>
	tsd->syscall_recursion--;
 1116594:	51000421 	sub	w1, w1, #0x1
 1116598:	b9014801 	str	w1, [x0, #328]
}
 111659c:	17ffff6e 	b	1116354 <user_ta_enter+0x80>

00000000011165a0 <user_ta_enter_invoke_cmd>:
	return user_ta_enter(s, UTEE_ENTRY_FUNC_INVOKE_COMMAND, cmd);
 11165a0:	2a0103e2 	mov	w2, w1
 11165a4:	52800041 	mov	w1, #0x2                   	// #2
 11165a8:	17ffff4b 	b	11162d4 <user_ta_enter>

00000000011165ac <user_ta_enter_open_session>:
	return user_ta_enter(s, UTEE_ENTRY_FUNC_OPEN_SESSION, 0);
 11165ac:	52800002 	mov	w2, #0x0                   	// #0
 11165b0:	52800001 	mov	w1, #0x0                   	// #0
 11165b4:	17ffff48 	b	11162d4 <user_ta_enter>

00000000011165b8 <user_ta_enter_close_session>:
{
 11165b8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 11165bc:	910003fd 	mov	x29, sp
 11165c0:	f9000bf3 	str	x19, [sp, #16]
 11165c4:	aa0003f3 	mov	x19, x0
	if (!to_user_ta_ctx(s->ctx)->uctx.is_initializing)
 11165c8:	f9400800 	ldr	x0, [x0, #16]
 11165cc:	97ffff11 	bl	1116210 <to_user_ta_ctx>
 11165d0:	394ae400 	ldrb	w0, [x0, #697]
 11165d4:	350000e0 	cbnz	w0, 11165f0 <user_ta_enter_close_session+0x38>
		user_ta_enter(s, UTEE_ENTRY_FUNC_CLOSE_SESSION, 0);
 11165d8:	aa1303e0 	mov	x0, x19
 11165dc:	52800002 	mov	w2, #0x0                   	// #0
}
 11165e0:	f9400bf3 	ldr	x19, [sp, #16]
		user_ta_enter(s, UTEE_ENTRY_FUNC_CLOSE_SESSION, 0);
 11165e4:	52800021 	mov	w1, #0x1                   	// #1
}
 11165e8:	a8c27bfd 	ldp	x29, x30, [sp], #32
		user_ta_enter(s, UTEE_ENTRY_FUNC_CLOSE_SESSION, 0);
 11165ec:	17ffff3a 	b	11162d4 <user_ta_enter>
}
 11165f0:	f9400bf3 	ldr	x19, [sp, #16]
 11165f4:	a8c27bfd 	ldp	x29, x30, [sp], #32
 11165f8:	d65f03c0 	ret

00000000011165fc <tee_ta_init_user_ta_session>:
service_init(check_ta_store);

TEE_Result tee_ta_init_user_ta_session(const TEE_UUID *uuid,
				       struct tee_ta_session *s)
{
 11165fc:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 1116600:	910003fd 	mov	x29, sp
 1116604:	a90153f3 	stp	x19, x20, [sp, #16]
 1116608:	aa0003f4 	mov	x20, x0
	TEE_Result res = TEE_SUCCESS;
	struct user_ta_ctx *utc = NULL;

	utc = calloc(1, sizeof(struct user_ta_ctx));
 111660c:	d2800020 	mov	x0, #0x1                   	// #1
{
 1116610:	a9025bf5 	stp	x21, x22, [sp, #32]
 1116614:	aa0103f5 	mov	x21, x1
	utc = calloc(1, sizeof(struct user_ta_ctx));
 1116618:	d2806401 	mov	x1, #0x320                 	// #800
{
 111661c:	a90363f7 	stp	x23, x24, [sp, #48]
 1116620:	a9046bf9 	stp	x25, x26, [sp, #64]
	utc = calloc(1, sizeof(struct user_ta_ctx));
 1116624:	9400b3ab 	bl	11434d0 <calloc>
	if (!utc)
 1116628:	b4000be0 	cbz	x0, 11167a4 <tee_ta_init_user_ta_session+0x1a8>
 111662c:	aa0003f3 	mov	x19, x0
		return TEE_ERROR_OUT_OF_MEMORY;

	utc->uctx.is_initializing = true;
 1116630:	52800020 	mov	w0, #0x1                   	// #1
	TAILQ_INIT(&utc->open_sessions);
	TAILQ_INIT(&utc->cryp_states);
	TAILQ_INIT(&utc->objects);
	TAILQ_INIT(&utc->storage_enums);
	condvar_init(&utc->ta_ctx.busy_cv);
 1116634:	910c4278 	add	x24, x19, #0x310
	utc->ta_ctx.ref_count = 1;

	utc->uctx.ts_ctx = &utc->ta_ctx.ts_ctx;
 1116638:	910ba277 	add	x23, x19, #0x2e8
	 * implementation to identify userland TA versus pseudo TA contexts.
	 */
	set_ta_ctx_ops(&utc->ta_ctx);

	utc->ta_ctx.ts_ctx.uuid = *uuid;
	res = vm_info_init(&utc->uctx);
 111663c:	91014279 	add	x25, x19, #0x50
	utc->uctx.is_initializing = true;
 1116640:	390ae660 	strb	w0, [x19, #697]
	TAILQ_INIT(&utc->cryp_states);
 1116644:	aa1303e0 	mov	x0, x19
	TAILQ_INIT(&utc->open_sessions);
 1116648:	a9004e7f 	stp	xzr, x19, [x19]
	TAILQ_INIT(&utc->cryp_states);
 111664c:	f8010c1f 	str	xzr, [x0, #16]!
 1116650:	f9000e60 	str	x0, [x19, #24]
	TAILQ_INIT(&utc->objects);
 1116654:	aa1303e0 	mov	x0, x19
 1116658:	f8020c1f 	str	xzr, [x0, #32]!
 111665c:	f9001660 	str	x0, [x19, #40]
	TAILQ_INIT(&utc->storage_enums);
 1116660:	aa1303e0 	mov	x0, x19
 1116664:	f8030c1f 	str	xzr, [x0, #48]!
 1116668:	f9001e60 	str	x0, [x19, #56]
	condvar_init(&utc->ta_ctx.busy_cv);
 111666c:	aa1803e0 	mov	x0, x24
 1116670:	97fffcba 	bl	1115958 <condvar_init>
	utc->uctx.ts_ctx = &utc->ta_ctx.ts_ctx;
 1116674:	f9014a77 	str	x23, [x19, #656]
	utc->ta_ctx.ref_count = 1;
 1116678:	52800020 	mov	w0, #0x1                   	// #1
 111667c:	b9030a60 	str	w0, [x19, #776]
	ctx->ts_ctx.ops = _user_ta_ops;
 1116680:	90000240 	adrp	x0, 115e000 <state+0x80>
	utc->ta_ctx.ts_ctx.uuid = *uuid;
 1116684:	aa1403e1 	mov	x1, x20
 1116688:	d2800202 	mov	x2, #0x10                  	// #16
	ctx->ts_ctx.ops = _user_ta_ops;
 111668c:	f9409400 	ldr	x0, [x0, #296]
 1116690:	f9017e60 	str	x0, [x19, #760]
	utc->ta_ctx.ts_ctx.uuid = *uuid;
 1116694:	aa1703e0 	mov	x0, x23
 1116698:	97ffb33e 	bl	1103390 <memcpy>
	res = vm_info_init(&utc->uctx);
 111669c:	aa1903e0 	mov	x0, x25
 11166a0:	94000dec 	bl	1119e50 <vm_info_init>
 11166a4:	2a0003f4 	mov	w20, w0
	if (res)
 11166a8:	35000520 	cbnz	w0, 111674c <tee_ta_init_user_ta_session+0x150>
		goto out;

	mutex_lock(&tee_ta_mutex);
 11166ac:	90000236 	adrp	x22, 115a000 <__scattered_array_1phys_mem_map+0x8>

	/*
	 * We must not hold tee_ta_mutex while allocating page tables as
	 * that may otherwise lead to a deadlock.
	 */
	ts_push_current_session(&s->ts_sess);
 11166b0:	910042ba 	add	x26, x21, #0x10
	mutex_lock(&tee_ta_mutex);
 11166b4:	f9413ed4 	ldr	x20, [x22, #632]
 11166b8:	aa1403e0 	mov	x0, x20
 11166bc:	97fffba6 	bl	1115554 <mutex_lock>
	s->ts_sess.handle_svc = s->ts_sess.ctx->ops->handle_svc;
 11166c0:	f9417e60 	ldr	x0, [x19, #760]
	TAILQ_INSERT_TAIL(&tee_ctxes, &utc->ta_ctx, link);
 11166c4:	910b4262 	add	x2, x19, #0x2d0
	s->ts_sess.handle_svc = s->ts_sess.ctx->ops->handle_svc;
 11166c8:	f9401c00 	ldr	x0, [x0, #56]
 11166cc:	f9001aa0 	str	x0, [x21, #48]
	TAILQ_INSERT_TAIL(&tee_ctxes, &utc->ta_ctx, link);
 11166d0:	f9413ac0 	ldr	x0, [x22, #624]
	s->ts_sess.ctx = &utc->ta_ctx.ts_ctx;
 11166d4:	f90012b7 	str	x23, [x21, #32]
	TAILQ_INSERT_TAIL(&tee_ctxes, &utc->ta_ctx, link);
 11166d8:	f9016e7f 	str	xzr, [x19, #728]
 11166dc:	aa1603f7 	mov	x23, x22
 11166e0:	f9400401 	ldr	x1, [x0, #8]
 11166e4:	f9017261 	str	x1, [x19, #736]
 11166e8:	f9000022 	str	x2, [x1]
 11166ec:	910b6261 	add	x1, x19, #0x2d8
 11166f0:	f9000401 	str	x1, [x0, #8]
	mutex_unlock(&tee_ta_mutex);
 11166f4:	aa1403e0 	mov	x0, x20
 11166f8:	97fffb76 	bl	11154d0 <mutex_unlock>
	ts_push_current_session(&s->ts_sess);
 11166fc:	aa1a03e0 	mov	x0, x26
 1116700:	97fff890 	bl	1114940 <ts_push_current_session>

	res = ldelf_load_ldelf(&utc->uctx);
 1116704:	aa1903e0 	mov	x0, x25
 1116708:	97ffb463 	bl	1103894 <ldelf_load_ldelf>
 111670c:	2a0003f4 	mov	w20, w0
	if (!res)
 1116710:	350000a0 	cbnz	w0, 1116724 <tee_ta_init_user_ta_session+0x128>
		res = ldelf_init_with_ldelf(&s->ts_sess, &utc->uctx);
 1116714:	aa1903e1 	mov	x1, x25
 1116718:	aa1a03e0 	mov	x0, x26
 111671c:	97ffb4af 	bl	11039d8 <ldelf_init_with_ldelf>
 1116720:	2a0003f4 	mov	w20, w0

	ts_pop_current_session();
 1116724:	97fff897 	bl	1114980 <ts_pop_current_session>

	mutex_lock(&tee_ta_mutex);
 1116728:	f9413ee0 	ldr	x0, [x23, #632]
 111672c:	97fffb8a 	bl	1115554 <mutex_lock>

	if (!res) {
 1116730:	35000254 	cbnz	w20, 1116778 <tee_ta_init_user_ta_session+0x17c>
		utc->uctx.is_initializing = false;
 1116734:	390ae67f 	strb	wzr, [x19, #697]
		s->ts_sess.ctx = NULL;
		TAILQ_REMOVE(&tee_ctxes, &utc->ta_ctx, link);
	}

	/* The state has changed for the context, notify eventual waiters. */
	condvar_broadcast(&tee_ta_init_cv);
 1116738:	f941bae0 	ldr	x0, [x23, #880]
 111673c:	97fffca1 	bl	11159c0 <condvar_broadcast>

	mutex_unlock(&tee_ta_mutex);
 1116740:	f9413ee0 	ldr	x0, [x23, #632]
 1116744:	97fffb63 	bl	11154d0 <mutex_unlock>

out:
	if (res) {
 1116748:	340000b4 	cbz	w20, 111675c <tee_ta_init_user_ta_session+0x160>
		condvar_destroy(&utc->ta_ctx.busy_cv);
 111674c:	aa1803e0 	mov	x0, x24
 1116750:	97fffc84 	bl	1115960 <condvar_destroy>
		pgt_flush_ctx(&utc->ta_ctx.ts_ctx);
		free_utc(utc);
 1116754:	aa1303e0 	mov	x0, x19
 1116758:	97fffe71 	bl	111611c <free_utc>
	}

	return res;
}
 111675c:	2a1403e0 	mov	w0, w20
 1116760:	a94153f3 	ldp	x19, x20, [sp, #16]
 1116764:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1116768:	a94363f7 	ldp	x23, x24, [sp, #48]
 111676c:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1116770:	a8c57bfd 	ldp	x29, x30, [sp], #80
 1116774:	d65f03c0 	ret
		TAILQ_REMOVE(&tee_ctxes, &utc->ta_ctx, link);
 1116778:	f9416e60 	ldr	x0, [x19, #728]
		s->ts_sess.ctx = NULL;
 111677c:	f90012bf 	str	xzr, [x21, #32]
		TAILQ_REMOVE(&tee_ctxes, &utc->ta_ctx, link);
 1116780:	f9417261 	ldr	x1, [x19, #736]
 1116784:	b40000a0 	cbz	x0, 1116798 <tee_ta_init_user_ta_session+0x19c>
 1116788:	f9000801 	str	x1, [x0, #16]
 111678c:	f9417261 	ldr	x1, [x19, #736]
 1116790:	f9000020 	str	x0, [x1]
 1116794:	17ffffe9 	b	1116738 <tee_ta_init_user_ta_session+0x13c>
 1116798:	f9413ae2 	ldr	x2, [x23, #624]
 111679c:	f9000441 	str	x1, [x2, #8]
 11167a0:	17fffffb 	b	111678c <tee_ta_init_user_ta_session+0x190>
		return TEE_ERROR_OUT_OF_MEMORY;
 11167a4:	129ffe74 	mov	w20, #0xffff000c            	// #-65524
 11167a8:	17ffffed 	b	111675c <tee_ta_init_user_ta_session+0x160>

00000000011167ac <ree_fs_ta_get_size>:
static TEE_Result ree_fs_ta_get_size(const struct ts_store_handle *h,
				     size_t *size)
{
	struct ree_fs_ta_handle *handle = (struct ree_fs_ta_handle *)h;

	*size = handle->shdr->img_size;
 11167ac:	f9401000 	ldr	x0, [x0, #32]
 11167b0:	b9400800 	ldr	w0, [x0, #8]
 11167b4:	f9000020 	str	x0, [x1]
	return TEE_SUCCESS;
}
 11167b8:	52800000 	mov	w0, #0x0                   	// #0
 11167bc:	d65f03c0 	ret

00000000011167c0 <ree_fs_ta_get_tag>:

static TEE_Result ree_fs_ta_get_tag(const struct ts_store_handle *h,
				    uint8_t *tag, unsigned int *tag_len)
{
 11167c0:	aa0003e3 	mov	x3, x0
 11167c4:	aa0103e0 	mov	x0, x1
 11167c8:	f9401061 	ldr	x1, [x3, #32]
 11167cc:	79402023 	ldrh	w3, [x1, #16]
	struct ree_fs_ta_handle *handle = (struct ree_fs_ta_handle *)h;

	if (!tag || *tag_len < handle->shdr->hash_size) {
 11167d0:	b4000080 	cbz	x0, 11167e0 <ree_fs_ta_get_tag+0x20>
 11167d4:	b9400044 	ldr	w4, [x2]
 11167d8:	6b03009f 	cmp	w4, w3
 11167dc:	54000082 	b.cs	11167ec <ree_fs_ta_get_tag+0x2c>  // b.hs, b.nlast
		*tag_len = handle->shdr->hash_size;
		return TEE_ERROR_SHORT_BUFFER;
 11167e0:	129ffde0 	mov	w0, #0xffff0010            	// #-65520
		*tag_len = handle->shdr->hash_size;
 11167e4:	b9000043 	str	w3, [x2]
	*tag_len = handle->shdr->hash_size;

	memcpy(tag, SHDR_GET_HASH(handle->shdr), handle->shdr->hash_size);

	return TEE_SUCCESS;
}
 11167e8:	d65f03c0 	ret
{
 11167ec:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	memcpy(tag, SHDR_GET_HASH(handle->shdr), handle->shdr->hash_size);
 11167f0:	91005021 	add	x1, x1, #0x14
{
 11167f4:	910003fd 	mov	x29, sp
	*tag_len = handle->shdr->hash_size;
 11167f8:	b9000043 	str	w3, [x2]
	memcpy(tag, SHDR_GET_HASH(handle->shdr), handle->shdr->hash_size);
 11167fc:	92403c62 	and	x2, x3, #0xffff
 1116800:	97ffb2e4 	bl	1103390 <memcpy>
	return TEE_SUCCESS;
 1116804:	52800000 	mov	w0, #0x0                   	// #0
}
 1116808:	a8c17bfd 	ldp	x29, x30, [sp], #16
 111680c:	d65f03c0 	ret

0000000001116810 <ree_fs_ta_read>:
	return res;
}

static TEE_Result ree_fs_ta_read(struct ts_store_handle *h, void *data,
				 size_t len)
{
 1116810:	d10403ff 	sub	sp, sp, #0x100
 1116814:	a9017bfd 	stp	x29, x30, [sp, #16]
 1116818:	910043fd 	add	x29, sp, #0x10
 111681c:	a90253f3 	stp	x19, x20, [sp, #32]
 1116820:	aa0003f3 	mov	x19, x0
	struct ree_fs_ta_handle *handle = (struct ree_fs_ta_handle *)h;

	uint8_t *src = (uint8_t *)handle->nw_ta + handle->offs;
 1116824:	f9400c00 	ldr	x0, [x0, #24]
{
 1116828:	a9035bf5 	stp	x21, x22, [sp, #48]
 111682c:	a90463f7 	stp	x23, x24, [sp, #64]
	size_t next_offs = 0;
	uint8_t *dst = src;
	TEE_Result res = TEE_SUCCESS;

	if (ADD_OVERFLOW(handle->offs, len, &next_offs) ||
 1116830:	ab020018 	adds	x24, x0, x2
{
 1116834:	a9056bf9 	stp	x25, x26, [sp, #80]
 1116838:	a90673fb 	stp	x27, x28, [sp, #96]
	if (ADD_OVERFLOW(handle->offs, len, &next_offs) ||
 111683c:	54001f02 	b.cs	1116c1c <ree_fs_ta_read+0x40c>  // b.hs, b.nlast
 1116840:	f9400663 	ldr	x3, [x19, #8]
 1116844:	9a9f37fb 	cset	x27, cs  // cs = hs, nlast
 1116848:	eb03031f 	cmp	x24, x3
 111684c:	54001e88 	b.hi	1116c1c <ree_fs_ta_read+0x40c>  // b.pmore
	uint8_t *src = (uint8_t *)handle->nw_ta + handle->offs;
 1116850:	f9400276 	ldr	x22, [x19]
 1116854:	aa0103f5 	mov	x21, x1
 1116858:	aa0203f4 	mov	x20, x2
 111685c:	8b0002d6 	add	x22, x22, x0
	    next_offs > handle->nw_ta_size)
		return TEE_ERROR_BAD_PARAMETERS;

	if (handle->shdr->img_type == SHDR_ENCRYPTED_TA) {
 1116860:	f9401260 	ldr	x0, [x19, #32]
 1116864:	b9400400 	ldr	w0, [x0, #4]
 1116868:	7100081f 	cmp	w0, #0x2
 111686c:	54001401 	b.ne	1116aec <ree_fs_ta_read+0x2dc>  // b.any
		if (data) {
 1116870:	b4000201 	cbz	x1, 11168b0 <ree_fs_ta_read+0xa0>
			dst = data; /* Hash secure buffer */
			res = tee_ta_decrypt_update(handle->enc_ctx, dst, src,
 1116874:	f9401a60 	ldr	x0, [x19, #48]
 1116878:	aa0203e3 	mov	x3, x2
 111687c:	aa1603e2 	mov	x2, x22
 1116880:	940044f2 	bl	1127c48 <tee_ta_decrypt_update>
						    len);
			if (res != TEE_SUCCESS)
 1116884:	340013c0 	cbz	w0, 1116afc <ree_fs_ta_read+0x2ec>
				return TEE_ERROR_SECURITY;
 1116888:	129ffe16 	mov	w22, #0xffff000f            	// #-65521

		if (handle->bs_hdr)
			res = check_update_version(handle->bs_hdr);
	}
	return res;
}
 111688c:	2a1603e0 	mov	w0, w22
 1116890:	a9417bfd 	ldp	x29, x30, [sp, #16]
 1116894:	a94253f3 	ldp	x19, x20, [sp, #32]
 1116898:	a9435bf5 	ldp	x21, x22, [sp, #48]
 111689c:	a94463f7 	ldp	x23, x24, [sp, #64]
 11168a0:	a9456bf9 	ldp	x25, x26, [sp, #80]
 11168a4:	a94673fb 	ldp	x27, x28, [sp, #96]
 11168a8:	910403ff 	add	sp, sp, #0x100
 11168ac:	d65f03c0 	ret
			size_t b_size = MIN(1024U, len);
 11168b0:	f110005f 	cmp	x2, #0x400
 11168b4:	d2808019 	mov	x25, #0x400                 	// #1024
 11168b8:	9a999059 	csel	x25, x2, x25, ls  // ls = plast
			uint8_t *b = malloc(b_size);
 11168bc:	aa1903e0 	mov	x0, x25
 11168c0:	9400b2e6 	bl	1143458 <malloc>
 11168c4:	aa0003f7 	mov	x23, x0
			if (!b)
 11168c8:	b5000280 	cbnz	x0, 1116918 <ree_fs_ta_read+0x108>
				return TEE_ERROR_OUT_OF_MEMORY;
 11168cc:	129ffe76 	mov	w22, #0xffff000c            	// #-65524
 11168d0:	17ffffef 	b	111688c <ree_fs_ta_read+0x7c>
				size_t n = MIN(b_size, len - num_bytes);
 11168d4:	cb1b029a 	sub	x26, x20, x27
				res = tee_ta_decrypt_update(handle->enc_ctx, b,
 11168d8:	8b1b02c2 	add	x2, x22, x27
 11168dc:	f9401a60 	ldr	x0, [x19, #48]
				size_t n = MIN(b_size, len - num_bytes);
 11168e0:	eb19035f 	cmp	x26, x25
 11168e4:	9a99935a 	csel	x26, x26, x25, ls  // ls = plast
				res = tee_ta_decrypt_update(handle->enc_ctx, b,
 11168e8:	aa1703e1 	mov	x1, x23
 11168ec:	aa1a03e3 	mov	x3, x26
 11168f0:	940044d6 	bl	1127c48 <tee_ta_decrypt_update>
 11168f4:	2a0003f5 	mov	w21, w0
				if (res)
 11168f8:	35000160 	cbnz	w0, 1116924 <ree_fs_ta_read+0x114>
				res = crypto_hash_update(handle->hash_ctx, b,
 11168fc:	f9401660 	ldr	x0, [x19, #40]
 1116900:	aa1a03e2 	mov	x2, x26
 1116904:	aa1703e1 	mov	x1, x23
				num_bytes += n;
 1116908:	8b1a037b 	add	x27, x27, x26
				res = crypto_hash_update(handle->hash_ctx, b,
 111690c:	97ffda86 	bl	110d324 <crypto_hash_update>
 1116910:	2a0003f5 	mov	w21, w0
				if (res)
 1116914:	35000080 	cbnz	w0, 1116924 <ree_fs_ta_read+0x114>
			while (num_bytes < len) {
 1116918:	eb14037f 	cmp	x27, x20
 111691c:	54fffdc3 	b.cc	11168d4 <ree_fs_ta_read+0xc4>  // b.lo, b.ul, b.last
 1116920:	52800015 	mov	w21, #0x0                   	// #0
			free(b);
 1116924:	aa1703e0 	mov	x0, x23
 1116928:	9400b32e 	bl	11435e0 <free>
			if (res != TEE_SUCCESS)
 111692c:	35fffaf5 	cbnz	w21, 1116888 <ree_fs_ta_read+0x78>
	if (handle->offs == handle->nw_ta_size) {
 1116930:	f9400660 	ldr	x0, [x19, #8]
	handle->offs = next_offs;
 1116934:	f9000e78 	str	x24, [x19, #24]
	if (handle->offs == handle->nw_ta_size) {
 1116938:	eb00031f 	cmp	x24, x0
 111693c:	54000f21 	b.ne	1116b20 <ree_fs_ta_read+0x310>  // b.any
		if (handle->shdr->img_type == SHDR_ENCRYPTED_TA) {
 1116940:	f9401260 	ldr	x0, [x19, #32]
 1116944:	b9400400 	ldr	w0, [x0, #4]
 1116948:	7100081f 	cmp	w0, #0x2
 111694c:	54000ee0 	b.eq	1116b28 <ree_fs_ta_read+0x318>  // b.none
	digest = malloc(h->shdr->hash_size);
 1116950:	f9401260 	ldr	x0, [x19, #32]
 1116954:	79402015 	ldrh	w21, [x0, #16]
 1116958:	aa1503e0 	mov	x0, x21
 111695c:	9400b2bf 	bl	1143458 <malloc>
 1116960:	aa0003f4 	mov	x20, x0
	if (!digest)
 1116964:	b4fffb40 	cbz	x0, 11168cc <ree_fs_ta_read+0xbc>
	res = crypto_hash_final(h->hash_ctx, digest, h->shdr->hash_size);
 1116968:	aa0003e1 	mov	x1, x0
 111696c:	aa1503e2 	mov	x2, x21
 1116970:	f9401660 	ldr	x0, [x19, #40]
 1116974:	97ffda7d 	bl	110d368 <crypto_hash_final>
	if (res != TEE_SUCCESS) {
 1116978:	35000e80 	cbnz	w0, 1116b48 <ree_fs_ta_read+0x338>
	if (memcmp(digest, SHDR_GET_HASH(h->shdr), h->shdr->hash_size))
 111697c:	f9401261 	ldr	x1, [x19, #32]
 1116980:	aa1403e0 	mov	x0, x20
		res = TEE_ERROR_SECURITY;
 1116984:	129ffe16 	mov	w22, #0xffff000f            	// #-65521
	if (memcmp(digest, SHDR_GET_HASH(h->shdr), h->shdr->hash_size))
 1116988:	91005021 	add	x1, x1, #0x14
 111698c:	785fc022 	ldurh	w2, [x1, #-4]
 1116990:	9400b4b0 	bl	1143c50 <memcmp>
		res = TEE_ERROR_SECURITY;
 1116994:	7100001f 	cmp	w0, #0x0
 1116998:	1a9603f6 	csel	w22, wzr, w22, eq  // eq = none
	free(digest);
 111699c:	aa1403e0 	mov	x0, x20
 11169a0:	9400b310 	bl	11435e0 <free>
		if (res != TEE_SUCCESS)
 11169a4:	35fff756 	cbnz	w22, 111688c <ree_fs_ta_read+0x7c>
		if (handle->bs_hdr)
 11169a8:	f9401e77 	ldr	x23, [x19, #56]
 11169ac:	b4000bb7 	cbz	x23, 1116b20 <ree_fs_ta_read+0x310>
	struct tee_pobj pobj = {
 11169b0:	9102e3f9 	add	x25, sp, #0xb8
 11169b4:	d2800902 	mov	x2, #0x48                  	// #72
 11169b8:	52800001 	mov	w1, #0x0                   	// #0
 11169bc:	aa1903e0 	mov	x0, x25
	size_t len = 0;
 11169c0:	a908ffff 	stp	xzr, xzr, [sp, #136]
	mutex_lock(&ta_ver_db_mutex);
 11169c4:	90000255 	adrp	x21, 115e000 <state+0x80>
	res = ops->open(&pobj, NULL, &fh);
 11169c8:	910223f4 	add	x20, sp, #0x88
	struct ta_ver_db_hdr db_hdr = { };
 11169cc:	f9004fff 	str	xzr, [sp, #152]
	struct shdr_bootstrap_ta hdr_entry = { };
 11169d0:	a90a7fff 	stp	xzr, xzr, [sp, #160]
 11169d4:	b900b3ff 	str	wzr, [sp, #176]
	struct tee_pobj pobj = {
 11169d8:	9400b4c2 	bl	1143ce0 <memset>
 11169dc:	d00001e0 	adrp	x0, 1154000 <__func__.1786+0x8>
 11169e0:	91391c00 	add	x0, x0, #0xe47
 11169e4:	f90073e0 	str	x0, [sp, #224]
 11169e8:	52800140 	mov	w0, #0xa                   	// #10
 11169ec:	b900ebe0 	str	w0, [sp, #232]
	mutex_lock(&ta_ver_db_mutex);
 11169f0:	9104c2a0 	add	x0, x21, #0x130
 11169f4:	97fffad8 	bl	1115554 <mutex_lock>
	ops = tee_svc_storage_file_ops(TEE_STORAGE_PRIVATE);
 11169f8:	52800020 	mov	w0, #0x1                   	// #1
 11169fc:	94002c82 	bl	1121c04 <tee_svc_storage_file_ops>
 1116a00:	aa0003f8 	mov	x24, x0
	res = ops->open(&pobj, NULL, &fh);
 1116a04:	aa1403e2 	mov	x2, x20
 1116a08:	aa1903e0 	mov	x0, x25
 1116a0c:	d2800001 	mov	x1, #0x0                   	// #0
 1116a10:	f9400303 	ldr	x3, [x24]
 1116a14:	d63f0060 	blr	x3
 1116a18:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS && res != TEE_ERROR_ITEM_NOT_FOUND)
 1116a1c:	f9003bf5 	str	x21, [sp, #112]
 1116a20:	7100027f 	cmp	w19, #0x0
 1116a24:	129ffee0 	mov	w0, #0xffff0008            	// #-65528
 1116a28:	7a401264 	ccmp	w19, w0, #0x4, ne  // ne = any
 1116a2c:	54000ae1 	b.ne	1116b88 <ree_fs_ta_read+0x378>  // b.any
	if (res == TEE_ERROR_ITEM_NOT_FOUND) {
 1116a30:	6b00027f 	cmp	w19, w0
 1116a34:	540008e1 	b.ne	1116b50 <ree_fs_ta_read+0x340>  // b.any
		res = ops->create(&pobj, false, NULL, 0, NULL, 0, NULL, 0, &fh);
 1116a38:	f90003f4 	str	x20, [sp]
 1116a3c:	aa1903e0 	mov	x0, x25
 1116a40:	d2800007 	mov	x7, #0x0                   	// #0
 1116a44:	d2800006 	mov	x6, #0x0                   	// #0
 1116a48:	f9400708 	ldr	x8, [x24, #8]
 1116a4c:	d2800005 	mov	x5, #0x0                   	// #0
 1116a50:	d2800004 	mov	x4, #0x0                   	// #0
 1116a54:	d2800003 	mov	x3, #0x0                   	// #0
 1116a58:	d2800002 	mov	x2, #0x0                   	// #0
 1116a5c:	52800001 	mov	w1, #0x0                   	// #0
 1116a60:	d63f0100 	blr	x8
 1116a64:	2a0003f3 	mov	w19, w0
		if (res != TEE_SUCCESS)
 1116a68:	35000900 	cbnz	w0, 1116b88 <ree_fs_ta_read+0x378>
		res = ops->write(fh, 0, &db_hdr, sizeof(db_hdr));
 1116a6c:	f9401304 	ldr	x4, [x24, #32]
 1116a70:	910263e2 	add	x2, sp, #0x98
 1116a74:	f94047e0 	ldr	x0, [sp, #136]
 1116a78:	d2800103 	mov	x3, #0x8                   	// #8
 1116a7c:	d2800001 	mov	x1, #0x0                   	// #0
 1116a80:	d63f0080 	blr	x4
 1116a84:	2a0003f3 	mov	w19, w0
		if (res != TEE_SUCCESS)
 1116a88:	35000800 	cbnz	w0, 1116b88 <ree_fs_ta_read+0x378>
		res = ops->read(fh, sizeof(db_hdr) + (i * len), &hdr_entry,
 1116a8c:	910243fa 	add	x26, sp, #0x90
 1116a90:	910283f5 	add	x21, sp, #0xa0
 1116a94:	d2800119 	mov	x25, #0x8                   	// #8
 1116a98:	d280029b 	mov	x27, #0x14                  	// #20
	for (i = 0; i < db_hdr.nb_entries; i++) {
 1116a9c:	b9409fe1 	ldr	w1, [sp, #156]
 1116aa0:	f94047e0 	ldr	x0, [sp, #136]
 1116aa4:	6b0102df 	cmp	w22, w1
 1116aa8:	54000803 	b.cc	1116ba8 <ree_fs_ta_read+0x398>  // b.lo, b.ul, b.last
		res = ops->write(fh, sizeof(db_hdr) + (db_hdr.nb_entries * len),
 1116aac:	9bbb6421 	umaddl	x1, w1, w27, x25
		len = sizeof(*hdr);
 1116ab0:	f9004bfb 	str	x27, [sp, #144]
		res = ops->write(fh, sizeof(db_hdr) + (db_hdr.nb_entries * len),
 1116ab4:	f9401304 	ldr	x4, [x24, #32]
 1116ab8:	aa1703e2 	mov	x2, x23
 1116abc:	d2800283 	mov	x3, #0x14                  	// #20
 1116ac0:	d63f0080 	blr	x4
 1116ac4:	2a0003f3 	mov	w19, w0
		if (res != TEE_SUCCESS)
 1116ac8:	35000600 	cbnz	w0, 1116b88 <ree_fs_ta_read+0x378>
		db_hdr.nb_entries++;
 1116acc:	b9409fe0 	ldr	w0, [sp, #156]
		res = ops->write(fh, 0, &db_hdr, sizeof(db_hdr));
 1116ad0:	910263e2 	add	x2, sp, #0x98
 1116ad4:	d2800103 	mov	x3, #0x8                   	// #8
 1116ad8:	d2800001 	mov	x1, #0x0                   	// #0
		db_hdr.nb_entries++;
 1116adc:	11000400 	add	w0, w0, #0x1
 1116ae0:	b9009fe0 	str	w0, [sp, #156]
		res = ops->write(fh, 0, &db_hdr, sizeof(db_hdr));
 1116ae4:	f9401304 	ldr	x4, [x24, #32]
 1116ae8:	14000049 	b	1116c0c <ree_fs_ta_read+0x3fc>
	} else if (data) {
 1116aec:	b4000141 	cbz	x1, 1116b14 <ree_fs_ta_read+0x304>
		memcpy(dst, src, len);
 1116af0:	aa1603e1 	mov	x1, x22
 1116af4:	aa1503e0 	mov	x0, x21
 1116af8:	97ffb226 	bl	1103390 <memcpy>
		res = crypto_hash_update(handle->hash_ctx, dst, len);
 1116afc:	f9401660 	ldr	x0, [x19, #40]
 1116b00:	aa1403e2 	mov	x2, x20
 1116b04:	aa1503e1 	mov	x1, x21
 1116b08:	97ffda07 	bl	110d324 <crypto_hash_update>
		if (res != TEE_SUCCESS)
 1116b0c:	34fff120 	cbz	w0, 1116930 <ree_fs_ta_read+0x120>
 1116b10:	17ffff5e 	b	1116888 <ree_fs_ta_read+0x78>
	if (dst) {
 1116b14:	b4fff0f6 	cbz	x22, 1116930 <ree_fs_ta_read+0x120>
 1116b18:	aa1603f5 	mov	x21, x22
 1116b1c:	17fffff8 	b	1116afc <ree_fs_ta_read+0x2ec>
		return TEE_ERROR_BAD_PARAMETERS;
 1116b20:	52800016 	mov	w22, #0x0                   	// #0
 1116b24:	17ffff5a 	b	111688c <ree_fs_ta_read+0x7c>
			res = tee_ta_decrypt_final(handle->enc_ctx,
 1116b28:	f9401a60 	ldr	x0, [x19, #48]
 1116b2c:	d2800004 	mov	x4, #0x0                   	// #0
 1116b30:	f9402261 	ldr	x1, [x19, #64]
 1116b34:	d2800003 	mov	x3, #0x0                   	// #0
 1116b38:	d2800002 	mov	x2, #0x0                   	// #0
 1116b3c:	94004454 	bl	1127c8c <tee_ta_decrypt_final>
			if (res != TEE_SUCCESS)
 1116b40:	34fff080 	cbz	w0, 1116950 <ree_fs_ta_read+0x140>
 1116b44:	17ffff51 	b	1116888 <ree_fs_ta_read+0x78>
		res = TEE_ERROR_SECURITY;
 1116b48:	129ffe16 	mov	w22, #0xffff000f            	// #-65521
 1116b4c:	17ffff94 	b	111699c <ree_fs_ta_read+0x18c>
		len = sizeof(db_hdr);
 1116b50:	d2800100 	mov	x0, #0x8                   	// #8
 1116b54:	f9004be0 	str	x0, [sp, #144]
		res = ops->read(fh, 0, &db_hdr, &len);
 1116b58:	f9400f04 	ldr	x4, [x24, #24]
 1116b5c:	910243e3 	add	x3, sp, #0x90
 1116b60:	f94047e0 	ldr	x0, [sp, #136]
 1116b64:	910263e2 	add	x2, sp, #0x98
 1116b68:	d2800001 	mov	x1, #0x0                   	// #0
 1116b6c:	d63f0080 	blr	x4
 1116b70:	2a0003f3 	mov	w19, w0
		if (res != TEE_SUCCESS) {
 1116b74:	350000a0 	cbnz	w0, 1116b88 <ree_fs_ta_read+0x378>
		} else if (len != sizeof(db_hdr)) {
 1116b78:	f9404be0 	ldr	x0, [sp, #144]
 1116b7c:	f100201f 	cmp	x0, #0x8
 1116b80:	54fff860 	b.eq	1116a8c <ree_fs_ta_read+0x27c>  // b.none
			res = TEE_ERROR_BAD_STATE;
 1116b84:	129fff13 	mov	w19, #0xffff0007            	// #-65529
	ops->close(&fh);
 1116b88:	f9400b01 	ldr	x1, [x24, #16]
 1116b8c:	aa1403e0 	mov	x0, x20
			res = check_update_version(handle->bs_hdr);
 1116b90:	2a1303f6 	mov	w22, w19
	ops->close(&fh);
 1116b94:	d63f0020 	blr	x1
	mutex_unlock(&ta_ver_db_mutex);
 1116b98:	f9403be0 	ldr	x0, [sp, #112]
 1116b9c:	9104c000 	add	x0, x0, #0x130
 1116ba0:	97fffa4c 	bl	11154d0 <mutex_unlock>
	return res;
 1116ba4:	17ffff3a 	b	111688c <ree_fs_ta_read+0x7c>
		res = ops->read(fh, sizeof(db_hdr) + (i * len), &hdr_entry,
 1116ba8:	f9400f05 	ldr	x5, [x24, #24]
 1116bac:	9bbb66dc 	umaddl	x28, w22, w27, x25
		len = sizeof(hdr_entry);
 1116bb0:	f9004bfb 	str	x27, [sp, #144]
		res = ops->read(fh, sizeof(db_hdr) + (i * len), &hdr_entry,
 1116bb4:	aa1a03e3 	mov	x3, x26
 1116bb8:	aa1503e2 	mov	x2, x21
 1116bbc:	aa1c03e1 	mov	x1, x28
 1116bc0:	d63f00a0 	blr	x5
 1116bc4:	2a0003f3 	mov	w19, w0
		if (res != TEE_SUCCESS) {
 1116bc8:	35fffe00 	cbnz	w0, 1116b88 <ree_fs_ta_read+0x378>
		} else if (len != sizeof(hdr_entry)) {
 1116bcc:	f9404be3 	ldr	x3, [sp, #144]
 1116bd0:	f9003fe3 	str	x3, [sp, #120]
 1116bd4:	f100507f 	cmp	x3, #0x14
 1116bd8:	54fffd61 	b.ne	1116b84 <ree_fs_ta_read+0x374>  // b.any
		if (!memcmp(hdr->uuid, hdr_entry.uuid, sizeof(TEE_UUID))) {
 1116bdc:	aa1503e1 	mov	x1, x21
 1116be0:	aa1703e0 	mov	x0, x23
 1116be4:	d2800202 	mov	x2, #0x10                  	// #16
 1116be8:	9400b41a 	bl	1143c50 <memcmp>
 1116bec:	f9403fe3 	ldr	x3, [sp, #120]
 1116bf0:	340001a0 	cbz	w0, 1116c24 <ree_fs_ta_read+0x414>
	for (i = 0; i < db_hdr.nb_entries; i++) {
 1116bf4:	110006d6 	add	w22, w22, #0x1
 1116bf8:	17ffffa9 	b	1116a9c <ree_fs_ta_read+0x28c>
		} else if (hdr_entry.ta_version < hdr->ta_version) {
 1116bfc:	54fffc62 	b.cs	1116b88 <ree_fs_ta_read+0x378>  // b.hs, b.nlast
			res = ops->write(fh, sizeof(db_hdr) + (i * len), hdr,
 1116c00:	f9401304 	ldr	x4, [x24, #32]
 1116c04:	aa1703e2 	mov	x2, x23
 1116c08:	aa1c03e1 	mov	x1, x28
		res = ops->write(fh, 0, &db_hdr, sizeof(db_hdr));
 1116c0c:	f94047e0 	ldr	x0, [sp, #136]
 1116c10:	d63f0080 	blr	x4
 1116c14:	2a0003f3 	mov	w19, w0
out:
 1116c18:	17ffffdc 	b	1116b88 <ree_fs_ta_read+0x378>
		return TEE_ERROR_BAD_PARAMETERS;
 1116c1c:	129fff36 	mov	w22, #0xffff0006            	// #-65530
 1116c20:	17ffff1b 	b	111688c <ree_fs_ta_read+0x7c>
		if (hdr_entry.ta_version > hdr->ta_version) {
 1116c24:	b94012e0 	ldr	w0, [x23, #16]
 1116c28:	b940b3e1 	ldr	w1, [sp, #176]
 1116c2c:	6b00003f 	cmp	w1, w0
 1116c30:	54fffe69 	b.ls	1116bfc <ree_fs_ta_read+0x3ec>  // b.plast
			res = TEE_ERROR_ACCESS_CONFLICT;
 1116c34:	129fff93 	mov	w19, #0xffff0003            	// #-65533
 1116c38:	17ffffd4 	b	1116b88 <ree_fs_ta_read+0x378>

0000000001116c3c <ree_fs_ta_close>:

static void ree_fs_ta_close(struct ts_store_handle *h)
{
	struct ree_fs_ta_handle *handle = (struct ree_fs_ta_handle *)h;

	if (!handle)
 1116c3c:	b4000260 	cbz	x0, 1116c88 <ree_fs_ta_close+0x4c>
{
 1116c40:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1116c44:	910003fd 	mov	x29, sp
 1116c48:	f9000bf3 	str	x19, [sp, #16]
 1116c4c:	aa0003f3 	mov	x19, x0
		return;
	thread_rpc_free_payload(handle->mobj);
 1116c50:	f9400800 	ldr	x0, [x0, #16]
 1116c54:	97ffc111 	bl	1107098 <thread_rpc_free_payload>
	crypto_hash_free_ctx(handle->hash_ctx);
 1116c58:	f9401660 	ldr	x0, [x19, #40]
 1116c5c:	97ffd98d 	bl	110d290 <crypto_hash_free_ctx>
	free(handle->shdr);
 1116c60:	f9401260 	ldr	x0, [x19, #32]
 1116c64:	9400b25f 	bl	11435e0 <free>
	free(handle->ehdr);
 1116c68:	f9402260 	ldr	x0, [x19, #64]
 1116c6c:	9400b25d 	bl	11435e0 <free>
	free(handle->bs_hdr);
 1116c70:	f9401e60 	ldr	x0, [x19, #56]
 1116c74:	9400b25b 	bl	11435e0 <free>
	free(handle);
 1116c78:	aa1303e0 	mov	x0, x19
}
 1116c7c:	f9400bf3 	ldr	x19, [sp, #16]
 1116c80:	a8c27bfd 	ldp	x29, x30, [sp], #32
	free(handle);
 1116c84:	1400b257 	b	11435e0 <free>
 1116c88:	d65f03c0 	ret

0000000001116c8c <ree_fs_ta_open>:
{
 1116c8c:	a9b37bfd 	stp	x29, x30, [sp, #-208]!
 1116c90:	910003fd 	mov	x29, sp
 1116c94:	a90153f3 	stp	x19, x20, [sp, #16]
 1116c98:	a9025bf5 	stp	x21, x22, [sp, #32]
 1116c9c:	a90363f7 	stp	x23, x24, [sp, #48]
 1116ca0:	a9046bf9 	stp	x25, x26, [sp, #64]
 1116ca4:	aa0003f9 	mov	x25, x0
	handle = calloc(1, sizeof(*handle));
 1116ca8:	d2800020 	mov	x0, #0x1                   	// #1
{
 1116cac:	a90573fb 	stp	x27, x28, [sp, #80]
 1116cb0:	f90037e1 	str	x1, [sp, #104]
	handle = calloc(1, sizeof(*handle));
 1116cb4:	d2800901 	mov	x1, #0x48                  	// #72
	void *hash_ctx = NULL;
 1116cb8:	f90047ff 	str	xzr, [sp, #136]
	handle = calloc(1, sizeof(*handle));
 1116cbc:	9400b205 	bl	11434d0 <calloc>
	if (!handle)
 1116cc0:	b4001be0 	cbz	x0, 111703c <ree_fs_ta_open+0x3b0>
 1116cc4:	aa0003f5 	mov	x21, x0
	if (!uuid || !ta || !mobj || !ta_size)
 1116cc8:	b4001f39 	cbz	x25, 11170ac <ree_fs_ta_open+0x420>
	memset(params, 0, sizeof(params));
 1116ccc:	910243fa 	add	x26, sp, #0x90
 1116cd0:	a9097fff 	stp	xzr, xzr, [sp, #144]
	tee_uuid_to_octets((void *)&params[0].u.value, uuid);
 1116cd4:	91002354 	add	x20, x26, #0x8
 1116cd8:	aa1903e1 	mov	x1, x25
 1116cdc:	aa1403e0 	mov	x0, x20
	params[0].attr = THREAD_PARAM_ATTR_VALUE_IN;
 1116ce0:	52800038 	mov	w24, #0x1                   	// #1
 1116ce4:	b90093f8 	str	w24, [sp, #144]
	memset(params, 0, sizeof(params));
 1116ce8:	a90a7fff 	stp	xzr, xzr, [sp, #160]
	params[1].attr = THREAD_PARAM_ATTR_MEMREF_OUT;
 1116cec:	528000b3 	mov	w19, #0x5                   	// #5
	memset(params, 0, sizeof(params));
 1116cf0:	a90b7fff 	stp	xzr, xzr, [sp, #176]
 1116cf4:	a90c7fff 	stp	xzr, xzr, [sp, #192]
	tee_uuid_to_octets((void *)&params[0].u.value, uuid);
 1116cf8:	940043fc 	bl	1127ce8 <tee_uuid_to_octets>
	res = thread_rpc_cmd(OPTEE_RPC_CMD_LOAD_TA, 2, params);
 1116cfc:	aa1a03e2 	mov	x2, x26
 1116d00:	d2800041 	mov	x1, #0x2                   	// #2
 1116d04:	52800000 	mov	w0, #0x0                   	// #0
	params[1].attr = THREAD_PARAM_ATTR_MEMREF_OUT;
 1116d08:	b900b3f3 	str	w19, [sp, #176]
	res = thread_rpc_cmd(OPTEE_RPC_CMD_LOAD_TA, 2, params);
 1116d0c:	97ffc094 	bl	1106f5c <thread_rpc_cmd>
 1116d10:	2a0003fc 	mov	w28, w0
	if (res != TEE_SUCCESS)
 1116d14:	35000540 	cbnz	w0, 1116dbc <ree_fs_ta_open+0x130>
	*mobj = thread_rpc_alloc_payload(params[1].u.memref.size);
 1116d18:	f94063e0 	ldr	x0, [sp, #192]
 1116d1c:	97ffc0cc 	bl	110704c <thread_rpc_alloc_payload>
 1116d20:	aa0003f6 	mov	x22, x0
	if (!*mobj)
 1116d24:	b4001c80 	cbz	x0, 11170b4 <ree_fs_ta_open+0x428>
	if ((*mobj)->size < params[1].u.memref.size) {
 1116d28:	f9400402 	ldr	x2, [x0, #8]
 1116d2c:	f94063e1 	ldr	x1, [sp, #192]
 1116d30:	eb01005f 	cmp	x2, x1
 1116d34:	540004c3 	b.cc	1116dcc <ree_fs_ta_open+0x140>  // b.lo, b.ul, b.last
	if (mobj && mobj->ops && mobj->ops->get_va)
 1116d38:	f9400001 	ldr	x1, [x0]
 1116d3c:	b5000141 	cbnz	x1, 1116d64 <ree_fs_ta_open+0xd8>
	assert(*ta);
 1116d40:	d00001e3 	adrp	x3, 1154000 <__func__.1786+0x8>
 1116d44:	d00001e1 	adrp	x1, 1154000 <__func__.1786+0x8>
 1116d48:	9138f863 	add	x3, x3, #0xe3e
 1116d4c:	91387821 	add	x1, x1, #0xe1e
 1116d50:	d00001e0 	adrp	x0, 1154000 <__func__.1786+0x8>
 1116d54:	9138d800 	add	x0, x0, #0xe36
 1116d58:	52800de2 	mov	w2, #0x6f                  	// #111
 1116d5c:	97ffed54 	bl	11122ac <_assert_log>
 1116d60:	97ffed64 	bl	11122f0 <_assert_break>
 1116d64:	f9400022 	ldr	x2, [x1]
 1116d68:	b4fffec2 	cbz	x2, 1116d40 <ree_fs_ta_open+0xb4>
		return mobj->ops->get_va(mobj, offset);
 1116d6c:	d2800001 	mov	x1, #0x0                   	// #0
 1116d70:	d63f0040 	blr	x2
 1116d74:	aa0003f7 	mov	x23, x0
 1116d78:	b4fffe40 	cbz	x0, 1116d40 <ree_fs_ta_open+0xb4>
	tee_uuid_to_octets((void *)&params[0].u.value, uuid);
 1116d7c:	aa1903e1 	mov	x1, x25
 1116d80:	aa1403e0 	mov	x0, x20
	params[0].attr = THREAD_PARAM_ATTR_VALUE_IN;
 1116d84:	b90093f8 	str	w24, [sp, #144]
	*ta_size = params[1].u.memref.size;
 1116d88:	f94063fb 	ldr	x27, [sp, #192]
	tee_uuid_to_octets((void *)&params[0].u.value, uuid);
 1116d8c:	940043d7 	bl	1127ce8 <tee_uuid_to_octets>
	res = thread_rpc_cmd(OPTEE_RPC_CMD_LOAD_TA, 2, params);
 1116d90:	aa1a03e2 	mov	x2, x26
 1116d94:	d2800041 	mov	x1, #0x2                   	// #2
 1116d98:	52800000 	mov	w0, #0x0                   	// #0
	params[1].attr = THREAD_PARAM_ATTR_MEMREF_OUT;
 1116d9c:	b900b3f3 	str	w19, [sp, #176]
	params[1].u.memref.offs = 0;
 1116da0:	f9005fff 	str	xzr, [sp, #184]
	params[1].u.memref.mobj = *mobj;
 1116da4:	f90067f6 	str	x22, [sp, #200]
	res = thread_rpc_cmd(OPTEE_RPC_CMD_LOAD_TA, 2, params);
 1116da8:	97ffc06d 	bl	1106f5c <thread_rpc_cmd>
 1116dac:	2a0003fc 	mov	w28, w0
	if (res != TEE_SUCCESS)
 1116db0:	340014a0 	cbz	w0, 1117044 <ree_fs_ta_open+0x3b8>
		thread_rpc_free_payload(*mobj);
 1116db4:	aa1603e0 	mov	x0, x22
 1116db8:	97ffc0b8 	bl	1107098 <thread_rpc_free_payload>
	struct shdr_encrypted_ta *ehdr = NULL;
 1116dbc:	d280001a 	mov	x26, #0x0                   	// #0
	struct shdr_bootstrap_ta *bs_hdr = NULL;
 1116dc0:	d2800014 	mov	x20, #0x0                   	// #0
	struct shdr *shdr = NULL;
 1116dc4:	d2800013 	mov	x19, #0x0                   	// #0
 1116dc8:	140000b0 	b	1117088 <ree_fs_ta_open+0x3fc>
		res = TEE_ERROR_SHORT_BUFFER;
 1116dcc:	129ffdfc 	mov	w28, #0xffff0010            	// #-65520
 1116dd0:	17fffff9 	b	1116db4 <ree_fs_ta_open+0x128>
	res = crypto_hash_alloc_ctx(&hash_ctx,
 1116dd4:	b9400e60 	ldr	w0, [x19, #12]
	if (algo == TEE_ALG_SM2_DSA_SM3)
 1116dd8:	528c08a1 	mov	w1, #0x6045                	// #24645
 1116ddc:	72ae0001 	movk	w1, #0x7000, lsl #16
 1116de0:	6b01001f 	cmp	w0, w1
 1116de4:	54000f00 	b.eq	1116fc4 <ree_fs_ta_open+0x338>  // b.none
	return (algo >> 12) & 0xF;
 1116de8:	d34c3c00 	ubfx	x0, x0, #12, #4
	return (TEE_OPERATION_DIGEST << 28) | main_hash;
 1116dec:	52aa0001 	mov	w1, #0x50000000            	// #1342177280
 1116df0:	71001c1f 	cmp	w0, #0x7
 1116df4:	2a010001 	orr	w1, w0, w1
 1116df8:	528000e0 	mov	w0, #0x7                   	// #7
 1116dfc:	72aa0000 	movk	w0, #0x5000, lsl #16
 1116e00:	1a801021 	csel	w1, w1, w0, ne  // ne = any
 1116e04:	910223e0 	add	x0, sp, #0x88
 1116e08:	97ffd8fd 	bl	110d1fc <crypto_hash_alloc_ctx>
 1116e0c:	2a0003fc 	mov	w28, w0
	if (res != TEE_SUCCESS)
 1116e10:	35001100 	cbnz	w0, 1117030 <ree_fs_ta_open+0x3a4>
	res = crypto_hash_init(hash_ctx);
 1116e14:	f94047e0 	ldr	x0, [sp, #136]
 1116e18:	97ffd938 	bl	110d2f8 <crypto_hash_init>
 1116e1c:	2a0003fc 	mov	w28, w0
	if (res != TEE_SUCCESS)
 1116e20:	35000fe0 	cbnz	w0, 111701c <ree_fs_ta_open+0x390>
	res = crypto_hash_update(hash_ctx, (uint8_t *)shdr, sizeof(*shdr));
 1116e24:	f94047e0 	ldr	x0, [sp, #136]
 1116e28:	aa1303e1 	mov	x1, x19
 1116e2c:	d2800282 	mov	x2, #0x14                  	// #20
 1116e30:	97ffd93d 	bl	110d324 <crypto_hash_update>
 1116e34:	2a0003fc 	mov	w28, w0
	if (res != TEE_SUCCESS)
 1116e38:	35000f20 	cbnz	w0, 111701c <ree_fs_ta_open+0x390>
	if (ADD_OVERFLOW(s, shdr->hash_size, &s) ||
 1116e3c:	79402260 	ldrh	w0, [x19, #16]
	    ADD_OVERFLOW(s, shdr->sig_size, &s))
 1116e40:	79402678 	ldrh	w24, [x19, #18]
 1116e44:	8b000318 	add	x24, x24, x0
	if (shdr->img_type == SHDR_BOOTSTRAP_TA ||
 1116e48:	b9400660 	ldr	w0, [x19, #4]
 1116e4c:	91005301 	add	x1, x24, #0x14
 1116e50:	51000400 	sub	w0, w0, #0x1
 1116e54:	7100041f 	cmp	w0, #0x1
 1116e58:	54000ce8 	b.hi	1116ff4 <ree_fs_ta_open+0x368>  // b.pmore
 1116e5c:	f9003be1 	str	x1, [sp, #112]
		if (ta_size < SHDR_GET_SIZE(shdr) + sizeof(*bs_hdr)) {
 1116e60:	9100a318 	add	x24, x24, #0x28
 1116e64:	eb1b031f 	cmp	x24, x27
 1116e68:	54000b48 	b.hi	1116fd0 <ree_fs_ta_open+0x344>  // b.pmore
		bs_hdr = malloc(sizeof(*bs_hdr));
 1116e6c:	d2800280 	mov	x0, #0x14                  	// #20
 1116e70:	9400b17a 	bl	1143458 <malloc>
 1116e74:	aa0003f4 	mov	x20, x0
		if (!bs_hdr) {
 1116e78:	b4000b20 	cbz	x0, 1116fdc <ree_fs_ta_open+0x350>
		memcpy(bs_hdr, (uint8_t *)ta + offs, sizeof(*bs_hdr));
 1116e7c:	f9403be1 	ldr	x1, [sp, #112]
 1116e80:	d2800282 	mov	x2, #0x14                  	// #20
 1116e84:	8b0102e1 	add	x1, x23, x1
 1116e88:	97ffb142 	bl	1103390 <memcpy>
		tee_uuid_from_octets(&bs_uuid, bs_hdr->uuid);
 1116e8c:	aa1403e1 	mov	x1, x20
 1116e90:	aa1a03e0 	mov	x0, x26
 1116e94:	940043aa 	bl	1127d3c <tee_uuid_from_octets>
		if (memcmp(&bs_uuid, uuid, sizeof(TEE_UUID))) {
 1116e98:	aa1903e1 	mov	x1, x25
 1116e9c:	aa1a03e0 	mov	x0, x26
 1116ea0:	d2800202 	mov	x2, #0x10                  	// #16
 1116ea4:	9400b36b 	bl	1143c50 <memcmp>
 1116ea8:	35000960 	cbnz	w0, 1116fd4 <ree_fs_ta_open+0x348>
		res = crypto_hash_update(hash_ctx, (uint8_t *)bs_hdr,
 1116eac:	f94047e0 	ldr	x0, [sp, #136]
 1116eb0:	aa1403e1 	mov	x1, x20
 1116eb4:	d2800282 	mov	x2, #0x14                  	// #20
 1116eb8:	97ffd91b 	bl	110d324 <crypto_hash_update>
		if (res != TEE_SUCCESS)
 1116ebc:	35000920 	cbnz	w0, 1116fe0 <ree_fs_ta_open+0x354>
		handle->bs_hdr = bs_hdr;
 1116ec0:	aa1803e1 	mov	x1, x24
 1116ec4:	f9001eb4 	str	x20, [x21, #56]
	if (shdr->img_type == SHDR_ENCRYPTED_TA) {
 1116ec8:	b9400660 	ldr	w0, [x19, #4]
 1116ecc:	91003038 	add	x24, x1, #0xc
 1116ed0:	7100081f 	cmp	w0, #0x2
 1116ed4:	54000a01 	b.ne	1117014 <ree_fs_ta_open+0x388>  // b.any
	if (ADD_OVERFLOW(s, shdr->hash_size, &s) ||
 1116ed8:	79402260 	ldrh	w0, [x19, #16]
	    ADD_OVERFLOW(s, shdr->sig_size, &s))
 1116edc:	79402662 	ldrh	w2, [x19, #18]
		    sizeof(struct shdr_bootstrap_ta) + sizeof(img_ehdr)) {
 1116ee0:	8b020000 	add	x0, x0, x2
 1116ee4:	9100d000 	add	x0, x0, #0x34
		if (ta_size < SHDR_GET_SIZE(shdr) +
 1116ee8:	eb1b001f 	cmp	x0, x27
 1116eec:	54000888 	b.hi	1116ffc <ree_fs_ta_open+0x370>  // b.pmore
		memcpy(&img_ehdr, ((uint8_t *)ta + offs), sizeof(img_ehdr));
 1116ef0:	8b0102e1 	add	x1, x23, x1
 1116ef4:	aa1a03e0 	mov	x0, x26
 1116ef8:	d2800182 	mov	x2, #0xc                   	// #12
 1116efc:	f9003fe1 	str	x1, [sp, #120]
 1116f00:	f94047f9 	ldr	x25, [sp, #136]
 1116f04:	97ffb123 	bl	1103390 <memcpy>
		ehdr = malloc(SHDR_ENC_GET_SIZE(&img_ehdr));
 1116f08:	794137e0 	ldrh	w0, [sp, #154]
 1116f0c:	794133e2 	ldrh	w2, [sp, #152]
 1116f10:	8b000042 	add	x2, x2, x0
 1116f14:	91003042 	add	x2, x2, #0xc
 1116f18:	f9003be2 	str	x2, [sp, #112]
 1116f1c:	aa0203e0 	mov	x0, x2
 1116f20:	9400b14e 	bl	1143458 <malloc>
 1116f24:	aa0003fa 	mov	x26, x0
		if (!ehdr) {
 1116f28:	b4000720 	cbz	x0, 111700c <ree_fs_ta_open+0x380>
		memcpy(ehdr, ((uint8_t *)ta + offs),
 1116f2c:	a94707e2 	ldp	x2, x1, [sp, #112]
 1116f30:	97ffb118 	bl	1103390 <memcpy>
					 SHDR_ENC_GET_SIZE(ehdr));
 1116f34:	79401740 	ldrh	w0, [x26, #10]
		res = crypto_hash_update(hash_ctx, (uint8_t *)ehdr,
 1116f38:	aa1a03e1 	mov	x1, x26
					 SHDR_ENC_GET_SIZE(ehdr));
 1116f3c:	79401342 	ldrh	w2, [x26, #8]
 1116f40:	8b000042 	add	x2, x2, x0
		res = crypto_hash_update(hash_ctx, (uint8_t *)ehdr,
 1116f44:	aa1903e0 	mov	x0, x25
 1116f48:	91003042 	add	x2, x2, #0xc
 1116f4c:	97ffd8f6 	bl	110d324 <crypto_hash_update>
		if (res != TEE_SUCCESS)
 1116f50:	350005a0 	cbnz	w0, 1117004 <ree_fs_ta_open+0x378>
		res = tee_ta_decrypt_init(&handle->enc_ctx, ehdr,
 1116f54:	b9400a62 	ldr	w2, [x19, #8]
 1116f58:	aa1a03e1 	mov	x1, x26
 1116f5c:	9100c2a0 	add	x0, x21, #0x30
 1116f60:	9400430a 	bl	1127b88 <tee_ta_decrypt_init>
		if (res != TEE_SUCCESS)
 1116f64:	35000500 	cbnz	w0, 1117004 <ree_fs_ta_open+0x378>
		offs += SHDR_ENC_GET_SIZE(ehdr);
 1116f68:	79401341 	ldrh	w1, [x26, #8]
 1116f6c:	79401740 	ldrh	w0, [x26, #10]
		handle->ehdr = ehdr;
 1116f70:	f90022ba 	str	x26, [x21, #64]
		offs += SHDR_ENC_GET_SIZE(ehdr);
 1116f74:	8b000021 	add	x1, x1, x0
 1116f78:	8b180021 	add	x1, x1, x24
	if (ta_size != offs + shdr->img_size) {
 1116f7c:	b9400a60 	ldr	w0, [x19, #8]
 1116f80:	8b010000 	add	x0, x0, x1
 1116f84:	eb1b001f 	cmp	x0, x27
 1116f88:	54000501 	b.ne	1117028 <ree_fs_ta_open+0x39c>  // b.any
	handle->hash_ctx = hash_ctx;
 1116f8c:	f94047e0 	ldr	x0, [sp, #136]
 1116f90:	a90202b3 	stp	x19, x0, [x21, #32]
	*h = (struct ts_store_handle *)handle;
 1116f94:	f94037e0 	ldr	x0, [sp, #104]
	handle->nw_ta_size = ta_size;
 1116f98:	a9006eb7 	stp	x23, x27, [x21]
	handle->offs = offs;
 1116f9c:	a90106b6 	stp	x22, x1, [x21, #16]
	*h = (struct ts_store_handle *)handle;
 1116fa0:	f9000015 	str	x21, [x0]
}
 1116fa4:	2a1c03e0 	mov	w0, w28
 1116fa8:	a94153f3 	ldp	x19, x20, [sp, #16]
 1116fac:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1116fb0:	a94363f7 	ldp	x23, x24, [sp, #48]
 1116fb4:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1116fb8:	a94573fb 	ldp	x27, x28, [sp, #80]
 1116fbc:	a8cd7bfd 	ldp	x29, x30, [sp], #208
 1116fc0:	d65f03c0 	ret
		return TEE_ALG_SM3;
 1116fc4:	528000e1 	mov	w1, #0x7                   	// #7
 1116fc8:	72aa0001 	movk	w1, #0x5000, lsl #16
 1116fcc:	17ffff8e 	b	1116e04 <ree_fs_ta_open+0x178>
	struct shdr_bootstrap_ta *bs_hdr = NULL;
 1116fd0:	d2800014 	mov	x20, #0x0                   	// #0
			res = TEE_ERROR_SECURITY;
 1116fd4:	129ffe00 	mov	w0, #0xffff000f            	// #-65521
 1116fd8:	14000002 	b	1116fe0 <ree_fs_ta_open+0x354>
			res = TEE_ERROR_OUT_OF_MEMORY;
 1116fdc:	129ffe60 	mov	w0, #0xffff000c            	// #-65524
			goto error_free_hash;
 1116fe0:	2a0003fc 	mov	w28, w0
	struct shdr_encrypted_ta *ehdr = NULL;
 1116fe4:	d280001a 	mov	x26, #0x0                   	// #0
	crypto_hash_free_ctx(hash_ctx);
 1116fe8:	f94047e0 	ldr	x0, [sp, #136]
 1116fec:	97ffd8a9 	bl	110d290 <crypto_hash_free_ctx>
 1116ff0:	14000024 	b	1117080 <ree_fs_ta_open+0x3f4>
	struct shdr_bootstrap_ta *bs_hdr = NULL;
 1116ff4:	d2800014 	mov	x20, #0x0                   	// #0
 1116ff8:	17ffffb4 	b	1116ec8 <ree_fs_ta_open+0x23c>
	struct shdr_encrypted_ta *ehdr = NULL;
 1116ffc:	d280001a 	mov	x26, #0x0                   	// #0
			res = TEE_ERROR_SECURITY;
 1117000:	129ffe00 	mov	w0, #0xffff000f            	// #-65521
			goto error_free_hash;
 1117004:	2a0003fc 	mov	w28, w0
 1117008:	17fffff8 	b	1116fe8 <ree_fs_ta_open+0x35c>
			res = TEE_ERROR_OUT_OF_MEMORY;
 111700c:	129ffe60 	mov	w0, #0xffff000c            	// #-65524
 1117010:	17fffffd 	b	1117004 <ree_fs_ta_open+0x378>
	struct shdr_encrypted_ta *ehdr = NULL;
 1117014:	d280001a 	mov	x26, #0x0                   	// #0
 1117018:	17ffffd9 	b	1116f7c <ree_fs_ta_open+0x2f0>
 111701c:	d280001a 	mov	x26, #0x0                   	// #0
	struct shdr_bootstrap_ta *bs_hdr = NULL;
 1117020:	d2800014 	mov	x20, #0x0                   	// #0
 1117024:	17fffff1 	b	1116fe8 <ree_fs_ta_open+0x35c>
		res = TEE_ERROR_SECURITY;
 1117028:	129ffe1c 	mov	w28, #0xffff000f            	// #-65521
 111702c:	17ffffef 	b	1116fe8 <ree_fs_ta_open+0x35c>
	struct shdr_encrypted_ta *ehdr = NULL;
 1117030:	d280001a 	mov	x26, #0x0                   	// #0
	struct shdr_bootstrap_ta *bs_hdr = NULL;
 1117034:	d2800014 	mov	x20, #0x0                   	// #0
 1117038:	14000012 	b	1117080 <ree_fs_ta_open+0x3f4>
		return TEE_ERROR_OUT_OF_MEMORY;
 111703c:	129ffe7c 	mov	w28, #0xffff000c            	// #-65524
 1117040:	17ffffd9 	b	1116fa4 <ree_fs_ta_open+0x318>
	shdr = shdr_alloc_and_copy(ta, ta_size);
 1117044:	aa1b03e1 	mov	x1, x27
 1117048:	aa1703e0 	mov	x0, x23
 111704c:	97ffdf62 	bl	110edd4 <shdr_alloc_and_copy>
 1117050:	aa0003f3 	mov	x19, x0
	if (!shdr) {
 1117054:	b4000100 	cbz	x0, 1117074 <ree_fs_ta_open+0x3e8>
	res = shdr_verify_signature(shdr);
 1117058:	aa1303e0 	mov	x0, x19
 111705c:	97ffdf82 	bl	110ee64 <shdr_verify_signature>
 1117060:	2a0003fc 	mov	w28, w0
	if (res != TEE_SUCCESS)
 1117064:	35fffe60 	cbnz	w0, 1117030 <ree_fs_ta_open+0x3a4>
	if (shdr->img_type != SHDR_TA && shdr->img_type != SHDR_BOOTSTRAP_TA &&
 1117068:	b9400660 	ldr	w0, [x19, #4]
 111706c:	7100081f 	cmp	w0, #0x2
 1117070:	54ffeb29 	b.ls	1116dd4 <ree_fs_ta_open+0x148>  // b.plast
	struct shdr_encrypted_ta *ehdr = NULL;
 1117074:	d280001a 	mov	x26, #0x0                   	// #0
	struct shdr_bootstrap_ta *bs_hdr = NULL;
 1117078:	d2800014 	mov	x20, #0x0                   	// #0
		res = TEE_ERROR_SECURITY;
 111707c:	129ffe1c 	mov	w28, #0xffff000f            	// #-65521
	thread_rpc_free_payload(mobj);
 1117080:	aa1603e0 	mov	x0, x22
 1117084:	97ffc005 	bl	1107098 <thread_rpc_free_payload>
	free(ehdr);
 1117088:	aa1a03e0 	mov	x0, x26
 111708c:	9400b155 	bl	11435e0 <free>
	free(bs_hdr);
 1117090:	aa1403e0 	mov	x0, x20
 1117094:	9400b153 	bl	11435e0 <free>
struct shdr *shdr_alloc_and_copy(const struct shdr *img, size_t img_size);

/* Frees a previously allocated struct shdr */
static inline void shdr_free(struct shdr *shdr)
{
	free(shdr);
 1117098:	aa1303e0 	mov	x0, x19
 111709c:	9400b151 	bl	11435e0 <free>
	free(handle);
 11170a0:	aa1503e0 	mov	x0, x21
 11170a4:	9400b14f 	bl	11435e0 <free>
	return res;
 11170a8:	17ffffbf 	b	1116fa4 <ree_fs_ta_open+0x318>
		return TEE_ERROR_BAD_PARAMETERS;
 11170ac:	129fff3c 	mov	w28, #0xffff0006            	// #-65530
 11170b0:	17ffff43 	b	1116dbc <ree_fs_ta_open+0x130>
		return TEE_ERROR_OUT_OF_MEMORY;
 11170b4:	129ffe7c 	mov	w28, #0xffff000c            	// #-65524
 11170b8:	17ffff41 	b	1116dbc <ree_fs_ta_open+0x130>

00000000011170bc <secstor_ta_close>:

static void secstor_ta_close(struct ts_store_handle *h)
{
	struct tee_tadb_ta_read *ta = (struct tee_tadb_ta_read *)h;

	tee_tadb_ta_close(ta);
 11170bc:	14004147 	b	11275d8 <tee_tadb_ta_close>

00000000011170c0 <secstor_ta_read>:
{
 11170c0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 11170c4:	910003fd 	mov	x29, sp
 11170c8:	f9000bf3 	str	x19, [sp, #16]
 11170cc:	aa0203f3 	mov	x19, x2
	size_t l = len;
 11170d0:	f90017e2 	str	x2, [sp, #40]
	TEE_Result res = tee_tadb_ta_read(ta, data, &l);
 11170d4:	9100a3e2 	add	x2, sp, #0x28
 11170d8:	940040bc 	bl	11273c8 <tee_tadb_ta_read>
	if (res)
 11170dc:	350000a0 	cbnz	w0, 11170f0 <secstor_ta_read+0x30>
		return TEE_ERROR_BAD_PARAMETERS;
 11170e0:	f94017e0 	ldr	x0, [sp, #40]
 11170e4:	eb13001f 	cmp	x0, x19
 11170e8:	129fff20 	mov	w0, #0xffff0006            	// #-65530
 11170ec:	1a8003e0 	csel	w0, wzr, w0, eq  // eq = none
}
 11170f0:	f9400bf3 	ldr	x19, [sp, #16]
 11170f4:	a8c37bfd 	ldp	x29, x30, [sp], #48
 11170f8:	d65f03c0 	ret

00000000011170fc <secstor_ta_get_tag>:
	return tee_tadb_get_tag((struct tee_tadb_ta_read *)h, tag, tag_len);
 11170fc:	140040a0 	b	112737c <tee_tadb_get_tag>

0000000001117100 <secstor_ta_get_size>:
{
 1117100:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1117104:	910003fd 	mov	x29, sp
 1117108:	f9000bf3 	str	x19, [sp, #16]
 111710c:	aa0103f3 	mov	x19, x1
	const struct tee_tadb_property *prop = tee_tadb_ta_get_property(ta);
 1117110:	94004099 	bl	1127374 <tee_tadb_ta_get_property>
	*size = prop->bin_size;
 1117114:	b9401800 	ldr	w0, [x0, #24]
 1117118:	f9000260 	str	x0, [x19]
}
 111711c:	52800000 	mov	w0, #0x0                   	// #0
 1117120:	f9400bf3 	ldr	x19, [sp, #16]
 1117124:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1117128:	d65f03c0 	ret

000000000111712c <secstor_ta_open>:
{
 111712c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 1117130:	910003fd 	mov	x29, sp
 1117134:	a90153f3 	stp	x19, x20, [sp, #16]
 1117138:	f90013f5 	str	x21, [sp, #32]
 111713c:	aa0103f5 	mov	x21, x1
	res = tee_tadb_ta_open(uuid, &ta);
 1117140:	9100c3e1 	add	x1, sp, #0x30
 1117144:	9400404f 	bl	1127280 <tee_tadb_ta_open>
 1117148:	2a0003f3 	mov	w19, w0
	if (res)
 111714c:	35000240 	cbnz	w0, 1117194 <secstor_ta_open+0x68>
	prop = tee_tadb_ta_get_property(ta);
 1117150:	f9401be0 	ldr	x0, [sp, #48]
 1117154:	94004088 	bl	1127374 <tee_tadb_ta_get_property>
 1117158:	aa0003f4 	mov	x20, x0
	l = prop->custom_size;
 111715c:	b9401400 	ldr	w0, [x0, #20]
	res = tee_tadb_ta_read(ta, NULL, &l);
 1117160:	9100e3e2 	add	x2, sp, #0x38
	l = prop->custom_size;
 1117164:	f9001fe0 	str	x0, [sp, #56]
	res = tee_tadb_ta_read(ta, NULL, &l);
 1117168:	d2800001 	mov	x1, #0x0                   	// #0
 111716c:	f9401be0 	ldr	x0, [sp, #48]
 1117170:	94004096 	bl	11273c8 <tee_tadb_ta_read>
 1117174:	2a0003f3 	mov	w19, w0
	if (res)
 1117178:	350001c0 	cbnz	w0, 11171b0 <secstor_ta_open+0x84>
	if (l != prop->custom_size) {
 111717c:	f9401fe0 	ldr	x0, [sp, #56]
 1117180:	b9401681 	ldr	w1, [x20, #20]
 1117184:	eb00003f 	cmp	x1, x0
 1117188:	54000101 	b.ne	11171a8 <secstor_ta_open+0x7c>  // b.any
	*handle = (struct ts_store_handle *)ta;
 111718c:	f9401be0 	ldr	x0, [sp, #48]
 1117190:	f90002a0 	str	x0, [x21]
}
 1117194:	2a1303e0 	mov	w0, w19
 1117198:	a94153f3 	ldp	x19, x20, [sp, #16]
 111719c:	f94013f5 	ldr	x21, [sp, #32]
 11171a0:	a8c47bfd 	ldp	x29, x30, [sp], #64
 11171a4:	d65f03c0 	ret
		res = TEE_ERROR_CORRUPT_OBJECT;
 11171a8:	52800033 	mov	w19, #0x1                   	// #1
 11171ac:	72be0213 	movk	w19, #0xf010, lsl #16
	tee_tadb_ta_close(ta);
 11171b0:	f9401be0 	ldr	x0, [sp, #48]
 11171b4:	94004109 	bl	11275d8 <tee_tadb_ta_close>
	return res;
 11171b8:	17fffff7 	b	1117194 <secstor_ta_open+0x68>

00000000011171bc <mobj_get_va>:
	if (mobj && mobj->ops && mobj->ops->get_va)
 11171bc:	b40000e0 	cbz	x0, 11171d8 <mobj_get_va+0x1c>
 11171c0:	f9400002 	ldr	x2, [x0]
 11171c4:	b40000a2 	cbz	x2, 11171d8 <mobj_get_va+0x1c>
 11171c8:	f9400042 	ldr	x2, [x2]
 11171cc:	b4000062 	cbz	x2, 11171d8 <mobj_get_va+0x1c>
		return mobj->ops->get_va(mobj, offset);
 11171d0:	aa0203f0 	mov	x16, x2
 11171d4:	d61f0200 	br	x16
}
 11171d8:	d2800000 	mov	x0, #0x0                   	// #0
 11171dc:	d65f03c0 	ret

00000000011171e0 <update_out_param>:
			     struct tee_ta_param *param)
{
	size_t n;

	for (n = 0; n < TEE_NUM_PARAMS; n++) {
		switch (TEE_PARAM_TYPE_GET(param->types, n)) {
 11171e0:	b8408425 	ldr	w5, [x1], #8
 11171e4:	52800002 	mov	w2, #0x0                   	// #0
 11171e8:	1ac224a4 	lsr	w4, w5, w2
 11171ec:	12000c83 	and	w3, w4, #0xf
 11171f0:	721e049f 	tst	w4, #0xc
 11171f4:	54000101 	b.ne	1117214 <update_out_param+0x34>  // b.any
 11171f8:	721f089f 	tst	w4, #0xe
 11171fc:	54000120 	b.eq	1117220 <update_out_param+0x40>  // b.none
		case TEE_PARAM_TYPE_VALUE_OUTPUT:
		case TEE_PARAM_TYPE_VALUE_INOUT:
			param->u[n].val.a = tee_param[n].value.a;
 1117200:	b9400003 	ldr	w3, [x0]
 1117204:	b9000023 	str	w3, [x1]
			param->u[n].val.b = tee_param[n].value.b;
 1117208:	b9400403 	ldr	w3, [x0, #4]
 111720c:	b9000423 	str	w3, [x1, #4]
			break;
 1117210:	14000004 	b	1117220 <update_out_param+0x40>
		switch (TEE_PARAM_TYPE_GET(param->types, n)) {
 1117214:	51001863 	sub	w3, w3, #0x6
 1117218:	7100047f 	cmp	w3, #0x1
 111721c:	540000e9 	b.ls	1117238 <update_out_param+0x58>  // b.plast
	for (n = 0; n < TEE_NUM_PARAMS; n++) {
 1117220:	11001042 	add	w2, w2, #0x4
 1117224:	91004000 	add	x0, x0, #0x10
 1117228:	91006021 	add	x1, x1, #0x18
 111722c:	7100405f 	cmp	w2, #0x10
 1117230:	54fffdc1 	b.ne	11171e8 <update_out_param+0x8>  // b.any
			break;
		default:
			break;
		}
	}
}
 1117234:	d65f03c0 	ret
			param->u[n].mem.size = tee_param[n].memref.size;
 1117238:	b9400803 	ldr	w3, [x0, #8]
 111723c:	f9000423 	str	x3, [x1, #8]
			break;
 1117240:	17fffff8 	b	1117220 <update_out_param+0x40>

0000000001117244 <verify_pseudo_tas_conformance>:
	return ctx->ops == &pseudo_ta_ops;
}

/* Insures declared pseudo TAs conforms with core expectations */
static TEE_Result verify_pseudo_tas_conformance(void)
{
 1117244:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
	const struct pseudo_ta_head *start =
		SCATTERED_ARRAY_BEGIN(pseudo_tas, struct pseudo_ta_head);
 1117248:	f0000200 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 111724c:	9100e000 	add	x0, x0, #0x38
{
 1117250:	910003fd 	mov	x29, sp
 1117254:	a9025bf5 	stp	x21, x22, [sp, #32]
	const struct pseudo_ta_head *end =
		SCATTERED_ARRAY_END(pseudo_tas, struct pseudo_ta_head);
	const struct pseudo_ta_head *pta;

	for (pta = start; pta < end; pta++) {
 1117258:	f0000215 	adrp	x21, 115a000 <__scattered_array_1phys_mem_map+0x8>
 111725c:	910682b5 	add	x21, x21, #0x1a0
{
 1117260:	a90153f3 	stp	x19, x20, [sp, #16]
 1117264:	a90363f7 	stp	x23, x24, [sp, #48]
		SCATTERED_ARRAY_BEGIN(pseudo_tas, struct pseudo_ta_head);
 1117268:	97fff5f2 	bl	1114a30 <scattered_array_relax_ptr>
		const struct pseudo_ta_head *pta2;

		/* PTAs must all have a specific UUID */
		for (pta2 = pta + 1; pta2 < end; pta2++) {
 111726c:	aa1503f7 	mov	x23, x21
		SCATTERED_ARRAY_BEGIN(pseudo_tas, struct pseudo_ta_head);
 1117270:	aa0003f3 	mov	x19, x0
			if (!memcmp(&pta->uuid, &pta2->uuid, sizeof(TEE_UUID)))
				goto err;
		}

		if (!pta->name ||
		    (pta->flags & PTA_MANDATORY_FLAGS) != PTA_MANDATORY_FLAGS ||
 1117274:	12806418 	mov	w24, #0xfffffcdf            	// #-801
 1117278:	aa1303f4 	mov	x20, x19
	for (pta = start; pta < end; pta++) {
 111727c:	eb15027f 	cmp	x19, x21
 1117280:	540000e3 	b.cc	111729c <verify_pseudo_tas_conformance+0x58>  // b.lo, b.ul, b.last
	}
	return TEE_SUCCESS;
err:
	DMSG("pseudo TA error at %p", (void *)pta);
	panic("PTA");
}
 1117284:	52800000 	mov	w0, #0x0                   	// #0
 1117288:	a94153f3 	ldp	x19, x20, [sp, #16]
 111728c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1117290:	a94363f7 	ldp	x23, x24, [sp, #48]
 1117294:	a8c47bfd 	ldp	x29, x30, [sp], #64
 1117298:	d65f03c0 	ret
		for (pta2 = pta + 1; pta2 < end; pta2++) {
 111729c:	91012273 	add	x19, x19, #0x48
 11172a0:	aa1303f6 	mov	x22, x19
 11172a4:	eb1702df 	cmp	x22, x23
 11172a8:	54000343 	b.cc	1117310 <verify_pseudo_tas_conformance+0xcc>  // b.lo, b.ul, b.last
		if (!pta->name ||
 11172ac:	f9400a80 	ldr	x0, [x20, #16]
 11172b0:	b40000e0 	cbz	x0, 11172cc <verify_pseudo_tas_conformance+0x88>
		    (pta->flags & PTA_MANDATORY_FLAGS) != PTA_MANDATORY_FLAGS ||
 11172b4:	b9401a80 	ldr	w0, [x20, #24]
 11172b8:	0a180000 	and	w0, w0, w24
 11172bc:	7100701f 	cmp	w0, #0x1c
 11172c0:	54000061 	b.ne	11172cc <verify_pseudo_tas_conformance+0x88>  // b.any
		    pta->flags & ~PTA_ALLOWED_FLAGS ||
 11172c4:	f85f8260 	ldur	x0, [x19, #-8]
 11172c8:	b5fffd80 	cbnz	x0, 1117278 <verify_pseudo_tas_conformance+0x34>
	DMSG("pseudo TA error at %p", (void *)pta);
 11172cc:	aa1403e5 	mov	x5, x20
 11172d0:	b00001e4 	adrp	x4, 1154000 <__func__.1786+0x8>
 11172d4:	91398c84 	add	x4, x4, #0xe63
 11172d8:	b00001f3 	adrp	x19, 1154000 <__func__.1786+0x8>
 11172dc:	913cea73 	add	x19, x19, #0xf3a
 11172e0:	52800023 	mov	w3, #0x1                   	// #1
 11172e4:	aa1303e0 	mov	x0, x19
 11172e8:	52800062 	mov	w2, #0x3                   	// #3
 11172ec:	52802341 	mov	w1, #0x11a                 	// #282
 11172f0:	9400b695 	bl	1144d44 <trace_printf>
	panic("PTA");
 11172f4:	b00001e3 	adrp	x3, 1154000 <__func__.1786+0x8>
 11172f8:	b00001e0 	adrp	x0, 1154000 <__func__.1786+0x8>
 11172fc:	9139e463 	add	x3, x3, #0xe79
 1117300:	aa1303e2 	mov	x2, x19
 1117304:	9139f400 	add	x0, x0, #0xe7d
 1117308:	52802361 	mov	w1, #0x11b                 	// #283
 111730c:	97fff057 	bl	1113468 <__do_panic>
			if (!memcmp(&pta->uuid, &pta2->uuid, sizeof(TEE_UUID)))
 1117310:	aa1603e1 	mov	x1, x22
 1117314:	aa1403e0 	mov	x0, x20
 1117318:	d2800202 	mov	x2, #0x10                  	// #16
 111731c:	9400b24d 	bl	1143c50 <memcmp>
 1117320:	34fffd60 	cbz	w0, 11172cc <verify_pseudo_tas_conformance+0x88>
		for (pta2 = pta + 1; pta2 < end; pta2++) {
 1117324:	910122d6 	add	x22, x22, #0x48
 1117328:	17ffffdf 	b	11172a4 <verify_pseudo_tas_conformance+0x60>

000000000111732c <unmap_mapped_param>:
{
 111732c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1117330:	910003fd 	mov	x29, sp
 1117334:	a90153f3 	stp	x19, x20, [sp, #16]
 1117338:	aa0103f4 	mov	x20, x1
	for (n = 0; n < TEE_NUM_PARAMS; n++) {
 111733c:	d2800013 	mov	x19, #0x0                   	// #0
{
 1117340:	a9025bf5 	stp	x21, x22, [sp, #32]
			res = mobj_dec_map(param->u[n].mem.mobj);
 1117344:	91002015 	add	x21, x0, #0x8
 1117348:	d2800316 	mov	x22, #0x18                  	// #24
		if (did_map[n]) {
 111734c:	38736a80 	ldrb	w0, [x20, x19]
 1117350:	34000260 	cbz	w0, 111739c <unmap_mapped_param+0x70>
			res = mobj_dec_map(param->u[n].mem.mobj);
 1117354:	9b167e60 	mul	x0, x19, x22
 1117358:	f8606aa0 	ldr	x0, [x21, x0]
	if (mobj && mobj->ops) {
 111735c:	b5000140 	cbnz	x0, 1117384 <unmap_mapped_param+0x58>
			assert(!res);
 1117360:	b00001e3 	adrp	x3, 1154000 <__func__.1786+0x8>
 1117364:	b00001e1 	adrp	x1, 1154000 <__func__.1786+0x8>
 1117368:	913c9c63 	add	x3, x3, #0xf27
 111736c:	9139f421 	add	x1, x1, #0xe7d
 1117370:	b00001e0 	adrp	x0, 1154000 <__func__.1786+0x8>
 1117374:	913a5400 	add	x0, x0, #0xe95
 1117378:	52801162 	mov	w2, #0x8b                  	// #139
 111737c:	97ffebcc 	bl	11122ac <_assert_log>
 1117380:	97ffebdc 	bl	11122f0 <_assert_break>
 1117384:	f9400001 	ldr	x1, [x0]
 1117388:	b4fffec1 	cbz	x1, 1117360 <unmap_mapped_param+0x34>
		if (mobj->ops->dec_map)
 111738c:	f9402421 	ldr	x1, [x1, #72]
 1117390:	b4000061 	cbz	x1, 111739c <unmap_mapped_param+0x70>
			return mobj->ops->dec_map(mobj);
 1117394:	d63f0020 	blr	x1
 1117398:	35fffe40 	cbnz	w0, 1117360 <unmap_mapped_param+0x34>
	for (n = 0; n < TEE_NUM_PARAMS; n++) {
 111739c:	91000673 	add	x19, x19, #0x1
 11173a0:	f100127f 	cmp	x19, #0x4
 11173a4:	54fffd41 	b.ne	111734c <unmap_mapped_param+0x20>  // b.any
}
 11173a8:	a94153f3 	ldp	x19, x20, [sp, #16]
 11173ac:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11173b0:	a8c37bfd 	ldp	x29, x30, [sp], #48
 11173b4:	d65f03c0 	ret

00000000011173b8 <copy_in_param.isra.0>:
static TEE_Result copy_in_param(struct ts_session *s __maybe_unused,
 11173b8:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 11173bc:	910003fd 	mov	x29, sp
 11173c0:	a90153f3 	stp	x19, x20, [sp, #16]
 11173c4:	91002013 	add	x19, x0, #0x8
 11173c8:	aa0103f4 	mov	x20, x1
 11173cc:	a90363f7 	stp	x23, x24, [sp, #48]
 11173d0:	aa0003f7 	mov	x23, x0
 11173d4:	aa0203f8 	mov	x24, x2
 11173d8:	a9025bf5 	stp	x21, x22, [sp, #32]
	for (n = 0; n < TEE_NUM_PARAMS; n++) {
 11173dc:	d2800015 	mov	x21, #0x0                   	// #0
static TEE_Result copy_in_param(struct ts_session *s __maybe_unused,
 11173e0:	f90023f9 	str	x25, [sp, #64]
				did_map[n] = true;
 11173e4:	52800039 	mov	w25, #0x1                   	// #1
		switch (TEE_PARAM_TYPE_GET(param->types, n)) {
 11173e8:	b94002e0 	ldr	w0, [x23]
 11173ec:	531e76a1 	lsl	w1, w21, #2
 11173f0:	1ac12401 	lsr	w1, w0, w1
 11173f4:	12000c20 	and	w0, w1, #0xf
 11173f8:	721e043f 	tst	w1, #0xc
 11173fc:	540001a1 	b.ne	1117430 <copy_in_param.isra.0+0x78>  // b.any
 1117400:	340001e0 	cbz	w0, 111743c <copy_in_param.isra.0+0x84>
			tee_param[n].value.a = param->u[n].val.a;
 1117404:	b9400260 	ldr	w0, [x19]
 1117408:	b9000280 	str	w0, [x20]
			tee_param[n].value.b = param->u[n].val.b;
 111740c:	b9400660 	ldr	w0, [x19, #4]
 1117410:	b9000680 	str	w0, [x20, #4]
	for (n = 0; n < TEE_NUM_PARAMS; n++) {
 1117414:	910006b5 	add	x21, x21, #0x1
 1117418:	91006273 	add	x19, x19, #0x18
 111741c:	91004294 	add	x20, x20, #0x10
 1117420:	f10012bf 	cmp	x21, #0x4
 1117424:	54fffe21 	b.ne	11173e8 <copy_in_param.isra.0+0x30>  // b.any
	return TEE_SUCCESS;
 1117428:	52800000 	mov	w0, #0x0                   	// #0
 111742c:	14000018 	b	111748c <copy_in_param.isra.0+0xd4>
		switch (TEE_PARAM_TYPE_GET(param->types, n)) {
 1117430:	51001400 	sub	w0, w0, #0x5
 1117434:	7100081f 	cmp	w0, #0x2
 1117438:	54000069 	b.ls	1117444 <copy_in_param.isra.0+0x8c>  // b.plast
			memset(tee_param + n, 0, sizeof(TEE_Param));
 111743c:	a9007e9f 	stp	xzr, xzr, [x20]
			break;
 1117440:	17fffff5 	b	1117414 <copy_in_param.isra.0+0x5c>
			if (mem->size) {
 1117444:	f9400660 	ldr	x0, [x19, #8]
 1117448:	b4000460 	cbz	x0, 11174d4 <copy_in_param.isra.0+0x11c>
			if (!validate_in_param(s, mem->mobj))
 111744c:	f9400260 	ldr	x0, [x19]
	if (mobj && mobj->ops) {
 1117450:	b4000460 	cbz	x0, 11174dc <copy_in_param.isra.0+0x124>
 1117454:	f9400001 	ldr	x1, [x0]
 1117458:	b4000421 	cbz	x1, 11174dc <copy_in_param.isra.0+0x124>
		if (mobj->ops->inc_map)
 111745c:	f9402021 	ldr	x1, [x1, #64]
 1117460:	b5000121 	cbnz	x1, 1117484 <copy_in_param.isra.0+0xcc>
				va = mobj_get_va(mem->mobj, mem->offs);
 1117464:	f9400260 	ldr	x0, [x19]
				did_map[n] = true;
 1117468:	38356b19 	strb	w25, [x24, x21]
				va = mobj_get_va(mem->mobj, mem->offs);
 111746c:	f9400a61 	ldr	x1, [x19, #16]
 1117470:	97ffff53 	bl	11171bc <mobj_get_va>
 1117474:	aa0003f6 	mov	x22, x0
				if (!va)
 1117478:	b5000160 	cbnz	x0, 11174a4 <copy_in_param.isra.0+0xec>
					return TEE_ERROR_BAD_PARAMETERS;
 111747c:	129fff20 	mov	w0, #0xffff0006            	// #-65530
 1117480:	14000003 	b	111748c <copy_in_param.isra.0+0xd4>
			return mobj->ops->inc_map(mobj);
 1117484:	d63f0020 	blr	x1
				if (res)
 1117488:	34fffee0 	cbz	w0, 1117464 <copy_in_param.isra.0+0xac>
}
 111748c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1117490:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1117494:	a94363f7 	ldp	x23, x24, [sp, #48]
 1117498:	f94023f9 	ldr	x25, [sp, #64]
 111749c:	a8c57bfd 	ldp	x29, x30, [sp], #80
 11174a0:	d65f03c0 	ret
				if (mem->size &&
 11174a4:	f9400661 	ldr	x1, [x19, #8]
 11174a8:	b40000e1 	cbz	x1, 11174c4 <copy_in_param.isra.0+0x10c>
						 mem->offs + mem->size - 1))
 11174ac:	f9400a60 	ldr	x0, [x19, #16]
 11174b0:	8b000021 	add	x1, x1, x0
				    !mobj_get_va(mem->mobj,
 11174b4:	f9400260 	ldr	x0, [x19]
 11174b8:	d1000421 	sub	x1, x1, #0x1
 11174bc:	97ffff40 	bl	11171bc <mobj_get_va>
				if (mem->size &&
 11174c0:	b4fffde0 	cbz	x0, 111747c <copy_in_param.isra.0+0xc4>
			tee_param[n].memref.size = mem->size;
 11174c4:	f9400660 	ldr	x0, [x19, #8]
			tee_param[n].memref.buffer = va;
 11174c8:	f9000296 	str	x22, [x20]
			tee_param[n].memref.size = mem->size;
 11174cc:	b9000a80 	str	w0, [x20, #8]
			break;
 11174d0:	17ffffd1 	b	1117414 <copy_in_param.isra.0+0x5c>
				va = NULL;
 11174d4:	d2800016 	mov	x22, #0x0                   	// #0
 11174d8:	17fffffb 	b	11174c4 <copy_in_param.isra.0+0x10c>
	return TEE_ERROR_GENERIC;
 11174dc:	52bfffe0 	mov	w0, #0xffff0000            	// #-65536
 11174e0:	17ffffeb 	b	111748c <copy_in_param.isra.0+0xd4>

00000000011174e4 <to_pseudo_ta_ctx.part.0>:

bool is_pseudo_ta_ctx(struct ts_ctx *ctx);

static inline struct pseudo_ta_ctx *to_pseudo_ta_ctx(struct ts_ctx *ctx)
{
	assert(is_pseudo_ta_ctx(ctx));
 11174e4:	b00001e3 	adrp	x3, 1154000 <__func__.1786+0x8>
 11174e8:	b00001e1 	adrp	x1, 1154000 <__func__.1786+0x8>
 11174ec:	913c5863 	add	x3, x3, #0xf16
 11174f0:	913a6821 	add	x1, x1, #0xe9a
 11174f4:	b00001e0 	adrp	x0, 1154000 <__func__.1786+0x8>
 11174f8:	913ae800 	add	x0, x0, #0xeba
static inline struct pseudo_ta_ctx *to_pseudo_ta_ctx(struct ts_ctx *ctx)
 11174fc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	assert(is_pseudo_ta_ctx(ctx));
 1117500:	52800702 	mov	w2, #0x38                  	// #56
static inline struct pseudo_ta_ctx *to_pseudo_ta_ctx(struct ts_ctx *ctx)
 1117504:	910003fd 	mov	x29, sp
	assert(is_pseudo_ta_ctx(ctx));
 1117508:	97ffeb69 	bl	11122ac <_assert_log>
 111750c:	97ffeb79 	bl	11122f0 <_assert_break>

0000000001117510 <pseudo_ta_enter_open_session>:
{
 1117510:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
 1117514:	90000221 	adrp	x1, 115b000 <__vcore_unpg_rw_start>
 1117518:	911f8021 	add	x1, x1, #0x7e0
 111751c:	910003fd 	mov	x29, sp
 1117520:	a9025bf5 	stp	x21, x22, [sp, #32]
	struct pseudo_ta_ctx *stc = to_pseudo_ta_ctx(s->ctx);
 1117524:	f9400816 	ldr	x22, [x0, #16]
{
 1117528:	a90153f3 	stp	x19, x20, [sp, #16]
 111752c:	a90363f7 	stp	x23, x24, [sp, #48]
 1117530:	f9400ac2 	ldr	x2, [x22, #16]
 1117534:	eb01005f 	cmp	x2, x1
 1117538:	54000040 	b.eq	1117540 <pseudo_ta_enter_open_session+0x30>  // b.none
 111753c:	97ffffea 	bl	11174e4 <to_pseudo_ta_ctx.part.0>
 1117540:	aa0003f5 	mov	x21, x0
	struct tee_ta_session *ta_sess = to_ta_session(s);
 1117544:	97fff27f 	bl	1113f40 <to_ta_session>
 1117548:	aa0003f4 	mov	x20, x0
	ts_push_current_session(s);
 111754c:	aa1503e0 	mov	x0, x21
	bool did_map[TEE_NUM_PARAMS] = { false };
 1117550:	b9004bff 	str	wzr, [sp, #72]
	TEE_Param tee_param[TEE_NUM_PARAMS] = { };
 1117554:	a9057fff 	stp	xzr, xzr, [sp, #80]
 1117558:	a9067fff 	stp	xzr, xzr, [sp, #96]
 111755c:	a9077fff 	stp	xzr, xzr, [sp, #112]
 1117560:	a9087fff 	stp	xzr, xzr, [sp, #128]
	ts_push_current_session(s);
 1117564:	97fff4f7 	bl	1114940 <ts_push_current_session>
	ta_sess->err_origin = TEE_ORIGIN_TRUSTED_APP;
 1117568:	52800080 	mov	w0, #0x4                   	// #4
 111756c:	b9005a80 	str	w0, [x20, #88]
	if (stc->ctx.ref_count == 1 && stc->pseudo_ta->create_entry_point) {
 1117570:	b94022c0 	ldr	w0, [x22, #32]
 1117574:	7100041f 	cmp	w0, #0x1
 1117578:	54000180 	b.eq	11175a8 <pseudo_ta_enter_open_session+0x98>  // b.none
	if (stc->pseudo_ta->open_session_entry_point) {
 111757c:	f85e02c0 	ldur	x0, [x22, #-32]
 1117580:	f9401800 	ldr	x0, [x0, #48]
 1117584:	b5000200 	cbnz	x0, 11175c4 <pseudo_ta_enter_open_session+0xb4>
out:
 1117588:	52800013 	mov	w19, #0x0                   	// #0
	ts_pop_current_session();
 111758c:	97fff4fd 	bl	1114980 <ts_pop_current_session>
}
 1117590:	2a1303e0 	mov	w0, w19
 1117594:	a94153f3 	ldp	x19, x20, [sp, #16]
 1117598:	a9425bf5 	ldp	x21, x22, [sp, #32]
 111759c:	a94363f7 	ldp	x23, x24, [sp, #48]
 11175a0:	a8c97bfd 	ldp	x29, x30, [sp], #144
 11175a4:	d65f03c0 	ret
	if (stc->ctx.ref_count == 1 && stc->pseudo_ta->create_entry_point) {
 11175a8:	f85e02c0 	ldur	x0, [x22, #-32]
 11175ac:	f9401000 	ldr	x0, [x0, #32]
 11175b0:	b4fffe60 	cbz	x0, 111757c <pseudo_ta_enter_open_session+0x6c>
		res = stc->pseudo_ta->create_entry_point();
 11175b4:	d63f0000 	blr	x0
 11175b8:	2a0003f3 	mov	w19, w0
		if (res != TEE_SUCCESS)
 11175bc:	34fffe00 	cbz	w0, 111757c <pseudo_ta_enter_open_session+0x6c>
 11175c0:	17fffff3 	b	111758c <pseudo_ta_enter_open_session+0x7c>
		if (ta_sess->param) {
 11175c4:	f9402a80 	ldr	x0, [x20, #80]
		void **user_ctx = &s->user_ctx;
 11175c8:	910062b5 	add	x21, x21, #0x18
		if (ta_sess->param) {
 11175cc:	910143f7 	add	x23, sp, #0x50
 11175d0:	b40003a0 	cbz	x0, 1117644 <pseudo_ta_enter_open_session+0x134>
			res = copy_in_param(s, ta_sess->param, tee_param,
 11175d4:	910123f8 	add	x24, sp, #0x48
 11175d8:	aa1703e1 	mov	x1, x23
 11175dc:	aa1803e2 	mov	x2, x24
 11175e0:	97ffff76 	bl	11173b8 <copy_in_param.isra.0>
 11175e4:	2a0003f3 	mov	w19, w0
			if (res != TEE_SUCCESS) {
 11175e8:	340000e0 	cbz	w0, 1117604 <pseudo_ta_enter_open_session+0xf4>
				unmap_mapped_param(ta_sess->param, did_map);
 11175ec:	f9402a80 	ldr	x0, [x20, #80]
 11175f0:	aa1803e1 	mov	x1, x24
 11175f4:	97ffff4e 	bl	111732c <unmap_mapped_param>
				ta_sess->err_origin = TEE_ORIGIN_TEE;
 11175f8:	52800060 	mov	w0, #0x3                   	// #3
 11175fc:	b9005a80 	str	w0, [x20, #88]
				goto out;
 1117600:	17ffffe3 	b	111758c <pseudo_ta_enter_open_session+0x7c>
			param_types = ta_sess->param->types;
 1117604:	f9402a80 	ldr	x0, [x20, #80]
 1117608:	b9400000 	ldr	w0, [x0]
		res = stc->pseudo_ta->open_session_entry_point(param_types,
 111760c:	f85e02c1 	ldur	x1, [x22, #-32]
 1117610:	aa1503e2 	mov	x2, x21
 1117614:	f9401823 	ldr	x3, [x1, #48]
 1117618:	aa1703e1 	mov	x1, x23
 111761c:	d63f0060 	blr	x3
 1117620:	2a0003f3 	mov	w19, w0
		if (ta_sess->param) {
 1117624:	f9402a81 	ldr	x1, [x20, #80]
 1117628:	b4fffb21 	cbz	x1, 111758c <pseudo_ta_enter_open_session+0x7c>
			update_out_param(tee_param, ta_sess->param);
 111762c:	aa1703e0 	mov	x0, x23
 1117630:	97fffeec 	bl	11171e0 <update_out_param>
			unmap_mapped_param(ta_sess->param, did_map);
 1117634:	f9402a80 	ldr	x0, [x20, #80]
 1117638:	910123e1 	add	x1, sp, #0x48
 111763c:	97ffff3c 	bl	111732c <unmap_mapped_param>
 1117640:	17ffffd3 	b	111758c <pseudo_ta_enter_open_session+0x7c>
		uint32_t param_types = 0;
 1117644:	52800000 	mov	w0, #0x0                   	// #0
 1117648:	17fffff1 	b	111760c <pseudo_ta_enter_open_session+0xfc>

000000000111764c <pseudo_ta_destroy>:
 111764c:	f9400802 	ldr	x2, [x0, #16]
 1117650:	90000221 	adrp	x1, 115b000 <__vcore_unpg_rw_start>
 1117654:	911f8021 	add	x1, x1, #0x7e0
 1117658:	eb01005f 	cmp	x2, x1
 111765c:	54000080 	b.eq	111766c <pseudo_ta_destroy+0x20>  // b.none
{
 1117660:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 1117664:	910003fd 	mov	x29, sp
 1117668:	97ffff9f 	bl	11174e4 <to_pseudo_ta_ctx.part.0>
	free(to_pseudo_ta_ctx(ctx));
 111766c:	d1008000 	sub	x0, x0, #0x20
 1117670:	1400afdc 	b	11435e0 <free>

0000000001117674 <pseudo_ta_enter_close_session>:
{
 1117674:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1117678:	90000222 	adrp	x2, 115b000 <__vcore_unpg_rw_start>
 111767c:	911f8042 	add	x2, x2, #0x7e0
 1117680:	910003fd 	mov	x29, sp
 1117684:	a90153f3 	stp	x19, x20, [sp, #16]
	struct pseudo_ta_ctx *stc = to_pseudo_ta_ctx(s->ctx);
 1117688:	f9400813 	ldr	x19, [x0, #16]
 111768c:	f9400a63 	ldr	x3, [x19, #16]
{
 1117690:	f90013f5 	str	x21, [sp, #32]
 1117694:	eb02007f 	cmp	x3, x2
 1117698:	54000040 	b.eq	11176a0 <pseudo_ta_enter_close_session+0x2c>  // b.none
 111769c:	97ffff92 	bl	11174e4 <to_pseudo_ta_ctx.part.0>
	void *user_ctx = s->user_ctx;
 11176a0:	f9400c15 	ldr	x21, [x0, #24]
	ts_push_current_session(s);
 11176a4:	97fff4a7 	bl	1114940 <ts_push_current_session>
	if (stc->pseudo_ta->close_session_entry_point)
 11176a8:	f85e0260 	ldur	x0, [x19, #-32]
	return container_of(ctx, struct pseudo_ta_ctx, ctx.ts_ctx);
 11176ac:	d1008274 	sub	x20, x19, #0x20
 11176b0:	f9401c01 	ldr	x1, [x0, #56]
 11176b4:	b4000061 	cbz	x1, 11176c0 <pseudo_ta_enter_close_session+0x4c>
		stc->pseudo_ta->close_session_entry_point(user_ctx);
 11176b8:	aa1503e0 	mov	x0, x21
 11176bc:	d63f0020 	blr	x1
	if (stc->ctx.ref_count == 1 && stc->pseudo_ta->destroy_entry_point)
 11176c0:	b9404280 	ldr	w0, [x20, #64]
 11176c4:	7100041f 	cmp	w0, #0x1
 11176c8:	540000a1 	b.ne	11176dc <pseudo_ta_enter_close_session+0x68>  // b.any
 11176cc:	f85e0260 	ldur	x0, [x19, #-32]
 11176d0:	f9401400 	ldr	x0, [x0, #40]
 11176d4:	b4000040 	cbz	x0, 11176dc <pseudo_ta_enter_close_session+0x68>
		stc->pseudo_ta->destroy_entry_point();
 11176d8:	d63f0000 	blr	x0
}
 11176dc:	a94153f3 	ldp	x19, x20, [sp, #16]
 11176e0:	f94013f5 	ldr	x21, [sp, #32]
 11176e4:	a8c37bfd 	ldp	x29, x30, [sp], #48
	ts_pop_current_session();
 11176e8:	17fff4a6 	b	1114980 <ts_pop_current_session>

00000000011176ec <pseudo_ta_enter_invoke_cmd>:
{
 11176ec:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
 11176f0:	910003fd 	mov	x29, sp
 11176f4:	a90363f7 	stp	x23, x24, [sp, #48]
 11176f8:	2a0103f7 	mov	w23, w1
	assert(is_pseudo_ta_ctx(ctx));
 11176fc:	90000221 	adrp	x1, 115b000 <__vcore_unpg_rw_start>
	struct pseudo_ta_ctx *stc = to_pseudo_ta_ctx(s->ctx);
 1117700:	f9400818 	ldr	x24, [x0, #16]
{
 1117704:	a90153f3 	stp	x19, x20, [sp, #16]
 1117708:	911f8021 	add	x1, x1, #0x7e0
 111770c:	a9025bf5 	stp	x21, x22, [sp, #32]
 1117710:	f9400b02 	ldr	x2, [x24, #16]
 1117714:	f90023f9 	str	x25, [sp, #64]
 1117718:	eb01005f 	cmp	x2, x1
 111771c:	54000040 	b.eq	1117724 <pseudo_ta_enter_invoke_cmd+0x38>  // b.none
 1117720:	97ffff71 	bl	11174e4 <to_pseudo_ta_ctx.part.0>
 1117724:	aa0003f5 	mov	x21, x0
	struct tee_ta_session *ta_sess = to_ta_session(s);
 1117728:	97fff206 	bl	1113f40 <to_ta_session>
 111772c:	aa0003f3 	mov	x19, x0
	ts_push_current_session(s);
 1117730:	aa1503e0 	mov	x0, x21
	bool did_map[TEE_NUM_PARAMS] = { false };
 1117734:	b9005bff 	str	wzr, [sp, #88]
 1117738:	910183f6 	add	x22, sp, #0x60
	TEE_Param tee_param[TEE_NUM_PARAMS] = { };
 111773c:	a9067fff 	stp	xzr, xzr, [sp, #96]
 1117740:	a9077fff 	stp	xzr, xzr, [sp, #112]
 1117744:	a9087fff 	stp	xzr, xzr, [sp, #128]
 1117748:	a9097fff 	stp	xzr, xzr, [sp, #144]
	ts_push_current_session(s);
 111774c:	97fff47d 	bl	1114940 <ts_push_current_session>
	if (ta_sess->param) {
 1117750:	f9402a60 	ldr	x0, [x19, #80]
 1117754:	b40004e0 	cbz	x0, 11177f0 <pseudo_ta_enter_invoke_cmd+0x104>
		res = copy_in_param(s, ta_sess->param, tee_param, did_map);
 1117758:	910163f9 	add	x25, sp, #0x58
 111775c:	aa1603e1 	mov	x1, x22
 1117760:	aa1903e2 	mov	x2, x25
 1117764:	97ffff15 	bl	11173b8 <copy_in_param.isra.0>
 1117768:	2a0003f4 	mov	w20, w0
		if (res != TEE_SUCCESS) {
 111776c:	340001c0 	cbz	w0, 11177a4 <pseudo_ta_enter_invoke_cmd+0xb8>
			unmap_mapped_param(ta_sess->param, did_map);
 1117770:	f9402a60 	ldr	x0, [x19, #80]
 1117774:	aa1903e1 	mov	x1, x25
 1117778:	97fffeed 	bl	111732c <unmap_mapped_param>
			ta_sess->err_origin = TEE_ORIGIN_TEE;
 111777c:	52800060 	mov	w0, #0x3                   	// #3
 1117780:	b9005a60 	str	w0, [x19, #88]
	ts_pop_current_session();
 1117784:	97fff47f 	bl	1114980 <ts_pop_current_session>
}
 1117788:	2a1403e0 	mov	w0, w20
 111778c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1117790:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1117794:	a94363f7 	ldp	x23, x24, [sp, #48]
 1117798:	f94023f9 	ldr	x25, [sp, #64]
 111779c:	a8ca7bfd 	ldp	x29, x30, [sp], #160
 11177a0:	d65f03c0 	ret
		param_types = ta_sess->param->types;
 11177a4:	f9402a60 	ldr	x0, [x19, #80]
 11177a8:	b9400002 	ldr	w2, [x0]
	ta_sess->err_origin = TEE_ORIGIN_TRUSTED_APP;
 11177ac:	52800080 	mov	w0, #0x4                   	// #4
 11177b0:	b9005a60 	str	w0, [x19, #88]
	res = stc->pseudo_ta->invoke_command_entry_point(s->user_ctx, cmd,
 11177b4:	f85e0300 	ldur	x0, [x24, #-32]
 11177b8:	2a1703e1 	mov	w1, w23
 11177bc:	aa1603e3 	mov	x3, x22
 11177c0:	f9402004 	ldr	x4, [x0, #64]
 11177c4:	f9400ea0 	ldr	x0, [x21, #24]
 11177c8:	d63f0080 	blr	x4
 11177cc:	2a0003f4 	mov	w20, w0
	if (ta_sess->param) {
 11177d0:	f9402a61 	ldr	x1, [x19, #80]
 11177d4:	b4fffd81 	cbz	x1, 1117784 <pseudo_ta_enter_invoke_cmd+0x98>
		update_out_param(tee_param, ta_sess->param);
 11177d8:	aa1603e0 	mov	x0, x22
 11177dc:	97fffe81 	bl	11171e0 <update_out_param>
		unmap_mapped_param(ta_sess->param, did_map);
 11177e0:	f9402a60 	ldr	x0, [x19, #80]
 11177e4:	910163e1 	add	x1, sp, #0x58
 11177e8:	97fffed1 	bl	111732c <unmap_mapped_param>
 11177ec:	17ffffe6 	b	1117784 <pseudo_ta_enter_invoke_cmd+0x98>
	uint32_t param_types = 0;
 11177f0:	52800002 	mov	w2, #0x0                   	// #0
 11177f4:	17ffffee 	b	11177ac <pseudo_ta_enter_invoke_cmd+0xc0>

00000000011177f8 <is_pseudo_ta_ctx>:
	return ctx->ops == &pseudo_ta_ops;
 11177f8:	f9400801 	ldr	x1, [x0, #16]
 11177fc:	90000220 	adrp	x0, 115b000 <__vcore_unpg_rw_start>
 1117800:	911f8000 	add	x0, x0, #0x7e0
 1117804:	eb00003f 	cmp	x1, x0
}
 1117808:	1a9f17e0 	cset	w0, eq  // eq = none
 111780c:	d65f03c0 	ret

0000000001117810 <tee_ta_init_pseudo_ta_session>:
 * Initialises a session based on the UUID or ptr to the ta
 * Returns ptr to the session (ta_session) and a TEE_Result
 *---------------------------------------------------------------------------*/
TEE_Result tee_ta_init_pseudo_ta_session(const TEE_UUID *uuid,
			struct tee_ta_session *s)
{
 1117810:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
	struct pseudo_ta_ctx *stc = NULL;
	struct tee_ta_ctx *ctx;
	const struct pseudo_ta_head *ta;

	DMSG("Lookup pseudo TA %pUl", (void *)uuid);
 1117814:	aa0003e5 	mov	x5, x0
 1117818:	b00001e4 	adrp	x4, 1154000 <__func__.1786+0x8>
{
 111781c:	910003fd 	mov	x29, sp
	DMSG("Lookup pseudo TA %pUl", (void *)uuid);
 1117820:	913b4084 	add	x4, x4, #0xed0
 1117824:	52800023 	mov	w3, #0x1                   	// #1
 1117828:	52800062 	mov	w2, #0x3                   	// #3
{
 111782c:	a90363f7 	stp	x23, x24, [sp, #48]
 1117830:	aa0103f8 	mov	x24, x1
	DMSG("Lookup pseudo TA %pUl", (void *)uuid);
 1117834:	52802561 	mov	w1, #0x12b                 	// #299
{
 1117838:	a90153f3 	stp	x19, x20, [sp, #16]
 111783c:	aa0003f4 	mov	x20, x0
 1117840:	a9025bf5 	stp	x21, x22, [sp, #32]
	DMSG("Lookup pseudo TA %pUl", (void *)uuid);
 1117844:	b00001f6 	adrp	x22, 1154000 <__func__.1786+0x8>
 1117848:	913d62c0 	add	x0, x22, #0xf58
{
 111784c:	a9046bf9 	stp	x25, x26, [sp, #64]
	DMSG("Lookup pseudo TA %pUl", (void *)uuid);
 1117850:	9400b53d 	bl	1144d44 <trace_printf>

	ta = SCATTERED_ARRAY_BEGIN(pseudo_tas, struct pseudo_ta_head);
 1117854:	f0000200 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
	while (true) {
		if (ta >= SCATTERED_ARRAY_END(pseudo_tas,
 1117858:	f0000215 	adrp	x21, 115a000 <__scattered_array_1phys_mem_map+0x8>
	ta = SCATTERED_ARRAY_BEGIN(pseudo_tas, struct pseudo_ta_head);
 111785c:	9100e000 	add	x0, x0, #0x38
		if (ta >= SCATTERED_ARRAY_END(pseudo_tas,
 1117860:	910682b5 	add	x21, x21, #0x1a0
	ta = SCATTERED_ARRAY_BEGIN(pseudo_tas, struct pseudo_ta_head);
 1117864:	97fff473 	bl	1114a30 <scattered_array_relax_ptr>
 1117868:	aa0003f3 	mov	x19, x0
		if (ta >= SCATTERED_ARRAY_END(pseudo_tas,
 111786c:	eb15027f 	cmp	x19, x21
 1117870:	54000842 	b.cs	1117978 <tee_ta_init_pseudo_ta_session+0x168>  // b.hs, b.nlast
					      struct pseudo_ta_head))
			return TEE_ERROR_ITEM_NOT_FOUND;
		if (memcmp(&ta->uuid, uuid, sizeof(TEE_UUID)) == 0)
 1117874:	aa1403e1 	mov	x1, x20
 1117878:	aa1303e0 	mov	x0, x19
 111787c:	d2800202 	mov	x2, #0x10                  	// #16
 1117880:	9400b0f4 	bl	1143c50 <memcmp>
 1117884:	34000060 	cbz	w0, 1117890 <tee_ta_init_pseudo_ta_session+0x80>
			break;
		ta++;
 1117888:	91012273 	add	x19, x19, #0x48
		if (ta >= SCATTERED_ARRAY_END(pseudo_tas,
 111788c:	17fffff8 	b	111786c <tee_ta_init_pseudo_ta_session+0x5c>
	}

	/* Load a new TA and create a session */
	DMSG("Open %s", ta->name);
 1117890:	f9400a65 	ldr	x5, [x19, #16]
 1117894:	b00001e4 	adrp	x4, 1154000 <__func__.1786+0x8>
 1117898:	913b9884 	add	x4, x4, #0xee6
 111789c:	52800023 	mov	w3, #0x1                   	// #1
 11178a0:	52800062 	mov	w2, #0x3                   	// #3
 11178a4:	913d62d6 	add	x22, x22, #0xf58
 11178a8:	aa1603e0 	mov	x0, x22
 11178ac:	52802701 	mov	w1, #0x138                 	// #312
 11178b0:	9400b525 	bl	1144d44 <trace_printf>
	stc = calloc(1, sizeof(struct pseudo_ta_ctx));
 11178b4:	d2800b01 	mov	x1, #0x58                  	// #88
 11178b8:	d2800020 	mov	x0, #0x1                   	// #1
 11178bc:	9400af05 	bl	11434d0 <calloc>
 11178c0:	aa0003f4 	mov	x20, x0
	if (!stc)
 11178c4:	b40005e0 	cbz	x0, 1117980 <tee_ta_init_pseudo_ta_session+0x170>
		return TEE_ERROR_OUT_OF_MEMORY;
	ctx = &stc->ctx;

	ctx->ref_count = 1;
	ctx->flags = ta->flags;
	stc->pseudo_ta = ta;
 11178c8:	aa0003f7 	mov	x23, x0
	ctx->ref_count = 1;
 11178cc:	91002015 	add	x21, x0, #0x8
	ctx->flags = ta->flags;
 11178d0:	b9401a60 	ldr	w0, [x19, #24]
	ctx->ref_count = 1;
 11178d4:	52800039 	mov	w25, #0x1                   	// #1
	ctx->flags = ta->flags;
 11178d8:	b9000a80 	str	w0, [x20, #8]
	ctx->ref_count = 1;
 11178dc:	b9004299 	str	w25, [x20, #64]
	stc->pseudo_ta = ta;
 11178e0:	f80206f3 	str	x19, [x23], #32
	ctx->ts_ctx.uuid = ta->uuid;
 11178e4:	f9400260 	ldr	x0, [x19]
 11178e8:	f9001280 	str	x0, [x20, #32]
 11178ec:	f9400660 	ldr	x0, [x19, #8]
	ctx->ts_ctx.ops = &pseudo_ta_ops;

	mutex_lock(&tee_ta_mutex);
 11178f0:	f0000213 	adrp	x19, 115a000 <__scattered_array_1phys_mem_map+0x8>
	ctx->ts_ctx.uuid = ta->uuid;
 11178f4:	f90006e0 	str	x0, [x23, #8]
	ctx->ts_ctx.ops = &pseudo_ta_ops;
 11178f8:	90000220 	adrp	x0, 115b000 <__vcore_unpg_rw_start>
	mutex_lock(&tee_ta_mutex);
 11178fc:	f9413e7a 	ldr	x26, [x19, #632]
	ctx->ts_ctx.ops = &pseudo_ta_ops;
 1117900:	911f8000 	add	x0, x0, #0x7e0
 1117904:	f9001a80 	str	x0, [x20, #48]
	mutex_lock(&tee_ta_mutex);
 1117908:	aa1a03e0 	mov	x0, x26
 111790c:	97fff712 	bl	1115554 <mutex_lock>
	s->ts_sess.ctx = &ctx->ts_ctx;
 1117910:	f9001317 	str	x23, [x24, #32]
	TAILQ_INSERT_TAIL(&tee_ctxes, ctx, link);
 1117914:	f9413a73 	ldr	x19, [x19, #624]
 1117918:	f9400660 	ldr	x0, [x19, #8]
 111791c:	a901029f 	stp	xzr, x0, [x20, #16]
 1117920:	f9000015 	str	x21, [x0]
	mutex_unlock(&tee_ta_mutex);
 1117924:	aa1a03e0 	mov	x0, x26
	TAILQ_INSERT_TAIL(&tee_ctxes, ctx, link);
 1117928:	91004295 	add	x21, x20, #0x10
 111792c:	f9000675 	str	x21, [x19, #8]
	mutex_unlock(&tee_ta_mutex);
 1117930:	97fff6e8 	bl	11154d0 <mutex_unlock>

	DMSG("%s : %pUl", stc->pseudo_ta->name, (void *)&ctx->ts_ctx.uuid);
 1117934:	f9400280 	ldr	x0, [x20]
 1117938:	aa1703e6 	mov	x6, x23
 111793c:	2a1903e3 	mov	w3, w25
 1117940:	b00001e4 	adrp	x4, 1154000 <__func__.1786+0x8>
 1117944:	52800062 	mov	w2, #0x3                   	// #3
 1117948:	913bb884 	add	x4, x4, #0xeee
 111794c:	f9400805 	ldr	x5, [x0, #16]
 1117950:	52802921 	mov	w1, #0x149                 	// #329
 1117954:	aa1603e0 	mov	x0, x22
 1117958:	9400b4fb 	bl	1144d44 <trace_printf>

	return TEE_SUCCESS;
 111795c:	52800000 	mov	w0, #0x0                   	// #0
}
 1117960:	a94153f3 	ldp	x19, x20, [sp, #16]
 1117964:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1117968:	a94363f7 	ldp	x23, x24, [sp, #48]
 111796c:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1117970:	a8c57bfd 	ldp	x29, x30, [sp], #80
 1117974:	d65f03c0 	ret
			return TEE_ERROR_ITEM_NOT_FOUND;
 1117978:	129ffee0 	mov	w0, #0xffff0008            	// #-65528
 111797c:	17fffff9 	b	1117960 <tee_ta_init_pseudo_ta_session+0x150>
		return TEE_ERROR_OUT_OF_MEMORY;
 1117980:	129ffe60 	mov	w0, #0xffff000c            	// #-65524
 1117984:	17fffff7 	b	1117960 <tee_ta_init_pseudo_ta_session+0x150>

0000000001117988 <mobj_shm_matches>:
	return to_mobj_shm(mobj)->pa & (granule - 1);
}

static bool mobj_shm_matches(struct mobj *mobj __unused, enum buf_is_attr attr)
{
	return attr == CORE_MEM_NSEC_SHM || attr == CORE_MEM_NON_SEC;
 1117988:	51000421 	sub	w1, w1, #0x1
 111798c:	7100043f 	cmp	w1, #0x1
}
 1117990:	1a9f87e0 	cset	w0, ls  // ls = plast
 1117994:	d65f03c0 	ret

0000000001117998 <mobj_with_fobj_get_cattr>:
}

static TEE_Result mobj_with_fobj_get_cattr(struct mobj *mobj __unused,
					   uint32_t *cattr)
{
	if (!cattr)
 1117998:	b40000a1 	cbz	x1, 11179ac <mobj_with_fobj_get_cattr+0x14>
		return TEE_ERROR_GENERIC;

	/* All fobjs are mapped as normal cached memory */
	*cattr = TEE_MATTR_CACHE_CACHED;
 111799c:	52800020 	mov	w0, #0x1                   	// #1
 11179a0:	b9000020 	str	w0, [x1]

	return TEE_SUCCESS;
 11179a4:	52800000 	mov	w0, #0x0                   	// #0
}
 11179a8:	d65f03c0 	ret
		return TEE_ERROR_GENERIC;
 11179ac:	52bfffe0 	mov	w0, #0xffff0000            	// #-65536
 11179b0:	17fffffe 	b	11179a8 <mobj_with_fobj_get_cattr+0x10>

00000000011179b4 <to_mobj_phys.part.0>:
	assert(mobj->ops == &mobj_phys_ops);
 11179b4:	d00001e3 	adrp	x3, 1155000 <__func__.3826+0xa8>
 11179b8:	b00001e1 	adrp	x1, 1154000 <__func__.1786+0x8>
 11179bc:	91038063 	add	x3, x3, #0xe0
 11179c0:	913dd821 	add	x1, x1, #0xf76
 11179c4:	b00001e0 	adrp	x0, 1154000 <__func__.1786+0x8>
 11179c8:	913e1400 	add	x0, x0, #0xf85
static struct mobj_phys *to_mobj_phys(struct mobj *mobj)
 11179cc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	assert(mobj->ops == &mobj_phys_ops);
 11179d0:	52801002 	mov	w2, #0x80                  	// #128
static struct mobj_phys *to_mobj_phys(struct mobj *mobj)
 11179d4:	910003fd 	mov	x29, sp
	assert(mobj->ops == &mobj_phys_ops);
 11179d8:	97ffea35 	bl	11122ac <_assert_log>
 11179dc:	97ffea45 	bl	11122f0 <_assert_break>

00000000011179e0 <mobj_phys_matches>:
 11179e0:	f9400003 	ldr	x3, [x0]
 11179e4:	f00001a2 	adrp	x2, 114e000 <ldelf_data+0x8000>
 11179e8:	91048042 	add	x2, x2, #0x120
 11179ec:	eb02007f 	cmp	x3, x2
 11179f0:	54000080 	b.eq	1117a00 <mobj_phys_matches+0x20>  // b.none
{
 11179f4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 11179f8:	910003fd 	mov	x29, sp
 11179fc:	97ffffee 	bl	11179b4 <to_mobj_phys.part.0>
	a = moph->battr;
 1117a00:	51000423 	sub	w3, w1, #0x1
 1117a04:	b9402000 	ldr	w0, [x0, #32]
	switch (attr) {
 1117a08:	7100147f 	cmp	w3, #0x5
 1117a0c:	54000208 	b.hi	1117a4c <mobj_phys_matches+0x6c>  // b.pmore
 1117a10:	f00001a2 	adrp	x2, 114e000 <ldelf_data+0x8000>
 1117a14:	911a9042 	add	x2, x2, #0x6a4
 1117a18:	38634842 	ldrb	w2, [x2, w3, uxtw]
 1117a1c:	10000063 	adr	x3, 1117a28 <mobj_phys_matches+0x48>
 1117a20:	8b228862 	add	x2, x3, w2, sxtb #2
 1117a24:	d61f0040 	br	x2
		       a == CORE_MEM_TA_RAM || a == CORE_MEM_SDP_MEM;
 1117a28:	51000c00 	sub	w0, w0, #0x3
 1117a2c:	71000c1f 	cmp	w0, #0x3
 1117a30:	1a9f87e0 	cset	w0, ls  // ls = plast
 1117a34:	d65f03c0 	ret
		return a == CORE_MEM_NSEC_SHM;
 1117a38:	7100041f 	cmp	w0, #0x1
		return attr == a;
 1117a3c:	1a9f17e0 	cset	w0, eq  // eq = none
 1117a40:	d65f03c0 	ret
 1117a44:	6b01001f 	cmp	w0, w1
 1117a48:	17fffffd 	b	1117a3c <mobj_phys_matches+0x5c>
	a = moph->battr;
 1117a4c:	52800000 	mov	w0, #0x0                   	// #0
}
 1117a50:	d65f03c0 	ret

0000000001117a54 <mobj_virt_get_va>:
	assert(mobj->ops == &mobj_virt_ops);
 1117a54:	f9400000 	ldr	x0, [x0]
 1117a58:	f00001a2 	adrp	x2, 114e000 <ldelf_data+0x8000>
 1117a5c:	91048042 	add	x2, x2, #0x120
 1117a60:	91014042 	add	x2, x2, #0x50
 1117a64:	eb02001f 	cmp	x0, x2
 1117a68:	54000180 	b.eq	1117a98 <mobj_virt_get_va+0x44>  // b.none
 1117a6c:	d00001e3 	adrp	x3, 1155000 <__func__.3826+0xa8>
 1117a70:	b00001e1 	adrp	x1, 1154000 <__func__.1786+0x8>
 1117a74:	9103f463 	add	x3, x3, #0xfd
 1117a78:	913dd821 	add	x1, x1, #0xf76
 1117a7c:	b00001e0 	adrp	x0, 1154000 <__func__.1786+0x8>
 1117a80:	913e8400 	add	x0, x0, #0xfa1
{
 1117a84:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	assert(mobj->ops == &mobj_virt_ops);
 1117a88:	52801942 	mov	w2, #0xca                  	// #202
{
 1117a8c:	910003fd 	mov	x29, sp
	assert(mobj->ops == &mobj_virt_ops);
 1117a90:	97ffea07 	bl	11122ac <_assert_log>
 1117a94:	97ffea17 	bl	11122f0 <_assert_break>
}
 1117a98:	aa0103e0 	mov	x0, x1
 1117a9c:	d65f03c0 	ret

0000000001117aa0 <to_mobj_mm>:
	assert(mobj->ops == &mobj_mm_ops);
 1117aa0:	f9400002 	ldr	x2, [x0]
 1117aa4:	f00001a1 	adrp	x1, 114e000 <ldelf_data+0x8000>
 1117aa8:	91048021 	add	x1, x1, #0x120
 1117aac:	91028021 	add	x1, x1, #0xa0
 1117ab0:	eb01005f 	cmp	x2, x1
 1117ab4:	54000180 	b.eq	1117ae4 <to_mobj_mm+0x44>  // b.none
 1117ab8:	d00001e3 	adrp	x3, 1155000 <__func__.3826+0xa8>
 1117abc:	b00001e1 	adrp	x1, 1154000 <__func__.1786+0x8>
 1117ac0:	91044c63 	add	x3, x3, #0x113
 1117ac4:	913dd821 	add	x1, x1, #0xf76
 1117ac8:	b00001e0 	adrp	x0, 1154000 <__func__.1786+0x8>
 1117acc:	913ef400 	add	x0, x0, #0xfbd
{
 1117ad0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	assert(mobj->ops == &mobj_mm_ops);
 1117ad4:	52802262 	mov	w2, #0x113                 	// #275
{
 1117ad8:	910003fd 	mov	x29, sp
	assert(mobj->ops == &mobj_mm_ops);
 1117adc:	97ffe9f4 	bl	11122ac <_assert_log>
 1117ae0:	97ffea04 	bl	11122f0 <_assert_break>
}
 1117ae4:	d1004000 	sub	x0, x0, #0x10
 1117ae8:	d65f03c0 	ret

0000000001117aec <mobj_mm_matches>:
{
 1117aec:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1117af0:	910003fd 	mov	x29, sp
 1117af4:	f9000bf3 	str	x19, [sp, #16]
 1117af8:	2a0103f3 	mov	w19, w1
	return mobj_matches(to_mobj_mm(mobj)->parent_mobj, attr);
 1117afc:	97ffffe9 	bl	1117aa0 <to_mobj_mm>
 1117b00:	f9400400 	ldr	x0, [x0, #8]
	if (mobj && mobj->ops && mobj->ops->matches)
 1117b04:	b4000140 	cbz	x0, 1117b2c <mobj_mm_matches+0x40>
 1117b08:	f9400001 	ldr	x1, [x0]
 1117b0c:	b4000101 	cbz	x1, 1117b2c <mobj_mm_matches+0x40>
 1117b10:	f9401022 	ldr	x2, [x1, #32]
 1117b14:	b40000c2 	cbz	x2, 1117b2c <mobj_mm_matches+0x40>
		return mobj->ops->matches(mobj, attr);
 1117b18:	2a1303e1 	mov	w1, w19
 1117b1c:	aa0203f0 	mov	x16, x2
}
 1117b20:	f9400bf3 	ldr	x19, [sp, #16]
 1117b24:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1117b28:	d61f0200 	br	x16
	return false;
 1117b2c:	52800000 	mov	w0, #0x0                   	// #0
 1117b30:	f9400bf3 	ldr	x19, [sp, #16]
 1117b34:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1117b38:	d65f03c0 	ret

0000000001117b3c <mobj_mm_get_cattr>:
{
 1117b3c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1117b40:	910003fd 	mov	x29, sp
 1117b44:	f9000bf3 	str	x19, [sp, #16]
 1117b48:	aa0103f3 	mov	x19, x1
	return mobj_get_cattr(to_mobj_mm(mobj)->parent_mobj, cattr);
 1117b4c:	97ffffd5 	bl	1117aa0 <to_mobj_mm>
 1117b50:	f9400400 	ldr	x0, [x0, #8]
	if (mobj && mobj->ops && mobj->ops->get_cattr)
 1117b54:	b4000140 	cbz	x0, 1117b7c <mobj_mm_get_cattr+0x40>
 1117b58:	f9400001 	ldr	x1, [x0]
 1117b5c:	b4000101 	cbz	x1, 1117b7c <mobj_mm_get_cattr+0x40>
 1117b60:	f9400c22 	ldr	x2, [x1, #24]
 1117b64:	b40000c2 	cbz	x2, 1117b7c <mobj_mm_get_cattr+0x40>
		return mobj->ops->get_cattr(mobj, cattr);
 1117b68:	aa1303e1 	mov	x1, x19
 1117b6c:	aa0203f0 	mov	x16, x2
}
 1117b70:	f9400bf3 	ldr	x19, [sp, #16]
 1117b74:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1117b78:	d61f0200 	br	x16
 1117b7c:	52bfffe0 	mov	w0, #0xffff0000            	// #-65536
 1117b80:	f9400bf3 	ldr	x19, [sp, #16]
 1117b84:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1117b88:	d65f03c0 	ret

0000000001117b8c <mobj_mm_get_phys_offs>:
{
 1117b8c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1117b90:	910003fd 	mov	x29, sp
 1117b94:	f9000bf3 	str	x19, [sp, #16]
 1117b98:	aa0103f3 	mov	x19, x1
	return mobj_get_phys_offs(to_mobj_mm(mobj)->parent_mobj, granule);
 1117b9c:	97ffffc1 	bl	1117aa0 <to_mobj_mm>
 1117ba0:	f9400400 	ldr	x0, [x0, #8]
	if (mobj && mobj->ops && mobj->ops->get_phys_offs)
 1117ba4:	b4000140 	cbz	x0, 1117bcc <mobj_mm_get_phys_offs+0x40>
 1117ba8:	f9400001 	ldr	x1, [x0]
 1117bac:	b4000101 	cbz	x1, 1117bcc <mobj_mm_get_phys_offs+0x40>
 1117bb0:	f9400822 	ldr	x2, [x1, #16]
 1117bb4:	b40000c2 	cbz	x2, 1117bcc <mobj_mm_get_phys_offs+0x40>
		return mobj->ops->get_phys_offs(mobj, granule);
 1117bb8:	aa1303e1 	mov	x1, x19
 1117bbc:	aa0203f0 	mov	x16, x2
}
 1117bc0:	f9400bf3 	ldr	x19, [sp, #16]
 1117bc4:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1117bc8:	d61f0200 	br	x16
 1117bcc:	d2800000 	mov	x0, #0x0                   	// #0
 1117bd0:	f9400bf3 	ldr	x19, [sp, #16]
 1117bd4:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1117bd8:	d65f03c0 	ret

0000000001117bdc <mobj_mm_get_pa>:
{
 1117bdc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1117be0:	910003fd 	mov	x29, sp
 1117be4:	a90153f3 	stp	x19, x20, [sp, #16]
 1117be8:	aa0103f3 	mov	x19, x1
 1117bec:	aa0203f4 	mov	x20, x2
 1117bf0:	f90013f5 	str	x21, [sp, #32]
 1117bf4:	aa0303f5 	mov	x21, x3
	return mobj_get_pa(to_mobj_mm(mobj)->parent_mobj,
 1117bf8:	97ffffaa 	bl	1117aa0 <to_mobj_mm>
 1117bfc:	aa0003e4 	mov	x4, x0
 1117c00:	f9400400 	ldr	x0, [x0, #8]
	if (mobj && mobj->ops && mobj->ops->get_pa)
 1117c04:	b4000240 	cbz	x0, 1117c4c <mobj_mm_get_pa+0x70>
 1117c08:	f9400001 	ldr	x1, [x0]
 1117c0c:	b4000201 	cbz	x1, 1117c4c <mobj_mm_get_pa+0x70>
 1117c10:	f9400425 	ldr	x5, [x1, #8]
 1117c14:	b40001c5 	cbz	x5, 1117c4c <mobj_mm_get_pa+0x70>
	tee_mm_entry_t *mm = to_mobj_mm(mobj)->mm;
 1117c18:	f9400082 	ldr	x2, [x4]
		return mobj->ops->get_pa(mobj, offs, granule, pa);
 1117c1c:	aa0503f0 	mov	x16, x5
	return (mm->offset << mm->pool->shift) + offs;
 1117c20:	f9400041 	ldr	x1, [x2]
 1117c24:	39407023 	ldrb	w3, [x1, #28]
 1117c28:	b9401041 	ldr	w1, [x2, #16]
 1117c2c:	aa1403e2 	mov	x2, x20
 1117c30:	1ac32021 	lsl	w1, w1, w3
 1117c34:	aa1503e3 	mov	x3, x21
 1117c38:	8b130021 	add	x1, x1, x19
}
 1117c3c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1117c40:	f94013f5 	ldr	x21, [sp, #32]
 1117c44:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1117c48:	d61f0200 	br	x16
 1117c4c:	52bfffe0 	mov	w0, #0xffff0000            	// #-65536
 1117c50:	a94153f3 	ldp	x19, x20, [sp, #16]
 1117c54:	f94013f5 	ldr	x21, [sp, #32]
 1117c58:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1117c5c:	d65f03c0 	ret

0000000001117c60 <mobj_mm_free>:
{
 1117c60:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1117c64:	910003fd 	mov	x29, sp
 1117c68:	f9000bf3 	str	x19, [sp, #16]
	struct mobj_mm *m = to_mobj_mm(mobj);
 1117c6c:	97ffff8d 	bl	1117aa0 <to_mobj_mm>
 1117c70:	aa0003f3 	mov	x19, x0
	tee_mm_free(m->mm);
 1117c74:	f9400000 	ldr	x0, [x0]
 1117c78:	97ffcf29 	bl	110b91c <tee_mm_free>
	free(m);
 1117c7c:	aa1303e0 	mov	x0, x19
}
 1117c80:	f9400bf3 	ldr	x19, [sp, #16]
 1117c84:	a8c27bfd 	ldp	x29, x30, [sp], #32
	free(m);
 1117c88:	1400ae56 	b	11435e0 <free>

0000000001117c8c <to_mobj_shm.part.0>:
	assert(mobj->ops == &mobj_shm_ops);
 1117c8c:	d00001e3 	adrp	x3, 1155000 <__func__.3826+0xa8>
 1117c90:	b00001e1 	adrp	x1, 1154000 <__func__.1786+0x8>
 1117c94:	9104d463 	add	x3, x3, #0x135
 1117c98:	913dd821 	add	x1, x1, #0xf76
 1117c9c:	b00001e0 	adrp	x0, 1154000 <__func__.1786+0x8>
 1117ca0:	913f5c00 	add	x0, x0, #0xfd7
static struct mobj_shm *to_mobj_shm(struct mobj *mobj)
 1117ca4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	assert(mobj->ops == &mobj_shm_ops);
 1117ca8:	52803022 	mov	w2, #0x181                 	// #385
static struct mobj_shm *to_mobj_shm(struct mobj *mobj)
 1117cac:	910003fd 	mov	x29, sp
	assert(mobj->ops == &mobj_shm_ops);
 1117cb0:	97ffe97f 	bl	11122ac <_assert_log>
 1117cb4:	97ffe98f 	bl	11122f0 <_assert_break>

0000000001117cb8 <mobj_shm_get_pa>:
 1117cb8:	f9400005 	ldr	x5, [x0]
 1117cbc:	f00001a4 	adrp	x4, 114e000 <ldelf_data+0x8000>
 1117cc0:	91048084 	add	x4, x4, #0x120
 1117cc4:	9103c084 	add	x4, x4, #0xf0
 1117cc8:	eb0400bf 	cmp	x5, x4
 1117ccc:	54000080 	b.eq	1117cdc <mobj_shm_get_pa+0x24>  // b.none
{
 1117cd0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 1117cd4:	910003fd 	mov	x29, sp
 1117cd8:	97ffffed 	bl	1117c8c <to_mobj_shm.part.0>
	if (!pa || offs >= mobj->size)
 1117cdc:	b4000203 	cbz	x3, 1117d1c <mobj_shm_get_pa+0x64>
 1117ce0:	f9400404 	ldr	x4, [x0, #8]
 1117ce4:	eb01009f 	cmp	x4, x1
 1117ce8:	540001a9 	b.ls	1117d1c <mobj_shm_get_pa+0x64>  // b.plast
	p = m->pa + offs;
 1117cec:	f9401000 	ldr	x0, [x0, #32]
 1117cf0:	8b000021 	add	x1, x1, x0
	if (granule) {
 1117cf4:	b40000e2 	cbz	x2, 1117d10 <mobj_shm_get_pa+0x58>
		if (granule != SMALL_PAGE_SIZE &&
 1117cf8:	f140045f 	cmp	x2, #0x1, lsl #12
 1117cfc:	d2a00400 	mov	x0, #0x200000              	// #2097152
 1117d00:	fa401044 	ccmp	x2, x0, #0x4, ne  // ne = any
 1117d04:	540000c1 	b.ne	1117d1c <mobj_shm_get_pa+0x64>  // b.any
		p &= ~(granule - 1);
 1117d08:	cb0203e2 	neg	x2, x2
 1117d0c:	8a020021 	and	x1, x1, x2
	return TEE_SUCCESS;
 1117d10:	52800000 	mov	w0, #0x0                   	// #0
	*pa = p;
 1117d14:	f9000061 	str	x1, [x3]
	return TEE_SUCCESS;
 1117d18:	d65f03c0 	ret
		return TEE_ERROR_GENERIC;
 1117d1c:	52bfffe0 	mov	w0, #0xffff0000            	// #-65536
}
 1117d20:	d65f03c0 	ret

0000000001117d24 <to_mobj_with_fobj>:
	assert(mobj && mobj->ops == &mobj_with_fobj_ops);
 1117d24:	b40000e0 	cbz	x0, 1117d40 <to_mobj_with_fobj+0x1c>
 1117d28:	f9400002 	ldr	x2, [x0]
 1117d2c:	f00001a1 	adrp	x1, 114e000 <ldelf_data+0x8000>
 1117d30:	91048021 	add	x1, x1, #0x120
 1117d34:	91050021 	add	x1, x1, #0x140
 1117d38:	eb01005f 	cmp	x2, x1
 1117d3c:	54000180 	b.eq	1117d6c <to_mobj_with_fobj+0x48>  // b.none
 1117d40:	d00001e3 	adrp	x3, 1155000 <__func__.3826+0xa8>
 1117d44:	b00001e1 	adrp	x1, 1154000 <__func__.1786+0x8>
 1117d48:	91050463 	add	x3, x3, #0x141
 1117d4c:	913dd821 	add	x1, x1, #0xf76
 1117d50:	b00001e0 	adrp	x0, 1154000 <__func__.1786+0x8>
 1117d54:	913fc800 	add	x0, x0, #0xff2
{
 1117d58:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	assert(mobj && mobj->ops == &mobj_with_fobj_ops);
 1117d5c:	528044a2 	mov	w2, #0x225                 	// #549
{
 1117d60:	910003fd 	mov	x29, sp
	assert(mobj && mobj->ops == &mobj_with_fobj_ops);
 1117d64:	97ffe952 	bl	11122ac <_assert_log>
 1117d68:	97ffe962 	bl	11122f0 <_assert_break>
}
 1117d6c:	d1004000 	sub	x0, x0, #0x10
 1117d70:	d65f03c0 	ret

0000000001117d74 <mobj_with_fobj_free>:
{
 1117d74:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1117d78:	910003fd 	mov	x29, sp
 1117d7c:	a90153f3 	stp	x19, x20, [sp, #16]
	struct mobj_with_fobj *m = to_mobj_with_fobj(mobj);
 1117d80:	97ffffe9 	bl	1117d24 <to_mobj_with_fobj>
 1117d84:	aa0003f3 	mov	x19, x0
	fobj_put(m->fobj);
 1117d88:	f9400014 	ldr	x20, [x0]
	if (fobj && refcount_dec(&fobj->refc))
 1117d8c:	b4000134 	cbz	x20, 1117db0 <mobj_with_fobj_free+0x3c>
 1117d90:	91003280 	add	x0, x20, #0xc
 1117d94:	97ffee06 	bl	11135ac <refcount_dec>
 1117d98:	72001c1f 	tst	w0, #0xff
 1117d9c:	540000a0 	b.eq	1117db0 <mobj_with_fobj_free+0x3c>  // b.none
		fobj->ops->free(fobj);
 1117da0:	f9400280 	ldr	x0, [x20]
 1117da4:	f9400001 	ldr	x1, [x0]
 1117da8:	aa1403e0 	mov	x0, x20
 1117dac:	d63f0020 	blr	x1
	file_put(m->file);
 1117db0:	f9400660 	ldr	x0, [x19, #8]
 1117db4:	940002bb 	bl	11188a0 <file_put>
	free(m);
 1117db8:	aa1303e0 	mov	x0, x19
}
 1117dbc:	a94153f3 	ldp	x19, x20, [sp, #16]
 1117dc0:	a8c27bfd 	ldp	x29, x30, [sp], #32
	free(m);
 1117dc4:	1400ae07 	b	11435e0 <free>

0000000001117dc8 <mobj_with_fobj_matches>:
{
 1117dc8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1117dcc:	910003fd 	mov	x29, sp
 1117dd0:	f9000bf3 	str	x19, [sp, #16]
 1117dd4:	2a0103f3 	mov	w19, w1
	assert(to_mobj_with_fobj(mobj));
 1117dd8:	97ffffd3 	bl	1117d24 <to_mobj_with_fobj>
 1117ddc:	b5000140 	cbnz	x0, 1117e04 <mobj_with_fobj_matches+0x3c>
 1117de0:	d00001e3 	adrp	x3, 1155000 <__func__.3826+0xa8>
 1117de4:	b00001e1 	adrp	x1, 1154000 <__func__.1786+0x8>
 1117de8:	91054c63 	add	x3, x3, #0x153
 1117dec:	913dd821 	add	x1, x1, #0xf76
 1117df0:	d00001e0 	adrp	x0, 1155000 <__func__.3826+0xa8>
 1117df4:	91006c00 	add	x0, x0, #0x1b
 1117df8:	528045a2 	mov	w2, #0x22d                 	// #557
 1117dfc:	97ffe92c 	bl	11122ac <_assert_log>
 1117e00:	97ffe93c 	bl	11122f0 <_assert_break>
	return attr == CORE_MEM_SEC;
 1117e04:	71000e7f 	cmp	w19, #0x3
}
 1117e08:	1a9f17e0 	cset	w0, eq  // eq = none
 1117e0c:	f9400bf3 	ldr	x19, [sp, #16]
 1117e10:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1117e14:	d65f03c0 	ret

0000000001117e18 <mobj_with_fobj_get_pa>:

static TEE_Result mobj_with_fobj_get_pa(struct mobj *mobj, size_t offs,
					size_t granule, paddr_t *pa)
{
 1117e18:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1117e1c:	910003fd 	mov	x29, sp
 1117e20:	a90153f3 	stp	x19, x20, [sp, #16]
 1117e24:	aa0103f3 	mov	x19, x1
 1117e28:	aa0203f4 	mov	x20, x2
 1117e2c:	f90013f5 	str	x21, [sp, #32]
 1117e30:	aa0303f5 	mov	x21, x3
	struct mobj_with_fobj *f = to_mobj_with_fobj(mobj);
 1117e34:	97ffffbc 	bl	1117d24 <to_mobj_with_fobj>
	paddr_t p = 0;

	if (!f->fobj->ops->get_pa) {
 1117e38:	f9400000 	ldr	x0, [x0]
 1117e3c:	f9400001 	ldr	x1, [x0]
 1117e40:	f9400422 	ldr	x2, [x1, #8]
 1117e44:	b5000142 	cbnz	x2, 1117e6c <mobj_with_fobj_get_pa+0x54>
		assert(mobj_is_paged(mobj));
 1117e48:	d00001e3 	adrp	x3, 1155000 <__func__.3826+0xa8>
 1117e4c:	b00001e1 	adrp	x1, 1154000 <__func__.1786+0x8>
 1117e50:	9105a863 	add	x3, x3, #0x16a
 1117e54:	913dd821 	add	x1, x1, #0xf76
 1117e58:	d00001e0 	adrp	x0, 1155000 <__func__.3826+0xa8>
 1117e5c:	9100cc00 	add	x0, x0, #0x33
 1117e60:	52804b22 	mov	w2, #0x259                 	// #601
 1117e64:	97ffe912 	bl	11122ac <_assert_log>
 1117e68:	97ffe922 	bl	11122f0 <_assert_break>
		return TEE_ERROR_NOT_SUPPORTED;
	}

	p = f->fobj->ops->get_pa(f->fobj, offs / SMALL_PAGE_SIZE) +
 1117e6c:	d34cae61 	ubfx	x1, x19, #12, #32
	    offs % SMALL_PAGE_SIZE;
 1117e70:	92402e73 	and	x19, x19, #0xfff
	p = f->fobj->ops->get_pa(f->fobj, offs / SMALL_PAGE_SIZE) +
 1117e74:	d63f0040 	blr	x2
 1117e78:	8b000260 	add	x0, x19, x0

	if (granule) {
 1117e7c:	b40000f4 	cbz	x20, 1117e98 <mobj_with_fobj_get_pa+0x80>
		if (granule != SMALL_PAGE_SIZE &&
 1117e80:	f140069f 	cmp	x20, #0x1, lsl #12
 1117e84:	d2a00401 	mov	x1, #0x200000              	// #2097152
 1117e88:	fa411284 	ccmp	x20, x1, #0x4, ne  // ne = any
 1117e8c:	54000121 	b.ne	1117eb0 <mobj_with_fobj_get_pa+0x98>  // b.any
		    granule != CORE_MMU_PGDIR_SIZE)
			return TEE_ERROR_GENERIC;
		p &= ~(granule - 1);
 1117e90:	cb1403f4 	neg	x20, x20
 1117e94:	8a140000 	and	x0, x0, x20
	}

	*pa = p;
 1117e98:	f90002a0 	str	x0, [x21]

	return TEE_SUCCESS;
 1117e9c:	52800000 	mov	w0, #0x0                   	// #0
}
 1117ea0:	a94153f3 	ldp	x19, x20, [sp, #16]
 1117ea4:	f94013f5 	ldr	x21, [sp, #32]
 1117ea8:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1117eac:	d65f03c0 	ret
			return TEE_ERROR_GENERIC;
 1117eb0:	52bfffe0 	mov	w0, #0xffff0000            	// #-65536
 1117eb4:	17fffffb 	b	1117ea0 <mobj_with_fobj_get_pa+0x88>

0000000001117eb8 <fobj_get.part.0>:
static inline struct fobj *fobj_get(struct fobj *fobj)
 1117eb8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
		panic();
 1117ebc:	d00001e2 	adrp	x2, 1155000 <__func__.3826+0xa8>
 1117ec0:	d00001e0 	adrp	x0, 1155000 <__func__.3826+0xa8>
static inline struct fobj *fobj_get(struct fobj *fobj)
 1117ec4:	910003fd 	mov	x29, sp
		panic();
 1117ec8:	91035c42 	add	x2, x2, #0xd7
 1117ecc:	91011c00 	add	x0, x0, #0x47
 1117ed0:	d2800003 	mov	x3, #0x0                   	// #0
 1117ed4:	52801781 	mov	w1, #0xbc                  	// #188
 1117ed8:	97ffed64 	bl	1113468 <__do_panic>

0000000001117edc <mobj_shm_get_cookie>:
	assert(mobj->ops == &mobj_shm_ops);
 1117edc:	f9400002 	ldr	x2, [x0]
 1117ee0:	f00001a1 	adrp	x1, 114e000 <ldelf_data+0x8000>
 1117ee4:	91048021 	add	x1, x1, #0x120
 1117ee8:	9103c021 	add	x1, x1, #0xf0
 1117eec:	eb01005f 	cmp	x2, x1
 1117ef0:	54000080 	b.eq	1117f00 <mobj_shm_get_cookie+0x24>  // b.none
{
 1117ef4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 1117ef8:	910003fd 	mov	x29, sp
 1117efc:	97ffff64 	bl	1117c8c <to_mobj_shm.part.0>
}
 1117f00:	f9401400 	ldr	x0, [x0, #40]
 1117f04:	d65f03c0 	ret

0000000001117f08 <mobj_shm_free>:
	assert(mobj->ops == &mobj_shm_ops);
 1117f08:	f9400002 	ldr	x2, [x0]
 1117f0c:	f00001a1 	adrp	x1, 114e000 <ldelf_data+0x8000>
 1117f10:	91048021 	add	x1, x1, #0x120
 1117f14:	9103c021 	add	x1, x1, #0xf0
 1117f18:	eb01005f 	cmp	x2, x1
 1117f1c:	54000080 	b.eq	1117f2c <mobj_shm_free+0x24>  // b.none
{
 1117f20:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 1117f24:	910003fd 	mov	x29, sp
 1117f28:	97ffff59 	bl	1117c8c <to_mobj_shm.part.0>
	free(m);
 1117f2c:	1400adad 	b	11435e0 <free>

0000000001117f30 <mobj_phys_free>:
	assert(mobj->ops == &mobj_phys_ops);
 1117f30:	f9400002 	ldr	x2, [x0]
 1117f34:	f00001a1 	adrp	x1, 114e000 <ldelf_data+0x8000>
 1117f38:	91048021 	add	x1, x1, #0x120
 1117f3c:	eb01005f 	cmp	x2, x1
 1117f40:	54000080 	b.eq	1117f50 <mobj_phys_free+0x20>  // b.none
{
 1117f44:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 1117f48:	910003fd 	mov	x29, sp
 1117f4c:	97fffe9a 	bl	11179b4 <to_mobj_phys.part.0>
	free(moph);
 1117f50:	1400ada4 	b	11435e0 <free>

0000000001117f54 <mobj_with_fobj_get_fobj>:
{
 1117f54:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1117f58:	910003fd 	mov	x29, sp
 1117f5c:	f9000bf3 	str	x19, [sp, #16]
	return fobj_get(to_mobj_with_fobj(mobj)->fobj);
 1117f60:	97ffff71 	bl	1117d24 <to_mobj_with_fobj>
 1117f64:	f9400013 	ldr	x19, [x0]
	if (fobj && !refcount_inc(&fobj->refc))
 1117f68:	b40000d3 	cbz	x19, 1117f80 <mobj_with_fobj_get_fobj+0x2c>
 1117f6c:	91003260 	add	x0, x19, #0xc
 1117f70:	97ffed81 	bl	1113574 <refcount_inc>
 1117f74:	72001c1f 	tst	w0, #0xff
 1117f78:	54000041 	b.ne	1117f80 <mobj_with_fobj_get_fobj+0x2c>  // b.any
 1117f7c:	97ffffcf 	bl	1117eb8 <fobj_get.part.0>
}
 1117f80:	aa1303e0 	mov	x0, x19
 1117f84:	f9400bf3 	ldr	x19, [sp, #16]
 1117f88:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1117f8c:	d65f03c0 	ret

0000000001117f90 <mobj_phys_get_cattr>:
	assert(mobj->ops == &mobj_phys_ops);
 1117f90:	f9400003 	ldr	x3, [x0]
 1117f94:	f00001a2 	adrp	x2, 114e000 <ldelf_data+0x8000>
 1117f98:	91048042 	add	x2, x2, #0x120
 1117f9c:	eb02007f 	cmp	x3, x2
 1117fa0:	54000080 	b.eq	1117fb0 <mobj_phys_get_cattr+0x20>  // b.none
{
 1117fa4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 1117fa8:	910003fd 	mov	x29, sp
 1117fac:	97fffe82 	bl	11179b4 <to_mobj_phys.part.0>
	if (!cattr)
 1117fb0:	b40000a1 	cbz	x1, 1117fc4 <mobj_phys_get_cattr+0x34>
	*cattr = moph->cattr;
 1117fb4:	b9402400 	ldr	w0, [x0, #36]
 1117fb8:	b9000020 	str	w0, [x1]
	return TEE_SUCCESS;
 1117fbc:	52800000 	mov	w0, #0x0                   	// #0
 1117fc0:	d65f03c0 	ret
		return TEE_ERROR_GENERIC;
 1117fc4:	52bfffe0 	mov	w0, #0xffff0000            	// #-65536
}
 1117fc8:	d65f03c0 	ret

0000000001117fcc <mobj_phys_get_va>:
	assert(mobj->ops == &mobj_phys_ops);
 1117fcc:	f9400003 	ldr	x3, [x0]
 1117fd0:	f00001a2 	adrp	x2, 114e000 <ldelf_data+0x8000>
 1117fd4:	91048042 	add	x2, x2, #0x120
 1117fd8:	eb02007f 	cmp	x3, x2
 1117fdc:	54000080 	b.eq	1117fec <mobj_phys_get_va+0x20>  // b.none
{
 1117fe0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 1117fe4:	910003fd 	mov	x29, sp
 1117fe8:	97fffe73 	bl	11179b4 <to_mobj_phys.part.0>
	if (!moph->va || offset >= mobj->size)
 1117fec:	f9401402 	ldr	x2, [x0, #40]
 1117ff0:	b40000c2 	cbz	x2, 1118008 <mobj_phys_get_va+0x3c>
 1117ff4:	f9400403 	ldr	x3, [x0, #8]
	return (void *)(moph->va + offset);
 1117ff8:	8b010040 	add	x0, x2, x1
 1117ffc:	eb01007f 	cmp	x3, x1
 1118000:	9a9f8000 	csel	x0, x0, xzr, hi  // hi = pmore
 1118004:	d65f03c0 	ret
		return NULL;
 1118008:	d2800000 	mov	x0, #0x0                   	// #0
}
 111800c:	d65f03c0 	ret

0000000001118010 <mobj_shm_get_va>:
{
 1118010:	aa0103e3 	mov	x3, x1
	assert(mobj->ops == &mobj_shm_ops);
 1118014:	d00001a2 	adrp	x2, 114e000 <ldelf_data+0x8000>
 1118018:	f9400001 	ldr	x1, [x0]
 111801c:	91048042 	add	x2, x2, #0x120
 1118020:	9103c042 	add	x2, x2, #0xf0
 1118024:	eb02003f 	cmp	x1, x2
 1118028:	54000080 	b.eq	1118038 <mobj_shm_get_va+0x28>  // b.none
{
 111802c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 1118030:	910003fd 	mov	x29, sp
 1118034:	97ffff16 	bl	1117c8c <to_mobj_shm.part.0>
	if (offset >= mobj->size)
 1118038:	f9400401 	ldr	x1, [x0, #8]
 111803c:	eb03003f 	cmp	x1, x3
 1118040:	540000a9 	b.ls	1118054 <mobj_shm_get_va+0x44>  // b.plast
	return phys_to_virt(m->pa + offset, MEM_AREA_NSEC_SHM);
 1118044:	f9401000 	ldr	x0, [x0, #32]
 1118048:	52800141 	mov	w1, #0xa                   	// #10
 111804c:	8b000060 	add	x0, x3, x0
 1118050:	17ffc9b9 	b	110a734 <phys_to_virt>
}
 1118054:	d2800000 	mov	x0, #0x0                   	// #0
 1118058:	d65f03c0 	ret

000000000111805c <mobj_shm_get_phys_offs>:
{
 111805c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 1118060:	910003fd 	mov	x29, sp
	assert(IS_POWER_OF_TWO(granule));
 1118064:	b40000a1 	cbz	x1, 1118078 <mobj_shm_get_phys_offs+0x1c>
 1118068:	cb0103e3 	neg	x3, x1
 111806c:	8a010062 	and	x2, x3, x1
 1118070:	ea23003f 	bics	xzr, x1, x3
 1118074:	54000140 	b.eq	111809c <mobj_shm_get_phys_offs+0x40>  // b.none
 1118078:	b00001e3 	adrp	x3, 1155000 <__func__.3826+0xa8>
 111807c:	900001e1 	adrp	x1, 1154000 <__func__.1786+0x8>
 1118080:	91047863 	add	x3, x3, #0x11e
 1118084:	913dd821 	add	x1, x1, #0xf76
 1118088:	b00001e0 	adrp	x0, 1155000 <__func__.3826+0xa8>
 111808c:	910b8400 	add	x0, x0, #0x2e1
 1118090:	52802c22 	mov	w2, #0x161                 	// #353
 1118094:	97ffe886 	bl	11122ac <_assert_log>
 1118098:	97ffe896 	bl	11122f0 <_assert_break>
	assert(mobj->ops == &mobj_shm_ops);
 111809c:	f9400003 	ldr	x3, [x0]
 11180a0:	d00001a1 	adrp	x1, 114e000 <ldelf_data+0x8000>
 11180a4:	91048021 	add	x1, x1, #0x120
 11180a8:	9103c021 	add	x1, x1, #0xf0
 11180ac:	eb01007f 	cmp	x3, x1
 11180b0:	54000040 	b.eq	11180b8 <mobj_shm_get_phys_offs+0x5c>  // b.none
 11180b4:	97fffef6 	bl	1117c8c <to_mobj_shm.part.0>
	return to_mobj_shm(mobj)->pa & (granule - 1);
 11180b8:	f9401000 	ldr	x0, [x0, #32]
 11180bc:	d1000442 	sub	x2, x2, #0x1
}
 11180c0:	a8c17bfd 	ldp	x29, x30, [sp], #16
 11180c4:	8a000040 	and	x0, x2, x0
 11180c8:	d65f03c0 	ret

00000000011180cc <mobj_phys_get_pa>:
	assert(mobj->ops == &mobj_phys_ops);
 11180cc:	f9400005 	ldr	x5, [x0]
 11180d0:	d00001a4 	adrp	x4, 114e000 <ldelf_data+0x8000>
 11180d4:	91048084 	add	x4, x4, #0x120
 11180d8:	eb0400bf 	cmp	x5, x4
 11180dc:	54000080 	b.eq	11180ec <mobj_phys_get_pa+0x20>  // b.none
{
 11180e0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 11180e4:	910003fd 	mov	x29, sp
 11180e8:	97fffe33 	bl	11179b4 <to_mobj_phys.part.0>
	if (!pa)
 11180ec:	b40001a3 	cbz	x3, 1118120 <mobj_phys_get_pa+0x54>
	p = moph->pa + offs;
 11180f0:	f9401800 	ldr	x0, [x0, #48]
 11180f4:	8b000021 	add	x1, x1, x0
	if (granule) {
 11180f8:	b40000e2 	cbz	x2, 1118114 <mobj_phys_get_pa+0x48>
		if (granule != SMALL_PAGE_SIZE &&
 11180fc:	f140045f 	cmp	x2, #0x1, lsl #12
 1118100:	d2a00400 	mov	x0, #0x200000              	// #2097152
 1118104:	fa401044 	ccmp	x2, x0, #0x4, ne  // ne = any
 1118108:	540000c1 	b.ne	1118120 <mobj_phys_get_pa+0x54>  // b.any
		p &= ~(granule - 1);
 111810c:	cb0203e2 	neg	x2, x2
 1118110:	8a020021 	and	x1, x1, x2
	return TEE_SUCCESS;
 1118114:	52800000 	mov	w0, #0x0                   	// #0
	*pa = p;
 1118118:	f9000061 	str	x1, [x3]
	return TEE_SUCCESS;
 111811c:	d65f03c0 	ret
		return TEE_ERROR_GENERIC;
 1118120:	52bfffe0 	mov	w0, #0xffff0000            	// #-65536
}
 1118124:	d65f03c0 	ret

0000000001118128 <mobj_mm_get_va>:
{
 1118128:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 111812c:	910003fd 	mov	x29, sp
 1118130:	f9000bf3 	str	x19, [sp, #16]
 1118134:	aa0103f3 	mov	x19, x1
	return mobj_get_va(to_mobj_mm(mobj)->parent_mobj,
 1118138:	97fffe5a 	bl	1117aa0 <to_mobj_mm>
 111813c:	aa0003e2 	mov	x2, x0
 1118140:	f9400400 	ldr	x0, [x0, #8]
	if (mobj && mobj->ops && mobj->ops->get_va)
 1118144:	b40001e0 	cbz	x0, 1118180 <mobj_mm_get_va+0x58>
 1118148:	f9400001 	ldr	x1, [x0]
 111814c:	b40001a1 	cbz	x1, 1118180 <mobj_mm_get_va+0x58>
 1118150:	f9400023 	ldr	x3, [x1]
 1118154:	b4000163 	cbz	x3, 1118180 <mobj_mm_get_va+0x58>
	tee_mm_entry_t *mm = to_mobj_mm(mobj)->mm;
 1118158:	f9400042 	ldr	x2, [x2]
		return mobj->ops->get_va(mobj, offset);
 111815c:	aa0303f0 	mov	x16, x3
	return (mm->offset << mm->pool->shift) + offs;
 1118160:	f9400041 	ldr	x1, [x2]
 1118164:	39407024 	ldrb	w4, [x1, #28]
 1118168:	b9401041 	ldr	w1, [x2, #16]
 111816c:	1ac42021 	lsl	w1, w1, w4
 1118170:	8b130021 	add	x1, x1, x19
}
 1118174:	f9400bf3 	ldr	x19, [sp, #16]
 1118178:	a8c27bfd 	ldp	x29, x30, [sp], #32
 111817c:	d61f0200 	br	x16
 1118180:	d2800000 	mov	x0, #0x0                   	// #0
 1118184:	f9400bf3 	ldr	x19, [sp, #16]
 1118188:	a8c27bfd 	ldp	x29, x30, [sp], #32
 111818c:	d65f03c0 	ret

0000000001118190 <mobj_phys_alloc>:
{
 1118190:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 1118194:	910003fd 	mov	x29, sp
 1118198:	a90153f3 	stp	x19, x20, [sp, #16]
 111819c:	aa0003f4 	mov	x20, x0
	if ((pa & CORE_MMU_USER_PARAM_MASK) ||
 11181a0:	aa010000 	orr	x0, x0, x1
{
 11181a4:	a9025bf5 	stp	x21, x22, [sp, #32]
	if ((pa & CORE_MMU_USER_PARAM_MASK) ||
 11181a8:	f2402c1f 	tst	x0, #0xfff
{
 11181ac:	f9001bf7 	str	x23, [sp, #48]
	if ((pa & CORE_MMU_USER_PARAM_MASK) ||
 11181b0:	54000180 	b.eq	11181e0 <mobj_phys_alloc+0x50>  // b.none
		DMSG("Expect %#x alignment", CORE_MMU_USER_PARAM_SIZE);
 11181b4:	b00001e4 	adrp	x4, 1155000 <__func__.3826+0xa8>
 11181b8:	b00001e0 	adrp	x0, 1155000 <__func__.3826+0xa8>
 11181bc:	91017884 	add	x4, x4, #0x5e
 11181c0:	9103b400 	add	x0, x0, #0xed
 11181c4:	52820005 	mov	w5, #0x1000                	// #4096
 11181c8:	52800023 	mov	w3, #0x1                   	// #1
 11181cc:	52800062 	mov	w2, #0x3                   	// #3
 11181d0:	528011a1 	mov	w1, #0x8d                  	// #141
 11181d4:	9400b2dc 	bl	1144d44 <trace_printf>
		return NULL;
 11181d8:	d2800000 	mov	x0, #0x0                   	// #0
 11181dc:	14000021 	b	1118260 <mobj_phys_alloc+0xd0>
 11181e0:	aa0103f6 	mov	x22, x1
 11181e4:	51000461 	sub	w1, w3, #0x1
 11181e8:	2a0303f3 	mov	w19, w3
	switch (battr) {
 11181ec:	7100143f 	cmp	w1, #0x5
 11181f0:	54000468 	b.hi	111827c <mobj_phys_alloc+0xec>  // b.pmore
 11181f4:	d00001a0 	adrp	x0, 114e000 <ldelf_data+0x8000>
 11181f8:	2a0203f7 	mov	w23, w2
 11181fc:	911ab000 	add	x0, x0, #0x6ac
 1118200:	38614800 	ldrb	w0, [x0, w1, uxtw]
 1118204:	10000061 	adr	x1, 1118210 <mobj_phys_alloc+0x80>
 1118208:	8b208820 	add	x0, x1, w0, sxtb #2
 111820c:	d61f0000 	br	x0
		area_type = MEM_AREA_TA_RAM;
 1118210:	52800121 	mov	w1, #0x9                   	// #9
	va = phys_to_virt(pa, area_type);
 1118214:	aa1403e0 	mov	x0, x20
 1118218:	97ffc947 	bl	110a734 <phys_to_virt>
	if (!va && battr != CORE_MEM_SDP_MEM)
 111821c:	f100001f 	cmp	x0, #0x0
	va = phys_to_virt(pa, area_type);
 1118220:	aa0003f5 	mov	x21, x0
	if (!va && battr != CORE_MEM_SDP_MEM)
 1118224:	7a460a64 	ccmp	w19, #0x6, #0x4, eq  // eq = none
 1118228:	54fffd81 	b.ne	11181d8 <mobj_phys_alloc+0x48>  // b.any
	moph = calloc(1, sizeof(*moph));
 111822c:	d2800701 	mov	x1, #0x38                  	// #56
 1118230:	d2800020 	mov	x0, #0x1                   	// #1
 1118234:	9400aca7 	bl	11434d0 <calloc>
	if (!moph)
 1118238:	b4000140 	cbz	x0, 1118260 <mobj_phys_alloc+0xd0>
	moph->mobj.ops = &mobj_phys_ops;
 111823c:	aa0003e1 	mov	x1, x0
	moph->mobj.size = size;
 1118240:	f9000416 	str	x22, [x0, #8]
	moph->cattr = cattr;
 1118244:	29045c13 	stp	w19, w23, [x0, #32]
	moph->mobj.ops = &mobj_phys_ops;
 1118248:	d00001a2 	adrp	x2, 114e000 <ldelf_data+0x8000>
 111824c:	91048042 	add	x2, x2, #0x120
 1118250:	f8018422 	str	x2, [x1], #24
	__compiler_atomic_store(p, val);
 1118254:	52800022 	mov	w2, #0x1                   	// #1
 1118258:	b9000022 	str	w2, [x1]
	moph->pa = pa;
 111825c:	a902d015 	stp	x21, x20, [x0, #40]
}
 1118260:	a94153f3 	ldp	x19, x20, [sp, #16]
 1118264:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1118268:	f9401bf7 	ldr	x23, [sp, #48]
 111826c:	a8c47bfd 	ldp	x29, x30, [sp], #64
 1118270:	d65f03c0 	ret
		area_type = MEM_AREA_SDP_MEM;
 1118274:	52800281 	mov	w1, #0x14                  	// #20
		break;
 1118278:	17ffffe7 	b	1118214 <mobj_phys_alloc+0x84>
		DMSG("can't allocate with specified attribute");
 111827c:	b00001e4 	adrp	x4, 1155000 <__func__.3826+0xa8>
 1118280:	52800023 	mov	w3, #0x1                   	// #1
 1118284:	9101cc84 	add	x4, x4, #0x73
 1118288:	52800062 	mov	w2, #0x3                   	// #3
 111828c:	528013e1 	mov	w1, #0x9f                  	// #159
 1118290:	b00001e0 	adrp	x0, 1155000 <__func__.3826+0xa8>
 1118294:	9103b400 	add	x0, x0, #0xed
 1118298:	9400b2ab 	bl	1144d44 <trace_printf>
		return NULL;
 111829c:	17ffffcf 	b	11181d8 <mobj_phys_alloc+0x48>
		area_type = MEM_AREA_TEE_RAM_RW_DATA;
 11182a0:	2a0303e1 	mov	w1, w3
 11182a4:	17ffffdc 	b	1118214 <mobj_phys_alloc+0x84>
	if ((pa & CORE_MMU_USER_PARAM_MASK) ||
 11182a8:	52800141 	mov	w1, #0xa                   	// #10
 11182ac:	17ffffda 	b	1118214 <mobj_phys_alloc+0x84>

00000000011182b0 <mobj_init>:
	return false;
}
#endif /*CFG_PAGED_USER_TA*/

static TEE_Result mobj_init(void)
{
 11182b0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	mobj_sec_ddr = mobj_phys_alloc(tee_mm_sec_ddr.lo,
 11182b4:	528000a3 	mov	w3, #0x5                   	// #5
 11182b8:	52800022 	mov	w2, #0x1                   	// #1
{
 11182bc:	910003fd 	mov	x29, sp
 11182c0:	f9000bf3 	str	x19, [sp, #16]
	mobj_sec_ddr = mobj_phys_alloc(tee_mm_sec_ddr.lo,
 11182c4:	d0000213 	adrp	x19, 115a000 <__scattered_array_1phys_mem_map+0x8>
 11182c8:	f9415261 	ldr	x1, [x19, #672]
 11182cc:	a9408420 	ldp	x0, x1, [x1, #8]
 11182d0:	cb000021 	sub	x1, x1, x0
 11182d4:	97ffffaf 	bl	1118190 <mobj_phys_alloc>
 11182d8:	f9412e61 	ldr	x1, [x19, #600]
 11182dc:	f9000020 	str	x0, [x1]
				       tee_mm_sec_ddr.hi - tee_mm_sec_ddr.lo,
				       OPTEE_SMC_SHM_CACHED, CORE_MEM_TA_RAM);
	if (!mobj_sec_ddr)
 11182e0:	b5000120 	cbnz	x0, 1118304 <mobj_init+0x54>
		panic("Failed to register secure ta ram");
 11182e4:	b00001e3 	adrp	x3, 1155000 <__func__.3826+0xa8>
 11182e8:	b00001e2 	adrp	x2, 1155000 <__func__.3826+0xa8>
 11182ec:	91026c63 	add	x3, x3, #0x9b
 11182f0:	91060042 	add	x2, x2, #0x180
 11182f4:	52805121 	mov	w1, #0x289                 	// #649
				       VCORE_UNPG_RW_PA + VCORE_UNPG_RW_SZ -
						TEE_RAM_START,
				       TEE_MATTR_CACHE_CACHED,
				       CORE_MEM_TEE_RAM);
	if (!mobj_tee_ram)
		panic("Failed to register tee ram");
 11182f8:	900001e0 	adrp	x0, 1154000 <__func__.1786+0x8>
 11182fc:	913dd800 	add	x0, x0, #0xf76
 1118300:	97ffec5a 	bl	1113468 <__do_panic>
	mobj_tee_ram = mobj_phys_alloc(TEE_RAM_START,
 1118304:	f9417e61 	ldr	x1, [x19, #760]
 1118308:	929fffe0 	mov	x0, #0xffffffffffff0000    	// #-65536
 111830c:	f2bfde00 	movk	x0, #0xfef0, lsl #16
 1118310:	52800083 	mov	w3, #0x4                   	// #4
 1118314:	8b000021 	add	x1, x1, x0
 1118318:	52800022 	mov	w2, #0x1                   	// #1
 111831c:	d2a02200 	mov	x0, #0x1100000             	// #17825792
 1118320:	97ffff9c 	bl	1118190 <mobj_phys_alloc>
 1118324:	f9420a73 	ldr	x19, [x19, #1040]
 1118328:	f9000260 	str	x0, [x19]
	if (!mobj_tee_ram)
 111832c:	b50000e0 	cbnz	x0, 1118348 <mobj_init+0x98>
		panic("Failed to register tee ram");
 1118330:	b00001e3 	adrp	x3, 1155000 <__func__.3826+0xa8>
 1118334:	b00001e2 	adrp	x2, 1155000 <__func__.3826+0xa8>
 1118338:	9102f063 	add	x3, x3, #0xbc
 111833c:	91060042 	add	x2, x2, #0x180
 1118340:	52805221 	mov	w1, #0x291                 	// #657
 1118344:	17ffffed 	b	11182f8 <mobj_init+0x48>

	return TEE_SUCCESS;
}
 1118348:	52800000 	mov	w0, #0x0                   	// #0
 111834c:	f9400bf3 	ldr	x19, [sp, #16]
 1118350:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1118354:	d65f03c0 	ret

0000000001118358 <mobj_mm_alloc>:
{
 1118358:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 111835c:	910003fd 	mov	x29, sp
 1118360:	a90153f3 	stp	x19, x20, [sp, #16]
 1118364:	aa0103f4 	mov	x20, x1
	struct mobj_mm *m = calloc(1, sizeof(*m));
 1118368:	d2800601 	mov	x1, #0x30                  	// #48
{
 111836c:	a9025bf5 	stp	x21, x22, [sp, #32]
 1118370:	aa0003f5 	mov	x21, x0
 1118374:	aa0203f6 	mov	x22, x2
	struct mobj_mm *m = calloc(1, sizeof(*m));
 1118378:	d2800020 	mov	x0, #0x1                   	// #1
 111837c:	9400ac55 	bl	11434d0 <calloc>
 1118380:	aa0003f3 	mov	x19, x0
	if (!m)
 1118384:	b4000120 	cbz	x0, 11183a8 <mobj_mm_alloc+0x50>
	m->mm = tee_mm_alloc(pool, size);
 1118388:	aa1403e1 	mov	x1, x20
 111838c:	aa1603e0 	mov	x0, x22
 1118390:	97ffccf4 	bl	110b760 <tee_mm_alloc>
 1118394:	f9000260 	str	x0, [x19]
	if (!m->mm) {
 1118398:	b5000120 	cbnz	x0, 11183bc <mobj_mm_alloc+0x64>
		free(m);
 111839c:	aa1303e0 	mov	x0, x19
		return NULL;
 11183a0:	d2800013 	mov	x19, #0x0                   	// #0
		free(m);
 11183a4:	9400ac8f 	bl	11435e0 <free>
}
 11183a8:	aa1303e0 	mov	x0, x19
 11183ac:	a94153f3 	ldp	x19, x20, [sp, #16]
 11183b0:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11183b4:	a8c37bfd 	ldp	x29, x30, [sp], #48
 11183b8:	d65f03c0 	ret
	m->mobj.ops = &mobj_mm_ops;
 11183bc:	d00001a0 	adrp	x0, 114e000 <ldelf_data+0x8000>
 11183c0:	91048000 	add	x0, x0, #0x120
 11183c4:	91028000 	add	x0, x0, #0xa0
 11183c8:	a9008275 	stp	x21, x0, [x19, #8]
 11183cc:	52800021 	mov	w1, #0x1                   	// #1
	m->mobj.size = size;
 11183d0:	f9000e74 	str	x20, [x19, #24]
 11183d4:	9100a260 	add	x0, x19, #0x28
 11183d8:	b9000001 	str	w1, [x0]
	return &m->mobj;
 11183dc:	91004273 	add	x19, x19, #0x10
 11183e0:	17fffff2 	b	11183a8 <mobj_mm_alloc+0x50>

00000000011183e4 <mobj_shm_alloc>:
{
 11183e4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 11183e8:	910003fd 	mov	x29, sp
 11183ec:	a90153f3 	stp	x19, x20, [sp, #16]
 11183f0:	aa0003f3 	mov	x19, x0
 11183f4:	aa0103f4 	mov	x20, x1
 11183f8:	f90013f5 	str	x21, [sp, #32]
 11183fc:	aa0203f5 	mov	x21, x2
	if (!core_pbuf_is(CORE_MEM_NSEC_SHM, pa, size))
 1118400:	aa0103e2 	mov	x2, x1
 1118404:	aa0003e1 	mov	x1, x0
 1118408:	52800020 	mov	w0, #0x1                   	// #1
 111840c:	97ffc47b 	bl	11095f8 <core_pbuf_is>
 1118410:	72001c1f 	tst	w0, #0xff
 1118414:	54000240 	b.eq	111845c <mobj_shm_alloc+0x78>  // b.none
	m = calloc(1, sizeof(*m));
 1118418:	d2800601 	mov	x1, #0x30                  	// #48
 111841c:	d2800020 	mov	x0, #0x1                   	// #1
 1118420:	9400ac2c 	bl	11434d0 <calloc>
	if (!m)
 1118424:	b4000140 	cbz	x0, 111844c <mobj_shm_alloc+0x68>
	m->mobj.ops = &mobj_shm_ops;
 1118428:	aa0003e2 	mov	x2, x0
 111842c:	d00001a1 	adrp	x1, 114e000 <ldelf_data+0x8000>
 1118430:	91048021 	add	x1, x1, #0x120
	m->mobj.size = size;
 1118434:	f9000414 	str	x20, [x0, #8]
	m->mobj.ops = &mobj_shm_ops;
 1118438:	9103c021 	add	x1, x1, #0xf0
 111843c:	f8018441 	str	x1, [x2], #24
 1118440:	52800021 	mov	w1, #0x1                   	// #1
 1118444:	b9000041 	str	w1, [x2]
	m->cookie = cookie;
 1118448:	a9025413 	stp	x19, x21, [x0, #32]
}
 111844c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1118450:	f94013f5 	ldr	x21, [sp, #32]
 1118454:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1118458:	d65f03c0 	ret
		return NULL;
 111845c:	d2800000 	mov	x0, #0x0                   	// #0
 1118460:	17fffffb 	b	111844c <mobj_shm_alloc+0x68>

0000000001118464 <mobj_with_fobj_alloc>:
	if (!fobj)
 1118464:	b5000100 	cbnz	x0, 1118484 <mobj_with_fobj_alloc+0x20>
		return NULL;
 1118468:	d2800000 	mov	x0, #0x0                   	// #0
}
 111846c:	d65f03c0 	ret
		return NULL;
 1118470:	d2800000 	mov	x0, #0x0                   	// #0
}
 1118474:	a94153f3 	ldp	x19, x20, [sp, #16]
 1118478:	f94013f5 	ldr	x21, [sp, #32]
 111847c:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1118480:	d65f03c0 	ret
{
 1118484:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1118488:	910003fd 	mov	x29, sp
 111848c:	a90153f3 	stp	x19, x20, [sp, #16]
 1118490:	aa0003f4 	mov	x20, x0
	m = calloc(1, sizeof(*m));
 1118494:	d2800020 	mov	x0, #0x1                   	// #1
{
 1118498:	f90013f5 	str	x21, [sp, #32]
 111849c:	aa0103f5 	mov	x21, x1
	m = calloc(1, sizeof(*m));
 11184a0:	d2800601 	mov	x1, #0x30                  	// #48
 11184a4:	9400ac0b 	bl	11434d0 <calloc>
 11184a8:	aa0003f3 	mov	x19, x0
	if (!m)
 11184ac:	b4fffe20 	cbz	x0, 1118470 <mobj_with_fobj_alloc+0xc>
	m->mobj.ops = &mobj_with_fobj_ops;
 11184b0:	d00001a0 	adrp	x0, 114e000 <ldelf_data+0x8000>
 11184b4:	91048000 	add	x0, x0, #0x120
 11184b8:	91050000 	add	x0, x0, #0x140
 11184bc:	f9000a60 	str	x0, [x19, #16]
 11184c0:	52800021 	mov	w1, #0x1                   	// #1
 11184c4:	9100a260 	add	x0, x19, #0x28
 11184c8:	b9000001 	str	w1, [x0]
	m->mobj.size = fobj->num_pages * SMALL_PAGE_SIZE;
 11184cc:	b9400a80 	ldr	w0, [x20, #8]
 11184d0:	53144c00 	lsl	w0, w0, #12
 11184d4:	f9000e60 	str	x0, [x19, #24]
	m->mobj.phys_granule = SMALL_PAGE_SIZE;
 11184d8:	d2820000 	mov	x0, #0x1000                	// #4096
 11184dc:	f9001260 	str	x0, [x19, #32]
 11184e0:	91003280 	add	x0, x20, #0xc
 11184e4:	97ffec24 	bl	1113574 <refcount_inc>
 11184e8:	72001c1f 	tst	w0, #0xff
 11184ec:	54000041 	b.ne	11184f4 <mobj_with_fobj_alloc+0x90>  // b.any
 11184f0:	97fffe72 	bl	1117eb8 <fobj_get.part.0>
	m->file = file_get(file);
 11184f4:	aa1503e0 	mov	x0, x21
	m->fobj = fobj_get(fobj);
 11184f8:	f9000274 	str	x20, [x19]
	m->file = file_get(file);
 11184fc:	94000092 	bl	1118744 <file_get>
 1118500:	f9000660 	str	x0, [x19, #8]
	return &m->mobj;
 1118504:	91004260 	add	x0, x19, #0x10
 1118508:	17ffffdb 	b	1118474 <mobj_with_fobj_alloc+0x10>

000000000111850c <to_sec_mem.part.0>:
	return NULL;
}

static struct fobj_sec_mem *to_sec_mem(struct fobj *fobj)
{
	assert(fobj->ops == &ops_sec_mem);
 111850c:	b00001e3 	adrp	x3, 1155000 <__func__.3826+0xa8>
 1118510:	b00001e1 	adrp	x1, 1155000 <__func__.3826+0xa8>
 1118514:	9107a463 	add	x3, x3, #0x1e9
 1118518:	91062821 	add	x1, x1, #0x18a
 111851c:	b00001e0 	adrp	x0, 1155000 <__func__.3826+0xa8>
 1118520:	91066400 	add	x0, x0, #0x199
static struct fobj_sec_mem *to_sec_mem(struct fobj *fobj)
 1118524:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	assert(fobj->ops == &ops_sec_mem);
 1118528:	52805f22 	mov	w2, #0x2f9                 	// #761
static struct fobj_sec_mem *to_sec_mem(struct fobj *fobj)
 111852c:	910003fd 	mov	x29, sp
	assert(fobj->ops == &ops_sec_mem);
 1118530:	97ffe75f 	bl	11122ac <_assert_log>
 1118534:	97ffe76f 	bl	11122f0 <_assert_break>

0000000001118538 <sec_mem_get_pa>:
	tee_mm_free(f->mm);
	free(f);
}

static paddr_t sec_mem_get_pa(struct fobj *fobj, unsigned int page_idx)
{
 1118538:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 111853c:	910003fd 	mov	x29, sp
	assert(fobj->ops == &ops_sec_mem);
 1118540:	f9400002 	ldr	x2, [x0]
{
 1118544:	f9000bf3 	str	x19, [sp, #16]
 1118548:	2a0103f3 	mov	w19, w1
	assert(fobj->ops == &ops_sec_mem);
 111854c:	d00001a1 	adrp	x1, 114e000 <ldelf_data+0x8000>
 1118550:	910ac021 	add	x1, x1, #0x2b0
 1118554:	eb01005f 	cmp	x2, x1
 1118558:	54000040 	b.eq	1118560 <sec_mem_get_pa+0x28>  // b.none
 111855c:	97ffffec 	bl	111850c <to_sec_mem.part.0>
	return __compiler_atomic_load(p);
 1118560:	91003001 	add	x1, x0, #0xc
 1118564:	b9400021 	ldr	w1, [x1]
	struct fobj_sec_mem *f = to_sec_mem(fobj);

	assert(refcount_val(&fobj->refc));
 1118568:	35000141 	cbnz	w1, 1118590 <sec_mem_get_pa+0x58>
 111856c:	b00001e3 	adrp	x3, 1155000 <__func__.3826+0xa8>
 1118570:	b00001e1 	adrp	x1, 1155000 <__func__.3826+0xa8>
 1118574:	b00001e0 	adrp	x0, 1155000 <__func__.3826+0xa8>
 1118578:	91080463 	add	x3, x3, #0x201
 111857c:	91062821 	add	x1, x1, #0x18a
 1118580:	91073c00 	add	x0, x0, #0x1cf
 1118584:	52806162 	mov	w2, #0x30b                 	// #779
	assert(page_idx < fobj->num_pages);
 1118588:	97ffe749 	bl	11122ac <_assert_log>
 111858c:	97ffe759 	bl	11122f0 <_assert_break>
 1118590:	b9400801 	ldr	w1, [x0, #8]
 1118594:	6b13003f 	cmp	w1, w19
 1118598:	54000128 	b.hi	11185bc <sec_mem_get_pa+0x84>  // b.pmore
 111859c:	b00001e3 	adrp	x3, 1155000 <__func__.3826+0xa8>
 11185a0:	b00001e1 	adrp	x1, 1155000 <__func__.3826+0xa8>
 11185a4:	b00001e0 	adrp	x0, 1155000 <__func__.3826+0xa8>
 11185a8:	91080463 	add	x3, x3, #0x201
 11185ac:	91062821 	add	x1, x1, #0x18a
 11185b0:	9106cc00 	add	x0, x0, #0x1b3
 11185b4:	52806182 	mov	w2, #0x30c                 	// #780
 11185b8:	17fffff4 	b	1118588 <sec_mem_get_pa+0x50>

	return tee_mm_get_smem(f->mm) + page_idx * SMALL_PAGE_SIZE;
 11185bc:	f85f8000 	ldur	x0, [x0, #-8]
 11185c0:	53144e73 	lsl	w19, w19, #12
 11185c4:	97ffcd32 	bl	110ba8c <tee_mm_get_smem>
}
 11185c8:	8b000260 	add	x0, x19, x0
 11185cc:	f9400bf3 	ldr	x19, [sp, #16]
 11185d0:	a8c27bfd 	ldp	x29, x30, [sp], #32
 11185d4:	d65f03c0 	ret

00000000011185d8 <sec_mem_free>:
{
 11185d8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	assert(fobj->ops == &ops_sec_mem);
 11185dc:	d00001a1 	adrp	x1, 114e000 <ldelf_data+0x8000>
 11185e0:	910ac021 	add	x1, x1, #0x2b0
{
 11185e4:	910003fd 	mov	x29, sp
	assert(fobj->ops == &ops_sec_mem);
 11185e8:	f9400002 	ldr	x2, [x0]
{
 11185ec:	f9000bf3 	str	x19, [sp, #16]
	assert(fobj->ops == &ops_sec_mem);
 11185f0:	eb01005f 	cmp	x2, x1
 11185f4:	54000040 	b.eq	11185fc <sec_mem_free+0x24>  // b.none
 11185f8:	97ffffc5 	bl	111850c <to_sec_mem.part.0>
	return container_of(fobj, struct fobj_sec_mem, fobj);
 11185fc:	d1002013 	sub	x19, x0, #0x8
 1118600:	91003001 	add	x1, x0, #0xc
 1118604:	b9400021 	ldr	w1, [x1]
	assert(!refcount_val(&fobj->refc));
 1118608:	34000141 	cbz	w1, 1118630 <sec_mem_free+0x58>
 111860c:	b00001e3 	adrp	x3, 1155000 <__func__.3826+0xa8>
 1118610:	b00001e1 	adrp	x1, 1155000 <__func__.3826+0xa8>
 1118614:	9107d063 	add	x3, x3, #0x1f4
 1118618:	91062821 	add	x1, x1, #0x18a
 111861c:	b00001e0 	adrp	x0, 1155000 <__func__.3826+0xa8>
 1118620:	91073800 	add	x0, x0, #0x1ce
 1118624:	52806042 	mov	w2, #0x302                 	// #770
 1118628:	97ffe721 	bl	11122ac <_assert_log>
 111862c:	97ffe731 	bl	11122f0 <_assert_break>
	tee_mm_free(f->mm);
 1118630:	f85f8000 	ldur	x0, [x0, #-8]
 1118634:	97ffccba 	bl	110b91c <tee_mm_free>
	free(f);
 1118638:	aa1303e0 	mov	x0, x19
}
 111863c:	f9400bf3 	ldr	x19, [sp, #16]
 1118640:	a8c27bfd 	ldp	x29, x30, [sp], #32
	free(f);
 1118644:	1400abe7 	b	11435e0 <free>

0000000001118648 <fobj_sec_mem_alloc>:
{
 1118648:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	struct fobj_sec_mem *f = calloc(1, sizeof(*f));
 111864c:	d2800301 	mov	x1, #0x18                  	// #24
{
 1118650:	910003fd 	mov	x29, sp
 1118654:	a90153f3 	stp	x19, x20, [sp, #16]
 1118658:	2a0003f4 	mov	w20, w0
	struct fobj_sec_mem *f = calloc(1, sizeof(*f));
 111865c:	d2800020 	mov	x0, #0x1                   	// #1
{
 1118660:	f90013f5 	str	x21, [sp, #32]
	struct fobj_sec_mem *f = calloc(1, sizeof(*f));
 1118664:	9400ab9b 	bl	11434d0 <calloc>
 1118668:	aa0003f3 	mov	x19, x0
	if (!f)
 111866c:	b40002e0 	cbz	x0, 11186c8 <fobj_sec_mem_alloc+0x80>
	f->mm = tee_mm_alloc(&tee_mm_sec_ddr, size);
 1118670:	d0000200 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
	if (MUL_OVERFLOW(num_pages, SMALL_PAGE_SIZE, &size))
 1118674:	d3747e95 	ubfiz	x21, x20, #12, #32
	f->mm = tee_mm_alloc(&tee_mm_sec_ddr, size);
 1118678:	aa1503e1 	mov	x1, x21
 111867c:	f9415000 	ldr	x0, [x0, #672]
 1118680:	97ffcc38 	bl	110b760 <tee_mm_alloc>
 1118684:	f9000260 	str	x0, [x19]
	if (!f->mm)
 1118688:	b40002a0 	cbz	x0, 11186dc <fobj_sec_mem_alloc+0x94>
	va = phys_to_virt(tee_mm_get_smem(f->mm), MEM_AREA_TA_RAM);
 111868c:	97ffcd00 	bl	110ba8c <tee_mm_get_smem>
 1118690:	52800121 	mov	w1, #0x9                   	// #9
 1118694:	97ffc828 	bl	110a734 <phys_to_virt>
	if (!va)
 1118698:	b4000220 	cbz	x0, 11186dc <fobj_sec_mem_alloc+0x94>
	memset(va, 0, size);
 111869c:	aa1503e2 	mov	x2, x21
 11186a0:	52800001 	mov	w1, #0x0                   	// #0
 11186a4:	9400ad8f 	bl	1143ce0 <memset>
	f->fobj.num_pages = num_pages;
 11186a8:	b9001274 	str	w20, [x19, #16]
	f->fobj.ops = &ops_sec_mem;
 11186ac:	d00001a0 	adrp	x0, 114e000 <ldelf_data+0x8000>
 11186b0:	910ac000 	add	x0, x0, #0x2b0
 11186b4:	f9000660 	str	x0, [x19, #8]
	__compiler_atomic_store(p, val);
 11186b8:	52800021 	mov	w1, #0x1                   	// #1
 11186bc:	91005260 	add	x0, x19, #0x14
 11186c0:	b9000001 	str	w1, [x0]
	return &f->fobj;
 11186c4:	91002273 	add	x19, x19, #0x8
}
 11186c8:	aa1303e0 	mov	x0, x19
 11186cc:	a94153f3 	ldp	x19, x20, [sp, #16]
 11186d0:	f94013f5 	ldr	x21, [sp, #32]
 11186d4:	a8c37bfd 	ldp	x29, x30, [sp], #48
 11186d8:	d65f03c0 	ret
	tee_mm_free(f->mm);
 11186dc:	f9400260 	ldr	x0, [x19]
 11186e0:	97ffcc8f 	bl	110b91c <tee_mm_free>
	free(f);
 11186e4:	aa1303e0 	mov	x0, x19
	return NULL;
 11186e8:	d2800013 	mov	x19, #0x0                   	// #0
	free(f);
 11186ec:	9400abbd 	bl	11435e0 <free>
	return NULL;
 11186f0:	17fffff6 	b	11186c8 <fobj_sec_mem_alloc+0x80>

00000000011186f4 <fobj_put>:
	if (fobj && refcount_dec(&fobj->refc))
 11186f4:	b4000260 	cbz	x0, 1118740 <fobj_put+0x4c>
{
 11186f8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 11186fc:	910003fd 	mov	x29, sp
 1118700:	f9000bf3 	str	x19, [sp, #16]
 1118704:	aa0003f3 	mov	x19, x0
	if (fobj && refcount_dec(&fobj->refc))
 1118708:	91003000 	add	x0, x0, #0xc
 111870c:	97ffeba8 	bl	11135ac <refcount_dec>
 1118710:	72001c1f 	tst	w0, #0xff
 1118714:	54000100 	b.eq	1118734 <fobj_put+0x40>  // b.none
		fobj->ops->free(fobj);
 1118718:	f9400260 	ldr	x0, [x19]
 111871c:	f9400001 	ldr	x1, [x0]
 1118720:	aa1303e0 	mov	x0, x19
}
 1118724:	f9400bf3 	ldr	x19, [sp, #16]
		fobj->ops->free(fobj);
 1118728:	aa0103f0 	mov	x16, x1
}
 111872c:	a8c27bfd 	ldp	x29, x30, [sp], #32
		fobj->ops->free(fobj);
 1118730:	d61f0200 	br	x16
}
 1118734:	f9400bf3 	ldr	x19, [sp, #16]
 1118738:	a8c27bfd 	ldp	x29, x30, [sp], #32
 111873c:	d65f03c0 	ret
 1118740:	d65f03c0 	ret

0000000001118744 <file_get>:

	return TEE_SUCCESS;
}

struct file *file_get(struct file *f)
{
 1118744:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1118748:	910003fd 	mov	x29, sp
 111874c:	f9000bf3 	str	x19, [sp, #16]
 1118750:	aa0003f3 	mov	x19, x0
	if (f && !refcount_inc(&f->refc))
 1118754:	b4000180 	cbz	x0, 1118784 <file_get+0x40>
 1118758:	91009000 	add	x0, x0, #0x24
 111875c:	97ffeb86 	bl	1113574 <refcount_inc>
 1118760:	72001c1f 	tst	w0, #0xff
 1118764:	54000101 	b.ne	1118784 <file_get+0x40>  // b.any
		panic();
 1118768:	b00001e2 	adrp	x2, 1155000 <__func__.3826+0xa8>
 111876c:	b00001e0 	adrp	x0, 1155000 <__func__.3826+0xa8>
 1118770:	9108d042 	add	x2, x2, #0x234
 1118774:	91084000 	add	x0, x0, #0x210
 1118778:	d2800003 	mov	x3, #0x0                   	// #0
 111877c:	52800e01 	mov	w1, #0x70                  	// #112
 1118780:	97ffeb3a 	bl	1113468 <__do_panic>

	return f;
}
 1118784:	aa1303e0 	mov	x0, x19
 1118788:	f9400bf3 	ldr	x19, [sp, #16]
 111878c:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1118790:	d65f03c0 	ret

0000000001118794 <file_get_by_tag>:

struct file *file_get_by_tag(const uint8_t *tag, unsigned int taglen)
{
 1118794:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
	struct file *f = NULL;

	if (taglen > sizeof(f->tag))
 1118798:	7100803f 	cmp	w1, #0x20
{
 111879c:	910003fd 	mov	x29, sp
 11187a0:	a90153f3 	stp	x19, x20, [sp, #16]
 11187a4:	a9025bf5 	stp	x21, x22, [sp, #32]
 11187a8:	a90363f7 	stp	x23, x24, [sp, #48]
	if (taglen > sizeof(f->tag))
 11187ac:	540006c8 	b.hi	1118884 <file_get_by_tag+0xf0>  // b.pmore
	TAILQ_FOREACH(f, &file_head, link)
 11187b0:	f0000215 	adrp	x21, 115b000 <__vcore_unpg_rw_start>
 11187b4:	2a0103f4 	mov	w20, w1
		return NULL;

	mutex_lock(&file_mu);
 11187b8:	aa0003f6 	mov	x22, x0
 11187bc:	d0000237 	adrp	x23, 115e000 <state+0x80>
 11187c0:	910522e0 	add	x0, x23, #0x148
 11187c4:	97fff364 	bl	1115554 <mutex_lock>
	TAILQ_FOREACH(f, &file_head, link)
 11187c8:	f94422b3 	ldr	x19, [x21, #2112]
	return memcmp(tag, f->tag, taglen);
 11187cc:	2a1403f8 	mov	w24, w20
	TAILQ_FOREACH(f, &file_head, link)
 11187d0:	b5000433 	cbnz	x19, 1118854 <file_get_by_tag+0xc0>
	 */
	f = file_find_tag_unlocked(tag, taglen);
	if (f && refcount_inc(&f->refc))
		goto out;

	f = calloc(1, sizeof(*f));
 11187d4:	d2800b01 	mov	x1, #0x58                  	// #88
 11187d8:	d2800020 	mov	x0, #0x1                   	// #1
 11187dc:	9400ab3d 	bl	11434d0 <calloc>
 11187e0:	aa0003f3 	mov	x19, x0
	if (!f)
 11187e4:	b4000280 	cbz	x0, 1118834 <file_get_by_tag+0xa0>
		goto out;
	memcpy(f->tag, tag, taglen);
 11187e8:	aa1603e1 	mov	x1, x22
 11187ec:	2a1403e2 	mov	w2, w20
 11187f0:	97ffaae8 	bl	1103390 <memcpy>
	f->taglen = taglen;
 11187f4:	b9002274 	str	w20, [x19, #32]
 11187f8:	91009260 	add	x0, x19, #0x24
 11187fc:	52800021 	mov	w1, #0x1                   	// #1
 1118800:	b9000001 	str	w1, [x0]
	refcount_set(&f->refc, 1);
	mutex_init(&f->mu);
 1118804:	9100e260 	add	x0, x19, #0x38
 1118808:	97fff32a 	bl	11154b0 <mutex_init>
	SLIST_INIT(&f->slice_head);
 111880c:	f9002a7f 	str	xzr, [x19, #80]
	TAILQ_INSERT_HEAD(&file_head, f, link);
 1118810:	aa1303e0 	mov	x0, x19
 1118814:	912102a2 	add	x2, x21, #0x840
 1118818:	f94422a1 	ldr	x1, [x21, #2112]
 111881c:	f8028c01 	str	x1, [x0, #40]!
 1118820:	b40002e1 	cbz	x1, 111887c <file_get_by_tag+0xe8>
 1118824:	f9001820 	str	x0, [x1, #48]
 1118828:	912102a0 	add	x0, x21, #0x840
 111882c:	f90422b3 	str	x19, [x21, #2112]
 1118830:	f9001a60 	str	x0, [x19, #48]

out:
	mutex_unlock(&file_mu);
 1118834:	910522e0 	add	x0, x23, #0x148
 1118838:	97fff326 	bl	11154d0 <mutex_unlock>

	return f;
}
 111883c:	aa1303e0 	mov	x0, x19
 1118840:	a94153f3 	ldp	x19, x20, [sp, #16]
 1118844:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1118848:	a94363f7 	ldp	x23, x24, [sp, #48]
 111884c:	a8c47bfd 	ldp	x29, x30, [sp], #64
 1118850:	d65f03c0 	ret
	if (f->taglen != taglen)
 1118854:	b9402260 	ldr	w0, [x19, #32]
 1118858:	6b00029f 	cmp	w20, w0
 111885c:	540000c1 	b.ne	1118874 <file_get_by_tag+0xe0>  // b.any
	return memcmp(tag, f->tag, taglen);
 1118860:	aa1803e2 	mov	x2, x24
 1118864:	aa1303e1 	mov	x1, x19
 1118868:	aa1603e0 	mov	x0, x22
 111886c:	9400acf9 	bl	1143c50 <memcmp>
		if (!file_tag_cmp(f, tag, taglen))
 1118870:	340000e0 	cbz	w0, 111888c <file_get_by_tag+0xf8>
	TAILQ_FOREACH(f, &file_head, link)
 1118874:	f9401673 	ldr	x19, [x19, #40]
 1118878:	17ffffd6 	b	11187d0 <file_get_by_tag+0x3c>
	TAILQ_INSERT_HEAD(&file_head, f, link);
 111887c:	f9000440 	str	x0, [x2, #8]
 1118880:	17ffffea 	b	1118828 <file_get_by_tag+0x94>
		return NULL;
 1118884:	d2800013 	mov	x19, #0x0                   	// #0
 1118888:	17ffffed 	b	111883c <file_get_by_tag+0xa8>
	if (f && refcount_inc(&f->refc))
 111888c:	91009260 	add	x0, x19, #0x24
 1118890:	97ffeb39 	bl	1113574 <refcount_inc>
 1118894:	72001c1f 	tst	w0, #0xff
 1118898:	54fff9e0 	b.eq	11187d4 <file_get_by_tag+0x40>  // b.none
 111889c:	17ffffe6 	b	1118834 <file_get_by_tag+0xa0>

00000000011188a0 <file_put>:

void file_put(struct file *f)
{
	if (f && refcount_dec(&f->refc)) {
 11188a0:	b4000500 	cbz	x0, 1118940 <file_put+0xa0>
{
 11188a4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 11188a8:	910003fd 	mov	x29, sp
 11188ac:	a90153f3 	stp	x19, x20, [sp, #16]
 11188b0:	aa0003f3 	mov	x19, x0
	if (f && refcount_dec(&f->refc)) {
 11188b4:	91009000 	add	x0, x0, #0x24
 11188b8:	97ffeb3d 	bl	11135ac <refcount_dec>
 11188bc:	72001c1f 	tst	w0, #0xff
 11188c0:	540003a0 	b.eq	1118934 <file_put+0x94>  // b.none
		mutex_lock(&file_mu);
 11188c4:	d0000234 	adrp	x20, 115e000 <state+0x80>
 11188c8:	91052280 	add	x0, x20, #0x148
 11188cc:	97fff322 	bl	1115554 <mutex_lock>
		TAILQ_REMOVE(&file_head, f, link);
 11188d0:	a9428660 	ldp	x0, x1, [x19, #40]
 11188d4:	b40001c0 	cbz	x0, 111890c <file_put+0x6c>
 11188d8:	f9001801 	str	x1, [x0, #48]
 11188dc:	f9401a61 	ldr	x1, [x19, #48]
 11188e0:	f9000020 	str	x0, [x1]
		mutex_unlock(&file_mu);
 11188e4:	91052280 	add	x0, x20, #0x148
 11188e8:	97fff2fa 	bl	11154d0 <mutex_unlock>
	mutex_destroy(&f->mu);
 11188ec:	9100e260 	add	x0, x19, #0x38
 11188f0:	97fff3ec 	bl	11158a0 <mutex_destroy>
	while (!SLIST_EMPTY(&f->slice_head)) {
 11188f4:	f9402a74 	ldr	x20, [x19, #80]
 11188f8:	b5000114 	cbnz	x20, 1118918 <file_put+0x78>
	free(f);
 11188fc:	aa1303e0 	mov	x0, x19

		file_free(f);
	}

}
 1118900:	a94153f3 	ldp	x19, x20, [sp, #16]
 1118904:	a8c27bfd 	ldp	x29, x30, [sp], #32
	free(f);
 1118908:	1400ab36 	b	11435e0 <free>
		TAILQ_REMOVE(&file_head, f, link);
 111890c:	f0000202 	adrp	x2, 115b000 <__vcore_unpg_rw_start>
 1118910:	f9042441 	str	x1, [x2, #2120]
 1118914:	17fffff2 	b	11188dc <file_put+0x3c>
		SLIST_REMOVE_HEAD(&f->slice_head, link);
 1118918:	f9400a80 	ldr	x0, [x20, #16]
 111891c:	f9002a60 	str	x0, [x19, #80]
		fobj_put(fse->slice.fobj);
 1118920:	f9400280 	ldr	x0, [x20]
 1118924:	97ffff74 	bl	11186f4 <fobj_put>
		free(fse);
 1118928:	aa1403e0 	mov	x0, x20
 111892c:	9400ab2d 	bl	11435e0 <free>
 1118930:	17fffff1 	b	11188f4 <file_put+0x54>
}
 1118934:	a94153f3 	ldp	x19, x20, [sp, #16]
 1118938:	a8c27bfd 	ldp	x29, x30, [sp], #32
 111893c:	d65f03c0 	ret
 1118940:	d65f03c0 	ret

0000000001118944 <file_find_slice>:

struct file_slice *file_find_slice(struct file *f, unsigned int page_offset)
{
	struct file_slice_elem *fse = NULL;

	assert(f->mu.state);
 1118944:	79c09002 	ldrsh	w2, [x0, #72]
 1118948:	35000182 	cbnz	w2, 1118978 <file_find_slice+0x34>
 111894c:	b00001e3 	adrp	x3, 1155000 <__func__.3826+0xa8>
 1118950:	b00001e1 	adrp	x1, 1155000 <__func__.3826+0xa8>
 1118954:	9108f463 	add	x3, x3, #0x23d
 1118958:	91084021 	add	x1, x1, #0x210
 111895c:	b00001e0 	adrp	x0, 1155000 <__func__.3826+0xa8>
 1118960:	91087c00 	add	x0, x0, #0x21f
{
 1118964:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	assert(f->mu.state);
 1118968:	528016e2 	mov	w2, #0xb7                  	// #183
{
 111896c:	910003fd 	mov	x29, sp
	assert(f->mu.state);
 1118970:	97ffe64f 	bl	11122ac <_assert_log>
 1118974:	97ffe65f 	bl	11122f0 <_assert_break>

	SLIST_FOREACH(fse, &f->slice_head, link) {
 1118978:	f9402800 	ldr	x0, [x0, #80]
 111897c:	b5000040 	cbnz	x0, 1118984 <file_find_slice+0x40>
		    page_offset < fs->page_offset + fs->fobj->num_pages)
			return fs;
	}

	return NULL;
}
 1118980:	d65f03c0 	ret
		if (page_offset >= fs->page_offset &&
 1118984:	b9400802 	ldr	w2, [x0, #8]
 1118988:	6b01005f 	cmp	w2, w1
 111898c:	540000c8 	b.hi	11189a4 <file_find_slice+0x60>  // b.pmore
		    page_offset < fs->page_offset + fs->fobj->num_pages)
 1118990:	f9400003 	ldr	x3, [x0]
 1118994:	b9400863 	ldr	w3, [x3, #8]
 1118998:	0b030042 	add	w2, w2, w3
		if (page_offset >= fs->page_offset &&
 111899c:	6b01005f 	cmp	w2, w1
 11189a0:	54ffff08 	b.hi	1118980 <file_find_slice+0x3c>  // b.pmore
	SLIST_FOREACH(fse, &f->slice_head, link) {
 11189a4:	f9400800 	ldr	x0, [x0, #16]
 11189a8:	17fffff5 	b	111897c <file_find_slice+0x38>

00000000011189ac <file_add_slice>:
{
 11189ac:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 11189b0:	910003fd 	mov	x29, sp
 11189b4:	a90153f3 	stp	x19, x20, [sp, #16]
 11189b8:	aa0103f4 	mov	x20, x1
	if (file_find_slice(f, page_offset))
 11189bc:	2a0203e1 	mov	w1, w2
{
 11189c0:	a9025bf5 	stp	x21, x22, [sp, #32]
 11189c4:	aa0003f6 	mov	x22, x0
 11189c8:	2a0203f5 	mov	w21, w2
	if (file_find_slice(f, page_offset))
 11189cc:	97ffffde 	bl	1118944 <file_find_slice>
 11189d0:	b5000380 	cbnz	x0, 1118a40 <file_add_slice+0x94>
	fse = calloc(1, sizeof(*fse));
 11189d4:	d2800301 	mov	x1, #0x18                  	// #24
 11189d8:	d2800020 	mov	x0, #0x1                   	// #1
 11189dc:	9400aabd 	bl	11434d0 <calloc>
 11189e0:	aa0003f3 	mov	x19, x0
	if (!fse)
 11189e4:	b4000420 	cbz	x0, 1118a68 <file_add_slice+0xbc>
	if (fobj && !refcount_inc(&fobj->refc))
 11189e8:	b4000194 	cbz	x20, 1118a18 <file_add_slice+0x6c>
 11189ec:	91003280 	add	x0, x20, #0xc
 11189f0:	97ffeae1 	bl	1113574 <refcount_inc>
 11189f4:	72001c1f 	tst	w0, #0xff
 11189f8:	54000101 	b.ne	1118a18 <file_add_slice+0x6c>  // b.any
		panic();
 11189fc:	b00001e2 	adrp	x2, 1155000 <__func__.3826+0xa8>
 1118a00:	b00001e0 	adrp	x0, 1155000 <__func__.3826+0xa8>
 1118a04:	9108ac42 	add	x2, x2, #0x22b
 1118a08:	91011c00 	add	x0, x0, #0x47
 1118a0c:	d2800003 	mov	x3, #0x0                   	// #0
 1118a10:	52801781 	mov	w1, #0xbc                  	// #188
 1118a14:	97ffea95 	bl	1113468 <__do_panic>
	fse->slice.fobj = fobj_get(fobj);
 1118a18:	f9000274 	str	x20, [x19]
	if (!fse->slice.fobj ||
 1118a1c:	b40000b4 	cbz	x20, 1118a30 <file_add_slice+0x84>
	    ADD_OVERFLOW(page_offset, fse->slice.fobj->num_pages, &s)) {
 1118a20:	b9400a80 	ldr	w0, [x20, #8]
 1118a24:	2b0002a0 	adds	w0, w21, w0
 1118a28:	1a9f37e0 	cset	w0, cs  // cs = hs, nlast
	if (!fse->slice.fobj ||
 1118a2c:	540000e3 	b.cc	1118a48 <file_add_slice+0x9c>  // b.lo, b.ul, b.last
		fobj_put(fse->slice.fobj);
 1118a30:	aa1403e0 	mov	x0, x20
 1118a34:	97ffff30 	bl	11186f4 <fobj_put>
		free(fse);
 1118a38:	aa1303e0 	mov	x0, x19
 1118a3c:	9400aae9 	bl	11435e0 <free>
		return TEE_ERROR_BAD_PARAMETERS;
 1118a40:	129fff20 	mov	w0, #0xffff0006            	// #-65530
 1118a44:	14000005 	b	1118a58 <file_add_slice+0xac>
	SLIST_INSERT_HEAD(&f->slice_head, fse, link);
 1118a48:	f9402ac1 	ldr	x1, [x22, #80]
	fse->slice.page_offset = page_offset;
 1118a4c:	b9000a75 	str	w21, [x19, #8]
	SLIST_INSERT_HEAD(&f->slice_head, fse, link);
 1118a50:	f9000a61 	str	x1, [x19, #16]
 1118a54:	f9002ad3 	str	x19, [x22, #80]
}
 1118a58:	a94153f3 	ldp	x19, x20, [sp, #16]
 1118a5c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1118a60:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1118a64:	d65f03c0 	ret
		return TEE_ERROR_OUT_OF_MEMORY;
 1118a68:	129ffe60 	mov	w0, #0xffff000c            	// #-65524
 1118a6c:	17fffffb 	b	1118a58 <file_add_slice+0xac>

0000000001118a70 <file_lock>:

void file_lock(struct file *f)
{
	mutex_lock(&f->mu);
 1118a70:	9100e000 	add	x0, x0, #0x38
 1118a74:	17fff2b8 	b	1115554 <mutex_lock>

0000000001118a78 <file_trylock>:
}

bool file_trylock(struct file *f)
{
	return mutex_trylock(&f->mu);
 1118a78:	9100e000 	add	x0, x0, #0x38
 1118a7c:	17fff2f0 	b	111563c <mutex_trylock>

0000000001118a80 <file_unlock>:
}

void file_unlock(struct file *f)
{
	mutex_unlock(&f->mu);
 1118a80:	9100e000 	add	x0, x0, #0x38
 1118a84:	17fff293 	b	11154d0 <mutex_unlock>

0000000001118a88 <mobj_get_pa>:
	if (mobj && mobj->ops && mobj->ops->get_pa)
 1118a88:	b40000e0 	cbz	x0, 1118aa4 <mobj_get_pa+0x1c>
 1118a8c:	f9400004 	ldr	x4, [x0]
 1118a90:	b40000a4 	cbz	x4, 1118aa4 <mobj_get_pa+0x1c>
 1118a94:	f9400484 	ldr	x4, [x4, #8]
 1118a98:	b4000064 	cbz	x4, 1118aa4 <mobj_get_pa+0x1c>
		return mobj->ops->get_pa(mobj, offs, granule, pa);
 1118a9c:	aa0403f0 	mov	x16, x4
 1118aa0:	d61f0200 	br	x16
}
 1118aa4:	52bfffe0 	mov	w0, #0xffff0000            	// #-65536
 1118aa8:	d65f03c0 	ret

0000000001118aac <va_range_is_contiguous>:
static bool va_range_is_contiguous(struct vm_region *r0, vaddr_t va,
				   size_t len,
				   bool (*cmp_regs)(const struct vm_region *r0,
						    const struct vm_region *r,
						    const struct vm_region *rn))
{
 1118aac:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1118ab0:	910003fd 	mov	x29, sp
 1118ab4:	a90153f3 	stp	x19, x20, [sp, #16]
	struct vm_region *r = r0;
	vaddr_t end_va = 0;

	if (ADD_OVERFLOW(va, len, &end_va))
 1118ab8:	ab020033 	adds	x19, x1, x2
{
 1118abc:	a9025bf5 	stp	x21, x22, [sp, #32]
	if (ADD_OVERFLOW(va, len, &end_va))
 1118ac0:	54000262 	b.cs	1118b0c <va_range_is_contiguous+0x60>  // b.hs, b.nlast
 1118ac4:	aa0003f5 	mov	x21, x0
 1118ac8:	aa0303f4 	mov	x20, x3
	struct vm_region *r = r0;
 1118acc:	aa0003e1 	mov	x1, x0
		return false;

	while (true) {
		struct vm_region *r_next = TAILQ_NEXT(r, link);
		vaddr_t r_end_va = r->va + r->size;
 1118ad0:	a9410820 	ldp	x0, x2, [x1, #16]
		struct vm_region *r_next = TAILQ_NEXT(r, link);
 1118ad4:	f9401436 	ldr	x22, [x1, #40]
		vaddr_t r_end_va = r->va + r->size;
 1118ad8:	8b020000 	add	x0, x0, x2

		if (r_end_va >= end_va)
 1118adc:	eb00027f 	cmp	x19, x0
 1118ae0:	54000249 	b.ls	1118b28 <va_range_is_contiguous+0x7c>  // b.plast
			return true;
		if (!r_next)
 1118ae4:	b4000156 	cbz	x22, 1118b0c <va_range_is_contiguous+0x60>
			return false;
		if (r_end_va != r_next->va)
 1118ae8:	f9400ac2 	ldr	x2, [x22, #16]
 1118aec:	eb00005f 	cmp	x2, x0
 1118af0:	540000e1 	b.ne	1118b0c <va_range_is_contiguous+0x60>  // b.any
			return false;
		if (cmp_regs && !cmp_regs(r0, r, r_next))
 1118af4:	b4000174 	cbz	x20, 1118b20 <va_range_is_contiguous+0x74>
 1118af8:	aa1603e2 	mov	x2, x22
 1118afc:	aa1503e0 	mov	x0, x21
 1118b00:	d63f0280 	blr	x20
 1118b04:	72001c1f 	tst	w0, #0xff
 1118b08:	540000c1 	b.ne	1118b20 <va_range_is_contiguous+0x74>  // b.any
		return false;
 1118b0c:	52800000 	mov	w0, #0x0                   	// #0
			return false;
		r = r_next;
	}
}
 1118b10:	a94153f3 	ldp	x19, x20, [sp, #16]
 1118b14:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1118b18:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1118b1c:	d65f03c0 	ret
{
 1118b20:	aa1603e1 	mov	x1, x22
 1118b24:	17ffffeb 	b	1118ad0 <va_range_is_contiguous+0x24>
			return true;
 1118b28:	52800020 	mov	w0, #0x1                   	// #1
 1118b2c:	17fffff9 	b	1118b10 <va_range_is_contiguous+0x64>

0000000001118b30 <cmp_region_for_remap>:
	 * contiguous.
	 *
	 * Note that vm_remap() depends on mobj/fobj to be the same.
	 */
	return r0->flags == r->flags && r0->attr == r->attr &&
	       r0->mobj == r->mobj && rn->offset == r->offset + r->size;
 1118b30:	b9402004 	ldr	w4, [x0, #32]
 1118b34:	b9402023 	ldr	w3, [x1, #32]
 1118b38:	6b03009f 	cmp	w4, w3
 1118b3c:	54000181 	b.ne	1118b6c <cmp_region_for_remap+0x3c>  // b.any
	return r0->flags == r->flags && r0->attr == r->attr &&
 1118b40:	f9400003 	ldr	x3, [x0]
 1118b44:	f9400020 	ldr	x0, [x1]
 1118b48:	eb00007f 	cmp	x3, x0
 1118b4c:	54000101 	b.ne	1118b6c <cmp_region_for_remap+0x3c>  // b.any
	       r0->mobj == r->mobj && rn->offset == r->offset + r->size;
 1118b50:	f9400420 	ldr	x0, [x1, #8]
 1118b54:	f9400c21 	ldr	x1, [x1, #24]
 1118b58:	8b010000 	add	x0, x0, x1
 1118b5c:	f9400441 	ldr	x1, [x2, #8]
 1118b60:	eb01001f 	cmp	x0, x1
 1118b64:	1a9f17e0 	cset	w0, eq  // eq = none
}
 1118b68:	d65f03c0 	ret
	       r0->mobj == r->mobj && rn->offset == r->offset + r->size;
 1118b6c:	52800000 	mov	w0, #0x0                   	// #0
 1118b70:	17fffffe 	b	1118b68 <cmp_region_for_remap+0x38>

0000000001118b74 <cmp_region_for_get_flags>:

static bool cmp_region_for_get_flags(const struct vm_region *r0,
				     const struct vm_region *r,
				     const struct vm_region *rn __unused)
{
	return r0->flags == r->flags;
 1118b74:	79404402 	ldrh	w2, [x0, #34]
 1118b78:	79404420 	ldrh	w0, [x1, #34]
 1118b7c:	6b00005f 	cmp	w2, w0
}
 1118b80:	1a9f17e0 	cset	w0, eq  // eq = none
 1118b84:	d65f03c0 	ret

0000000001118b88 <select_va_in_range>:
	if (prev_reg->flags && (prev_reg->flags & f) != (reg->flags & f))
 1118b88:	79404406 	ldrh	w6, [x0, #34]
 1118b8c:	340004e6 	cbz	w6, 1118c28 <select_va_in_range+0xa0>
 1118b90:	79404447 	ldrh	w7, [x2, #34]
 1118b94:	4a0700c6 	eor	w6, w6, w7
		pad = SMALL_PAGE_SIZE;
 1118b98:	f24008df 	tst	x6, #0x7
 1118b9c:	9a9f07e7 	cset	x7, ne  // ne = any
 1118ba0:	d374cce7 	lsl	x7, x7, #12
	if (ADD_OVERFLOW(prev_reg->va, prev_reg->size, &begin_va) ||
 1118ba4:	a9410006 	ldp	x6, x0, [x0, #16]
 1118ba8:	ab0000c6 	adds	x6, x6, x0
 1118bac:	9a9f37e0 	cset	x0, cs  // cs = hs, nlast
 1118bb0:	54000382 	b.cs	1118c20 <select_va_in_range+0x98>  // b.hs, b.nlast
	    ADD_OVERFLOW(begin_va, pad_begin, &begin_va) ||
 1118bb4:	ab0300c3 	adds	x3, x6, x3
 1118bb8:	54000362 	b.cs	1118c24 <select_va_in_range+0x9c>  // b.hs, b.nlast
	    ADD_OVERFLOW(begin_va, pad, &begin_va) ||
 1118bbc:	ab070063 	adds	x3, x3, x7
 1118bc0:	54000322 	b.cs	1118c24 <select_va_in_range+0x9c>  // b.hs, b.nlast
 1118bc4:	aa0303e0 	mov	x0, x3
	    ROUNDUP_OVERFLOW(begin_va, granul, &begin_va))
 1118bc8:	d10004a3 	sub	x3, x5, #0x1
 1118bcc:	ab030006 	adds	x6, x0, x3
 1118bd0:	54000062 	b.cs	1118bdc <select_va_in_range+0x54>  // b.hs, b.nlast
 1118bd4:	cb0503e0 	neg	x0, x5
 1118bd8:	8a060000 	and	x0, x0, x6
	if (reg->va) {
 1118bdc:	f9400846 	ldr	x6, [x2, #16]
 1118be0:	b4000086 	cbz	x6, 1118bf0 <select_va_in_range+0x68>
		if (reg->va < begin_va)
 1118be4:	eb0000df 	cmp	x6, x0
 1118be8:	540001c3 	b.cc	1118c20 <select_va_in_range+0x98>  // b.lo, b.ul, b.last
 1118bec:	aa0603e0 	mov	x0, x6
	if (next_reg->flags && (next_reg->flags & f) != (reg->flags & f))
 1118bf0:	79404427 	ldrh	w7, [x1, #34]
 1118bf4:	340001e7 	cbz	w7, 1118c30 <select_va_in_range+0xa8>
 1118bf8:	79404448 	ldrh	w8, [x2, #34]
 1118bfc:	4a0800e7 	eor	w7, w7, w8
		pad = SMALL_PAGE_SIZE;
 1118c00:	f24008ff 	tst	x7, #0x7
 1118c04:	9a9f07e7 	cset	x7, ne  // ne = any
 1118c08:	d374cce7 	lsl	x7, x7, #12
	if (ADD_OVERFLOW(begin_va, reg->size, &end_va) ||
 1118c0c:	f9400c42 	ldr	x2, [x2, #24]
 1118c10:	ab020002 	adds	x2, x0, x2
 1118c14:	54000062 	b.cs	1118c20 <select_va_in_range+0x98>  // b.hs, b.nlast
	    ADD_OVERFLOW(end_va, pad_end, &end_va) ||
 1118c18:	ab040042 	adds	x2, x2, x4
 1118c1c:	540000e3 	b.cc	1118c38 <select_va_in_range+0xb0>  // b.lo, b.ul, b.last
		return 0;
 1118c20:	d2800000 	mov	x0, #0x0                   	// #0
}
 1118c24:	d65f03c0 	ret
		pad = 0;
 1118c28:	d2800007 	mov	x7, #0x0                   	// #0
 1118c2c:	17ffffde 	b	1118ba4 <select_va_in_range+0x1c>
		pad = 0;
 1118c30:	d2800007 	mov	x7, #0x0                   	// #0
 1118c34:	17fffff6 	b	1118c0c <select_va_in_range+0x84>
	    ADD_OVERFLOW(end_va, pad, &end_va) ||
 1118c38:	ab070044 	adds	x4, x2, x7
 1118c3c:	54ffff22 	b.cs	1118c20 <select_va_in_range+0x98>  // b.hs, b.nlast
	    ROUNDUP_OVERFLOW(end_va, granul, &end_va))
 1118c40:	ab030083 	adds	x3, x4, x3
 1118c44:	54000243 	b.cc	1118c8c <select_va_in_range+0x104>  // b.lo, b.ul, b.last
	if (end_va <= next_reg->va) {
 1118c48:	f9400821 	ldr	x1, [x1, #16]
 1118c4c:	eb04003f 	cmp	x1, x4
 1118c50:	54fffe83 	b.cc	1118c20 <select_va_in_range+0x98>  // b.lo, b.ul, b.last
		assert(!reg->va || reg->va == begin_va);
 1118c54:	b4fffe86 	cbz	x6, 1118c24 <select_va_in_range+0x9c>
 1118c58:	eb0000df 	cmp	x6, x0
 1118c5c:	54fffe40 	b.eq	1118c24 <select_va_in_range+0x9c>  // b.none
 1118c60:	b00001e3 	adrp	x3, 1155000 <__func__.3826+0xa8>
 1118c64:	b00001e1 	adrp	x1, 1155000 <__func__.3826+0xa8>
 1118c68:	910db463 	add	x3, x3, #0x36d
 1118c6c:	91093421 	add	x1, x1, #0x24d
 1118c70:	b00001e0 	adrp	x0, 1155000 <__func__.3826+0xa8>
 1118c74:	91096800 	add	x0, x0, #0x25a
{
 1118c78:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
		assert(!reg->va || reg->va == begin_va);
 1118c7c:	52800d22 	mov	w2, #0x69                  	// #105
{
 1118c80:	910003fd 	mov	x29, sp
		assert(!reg->va || reg->va == begin_va);
 1118c84:	97ffe58a 	bl	11122ac <_assert_log>
 1118c88:	97ffe59a 	bl	11122f0 <_assert_break>
	    ROUNDUP_OVERFLOW(end_va, granul, &end_va))
 1118c8c:	cb0503e5 	neg	x5, x5
 1118c90:	8a0300a4 	and	x4, x5, x3
 1118c94:	17ffffed 	b	1118c48 <select_va_in_range+0xc0>

0000000001118c98 <umap_add_region>:
{
 1118c98:	a9b37bfd 	stp	x29, x30, [sp, #-208]!
 1118c9c:	910003fd 	mov	x29, sp
 1118ca0:	a90153f3 	stp	x19, x20, [sp, #16]
 1118ca4:	aa0103f3 	mov	x19, x1
 1118ca8:	aa0403f4 	mov	x20, x4
	core_mmu_get_user_va_range(&va_range_base, &va_range_size);
 1118cac:	910163e1 	add	x1, sp, #0x58
{
 1118cb0:	a9025bf5 	stp	x21, x22, [sp, #32]
 1118cb4:	aa030055 	orr	x21, x2, x3
 1118cb8:	aa0003f6 	mov	x22, x0
	core_mmu_get_user_va_range(&va_range_base, &va_range_size);
 1118cbc:	910143e0 	add	x0, sp, #0x50
{
 1118cc0:	a90363f7 	stp	x23, x24, [sp, #48]
 1118cc4:	aa0203f7 	mov	x23, x2
 1118cc8:	aa0303f8 	mov	x24, x3
 1118ccc:	f90023f9 	str	x25, [sp, #64]
	size_t va_range_size = 0;
 1118cd0:	a9057fff 	stp	xzr, xzr, [sp, #80]
	struct vm_region dummy_first_reg = { };
 1118cd4:	a9067fff 	stp	xzr, xzr, [sp, #96]
 1118cd8:	a9077fff 	stp	xzr, xzr, [sp, #112]
 1118cdc:	a9087fff 	stp	xzr, xzr, [sp, #128]
	struct vm_region dummy_last_reg = { };
 1118ce0:	a9097fff 	stp	xzr, xzr, [sp, #144]
 1118ce4:	a90a7fff 	stp	xzr, xzr, [sp, #160]
 1118ce8:	a90b7fff 	stp	xzr, xzr, [sp, #176]
 1118cec:	a90c7fff 	stp	xzr, xzr, [sp, #192]
	core_mmu_get_user_va_range(&va_range_base, &va_range_size);
 1118cf0:	97ffc8f8 	bl	110b0d0 <core_mmu_get_user_va_range>
	dummy_last_reg.va = va_range_base + va_range_size;
 1118cf4:	a94503e1 	ldp	x1, x0, [sp, #80]
	dummy_first_reg.va = va_range_base;
 1118cf8:	f9003be1 	str	x1, [sp, #112]
	if ((reg->va | reg->size | pad_begin | pad_end) & SMALL_PAGE_MASK)
 1118cfc:	f9400a62 	ldr	x2, [x19, #16]
	dummy_last_reg.va = va_range_base + va_range_size;
 1118d00:	8b010000 	add	x0, x0, x1
 1118d04:	f90057e0 	str	x0, [sp, #168]
	if ((reg->va | reg->size | pad_begin | pad_end) & SMALL_PAGE_MASK)
 1118d08:	f9400e61 	ldr	x1, [x19, #24]
 1118d0c:	aa020022 	orr	x2, x1, x2
 1118d10:	aa150042 	orr	x2, x2, x21
 1118d14:	f2402c5f 	tst	x2, #0xfff
 1118d18:	54000100 	b.eq	1118d38 <umap_add_region+0xa0>  // b.none
		return TEE_ERROR_ACCESS_CONFLICT;
 1118d1c:	129fff80 	mov	w0, #0xffff0003            	// #-65533
}
 1118d20:	a94153f3 	ldp	x19, x20, [sp, #16]
 1118d24:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1118d28:	a94363f7 	ldp	x23, x24, [sp, #48]
 1118d2c:	f94023f9 	ldr	x25, [sp, #64]
 1118d30:	a8cd7bfd 	ldp	x29, x30, [sp], #208
 1118d34:	d65f03c0 	ret
	if (ADD_OVERFLOW(reg->offset, reg->size, &offs_plus_size))
 1118d38:	f9400660 	ldr	x0, [x19, #8]
 1118d3c:	ab010001 	adds	x1, x0, x1
 1118d40:	540000e2 	b.cs	1118d5c <umap_add_region+0xc4>  // b.hs, b.nlast
	if (offs_plus_size > ROUNDUP(reg->mobj->size, SMALL_PAGE_SIZE))
 1118d44:	f9400260 	ldr	x0, [x19]
 1118d48:	f9400400 	ldr	x0, [x0, #8]
 1118d4c:	913ffc00 	add	x0, x0, #0xfff
 1118d50:	9274cc00 	and	x0, x0, #0xfffffffffffff000
 1118d54:	eb00003f 	cmp	x1, x0
 1118d58:	54000069 	b.ls	1118d64 <umap_add_region+0xcc>  // b.plast
		return TEE_ERROR_BAD_PARAMETERS;
 1118d5c:	129fff20 	mov	w0, #0xffff0006            	// #-65530
 1118d60:	17fffff0 	b	1118d20 <umap_add_region+0x88>
	granul = MAX(align, SMALL_PAGE_SIZE);
 1118d64:	f140069f 	cmp	x20, #0x1, lsl #12
 1118d68:	d2820005 	mov	x5, #0x1000                	// #4096
 1118d6c:	9a852294 	csel	x20, x20, x5, cs  // cs = hs, nlast
	if (!IS_POWER_OF_TWO(granul))
 1118d70:	cb1403e0 	neg	x0, x20
 1118d74:	ea20029f 	bics	xzr, x20, x0
 1118d78:	54ffff21 	b.ne	1118d5c <umap_add_region+0xc4>  // b.any
	prev_r = &dummy_first_reg;
 1118d7c:	910183e0 	add	x0, sp, #0x60
	TAILQ_FOREACH(r, &vmi->regions, link) {
 1118d80:	f94002d5 	ldr	x21, [x22]
 1118d84:	aa0003f9 	mov	x25, x0
 1118d88:	b50002b5 	cbnz	x21, 1118ddc <umap_add_region+0x144>
	r = TAILQ_LAST(&vmi->regions, vm_region_head);
 1118d8c:	f94006c0 	ldr	x0, [x22, #8]
	va = select_va_in_range(r, &dummy_last_reg, reg, pad_begin, pad_end,
 1118d90:	aa1403e5 	mov	x5, x20
 1118d94:	aa1803e4 	mov	x4, x24
 1118d98:	aa1703e3 	mov	x3, x23
 1118d9c:	aa1303e2 	mov	x2, x19
 1118da0:	910263e1 	add	x1, sp, #0x98
	r = TAILQ_LAST(&vmi->regions, vm_region_head);
 1118da4:	f9400400 	ldr	x0, [x0, #8]
 1118da8:	f9400000 	ldr	x0, [x0]
		r = &dummy_first_reg;
 1118dac:	f100001f 	cmp	x0, #0x0
	va = select_va_in_range(r, &dummy_last_reg, reg, pad_begin, pad_end,
 1118db0:	9a991000 	csel	x0, x0, x25, ne  // ne = any
 1118db4:	97ffff75 	bl	1118b88 <select_va_in_range>
	if (va) {
 1118db8:	b4fffb20 	cbz	x0, 1118d1c <umap_add_region+0x84>
		reg->va = va;
 1118dbc:	f9000a60 	str	x0, [x19, #16]
		TAILQ_INSERT_TAIL(&vmi->regions, reg, link);
 1118dc0:	f94006c0 	ldr	x0, [x22, #8]
 1118dc4:	f900167f 	str	xzr, [x19, #40]
 1118dc8:	f9001a60 	str	x0, [x19, #48]
 1118dcc:	f9000013 	str	x19, [x0]
 1118dd0:	9100a273 	add	x19, x19, #0x28
 1118dd4:	f90006d3 	str	x19, [x22, #8]
 1118dd8:	1400000f 	b	1118e14 <umap_add_region+0x17c>
		va = select_va_in_range(prev_r, r, reg, pad_begin, pad_end,
 1118ddc:	aa1403e5 	mov	x5, x20
 1118de0:	aa1803e4 	mov	x4, x24
 1118de4:	aa1703e3 	mov	x3, x23
 1118de8:	aa1303e2 	mov	x2, x19
 1118dec:	aa1503e1 	mov	x1, x21
 1118df0:	97ffff66 	bl	1118b88 <select_va_in_range>
		if (va) {
 1118df4:	b4000140 	cbz	x0, 1118e1c <umap_add_region+0x184>
			reg->va = va;
 1118df8:	f9000a60 	str	x0, [x19, #16]
			TAILQ_INSERT_BEFORE(r, reg, link);
 1118dfc:	f9401aa0 	ldr	x0, [x21, #48]
 1118e00:	a9028275 	stp	x21, x0, [x19, #40]
 1118e04:	f9401aa0 	ldr	x0, [x21, #48]
 1118e08:	f9000013 	str	x19, [x0]
 1118e0c:	9100a273 	add	x19, x19, #0x28
 1118e10:	f9001ab3 	str	x19, [x21, #48]
		return TEE_SUCCESS;
 1118e14:	52800000 	mov	w0, #0x0                   	// #0
 1118e18:	17ffffc2 	b	1118d20 <umap_add_region+0x88>
	TAILQ_FOREACH(r, &vmi->regions, link) {
 1118e1c:	aa1503e0 	mov	x0, x21
 1118e20:	f94016b5 	ldr	x21, [x21, #40]
 1118e24:	17ffffd9 	b	1118d88 <umap_add_region+0xf0>

0000000001118e28 <alloc_pgt>:
{
 1118e28:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1118e2c:	910003fd 	mov	x29, sp
	if (TAILQ_EMPTY(&uctx->vm_info.regions)) {
 1118e30:	f9400001 	ldr	x1, [x0]
 1118e34:	b50002a1 	cbnz	x1, 1118e88 <alloc_pgt+0x60>
		core_mmu_get_user_va_range(&b, NULL);
 1118e38:	910063e0 	add	x0, sp, #0x18
 1118e3c:	97ffc8a5 	bl	110b0d0 <core_mmu_get_user_va_range>
		e = b;
 1118e40:	f9400fe5 	ldr	x5, [sp, #24]
	return (e - b) >> CORE_MMU_PGDIR_SHIFT;
 1118e44:	f9400fe0 	ldr	x0, [sp, #24]
 1118e48:	cb0000a5 	sub	x5, x5, x0
	return TEE_SUCCESS;
 1118e4c:	52800000 	mov	w0, #0x0                   	// #0
	return (e - b) >> CORE_MMU_PGDIR_SHIFT;
 1118e50:	d355fca5 	lsr	x5, x5, #21
	if (!pgt_check_avail(ntbl)) {
 1118e54:	f10010bf 	cmp	x5, #0x4
 1118e58:	54000149 	b.ls	1118e80 <alloc_pgt+0x58>  // b.plast
		EMSG("%zu page tables not available", ntbl);
 1118e5c:	b00001e4 	adrp	x4, 1155000 <__func__.3826+0xa8>
 1118e60:	52800023 	mov	w3, #0x1                   	// #1
 1118e64:	9109e884 	add	x4, x4, #0x27a
 1118e68:	52800022 	mov	w2, #0x1                   	// #1
 1118e6c:	52801261 	mov	w1, #0x93                  	// #147
 1118e70:	b00001e0 	adrp	x0, 1155000 <__func__.3826+0xa8>
 1118e74:	910e0000 	add	x0, x0, #0x380
 1118e78:	9400afb3 	bl	1144d44 <trace_printf>
		return TEE_ERROR_OUT_OF_MEMORY;
 1118e7c:	129ffe60 	mov	w0, #0xffff000c            	// #-65524
}
 1118e80:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1118e84:	d65f03c0 	ret
		r = TAILQ_LAST(&uctx->vm_info.regions, vm_region_head);
 1118e88:	f9400400 	ldr	x0, [x0, #8]
 1118e8c:	f9400400 	ldr	x0, [x0, #8]
 1118e90:	f9400000 	ldr	x0, [x0]
		e = r->va + r->size;
 1118e94:	a9410005 	ldp	x5, x0, [x0, #16]
 1118e98:	8b0000a5 	add	x5, x5, x0
		e = ROUNDUP(e, CORE_MMU_PGDIR_SIZE);
 1118e9c:	b24053e0 	mov	x0, #0x1fffff              	// #2097151
 1118ea0:	8b0000a5 	add	x5, x5, x0
		b = ROUNDDOWN(b, CORE_MMU_PGDIR_SIZE);
 1118ea4:	f9400820 	ldr	x0, [x1, #16]
		e = ROUNDUP(e, CORE_MMU_PGDIR_SIZE);
 1118ea8:	926ba8a5 	and	x5, x5, #0xffffffffffe00000
		b = ROUNDDOWN(b, CORE_MMU_PGDIR_SIZE);
 1118eac:	926ba800 	and	x0, x0, #0xffffffffffe00000
 1118eb0:	f9000fe0 	str	x0, [sp, #24]
		e = ROUNDUP(e, CORE_MMU_PGDIR_SIZE);
 1118eb4:	17ffffe4 	b	1118e44 <alloc_pgt+0x1c>

0000000001118eb8 <rem_um_region>:
{
 1118eb8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1118ebc:	910003fd 	mov	x29, sp
 1118ec0:	a90153f3 	stp	x19, x20, [sp, #16]
 1118ec4:	aa0103f3 	mov	x19, x1
 1118ec8:	aa0003f4 	mov	x20, x0
	struct thread_specific_data *tsd = thread_get_tsd();
 1118ecc:	97ffb33d 	bl	1105bc0 <thread_get_tsd>
		pgt_cache = &tsd->pgt_cache;
 1118ed0:	91006000 	add	x0, x0, #0x18
	if (uctx->ts_ctx == tsd->ctx)
 1118ed4:	f85f8004 	ldur	x4, [x0, #-8]
	vaddr_t last = ROUNDUP(r->va + r->size, CORE_MMU_PGDIR_SIZE);
 1118ed8:	a9410e62 	ldp	x2, x3, [x19, #16]
	if (uctx->ts_ctx == tsd->ctx)
 1118edc:	f9412281 	ldr	x1, [x20, #576]
		pgt_cache = &tsd->pgt_cache;
 1118ee0:	eb04003f 	cmp	x1, x4
		pgt_clear_ctx_range(pgt_cache, uctx->ts_ctx, r->va,
 1118ee4:	8b030043 	add	x3, x2, x3
 1118ee8:	9a9f0000 	csel	x0, x0, xzr, eq  // eq = none
 1118eec:	97ffcb16 	bl	110bb44 <pgt_clear_ctx_range>
		tlbi_mva_range_asid(r->va, r->size, SMALL_PAGE_SIZE,
 1118ef0:	b9401283 	ldr	w3, [x20, #16]
 1118ef4:	d2820002 	mov	x2, #0x1000                	// #4096
 1118ef8:	a9410660 	ldp	x0, x1, [x19, #16]
}
 1118efc:	a94153f3 	ldp	x19, x20, [sp, #16]
 1118f00:	a8c27bfd 	ldp	x29, x30, [sp], #32
		tlbi_mva_range_asid(r->va, r->size, SMALL_PAGE_SIZE,
 1118f04:	17ffc223 	b	1109790 <tlbi_mva_range_asid>

0000000001118f08 <find_vm_region.isra.0>:
	TAILQ_FOREACH(r, &vm_info->regions, link)
 1118f08:	b5000040 	cbnz	x0, 1118f10 <find_vm_region.isra.0+0x8>
}
 1118f0c:	d65f03c0 	ret
		if (va >= r->va && va < r->va + r->size)
 1118f10:	f9400802 	ldr	x2, [x0, #16]
 1118f14:	eb01005f 	cmp	x2, x1
 1118f18:	540000a8 	b.hi	1118f2c <find_vm_region.isra.0+0x24>  // b.pmore
 1118f1c:	f9400c03 	ldr	x3, [x0, #24]
 1118f20:	8b030042 	add	x2, x2, x3
 1118f24:	eb02003f 	cmp	x1, x2
 1118f28:	54ffff23 	b.cc	1118f0c <find_vm_region.isra.0+0x4>  // b.lo, b.ul, b.last
	TAILQ_FOREACH(r, &vm_info->regions, link)
 1118f2c:	f9401400 	ldr	x0, [x0, #40]
 1118f30:	17fffff6 	b	1118f08 <find_vm_region.isra.0>

0000000001118f34 <mobj_get.part.0>:
static inline struct mobj *mobj_get(struct mobj *mobj)
 1118f34:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
		panic();
 1118f38:	b00001e2 	adrp	x2, 1155000 <__func__.3826+0xa8>
 1118f3c:	f00001c0 	adrp	x0, 1153000 <__func__.3477+0x91>
static inline struct mobj *mobj_get(struct mobj *mobj)
 1118f40:	910003fd 	mov	x29, sp
		panic();
 1118f44:	910d9042 	add	x2, x2, #0x364
 1118f48:	91019c00 	add	x0, x0, #0x67
 1118f4c:	d2800003 	mov	x3, #0x0                   	// #0
 1118f50:	52801041 	mov	w1, #0x82                  	// #130
 1118f54:	97ffe945 	bl	1113468 <__do_panic>

0000000001118f58 <mobj_put>:
	if (mobj && refcount_dec(&mobj->refc))
 1118f58:	b4000260 	cbz	x0, 1118fa4 <mobj_put+0x4c>
{
 1118f5c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1118f60:	910003fd 	mov	x29, sp
 1118f64:	f9000bf3 	str	x19, [sp, #16]
 1118f68:	aa0003f3 	mov	x19, x0
	if (mobj && refcount_dec(&mobj->refc))
 1118f6c:	91006000 	add	x0, x0, #0x18
 1118f70:	97ffe98f 	bl	11135ac <refcount_dec>
 1118f74:	72001c1f 	tst	w0, #0xff
 1118f78:	54000100 	b.eq	1118f98 <mobj_put+0x40>  // b.none
		mobj->ops->free(mobj);
 1118f7c:	f9400260 	ldr	x0, [x19]
 1118f80:	f9401401 	ldr	x1, [x0, #40]
 1118f84:	aa1303e0 	mov	x0, x19
}
 1118f88:	f9400bf3 	ldr	x19, [sp, #16]
		mobj->ops->free(mobj);
 1118f8c:	aa0103f0 	mov	x16, x1
}
 1118f90:	a8c27bfd 	ldp	x29, x30, [sp], #32
		mobj->ops->free(mobj);
 1118f94:	d61f0200 	br	x16
}
 1118f98:	f9400bf3 	ldr	x19, [sp, #16]
 1118f9c:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1118fa0:	d65f03c0 	ret
 1118fa4:	d65f03c0 	ret

0000000001118fa8 <umap_remove_region.isra.0>:
	merge_vm_range(uctx, va, len);

	return TEE_SUCCESS;
}

static void umap_remove_region(struct vm_info *vmi, struct vm_region *reg)
 1118fa8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1118fac:	910003fd 	mov	x29, sp
 1118fb0:	f9000bf3 	str	x19, [sp, #16]
 1118fb4:	aa0103f3 	mov	x19, x1
{
	TAILQ_REMOVE(&vmi->regions, reg, link);
 1118fb8:	f9401421 	ldr	x1, [x1, #40]
 1118fbc:	f9401a62 	ldr	x2, [x19, #48]
 1118fc0:	b4000141 	cbz	x1, 1118fe8 <umap_remove_region.isra.0+0x40>
 1118fc4:	f9001822 	str	x2, [x1, #48]
 1118fc8:	f9401a60 	ldr	x0, [x19, #48]
 1118fcc:	f9000001 	str	x1, [x0]
	mobj_put(reg->mobj);
 1118fd0:	f9400260 	ldr	x0, [x19]
 1118fd4:	97ffffe1 	bl	1118f58 <mobj_put>
	free(reg);
 1118fd8:	aa1303e0 	mov	x0, x19
}
 1118fdc:	f9400bf3 	ldr	x19, [sp, #16]
 1118fe0:	a8c27bfd 	ldp	x29, x30, [sp], #32
	free(reg);
 1118fe4:	1400a97f 	b	11435e0 <free>
	TAILQ_REMOVE(&vmi->regions, reg, link);
 1118fe8:	f9000002 	str	x2, [x0]
 1118fec:	17fffff7 	b	1118fc8 <umap_remove_region.isra.0+0x20>

0000000001118ff0 <mobj_matches.constprop.0>:
	if (mobj && mobj->ops && mobj->ops->matches)
 1118ff0:	b4000100 	cbz	x0, 1119010 <mobj_matches.constprop.0+0x20>
 1118ff4:	f9400001 	ldr	x1, [x0]
 1118ff8:	b40000c1 	cbz	x1, 1119010 <mobj_matches.constprop.0+0x20>
 1118ffc:	f9401022 	ldr	x2, [x1, #32]
 1119000:	b4000082 	cbz	x2, 1119010 <mobj_matches.constprop.0+0x20>
		return mobj->ops->matches(mobj, attr);
 1119004:	aa0203f0 	mov	x16, x2
 1119008:	52800061 	mov	w1, #0x3                   	// #3
 111900c:	d61f0200 	br	x16
	return false;
 1119010:	52800000 	mov	w0, #0x0                   	// #0
}
 1119014:	d65f03c0 	ret

0000000001119018 <mobj_get_phys_offs.constprop.0>:
	if (mobj && mobj->ops && mobj->ops->get_phys_offs)
 1119018:	b4000100 	cbz	x0, 1119038 <mobj_get_phys_offs.constprop.0+0x20>
 111901c:	f9400001 	ldr	x1, [x0]
 1119020:	b40000c1 	cbz	x1, 1119038 <mobj_get_phys_offs.constprop.0+0x20>
 1119024:	f9400822 	ldr	x2, [x1, #16]
 1119028:	b4000082 	cbz	x2, 1119038 <mobj_get_phys_offs.constprop.0+0x20>
		return mobj->ops->get_phys_offs(mobj, granule);
 111902c:	aa0203f0 	mov	x16, x2
 1119030:	d2820001 	mov	x1, #0x1000                	// #4096
 1119034:	d61f0200 	br	x16
}
 1119038:	d2800000 	mov	x0, #0x0                   	// #0
 111903c:	d65f03c0 	ret

0000000001119040 <cmp_param_mem>:
	}
	return TEE_ERROR_GENERIC;
}

static int cmp_param_mem(const void *a0, const void *a1)
{
 1119040:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1119044:	910003fd 	mov	x29, sp
 1119048:	a90153f3 	stp	x19, x20, [sp, #16]
 111904c:	aa0003f4 	mov	x20, x0
 1119050:	aa0103f3 	mov	x19, x1
	const struct param_mem *m1 = a1;
	const struct param_mem *m0 = a0;
	int ret;

	/* Make sure that invalid param_mem are placed last in the array */
	if (!m0->mobj && !m1->mobj)
 1119054:	f9400000 	ldr	x0, [x0]
 1119058:	f9400021 	ldr	x1, [x1]
{
 111905c:	f90013f5 	str	x21, [sp, #32]
	if (!m0->mobj && !m1->mobj)
 1119060:	b50000e0 	cbnz	x0, 111907c <cmp_param_mem+0x3c>
 1119064:	f100003f 	cmp	x1, #0x0
 1119068:	1a9f07e0 	cset	w0, ne  // ne = any
	ret = CMP_TRILEAN(m0->offs, m1->offs);
	if (ret)
		return ret;

	return CMP_TRILEAN(m0->size, m1->size);
}
 111906c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1119070:	f94013f5 	ldr	x21, [sp, #32]
 1119074:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1119078:	d65f03c0 	ret
	if (!m1->mobj)
 111907c:	b5000061 	cbnz	x1, 1119088 <cmp_param_mem+0x48>
		return -1;
 1119080:	12800000 	mov	w0, #0xffffffff            	// #-1
 1119084:	17fffffa 	b	111906c <cmp_param_mem+0x2c>
	return mobj_matches(mobj, CORE_MEM_SEC);
 1119088:	97ffffda 	bl	1118ff0 <mobj_matches.constprop.0>
 111908c:	12001c15 	and	w21, w0, #0xff
 1119090:	f9400260 	ldr	x0, [x19]
 1119094:	97ffffd7 	bl	1118ff0 <mobj_matches.constprop.0>
 1119098:	12001c00 	and	w0, w0, #0xff
	ret = CMP_TRILEAN(mobj_is_secure(m0->mobj), mobj_is_secure(m1->mobj));
 111909c:	6b15001f 	cmp	w0, w21
 11190a0:	54000243 	b.cc	11190e8 <cmp_param_mem+0xa8>  // b.lo, b.ul, b.last
 11190a4:	54fffee8 	b.hi	1119080 <cmp_param_mem+0x40>  // b.pmore
	ret = CMP_TRILEAN((vaddr_t)m0->mobj, (vaddr_t)m1->mobj);
 11190a8:	f9400260 	ldr	x0, [x19]
 11190ac:	f9400281 	ldr	x1, [x20]
 11190b0:	eb00003f 	cmp	x1, x0
 11190b4:	540001a8 	b.hi	11190e8 <cmp_param_mem+0xa8>  // b.pmore
 11190b8:	54fffe43 	b.cc	1119080 <cmp_param_mem+0x40>  // b.lo, b.ul, b.last
	ret = CMP_TRILEAN(m0->offs, m1->offs);
 11190bc:	f9400a60 	ldr	x0, [x19, #16]
 11190c0:	f9400a81 	ldr	x1, [x20, #16]
 11190c4:	eb00003f 	cmp	x1, x0
 11190c8:	54000108 	b.hi	11190e8 <cmp_param_mem+0xa8>  // b.pmore
 11190cc:	54fffda3 	b.cc	1119080 <cmp_param_mem+0x40>  // b.lo, b.ul, b.last
	return CMP_TRILEAN(m0->size, m1->size);
 11190d0:	f9400661 	ldr	x1, [x19, #8]
 11190d4:	f9400682 	ldr	x2, [x20, #8]
 11190d8:	eb01005f 	cmp	x2, x1
 11190dc:	5a9f23e0 	csetm	w0, cc  // cc = lo, ul, last
 11190e0:	1a9f9400 	csinc	w0, w0, wzr, ls  // ls = plast
 11190e4:	17ffffe2 	b	111906c <cmp_param_mem+0x2c>
	ret = CMP_TRILEAN(mobj_is_secure(m0->mobj), mobj_is_secure(m1->mobj));
 11190e8:	52800020 	mov	w0, #0x1                   	// #1
 11190ec:	17ffffe0 	b	111906c <cmp_param_mem+0x2c>

00000000011190f0 <split_vm_region.isra.0>:
static TEE_Result split_vm_region(struct user_mode_ctx *uctx,
 11190f0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 11190f4:	910003fd 	mov	x29, sp
 11190f8:	a9025bf5 	stp	x21, x22, [sp, #32]
	size_t diff = va - r->va;
 11190fc:	f9400835 	ldr	x21, [x1, #16]
static TEE_Result split_vm_region(struct user_mode_ctx *uctx,
 1119100:	a90153f3 	stp	x19, x20, [sp, #16]
 1119104:	a90363f7 	stp	x23, x24, [sp, #48]
	assert(diff && diff < r->size);
 1119108:	eb150058 	subs	x24, x2, x21
static TEE_Result split_vm_region(struct user_mode_ctx *uctx,
 111910c:	f90023f9 	str	x25, [sp, #64]
	assert(diff && diff < r->size);
 1119110:	540000c0 	b.eq	1119128 <split_vm_region.isra.0+0x38>  // b.none
 1119114:	aa0003f7 	mov	x23, x0
 1119118:	aa0103f3 	mov	x19, x1
 111911c:	f9400c20 	ldr	x0, [x1, #24]
 1119120:	eb00031f 	cmp	x24, x0
 1119124:	54000143 	b.cc	111914c <split_vm_region.isra.0+0x5c>  // b.lo, b.ul, b.last
 1119128:	900001e3 	adrp	x3, 1155000 <__func__.3826+0xa8>
 111912c:	900001e1 	adrp	x1, 1155000 <__func__.3826+0xa8>
 1119130:	910e2863 	add	x3, x3, #0x38a
 1119134:	91093421 	add	x1, x1, #0x24d
 1119138:	900001e0 	adrp	x0, 1155000 <__func__.3826+0xa8>
 111913c:	910a6000 	add	x0, x0, #0x298
 1119140:	52802f82 	mov	w2, #0x17c                 	// #380
 1119144:	97ffe45a 	bl	11122ac <_assert_log>
 1119148:	97ffe46a 	bl	11122f0 <_assert_break>
 111914c:	aa0203f6 	mov	x22, x2
	r2 = calloc(1, sizeof(*r2));
 1119150:	d2800701 	mov	x1, #0x38                  	// #56
 1119154:	d2800020 	mov	x0, #0x1                   	// #1
 1119158:	9400a8de 	bl	11434d0 <calloc>
 111915c:	aa0003f4 	mov	x20, x0
	if (!r2)
 1119160:	b4000440 	cbz	x0, 11191e8 <split_vm_region.isra.0+0xf8>
	if (mobj_is_paged(r->mobj)) {
 1119164:	f9400279 	ldr	x25, [x19]
	if (mobj && !refcount_inc(&mobj->refc))
 1119168:	b40000d9 	cbz	x25, 1119180 <split_vm_region.isra.0+0x90>
 111916c:	91006320 	add	x0, x25, #0x18
 1119170:	97ffe901 	bl	1113574 <refcount_inc>
 1119174:	72001c1f 	tst	w0, #0xff
 1119178:	54000041 	b.ne	1119180 <split_vm_region.isra.0+0x90>  // b.any
 111917c:	97ffff6e 	bl	1118f34 <mobj_get.part.0>
	r2->offset = r->offset + diff;
 1119180:	f9400660 	ldr	x0, [x19, #8]
	r2->size = r->size - diff;
 1119184:	f9400e62 	ldr	x2, [x19, #24]
	r2->offset = r->offset + diff;
 1119188:	8b180000 	add	x0, x0, x24
 111918c:	a9000299 	stp	x25, x0, [x20]
	r2->attr = r->attr;
 1119190:	b9402260 	ldr	w0, [x19, #32]
 1119194:	b9002280 	str	w0, [x20, #32]
	TAILQ_INSERT_AFTER(&uctx->vm_info.regions, r, r2, link);
 1119198:	aa1403e0 	mov	x0, x20
	r2->size = r->size - diff;
 111919c:	8b0202b5 	add	x21, x21, x2
	r->size = diff;
 11191a0:	f9000e78 	str	x24, [x19, #24]
	TAILQ_INSERT_AFTER(&uctx->vm_info.regions, r, r2, link);
 11191a4:	f9401661 	ldr	x1, [x19, #40]
	r2->size = r->size - diff;
 11191a8:	cb1602b5 	sub	x21, x21, x22
 11191ac:	a9015696 	stp	x22, x21, [x20, #16]
	TAILQ_INSERT_AFTER(&uctx->vm_info.regions, r, r2, link);
 11191b0:	f8028c01 	str	x1, [x0, #40]!
 11191b4:	b4000161 	cbz	x1, 11191e0 <split_vm_region.isra.0+0xf0>
 11191b8:	f9001820 	str	x0, [x1, #48]
 11191bc:	f8028e74 	str	x20, [x19, #40]!
	return TEE_SUCCESS;
 11191c0:	52800000 	mov	w0, #0x0                   	// #0
	TAILQ_INSERT_AFTER(&uctx->vm_info.regions, r, r2, link);
 11191c4:	f9001a93 	str	x19, [x20, #48]
}
 11191c8:	a94153f3 	ldp	x19, x20, [sp, #16]
 11191cc:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11191d0:	a94363f7 	ldp	x23, x24, [sp, #48]
 11191d4:	f94023f9 	ldr	x25, [sp, #64]
 11191d8:	a8c57bfd 	ldp	x29, x30, [sp], #80
 11191dc:	d65f03c0 	ret
	TAILQ_INSERT_AFTER(&uctx->vm_info.regions, r, r2, link);
 11191e0:	f90002e0 	str	x0, [x23]
 11191e4:	17fffff6 	b	11191bc <split_vm_region.isra.0+0xcc>
		return TEE_ERROR_OUT_OF_MEMORY;
 11191e8:	129ffe60 	mov	w0, #0xffff000c            	// #-65524
 11191ec:	17fffff7 	b	11191c8 <split_vm_region.isra.0+0xd8>

00000000011191f0 <split_vm_range>:
{
 11191f0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 11191f4:	910003fd 	mov	x29, sp
 11191f8:	a90153f3 	stp	x19, x20, [sp, #16]
 11191fc:	a9025bf5 	stp	x21, x22, [sp, #32]
 1119200:	aa0003f6 	mov	x22, x0
	if ((va | len) & SMALL_PAGE_MASK)
 1119204:	aa020020 	orr	x0, x1, x2
{
 1119208:	a90363f7 	stp	x23, x24, [sp, #48]
	if ((va | len) & SMALL_PAGE_MASK)
 111920c:	f2402c1f 	tst	x0, #0xfff
 1119210:	540000e0 	b.eq	111922c <split_vm_range+0x3c>  // b.none
		return TEE_ERROR_BAD_PARAMETERS;
 1119214:	129fff20 	mov	w0, #0xffff0006            	// #-65530
}
 1119218:	a94153f3 	ldp	x19, x20, [sp, #16]
 111921c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1119220:	a94363f7 	ldp	x23, x24, [sp, #48]
 1119224:	a8c47bfd 	ldp	x29, x30, [sp], #64
 1119228:	d65f03c0 	ret
 111922c:	aa0103f3 	mov	x19, x1
 1119230:	aa0203f4 	mov	x20, x2
	if (ADD_OVERFLOW(va, len, &end_va))
 1119234:	ab020037 	adds	x23, x1, x2
 1119238:	54fffee2 	b.cs	1119214 <split_vm_range+0x24>  // b.hs, b.nlast
	r = find_vm_region(&uctx->vm_info, va);
 111923c:	f94002c0 	ldr	x0, [x22]
 1119240:	aa0303e5 	mov	x5, x3
 1119244:	97ffff31 	bl	1118f08 <find_vm_region.isra.0>
 1119248:	aa0003f5 	mov	x21, x0
	if (!r || !va_range_is_contiguous(r, va, len, cmp_regs))
 111924c:	b4fffe40 	cbz	x0, 1119214 <split_vm_range+0x24>
 1119250:	aa0403f8 	mov	x24, x4
 1119254:	aa0503e3 	mov	x3, x5
 1119258:	aa1403e2 	mov	x2, x20
 111925c:	97fffe14 	bl	1118aac <va_range_is_contiguous>
 1119260:	72001c1f 	tst	w0, #0xff
 1119264:	54fffd80 	b.eq	1119214 <split_vm_range+0x24>  // b.none
	if (va != r->va) {
 1119268:	f9400aa0 	ldr	x0, [x21, #16]
 111926c:	eb13001f 	cmp	x0, x19
 1119270:	540000e0 	b.eq	111928c <split_vm_range+0x9c>  // b.none
		res = split_vm_region(uctx, r, va);
 1119274:	aa1303e2 	mov	x2, x19
 1119278:	aa1503e1 	mov	x1, x21
 111927c:	910022c0 	add	x0, x22, #0x8
 1119280:	97ffff9c 	bl	11190f0 <split_vm_region.isra.0>
		if (res)
 1119284:	35fffca0 	cbnz	w0, 1119218 <split_vm_range+0x28>
		r = TAILQ_NEXT(r, link);
 1119288:	f94016b5 	ldr	x21, [x21, #40]
	*r0_ret = r;
 111928c:	f9000315 	str	x21, [x24]
	r = find_vm_region(&uctx->vm_info, va + len - 1);
 1119290:	d1000681 	sub	x1, x20, #0x1
 1119294:	f94002c0 	ldr	x0, [x22]
 1119298:	8b130021 	add	x1, x1, x19
 111929c:	97ffff1b 	bl	1118f08 <find_vm_region.isra.0>
 11192a0:	aa0003e1 	mov	x1, x0
	if (!r)
 11192a4:	b4fffb80 	cbz	x0, 1119214 <split_vm_range+0x24>
	if (end_va != r->va + r->size) {
 11192a8:	a9410800 	ldp	x0, x2, [x0, #16]
 11192ac:	8b020000 	add	x0, x0, x2
 11192b0:	eb0002ff 	cmp	x23, x0
 11192b4:	54000100 	b.eq	11192d4 <split_vm_range+0xe4>  // b.none
		res = split_vm_region(uctx, r, end_va);
 11192b8:	aa1703e2 	mov	x2, x23
 11192bc:	910022c0 	add	x0, x22, #0x8
}
 11192c0:	a94153f3 	ldp	x19, x20, [sp, #16]
 11192c4:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11192c8:	a94363f7 	ldp	x23, x24, [sp, #48]
 11192cc:	a8c47bfd 	ldp	x29, x30, [sp], #64
		res = split_vm_region(uctx, r, end_va);
 11192d0:	17ffff88 	b	11190f0 <split_vm_region.isra.0>
	return TEE_SUCCESS;
 11192d4:	52800000 	mov	w0, #0x0                   	// #0
 11192d8:	17ffffd0 	b	1119218 <split_vm_range+0x28>

00000000011192dc <vm_get_flags>:
	if (!len || ((len | va) & SMALL_PAGE_MASK))
 11192dc:	b50000e2 	cbnz	x2, 11192f8 <vm_get_flags+0x1c>
		return TEE_ERROR_BAD_PARAMETERS;
 11192e0:	129fff20 	mov	w0, #0xffff0006            	// #-65530
}
 11192e4:	d65f03c0 	ret
		return TEE_ERROR_BAD_PARAMETERS;
 11192e8:	129fff20 	mov	w0, #0xffff0006            	// #-65530
}
 11192ec:	a94153f3 	ldp	x19, x20, [sp, #16]
 11192f0:	a8c27bfd 	ldp	x29, x30, [sp], #32
 11192f4:	d65f03c0 	ret
 11192f8:	aa0203e4 	mov	x4, x2
	if (!len || ((len | va) & SMALL_PAGE_MASK))
 11192fc:	aa010042 	orr	x2, x2, x1
 1119300:	f2402c5f 	tst	x2, #0xfff
 1119304:	54fffee1 	b.ne	11192e0 <vm_get_flags+0x4>  // b.any
{
 1119308:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 111930c:	910003fd 	mov	x29, sp
	r = find_vm_region(&uctx->vm_info, va);
 1119310:	f9400000 	ldr	x0, [x0]
{
 1119314:	a90153f3 	stp	x19, x20, [sp, #16]
 1119318:	aa0303f4 	mov	x20, x3
	r = find_vm_region(&uctx->vm_info, va);
 111931c:	97fffefb 	bl	1118f08 <find_vm_region.isra.0>
 1119320:	aa0003f3 	mov	x19, x0
	if (!r)
 1119324:	b4fffe20 	cbz	x0, 11192e8 <vm_get_flags+0xc>
	if (!va_range_is_contiguous(r, va, len, cmp_region_for_get_flags))
 1119328:	aa0403e2 	mov	x2, x4
 111932c:	f0ffffe3 	adrp	x3, 1118000 <mobj_phys_get_va+0x34>
 1119330:	912dd063 	add	x3, x3, #0xb74
 1119334:	97fffdde 	bl	1118aac <va_range_is_contiguous>
 1119338:	72001c1f 	tst	w0, #0xff
 111933c:	54fffd60 	b.eq	11192e8 <vm_get_flags+0xc>  // b.none
	*flags = r->flags;
 1119340:	79404660 	ldrh	w0, [x19, #34]
 1119344:	b9000280 	str	w0, [x20]
	return TEE_SUCCESS;
 1119348:	52800000 	mov	w0, #0x0                   	// #0
 111934c:	17ffffe8 	b	11192ec <vm_get_flags+0x10>

0000000001119350 <vm_unmap>:
{
 1119350:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 1119354:	910003fd 	mov	x29, sp
 1119358:	a9025bf5 	stp	x21, x22, [sp, #32]
 111935c:	aa0003f5 	mov	x21, x0
 1119360:	a90153f3 	stp	x19, x20, [sp, #16]
 1119364:	aa0103f4 	mov	x20, x1
 1119368:	aa0203f3 	mov	x19, x2
 111936c:	a90363f7 	stp	x23, x24, [sp, #48]
	struct vm_region *r = NULL;
 1119370:	f90027ff 	str	xzr, [sp, #72]
	assert(thread_get_tsd()->ctx == uctx->ts_ctx);
 1119374:	97ffb213 	bl	1105bc0 <thread_get_tsd>
 1119378:	f9400801 	ldr	x1, [x0, #16]
 111937c:	f94122a0 	ldr	x0, [x21, #576]
 1119380:	eb00003f 	cmp	x1, x0
 1119384:	54000140 	b.eq	11193ac <vm_unmap+0x5c>  // b.none
 1119388:	900001e3 	adrp	x3, 1155000 <__func__.3826+0xa8>
 111938c:	900001e1 	adrp	x1, 1155000 <__func__.3826+0xa8>
 1119390:	910ebc63 	add	x3, x3, #0x3af
 1119394:	91093421 	add	x1, x1, #0x24d
 1119398:	900001e0 	adrp	x0, 1155000 <__func__.3826+0xa8>
 111939c:	910abc00 	add	x0, x0, #0x2af
 11193a0:	52805fa2 	mov	w2, #0x2fd                 	// #765
 11193a4:	97ffe3c2 	bl	11122ac <_assert_log>
 11193a8:	97ffe3d2 	bl	11122f0 <_assert_break>
	if (ROUNDUP_OVERFLOW(len, SMALL_PAGE_SIZE, &l))
 11193ac:	b13ffe62 	adds	x2, x19, #0xfff
 11193b0:	54000062 	b.cs	11193bc <vm_unmap+0x6c>  // b.hs, b.nlast
	if (!l || (va & SMALL_PAGE_MASK))
 11193b4:	f274cc42 	ands	x2, x2, #0xfffffffffffff000
 11193b8:	54000061 	b.ne	11193c4 <vm_unmap+0x74>  // b.any
		return TEE_ERROR_BAD_PARAMETERS;
 11193bc:	129fff33 	mov	w19, #0xffff0006            	// #-65530
 11193c0:	1400000c 	b	11193f0 <vm_unmap+0xa0>
	if (!l || (va & SMALL_PAGE_MASK))
 11193c4:	f2402e9f 	tst	x20, #0xfff
 11193c8:	54ffffa1 	b.ne	11193bc <vm_unmap+0x6c>  // b.any
	if (ADD_OVERFLOW(va, l, &end_va))
 11193cc:	ab020297 	adds	x23, x20, x2
 11193d0:	54ffff62 	b.cs	11193bc <vm_unmap+0x6c>  // b.hs, b.nlast
	res = split_vm_range(uctx, va, l, NULL, &r);
 11193d4:	910123e4 	add	x4, sp, #0x48
 11193d8:	aa1403e1 	mov	x1, x20
 11193dc:	aa1503e0 	mov	x0, x21
 11193e0:	d2800003 	mov	x3, #0x0                   	// #0
 11193e4:	97ffff83 	bl	11191f0 <split_vm_range>
 11193e8:	2a0003f3 	mov	w19, w0
	if (res)
 11193ec:	340000e0 	cbz	w0, 1119408 <vm_unmap+0xb8>
}
 11193f0:	2a1303e0 	mov	w0, w19
 11193f4:	a94153f3 	ldp	x19, x20, [sp, #16]
 11193f8:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11193fc:	a94363f7 	ldp	x23, x24, [sp, #48]
 1119400:	a8c57bfd 	ldp	x29, x30, [sp], #80
 1119404:	d65f03c0 	ret
		umap_remove_region(&uctx->vm_info, r);
 1119408:	910022b8 	add	x24, x21, #0x8
		r_next = TAILQ_NEXT(r, link);
 111940c:	f94027e1 	ldr	x1, [sp, #72]
		unmap_end_va = r->va + r->size;
 1119410:	a9410034 	ldp	x20, x0, [x1, #16]
		r_next = TAILQ_NEXT(r, link);
 1119414:	f9401436 	ldr	x22, [x1, #40]
		unmap_end_va = r->va + r->size;
 1119418:	8b000294 	add	x20, x20, x0
		rem_um_region(uctx, r);
 111941c:	aa1503e0 	mov	x0, x21
 1119420:	97fffea6 	bl	1118eb8 <rem_um_region>
		umap_remove_region(&uctx->vm_info, r);
 1119424:	f94027e1 	ldr	x1, [sp, #72]
 1119428:	aa1803e0 	mov	x0, x24
 111942c:	97fffedf 	bl	1118fa8 <umap_remove_region.isra.0>
		if (!r_next || unmap_end_va == end_va)
 1119430:	b4fffe16 	cbz	x22, 11193f0 <vm_unmap+0xa0>
 1119434:	eb1402ff 	cmp	x23, x20
 1119438:	54fffdc0 	b.eq	11193f0 <vm_unmap+0xa0>  // b.none
		r = r_next;
 111943c:	f90027f6 	str	x22, [sp, #72]
		r_next = TAILQ_NEXT(r, link);
 1119440:	17fffff3 	b	111940c <vm_unmap+0xbc>

0000000001119444 <vm_clean_param>:
{
 1119444:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1119448:	910003fd 	mov	x29, sp
 111944c:	a9025bf5 	stp	x21, x22, [sp, #32]
	TAILQ_FOREACH_SAFE(r, &uctx->vm_info.regions, link, next_r) {
 1119450:	aa0003f5 	mov	x21, x0
{
 1119454:	a90153f3 	stp	x19, x20, [sp, #16]
 1119458:	aa0003f4 	mov	x20, x0
	TAILQ_FOREACH_SAFE(r, &uctx->vm_info.regions, link, next_r) {
 111945c:	f84086b3 	ldr	x19, [x21], #8
 1119460:	b4000193 	cbz	x19, 1119490 <vm_clean_param+0x4c>
		if (r->flags & VM_FLAG_EPHEMERAL) {
 1119464:	79404660 	ldrh	w0, [x19, #34]
	TAILQ_FOREACH_SAFE(r, &uctx->vm_info.regions, link, next_r) {
 1119468:	f9401676 	ldr	x22, [x19, #40]
		if (r->flags & VM_FLAG_EPHEMERAL) {
 111946c:	360000e0 	tbz	w0, #0, 1119488 <vm_clean_param+0x44>
			rem_um_region(uctx, r);
 1119470:	aa1303e1 	mov	x1, x19
 1119474:	aa1403e0 	mov	x0, x20
 1119478:	97fffe90 	bl	1118eb8 <rem_um_region>
			umap_remove_region(&uctx->vm_info, r);
 111947c:	aa1303e1 	mov	x1, x19
 1119480:	aa1503e0 	mov	x0, x21
 1119484:	97fffec9 	bl	1118fa8 <umap_remove_region.isra.0>
{
 1119488:	aa1603f3 	mov	x19, x22
 111948c:	17fffff5 	b	1119460 <vm_clean_param+0x1c>
}
 1119490:	a94153f3 	ldp	x19, x20, [sp, #16]
 1119494:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1119498:	a8c37bfd 	ldp	x29, x30, [sp], #48
 111949c:	d65f03c0 	ret

00000000011194a0 <vm_info_final>:
		}
	}
}

void vm_info_final(struct user_mode_ctx *uctx)
{
 11194a0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 11194a4:	910003fd 	mov	x29, sp
 11194a8:	a90153f3 	stp	x19, x20, [sp, #16]
 11194ac:	aa0003f3 	mov	x19, x0
	if (!uctx->vm_info.asid)
 11194b0:	b9401000 	ldr	w0, [x0, #16]
 11194b4:	34000200 	cbz	w0, 11194f4 <vm_info_final+0x54>
		return;

	/* clear MMU entries to avoid clash when asid is reused */
	tlbi_asid(uctx->vm_info.asid);
 11194b8:	2a0003e0 	mov	w0, w0
 11194bc:	97ffac38 	bl	110459c <tlbi_asid>

	asid_free(uctx->vm_info.asid);
 11194c0:	b9401260 	ldr	w0, [x19, #16]
	while (!TAILQ_EMPTY(&uctx->vm_info.regions))
		umap_remove_region(&uctx->vm_info,
 11194c4:	91002274 	add	x20, x19, #0x8
	asid_free(uctx->vm_info.asid);
 11194c8:	97ffc2f4 	bl	110a098 <asid_free>
	while (!TAILQ_EMPTY(&uctx->vm_info.regions))
 11194cc:	f9400261 	ldr	x1, [x19]
 11194d0:	b50000c1 	cbnz	x1, 11194e8 <vm_info_final+0x48>
				   TAILQ_FIRST(&uctx->vm_info.regions));
	memset(&uctx->vm_info, 0, sizeof(uctx->vm_info));
 11194d4:	aa1303e0 	mov	x0, x19
 11194d8:	d2800302 	mov	x2, #0x18                  	// #24
}
 11194dc:	a94153f3 	ldp	x19, x20, [sp, #16]
 11194e0:	a8c27bfd 	ldp	x29, x30, [sp], #32
	memset(&uctx->vm_info, 0, sizeof(uctx->vm_info));
 11194e4:	1400a9ff 	b	1143ce0 <memset>
		umap_remove_region(&uctx->vm_info,
 11194e8:	aa1403e0 	mov	x0, x20
 11194ec:	97fffeaf 	bl	1118fa8 <umap_remove_region.isra.0>
 11194f0:	17fffff7 	b	11194cc <vm_info_final+0x2c>
}
 11194f4:	a94153f3 	ldp	x19, x20, [sp, #16]
 11194f8:	a8c27bfd 	ldp	x29, x30, [sp], #32
 11194fc:	d65f03c0 	ret

0000000001119500 <vm_buf_is_inside_um_private>:

/* return true only if buffer fits inside TA private memory */
bool vm_buf_is_inside_um_private(const struct user_mode_ctx *uctx,
				 const void *va, size_t size)
{
 1119500:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1119504:	910003fd 	mov	x29, sp
 1119508:	a90153f3 	stp	x19, x20, [sp, #16]
 111950c:	aa0103f4 	mov	x20, x1
	struct vm_region *r = NULL;

	TAILQ_FOREACH(r, &uctx->vm_info.regions, link) {
 1119510:	f9400013 	ldr	x19, [x0]
{
 1119514:	f90013f5 	str	x21, [sp, #32]
 1119518:	aa0203f5 	mov	x21, x2
	TAILQ_FOREACH(r, &uctx->vm_info.regions, link) {
 111951c:	b5000073 	cbnz	x19, 1119528 <vm_buf_is_inside_um_private+0x28>
			continue;
		if (core_is_buffer_inside((vaddr_t)va, size, r->va, r->size))
			return true;
	}

	return false;
 1119520:	52800000 	mov	w0, #0x0                   	// #0
 1119524:	1400000c 	b	1119554 <vm_buf_is_inside_um_private+0x54>
		if (r->flags & VM_FLAGS_NONPRIV)
 1119528:	79404660 	ldrh	w0, [x19, #34]
 111952c:	f240081f 	tst	x0, #0x7
 1119530:	54000060 	b.eq	111953c <vm_buf_is_inside_um_private+0x3c>  // b.none
	TAILQ_FOREACH(r, &uctx->vm_info.regions, link) {
 1119534:	f9401673 	ldr	x19, [x19, #40]
 1119538:	17fffff9 	b	111951c <vm_buf_is_inside_um_private+0x1c>
		if (core_is_buffer_inside((vaddr_t)va, size, r->va, r->size))
 111953c:	a9410e62 	ldp	x2, x3, [x19, #16]
 1119540:	aa1503e1 	mov	x1, x21
 1119544:	aa1403e0 	mov	x0, x20
 1119548:	97ffe83d 	bl	111363c <core_is_buffer_inside>
 111954c:	72001c00 	ands	w0, w0, #0xff
 1119550:	54ffff20 	b.eq	1119534 <vm_buf_is_inside_um_private+0x34>  // b.none
}
 1119554:	a94153f3 	ldp	x19, x20, [sp, #16]
 1119558:	f94013f5 	ldr	x21, [sp, #32]
 111955c:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1119560:	d65f03c0 	ret

0000000001119564 <vm_buf_to_mboj_offs>:
}

TEE_Result vm_buf_to_mboj_offs(const struct user_mode_ctx *uctx,
			       const void *va, size_t size,
			       struct mobj **mobj, size_t *offs)
{
 1119564:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 1119568:	910003fd 	mov	x29, sp
 111956c:	a90153f3 	stp	x19, x20, [sp, #16]
 1119570:	aa0103f4 	mov	x20, x1
 1119574:	a9025bf5 	stp	x21, x22, [sp, #32]
 1119578:	aa0203f5 	mov	x21, x2
 111957c:	aa0303f6 	mov	x22, x3
	struct vm_region *r = NULL;

	TAILQ_FOREACH(r, &uctx->vm_info.regions, link) {
 1119580:	f9400013 	ldr	x19, [x0]
{
 1119584:	f9001bf7 	str	x23, [sp, #48]
 1119588:	aa0403f7 	mov	x23, x4
	TAILQ_FOREACH(r, &uctx->vm_info.regions, link) {
 111958c:	b5000073 	cbnz	x19, 1119598 <vm_buf_to_mboj_offs+0x34>
			*offs = (vaddr_t)va - r->va + r->offset - poffs;
			return TEE_SUCCESS;
		}
	}

	return TEE_ERROR_BAD_PARAMETERS;
 1119590:	129fff20 	mov	w0, #0xffff0006            	// #-65530
 1119594:	14000013 	b	11195e0 <vm_buf_to_mboj_offs+0x7c>
		if (!r->mobj)
 1119598:	f9400260 	ldr	x0, [x19]
 111959c:	b40002c0 	cbz	x0, 11195f4 <vm_buf_to_mboj_offs+0x90>
		if (core_is_buffer_inside((vaddr_t)va, size, r->va, r->size)) {
 11195a0:	a9410e62 	ldp	x2, x3, [x19, #16]
 11195a4:	aa1503e1 	mov	x1, x21
 11195a8:	aa1403e0 	mov	x0, x20
 11195ac:	97ffe824 	bl	111363c <core_is_buffer_inside>
 11195b0:	72001c1f 	tst	w0, #0xff
 11195b4:	54000200 	b.eq	11195f4 <vm_buf_to_mboj_offs+0x90>  // b.none
			poffs = mobj_get_phys_offs(r->mobj,
 11195b8:	f9400260 	ldr	x0, [x19]
 11195bc:	97fffe97 	bl	1119018 <mobj_get_phys_offs.constprop.0>
			*offs = (vaddr_t)va - r->va + r->offset - poffs;
 11195c0:	a9400a61 	ldp	x1, x2, [x19]
			*mobj = r->mobj;
 11195c4:	f90002c1 	str	x1, [x22]
			*offs = (vaddr_t)va - r->va + r->offset - poffs;
 11195c8:	f9400a61 	ldr	x1, [x19, #16]
 11195cc:	cb010294 	sub	x20, x20, x1
 11195d0:	cb000042 	sub	x2, x2, x0
			return TEE_SUCCESS;
 11195d4:	52800000 	mov	w0, #0x0                   	// #0
			*offs = (vaddr_t)va - r->va + r->offset - poffs;
 11195d8:	8b140042 	add	x2, x2, x20
 11195dc:	f90002e2 	str	x2, [x23]
}
 11195e0:	a94153f3 	ldp	x19, x20, [sp, #16]
 11195e4:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11195e8:	f9401bf7 	ldr	x23, [sp, #48]
 11195ec:	a8c47bfd 	ldp	x29, x30, [sp], #64
 11195f0:	d65f03c0 	ret
	TAILQ_FOREACH(r, &uctx->vm_info.regions, link) {
 11195f4:	f9401673 	ldr	x19, [x19, #40]
 11195f8:	17ffffe5 	b	111958c <vm_buf_to_mboj_offs+0x28>

00000000011195fc <vm_va2pa>:

	return TEE_ERROR_ACCESS_DENIED;
}

TEE_Result vm_va2pa(const struct user_mode_ctx *uctx, void *ua, paddr_t *pa)
{
 11195fc:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 1119600:	910003fd 	mov	x29, sp
 1119604:	a90153f3 	stp	x19, x20, [sp, #16]
	return tee_mmu_user_va2pa_attr(uctx, ua, pa, NULL);
 1119608:	f9400014 	ldr	x20, [x0]
{
 111960c:	a9025bf5 	stp	x21, x22, [sp, #32]
 1119610:	aa0103f5 	mov	x21, x1
 1119614:	aa0203f6 	mov	x22, x2
	TAILQ_FOREACH(region, &uctx->vm_info.regions, link) {
 1119618:	b5000074 	cbnz	x20, 1119624 <vm_va2pa+0x28>
	return TEE_ERROR_ACCESS_DENIED;
 111961c:	129fffc0 	mov	w0, #0xffff0001            	// #-65535
 1119620:	14000028 	b	11196c0 <vm_va2pa+0xc4>
		if (!core_is_buffer_inside((vaddr_t)ua, 1, region->va,
 1119624:	a9410e82 	ldp	x2, x3, [x20, #16]
 1119628:	aa1503e0 	mov	x0, x21
 111962c:	d2800021 	mov	x1, #0x1                   	// #1
 1119630:	97ffe803 	bl	111363c <core_is_buffer_inside>
 1119634:	72001c1f 	tst	w0, #0xff
 1119638:	54000061 	b.ne	1119644 <vm_va2pa+0x48>  // b.any
	TAILQ_FOREACH(region, &uctx->vm_info.regions, link) {
 111963c:	f9401694 	ldr	x20, [x20, #40]
 1119640:	17fffff6 	b	1119618 <vm_va2pa+0x1c>
		if (pa) {
 1119644:	b4000476 	cbz	x22, 11196d0 <vm_va2pa+0xd4>
			granule = MAX(region->mobj->phys_granule,
 1119648:	f9400280 	ldr	x0, [x20]
 111964c:	d2820002 	mov	x2, #0x1000                	// #4096
 1119650:	f9400813 	ldr	x19, [x0, #16]
 1119654:	f140067f 	cmp	x19, #0x1, lsl #12
 1119658:	9a822273 	csel	x19, x19, x2, cs  // cs = hs, nlast
			assert(!granule || IS_POWER_OF_TWO(granule));
 111965c:	cb1303e2 	neg	x2, x19
 1119660:	ea22027f 	bics	xzr, x19, x2
 1119664:	54000140 	b.eq	111968c <vm_va2pa+0x90>  // b.none
 1119668:	900001e3 	adrp	x3, 1155000 <__func__.3826+0xa8>
 111966c:	900001e1 	adrp	x1, 1155000 <__func__.3826+0xa8>
 1119670:	910f6c63 	add	x3, x3, #0x3db
 1119674:	91093421 	add	x1, x1, #0x24d
 1119678:	900001e0 	adrp	x0, 1155000 <__func__.3826+0xa8>
 111967c:	910b5400 	add	x0, x0, #0x2d5
 1119680:	528090a2 	mov	w2, #0x485                 	// #1157
 1119684:	97ffe30a 	bl	11122ac <_assert_log>
 1119688:	97ffe31a 	bl	11122f0 <_assert_break>
				 ROUNDDOWN((vaddr_t)ua - region->va, granule);
 111968c:	a9408684 	ldp	x4, x1, [x20, #8]
			res = mobj_get_pa(region->mobj, offset, granule, &p);
 1119690:	9100e3e3 	add	x3, sp, #0x38
				 ROUNDDOWN((vaddr_t)ua - region->va, granule);
 1119694:	cb0102a1 	sub	x1, x21, x1
 1119698:	8a020021 	and	x1, x1, x2
			res = mobj_get_pa(region->mobj, offset, granule, &p);
 111969c:	aa1303e2 	mov	x2, x19
 11196a0:	8b040021 	add	x1, x1, x4
 11196a4:	97fffcf9 	bl	1118a88 <mobj_get_pa>
			if (res != TEE_SUCCESS)
 11196a8:	350000c0 	cbnz	w0, 11196c0 <vm_va2pa+0xc4>
			*pa = p | ((vaddr_t)ua & (granule - 1));
 11196ac:	f9401fe1 	ldr	x1, [sp, #56]
 11196b0:	d1000673 	sub	x19, x19, #0x1
 11196b4:	8a150273 	and	x19, x19, x21
 11196b8:	aa010273 	orr	x19, x19, x1
 11196bc:	f90002d3 	str	x19, [x22]
}
 11196c0:	a94153f3 	ldp	x19, x20, [sp, #16]
 11196c4:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11196c8:	a8c47bfd 	ldp	x29, x30, [sp], #64
 11196cc:	d65f03c0 	ret
		return TEE_SUCCESS;
 11196d0:	52800000 	mov	w0, #0x0                   	// #0
	return tee_mmu_user_va2pa_attr(uctx, ua, pa, NULL);
 11196d4:	17fffffb 	b	11196c0 <vm_va2pa+0xc4>

00000000011196d8 <vm_pa2va>:

void *vm_pa2va(const struct user_mode_ctx *uctx, paddr_t pa)
{
 11196d8:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
 11196dc:	910003fd 	mov	x29, sp
 11196e0:	a90363f7 	stp	x23, x24, [sp, #48]
 11196e4:	aa0103f7 	mov	x23, x1
					size = region->size - ofs;
			} else {
				size = region->size;
			}

			if (mobj_get_pa(region->mobj, ofs, granule, &p))
 11196e8:	910163f8 	add	x24, sp, #0x58
{
 11196ec:	a90153f3 	stp	x19, x20, [sp, #16]
 11196f0:	a9025bf5 	stp	x21, x22, [sp, #32]
	paddr_t p = 0;
 11196f4:	f9002fff 	str	xzr, [sp, #88]
	TAILQ_FOREACH(region, &uctx->vm_info.regions, link) {
 11196f8:	f9400013 	ldr	x19, [x0]
{
 11196fc:	f90023f9 	str	x25, [sp, #64]
	TAILQ_FOREACH(region, &uctx->vm_info.regions, link) {
 1119700:	b4000653 	cbz	x19, 11197c8 <vm_pa2va+0xf0>
		if (!region->mobj)
 1119704:	f9400260 	ldr	x0, [x19]
 1119708:	b5000060 	cbnz	x0, 1119714 <vm_pa2va+0x3c>
	TAILQ_FOREACH(region, &uctx->vm_info.regions, link) {
 111970c:	f9401673 	ldr	x19, [x19, #40]
 1119710:	17fffffc 	b	1119700 <vm_pa2va+0x28>
		granule = region->mobj->phys_granule;
 1119714:	f9400816 	ldr	x22, [x0, #16]
		assert(!granule || IS_POWER_OF_TWO(granule));
 1119718:	b40001b6 	cbz	x22, 111974c <vm_pa2va+0x74>
 111971c:	cb1603e0 	neg	x0, x22
 1119720:	ea2002df 	bics	xzr, x22, x0
 1119724:	54000140 	b.eq	111974c <vm_pa2va+0x74>  // b.none
 1119728:	900001e3 	adrp	x3, 1155000 <__func__.3826+0xa8>
 111972c:	900001e1 	adrp	x1, 1155000 <__func__.3826+0xa8>
 1119730:	910fcc63 	add	x3, x3, #0x3f3
 1119734:	91093421 	add	x1, x1, #0x24d
 1119738:	900001e0 	adrp	x0, 1155000 <__func__.3826+0xa8>
 111973c:	910b5400 	add	x0, x0, #0x2d5
 1119740:	528095c2 	mov	w2, #0x4ae                 	// #1198
 1119744:	97ffe2da 	bl	11122ac <_assert_log>
 1119748:	97ffe2ea 	bl	11122f0 <_assert_break>
		for (ofs = region->offset; ofs < region->size; ofs += size) {
 111974c:	f9400674 	ldr	x20, [x19, #8]
				size = granule - (ofs & (granule - 1));
 1119750:	d10006d9 	sub	x25, x22, #0x1
		for (ofs = region->offset; ofs < region->size; ofs += size) {
 1119754:	f9400e75 	ldr	x21, [x19, #24]
 1119758:	eb1402bf 	cmp	x21, x20
 111975c:	54fffd89 	b.ls	111970c <vm_pa2va+0x34>  // b.plast
			if (granule) {
 1119760:	b40000d6 	cbz	x22, 1119778 <vm_pa2va+0xa0>
				size = granule - (ofs & (granule - 1));
 1119764:	8a140320 	and	x0, x25, x20
				if (size > (region->size - ofs))
 1119768:	cb1402b5 	sub	x21, x21, x20
				size = granule - (ofs & (granule - 1));
 111976c:	cb0002c0 	sub	x0, x22, x0
 1119770:	eb15001f 	cmp	x0, x21
 1119774:	9a959015 	csel	x21, x0, x21, ls  // ls = plast
			if (mobj_get_pa(region->mobj, ofs, granule, &p))
 1119778:	f9400260 	ldr	x0, [x19]
 111977c:	aa1803e3 	mov	x3, x24
 1119780:	aa1603e2 	mov	x2, x22
 1119784:	aa1403e1 	mov	x1, x20
 1119788:	97fffcc0 	bl	1118a88 <mobj_get_pa>
 111978c:	350002c0 	cbnz	w0, 11197e4 <vm_pa2va+0x10c>
				continue;

			if (core_is_buffer_inside(pa, 1, p, size)) {
 1119790:	f9402fe2 	ldr	x2, [sp, #88]
 1119794:	aa1503e3 	mov	x3, x21
 1119798:	aa1703e0 	mov	x0, x23
 111979c:	d2800021 	mov	x1, #0x1                   	// #1
 11197a0:	97ffe7a7 	bl	111363c <core_is_buffer_inside>
 11197a4:	72001c1f 	tst	w0, #0xff
 11197a8:	540001e0 	b.eq	11197e4 <vm_pa2va+0x10c>  // b.none
				/* Remove region offset (mobj phys offset) */
				ofs -= region->offset;
				/* Get offset-in-granule */
				p = pa - p;

				return (void *)(region->va + ofs + (vaddr_t)p);
 11197ac:	f9400a60 	ldr	x0, [x19, #16]
 11197b0:	f9402fe1 	ldr	x1, [sp, #88]
 11197b4:	8b000294 	add	x20, x20, x0
 11197b8:	f9400673 	ldr	x19, [x19, #8]
 11197bc:	cb0102f7 	sub	x23, x23, x1
 11197c0:	8b170294 	add	x20, x20, x23
 11197c4:	cb130293 	sub	x19, x20, x19
			}
		}
	}

	return NULL;
}
 11197c8:	aa1303e0 	mov	x0, x19
 11197cc:	a94153f3 	ldp	x19, x20, [sp, #16]
 11197d0:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11197d4:	a94363f7 	ldp	x23, x24, [sp, #48]
 11197d8:	f94023f9 	ldr	x25, [sp, #64]
 11197dc:	a8c67bfd 	ldp	x29, x30, [sp], #96
 11197e0:	d65f03c0 	ret
		for (ofs = region->offset; ofs < region->size; ofs += size) {
 11197e4:	8b150294 	add	x20, x20, x21
 11197e8:	17ffffdb 	b	1119754 <vm_pa2va+0x7c>

00000000011197ec <vm_check_access_rights>:

TEE_Result vm_check_access_rights(const struct user_mode_ctx *uctx,
				  uint32_t flags, uaddr_t uaddr, size_t len)
{
 11197ec:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 11197f0:	910003fd 	mov	x29, sp
 11197f4:	a90153f3 	stp	x19, x20, [sp, #16]
 11197f8:	aa0203f3 	mov	x19, x2
 11197fc:	a9025bf5 	stp	x21, x22, [sp, #32]
 1119800:	a90363f7 	stp	x23, x24, [sp, #48]
	uaddr_t a = 0;
	uaddr_t end_addr = 0;
	size_t addr_incr = MIN(CORE_MMU_USER_CODE_SIZE,
			       CORE_MMU_USER_PARAM_SIZE);

	if (ADD_OVERFLOW(uaddr, len, &end_addr))
 1119804:	ab030057 	adds	x23, x2, x3
{
 1119808:	a9046bf9 	stp	x25, x26, [sp, #64]
	if (ADD_OVERFLOW(uaddr, len, &end_addr))
 111980c:	540000e2 	b.cs	1119828 <vm_check_access_rights+0x3c>  // b.hs, b.nlast
 1119810:	aa0303e2 	mov	x2, x3
		return TEE_ERROR_ACCESS_DENIED;

	if ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&
 1119814:	12040423 	and	w3, w1, #0x30000000
 1119818:	2a0103f4 	mov	w20, w1
 111981c:	52a60001 	mov	w1, #0x30000000            	// #805306368
 1119820:	6b01007f 	cmp	w3, w1
 1119824:	54000101 	b.ne	1119844 <vm_check_access_rights+0x58>  // b.any
		return TEE_ERROR_ACCESS_DENIED;
 1119828:	129fffc0 	mov	w0, #0xffff0001            	// #-65535
		if ((flags & TEE_MEMORY_ACCESS_READ) && !(attr & TEE_MATTR_UR))
			return TEE_ERROR_ACCESS_DENIED;
	}

	return TEE_SUCCESS;
}
 111982c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1119830:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1119834:	a94363f7 	ldp	x23, x24, [sp, #48]
 1119838:	a9446bf9 	ldp	x25, x26, [sp, #64]
 111983c:	a8c57bfd 	ldp	x29, x30, [sp], #80
 1119840:	d65f03c0 	ret
 1119844:	aa0003f6 	mov	x22, x0
	if (!(flags & TEE_MEMORY_ACCESS_ANY_OWNER) &&
 1119848:	36100154 	tbz	w20, #2, 1119870 <vm_check_access_rights+0x84>
		if ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&
 111984c:	12040298 	and	w24, w20, #0x10000000
		if ((flags & TEE_MEMORY_ACCESS_SECURE) &&
 1119850:	12030299 	and	w25, w20, #0x20000000
		if ((flags & TEE_MEMORY_ACCESS_WRITE) && !(attr & TEE_MATTR_UW))
 1119854:	121f029a 	and	w26, w20, #0x2
	for (a = ROUNDDOWN(uaddr, addr_incr); a < end_addr; a += addr_incr) {
 1119858:	9274ce73 	and	x19, x19, #0xfffffffffffff000
		if ((flags & TEE_MEMORY_ACCESS_READ) && !(attr & TEE_MATTR_UR))
 111985c:	12000294 	and	w20, w20, #0x1
	for (a = ROUNDDOWN(uaddr, addr_incr); a < end_addr; a += addr_incr) {
 1119860:	eb1302ff 	cmp	x23, x19
 1119864:	54000108 	b.hi	1119884 <vm_check_access_rights+0x98>  // b.pmore
	return TEE_SUCCESS;
 1119868:	52800000 	mov	w0, #0x0                   	// #0
 111986c:	17fffff0 	b	111982c <vm_check_access_rights+0x40>
	   !vm_buf_is_inside_um_private(uctx, (void *)uaddr, len))
 1119870:	aa1303e1 	mov	x1, x19
 1119874:	97ffff23 	bl	1119500 <vm_buf_is_inside_um_private>
	if (!(flags & TEE_MEMORY_ACCESS_ANY_OWNER) &&
 1119878:	72001c1f 	tst	w0, #0xff
 111987c:	54fffe81 	b.ne	111984c <vm_check_access_rights+0x60>  // b.any
 1119880:	17ffffea 	b	1119828 <vm_check_access_rights+0x3c>
		res = tee_mmu_user_va2pa_attr(uctx, (void *)a, NULL, &attr);
 1119884:	f94002d5 	ldr	x21, [x22]
	TAILQ_FOREACH(region, &uctx->vm_info.regions, link) {
 1119888:	b4fffd15 	cbz	x21, 1119828 <vm_check_access_rights+0x3c>
		if (!core_is_buffer_inside((vaddr_t)ua, 1, region->va,
 111988c:	a9410ea2 	ldp	x2, x3, [x21, #16]
 1119890:	aa1303e0 	mov	x0, x19
 1119894:	d2800021 	mov	x1, #0x1                   	// #1
 1119898:	97ffe769 	bl	111363c <core_is_buffer_inside>
 111989c:	72001c1f 	tst	w0, #0xff
 11198a0:	54000061 	b.ne	11198ac <vm_check_access_rights+0xc0>  // b.any
	TAILQ_FOREACH(region, &uctx->vm_info.regions, link) {
 11198a4:	f94016b5 	ldr	x21, [x21, #40]
 11198a8:	17fffff8 	b	1119888 <vm_check_access_rights+0x9c>
			*attr = region->attr;
 11198ac:	794042a0 	ldrh	w0, [x21, #32]
		if ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&
 11198b0:	35000138 	cbnz	w24, 11198d4 <vm_check_access_rights+0xe8>
		if ((flags & TEE_MEMORY_ACCESS_SECURE) &&
 11198b4:	34000059 	cbz	w25, 11198bc <vm_check_access_rights+0xd0>
 11198b8:	365ffb80 	tbz	w0, #11, 1119828 <vm_check_access_rights+0x3c>
		if ((flags & TEE_MEMORY_ACCESS_WRITE) && !(attr & TEE_MATTR_UW))
 11198bc:	3400005a 	cbz	w26, 11198c4 <vm_check_access_rights+0xd8>
 11198c0:	3647fb40 	tbz	w0, #8, 1119828 <vm_check_access_rights+0x3c>
		if ((flags & TEE_MEMORY_ACCESS_READ) && !(attr & TEE_MATTR_UR))
 11198c4:	34000054 	cbz	w20, 11198cc <vm_check_access_rights+0xe0>
 11198c8:	363ffb00 	tbz	w0, #7, 1119828 <vm_check_access_rights+0x3c>
	for (a = ROUNDDOWN(uaddr, addr_incr); a < end_addr; a += addr_incr) {
 11198cc:	91400673 	add	x19, x19, #0x1, lsl #12
 11198d0:	17ffffe4 	b	1119860 <vm_check_access_rights+0x74>
		if ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&
 11198d4:	365fff00 	tbz	w0, #11, 11198b4 <vm_check_access_rights+0xc8>
 11198d8:	17ffffd4 	b	1119828 <vm_check_access_rights+0x3c>

00000000011198dc <vm_set_ctx>:

void vm_set_ctx(struct ts_ctx *ctx)
{
 11198dc:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 11198e0:	910003fd 	mov	x29, sp
 11198e4:	a90153f3 	stp	x19, x20, [sp, #16]
 11198e8:	aa0003f3 	mov	x19, x0
 11198ec:	f90013f5 	str	x21, [sp, #32]
	struct thread_specific_data *tsd = thread_get_tsd();
 11198f0:	97ffb0b4 	bl	1105bc0 <thread_get_tsd>
 11198f4:	aa0003f4 	mov	x20, x0

	core_mmu_set_user_map(NULL);
 11198f8:	d2800000 	mov	x0, #0x0                   	// #0
 11198fc:	97ffc681 	bl	110b300 <core_mmu_set_user_map>
	 * This function has to be called before there's a chance that
	 * pgt_free_unlocked() is called.
	 *
	 * Save translation tables in a cache if it's a user TA.
	 */
	pgt_free(&tsd->pgt_cache, is_user_ta_ctx(tsd->ctx));
 1119900:	f9400a80 	ldr	x0, [x20, #16]
 1119904:	97fff23a 	bl	11161ec <is_user_ta_ctx>
 1119908:	2a0003e1 	mov	w1, w0
 111990c:	91006280 	add	x0, x20, #0x18
 1119910:	97ffc901 	bl	110bd14 <pgt_free>
	return is_user_ta_ctx(ctx) || is_stmm_ctx(ctx) || is_sp_ctx(ctx);
 1119914:	aa1303e0 	mov	x0, x19
 1119918:	97fff235 	bl	11161ec <is_user_ta_ctx>

	if (is_user_mode_ctx(ctx)) {
 111991c:	72001c1f 	tst	w0, #0xff
 1119920:	54000320 	b.eq	1119984 <vm_set_ctx+0xa8>  // b.none
	if (is_user_ta_ctx(ctx))
 1119924:	aa1303e0 	mov	x0, x19
		struct core_mmu_user_map map = { };
 1119928:	a9037fff 	stp	xzr, xzr, [sp, #48]
 111992c:	97fff230 	bl	11161ec <is_user_ta_ctx>
 1119930:	72001c1f 	tst	w0, #0xff
 1119934:	54000320 	b.eq	1119998 <vm_set_ctx+0xbc>  // b.none
	assert(is_user_ta_ctx(ctx));
 1119938:	aa1303e0 	mov	x0, x19
 111993c:	97fff22c 	bl	11161ec <is_user_ta_ctx>
 1119940:	72001c1f 	tst	w0, #0xff
 1119944:	54000141 	b.ne	111996c <vm_set_ctx+0x90>  // b.any
 1119948:	900001e3 	adrp	x3, 1155000 <__func__.3826+0xa8>
 111994c:	900001c1 	adrp	x1, 1151000 <small_prime+0x168>
 1119950:	900001c0 	adrp	x0, 1151000 <small_prime+0x168>
 1119954:	910d5463 	add	x3, x3, #0x355
 1119958:	91081021 	add	x1, x1, #0x204
 111995c:	91088800 	add	x0, x0, #0x222
 1119960:	52800702 	mov	w2, #0x38                  	// #56
 1119964:	97ffe252 	bl	11122ac <_assert_log>
 1119968:	97ffe262 	bl	11122f0 <_assert_break>
		struct user_mode_ctx *uctx = to_user_mode_ctx(ctx);

		core_mmu_create_user_map(uctx, &map);
 111996c:	9100c3f5 	add	x21, sp, #0x30
 1119970:	d10a6260 	sub	x0, x19, #0x298
 1119974:	aa1503e1 	mov	x1, x21
 1119978:	97ffc602 	bl	110b180 <core_mmu_create_user_map>
		core_mmu_set_user_map(&map);
 111997c:	aa1503e0 	mov	x0, x21
 1119980:	97ffc660 	bl	110b300 <core_mmu_set_user_map>
		tee_pager_assign_um_tables(uctx);
	}
	tsd->ctx = ctx;
}
 1119984:	f94013f5 	ldr	x21, [sp, #32]
	tsd->ctx = ctx;
 1119988:	f9000a93 	str	x19, [x20, #16]
}
 111998c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1119990:	a8c47bfd 	ldp	x29, x30, [sp], #64
 1119994:	d65f03c0 	ret
 1119998:	900001e3 	adrp	x3, 1155000 <__func__.3826+0xa8>
 111999c:	900001c1 	adrp	x1, 1151000 <small_prime+0x168>
 11199a0:	900001c0 	adrp	x0, 1151000 <small_prime+0x168>
 11199a4:	910d2463 	add	x3, x3, #0x349
 11199a8:	913a8421 	add	x1, x1, #0xea1
 11199ac:	913b2000 	add	x0, x0, #0xec8
 11199b0:	52801322 	mov	w2, #0x99                  	// #153
 11199b4:	17ffffec 	b	1119964 <vm_set_ctx+0x88>

00000000011199b8 <vm_map_pad.part.0>:
TEE_Result vm_map_pad(struct user_mode_ctx *uctx, vaddr_t *va, size_t len,
 11199b8:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
 11199bc:	910003fd 	mov	x29, sp
 11199c0:	a90153f3 	stp	x19, x20, [sp, #16]
 11199c4:	a9025bf5 	stp	x21, x22, [sp, #32]
 11199c8:	aa0003f6 	mov	x22, x0
 11199cc:	aa0203f5 	mov	x21, x2
	reg = calloc(1, sizeof(*reg));
 11199d0:	d2800020 	mov	x0, #0x1                   	// #1
TEE_Result vm_map_pad(struct user_mode_ctx *uctx, vaddr_t *va, size_t len,
 11199d4:	a90363f7 	stp	x23, x24, [sp, #48]
 11199d8:	aa0103f7 	mov	x23, x1
 11199dc:	aa0703f8 	mov	x24, x7
	reg = calloc(1, sizeof(*reg));
 11199e0:	d2800701 	mov	x1, #0x38                  	// #56
TEE_Result vm_map_pad(struct user_mode_ctx *uctx, vaddr_t *va, size_t len,
 11199e4:	a9046bf9 	stp	x25, x26, [sp, #64]
 11199e8:	2a0303fa 	mov	w26, w3
 11199ec:	2a0403f9 	mov	w25, w4
 11199f0:	a90573fb 	stp	x27, x28, [sp, #80]
 11199f4:	aa0503fc 	mov	x28, x5
 11199f8:	aa0603fb 	mov	x27, x6
	reg = calloc(1, sizeof(*reg));
 11199fc:	9400a6b5 	bl	11434d0 <calloc>
	if (!reg)
 1119a00:	b4000980 	cbz	x0, 1119b30 <vm_map_pad.part.0+0x178>
 1119a04:	aa0003f4 	mov	x20, x0
	if (mobj && mobj->ops && mobj->ops->get_cattr)
 1119a08:	b40001fc 	cbz	x28, 1119a44 <vm_map_pad.part.0+0x8c>
 1119a0c:	f9400380 	ldr	x0, [x28]
 1119a10:	b40001a0 	cbz	x0, 1119a44 <vm_map_pad.part.0+0x8c>
 1119a14:	f9400c02 	ldr	x2, [x0, #24]
 1119a18:	b4000162 	cbz	x2, 1119a44 <vm_map_pad.part.0+0x8c>
		return mobj->ops->get_cattr(mobj, cattr);
 1119a1c:	9101b3e1 	add	x1, sp, #0x6c
 1119a20:	aa1c03e0 	mov	x0, x28
 1119a24:	d63f0040 	blr	x2
 1119a28:	2a0003f3 	mov	w19, w0
		if (res)
 1119a2c:	34000100 	cbz	w0, 1119a4c <vm_map_pad.part.0+0x94>
	mobj_put(reg->mobj);
 1119a30:	f9400280 	ldr	x0, [x20]
 1119a34:	97fffd49 	bl	1118f58 <mobj_put>
	free(reg);
 1119a38:	aa1403e0 	mov	x0, x20
 1119a3c:	9400a6e9 	bl	11435e0 <free>
	return res;
 1119a40:	14000030 	b	1119b00 <vm_map_pad.part.0+0x148>
	return TEE_ERROR_GENERIC;
 1119a44:	52bffff3 	mov	w19, #0xffff0000            	// #-65536
			goto err_free_reg;
 1119a48:	17fffffa 	b	1119a30 <vm_map_pad.part.0+0x78>
		attr |= cattr << TEE_MATTR_CACHE_SHIFT;
 1119a4c:	b9406ff3 	ldr	w19, [sp, #108]
	return mobj_matches(mobj, CORE_MEM_SEC);
 1119a50:	aa1c03e0 	mov	x0, x28
 1119a54:	97fffd67 	bl	1118ff0 <mobj_matches.constprop.0>
		attr |= TEE_MATTR_SECURE;
 1119a58:	72001c1f 	tst	w0, #0xff
 1119a5c:	52810023 	mov	w3, #0x801                 	// #2049
	if (mobj && !refcount_inc(&mobj->refc))
 1119a60:	91006380 	add	x0, x28, #0x18
		attr |= cattr << TEE_MATTR_CACHE_SHIFT;
 1119a64:	53144e73 	lsl	w19, w19, #12
		attr |= TEE_MATTR_SECURE;
 1119a68:	2a030263 	orr	w3, w19, w3
 1119a6c:	32000273 	orr	w19, w19, #0x1
 1119a70:	1a830273 	csel	w19, w19, w3, eq  // eq = none
 1119a74:	97ffe6c0 	bl	1113574 <refcount_inc>
 1119a78:	72001c1f 	tst	w0, #0xff
 1119a7c:	54000041 	b.ne	1119a84 <vm_map_pad.part.0+0xcc>  // b.any
 1119a80:	97fffd2d 	bl	1118f34 <mobj_get.part.0>
	res = umap_add_region(&uctx->vm_info, reg, pad_begin, pad_end, align);
 1119a84:	a94713e3 	ldp	x3, x4, [sp, #112]
	reg->size = ROUNDUP(len, SMALL_PAGE_SIZE);
 1119a88:	913ffeb5 	add	x21, x21, #0xfff
	reg->va = *va;
 1119a8c:	f94002e0 	ldr	x0, [x23]
	reg->attr = attr | prot;
 1119a90:	2a1a0273 	orr	w19, w19, w26
	reg->size = ROUNDUP(len, SMALL_PAGE_SIZE);
 1119a94:	9274ceb5 	and	x21, x21, #0xfffffffffffff000
	reg->offset = offs;
 1119a98:	a9006e9c 	stp	x28, x27, [x20]
	res = umap_add_region(&uctx->vm_info, reg, pad_begin, pad_end, align);
 1119a9c:	aa1803e2 	mov	x2, x24
	reg->size = ROUNDUP(len, SMALL_PAGE_SIZE);
 1119aa0:	a9015680 	stp	x0, x21, [x20, #16]
	res = umap_add_region(&uctx->vm_info, reg, pad_begin, pad_end, align);
 1119aa4:	aa1403e1 	mov	x1, x20
 1119aa8:	aa1603e0 	mov	x0, x22
	reg->attr = attr | prot;
 1119aac:	79004293 	strh	w19, [x20, #32]
	reg->flags = flags;
 1119ab0:	79004699 	strh	w25, [x20, #34]
	res = umap_add_region(&uctx->vm_info, reg, pad_begin, pad_end, align);
 1119ab4:	97fffc79 	bl	1118c98 <umap_add_region>
 1119ab8:	2a0003f3 	mov	w19, w0
	if (res)
 1119abc:	35fffba0 	cbnz	w0, 1119a30 <vm_map_pad.part.0+0x78>
	res = alloc_pgt(uctx);
 1119ac0:	aa1603e0 	mov	x0, x22
 1119ac4:	97fffcd9 	bl	1118e28 <alloc_pgt>
 1119ac8:	2a0003f3 	mov	w19, w0
	if (res)
 1119acc:	340000a0 	cbz	w0, 1119ae0 <vm_map_pad.part.0+0x128>
	TAILQ_REMOVE(&uctx->vm_info.regions, reg, link);
 1119ad0:	a9428680 	ldp	x0, x1, [x20, #40]
 1119ad4:	b5000260 	cbnz	x0, 1119b20 <vm_map_pad.part.0+0x168>
 1119ad8:	f90006c1 	str	x1, [x22, #8]
 1119adc:	14000012 	b	1119b24 <vm_map_pad.part.0+0x16c>
	if (thread_get_tsd()->ctx == uctx->ts_ctx)
 1119ae0:	97ffb038 	bl	1105bc0 <thread_get_tsd>
 1119ae4:	f9400800 	ldr	x0, [x0, #16]
 1119ae8:	f94122c1 	ldr	x1, [x22, #576]
 1119aec:	eb01001f 	cmp	x0, x1
 1119af0:	54000041 	b.ne	1119af8 <vm_map_pad.part.0+0x140>  // b.any
		vm_set_ctx(uctx->ts_ctx);
 1119af4:	97ffff7a 	bl	11198dc <vm_set_ctx>
	*va = reg->va;
 1119af8:	f9400a80 	ldr	x0, [x20, #16]
 1119afc:	f90002e0 	str	x0, [x23]
}
 1119b00:	2a1303e0 	mov	w0, w19
 1119b04:	a94153f3 	ldp	x19, x20, [sp, #16]
 1119b08:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1119b0c:	a94363f7 	ldp	x23, x24, [sp, #48]
 1119b10:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1119b14:	a94573fb 	ldp	x27, x28, [sp, #80]
 1119b18:	a8c77bfd 	ldp	x29, x30, [sp], #112
 1119b1c:	d65f03c0 	ret
	TAILQ_REMOVE(&uctx->vm_info.regions, reg, link);
 1119b20:	f9001801 	str	x1, [x0, #48]
 1119b24:	f9401a81 	ldr	x1, [x20, #48]
 1119b28:	f9000020 	str	x0, [x1]
 1119b2c:	17ffffc1 	b	1119a30 <vm_map_pad.part.0+0x78>
		return TEE_ERROR_OUT_OF_MEMORY;
 1119b30:	129ffe73 	mov	w19, #0xffff000c            	// #-65524
 1119b34:	17fffff3 	b	1119b00 <vm_map_pad.part.0+0x148>

0000000001119b38 <vm_map_pad>:
	if (prot & ~TEE_MATTR_PROT_MASK)
 1119b38:	7216647f 	tst	w3, #0xfffffc0f
 1119b3c:	54000041 	b.ne	1119b44 <vm_map_pad+0xc>  // b.any
 1119b40:	17ffff9e 	b	11199b8 <vm_map_pad.part.0>
}
 1119b44:	129fff20 	mov	w0, #0xffff0006            	// #-65530
 1119b48:	d65f03c0 	ret

0000000001119b4c <vm_map_param>:
{
 1119b4c:	d103c3ff 	sub	sp, sp, #0xf0
 1119b50:	a9017bfd 	stp	x29, x30, [sp, #16]
 1119b54:	910043fd 	add	x29, sp, #0x10
 1119b58:	a9035bf5 	stp	x21, x22, [sp, #48]
 1119b5c:	91002035 	add	x21, x1, #0x8
 1119b60:	aa0103f6 	mov	x22, x1
 1119b64:	a9056bf9 	stp	x25, x26, [sp, #80]
	memset(mem, 0, sizeof(mem));
 1119b68:	910243fa 	add	x26, sp, #0x90
 1119b6c:	aa1a03f9 	mov	x25, x26
{
 1119b70:	a90253f3 	stp	x19, x20, [sp, #32]
 1119b74:	aa0003f4 	mov	x20, x0
	memset(mem, 0, sizeof(mem));
 1119b78:	aa1503f3 	mov	x19, x21
{
 1119b7c:	a90463f7 	stp	x23, x24, [sp, #64]
 1119b80:	aa0203f8 	mov	x24, x2
 1119b84:	aa1a03f7 	mov	x23, x26
 1119b88:	a90673fb 	stp	x27, x28, [sp, #96]
	memset(mem, 0, sizeof(mem));
 1119b8c:	5280001b 	mov	w27, #0x0                   	// #0
		mem[n].size = ROUNDUP(phys_offs + param->u[n].mem.offs -
 1119b90:	d282001c 	mov	x28, #0x1000                	// #4096
	memset(mem, 0, sizeof(mem));
 1119b94:	a9097fff 	stp	xzr, xzr, [sp, #144]
 1119b98:	a90a7fff 	stp	xzr, xzr, [sp, #160]
 1119b9c:	a90b7fff 	stp	xzr, xzr, [sp, #176]
 1119ba0:	a90c7fff 	stp	xzr, xzr, [sp, #192]
 1119ba4:	a90d7fff 	stp	xzr, xzr, [sp, #208]
 1119ba8:	a90e7fff 	stp	xzr, xzr, [sp, #224]
		uint32_t param_type = TEE_PARAM_TYPE_GET(param->types, n);
 1119bac:	b94002c0 	ldr	w0, [x22]
 1119bb0:	1adb2400 	lsr	w0, w0, w27
 1119bb4:	12000c00 	and	w0, w0, #0xf
		    param_type != TEE_PARAM_TYPE_MEMREF_OUTPUT &&
 1119bb8:	51001400 	sub	w0, w0, #0x5
		if (param_type != TEE_PARAM_TYPE_MEMREF_INPUT &&
 1119bbc:	7100081f 	cmp	w0, #0x2
 1119bc0:	540001e8 	b.hi	1119bfc <vm_map_param+0xb0>  // b.pmore
		phys_offs = mobj_get_phys_offs(param->u[n].mem.mobj,
 1119bc4:	f9400260 	ldr	x0, [x19]
 1119bc8:	97fffd14 	bl	1119018 <mobj_get_phys_offs.constprop.0>
		mem[n].offs = ROUNDDOWN(phys_offs + param->u[n].mem.offs,
 1119bcc:	f9400a63 	ldr	x3, [x19, #16]
		mem[n].mobj = param->u[n].mem.mobj;
 1119bd0:	f9400261 	ldr	x1, [x19]
		mem[n].offs = ROUNDDOWN(phys_offs + param->u[n].mem.offs,
 1119bd4:	8b030000 	add	x0, x0, x3
		mem[n].size = ROUNDUP(phys_offs + param->u[n].mem.offs -
 1119bd8:	f9400663 	ldr	x3, [x19, #8]
		mem[n].mobj = param->u[n].mem.mobj;
 1119bdc:	f9000321 	str	x1, [x25]
		mem[n].offs = ROUNDDOWN(phys_offs + param->u[n].mem.offs,
 1119be0:	9274cc01 	and	x1, x0, #0xfffffffffffff000
		mem[n].size = ROUNDUP(phys_offs + param->u[n].mem.offs -
 1119be4:	913ffc63 	add	x3, x3, #0xfff
 1119be8:	cb010000 	sub	x0, x0, x1
 1119bec:	8b000063 	add	x3, x3, x0
 1119bf0:	f274cc63 	ands	x3, x3, #0xfffffffffffff000
 1119bf4:	9a9c1063 	csel	x3, x3, x28, ne  // ne = any
		mem[n].offs = ROUNDDOWN(phys_offs + param->u[n].mem.offs,
 1119bf8:	a9008723 	stp	x3, x1, [x25, #8]
	for (n = 0; n < TEE_NUM_PARAMS; n++) {
 1119bfc:	1100137b 	add	w27, w27, #0x4
 1119c00:	91006339 	add	x25, x25, #0x18
 1119c04:	91006273 	add	x19, x19, #0x18
 1119c08:	7100437f 	cmp	w27, #0x10
 1119c0c:	54fffd01 	b.ne	1119bac <vm_map_param+0x60>  // b.any
	qsort(mem, TEE_NUM_PARAMS, sizeof(struct param_mem), cmp_param_mem);
 1119c10:	aa1a03e0 	mov	x0, x26
 1119c14:	90000003 	adrp	x3, 1119000 <mobj_matches.constprop.0+0x10>
 1119c18:	d2800302 	mov	x2, #0x18                  	// #24
 1119c1c:	91010063 	add	x3, x3, #0x40
 1119c20:	d2800081 	mov	x1, #0x4                   	// #4
 1119c24:	9400a707 	bl	1143840 <qsort>
	for (n = 1, m = 0; n < TEE_NUM_PARAMS && mem[n].mobj; n++) {
 1119c28:	91006353 	add	x19, x26, #0x18
		    (mem[n].offs == (mem[m].offs + mem[m].size) ||
 1119c2c:	910283e4 	add	x4, sp, #0xa0
 1119c30:	910263e5 	add	x5, sp, #0x98
	for (n = 1, m = 0; n < TEE_NUM_PARAMS && mem[n].mobj; n++) {
 1119c34:	d2800019 	mov	x25, #0x0                   	// #0
 1119c38:	d280003b 	mov	x27, #0x1                   	// #1
		if (mem[n].mobj == mem[m].mobj &&
 1119c3c:	d280031c 	mov	x28, #0x18                  	// #24
	for (n = 1, m = 0; n < TEE_NUM_PARAMS && mem[n].mobj; n++) {
 1119c40:	f9400260 	ldr	x0, [x19]
 1119c44:	b40002a0 	cbz	x0, 1119c98 <vm_map_param+0x14c>
		if (mem[n].mobj == mem[m].mobj &&
 1119c48:	9b1c7f21 	mul	x1, x25, x28
 1119c4c:	f8616b42 	ldr	x2, [x26, x1]
 1119c50:	eb00005f 	cmp	x2, x0
 1119c54:	54000601 	b.ne	1119d14 <vm_map_param+0x1c8>  // b.any
		    (mem[n].offs == (mem[m].offs + mem[m].size) ||
 1119c58:	f8616880 	ldr	x0, [x4, x1]
 1119c5c:	f86168a1 	ldr	x1, [x5, x1]
 1119c60:	f9400a62 	ldr	x2, [x19, #16]
 1119c64:	8b010003 	add	x3, x0, x1
		if (mem[n].mobj == mem[m].mobj &&
 1119c68:	eb03005f 	cmp	x2, x3
 1119c6c:	54000481 	b.ne	1119cfc <vm_map_param+0x1b0>  // b.any
			mem[m].size = mem[n].offs + mem[n].size - mem[m].offs;
 1119c70:	a9408262 	ldp	x2, x0, [x19, #8]
 1119c74:	9b1c7f21 	mul	x1, x25, x28
 1119c78:	8b020000 	add	x0, x0, x2
 1119c7c:	f8616882 	ldr	x2, [x4, x1]
 1119c80:	cb020000 	sub	x0, x0, x2
 1119c84:	f82168a0 	str	x0, [x5, x1]
	for (n = 1, m = 0; n < TEE_NUM_PARAMS && mem[n].mobj; n++) {
 1119c88:	9100077b 	add	x27, x27, #0x1
 1119c8c:	91006273 	add	x19, x19, #0x18
 1119c90:	f100137f 	cmp	x27, #0x4
 1119c94:	54fffd61 	b.ne	1119c40 <vm_map_param+0xf4>  // b.any
	if (mem[0].mobj)
 1119c98:	f9404be0 	ldr	x0, [sp, #144]
 1119c9c:	b4000040 	cbz	x0, 1119ca4 <vm_map_param+0x158>
		m++;
 1119ca0:	91000739 	add	x25, x25, #0x1
	check_param_map_empty(uctx);
 1119ca4:	f9400280 	ldr	x0, [x20]
	TAILQ_FOREACH(r, &uctx->vm_info.regions, link)
 1119ca8:	b50004e0 	cbnz	x0, 1119d44 <vm_map_param+0x1f8>
 1119cac:	910223fb 	add	x27, sp, #0x88
	for (n = 0; n < m; n++) {
 1119cb0:	d280001a 	mov	x26, #0x0                   	// #0
 1119cb4:	eb19035f 	cmp	x26, x25
 1119cb8:	54000601 	b.ne	1119d78 <vm_map_param+0x22c>  // b.any
	for (n = 0; n < TEE_NUM_PARAMS; n++) {
 1119cbc:	d2800017 	mov	x23, #0x0                   	// #0
		uint32_t param_type = TEE_PARAM_TYPE_GET(param->types, n);
 1119cc0:	b94002c1 	ldr	w1, [x22]
 1119cc4:	531e76e0 	lsl	w0, w23, #2
 1119cc8:	1ac02420 	lsr	w0, w1, w0
 1119ccc:	12000c00 	and	w0, w0, #0xf
		    param_type != TEE_PARAM_TYPE_MEMREF_OUTPUT &&
 1119cd0:	51001400 	sub	w0, w0, #0x5
		if (param_type != TEE_PARAM_TYPE_MEMREF_INPUT &&
 1119cd4:	7100081f 	cmp	w0, #0x2
 1119cd8:	54000968 	b.hi	1119e04 <vm_map_param+0x2b8>  // b.pmore
		if (!param->u[n].mem.mobj)
 1119cdc:	f94002a0 	ldr	x0, [x21]
 1119ce0:	b4000920 	cbz	x0, 1119e04 <vm_map_param+0x2b8>
		res = param_mem_to_user_va(uctx, &param->u[n].mem,
 1119ce4:	f9400293 	ldr	x19, [x20]
	TAILQ_FOREACH(region, &uctx->vm_info.regions, link) {
 1119ce8:	b5000673 	cbnz	x19, 1119db4 <vm_map_param+0x268>
 1119cec:	52bffff3 	mov	w19, #0xffff0000            	// #-65536
		vm_clean_param(uctx);
 1119cf0:	aa1403e0 	mov	x0, x20
 1119cf4:	97fffdd4 	bl	1119444 <vm_clean_param>
	return res;
 1119cf8:	1400004b 	b	1119e24 <vm_map_param+0x2d8>
		     core_is_buffer_intersect(mem[m].offs, mem[m].size,
 1119cfc:	f9400663 	ldr	x3, [x19, #8]
 1119d00:	a90717e4 	stp	x4, x5, [sp, #112]
 1119d04:	97ffe670 	bl	11136c4 <core_is_buffer_intersect>
		    (mem[n].offs == (mem[m].offs + mem[m].size) ||
 1119d08:	72001c1f 	tst	w0, #0xff
 1119d0c:	a94717e4 	ldp	x4, x5, [sp, #112]
 1119d10:	54fffb01 	b.ne	1119c70 <vm_map_param+0x124>  // b.any
		m++;
 1119d14:	91000739 	add	x25, x25, #0x1
		if (n != m)
 1119d18:	eb1b033f 	cmp	x25, x27
 1119d1c:	54fffb60 	b.eq	1119c88 <vm_map_param+0x13c>  // b.none
			mem[m] = mem[n];
 1119d20:	9b1c7f20 	mul	x0, x25, x28
 1119d24:	f9400261 	ldr	x1, [x19]
 1119d28:	f8206b41 	str	x1, [x26, x0]
 1119d2c:	8b000340 	add	x0, x26, x0
 1119d30:	f9400661 	ldr	x1, [x19, #8]
 1119d34:	f9000401 	str	x1, [x0, #8]
 1119d38:	f9400a61 	ldr	x1, [x19, #16]
 1119d3c:	f9000801 	str	x1, [x0, #16]
 1119d40:	17ffffd2 	b	1119c88 <vm_map_param+0x13c>
		assert(!(r->flags & VM_FLAG_EPHEMERAL));
 1119d44:	79404401 	ldrh	w1, [x0, #34]
 1119d48:	36000141 	tbz	w1, #0, 1119d70 <vm_map_param+0x224>
 1119d4c:	900001e3 	adrp	x3, 1155000 <__func__.3826+0xa8>
 1119d50:	900001e1 	adrp	x1, 1155000 <__func__.3826+0xa8>
 1119d54:	910f1463 	add	x3, x3, #0x3c5
 1119d58:	91093421 	add	x1, x1, #0x24d
 1119d5c:	900001e0 	adrp	x0, 1155000 <__func__.3826+0xa8>
 1119d60:	910be800 	add	x0, x0, #0x2fa
 1119d64:	52806ae2 	mov	w2, #0x357                 	// #855
 1119d68:	97ffe151 	bl	11122ac <_assert_log>
 1119d6c:	97ffe161 	bl	11122f0 <_assert_break>
	TAILQ_FOREACH(r, &uctx->vm_info.regions, link)
 1119d70:	f9401400 	ldr	x0, [x0, #40]
 1119d74:	17ffffcd 	b	1119ca8 <vm_map_param+0x15c>
		vaddr_t va = 0;
 1119d78:	a9007fff 	stp	xzr, xzr, [sp]
 1119d7c:	aa1b03e1 	mov	x1, x27
 1119d80:	aa1403e0 	mov	x0, x20
 1119d84:	a9400ae5 	ldp	x5, x2, [x23]
 1119d88:	d2800007 	mov	x7, #0x0                   	// #0
 1119d8c:	f9400ae6 	ldr	x6, [x23, #16]
 1119d90:	528000a4 	mov	w4, #0x5                   	// #5
 1119d94:	52803603 	mov	w3, #0x1b0                 	// #432
 1119d98:	910062f7 	add	x23, x23, #0x18
 1119d9c:	f90047ff 	str	xzr, [sp, #136]
	if (prot & ~TEE_MATTR_PROT_MASK)
 1119da0:	97ffff06 	bl	11199b8 <vm_map_pad.part.0>
 1119da4:	2a0003f3 	mov	w19, w0
		if (res)
 1119da8:	35fffa40 	cbnz	w0, 1119cf0 <vm_map_param+0x1a4>
	for (n = 0; n < m; n++) {
 1119dac:	9100075a 	add	x26, x26, #0x1
 1119db0:	17ffffc1 	b	1119cb4 <vm_map_param+0x168>
		if (!(region->flags & VM_FLAG_EPHEMERAL))
 1119db4:	79404660 	ldrh	w0, [x19, #34]
 1119db8:	36000480 	tbz	w0, #0, 1119e48 <vm_map_param+0x2fc>
		if (mem->mobj != region->mobj)
 1119dbc:	f9400261 	ldr	x1, [x19]
 1119dc0:	f94002a0 	ldr	x0, [x21]
 1119dc4:	eb01001f 	cmp	x0, x1
 1119dc8:	54000401 	b.ne	1119e48 <vm_map_param+0x2fc>  // b.any
		phys_offs = mobj_get_phys_offs(mem->mobj,
 1119dcc:	97fffc93 	bl	1119018 <mobj_get_phys_offs.constprop.0>
		phys_offs += mem->offs;
 1119dd0:	f9400aa1 	ldr	x1, [x21, #16]
		if (phys_offs < region->offset)
 1119dd4:	f9400662 	ldr	x2, [x19, #8]
		phys_offs += mem->offs;
 1119dd8:	8b010001 	add	x1, x0, x1
		if (phys_offs < region->offset)
 1119ddc:	eb02003f 	cmp	x1, x2
 1119de0:	54000343 	b.cc	1119e48 <vm_map_param+0x2fc>  // b.lo, b.ul, b.last
		if (phys_offs >= (region->offset + region->size))
 1119de4:	f9400e60 	ldr	x0, [x19, #24]
 1119de8:	8b000040 	add	x0, x2, x0
 1119dec:	eb00003f 	cmp	x1, x0
 1119df0:	540002c2 	b.cs	1119e48 <vm_map_param+0x2fc>  // b.hs, b.nlast
		va = region->va + phys_offs - region->offset;
 1119df4:	f9400a60 	ldr	x0, [x19, #16]
 1119df8:	cb020000 	sub	x0, x0, x2
 1119dfc:	8b010000 	add	x0, x0, x1
		*user_va = (void *)va;
 1119e00:	f8377b00 	str	x0, [x24, x23, lsl #3]
	for (n = 0; n < TEE_NUM_PARAMS; n++) {
 1119e04:	910006f7 	add	x23, x23, #0x1
 1119e08:	910062b5 	add	x21, x21, #0x18
 1119e0c:	f10012ff 	cmp	x23, #0x4
 1119e10:	54fff581 	b.ne	1119cc0 <vm_map_param+0x174>  // b.any
	res = alloc_pgt(uctx);
 1119e14:	aa1403e0 	mov	x0, x20
 1119e18:	97fffc04 	bl	1118e28 <alloc_pgt>
 1119e1c:	2a0003f3 	mov	w19, w0
	if (res)
 1119e20:	35fff680 	cbnz	w0, 1119cf0 <vm_map_param+0x1a4>
}
 1119e24:	2a1303e0 	mov	w0, w19
 1119e28:	a9417bfd 	ldp	x29, x30, [sp, #16]
 1119e2c:	a94253f3 	ldp	x19, x20, [sp, #32]
 1119e30:	a9435bf5 	ldp	x21, x22, [sp, #48]
 1119e34:	a94463f7 	ldp	x23, x24, [sp, #64]
 1119e38:	a9456bf9 	ldp	x25, x26, [sp, #80]
 1119e3c:	a94673fb 	ldp	x27, x28, [sp, #96]
 1119e40:	9103c3ff 	add	sp, sp, #0xf0
 1119e44:	d65f03c0 	ret
	TAILQ_FOREACH(region, &uctx->vm_info.regions, link) {
 1119e48:	f9401673 	ldr	x19, [x19, #40]
 1119e4c:	17ffffa7 	b	1119ce8 <vm_map_param+0x19c>

0000000001119e50 <vm_info_init>:
{
 1119e50:	d101c3ff 	sub	sp, sp, #0x70
 1119e54:	a9017bfd 	stp	x29, x30, [sp, #16]
 1119e58:	910043fd 	add	x29, sp, #0x10
 1119e5c:	a90253f3 	stp	x19, x20, [sp, #32]
 1119e60:	aa0003f3 	mov	x19, x0
 1119e64:	a9035bf5 	stp	x21, x22, [sp, #48]
 1119e68:	a90463f7 	stp	x23, x24, [sp, #64]
	uint32_t asid = asid_alloc();
 1119e6c:	97ffc057 	bl	1109fc8 <asid_alloc>
	if (!asid) {
 1119e70:	35000220 	cbnz	w0, 1119eb4 <vm_info_init+0x64>
		return TEE_ERROR_GENERIC;
 1119e74:	52bffff4 	mov	w20, #0xffff0000            	// #-65536
		DMSG("Failed to allocate ASID");
 1119e78:	900001e4 	adrp	x4, 1155000 <__func__.3826+0xa8>
 1119e7c:	52800023 	mov	w3, #0x1                   	// #1
 1119e80:	910c6884 	add	x4, x4, #0x31a
 1119e84:	52800062 	mov	w2, #0x3                   	// #3
 1119e88:	528066e1 	mov	w1, #0x337                 	// #823
 1119e8c:	900001e0 	adrp	x0, 1155000 <__func__.3826+0xa8>
 1119e90:	910ee000 	add	x0, x0, #0x3b8
 1119e94:	9400abac 	bl	1144d44 <trace_printf>
}
 1119e98:	2a1403e0 	mov	w0, w20
 1119e9c:	a9417bfd 	ldp	x29, x30, [sp, #16]
 1119ea0:	a94253f3 	ldp	x19, x20, [sp, #32]
 1119ea4:	a9435bf5 	ldp	x21, x22, [sp, #48]
 1119ea8:	a94463f7 	ldp	x23, x24, [sp, #64]
 1119eac:	9101c3ff 	add	sp, sp, #0x70
 1119eb0:	d65f03c0 	ret
	TAILQ_INIT(&uctx->vm_info.regions);
 1119eb4:	a9004e7f 	stp	xzr, x19, [x19]
	thread_get_user_kcode(&mobj, &offs, &va, &sz);
 1119eb8:	9101a3f6 	add	x22, sp, #0x68
 1119ebc:	910183f5 	add	x21, sp, #0x60
	uctx->vm_info.asid = asid;
 1119ec0:	b9001260 	str	w0, [x19, #16]
	thread_get_user_kcode(&mobj, &offs, &va, &sz);
 1119ec4:	910163f7 	add	x23, sp, #0x58
	memset(&uctx->vm_info, 0, sizeof(uctx->vm_info));
 1119ec8:	3900527f 	strb	wzr, [x19, #20]
	thread_get_user_kcode(&mobj, &offs, &va, &sz);
 1119ecc:	910143f8 	add	x24, sp, #0x50
	memset(&uctx->vm_info, 0, sizeof(uctx->vm_info));
 1119ed0:	3900567f 	strb	wzr, [x19, #21]
	thread_get_user_kcode(&mobj, &offs, &va, &sz);
 1119ed4:	aa1503e2 	mov	x2, x21
	memset(&uctx->vm_info, 0, sizeof(uctx->vm_info));
 1119ed8:	39005a7f 	strb	wzr, [x19, #22]
	thread_get_user_kcode(&mobj, &offs, &va, &sz);
 1119edc:	aa1603e3 	mov	x3, x22
	memset(&uctx->vm_info, 0, sizeof(uctx->vm_info));
 1119ee0:	39005e7f 	strb	wzr, [x19, #23]
	thread_get_user_kcode(&mobj, &offs, &va, &sz);
 1119ee4:	aa1703e1 	mov	x1, x23
 1119ee8:	aa1803e0 	mov	x0, x24
 1119eec:	97ffb0dd 	bl	1106260 <thread_get_user_kcode>
	if (sz) {
 1119ef0:	f94037e2 	ldr	x2, [sp, #104]
 1119ef4:	b5000262 	cbnz	x2, 1119f40 <vm_info_init+0xf0>
	thread_get_user_kdata(&mobj, &offs, &va, &sz);
 1119ef8:	aa1503e2 	mov	x2, x21
 1119efc:	aa1603e3 	mov	x3, x22
 1119f00:	aa1703e1 	mov	x1, x23
 1119f04:	aa1803e0 	mov	x0, x24
 1119f08:	97ffb0f0 	bl	11062c8 <thread_get_user_kdata>
	if (sz)
 1119f0c:	f94037e2 	ldr	x2, [sp, #104]
 1119f10:	b4000322 	cbz	x2, 1119f74 <vm_info_init+0x124>
	if (prot & ~TEE_MATTR_PROT_MASK)
 1119f14:	a9451be5 	ldp	x5, x6, [sp, #80]
 1119f18:	a9007fff 	stp	xzr, xzr, [sp]
 1119f1c:	aa1503e1 	mov	x1, x21
 1119f20:	aa1303e0 	mov	x0, x19
 1119f24:	d2800007 	mov	x7, #0x0                   	// #0
 1119f28:	52800044 	mov	w4, #0x2                   	// #2
 1119f2c:	52800603 	mov	w3, #0x30                  	// #48
 1119f30:	97fffea2 	bl	11199b8 <vm_map_pad.part.0>
 1119f34:	2a0003f4 	mov	w20, w0
	if (res)
 1119f38:	34fffb00 	cbz	w0, 1119e98 <vm_info_init+0x48>
 1119f3c:	1400000b 	b	1119f68 <vm_info_init+0x118>
	if (prot & ~TEE_MATTR_PROT_MASK)
 1119f40:	a9451be5 	ldp	x5, x6, [sp, #80]
 1119f44:	a9007fff 	stp	xzr, xzr, [sp]
 1119f48:	aa1503e1 	mov	x1, x21
 1119f4c:	aa1303e0 	mov	x0, x19
 1119f50:	d2800007 	mov	x7, #0x0                   	// #0
 1119f54:	52800044 	mov	w4, #0x2                   	// #2
 1119f58:	52800a03 	mov	w3, #0x50                  	// #80
 1119f5c:	97fffe97 	bl	11199b8 <vm_map_pad.part.0>
 1119f60:	2a0003f4 	mov	w20, w0
		if (res)
 1119f64:	34fffca0 	cbz	w0, 1119ef8 <vm_info_init+0xa8>
		vm_info_final(uctx);
 1119f68:	aa1303e0 	mov	x0, x19
 1119f6c:	97fffd4d 	bl	11194a0 <vm_info_final>
 1119f70:	17ffffca 	b	1119e98 <vm_info_init+0x48>
	return TEE_SUCCESS;
 1119f74:	52800014 	mov	w20, #0x0                   	// #0
 1119f78:	17ffffc8 	b	1119e98 <vm_info_init+0x48>

0000000001119f7c <vm_remap>:
{
 1119f7c:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
 1119f80:	910003fd 	mov	x29, sp
 1119f84:	a90153f3 	stp	x19, x20, [sp, #16]
 1119f88:	aa0003f4 	mov	x20, x0
 1119f8c:	a9025bf5 	stp	x21, x22, [sp, #32]
 1119f90:	aa0203f5 	mov	x21, x2
 1119f94:	a90363f7 	stp	x23, x24, [sp, #48]
 1119f98:	aa0103f8 	mov	x24, x1
 1119f9c:	aa0303f7 	mov	x23, x3
 1119fa0:	a9046bf9 	stp	x25, x26, [sp, #64]
	struct vm_region_head regs = TAILQ_HEAD_INITIALIZER(regs);
 1119fa4:	910203f9 	add	x25, sp, #0x80
{
 1119fa8:	a90573fb 	stp	x27, x28, [sp, #80]
 1119fac:	a90617e4 	stp	x4, x5, [sp, #96]
	struct vm_region_head regs = TAILQ_HEAD_INITIALIZER(regs);
 1119fb0:	a907ffff 	stp	xzr, xzr, [sp, #120]
 1119fb4:	f90047f9 	str	x25, [sp, #136]
	assert(thread_get_tsd()->ctx == uctx->ts_ctx);
 1119fb8:	97ffaf02 	bl	1105bc0 <thread_get_tsd>
 1119fbc:	f9400801 	ldr	x1, [x0, #16]
 1119fc0:	f9412280 	ldr	x0, [x20, #576]
 1119fc4:	eb00003f 	cmp	x1, x0
 1119fc8:	54000140 	b.eq	1119ff0 <vm_remap+0x74>  // b.none
 1119fcc:	900001e3 	adrp	x3, 1155000 <__func__.3826+0xa8>
 1119fd0:	900001e1 	adrp	x1, 1155000 <__func__.3826+0xa8>
 1119fd4:	910e6863 	add	x3, x3, #0x39a
 1119fd8:	91093421 	add	x1, x1, #0x24d
 1119fdc:	900001e0 	adrp	x0, 1155000 <__func__.3826+0xa8>
 1119fe0:	910abc00 	add	x0, x0, #0x2af
 1119fe4:	52804262 	mov	w2, #0x213                 	// #531
 1119fe8:	97ffe0b1 	bl	11122ac <_assert_log>
 1119fec:	97ffe0c1 	bl	11122f0 <_assert_break>
	if (!len || ((len | old_va) & SMALL_PAGE_MASK))
 1119ff0:	b4001617 	cbz	x23, 111a2b0 <vm_remap+0x334>
 1119ff4:	aa1502e0 	orr	x0, x23, x21
 1119ff8:	f2402c1f 	tst	x0, #0xfff
 1119ffc:	540015a1 	b.ne	111a2b0 <vm_remap+0x334>  // b.any
	res = split_vm_range(uctx, old_va, len, cmp_region_for_remap, &r0);
 111a000:	9101e3e4 	add	x4, sp, #0x78
 111a004:	aa1703e2 	mov	x2, x23
 111a008:	aa1503e1 	mov	x1, x21
 111a00c:	aa1403e0 	mov	x0, x20
 111a010:	d0ffffe3 	adrp	x3, 1118000 <mobj_phys_get_va+0x34>
 111a014:	912cc063 	add	x3, x3, #0xb30
 111a018:	97fffc76 	bl	11191f0 <split_vm_range>
 111a01c:	2a0003f6 	mov	w22, w0
	if (res)
 111a020:	350001e0 	cbnz	w0, 111a05c <vm_remap+0xe0>
	if (mobj_is_paged(r0->mobj)) {
 111a024:	f9403ff3 	ldr	x19, [sp, #120]
		if (r->va + r->size > old_va + len)
 111a028:	8b1502fc 	add	x28, x23, x21
	for (r = r0; r; r = r_next) {
 111a02c:	b5000293 	cbnz	x19, 111a07c <vm_remap+0x100>
	vm_set_ctx(uctx->ts_ctx);
 111a030:	f9412280 	ldr	x0, [x20, #576]
	struct vm_region *r_last = NULL;
 111a034:	d2800013 	mov	x19, #0x0                   	// #0
	vm_set_ctx(uctx->ts_ctx);
 111a038:	97fffe29 	bl	11198dc <vm_set_ctx>
	r_first = TAILQ_FIRST(&regs);
 111a03c:	f94043fc 	ldr	x28, [sp, #128]
	while (!TAILQ_EMPTY(&regs)) {
 111a040:	aa1303fa 	mov	x26, x19
 111a044:	f94043f3 	ldr	x19, [sp, #128]
 111a048:	b5000473 	cbnz	x19, 111a0d4 <vm_remap+0x158>
	vm_set_ctx(uctx->ts_ctx);
 111a04c:	f9412280 	ldr	x0, [x20, #576]
 111a050:	97fffe23 	bl	11198dc <vm_set_ctx>
	*new_va = r_first->va;
 111a054:	f9400b80 	ldr	x0, [x28, #16]
 111a058:	f9000300 	str	x0, [x24]
}
 111a05c:	2a1603e0 	mov	w0, w22
 111a060:	a94153f3 	ldp	x19, x20, [sp, #16]
 111a064:	a9425bf5 	ldp	x21, x22, [sp, #32]
 111a068:	a94363f7 	ldp	x23, x24, [sp, #48]
 111a06c:	a9446bf9 	ldp	x25, x26, [sp, #64]
 111a070:	a94573fb 	ldp	x27, x28, [sp, #80]
 111a074:	a8c97bfd 	ldp	x29, x30, [sp], #144
 111a078:	d65f03c0 	ret
		if (r->va + r->size > old_va + len)
 111a07c:	a9410660 	ldp	x0, x1, [x19, #16]
 111a080:	8b010000 	add	x0, x0, x1
 111a084:	eb1c001f 	cmp	x0, x28
 111a088:	54fffd48 	b.hi	111a030 <vm_remap+0xb4>  // b.pmore
		rem_um_region(uctx, r);
 111a08c:	aa1303e1 	mov	x1, x19
 111a090:	aa1403e0 	mov	x0, x20
		r_next = TAILQ_NEXT(r, link);
 111a094:	f940167a 	ldr	x26, [x19, #40]
		rem_um_region(uctx, r);
 111a098:	97fffb88 	bl	1118eb8 <rem_um_region>
		TAILQ_REMOVE(&uctx->vm_info.regions, r, link);
 111a09c:	a9428660 	ldp	x0, x1, [x19, #40]
 111a0a0:	b4000160 	cbz	x0, 111a0cc <vm_remap+0x150>
 111a0a4:	f9001801 	str	x1, [x0, #48]
 111a0a8:	f9401a61 	ldr	x1, [x19, #48]
 111a0ac:	f9000020 	str	x0, [x1]
		TAILQ_INSERT_TAIL(&regs, r, link);
 111a0b0:	f94047e0 	ldr	x0, [sp, #136]
 111a0b4:	a902827f 	stp	xzr, x0, [x19, #40]
 111a0b8:	f9000013 	str	x19, [x0]
 111a0bc:	9100a273 	add	x19, x19, #0x28
 111a0c0:	f90047f3 	str	x19, [sp, #136]
	for (r = r0; r; r = r_next) {
 111a0c4:	aa1a03f3 	mov	x19, x26
 111a0c8:	17ffffd9 	b	111a02c <vm_remap+0xb0>
		TAILQ_REMOVE(&uctx->vm_info.regions, r, link);
 111a0cc:	f9000681 	str	x1, [x20, #8]
 111a0d0:	17fffff6 	b	111a0a8 <vm_remap+0x12c>
		TAILQ_REMOVE(&regs, r, link);
 111a0d4:	a9428660 	ldp	x0, x1, [x19, #40]
 111a0d8:	b4000520 	cbz	x0, 111a17c <vm_remap+0x200>
 111a0dc:	f9001801 	str	x1, [x0, #48]
 111a0e0:	f9401a61 	ldr	x1, [x19, #48]
 111a0e4:	f9000020 	str	x0, [x1]
		if (r_last) {
 111a0e8:	b40004fa 	cbz	x26, 111a184 <vm_remap+0x208>
			r->va = r_last->va + r_last->size;
 111a0ec:	a9410740 	ldp	x0, x1, [x26, #16]
			res = umap_add_region(&uctx->vm_info, r, 0, 0, 0);
 111a0f0:	d2800004 	mov	x4, #0x0                   	// #0
 111a0f4:	d2800003 	mov	x3, #0x0                   	// #0
 111a0f8:	d2800002 	mov	x2, #0x0                   	// #0
			r->va = r_last->va + r_last->size;
 111a0fc:	8b010000 	add	x0, x0, x1
 111a100:	f9000a60 	str	x0, [x19, #16]
			res = umap_add_region(&uctx->vm_info, r, pad_begin,
 111a104:	aa1303e1 	mov	x1, x19
 111a108:	aa1403e0 	mov	x0, x20
 111a10c:	97fffae3 	bl	1118c98 <umap_add_region>
 111a110:	2a0003fb 	mov	w27, w0
		if (!res)
 111a114:	34000d20 	cbz	w0, 111a2b8 <vm_remap+0x33c>
			if (r != r_last) {
 111a118:	eb1a027f 	cmp	x19, x26
 111a11c:	54000100 	b.eq	111a13c <vm_remap+0x1c0>  // b.none
				TAILQ_INSERT_HEAD(&regs, r, link);
 111a120:	aa1303e0 	mov	x0, x19
 111a124:	f94043e1 	ldr	x1, [sp, #128]
 111a128:	f8028c01 	str	x1, [x0, #40]!
 111a12c:	b40003e1 	cbz	x1, 111a1a8 <vm_remap+0x22c>
 111a130:	f9001820 	str	x0, [x1, #48]
 111a134:	f9001a79 	str	x25, [x19, #48]
 111a138:	f90043f3 	str	x19, [sp, #128]
 111a13c:	f94047e3 	ldr	x3, [sp, #136]
					TAILQ_INSERT_HEAD(&regs, r, link);
 111a140:	52800004 	mov	w4, #0x0                   	// #0
 111a144:	d2800000 	mov	x0, #0x0                   	// #0
			for (r = r_first; r_last && r != r_last; r = r_next) {
 111a148:	f100035f 	cmp	x26, #0x0
 111a14c:	1a9f07e1 	cset	w1, ne  // ne = any
 111a150:	eb1a039f 	cmp	x28, x26
 111a154:	1a9f1021 	csel	w1, w1, wzr, ne  // ne = any
 111a158:	350002c1 	cbnz	w1, 111a1b0 <vm_remap+0x234>
 111a15c:	34000044 	cbz	w4, 111a164 <vm_remap+0x1e8>
 111a160:	f90047e3 	str	x3, [sp, #136]
	while (!TAILQ_EMPTY(&regs)) {
 111a164:	f94043e1 	ldr	x1, [sp, #128]
 111a168:	b5000621 	cbnz	x1, 111a22c <vm_remap+0x2b0>
	vm_set_ctx(uctx->ts_ctx);
 111a16c:	f9412280 	ldr	x0, [x20, #576]
	return res;
 111a170:	2a1b03f6 	mov	w22, w27
	vm_set_ctx(uctx->ts_ctx);
 111a174:	97fffdda 	bl	11198dc <vm_set_ctx>
	return res;
 111a178:	17ffffb9 	b	111a05c <vm_remap+0xe0>
		TAILQ_REMOVE(&regs, r, link);
 111a17c:	f90047e1 	str	x1, [sp, #136]
 111a180:	17ffffd8 	b	111a0e0 <vm_remap+0x164>
			r->va = *new_va;
 111a184:	f9400300 	ldr	x0, [x24]
 111a188:	f9000a60 	str	x0, [x19, #16]
			res = umap_add_region(&uctx->vm_info, r, pad_begin,
 111a18c:	f9400e63 	ldr	x3, [x19, #24]
 111a190:	d2800004 	mov	x4, #0x0                   	// #0
 111a194:	f94037e0 	ldr	x0, [sp, #104]
 111a198:	f94033e2 	ldr	x2, [sp, #96]
 111a19c:	cb030003 	sub	x3, x0, x3
 111a1a0:	8b170063 	add	x3, x3, x23
 111a1a4:	17ffffd8 	b	111a104 <vm_remap+0x188>
				TAILQ_INSERT_HEAD(&regs, r, link);
 111a1a8:	f90047e0 	str	x0, [sp, #136]
 111a1ac:	17ffffe2 	b	111a134 <vm_remap+0x1b8>
				r_next = TAILQ_NEXT(r, link);
 111a1b0:	a9428b87 	ldp	x7, x2, [x28, #40]
				TAILQ_REMOVE(&uctx->vm_info.regions, r, link);
 111a1b4:	b4000267 	cbz	x7, 111a200 <vm_remap+0x284>
 111a1b8:	f90018e2 	str	x2, [x7, #48]
 111a1bc:	f9401b82 	ldr	x2, [x28, #48]
 111a1c0:	f9000047 	str	x7, [x2]
				if (r_tmp)
 111a1c4:	9100a382 	add	x2, x28, #0x28
 111a1c8:	b4000200 	cbz	x0, 111a208 <vm_remap+0x28c>
					TAILQ_INSERT_AFTER(&regs, r_tmp, r,
 111a1cc:	f9401408 	ldr	x8, [x0, #40]
 111a1d0:	f9001788 	str	x8, [x28, #40]
 111a1d4:	b4000088 	cbz	x8, 111a1e4 <vm_remap+0x268>
 111a1d8:	2a0403e1 	mov	w1, w4
 111a1dc:	f9001902 	str	x2, [x8, #48]
 111a1e0:	aa0303e2 	mov	x2, x3
 111a1e4:	f8028c1c 	str	x28, [x0, #40]!
 111a1e8:	f9001b80 	str	x0, [x28, #48]
					TAILQ_INSERT_HEAD(&regs, r, link);
 111a1ec:	aa1c03e0 	mov	x0, x28
 111a1f0:	2a0103e4 	mov	w4, w1
 111a1f4:	aa0203e3 	mov	x3, x2
				r_next = TAILQ_NEXT(r, link);
 111a1f8:	aa0703fc 	mov	x28, x7
 111a1fc:	17ffffd3 	b	111a148 <vm_remap+0x1cc>
				TAILQ_REMOVE(&uctx->vm_info.regions, r, link);
 111a200:	f9000682 	str	x2, [x20, #8]
 111a204:	17ffffee 	b	111a1bc <vm_remap+0x240>
					TAILQ_INSERT_HEAD(&regs, r, link);
 111a208:	f94043e0 	ldr	x0, [sp, #128]
 111a20c:	f9001780 	str	x0, [x28, #40]
 111a210:	b4000080 	cbz	x0, 111a220 <vm_remap+0x2a4>
 111a214:	2a0403e1 	mov	w1, w4
 111a218:	f9001802 	str	x2, [x0, #48]
 111a21c:	aa0303e2 	mov	x2, x3
 111a220:	f9001b99 	str	x25, [x28, #48]
 111a224:	f90043fc 	str	x28, [sp, #128]
 111a228:	17fffff1 	b	111a1ec <vm_remap+0x270>
		TAILQ_REMOVE(&regs, r, link);
 111a22c:	a9428820 	ldp	x0, x2, [x1, #40]
 111a230:	b40002a0 	cbz	x0, 111a284 <vm_remap+0x308>
 111a234:	f9001802 	str	x2, [x0, #48]
 111a238:	f9401822 	ldr	x2, [x1, #48]
		if (umap_add_region(&uctx->vm_info, r, 0, 0, 0))
 111a23c:	d2800004 	mov	x4, #0x0                   	// #0
 111a240:	d2800003 	mov	x3, #0x0                   	// #0
		TAILQ_REMOVE(&regs, r, link);
 111a244:	f9000040 	str	x0, [x2]
		if (umap_add_region(&uctx->vm_info, r, 0, 0, 0))
 111a248:	d2800002 	mov	x2, #0x0                   	// #0
		next_va += r->size;
 111a24c:	f9400c20 	ldr	x0, [x1, #24]
		r->va = next_va;
 111a250:	f9000835 	str	x21, [x1, #16]
		next_va += r->size;
 111a254:	8b0002b5 	add	x21, x21, x0
		if (umap_add_region(&uctx->vm_info, r, 0, 0, 0))
 111a258:	aa1403e0 	mov	x0, x20
 111a25c:	97fffa8f 	bl	1118c98 <umap_add_region>
 111a260:	34000160 	cbz	w0, 111a28c <vm_remap+0x310>
			panic("Cannot restore mapping");
 111a264:	f00001c3 	adrp	x3, 1155000 <__func__.3826+0xa8>
 111a268:	f00001c2 	adrp	x2, 1155000 <__func__.3826+0xa8>
 111a26c:	910cc863 	add	x3, x3, #0x332
 111a270:	910e6842 	add	x2, x2, #0x39a
 111a274:	52804e21 	mov	w1, #0x271                 	// #625
			panic("Cannot restore mapping");
 111a278:	f00001c0 	adrp	x0, 1155000 <__func__.3826+0xa8>
 111a27c:	91093400 	add	x0, x0, #0x24d
 111a280:	97ffe47a 	bl	1113468 <__do_panic>
		TAILQ_REMOVE(&regs, r, link);
 111a284:	f90047e2 	str	x2, [sp, #136]
 111a288:	17ffffec 	b	111a238 <vm_remap+0x2bc>
		if (alloc_pgt(uctx))
 111a28c:	aa1403e0 	mov	x0, x20
 111a290:	97fffae6 	bl	1118e28 <alloc_pgt>
 111a294:	34fff680 	cbz	w0, 111a164 <vm_remap+0x1e8>
			panic("Cannot restore mapping");
 111a298:	f00001c3 	adrp	x3, 1155000 <__func__.3826+0xa8>
 111a29c:	f00001c2 	adrp	x2, 1155000 <__func__.3826+0xa8>
 111a2a0:	910cc863 	add	x3, x3, #0x332
 111a2a4:	910e6842 	add	x2, x2, #0x39a
 111a2a8:	52804e61 	mov	w1, #0x273                 	// #627
 111a2ac:	17fffff3 	b	111a278 <vm_remap+0x2fc>
		return TEE_ERROR_BAD_PARAMETERS;
 111a2b0:	129fff36 	mov	w22, #0xffff0006            	// #-65530
 111a2b4:	17ffff6a 	b	111a05c <vm_remap+0xe0>
			res = alloc_pgt(uctx);
 111a2b8:	aa1403e0 	mov	x0, x20
 111a2bc:	97fffadb 	bl	1118e28 <alloc_pgt>
 111a2c0:	2a0003fb 	mov	w27, w0
		if (res) {
 111a2c4:	34ffebe0 	cbz	w0, 111a040 <vm_remap+0xc4>
	while (!TAILQ_EMPTY(&regs)) {
 111a2c8:	aa1303fa 	mov	x26, x19
 111a2cc:	17ffff9c 	b	111a13c <vm_remap+0x1c0>

000000000111a2d0 <vm_set_prot>:
{
 111a2d0:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
 111a2d4:	910003fd 	mov	x29, sp
 111a2d8:	a90363f7 	stp	x23, x24, [sp, #48]
 111a2dc:	aa0003f7 	mov	x23, x0
 111a2e0:	a90153f3 	stp	x19, x20, [sp, #16]
 111a2e4:	aa0203f3 	mov	x19, x2
 111a2e8:	2a0303f4 	mov	w20, w3
 111a2ec:	a9025bf5 	stp	x21, x22, [sp, #32]
 111a2f0:	aa0103f6 	mov	x22, x1
 111a2f4:	a9046bf9 	stp	x25, x26, [sp, #64]
	struct vm_region *r0 = NULL;
 111a2f8:	f9002fff 	str	xzr, [sp, #88]
	assert(thread_get_tsd()->ctx == uctx->ts_ctx);
 111a2fc:	97ffae31 	bl	1105bc0 <thread_get_tsd>
 111a300:	f9400801 	ldr	x1, [x0, #16]
 111a304:	f94122e0 	ldr	x0, [x23, #576]
 111a308:	eb00003f 	cmp	x1, x0
 111a30c:	54000140 	b.eq	111a334 <vm_set_prot+0x64>  // b.none
 111a310:	f00001c3 	adrp	x3, 1155000 <__func__.3826+0xa8>
 111a314:	f00001c1 	adrp	x1, 1155000 <__func__.3826+0xa8>
 111a318:	910e8c63 	add	x3, x3, #0x3a3
 111a31c:	91093421 	add	x1, x1, #0x24d
 111a320:	f00001c0 	adrp	x0, 1155000 <__func__.3826+0xa8>
 111a324:	910abc00 	add	x0, x0, #0x2af
 111a328:	528057a2 	mov	w2, #0x2bd                 	// #701
 111a32c:	97ffdfe0 	bl	11122ac <_assert_log>
 111a330:	97ffdff0 	bl	11122f0 <_assert_break>
	if (prot & ~TEE_MATTR_PROT_MASK || !len)
 111a334:	7216669f 	tst	w20, #0xfffffc0f
 111a338:	54000bc1 	b.ne	111a4b0 <vm_set_prot+0x1e0>  // b.any
 111a33c:	b4000bb3 	cbz	x19, 111a4b0 <vm_set_prot+0x1e0>
	res = split_vm_range(uctx, va, len, NULL, &r0);
 111a340:	910163e4 	add	x4, sp, #0x58
 111a344:	aa1303e2 	mov	x2, x19
 111a348:	aa1603e1 	mov	x1, x22
 111a34c:	aa1703e0 	mov	x0, x23
 111a350:	d2800003 	mov	x3, #0x0                   	// #0
 111a354:	97fffba7 	bl	11191f0 <split_vm_range>
 111a358:	2a0003f8 	mov	w24, w0
	if (res)
 111a35c:	35000ac0 	cbnz	w0, 111a4b4 <vm_set_prot+0x1e4>
	for (r = r0; r; r = TAILQ_NEXT(r, link)) {
 111a360:	f9402fe1 	ldr	x1, [sp, #88]
 111a364:	8b160275 	add	x21, x19, x22
	bool need_sync = false;
 111a368:	5280001a 	mov	w26, #0x0                   	// #0
	bool was_writeable = false;
 111a36c:	52800019 	mov	w25, #0x0                   	// #0
		if (r->attr & (TEE_MATTR_UW | TEE_MATTR_PW))
 111a370:	52802402 	mov	w2, #0x120                 	// #288
			was_writeable = true;
 111a374:	52800023 	mov	w3, #0x1                   	// #1
	for (r = r0; r; r = TAILQ_NEXT(r, link)) {
 111a378:	b50006c1 	cbnz	x1, 111a450 <vm_set_prot+0x180>
	if (need_sync) {
 111a37c:	3400007a 	cbz	w26, 111a388 <vm_set_prot+0xb8>
		vm_set_ctx(uctx->ts_ctx);
 111a380:	f94122e0 	ldr	x0, [x23, #576]
 111a384:	97fffd56 	bl	11198dc <vm_set_ctx>
	for (r = r0; r; r = TAILQ_NEXT(r, link)) {
 111a388:	f9402ff4 	ldr	x20, [sp, #88]
 111a38c:	b50007d4 	cbnz	x20, 111a484 <vm_set_prot+0x1b4>
	if (need_sync && was_writeable)
 111a390:	7100033f 	cmp	w25, #0x0
 111a394:	7a401b44 	ccmp	w26, #0x0, #0x4, ne  // ne = any
 111a398:	540000a0 	b.eq	111a3ac <vm_set_prot+0xdc>  // b.none
		cache_op_inner(ICACHE_INVALIDATE, NULL, 0);
 111a39c:	d2800002 	mov	x2, #0x0                   	// #0
 111a3a0:	d2800001 	mov	x1, #0x0                   	// #0
 111a3a4:	52800080 	mov	w0, #0x4                   	// #4
 111a3a8:	97ffbd25 	bl	110983c <cache_op_inner>
	if (ADD_OVERFLOW(va, len, &end_va))
 111a3ac:	ab1302d5 	adds	x21, x22, x19
 111a3b0:	54000822 	b.cs	111a4b4 <vm_set_prot+0x1e4>  // b.hs, b.nlast
	for (r = TAILQ_FIRST(&uctx->vm_info.regions);; r = r_next) {
 111a3b4:	f94002f4 	ldr	x20, [x23]
		r_next = TAILQ_NEXT(r, link);
 111a3b8:	f9401693 	ldr	x19, [x20, #40]
		if (!r_next)
 111a3bc:	b40007d3 	cbz	x19, 111a4b4 <vm_set_prot+0x1e4>
		if (r->va + r->size < va)
 111a3c0:	a9410a81 	ldp	x1, x2, [x20, #16]
 111a3c4:	8b020020 	add	x0, x1, x2
 111a3c8:	eb0002df 	cmp	x22, x0
 111a3cc:	540003e8 	b.hi	111a448 <vm_set_prot+0x178>  // b.pmore
		if (r->va > end_va)
 111a3d0:	eb0102bf 	cmp	x21, x1
 111a3d4:	54000703 	b.cc	111a4b4 <vm_set_prot+0x1e4>  // b.lo, b.ul, b.last
		if (r->va + r->size != r_next->va)
 111a3d8:	f9400a61 	ldr	x1, [x19, #16]
 111a3dc:	eb01001f 	cmp	x0, x1
 111a3e0:	54000341 	b.ne	111a448 <vm_set_prot+0x178>  // b.any
		if (r->mobj != r_next->mobj ||
 111a3e4:	f9400260 	ldr	x0, [x19]
 111a3e8:	f9400281 	ldr	x1, [x20]
 111a3ec:	eb00003f 	cmp	x1, x0
 111a3f0:	540002c1 	b.ne	111a448 <vm_set_prot+0x178>  // b.any
		    r->flags != r_next->flags ||
 111a3f4:	b9402261 	ldr	w1, [x19, #32]
 111a3f8:	b9402283 	ldr	w3, [x20, #32]
 111a3fc:	6b01007f 	cmp	w3, w1
 111a400:	54000241 	b.ne	111a448 <vm_set_prot+0x178>  // b.any
		if (r->offset + r->size != r_next->offset)
 111a404:	f9400681 	ldr	x1, [x20, #8]
 111a408:	f9400663 	ldr	x3, [x19, #8]
 111a40c:	8b010041 	add	x1, x2, x1
 111a410:	eb03003f 	cmp	x1, x3
 111a414:	540001a1 	b.ne	111a448 <vm_set_prot+0x178>  // b.any
 111a418:	a9428e61 	ldp	x1, x3, [x19, #40]
		TAILQ_REMOVE(&uctx->vm_info.regions, r_next, link);
 111a41c:	b4000461 	cbz	x1, 111a4a8 <vm_set_prot+0x1d8>
 111a420:	f9001823 	str	x3, [x1, #48]
 111a424:	f9401a63 	ldr	x3, [x19, #48]
 111a428:	f9000061 	str	x1, [x3]
		r->size += r_next->size;
 111a42c:	f9400e61 	ldr	x1, [x19, #24]
 111a430:	8b020021 	add	x1, x1, x2
 111a434:	f9000e81 	str	x1, [x20, #24]
		mobj_put(r_next->mobj);
 111a438:	97fffac8 	bl	1118f58 <mobj_put>
		free(r_next);
 111a43c:	aa1303e0 	mov	x0, x19
 111a440:	aa1403f3 	mov	x19, x20
 111a444:	9400a467 	bl	11435e0 <free>
 111a448:	aa1303f4 	mov	x20, x19
 111a44c:	17ffffdb 	b	111a3b8 <vm_set_prot+0xe8>
		if (r->va + r->size > va + len)
 111a450:	a9411020 	ldp	x0, x4, [x1, #16]
 111a454:	8b040000 	add	x0, x0, x4
 111a458:	eb15001f 	cmp	x0, x21
 111a45c:	54fff908 	b.hi	111a37c <vm_set_prot+0xac>  // b.pmore
		if (r->attr & (TEE_MATTR_UW | TEE_MATTR_PW))
 111a460:	79404020 	ldrh	w0, [x1, #32]
	for (r = r0; r; r = TAILQ_NEXT(r, link)) {
 111a464:	5280003a 	mov	w26, #0x1                   	// #1
			was_writeable = true;
 111a468:	6a02001f 	tst	w0, w2
		r->attr &= ~TEE_MATTR_PROT_MASK;
 111a46c:	12166400 	and	w0, w0, #0xfffffc0f
		r->attr |= prot;
 111a470:	2a140000 	orr	w0, w0, w20
			was_writeable = true;
 111a474:	1a830339 	csel	w25, w25, w3, eq  // eq = none
		r->attr |= prot;
 111a478:	79004020 	strh	w0, [x1, #32]
	for (r = r0; r; r = TAILQ_NEXT(r, link)) {
 111a47c:	f9401421 	ldr	x1, [x1, #40]
 111a480:	17ffffbe 	b	111a378 <vm_set_prot+0xa8>
		if (r->va + r->size > va + len)
 111a484:	a9410a81 	ldp	x1, x2, [x20, #16]
 111a488:	8b020020 	add	x0, x1, x2
 111a48c:	eb15001f 	cmp	x0, x21
 111a490:	54fff808 	b.hi	111a390 <vm_set_prot+0xc0>  // b.pmore
		} else if (was_writeable) {
 111a494:	34000079 	cbz	w25, 111a4a0 <vm_set_prot+0x1d0>
			cache_op_inner(DCACHE_AREA_CLEAN, (void *)r->va,
 111a498:	52800020 	mov	w0, #0x1                   	// #1
 111a49c:	97ffbce8 	bl	110983c <cache_op_inner>
	for (r = r0; r; r = TAILQ_NEXT(r, link)) {
 111a4a0:	f9401694 	ldr	x20, [x20, #40]
 111a4a4:	17ffffba 	b	111a38c <vm_set_prot+0xbc>
		TAILQ_REMOVE(&uctx->vm_info.regions, r_next, link);
 111a4a8:	f90006e3 	str	x3, [x23, #8]
 111a4ac:	17ffffde 	b	111a424 <vm_set_prot+0x154>
		return TEE_ERROR_BAD_PARAMETERS;
 111a4b0:	129fff38 	mov	w24, #0xffff0006            	// #-65530
}
 111a4b4:	2a1803e0 	mov	w0, w24
 111a4b8:	a94153f3 	ldp	x19, x20, [sp, #16]
 111a4bc:	a9425bf5 	ldp	x21, x22, [sp, #32]
 111a4c0:	a94363f7 	ldp	x23, x24, [sp, #48]
 111a4c4:	a9446bf9 	ldp	x25, x26, [sp, #64]
 111a4c8:	a8c67bfd 	ldp	x29, x30, [sp], #96
 111a4cc:	d65f03c0 	ret

000000000111a4d0 <get_devices>:
	const struct embedded_ts *eta = NULL;
	void *buf = NULL;
	uint32_t blen = 0;
	uint32_t pos = 0;

	if (types != TEE_PARAM_TYPES(TEE_PARAM_TYPE_MEMREF_OUTPUT,
 111a4d0:	7100181f 	cmp	w0, #0x6
 111a4d4:	540007c1 	b.ne	111a5cc <get_devices+0xfc>  // b.any
{
 111a4d8:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
 111a4dc:	910003fd 	mov	x29, sp
 111a4e0:	a9025bf5 	stp	x21, x22, [sp, #32]
 111a4e4:	aa0103f5 	mov	x21, x1
 111a4e8:	b9400836 	ldr	w22, [x1, #8]
 111a4ec:	f9002bfb 	str	x27, [sp, #80]
				     TEE_PARAM_TYPE_NONE,
				     TEE_PARAM_TYPE_NONE,
				     TEE_PARAM_TYPE_NONE))
		return TEE_ERROR_BAD_PARAMETERS;

	if (!params[0].memref.buffer && (params[0].memref.size > 0))
 111a4f0:	f940003b 	ldr	x27, [x1]
{
 111a4f4:	a90153f3 	stp	x19, x20, [sp, #16]
 111a4f8:	a90363f7 	stp	x23, x24, [sp, #48]
 111a4fc:	2a0203f8 	mov	w24, w2
 111a500:	a9046bf9 	stp	x25, x26, [sp, #64]
	if (!params[0].memref.buffer && (params[0].memref.size > 0))
 111a504:	b500005b 	cbnz	x27, 111a50c <get_devices+0x3c>
 111a508:	35000676 	cbnz	w22, 111a5d4 <get_devices+0x104>
		return TEE_ERROR_BAD_PARAMETERS;

	buf =  params[0].memref.buffer;
	blen = params[0].memref.size;

	SCATTERED_ARRAY_FOREACH(ta, pseudo_tas, struct pseudo_ta_head)
 111a50c:	90000200 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 111a510:	90000217 	adrp	x23, 115a000 <__scattered_array_1phys_mem_map+0x8>
 111a514:	9100e000 	add	x0, x0, #0x38
		EMSG(PTA_NAME ": skipping TA %pUl, inconsistent flags", uuid);
 111a518:	f00001d9 	adrp	x25, 1155000 <__func__.3826+0xa8>
 111a51c:	f00001da 	adrp	x26, 1155000 <__func__.3826+0xa8>
	SCATTERED_ARRAY_FOREACH(ta, pseudo_tas, struct pseudo_ta_head)
 111a520:	97ffe944 	bl	1114a30 <scattered_array_relax_ptr>
 111a524:	910682f7 	add	x23, x23, #0x1a0
 111a528:	aa0003f3 	mov	x19, x0
		EMSG(PTA_NAME ": skipping TA %pUl, inconsistent flags", uuid);
 111a52c:	910ff339 	add	x25, x25, #0x3fc
 111a530:	9110e35a 	add	x26, x26, #0x438
	uint32_t pos = 0;
 111a534:	52800014 	mov	w20, #0x0                   	// #0
	SCATTERED_ARRAY_FOREACH(ta, pseudo_tas, struct pseudo_ta_head)
 111a538:	eb17027f 	cmp	x19, x23
 111a53c:	54000183 	b.cc	111a56c <get_devices+0x9c>  // b.lo, b.ul, b.last
			add_ta(eta->flags, &eta->uuid, buf, blen, &pos,
			       rflags);

	params[0].memref.size = pos;
	if (pos > blen)
		return TEE_ERROR_SHORT_BUFFER;
 111a540:	6b1402df 	cmp	w22, w20
 111a544:	129ffde0 	mov	w0, #0xffff0010            	// #-65520
 111a548:	1a8023e0 	csel	w0, wzr, w0, cs  // cs = hs, nlast
	params[0].memref.size = pos;
 111a54c:	b9000ab4 	str	w20, [x21, #8]

	return TEE_SUCCESS;
}
 111a550:	a94153f3 	ldp	x19, x20, [sp, #16]
 111a554:	a9425bf5 	ldp	x21, x22, [sp, #32]
 111a558:	a94363f7 	ldp	x23, x24, [sp, #48]
 111a55c:	a9446bf9 	ldp	x25, x26, [sp, #64]
 111a560:	f9402bfb 	ldr	x27, [sp, #80]
 111a564:	a8c67bfd 	ldp	x29, x30, [sp], #96
 111a568:	d65f03c0 	ret
		add_ta(ta->flags, &ta->uuid, buf, blen, &pos, rflags);
 111a56c:	b9401a60 	ldr	w0, [x19, #24]
	if ((flags & TA_FLAG_DEVICE_ENUM) &&
 111a570:	12170401 	and	w1, w0, #0x600
 111a574:	7118003f 	cmp	w1, #0x600
 111a578:	54000141 	b.ne	111a5a0 <get_devices+0xd0>  // b.any
		EMSG(PTA_NAME ": skipping TA %pUl, inconsistent flags", uuid);
 111a57c:	aa1303e5 	mov	x5, x19
 111a580:	aa1903e4 	mov	x4, x25
 111a584:	aa1a03e0 	mov	x0, x26
 111a588:	52800023 	mov	w3, #0x1                   	// #1
 111a58c:	52800022 	mov	w2, #0x1                   	// #1
 111a590:	52800381 	mov	w1, #0x1c                  	// #28
 111a594:	9400a9ec 	bl	1144d44 <trace_printf>
	SCATTERED_ARRAY_FOREACH(ta, pseudo_tas, struct pseudo_ta_head)
 111a598:	91012273 	add	x19, x19, #0x48
 111a59c:	17ffffe7 	b	111a538 <get_devices+0x68>
	if (flags & rflags) {
 111a5a0:	6a18001f 	tst	w0, w24
 111a5a4:	54ffffa0 	b.eq	111a598 <get_devices+0xc8>  // b.none
		if (*pos + sizeof(*uuid) <= blen)
 111a5a8:	2a1403e0 	mov	w0, w20
 111a5ac:	91004001 	add	x1, x0, #0x10
 111a5b0:	eb36403f 	cmp	x1, w22, uxtw
 111a5b4:	54000088 	b.hi	111a5c4 <get_devices+0xf4>  // b.pmore
			tee_uuid_to_octets(buf + *pos, uuid);
 111a5b8:	aa1303e1 	mov	x1, x19
 111a5bc:	8b000360 	add	x0, x27, x0
 111a5c0:	940035ca 	bl	1127ce8 <tee_uuid_to_octets>
		*pos += sizeof(*uuid);
 111a5c4:	11004294 	add	w20, w20, #0x10
 111a5c8:	17fffff4 	b	111a598 <get_devices+0xc8>
		return TEE_ERROR_BAD_PARAMETERS;
 111a5cc:	129fff20 	mov	w0, #0xffff0006            	// #-65530
}
 111a5d0:	d65f03c0 	ret
		return TEE_ERROR_BAD_PARAMETERS;
 111a5d4:	129fff20 	mov	w0, #0xffff0006            	// #-65530
 111a5d8:	17ffffde 	b	111a550 <get_devices+0x80>

000000000111a5dc <invoke_command>:

static TEE_Result invoke_command(void *pSessionContext __unused,
				 uint32_t nCommandID, uint32_t nParamTypes,
				 TEE_Param pParams[TEE_NUM_PARAMS])
{
 111a5dc:	2a0103e4 	mov	w4, w1
 111a5e0:	2a0203e0 	mov	w0, w2
 111a5e4:	aa0303e1 	mov	x1, x3
	switch (nCommandID) {
 111a5e8:	340000a4 	cbz	w4, 111a5fc <invoke_command+0x20>
 111a5ec:	7100049f 	cmp	w4, #0x1
 111a5f0:	540000a0 	b.eq	111a604 <invoke_command+0x28>  // b.none
	default:
		break;
	}

	return TEE_ERROR_NOT_IMPLEMENTED;
}
 111a5f4:	129ffec0 	mov	w0, #0xffff0009            	// #-65527
 111a5f8:	d65f03c0 	ret
		return get_devices(nParamTypes, pParams,
 111a5fc:	52804002 	mov	w2, #0x200                 	// #512
		return get_devices(nParamTypes, pParams,
 111a600:	17ffffb4 	b	111a4d0 <get_devices>
 111a604:	52808002 	mov	w2, #0x400                 	// #1024
 111a608:	17fffffe 	b	111a600 <invoke_command+0x24>

000000000111a60c <invoke_command>:
}

static TEE_Result invoke_command(void *sess_ctx __unused, uint32_t cmd_id,
				 uint32_t param_types,
				 TEE_Param params[TEE_NUM_PARAMS])
{
 111a60c:	a9b57bfd 	stp	x29, x30, [sp, #-176]!
 111a610:	910003fd 	mov	x29, sp
 111a614:	a90153f3 	stp	x19, x20, [sp, #16]
 111a618:	a9025bf5 	stp	x21, x22, [sp, #32]
 111a61c:	a90363f7 	stp	x23, x24, [sp, #48]
 111a620:	a9046bf9 	stp	x25, x26, [sp, #64]
 111a624:	a90573fb 	stp	x27, x28, [sp, #80]
	switch (cmd_id) {
 111a628:	350017a1 	cbnz	w1, 111a91c <invoke_command+0x310>
	if (param_types != exp_pt)
 111a62c:	7100145f 	cmp	w2, #0x5
 111a630:	540017a1 	b.ne	111a924 <invoke_command+0x318>  // b.any
	shdr = shdr_alloc_and_copy(params->memref.buffer, params->memref.size);
 111a634:	b9400861 	ldr	w1, [x3, #8]
 111a638:	aa0303f5 	mov	x21, x3
 111a63c:	f9400060 	ldr	x0, [x3]
 111a640:	97ffd1e5 	bl	110edd4 <shdr_alloc_and_copy>
 111a644:	aa0003f4 	mov	x20, x0
	if (!shdr)
 111a648:	b4001720 	cbz	x0, 111a92c <invoke_command+0x320>
	res = shdr_verify_signature(shdr);
 111a64c:	97ffd206 	bl	110ee64 <shdr_verify_signature>
 111a650:	2a0003f3 	mov	w19, w0
	if (res)
 111a654:	35001080 	cbnz	w0, 111a864 <invoke_command+0x258>
	if (shdr->img_type != SHDR_BOOTSTRAP_TA)
 111a658:	b9400680 	ldr	w0, [x20, #4]
	void *hash_ctx = NULL;
 111a65c:	f90037ff 	str	xzr, [sp, #104]
	res = install_ta(shdr, params->memref.buffer, params->memref.size);
 111a660:	b9400aba 	ldr	w26, [x21, #8]
	if (shdr->img_type != SHDR_BOOTSTRAP_TA)
 111a664:	7100041f 	cmp	w0, #0x1
	res = install_ta(shdr, params->memref.buffer, params->memref.size);
 111a668:	f94002b8 	ldr	x24, [x21]
	if (shdr->img_type != SHDR_BOOTSTRAP_TA)
 111a66c:	54001501 	b.ne	111a90c <invoke_command+0x300>  // b.any
	    ADD_OVERFLOW(s, shdr->sig_size, &s))
 111a670:	79402680 	ldrh	w0, [x20, #18]
	res = install_ta(shdr, params->memref.buffer, params->memref.size);
 111a674:	2a1a03f7 	mov	w23, w26
	if (ADD_OVERFLOW(s, shdr->hash_size, &s) ||
 111a678:	79402282 	ldrh	w2, [x20, #16]
 111a67c:	79402281 	ldrh	w1, [x20, #16]
	if (nw_size < (sizeof(struct shdr_bootstrap_ta) + SHDR_GET_SIZE(shdr)))
 111a680:	8b020000 	add	x0, x0, x2
 111a684:	9100a000 	add	x0, x0, #0x28
 111a688:	eb3a401f 	cmp	x0, w26, uxtw
 111a68c:	54001408 	b.hi	111a90c <invoke_command+0x300>  // b.pmore
	if (shdr->hash_size > buf_size)
 111a690:	7140083f 	cmp	w1, #0x2, lsl #12
 111a694:	540013c8 	b.hi	111a90c <invoke_command+0x300>  // b.pmore
	buf = malloc(buf_size);
 111a698:	d2840000 	mov	x0, #0x2000                	// #8192
 111a69c:	9400a36f 	bl	1143458 <malloc>
 111a6a0:	aa0003f6 	mov	x22, x0
	if (!buf)
 111a6a4:	b4001380 	cbz	x0, 111a914 <invoke_command+0x308>
	res = crypto_hash_alloc_ctx(&hash_ctx,
 111a6a8:	b9400e80 	ldr	w0, [x20, #12]
	if (algo == TEE_ALG_SM2_DSA_SM3)
 111a6ac:	528c08a1 	mov	w1, #0x6045                	// #24645
 111a6b0:	72ae0001 	movk	w1, #0x7000, lsl #16
 111a6b4:	6b01001f 	cmp	w0, w1
 111a6b8:	54000ea0 	b.eq	111a88c <invoke_command+0x280>  // b.none
	return (algo >> 12) & 0xF;
 111a6bc:	d34c3c00 	ubfx	x0, x0, #12, #4
	return (TEE_OPERATION_DIGEST << 28) | main_hash;
 111a6c0:	52aa0001 	mov	w1, #0x50000000            	// #1342177280
 111a6c4:	71001c1f 	cmp	w0, #0x7
 111a6c8:	2a010001 	orr	w1, w0, w1
 111a6cc:	528000e0 	mov	w0, #0x7                   	// #7
 111a6d0:	72aa0000 	movk	w0, #0x5000, lsl #16
 111a6d4:	1a801021 	csel	w1, w1, w0, ne  // ne = any
 111a6d8:	9101a3e0 	add	x0, sp, #0x68
 111a6dc:	97ffcac8 	bl	110d1fc <crypto_hash_alloc_ctx>
 111a6e0:	2a0003f3 	mov	w19, w0
	if (res)
 111a6e4:	350010e0 	cbnz	w0, 111a900 <invoke_command+0x2f4>
	res = crypto_hash_init(hash_ctx);
 111a6e8:	f94037e0 	ldr	x0, [sp, #104]
 111a6ec:	97ffcb03 	bl	110d2f8 <crypto_hash_init>
 111a6f0:	2a0003f3 	mov	w19, w0
	if (res)
 111a6f4:	35001020 	cbnz	w0, 111a8f8 <invoke_command+0x2ec>
	res = crypto_hash_update(hash_ctx, (uint8_t *)shdr, sizeof(*shdr));
 111a6f8:	f94037e0 	ldr	x0, [sp, #104]
 111a6fc:	aa1403e1 	mov	x1, x20
 111a700:	d2800282 	mov	x2, #0x14                  	// #20
 111a704:	97ffcb08 	bl	110d324 <crypto_hash_update>
 111a708:	2a0003f3 	mov	w19, w0
	if (res)
 111a70c:	35000f60 	cbnz	w0, 111a8f8 <invoke_command+0x2ec>
	    ADD_OVERFLOW(s, shdr->sig_size, &s))
 111a710:	79402680 	ldrh	w0, [x20, #18]
	memcpy(&bs_ta, nw + offs, sizeof(bs_ta));
 111a714:	d2800282 	mov	x2, #0x14                  	// #20
	if (ADD_OVERFLOW(s, shdr->hash_size, &s) ||
 111a718:	79402295 	ldrh	w21, [x20, #16]
 111a71c:	9101e3fc 	add	x28, sp, #0x78
	tee_uuid_from_octets(&uuid, bs_ta->uuid);
 111a720:	910243f9 	add	x25, sp, #0x90
	res = tee_tadb_ta_open(&uuid, &ta);
 111a724:	9101c3fb 	add	x27, sp, #0x70
 111a728:	8b0002b5 	add	x21, x21, x0
	memcpy(&bs_ta, nw + offs, sizeof(bs_ta));
 111a72c:	aa1c03e0 	mov	x0, x28
	    ADD_OVERFLOW(s, shdr->sig_size, &s))
 111a730:	910052a1 	add	x1, x21, #0x14
 111a734:	8b010301 	add	x1, x24, x1
 111a738:	97ffa316 	bl	1103390 <memcpy>
	tee_uuid_from_octets(&uuid, bs_ta->uuid);
 111a73c:	aa1c03e1 	mov	x1, x28
 111a740:	aa1903e0 	mov	x0, x25
 111a744:	9400357e 	bl	1127d3c <tee_uuid_from_octets>
	res = tee_tadb_ta_open(&uuid, &ta);
 111a748:	aa1b03e1 	mov	x1, x27
 111a74c:	aa1903e0 	mov	x0, x25
 111a750:	940032cc 	bl	1127280 <tee_tadb_ta_open>
 111a754:	2a0003f3 	mov	w19, w0
	if (res == TEE_ERROR_ITEM_NOT_FOUND)
 111a758:	129ffee0 	mov	w0, #0xffff0008            	// #-65528
 111a75c:	6b00027f 	cmp	w19, w0
 111a760:	54000180 	b.eq	111a790 <invoke_command+0x184>  // b.none
	if (res)
 111a764:	35000cb3 	cbnz	w19, 111a8f8 <invoke_command+0x2ec>
	prop = tee_tadb_ta_get_property(ta);
 111a768:	f9403be0 	ldr	x0, [sp, #112]
 111a76c:	94003302 	bl	1127374 <tee_tadb_ta_get_property>
	if (prop->version > bs_ta->ta_version)
 111a770:	b9401001 	ldr	w1, [x0, #16]
		res = TEE_ERROR_ACCESS_CONFLICT;
 111a774:	b9408be0 	ldr	w0, [sp, #136]
 111a778:	6b00003f 	cmp	w1, w0
 111a77c:	129fff80 	mov	w0, #0xffff0003            	// #-65533
 111a780:	1a8093f3 	csel	w19, wzr, w0, ls  // ls = plast
	tee_tadb_ta_close(ta);
 111a784:	f9403be0 	ldr	x0, [sp, #112]
 111a788:	94003394 	bl	11275d8 <tee_tadb_ta_close>
	if (res)
 111a78c:	35000b73 	cbnz	w19, 111a8f8 <invoke_command+0x2ec>
	res = crypto_hash_update(hash_ctx, (uint8_t *)&bs_ta, sizeof(bs_ta));
 111a790:	f94037e0 	ldr	x0, [sp, #104]
 111a794:	aa1c03e1 	mov	x1, x28
 111a798:	d2800282 	mov	x2, #0x14                  	// #20
 111a79c:	97ffcae2 	bl	110d324 <crypto_hash_update>
 111a7a0:	2a0003f3 	mov	w19, w0
	if (res)
 111a7a4:	35000aa0 	cbnz	w0, 111a8f8 <invoke_command+0x2ec>
	tee_uuid_from_octets(&property.uuid, bs_ta.uuid);
 111a7a8:	aa1c03e1 	mov	x1, x28
 111a7ac:	aa1903e0 	mov	x0, x25
	memset(&property, 0, sizeof(property));
 111a7b0:	a9097fff 	stp	xzr, xzr, [sp, #144]
	offs += sizeof(bs_ta);
 111a7b4:	9100a2b5 	add	x21, x21, #0x28
	property.bin_size = nw_size - offs;
 111a7b8:	4b15035a 	sub	w26, w26, w21
	memset(&property, 0, sizeof(property));
 111a7bc:	f90053ff 	str	xzr, [sp, #160]
 111a7c0:	b900abff 	str	wzr, [sp, #168]
	tee_uuid_from_octets(&property.uuid, bs_ta.uuid);
 111a7c4:	9400355e 	bl	1127d3c <tee_uuid_from_octets>
	property.version = bs_ta.ta_version;
 111a7c8:	b9408be0 	ldr	w0, [sp, #136]
	DMSG("Installing %pUl", (void *)&property.uuid);
 111a7cc:	aa1903e5 	mov	x5, x25
 111a7d0:	f00001c4 	adrp	x4, 1155000 <__func__.3826+0xa8>
 111a7d4:	9110fc84 	add	x4, x4, #0x43f
 111a7d8:	52800023 	mov	w3, #0x1                   	// #1
 111a7dc:	52800062 	mov	w2, #0x3                   	// #3
 111a7e0:	52800c61 	mov	w1, #0x63                  	// #99
	property.custom_size = 0;
 111a7e4:	29147fe0 	stp	w0, wzr, [sp, #160]
	DMSG("Installing %pUl", (void *)&property.uuid);
 111a7e8:	f00001c0 	adrp	x0, 1155000 <__func__.3826+0xa8>
 111a7ec:	91117c00 	add	x0, x0, #0x45f
	property.bin_size = nw_size - offs;
 111a7f0:	b900abfa 	str	w26, [sp, #168]
	DMSG("Installing %pUl", (void *)&property.uuid);
 111a7f4:	9400a954 	bl	1144d44 <trace_printf>
	res = tee_tadb_ta_create(&property, &ta);
 111a7f8:	aa1b03e1 	mov	x1, x27
 111a7fc:	aa1903e0 	mov	x0, x25
 111a800:	94003157 	bl	1126d5c <tee_tadb_ta_create>
 111a804:	2a0003f3 	mov	w19, w0
	if (res)
 111a808:	35000780 	cbnz	w0, 111a8f8 <invoke_command+0x2ec>
		size_t l = MIN(buf_size, nw_size - offs);
 111a80c:	d284001a 	mov	x26, #0x2000                	// #8192
	while (offs < nw_size) {
 111a810:	eb1502ff 	cmp	x23, x21
 111a814:	f94037f3 	ldr	x19, [sp, #104]
 111a818:	54000408 	b.hi	111a898 <invoke_command+0x28c>  // b.pmore
	res = crypto_hash_final(hash_ctx, buf, shdr->hash_size);
 111a81c:	79402282 	ldrh	w2, [x20, #16]
 111a820:	aa1303e0 	mov	x0, x19
 111a824:	aa1603e1 	mov	x1, x22
 111a828:	97ffcad0 	bl	110d368 <crypto_hash_final>
 111a82c:	2a0003f3 	mov	w19, w0
	if (res)
 111a830:	35000600 	cbnz	w0, 111a8f0 <invoke_command+0x2e4>
	if (consttime_memcmp(buf, SHDR_GET_HASH(shdr), shdr->hash_size)) {
 111a834:	79402282 	ldrh	w2, [x20, #16]
 111a838:	91005281 	add	x1, x20, #0x14
 111a83c:	aa1603e0 	mov	x0, x22
 111a840:	9400a9d4 	bl	1144f90 <consttime_memcmp>
 111a844:	35000540 	cbnz	w0, 111a8ec <invoke_command+0x2e0>
	crypto_hash_free_ctx(hash_ctx);
 111a848:	f94037e0 	ldr	x0, [sp, #104]
 111a84c:	97ffca91 	bl	110d290 <crypto_hash_free_ctx>
	free(buf);
 111a850:	aa1603e0 	mov	x0, x22
 111a854:	9400a363 	bl	11435e0 <free>
	return tee_tadb_ta_close_and_commit(ta);
 111a858:	f9403be0 	ldr	x0, [sp, #112]
 111a85c:	94003238 	bl	112713c <tee_tadb_ta_close_and_commit>
 111a860:	2a0003f3 	mov	w19, w0
	free(shdr);
 111a864:	aa1403e0 	mov	x0, x20
 111a868:	9400a35e 	bl	11435e0 <free>
		return bootstrap(param_types, params);
	default:
		break;
	}
	return TEE_ERROR_NOT_IMPLEMENTED;
}
 111a86c:	2a1303e0 	mov	w0, w19
 111a870:	a94153f3 	ldp	x19, x20, [sp, #16]
 111a874:	a9425bf5 	ldp	x21, x22, [sp, #32]
 111a878:	a94363f7 	ldp	x23, x24, [sp, #48]
 111a87c:	a9446bf9 	ldp	x25, x26, [sp, #64]
 111a880:	a94573fb 	ldp	x27, x28, [sp, #80]
 111a884:	a8cb7bfd 	ldp	x29, x30, [sp], #176
 111a888:	d65f03c0 	ret
		return TEE_ALG_SM3;
 111a88c:	528000e1 	mov	w1, #0x7                   	// #7
 111a890:	72aa0001 	movk	w1, #0x5000, lsl #16
 111a894:	17ffff91 	b	111a6d8 <invoke_command+0xcc>
		size_t l = MIN(buf_size, nw_size - offs);
 111a898:	cb1502f9 	sub	x25, x23, x21
		memcpy(buf, nw + offs, l);
 111a89c:	8b150301 	add	x1, x24, x21
		size_t l = MIN(buf_size, nw_size - offs);
 111a8a0:	f1400b3f 	cmp	x25, #0x2, lsl #12
		memcpy(buf, nw + offs, l);
 111a8a4:	aa1603e0 	mov	x0, x22
		size_t l = MIN(buf_size, nw_size - offs);
 111a8a8:	9a9a9339 	csel	x25, x25, x26, ls  // ls = plast
		memcpy(buf, nw + offs, l);
 111a8ac:	aa1903e2 	mov	x2, x25
 111a8b0:	97ffa2b8 	bl	1103390 <memcpy>
		res = crypto_hash_update(hash_ctx, buf, l);
 111a8b4:	aa1303e0 	mov	x0, x19
 111a8b8:	aa1903e2 	mov	x2, x25
 111a8bc:	aa1603e1 	mov	x1, x22
 111a8c0:	97ffca99 	bl	110d324 <crypto_hash_update>
 111a8c4:	2a0003f3 	mov	w19, w0
		if (res)
 111a8c8:	35000140 	cbnz	w0, 111a8f0 <invoke_command+0x2e4>
		res = tee_tadb_ta_write(ta, buf, l);
 111a8cc:	f9403be0 	ldr	x0, [sp, #112]
 111a8d0:	aa1903e2 	mov	x2, x25
 111a8d4:	aa1603e1 	mov	x1, x22
 111a8d8:	940031c5 	bl	1126fec <tee_tadb_ta_write>
 111a8dc:	2a0003f3 	mov	w19, w0
		if (res)
 111a8e0:	35000080 	cbnz	w0, 111a8f0 <invoke_command+0x2e4>
		offs += l;
 111a8e4:	8b1902b5 	add	x21, x21, x25
 111a8e8:	17ffffca 	b	111a810 <invoke_command+0x204>
		res = TEE_ERROR_SECURITY;
 111a8ec:	129ffe13 	mov	w19, #0xffff000f            	// #-65521
	tee_tadb_ta_close_and_delete(ta);
 111a8f0:	f9403be0 	ldr	x0, [sp, #112]
 111a8f4:	940031ec 	bl	11270a4 <tee_tadb_ta_close_and_delete>
	crypto_hash_free_ctx(hash_ctx);
 111a8f8:	f94037e0 	ldr	x0, [sp, #104]
 111a8fc:	97ffca65 	bl	110d290 <crypto_hash_free_ctx>
	free(buf);
 111a900:	aa1603e0 	mov	x0, x22
 111a904:	9400a337 	bl	11435e0 <free>
	return res;
 111a908:	17ffffd7 	b	111a864 <invoke_command+0x258>
		return TEE_ERROR_SECURITY;
 111a90c:	129ffe13 	mov	w19, #0xffff000f            	// #-65521
 111a910:	17ffffd5 	b	111a864 <invoke_command+0x258>
		return TEE_ERROR_OUT_OF_MEMORY;
 111a914:	129ffe73 	mov	w19, #0xffff000c            	// #-65524
 111a918:	17ffffd3 	b	111a864 <invoke_command+0x258>
	return TEE_ERROR_NOT_IMPLEMENTED;
 111a91c:	129ffed3 	mov	w19, #0xffff0009            	// #-65527
 111a920:	17ffffd3 	b	111a86c <invoke_command+0x260>
		return TEE_ERROR_BAD_PARAMETERS;
 111a924:	129fff33 	mov	w19, #0xffff0006            	// #-65530
 111a928:	17ffffd1 	b	111a86c <invoke_command+0x260>
		return TEE_ERROR_SECURITY;
 111a92c:	129ffe13 	mov	w19, #0xffff000f            	// #-65521
 111a930:	17ffffcf 	b	111a86c <invoke_command+0x260>

000000000111a934 <invoke_command>:
 */

static TEE_Result invoke_command(void *psess __unused,
				 uint32_t cmd, uint32_t ptypes,
				 TEE_Param params[TEE_NUM_PARAMS])
{
 111a934:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
	switch (cmd) {
 111a938:	7100043f 	cmp	w1, #0x1
{
 111a93c:	910003fd 	mov	x29, sp
 111a940:	a90153f3 	stp	x19, x20, [sp, #16]
 111a944:	2a0103f3 	mov	w19, w1
 111a948:	aa0303f4 	mov	x20, x3
 111a94c:	a9025bf5 	stp	x21, x22, [sp, #32]
 111a950:	a90363f7 	stp	x23, x24, [sp, #48]
	switch (cmd) {
 111a954:	54000320 	b.eq	111a9b8 <invoke_command+0x84>  // b.none
 111a958:	7100083f 	cmp	w1, #0x2
 111a95c:	54000be0 	b.eq	111aad8 <invoke_command+0x1a4>  // b.none
 111a960:	35000be1 	cbnz	w1, 111aadc <invoke_command+0x1a8>
	if (TEE_PARAM_TYPES(TEE_PARAM_TYPE_VALUE_OUTPUT,
 111a964:	7108885f 	cmp	w2, #0x222
 111a968:	54000200 	b.eq	111a9a8 <invoke_command+0x74>  // b.none
		return TEE_ERROR_BAD_PARAMETERS;
 111a96c:	129fff33 	mov	w19, #0xffff0006            	// #-65530
		EMSG("expect 3 output values as argument");
 111a970:	f00001c4 	adrp	x4, 1155000 <__func__.3826+0xa8>
 111a974:	52800023 	mov	w3, #0x1                   	// #1
 111a978:	9111a884 	add	x4, x4, #0x46a
 111a97c:	52800022 	mov	w2, #0x1                   	// #1
 111a980:	52800e01 	mov	w1, #0x70                  	// #112
 111a984:	f00001c0 	adrp	x0, 1155000 <__func__.3826+0xa8>
 111a988:	9113c800 	add	x0, x0, #0x4f2
 111a98c:	9400a8ee 	bl	1144d44 <trace_printf>
	case STATS_CMD_PAGER_STATS:
		return get_pager_stats(ptypes, params);
 111a990:	2a1303e0 	mov	w0, w19
		return get_memleak_stats(ptypes, params);
	default:
		break;
	}
	return TEE_ERROR_BAD_PARAMETERS;
}
 111a994:	a94153f3 	ldp	x19, x20, [sp, #16]
 111a998:	a9425bf5 	ldp	x21, x22, [sp, #32]
 111a99c:	a94363f7 	ldp	x23, x24, [sp, #48]
 111a9a0:	a8c47bfd 	ldp	x29, x30, [sp], #64
 111a9a4:	d65f03c0 	ret
	p[0].value.a = stats.npages;
 111a9a8:	f900007f 	str	xzr, [x3]
	p[1].value.a = stats.ro_hits;
 111a9ac:	f900087f 	str	xzr, [x3, #16]
	p[2].value.a = stats.hidden_hits;
 111a9b0:	f900107f 	str	xzr, [x3, #32]
	return TEE_SUCCESS;
 111a9b4:	17fffff7 	b	111a990 <invoke_command+0x5c>
	if (TEE_PARAM_TYPES(TEE_PARAM_TYPE_VALUE_INPUT,
 111a9b8:	7101845f 	cmp	w2, #0x61
 111a9bc:	54000901 	b.ne	111aadc <invoke_command+0x1a8>  // b.any
	pool_id = p[0].value.a;
 111a9c0:	b9400076 	ldr	w22, [x3]
	if (pool_id > STATS_NB_POOLS)
 111a9c4:	710012df 	cmp	w22, #0x4
 111a9c8:	540008a8 	b.hi	111aadc <invoke_command+0x1a8>  // b.pmore
		size_to_retrieve *= STATS_NB_POOLS;
 111a9cc:	52801c01 	mov	w1, #0xe0                  	// #224
 111a9d0:	710002df 	cmp	w22, #0x0
 111a9d4:	52800700 	mov	w0, #0x38                  	// #56
 111a9d8:	1a811000 	csel	w0, w0, w1, ne  // ne = any
	if (p[1].memref.size < size_to_retrieve) {
 111a9dc:	91004061 	add	x1, x3, #0x10
 111a9e0:	b9400822 	ldr	w2, [x1, #8]
		p[1].memref.size = size_to_retrieve;
 111a9e4:	b9000820 	str	w0, [x1, #8]
	if (p[1].memref.size < size_to_retrieve) {
 111a9e8:	6b00005f 	cmp	w2, w0
 111a9ec:	54000062 	b.cs	111a9f8 <invoke_command+0xc4>  // b.hs, b.nlast
		return TEE_ERROR_SHORT_BUFFER;
 111a9f0:	129ffde0 	mov	w0, #0xffff0010            	// #-65520
 111a9f4:	17ffffe8 	b	111a994 <invoke_command+0x60>
	stats = p[1].memref.buffer;
 111a9f8:	f9400875 	ldr	x21, [x3, #16]
			EMSG("public DDR not managed by secure side anymore");
 111a9fc:	f00001d8 	adrp	x24, 1155000 <__func__.3826+0xa8>
 111aa00:	f00001d7 	adrp	x23, 1155000 <__func__.3826+0xa8>
 111aa04:	91124b18 	add	x24, x24, #0x492
 111aa08:	91138af7 	add	x23, x23, #0x4e2
		if ((pool_id) && (i != pool_id))
 111aa0c:	710002df 	cmp	w22, #0x0
 111aa10:	7a5312c4 	ccmp	w22, w19, #0x4, ne  // ne = any
 111aa14:	54000241 	b.ne	111aa5c <invoke_command+0x128>  // b.any
		switch (i) {
 111aa18:	71000a7f 	cmp	w19, #0x2
 111aa1c:	540002a0 	b.eq	111aa70 <invoke_command+0x13c>  // b.none
 111aa20:	71000e7f 	cmp	w19, #0x3
 111aa24:	54000340 	b.eq	111aa8c <invoke_command+0x158>  // b.none
 111aa28:	7100067f 	cmp	w19, #0x1
 111aa2c:	540004a1 	b.ne	111aac0 <invoke_command+0x18c>  // b.any
			malloc_get_stats(stats);
 111aa30:	aa1503e0 	mov	x0, x21
 111aa34:	9400a274 	bl	1143404 <malloc_get_stats>
			strlcpy(stats->desc, "Heap", sizeof(stats->desc));
 111aa38:	aa1503e0 	mov	x0, x21
 111aa3c:	d2800402 	mov	x2, #0x20                  	// #32
 111aa40:	f00001c1 	adrp	x1, 1155000 <__func__.3826+0xa8>
 111aa44:	91123421 	add	x1, x1, #0x48d
 111aa48:	9400a80b 	bl	1144a74 <strlcpy>
			if (p[0].value.b)
 111aa4c:	b9400680 	ldr	w0, [x20, #4]
 111aa50:	34000040 	cbz	w0, 111aa58 <invoke_command+0x124>
				malloc_reset_stats();
 111aa54:	9400a260 	bl	11433d4 <malloc_reset_stats>
		stats++;
 111aa58:	9100e2b5 	add	x21, x21, #0x38
	for (i = 1; i <= STATS_NB_POOLS; i++) {
 111aa5c:	11000673 	add	w19, w19, #0x1
 111aa60:	7100167f 	cmp	w19, #0x5
 111aa64:	54fffd41 	b.ne	111aa0c <invoke_command+0xd8>  // b.any
	return TEE_SUCCESS;
 111aa68:	52800000 	mov	w0, #0x0                   	// #0
 111aa6c:	17ffffca 	b	111a994 <invoke_command+0x60>
			EMSG("public DDR not managed by secure side anymore");
 111aa70:	aa1803e4 	mov	x4, x24
 111aa74:	52800023 	mov	w3, #0x1                   	// #1
 111aa78:	52800022 	mov	w2, #0x1                   	// #1
 111aa7c:	52800981 	mov	w1, #0x4c                  	// #76
			EMSG("Wrong pool id");
 111aa80:	aa1703e0 	mov	x0, x23
 111aa84:	9400a8b0 	bl	1144d44 <trace_printf>
			break;
 111aa88:	17fffff4 	b	111aa58 <invoke_command+0x124>
			tee_mm_get_pool_stats(&tee_mm_sec_ddr, stats,
 111aa8c:	b9400680 	ldr	w0, [x20, #4]
 111aa90:	aa1503e1 	mov	x1, x21
 111aa94:	7100001f 	cmp	w0, #0x0
 111aa98:	90000200 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 111aa9c:	1a9f07e2 	cset	w2, ne  // ne = any
 111aaa0:	f9415000 	ldr	x0, [x0, #672]
 111aaa4:	97ffc305 	bl	110b6b8 <tee_mm_get_pool_stats>
			strlcpy(stats->desc, "Secure DDR", sizeof(stats->desc));
 111aaa8:	aa1503e0 	mov	x0, x21
 111aaac:	d2800402 	mov	x2, #0x20                  	// #32
 111aab0:	f00001c1 	adrp	x1, 1155000 <__func__.3826+0xa8>
 111aab4:	91130021 	add	x1, x1, #0x4c0
 111aab8:	9400a7ef 	bl	1144a74 <strlcpy>
			break;
 111aabc:	17ffffe7 	b	111aa58 <invoke_command+0x124>
			EMSG("Wrong pool id");
 111aac0:	f00001c4 	adrp	x4, 1155000 <__func__.3826+0xa8>
 111aac4:	52800023 	mov	w3, #0x1                   	// #1
 111aac8:	91132c84 	add	x4, x4, #0x4cb
 111aacc:	52800022 	mov	w2, #0x1                   	// #1
 111aad0:	52800bc1 	mov	w1, #0x5e                  	// #94
 111aad4:	17ffffeb 	b	111aa80 <invoke_command+0x14c>
	if (TEE_PARAM_TYPES(TEE_PARAM_TYPE_NONE, TEE_PARAM_TYPE_NONE,
 111aad8:	34fffc82 	cbz	w2, 111aa68 <invoke_command+0x134>
		return TEE_ERROR_BAD_PARAMETERS;
 111aadc:	129fff20 	mov	w0, #0xffff0006            	// #-65530
 111aae0:	17ffffad 	b	111a994 <invoke_command+0x60>

000000000111aae4 <open_session>:
}

static TEE_Result open_session(uint32_t param_types __unused,
			       TEE_Param params[TEE_NUM_PARAMS] __unused,
			       void **sess_ctx __unused)
{
 111aae4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 111aae8:	910003fd 	mov	x29, sp
	struct ts_session *s = NULL;

	/* Check that we're called from a user TA */
	s = ts_get_calling_session();
 111aaec:	97ffe7ca 	bl	1114a14 <ts_get_calling_session>
	if (!s)
 111aaf0:	b40000a0 	cbz	x0, 111ab04 <open_session+0x20>
		return TEE_ERROR_ACCESS_DENIED;
	if (!is_user_ta_ctx(s->ctx))
 111aaf4:	f9400800 	ldr	x0, [x0, #16]
 111aaf8:	97ffedbd 	bl	11161ec <is_user_ta_ctx>
 111aafc:	72001c1f 	tst	w0, #0xff
 111ab00:	54000081 	b.ne	111ab10 <open_session+0x2c>  // b.any
		return TEE_ERROR_ACCESS_DENIED;
 111ab04:	129fffc0 	mov	w0, #0xffff0001            	// #-65535

	return TEE_SUCCESS;
}
 111ab08:	a8c17bfd 	ldp	x29, x30, [sp], #16
 111ab0c:	d65f03c0 	ret
	return TEE_SUCCESS;
 111ab10:	52800000 	mov	w0, #0x0                   	// #0
 111ab14:	17fffffd 	b	111ab08 <open_session+0x24>

000000000111ab18 <invoke_command>:

static TEE_Result invoke_command(void *sess_ctx __unused, uint32_t cmd_id,
				 uint32_t param_types,
				 TEE_Param params[TEE_NUM_PARAMS])
{
 111ab18:	d101c3ff 	sub	sp, sp, #0x70
 111ab1c:	a9017bfd 	stp	x29, x30, [sp, #16]
 111ab20:	910043fd 	add	x29, sp, #0x10
 111ab24:	a90253f3 	stp	x19, x20, [sp, #32]
 111ab28:	2a0103f3 	mov	w19, w1
 111ab2c:	aa0303f4 	mov	x20, x3
 111ab30:	a9035bf5 	stp	x21, x22, [sp, #48]
 111ab34:	2a0203f6 	mov	w22, w2
 111ab38:	a90463f7 	stp	x23, x24, [sp, #64]
 111ab3c:	a9056bf9 	stp	x25, x26, [sp, #80]
	struct ts_session *s = ts_get_calling_session();
 111ab40:	97ffe7b5 	bl	1114a14 <ts_get_calling_session>
	struct user_mode_ctx *uctx = to_user_mode_ctx(s->ctx);
 111ab44:	f9400815 	ldr	x21, [x0, #16]
 111ab48:	aa1503e0 	mov	x0, x21
 111ab4c:	97ffeda8 	bl	11161ec <is_user_ta_ctx>
 111ab50:	72001c1f 	tst	w0, #0xff
 111ab54:	540002e0 	b.eq	111abb0 <invoke_command+0x98>  // b.none
 111ab58:	aa1503e0 	mov	x0, x21
 111ab5c:	97ffeda4 	bl	11161ec <is_user_ta_ctx>
 111ab60:	72001c1f 	tst	w0, #0xff
 111ab64:	54000141 	b.ne	111ab8c <invoke_command+0x74>  // b.any
 111ab68:	f00001c3 	adrp	x3, 1155000 <__func__.3826+0xa8>
 111ab6c:	f00001a1 	adrp	x1, 1151000 <small_prime+0x168>
 111ab70:	f00001a0 	adrp	x0, 1151000 <small_prime+0x168>
 111ab74:	91146463 	add	x3, x3, #0x519
 111ab78:	91081021 	add	x1, x1, #0x204
 111ab7c:	91088800 	add	x0, x0, #0x222
 111ab80:	52800702 	mov	w2, #0x38                  	// #56
 111ab84:	97ffddca 	bl	11122ac <_assert_log>
 111ab88:	97ffddda 	bl	11122f0 <_assert_break>
		return &to_user_ta_ctx(ctx)->uctx;
 111ab8c:	d10a62b5 	sub	x21, x21, #0x298

	switch (cmd_id) {
 111ab90:	7100367f 	cmp	w19, #0xd
 111ab94:	54001c88 	b.hi	111af24 <invoke_command+0x40c>  // b.pmore
 111ab98:	900001a0 	adrp	x0, 114e000 <ldelf_data+0x8000>
 111ab9c:	911ad000 	add	x0, x0, #0x6b4
 111aba0:	78735800 	ldrh	w0, [x0, w19, uxtw #1]
 111aba4:	10000061 	adr	x1, 111abb0 <invoke_command+0x98>
 111aba8:	8b20a820 	add	x0, x1, w0, sxth #2
 111abac:	d61f0000 	br	x0
 111abb0:	f00001c3 	adrp	x3, 1155000 <__func__.3826+0xa8>
 111abb4:	f00001a1 	adrp	x1, 1151000 <small_prime+0x168>
 111abb8:	f00001a0 	adrp	x0, 1151000 <small_prime+0x168>
 111abbc:	91143463 	add	x3, x3, #0x50d
 111abc0:	913a8421 	add	x1, x1, #0xea1
 111abc4:	913b2000 	add	x0, x0, #0xec8
 111abc8:	52801322 	mov	w2, #0x99                  	// #153
 111abcc:	17ffffee 	b	111ab84 <invoke_command+0x6c>
	if (exp_pt != param_types)
 111abd0:	710016df 	cmp	w22, #0x5
 111abd4:	54001b01 	b.ne	111af34 <invoke_command+0x41c>  // b.any
	entropy_sz = params[0].memref.size;
 111abd8:	b9400a83 	ldr	w3, [x20, #8]
	entropy_input = params[0].memref.buffer;
 111abdc:	f9400282 	ldr	x2, [x20]
	if (!entropy_sz || !entropy_input)
 111abe0:	f100007f 	cmp	x3, #0x0
 111abe4:	fa401844 	ccmp	x2, #0x0, #0x4, ne  // ne = any
 111abe8:	54001a60 	b.eq	111af34 <invoke_command+0x41c>  // b.none
	crypto_rng_add_event(CRYPTO_RNG_SRC_NONSECURE, &system_pnum,
 111abec:	d0000261 	adrp	x1, 1168000 <data.5093+0x9e28>
 111abf0:	52800040 	mov	w0, #0x2                   	// #2
 111abf4:	912a0021 	add	x1, x1, #0xa80
 111abf8:	97ffd1f1 	bl	110f3bc <crypto_rng_add_event>
	default:
		break;
	}

	return TEE_ERROR_NOT_IMPLEMENTED;
}
 111abfc:	2a1303e0 	mov	w0, w19
 111ac00:	a9417bfd 	ldp	x29, x30, [sp, #16]
 111ac04:	a94253f3 	ldp	x19, x20, [sp, #32]
 111ac08:	a9435bf5 	ldp	x21, x22, [sp, #48]
 111ac0c:	a94463f7 	ldp	x23, x24, [sp, #64]
 111ac10:	a9456bf9 	ldp	x25, x26, [sp, #80]
 111ac14:	9101c3ff 	add	sp, sp, #0x70
 111ac18:	d65f03c0 	ret
	if (exp_pt != param_types)
 111ac1c:	710196df 	cmp	w22, #0x65
 111ac20:	540018a1 	b.ne	111af34 <invoke_command+0x41c>  // b.any
	if (params[0].memref.size > TA_DERIVED_EXTRA_DATA_MAX_SIZE ||
 111ac24:	b9400a80 	ldr	w0, [x20, #8]
 111ac28:	7110001f 	cmp	w0, #0x400
 111ac2c:	54001848 	b.hi	111af34 <invoke_command+0x41c>  // b.pmore
	    params[1].memref.size < TA_DERIVED_KEY_MIN_SIZE ||
 111ac30:	b9401a83 	ldr	w3, [x20, #24]
	if (params[0].memref.size > TA_DERIVED_EXTRA_DATA_MAX_SIZE ||
 111ac34:	51004060 	sub	w0, w3, #0x10
 111ac38:	7100401f 	cmp	w0, #0x10
 111ac3c:	540017c8 	b.hi	111af34 <invoke_command+0x41c>  // b.pmore
	res = vm_check_access_rights(uctx, access_flags,
 111ac40:	f9400a82 	ldr	x2, [x20, #16]
 111ac44:	528000c1 	mov	w1, #0x6                   	// #6
 111ac48:	2a0303e3 	mov	w3, w3
 111ac4c:	aa1503e0 	mov	x0, x21
 111ac50:	72a40001 	movk	w1, #0x2000, lsl #16
 111ac54:	97fffae6 	bl	11197ec <vm_check_access_rights>
	if (res != TEE_SUCCESS)
 111ac58:	350016a0 	cbnz	w0, 111af2c <invoke_command+0x414>
	if (ADD_OVERFLOW(data_len, params[0].memref.size, &data_len))
 111ac5c:	b9400a98 	ldr	w24, [x20, #8]
	data = calloc(data_len, 1);
 111ac60:	d2800021 	mov	x1, #0x1                   	// #1
	if (ADD_OVERFLOW(data_len, params[0].memref.size, &data_len))
 111ac64:	91004313 	add	x19, x24, #0x10
	data = calloc(data_len, 1);
 111ac68:	aa1303e0 	mov	x0, x19
 111ac6c:	9400a219 	bl	11434d0 <calloc>
 111ac70:	aa0003f6 	mov	x22, x0
	if (!data)
 111ac74:	b4000500 	cbz	x0, 111ad14 <invoke_command+0x1fc>
	memcpy(data, &uctx->ts_ctx->uuid, sizeof(TEE_UUID));
 111ac78:	f94122a1 	ldr	x1, [x21, #576]
 111ac7c:	d2800202 	mov	x2, #0x10                  	// #16
 111ac80:	97ffa1c4 	bl	1103390 <memcpy>
	memcpy(data + sizeof(TEE_UUID), params[0].memref.buffer,
 111ac84:	f9400281 	ldr	x1, [x20]
 111ac88:	aa1803e2 	mov	x2, x24
 111ac8c:	910042c0 	add	x0, x22, #0x10
 111ac90:	97ffa1c0 	bl	1103390 <memcpy>
	res = huk_subkey_derive(HUK_SUBKEY_UNIQUE_TA, data, data_len,
 111ac94:	b9401a84 	ldr	w4, [x20, #24]
 111ac98:	aa1303e2 	mov	x2, x19
 111ac9c:	f9400a83 	ldr	x3, [x20, #16]
 111aca0:	aa1603e1 	mov	x1, x22
 111aca4:	52800060 	mov	w0, #0x3                   	// #3
 111aca8:	97ffe763 	bl	1114a34 <huk_subkey_derive>
 111acac:	2a0003f3 	mov	w19, w0
	free_wipe(data);
 111acb0:	aa1603e0 	mov	x0, x22
 111acb4:	9400a24d 	bl	11435e8 <free_wipe>
	return res;
 111acb8:	17ffffd1 	b	111abfc <invoke_command+0xe4>
	if (exp_pt != param_types)
 111acbc:	7104c6df 	cmp	w22, #0x131
 111acc0:	540013a1 	b.ne	111af34 <invoke_command+0x41c>  // b.any
	if (params[0].value.b & ~PTA_SYSTEM_MAP_FLAG_SHAREABLE)
 111acc4:	b9400697 	ldr	w23, [x20, #4]
 111acc8:	721f7aff 	tst	w23, #0xfffffffe
 111accc:	54001341 	b.ne	111af34 <invoke_command+0x41c>  // b.any
	num_bytes = params[0].value.a;
 111acd0:	aa1403e2 	mov	x2, x20
		vm_flags |= VM_FLAG_SHAREABLE;
 111acd4:	710002ff 	cmp	w23, #0x0
 111acd8:	52800080 	mov	w0, #0x4                   	// #4
 111acdc:	1a8002f7 	csel	w23, w23, w0, eq  // eq = none
	return (uint64_t)reg0 << 32 | reg1;
 111ace0:	b9401281 	ldr	w1, [x20, #16]
	num_bytes = params[0].value.a;
 111ace4:	b8410440 	ldr	w0, [x2], #16
	pad_end = params[2].value.b;
 111ace8:	2944629a 	ldp	w26, w24, [x20, #32]
	num_bytes = params[0].value.a;
 111acec:	2a0003f9 	mov	w25, w0
	f = fobj_ta_mem_alloc(ROUNDUP_DIV(num_bytes, SMALL_PAGE_SIZE));
 111acf0:	f2402c1f 	tst	x0, #0xfff
 111acf4:	530c7c00 	lsr	w0, w0, #12
 111acf8:	b9400442 	ldr	w2, [x2, #4]
 111acfc:	1a800400 	cinc	w0, w0, ne  // ne = any
 111ad00:	aa018041 	orr	x1, x2, x1, lsl #32
	va = reg_pair_to_64(params[1].value.a, params[1].value.b);
 111ad04:	f90037e1 	str	x1, [sp, #104]
	f = fobj_ta_mem_alloc(ROUNDUP_DIV(num_bytes, SMALL_PAGE_SIZE));
 111ad08:	97fff650 	bl	1118648 <fobj_sec_mem_alloc>
 111ad0c:	aa0003f3 	mov	x19, x0
	if (!f)
 111ad10:	b5000060 	cbnz	x0, 111ad1c <invoke_command+0x204>
		return TEE_ERROR_OUT_OF_MEMORY;
 111ad14:	129ffe73 	mov	w19, #0xffff000c            	// #-65524
 111ad18:	17ffffb9 	b	111abfc <invoke_command+0xe4>
	mobj = mobj_with_fobj_alloc(f, NULL);
 111ad1c:	d2800001 	mov	x1, #0x0                   	// #0
 111ad20:	97fff5d1 	bl	1118464 <mobj_with_fobj_alloc>
 111ad24:	aa0003f6 	mov	x22, x0
	if (fobj && refcount_dec(&fobj->refc))
 111ad28:	91003260 	add	x0, x19, #0xc
 111ad2c:	97ffe220 	bl	11135ac <refcount_dec>
 111ad30:	72001c1f 	tst	w0, #0xff
 111ad34:	540000a0 	b.eq	111ad48 <invoke_command+0x230>  // b.none
		fobj->ops->free(fobj);
 111ad38:	f9400260 	ldr	x0, [x19]
 111ad3c:	f9400001 	ldr	x1, [x0]
 111ad40:	aa1303e0 	mov	x0, x19
 111ad44:	d63f0020 	blr	x1
	if (!mobj)
 111ad48:	b4fffe76 	cbz	x22, 111ad14 <invoke_command+0x1fc>
	res = vm_map_pad(uctx, &va, num_bytes, prot, vm_flags,
 111ad4c:	2a1a03e7 	mov	w7, w26
 111ad50:	aa1603e5 	mov	x5, x22
 111ad54:	2a1703e4 	mov	w4, w23
 111ad58:	aa1903e2 	mov	x2, x25
 111ad5c:	9101a3e1 	add	x1, sp, #0x68
 111ad60:	2a1803f8 	mov	w24, w24
 111ad64:	a9007ff8 	stp	x24, xzr, [sp]
 111ad68:	d2800006 	mov	x6, #0x0                   	// #0
 111ad6c:	52803603 	mov	w3, #0x1b0                 	// #432
 111ad70:	aa1503e0 	mov	x0, x21
 111ad74:	97fffb71 	bl	1119b38 <vm_map_pad>
 111ad78:	2a0003f3 	mov	w19, w0
	if (mobj && refcount_dec(&mobj->refc))
 111ad7c:	910062c0 	add	x0, x22, #0x18
 111ad80:	97ffe20b 	bl	11135ac <refcount_dec>
 111ad84:	72001c1f 	tst	w0, #0xff
 111ad88:	540000a0 	b.eq	111ad9c <invoke_command+0x284>  // b.none
		mobj->ops->free(mobj);
 111ad8c:	f94002c0 	ldr	x0, [x22]
 111ad90:	f9401401 	ldr	x1, [x0, #40]
 111ad94:	aa1603e0 	mov	x0, x22
 111ad98:	d63f0020 	blr	x1
	if (!res)
 111ad9c:	35fff313 	cbnz	w19, 111abfc <invoke_command+0xe4>
		reg_pair_from_64(va, &params[1].value.a, &params[1].value.b);
 111ada0:	f94037e0 	ldr	x0, [sp, #104]
	*reg0 = val >> 32;
 111ada4:	d360fc01 	lsr	x1, x0, #32
	*reg1 = val;
 111ada8:	29020281 	stp	w1, w0, [x20, #16]
}
 111adac:	17ffff94 	b	111abfc <invoke_command+0xe4>
	uint32_t vm_flags = 0;
 111adb0:	b9006bff 	str	wzr, [sp, #104]
	if (exp_pt != param_types)
 111adb4:	710046df 	cmp	w22, #0x11
 111adb8:	54000be1 	b.ne	111af34 <invoke_command+0x41c>  // b.any
	if (params[0].value.b)
 111adbc:	b9400680 	ldr	w0, [x20, #4]
 111adc0:	35000ba0 	cbnz	w0, 111af34 <invoke_command+0x41c>
	return (uint64_t)reg0 << 32 | reg1;
 111adc4:	29420696 	ldp	w22, w1, [x20, #16]
	sz = ROUNDUP(params[0].value.a, SMALL_PAGE_SIZE);
 111adc8:	b9400294 	ldr	w20, [x20]
 111adcc:	113ffe94 	add	w20, w20, #0xfff
 111add0:	aa168036 	orr	x22, x1, x22, lsl #32
 111add4:	92744e94 	and	x20, x20, #0xfffff000
	if (ADD_OVERFLOW(va, sz, &end_va))
 111add8:	ab1402c0 	adds	x0, x22, x20
 111addc:	54000ac2 	b.cs	111af34 <invoke_command+0x41c>  // b.hs, b.nlast
	res = vm_get_flags(uctx, va, sz, &vm_flags);
 111ade0:	9101a3e3 	add	x3, sp, #0x68
 111ade4:	aa1403e2 	mov	x2, x20
 111ade8:	aa1603e1 	mov	x1, x22
 111adec:	aa1503e0 	mov	x0, x21
 111adf0:	97fff93b 	bl	11192dc <vm_get_flags>
 111adf4:	2a0003f3 	mov	w19, w0
	if (res)
 111adf8:	35fff020 	cbnz	w0, 111abfc <invoke_command+0xe4>
	if (vm_flags & VM_FLAG_PERMANENT)
 111adfc:	b9406be0 	ldr	w0, [sp, #104]
 111ae00:	370800e0 	tbnz	w0, #1, 111ae1c <invoke_command+0x304>
	return vm_unmap(uctx, va, sz);
 111ae04:	aa1403e2 	mov	x2, x20
 111ae08:	aa1603e1 	mov	x1, x22
 111ae0c:	aa1503e0 	mov	x0, x21
 111ae10:	97fff950 	bl	1119350 <vm_unmap>
 111ae14:	2a0003f3 	mov	w19, w0
 111ae18:	17ffff79 	b	111abfc <invoke_command+0xe4>
		return TEE_ERROR_ACCESS_DENIED;
 111ae1c:	129fffd3 	mov	w19, #0xffff0001            	// #-65535
		return system_unmap(uctx, param_types, params);
 111ae20:	17ffff77 	b	111abfc <invoke_command+0xe4>
	if (exp_pt != param_types)
 111ae24:	710056df 	cmp	w22, #0x15
 111ae28:	54000861 	b.ne	111af34 <invoke_command+0x41c>  // b.any
	uuid = params[0].memref.buffer;
 111ae2c:	f9400293 	ldr	x19, [x20]
	if (!uuid || params[0].memref.size != sizeof(*uuid))
 111ae30:	b4000833 	cbz	x19, 111af34 <invoke_command+0x41c>
 111ae34:	b9400a80 	ldr	w0, [x20, #8]
 111ae38:	7100401f 	cmp	w0, #0x10
 111ae3c:	540007c1 	b.ne	111af34 <invoke_command+0x41c>  // b.any
	flags = params[1].value.a;
 111ae40:	b9401296 	ldr	w22, [x20, #16]
	s = ts_pop_current_session();
 111ae44:	97ffe6cf 	bl	1114980 <ts_pop_current_session>
	res = ldelf_dlopen(uctx, uuid, flags);
 111ae48:	aa1303e1 	mov	x1, x19
	s = ts_pop_current_session();
 111ae4c:	aa0003f4 	mov	x20, x0
	res = ldelf_dlopen(uctx, uuid, flags);
 111ae50:	2a1603e2 	mov	w2, w22
 111ae54:	aa1503e0 	mov	x0, x21
 111ae58:	97ffa40a 	bl	1103e80 <ldelf_dlopen>
 111ae5c:	2a0003f3 	mov	w19, w0
	ts_push_current_session(s);
 111ae60:	aa1403e0 	mov	x0, x20
 111ae64:	97ffe6b7 	bl	1114940 <ts_push_current_session>
	return res;
 111ae68:	17ffff65 	b	111abfc <invoke_command+0xe4>
	vaddr_t va = 0;
 111ae6c:	f90037ff 	str	xzr, [sp, #104]
	if (exp_pt != param_types)
 111ae70:	710956df 	cmp	w22, #0x255
 111ae74:	54000601 	b.ne	111af34 <invoke_command+0x41c>  // b.any
	uuid = params[0].memref.buffer;
 111ae78:	f9400293 	ldr	x19, [x20]
	if (!uuid || params[0].memref.size != sizeof(*uuid))
 111ae7c:	b40005d3 	cbz	x19, 111af34 <invoke_command+0x41c>
 111ae80:	b9400a80 	ldr	w0, [x20, #8]
 111ae84:	7100401f 	cmp	w0, #0x10
 111ae88:	54000561 	b.ne	111af34 <invoke_command+0x41c>  // b.any
	sym = params[1].memref.buffer;
 111ae8c:	f9400a97 	ldr	x23, [x20, #16]
	if (!sym)
 111ae90:	b4000537 	cbz	x23, 111af34 <invoke_command+0x41c>
	maxlen = params[1].memref.size;
 111ae94:	b9401a98 	ldr	w24, [x20, #24]
	s = ts_pop_current_session();
 111ae98:	97ffe6ba 	bl	1114980 <ts_pop_current_session>
	res = ldelf_dlsym(uctx, uuid, sym, maxlen, &va);
 111ae9c:	aa1303e1 	mov	x1, x19
 111aea0:	9101a3e4 	add	x4, sp, #0x68
 111aea4:	aa1803e3 	mov	x3, x24
 111aea8:	aa1703e2 	mov	x2, x23
	s = ts_pop_current_session();
 111aeac:	aa0003f6 	mov	x22, x0
	res = ldelf_dlsym(uctx, uuid, sym, maxlen, &va);
 111aeb0:	aa1503e0 	mov	x0, x21
 111aeb4:	97ffa44f 	bl	1103ff0 <ldelf_dlsym>
 111aeb8:	2a0003f3 	mov	w19, w0
	ts_push_current_session(s);
 111aebc:	aa1603e0 	mov	x0, x22
 111aec0:	97ffe6a0 	bl	1114940 <ts_push_current_session>
	if (!res)
 111aec4:	35ffe9d3 	cbnz	w19, 111abfc <invoke_command+0xe4>
		reg_pair_from_64(va, &params[2].value.a, &params[2].value.b);
 111aec8:	f94037e0 	ldr	x0, [sp, #104]
	*reg0 = val >> 32;
 111aecc:	d360fc01 	lsr	x1, x0, #32
	*reg1 = val;
 111aed0:	29040281 	stp	w1, w0, [x20, #32]
}
 111aed4:	17ffff4a 	b	111abfc <invoke_command+0xe4>
	return res;
 111aed8:	71001adf 	cmp	w22, #0x6
 111aedc:	129fff33 	mov	w19, #0xffff0006            	// #-65530
 111aee0:	129ffea0 	mov	w0, #0xffff000a            	// #-65526
 111aee4:	1a801273 	csel	w19, w19, w0, ne  // ne = any
 111aee8:	17ffff45 	b	111abfc <invoke_command+0xe4>
	size_t outlen = 0;
 111aeec:	f90037ff 	str	xzr, [sp, #104]
	if (exp_pt != param_types)
 111aef0:	5284e2a0 	mov	w0, #0x2715                	// #10005
 111aef4:	6b0002df 	cmp	w22, w0
 111aef8:	540001e1 	b.ne	111af34 <invoke_command+0x41c>  // b.any
	res = tee_invoke_supp_plugin_rpc(params[0].memref.buffer, /* uuid */
 111aefc:	29420a81 	ldp	w1, w2, [x20, #16]
 111af00:	9101a3e5 	add	x5, sp, #0x68
 111af04:	b9402a84 	ldr	w4, [x20, #40]
 111af08:	f9400280 	ldr	x0, [x20]
 111af0c:	f9401283 	ldr	x3, [x20, #32]
 111af10:	940033a2 	bl	1127d98 <tee_invoke_supp_plugin_rpc>
 111af14:	2a0003f3 	mov	w19, w0
	params[3].value.a = (uint32_t)outlen;
 111af18:	f94037e0 	ldr	x0, [sp, #104]
 111af1c:	b9003280 	str	w0, [x20, #48]
	return res;
 111af20:	17ffff37 	b	111abfc <invoke_command+0xe4>
 111af24:	129ffed3 	mov	w19, #0xffff0009            	// #-65527
 111af28:	17ffff35 	b	111abfc <invoke_command+0xe4>
		return TEE_ERROR_SECURITY;
 111af2c:	129ffe13 	mov	w19, #0xffff000f            	// #-65521
 111af30:	17ffff33 	b	111abfc <invoke_command+0xe4>
		return TEE_ERROR_BAD_PARAMETERS;
 111af34:	129fff33 	mov	w19, #0xffff0006            	// #-65530
 111af38:	17ffff31 	b	111abfc <invoke_command+0xe4>

000000000111af3c <copy_out_param>:
static void copy_out_param(struct tee_ta_param *ta_param, uint32_t num_params,
			   struct optee_msg_param *params, uint64_t *saved_attr)
{
	size_t n;

	for (n = 0; n < num_params; n++) {
 111af3c:	91002004 	add	x4, x0, #0x8
 111af40:	91002042 	add	x2, x2, #0x8
 111af44:	2a0103e1 	mov	w1, w1
 111af48:	d2800005 	mov	x5, #0x0                   	// #0
 111af4c:	eb05003f 	cmp	x1, x5
 111af50:	54000048 	b.hi	111af58 <copy_out_param+0x1c>  // b.pmore
			break;
		default:
			break;
		}
	}
}
 111af54:	d65f03c0 	ret
		switch (TEE_PARAM_TYPE_GET(ta_param->types, n)) {
 111af58:	b9400007 	ldr	w7, [x0]
 111af5c:	531e74a6 	lsl	w6, w5, #2
 111af60:	1ac624e6 	lsr	w6, w7, w6
 111af64:	12000cc7 	and	w7, w6, #0xf
 111af68:	721e04df 	tst	w6, #0xc
 111af6c:	540000e1 	b.ne	111af88 <copy_out_param+0x4c>  // b.any
 111af70:	721f08df 	tst	w6, #0xe
 111af74:	54000280 	b.eq	111afc4 <copy_out_param+0x88>  // b.none
			params[n].u.value.a = ta_param->u[n].val.a;
 111af78:	b9400086 	ldr	w6, [x4]
 111af7c:	f9000046 	str	x6, [x2]
			params[n].u.value.b = ta_param->u[n].val.b;
 111af80:	b9400486 	ldr	w6, [x4, #4]
 111af84:	1400000b 	b	111afb0 <copy_out_param+0x74>
		switch (TEE_PARAM_TYPE_GET(ta_param->types, n)) {
 111af88:	510018e6 	sub	w6, w7, #0x6
 111af8c:	710004df 	cmp	w6, #0x1
 111af90:	540001a8 	b.hi	111afc4 <copy_out_param+0x88>  // b.pmore
			switch (saved_attr[n] & OPTEE_MSG_ATTR_TYPE_MASK) {
 111af94:	f8657867 	ldr	x7, [x3, x5, lsl #3]
 111af98:	92401ce6 	and	x6, x7, #0xff
 111af9c:	f27d10ff 	tst	x7, #0xf8
 111afa0:	540000c1 	b.ne	111afb8 <copy_out_param+0x7c>  // b.any
 111afa4:	f10014df 	cmp	x6, #0x5
 111afa8:	540000e9 	b.ls	111afc4 <copy_out_param+0x88>  // b.plast
				params[n].u.rmem.size = ta_param->u[n].mem.size;
 111afac:	f9400486 	ldr	x6, [x4, #8]
			params[n].u.value.b = ta_param->u[n].val.b;
 111afb0:	f9000446 	str	x6, [x2, #8]
			break;
 111afb4:	14000004 	b	111afc4 <copy_out_param+0x88>
 111afb8:	d10028c6 	sub	x6, x6, #0xa
 111afbc:	f10004df 	cmp	x6, #0x1
 111afc0:	54ffff69 	b.ls	111afac <copy_out_param+0x70>  // b.plast
	for (n = 0; n < num_params; n++) {
 111afc4:	910004a5 	add	x5, x5, #0x1
 111afc8:	91006084 	add	x4, x4, #0x18
 111afcc:	91008042 	add	x2, x2, #0x20
 111afd0:	17ffffdf 	b	111af4c <copy_out_param+0x10>

000000000111afd4 <cleanup_shm_refs>:
{
 111afd4:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 111afd8:	910003fd 	mov	x29, sp
 111afdc:	a9025bf5 	stp	x21, x22, [sp, #32]
 111afe0:	aa0003f6 	mov	x22, x0
	for (n = 0; n < num_params; n++) {
 111afe4:	2a0203f5 	mov	w21, w2
{
 111afe8:	a90363f7 	stp	x23, x24, [sp, #48]
			mobj_put(param->u[n].mem.mobj);
 111afec:	91002037 	add	x23, x1, #0x8
 111aff0:	d2800318 	mov	x24, #0x18                  	// #24
{
 111aff4:	a90153f3 	stp	x19, x20, [sp, #16]
	for (n = 0; n < num_params; n++) {
 111aff8:	d2800013 	mov	x19, #0x0                   	// #0
 111affc:	eb1302bf 	cmp	x21, x19
 111b000:	540000c8 	b.hi	111b018 <cleanup_shm_refs+0x44>  // b.pmore
}
 111b004:	a94153f3 	ldp	x19, x20, [sp, #16]
 111b008:	a9425bf5 	ldp	x21, x22, [sp, #32]
 111b00c:	a94363f7 	ldp	x23, x24, [sp, #48]
 111b010:	a8c47bfd 	ldp	x29, x30, [sp], #64
 111b014:	d65f03c0 	ret
		switch (saved_attr[n]) {
 111b018:	f8737ac3 	ldr	x3, [x22, x19, lsl #3]
 111b01c:	f1001c7f 	cmp	x3, #0x7
 111b020:	540001e8 	b.hi	111b05c <cleanup_shm_refs+0x88>  // b.pmore
 111b024:	f100107f 	cmp	x3, #0x4
 111b028:	54000209 	b.ls	111b068 <cleanup_shm_refs+0x94>  // b.plast
			mobj_put(param->u[n].mem.mobj);
 111b02c:	9b187e60 	mul	x0, x19, x24
 111b030:	f8606af4 	ldr	x20, [x23, x0]
	if (mobj && refcount_dec(&mobj->refc))
 111b034:	b40001b4 	cbz	x20, 111b068 <cleanup_shm_refs+0x94>
 111b038:	91006280 	add	x0, x20, #0x18
 111b03c:	97ffe15c 	bl	11135ac <refcount_dec>
 111b040:	72001c1f 	tst	w0, #0xff
 111b044:	54000120 	b.eq	111b068 <cleanup_shm_refs+0x94>  // b.none
		mobj->ops->free(mobj);
 111b048:	f9400280 	ldr	x0, [x20]
 111b04c:	f9401401 	ldr	x1, [x0, #40]
 111b050:	aa1403e0 	mov	x0, x20
 111b054:	d63f0020 	blr	x1
 111b058:	14000004 	b	111b068 <cleanup_shm_refs+0x94>
		switch (saved_attr[n]) {
 111b05c:	d1002463 	sub	x3, x3, #0x9
 111b060:	f100087f 	cmp	x3, #0x2
 111b064:	54fffe49 	b.ls	111b02c <cleanup_shm_refs+0x58>  // b.plast
	for (n = 0; n < num_params; n++) {
 111b068:	91000673 	add	x19, x19, #0x1
 111b06c:	17ffffe4 	b	111affc <cleanup_shm_refs+0x28>

000000000111b070 <default_mobj_init>:

	return rv;
}

static TEE_Result default_mobj_init(void)
{
 111b070:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
#ifdef CFG_CORE_RESERVED_SHM
	shm_mobj = mobj_phys_alloc(default_nsec_shm_paddr,
 111b074:	f00001e0 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
{
 111b078:	910003fd 	mov	x29, sp
	shm_mobj = mobj_phys_alloc(default_nsec_shm_paddr,
 111b07c:	f9422001 	ldr	x1, [x0, #1088]
{
 111b080:	a90153f3 	stp	x19, x20, [sp, #16]
	shm_mobj = mobj_phys_alloc(default_nsec_shm_paddr,
 111b084:	f9418400 	ldr	x0, [x0, #776]
 111b088:	f9400033 	ldr	x19, [x1]
 111b08c:	f9400014 	ldr	x20, [x0]
 111b090:	52800140 	mov	w0, #0xa                   	// #10
 111b094:	97ffb6b2 	bl	1108b5c <core_mmu_type_to_attr>
 111b098:	d34c3002 	ubfx	x2, x0, #12, #1
 111b09c:	aa1403e1 	mov	x1, x20
 111b0a0:	aa1303e0 	mov	x0, x19
 111b0a4:	52800023 	mov	w3, #0x1                   	// #1
 111b0a8:	97fff43a 	bl	1118190 <mobj_phys_alloc>
 111b0ac:	f0000201 	adrp	x1, 115e000 <state+0x80>
 111b0b0:	f900b020 	str	x0, [x1, #352]
				   default_nsec_shm_size, SHM_CACHE_ATTRS,
				   CORE_MEM_NSEC_SHM);
	if (!shm_mobj)
 111b0b4:	b5000120 	cbnz	x0, 111b0d8 <default_mobj_init+0x68>
		panic("Failed to register shared memory");
 111b0b8:	d00001c3 	adrp	x3, 1155000 <__func__.3826+0xa8>
 111b0bc:	d00001c2 	adrp	x2, 1155000 <__func__.3826+0xa8>
 111b0c0:	d00001c0 	adrp	x0, 1155000 <__func__.3826+0xa8>
 111b0c4:	9114a063 	add	x3, x3, #0x528
 111b0c8:	9117d442 	add	x2, x2, #0x5f5
 111b0cc:	91152400 	add	x0, x0, #0x549
 111b0d0:	52804861 	mov	w1, #0x243                 	// #579
 111b0d4:	97ffe0e5 	bl	1113468 <__do_panic>
	if (!sdp_mem_mobjs)
		panic("Failed to register SDP memory");
#endif

	return TEE_SUCCESS;
}
 111b0d8:	52800000 	mov	w0, #0x0                   	// #0
 111b0dc:	a94153f3 	ldp	x19, x20, [sp, #16]
 111b0e0:	a8c27bfd 	ldp	x29, x30, [sp], #32
 111b0e4:	d65f03c0 	ret

000000000111b0e8 <copy_in_params>:
{
 111b0e8:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
	if (num_params > TEE_NUM_PARAMS)
 111b0ec:	7100103f 	cmp	w1, #0x4
{
 111b0f0:	910003fd 	mov	x29, sp
 111b0f4:	a90153f3 	stp	x19, x20, [sp, #16]
 111b0f8:	a9025bf5 	stp	x21, x22, [sp, #32]
 111b0fc:	a90363f7 	stp	x23, x24, [sp, #48]
 111b100:	a9046bf9 	stp	x25, x26, [sp, #64]
 111b104:	a90573fb 	stp	x27, x28, [sp, #80]
 111b108:	f90037e3 	str	x3, [sp, #104]
	uint8_t pt[TEE_NUM_PARAMS] = { 0 };
 111b10c:	b90083ff 	str	wzr, [sp, #128]
	if (num_params > TEE_NUM_PARAMS)
 111b110:	54000069 	b.ls	111b11c <copy_in_params+0x34>  // b.plast
		attr = saved_attr[n] & OPTEE_MSG_ATTR_TYPE_MASK;
 111b114:	129fff20 	mov	w0, #0xffff0006            	// #-65530
 111b118:	1400001e 	b	111b190 <copy_in_params+0xa8>
 111b11c:	aa0203f7 	mov	x23, x2
	memset(ta_param, 0, sizeof(*ta_param));
 111b120:	2a0103f6 	mov	w22, w1
 111b124:	aa0003fa 	mov	x26, x0
 111b128:	d2800d02 	mov	x2, #0x68                  	// #104
 111b12c:	aa1703e0 	mov	x0, x23
 111b130:	52800001 	mov	w1, #0x0                   	// #0
 111b134:	9400a2eb 	bl	1143ce0 <memset>
	for (n = 0; n < num_params; n++) {
 111b138:	910022f3 	add	x19, x23, #0x8
 111b13c:	2a1603e0 	mov	w0, w22
			pt[n] = TEE_PARAM_TYPE_MEMREF_INPUT + attr -
 111b140:	910203f9 	add	x25, sp, #0x80
		return mobj->ops->get_pa(mobj, offs, granule, pa);
 111b144:	910223fc 	add	x28, sp, #0x88
 111b148:	f000019b 	adrp	x27, 114e000 <ldelf_data+0x8000>
	for (n = 0; n < num_params; n++) {
 111b14c:	d2800015 	mov	x21, #0x0                   	// #0
 111b150:	f9003be0 	str	x0, [sp, #112]
 111b154:	911b4360 	add	x0, x27, #0x6d0
 111b158:	f9003fe0 	str	x0, [sp, #120]
 111b15c:	f9403be0 	ldr	x0, [sp, #112]
 111b160:	eb15001f 	cmp	x0, x21
 111b164:	54000248 	b.hi	111b1ac <copy_in_params+0xc4>  // b.pmore
	ta_param->types = TEE_PARAM_TYPES(pt[0], pt[1], pt[2], pt[3]);
 111b168:	39420be1 	ldrb	w1, [sp, #130]
 111b16c:	394207e0 	ldrb	w0, [sp, #129]
 111b170:	394203e2 	ldrb	w2, [sp, #128]
 111b174:	53185c21 	lsl	w1, w1, #8
 111b178:	2a001020 	orr	w0, w1, w0, lsl #4
 111b17c:	39420fe1 	ldrb	w1, [sp, #131]
 111b180:	2a013041 	orr	w1, w2, w1, lsl #12
 111b184:	2a010000 	orr	w0, w0, w1
 111b188:	b90002e0 	str	w0, [x23]
	return TEE_SUCCESS;
 111b18c:	52800000 	mov	w0, #0x0                   	// #0
}
 111b190:	a94153f3 	ldp	x19, x20, [sp, #16]
 111b194:	a9425bf5 	ldp	x21, x22, [sp, #32]
 111b198:	a94363f7 	ldp	x23, x24, [sp, #48]
 111b19c:	a9446bf9 	ldp	x25, x26, [sp, #64]
 111b1a0:	a94573fb 	ldp	x27, x28, [sp, #80]
 111b1a4:	a8c97bfd 	ldp	x29, x30, [sp], #144
 111b1a8:	d65f03c0 	ret
		saved_attr[n] = READ_ONCE(params[n].attr);
 111b1ac:	f9400354 	ldr	x20, [x26]
 111b1b0:	f94037e0 	ldr	x0, [sp, #104]
 111b1b4:	f8357814 	str	x20, [x0, x21, lsl #3]
		if (saved_attr[n] & OPTEE_MSG_ATTR_META)
 111b1b8:	3747faf4 	tbnz	w20, #8, 111b114 <copy_in_params+0x2c>
		attr = saved_attr[n] & OPTEE_MSG_ATTR_TYPE_MASK;
 111b1bc:	12001e80 	and	w0, w20, #0xff
 111b1c0:	71002c1f 	cmp	w0, #0xb
 111b1c4:	54fffa88 	b.hi	111b114 <copy_in_params+0x2c>  // b.pmore
 111b1c8:	f9403fe1 	ldr	x1, [sp, #120]
 111b1cc:	38604820 	ldrb	w0, [x1, w0, uxtw]
 111b1d0:	10000061 	adr	x1, 111b1dc <copy_in_params+0xf4>
 111b1d4:	8b208820 	add	x0, x1, w0, sxtb #2
 111b1d8:	d61f0000 	br	x0
			pt[n] = TEE_PARAM_TYPE_NONE;
 111b1dc:	38396abf 	strb	wzr, [x21, x25]
	for (n = 0; n < num_params; n++) {
 111b1e0:	910006b5 	add	x21, x21, #0x1
 111b1e4:	9100835a 	add	x26, x26, #0x20
 111b1e8:	91006273 	add	x19, x19, #0x18
 111b1ec:	17ffffdc 	b	111b15c <copy_in_params+0x74>
			ta_param->u[n].val.a = READ_ONCE(params[n].u.value.a);
 111b1f0:	91002340 	add	x0, x26, #0x8
			pt[n] = TEE_PARAM_TYPE_VALUE_INPUT + attr -
 111b1f4:	38396ab4 	strb	w20, [x21, x25]
			ta_param->u[n].val.a = READ_ONCE(params[n].u.value.a);
 111b1f8:	f9400000 	ldr	x0, [x0]
 111b1fc:	b9000260 	str	w0, [x19]
			ta_param->u[n].val.b = READ_ONCE(params[n].u.value.b);
 111b200:	91004340 	add	x0, x26, #0x10
 111b204:	f9400000 	ldr	x0, [x0]
 111b208:	b9000660 	str	w0, [x19, #4]
			break;
 111b20c:	17fffff5 	b	111b1e0 <copy_in_params+0xf8>
	paddr_t pa = READ_ONCE(tmem->buf_ptr);
 111b210:	91002340 	add	x0, x26, #0x8
 111b214:	f9400016 	ldr	x22, [x0]
	size_t sz = READ_ONCE(tmem->size);
 111b218:	91004340 	add	x0, x26, #0x10
 111b21c:	f9400018 	ldr	x24, [x0]
	if (!pa) {
 111b220:	b50000d6 	cbnz	x22, 111b238 <copy_in_params+0x150>
		mem->size = 0;
 111b224:	a9007e7f 	stp	xzr, xzr, [x19]
		mem->offs = 0;
 111b228:	f9000a7f 	str	xzr, [x19, #16]
			pt[n] = TEE_PARAM_TYPE_MEMREF_INPUT + attr -
 111b22c:	51001294 	sub	w20, w20, #0x4
			pt[n] = TEE_PARAM_TYPE_MEMREF_INPUT + attr -
 111b230:	38396ab4 	strb	w20, [x21, x25]
			break;
 111b234:	17ffffeb 	b	111b1e0 <copy_in_params+0xf8>
	if (attr & OPTEE_MSG_ATTR_NONCONTIG) {
 111b238:	36480194 	tbz	w20, #9, 111b268 <copy_in_params+0x180>
		uint64_t shm_ref = READ_ONCE(tmem->shm_ref);
 111b23c:	91006340 	add	x0, x26, #0x18
 111b240:	f9400002 	ldr	x2, [x0]
		mem->mobj = msg_param_mobj_from_noncontig(pa, sz, shm_ref,
 111b244:	52800003 	mov	w3, #0x0                   	// #0
 111b248:	aa1803e1 	mov	x1, x24
 111b24c:	aa1603e0 	mov	x0, x22
 111b250:	97ffe01f 	bl	11132cc <msg_param_mobj_from_noncontig>
 111b254:	f9000260 	str	x0, [x19]
		if (!mem->mobj)
 111b258:	b4fff5e0 	cbz	x0, 111b114 <copy_in_params+0x2c>
		mem->offs = 0;
 111b25c:	f9000a7f 	str	xzr, [x19, #16]
	mem->size = sz;
 111b260:	f9000678 	str	x24, [x19, #8]
			if (res)
 111b264:	17fffff2 	b	111b22c <copy_in_params+0x144>
	if (param_mem_from_mobj(mem, shm_mobj, pa, sz))
 111b268:	f0000200 	adrp	x0, 115e000 <state+0x80>
 111b26c:	f940b01b 	ldr	x27, [x0, #352]
	if (mobj && mobj->ops && mobj->ops->get_pa)
 111b270:	b500013b 	cbnz	x27, 111b294 <copy_in_params+0x1ac>
		panic("mobj_get_pa failed");
 111b274:	d00001c3 	adrp	x3, 1155000 <__func__.3826+0xa8>
 111b278:	d00001c2 	adrp	x2, 1155000 <__func__.3826+0xa8>
 111b27c:	d00001c0 	adrp	x0, 1155000 <__func__.3826+0xa8>
 111b280:	91157863 	add	x3, x3, #0x55e
 111b284:	91170842 	add	x2, x2, #0x5c2
 111b288:	91152400 	add	x0, x0, #0x549
 111b28c:	52800661 	mov	w1, #0x33                  	// #51
		panic();
 111b290:	97ffe076 	bl	1113468 <__do_panic>
	if (mobj && mobj->ops && mobj->ops->get_pa)
 111b294:	f9400360 	ldr	x0, [x27]
 111b298:	b4fffee0 	cbz	x0, 111b274 <copy_in_params+0x18c>
 111b29c:	f9400407 	ldr	x7, [x0, #8]
 111b2a0:	b4fffea7 	cbz	x7, 111b274 <copy_in_params+0x18c>
		return mobj->ops->get_pa(mobj, offs, granule, pa);
 111b2a4:	aa1c03e3 	mov	x3, x28
 111b2a8:	aa1b03e0 	mov	x0, x27
 111b2ac:	d2800002 	mov	x2, #0x0                   	// #0
 111b2b0:	d2800001 	mov	x1, #0x0                   	// #0
 111b2b4:	d63f00e0 	blr	x7
	if (mobj_get_pa(mobj, 0, 0, &b) != TEE_SUCCESS)
 111b2b8:	35fffde0 	cbnz	w0, 111b274 <copy_in_params+0x18c>
	if (!core_is_buffer_inside(pa, MAX(sz, 1UL), b, mobj->size))
 111b2bc:	f9400763 	ldr	x3, [x27, #8]
 111b2c0:	f100031f 	cmp	x24, #0x0
 111b2c4:	f94047e2 	ldr	x2, [sp, #136]
 111b2c8:	9a9f1701 	csinc	x1, x24, xzr, ne  // ne = any
 111b2cc:	aa1603e0 	mov	x0, x22
 111b2d0:	97ffe0db 	bl	111363c <core_is_buffer_inside>
 111b2d4:	72001c1f 	tst	w0, #0xff
 111b2d8:	54fff1e0 	b.eq	111b114 <copy_in_params+0x2c>  // b.none
	if (mobj && !refcount_inc(&mobj->refc))
 111b2dc:	91006360 	add	x0, x27, #0x18
 111b2e0:	97ffe0a5 	bl	1113574 <refcount_inc>
 111b2e4:	72001c1f 	tst	w0, #0xff
 111b2e8:	54000101 	b.ne	111b308 <copy_in_params+0x220>  // b.any
		panic();
 111b2ec:	d00001c2 	adrp	x2, 1155000 <__func__.3826+0xa8>
 111b2f0:	900001c0 	adrp	x0, 1153000 <__func__.3477+0x91>
 111b2f4:	9116e442 	add	x2, x2, #0x5b9
 111b2f8:	91019c00 	add	x0, x0, #0x67
 111b2fc:	d2800003 	mov	x3, #0x0                   	// #0
 111b300:	52801041 	mov	w1, #0x82                  	// #130
 111b304:	17ffffe3 	b	111b290 <copy_in_params+0x1a8>
	mem->offs = pa - b;
 111b308:	f94047e0 	ldr	x0, [sp, #136]
	mem->mobj = mobj_get(mobj);
 111b30c:	f900027b 	str	x27, [x19]
	mem->offs = pa - b;
 111b310:	cb0002c5 	sub	x5, x22, x0
 111b314:	f9000a65 	str	x5, [x19, #16]
 111b318:	17ffffd2 	b	111b260 <copy_in_params+0x178>
	uint64_t shm_ref = READ_ONCE(rmem->shm_ref);
 111b31c:	91006340 	add	x0, x26, #0x18
 111b320:	f9400000 	ldr	x0, [x0]
	size_t sz = READ_ONCE(rmem->size);
 111b324:	91004341 	add	x1, x26, #0x10
 111b328:	f9400038 	ldr	x24, [x1]
	mem->mobj = mobj_reg_shm_get_by_cookie(shm_ref);
 111b32c:	97ffc4d8 	bl	110c68c <mobj_reg_shm_get_by_cookie>
 111b330:	f9000260 	str	x0, [x19]
	if (!mem->mobj)
 111b334:	b4ffef00 	cbz	x0, 111b114 <copy_in_params+0x2c>
	mem->offs = READ_ONCE(rmem->offs);
 111b338:	91002341 	add	x1, x26, #0x8
 111b33c:	f9400021 	ldr	x1, [x1]
 111b340:	a9008678 	stp	x24, x1, [x19, #8]
	if (ADD_OVERFLOW(mem->offs, mem->size, &req_size) ||
 111b344:	ab180021 	adds	x1, x1, x24
 111b348:	54000082 	b.cs	111b358 <copy_in_params+0x270>  // b.hs, b.nlast
 111b34c:	f9400400 	ldr	x0, [x0, #8]
 111b350:	eb00003f 	cmp	x1, x0
 111b354:	54fff6e9 	b.ls	111b230 <copy_in_params+0x148>  // b.plast
		return TEE_ERROR_SECURITY;
 111b358:	129ffe00 	mov	w0, #0xffff000f            	// #-65521
 111b35c:	17ffff8d 	b	111b190 <copy_in_params+0xa8>

000000000111b360 <nsec_sessions_list_head>:
	*open_sessions = &tee_open_sessions;
 111b360:	90000201 	adrp	x1, 115b000 <__vcore_unpg_rw_start>
 111b364:	91214021 	add	x1, x1, #0x850
 111b368:	f9000001 	str	x1, [x0]
}
 111b36c:	d65f03c0 	ret

000000000111b370 <__tee_entry_std>:
{
 111b370:	a9af7bfd 	stp	x29, x30, [sp, #-272]!
 111b374:	910003fd 	mov	x29, sp
 111b378:	a90153f3 	stp	x19, x20, [sp, #16]
 111b37c:	aa0003f3 	mov	x19, x0
 111b380:	2a0103f4 	mov	w20, w1
	thread_set_foreign_intr(true);
 111b384:	52800020 	mov	w0, #0x1                   	// #1
{
 111b388:	a9025bf5 	stp	x21, x22, [sp, #32]
 111b38c:	a90363f7 	stp	x23, x24, [sp, #48]
 111b390:	a9046bf9 	stp	x25, x26, [sp, #64]
	thread_set_foreign_intr(true);
 111b394:	97ffaa2c 	bl	1105c44 <thread_set_foreign_intr>
	switch (arg->cmd) {
 111b398:	b9400275 	ldr	w21, [x19]
 111b39c:	710016bf 	cmp	w21, #0x5
 111b3a0:	54001b48 	b.hi	111b708 <__tee_entry_std+0x398>  // b.pmore
 111b3a4:	f0000180 	adrp	x0, 114e000 <ldelf_data+0x8000>
 111b3a8:	911b7000 	add	x0, x0, #0x6dc
 111b3ac:	78755800 	ldrh	w0, [x0, w21, uxtw #1]
 111b3b0:	10000061 	adr	x1, 111b3bc <__tee_entry_std+0x4c>
 111b3b4:	8b20a820 	add	x0, x1, w0, sxth #2
 111b3b8:	d61f0000 	br	x0
	TEE_ErrorOrigin err_orig = TEE_ORIGIN_TEE;
 111b3bc:	52800060 	mov	w0, #0x3                   	// #3
 111b3c0:	b90057e0 	str	w0, [sp, #84]
	struct tee_ta_session *s = NULL;
 111b3c4:	f9002fff 	str	xzr, [sp, #88]
	if (num_params < 2)
 111b3c8:	7100069f 	cmp	w20, #0x1
	uint64_t saved_attr[TEE_NUM_PARAMS] = { 0 };
 111b3cc:	a908ffff 	stp	xzr, xzr, [sp, #136]
 111b3d0:	a909ffff 	stp	xzr, xzr, [sp, #152]
	if (num_params < 2)
 111b3d4:	54000269 	b.ls	111b420 <__tee_entry_std+0xb0>  // b.plast
	if (params[0].attr != req_attr || params[1].attr != req_attr)
 111b3d8:	f9401260 	ldr	x0, [x19, #32]
 111b3dc:	f104041f 	cmp	x0, #0x101
 111b3e0:	54000201 	b.ne	111b420 <__tee_entry_std+0xb0>  // b.any
 111b3e4:	f9402260 	ldr	x0, [x19, #64]
 111b3e8:	f104041f 	cmp	x0, #0x101
 111b3ec:	540001a1 	b.ne	111b420 <__tee_entry_std+0xb0>  // b.any
	tee_uuid_from_octets(uuid, (void *)&params[0].u.value);
 111b3f0:	910183f8 	add	x24, sp, #0x60
 111b3f4:	9100a261 	add	x1, x19, #0x28
 111b3f8:	aa1803e0 	mov	x0, x24
 111b3fc:	94003250 	bl	1127d3c <tee_uuid_from_octets>
	clnt_id->login = params[1].u.value.c;
 111b400:	f9402e60 	ldr	x0, [x19, #88]
 111b404:	b90073e0 	str	w0, [sp, #112]
	switch (clnt_id->login) {
 111b408:	7100181f 	cmp	w0, #0x6
 111b40c:	540000e8 	b.hi	111b428 <__tee_entry_std+0xb8>  // b.pmore
 111b410:	71000c1f 	cmp	w0, #0x3
 111b414:	54000788 	b.hi	111b504 <__tee_entry_std+0x194>  // b.pmore
 111b418:	340000e0 	cbz	w0, 111b434 <__tee_entry_std+0xc4>
 111b41c:	54000741 	b.ne	111b504 <__tee_entry_std+0x194>  // b.any
 111b420:	129fff36 	mov	w22, #0xffff0006            	// #-65530
 111b424:	1400002a 	b	111b4cc <__tee_entry_std+0x15c>
 111b428:	52b00001 	mov	w1, #0x80000000            	// #-2147483648
 111b42c:	6b01001f 	cmp	w0, w1
 111b430:	54ffff81 	b.ne	111b420 <__tee_entry_std+0xb0>  // b.any
		memset(&clnt_id->uuid, 0, sizeof(clnt_id->uuid));
 111b434:	290effff 	stp	wzr, wzr, [sp, #116]
 111b438:	290fffff 	stp	wzr, wzr, [sp, #124]
	res = copy_in_params(arg->params + num_meta, num_params - num_meta,
 111b43c:	9101827a 	add	x26, x19, #0x60
 111b440:	51000a94 	sub	w20, w20, #0x2
 111b444:	910223f9 	add	x25, sp, #0x88
 111b448:	9102a3f7 	add	x23, sp, #0xa8
 111b44c:	aa1903e3 	mov	x3, x25
 111b450:	aa1703e2 	mov	x2, x23
 111b454:	2a1403e1 	mov	w1, w20
 111b458:	aa1a03e0 	mov	x0, x26
 111b45c:	97ffff23 	bl	111b0e8 <copy_in_params>
 111b460:	2a0003f6 	mov	w22, w0
	if (res != TEE_SUCCESS)
 111b464:	350002c0 	cbnz	w0, 111b4bc <__tee_entry_std+0x14c>
	res = tee_ta_open_session(&err_orig, &s, &tee_open_sessions, &uuid,
 111b468:	aa1703e6 	mov	x6, x23
 111b46c:	9101c3e4 	add	x4, sp, #0x70
 111b470:	aa1803e3 	mov	x3, x24
 111b474:	910163e1 	add	x1, sp, #0x58
 111b478:	910153e0 	add	x0, sp, #0x54
 111b47c:	12800005 	mov	w5, #0xffffffff            	// #-1
 111b480:	90000202 	adrp	x2, 115b000 <__vcore_unpg_rw_start>
 111b484:	91214042 	add	x2, x2, #0x850
 111b488:	97ffe364 	bl	1114218 <tee_ta_open_session>
 111b48c:	2a0003f6 	mov	w22, w0
	if (res != TEE_SUCCESS)
 111b490:	34000040 	cbz	w0, 111b498 <__tee_entry_std+0x128>
		s = NULL;
 111b494:	f9002fff 	str	xzr, [sp, #88]
	copy_out_param(&param, num_params - num_meta, arg->params + num_meta,
 111b498:	aa1903e3 	mov	x3, x25
 111b49c:	aa1a03e2 	mov	x2, x26
 111b4a0:	2a1403e1 	mov	w1, w20
 111b4a4:	aa1703e0 	mov	x0, x23
 111b4a8:	97fffea5 	bl	111af3c <copy_out_param>
	plat_prng_add_jitter_entropy(CRYPTO_RNG_SRC_JITTER_SESSION,
 111b4ac:	b0000261 	adrp	x1, 1168000 <data.5093+0x9e28>
 111b4b0:	52800000 	mov	w0, #0x0                   	// #0
 111b4b4:	912a1021 	add	x1, x1, #0xa84
 111b4b8:	97ffa3b3 	bl	1104384 <plat_prng_add_jitter_entropy>
	cleanup_shm_refs(saved_attr, &param, num_params - num_meta);
 111b4bc:	2a1403e2 	mov	w2, w20
 111b4c0:	aa1703e1 	mov	x1, x23
 111b4c4:	aa1903e0 	mov	x0, x25
 111b4c8:	97fffec3 	bl	111afd4 <cleanup_shm_refs>
	if (s)
 111b4cc:	f9402fe0 	ldr	x0, [sp, #88]
 111b4d0:	b4000220 	cbz	x0, 111b514 <__tee_entry_std+0x1a4>
		arg->session = s->id;
 111b4d4:	b9403800 	ldr	w0, [x0, #56]
 111b4d8:	b9000a60 	str	w0, [x19, #8]
	arg->ret_origin = err_orig;
 111b4dc:	b94057e0 	ldr	w0, [sp, #84]
	arg->ret = res;
 111b4e0:	b9001676 	str	w22, [x19, #20]
	arg->ret_origin = err_orig;
 111b4e4:	b9001a60 	str	w0, [x19, #24]
}
 111b4e8:	2a1503e0 	mov	w0, w21
 111b4ec:	a94153f3 	ldp	x19, x20, [sp, #16]
 111b4f0:	a9425bf5 	ldp	x21, x22, [sp, #32]
 111b4f4:	a94363f7 	ldp	x23, x24, [sp, #48]
 111b4f8:	a9446bf9 	ldp	x25, x26, [sp, #64]
 111b4fc:	a8d17bfd 	ldp	x29, x30, [sp], #272
 111b500:	d65f03c0 	ret
		tee_uuid_from_octets(&clnt_id->uuid,
 111b504:	91012261 	add	x1, x19, #0x48
 111b508:	9101d3e0 	add	x0, sp, #0x74
 111b50c:	9400320c 	bl	1127d3c <tee_uuid_from_octets>
	if (res != TEE_SUCCESS)
 111b510:	17ffffcb 	b	111b43c <__tee_entry_std+0xcc>
		arg->session = 0;
 111b514:	2a1503e0 	mov	w0, w21
 111b518:	17fffff0 	b	111b4d8 <__tee_entry_std+0x168>
	if (num_params) {
 111b51c:	35000f34 	cbnz	w20, 111b700 <__tee_entry_std+0x390>
	plat_prng_add_jitter_entropy(CRYPTO_RNG_SRC_JITTER_SESSION,
 111b520:	52800000 	mov	w0, #0x0                   	// #0
 111b524:	b0000261 	adrp	x1, 1168000 <data.5093+0x9e28>
 111b528:	912a1021 	add	x1, x1, #0xa84
 111b52c:	97ffa396 	bl	1104384 <plat_prng_add_jitter_entropy>
	s = tee_ta_find_session(arg->session, &tee_open_sessions);
 111b530:	b9400a60 	ldr	w0, [x19, #8]
 111b534:	90000214 	adrp	x20, 115b000 <__vcore_unpg_rw_start>
 111b538:	91214294 	add	x20, x20, #0x850
 111b53c:	aa1403e1 	mov	x1, x20
 111b540:	97ffe1eb 	bl	1113cec <tee_ta_find_session>
	res = tee_ta_close_session(s, &tee_open_sessions, NSAPP_IDENTITY);
 111b544:	aa1403e1 	mov	x1, x20
 111b548:	d2800002 	mov	x2, #0x0                   	// #0
 111b54c:	97ffe2b2 	bl	1114014 <tee_ta_close_session>
		arg->ret = TEE_ERROR_BAD_PARAMETERS;
 111b550:	b9001660 	str	w0, [x19, #20]
		arg->ret_origin = TEE_ORIGIN_TEE;
 111b554:	52800060 	mov	w0, #0x3                   	// #3
 111b558:	1400002f 	b	111b614 <__tee_entry_std+0x2a4>
	struct tee_ta_param param = { 0 };
 111b55c:	9102a3f6 	add	x22, sp, #0xa8
	TEE_ErrorOrigin err_orig = TEE_ORIGIN_TEE;
 111b560:	52800060 	mov	w0, #0x3                   	// #3
	struct tee_ta_param param = { 0 };
 111b564:	d2800d02 	mov	x2, #0x68                  	// #104
 111b568:	52800001 	mov	w1, #0x0                   	// #0
	res = copy_in_params(arg->params, num_params, &param, saved_attr);
 111b56c:	91008279 	add	x25, x19, #0x20
 111b570:	910223f8 	add	x24, sp, #0x88
	TEE_ErrorOrigin err_orig = TEE_ORIGIN_TEE;
 111b574:	b90073e0 	str	w0, [sp, #112]
	struct tee_ta_param param = { 0 };
 111b578:	aa1603e0 	mov	x0, x22
 111b57c:	9400a1d9 	bl	1143ce0 <memset>
	uint64_t saved_attr[TEE_NUM_PARAMS] = { 0 };
 111b580:	a908ffff 	stp	xzr, xzr, [sp, #136]
	res = copy_in_params(arg->params, num_params, &param, saved_attr);
 111b584:	aa1803e3 	mov	x3, x24
 111b588:	aa1603e2 	mov	x2, x22
 111b58c:	2a1403e1 	mov	w1, w20
 111b590:	aa1903e0 	mov	x0, x25
	uint64_t saved_attr[TEE_NUM_PARAMS] = { 0 };
 111b594:	a909ffff 	stp	xzr, xzr, [sp, #152]
	res = copy_in_params(arg->params, num_params, &param, saved_attr);
 111b598:	97fffed4 	bl	111b0e8 <copy_in_params>
 111b59c:	2a0003f5 	mov	w21, w0
	if (res != TEE_SUCCESS)
 111b5a0:	350002e0 	cbnz	w0, 111b5fc <__tee_entry_std+0x28c>
	s = tee_ta_get_session(arg->session, true, &tee_open_sessions);
 111b5a4:	b9400a60 	ldr	w0, [x19, #8]
 111b5a8:	90000202 	adrp	x2, 115b000 <__vcore_unpg_rw_start>
 111b5ac:	52800021 	mov	w1, #0x1                   	// #1
 111b5b0:	91214042 	add	x2, x2, #0x850
 111b5b4:	97ffe1e3 	bl	1113d40 <tee_ta_get_session>
 111b5b8:	aa0003f7 	mov	x23, x0
	if (!s) {
 111b5bc:	b4000300 	cbz	x0, 111b61c <__tee_entry_std+0x2ac>
	res = tee_ta_invoke_command(&err_orig, s, NSAPP_IDENTITY,
 111b5c0:	b9400664 	ldr	w4, [x19, #4]
 111b5c4:	aa0003e1 	mov	x1, x0
 111b5c8:	aa1603e5 	mov	x5, x22
 111b5cc:	12800003 	mov	w3, #0xffffffff            	// #-1
 111b5d0:	d2800002 	mov	x2, #0x0                   	// #0
 111b5d4:	9101c3e0 	add	x0, sp, #0x70
 111b5d8:	97ffe468 	bl	1114778 <tee_ta_invoke_command>
 111b5dc:	2a0003f5 	mov	w21, w0
	tee_ta_put_session(s);
 111b5e0:	aa1703e0 	mov	x0, x23
 111b5e4:	97ffe1ab 	bl	1113c90 <tee_ta_put_session>
	copy_out_param(&param, num_params, arg->params, saved_attr);
 111b5e8:	aa1803e3 	mov	x3, x24
 111b5ec:	aa1903e2 	mov	x2, x25
 111b5f0:	2a1403e1 	mov	w1, w20
 111b5f4:	aa1603e0 	mov	x0, x22
 111b5f8:	97fffe51 	bl	111af3c <copy_out_param>
	cleanup_shm_refs(saved_attr, &param, num_params);
 111b5fc:	aa1803e0 	mov	x0, x24
 111b600:	2a1403e2 	mov	w2, w20
 111b604:	aa1603e1 	mov	x1, x22
 111b608:	97fffe73 	bl	111afd4 <cleanup_shm_refs>
	arg->ret_origin = err_orig;
 111b60c:	b94073e0 	ldr	w0, [sp, #112]
	arg->ret = res;
 111b610:	b9001675 	str	w21, [x19, #20]
		arg->ret_origin = TEE_ORIGIN_TEE;
 111b614:	b9001a60 	str	w0, [x19, #24]
 111b618:	1400001d 	b	111b68c <__tee_entry_std+0x31c>
		res = TEE_ERROR_BAD_PARAMETERS;
 111b61c:	129fff35 	mov	w21, #0xffff0006            	// #-65530
 111b620:	17fffff7 	b	111b5fc <__tee_entry_std+0x28c>
	TEE_ErrorOrigin err_orig = TEE_ORIGIN_TEE;
 111b624:	52800060 	mov	w0, #0x3                   	// #3
 111b628:	b900abe0 	str	w0, [sp, #168]
	if (num_params) {
 111b62c:	340000b4 	cbz	w20, 111b640 <__tee_entry_std+0x2d0>
		res = TEE_ERROR_BAD_PARAMETERS;
 111b630:	129fff35 	mov	w21, #0xffff0006            	// #-65530
	arg->ret_origin = err_orig;
 111b634:	b940abe0 	ldr	w0, [sp, #168]
	arg->ret = res;
 111b638:	b9001675 	str	w21, [x19, #20]
	arg->ret_origin = err_orig;
 111b63c:	17fffff6 	b	111b614 <__tee_entry_std+0x2a4>
	s = tee_ta_get_session(arg->session, false, &tee_open_sessions);
 111b640:	b9400a60 	ldr	w0, [x19, #8]
 111b644:	90000202 	adrp	x2, 115b000 <__vcore_unpg_rw_start>
 111b648:	52800001 	mov	w1, #0x0                   	// #0
 111b64c:	91214042 	add	x2, x2, #0x850
 111b650:	97ffe1bc 	bl	1113d40 <tee_ta_get_session>
 111b654:	aa0003f4 	mov	x20, x0
	if (!s) {
 111b658:	b4fffec0 	cbz	x0, 111b630 <__tee_entry_std+0x2c0>
	res = tee_ta_cancel_command(&err_orig, s, NSAPP_IDENTITY);
 111b65c:	aa0003e1 	mov	x1, x0
 111b660:	d2800002 	mov	x2, #0x0                   	// #0
 111b664:	9102a3e0 	add	x0, sp, #0xa8
 111b668:	97ffe1f2 	bl	1113e30 <tee_ta_cancel_command>
 111b66c:	2a0003f5 	mov	w21, w0
	tee_ta_put_session(s);
 111b670:	aa1403e0 	mov	x0, x20
 111b674:	97ffe187 	bl	1113c90 <tee_ta_put_session>
 111b678:	17ffffef 	b	111b634 <__tee_entry_std+0x2c4>
	arg->ret = TEE_ERROR_BAD_PARAMETERS;
 111b67c:	129fff20 	mov	w0, #0xffff0006            	// #-65530
 111b680:	b9001660 	str	w0, [x19, #20]
	if (num_params != 1 ||
 111b684:	7100069f 	cmp	w20, #0x1
 111b688:	54000060 	b.eq	111b694 <__tee_entry_std+0x324>  // b.none
	uint32_t rv = OPTEE_SMC_RETURN_OK;
 111b68c:	52800015 	mov	w21, #0x0                   	// #0
 111b690:	17ffff96 	b	111b4e8 <__tee_entry_std+0x178>
	if (num_params != 1 ||
 111b694:	f9401260 	ldr	x0, [x19, #32]
 111b698:	f108281f 	cmp	x0, #0x20a
 111b69c:	54ffff81 	b.ne	111b68c <__tee_entry_std+0x31c>  // b.any
	struct mobj *mobj = msg_param_mobj_from_noncontig(tmem->buf_ptr,
 111b6a0:	a9428660 	ldp	x0, x1, [x19, #40]
 111b6a4:	52800003 	mov	w3, #0x0                   	// #0
 111b6a8:	f9401e62 	ldr	x2, [x19, #56]
 111b6ac:	97ffdf08 	bl	11132cc <msg_param_mobj_from_noncontig>
	if (!mobj)
 111b6b0:	b4fffee0 	cbz	x0, 111b68c <__tee_entry_std+0x31c>
	mobj_reg_shm_unguard(mobj);
 111b6b4:	97ffc3e0 	bl	110c634 <mobj_reg_shm_unguard>
	arg->ret = TEE_SUCCESS;
 111b6b8:	b900167f 	str	wzr, [x19, #20]
 111b6bc:	17fffff4 	b	111b68c <__tee_entry_std+0x31c>
	if (num_params == 1) {
 111b6c0:	7100069f 	cmp	w20, #0x1
 111b6c4:	540001e1 	b.ne	111b700 <__tee_entry_std+0x390>  // b.any
		TEE_Result res = mobj_reg_shm_release_by_cookie(cookie);
 111b6c8:	f9401e60 	ldr	x0, [x19, #56]
 111b6cc:	97ffc417 	bl	110c728 <mobj_reg_shm_release_by_cookie>
 111b6d0:	2a0003f5 	mov	w21, w0
		if (res)
 111b6d4:	34000120 	cbz	w0, 111b6f8 <__tee_entry_std+0x388>
			EMSG("Can't find mapping with given cookie");
 111b6d8:	d00001c4 	adrp	x4, 1155000 <__func__.3826+0xa8>
 111b6dc:	d00001c0 	adrp	x0, 1155000 <__func__.3826+0xa8>
 111b6e0:	9115c484 	add	x4, x4, #0x571
 111b6e4:	2a1403e3 	mov	w3, w20
 111b6e8:	2a1403e2 	mov	w2, w20
 111b6ec:	91175800 	add	x0, x0, #0x5d6
 111b6f0:	52803fc1 	mov	w1, #0x1fe                 	// #510
 111b6f4:	9400a594 	bl	1144d44 <trace_printf>
		arg->ret = res;
 111b6f8:	b9001675 	str	w21, [x19, #20]
 111b6fc:	17ffffe4 	b	111b68c <__tee_entry_std+0x31c>
		arg->ret = TEE_ERROR_BAD_PARAMETERS;
 111b700:	129fff20 	mov	w0, #0xffff0006            	// #-65530
 111b704:	17ffff93 	b	111b550 <__tee_entry_std+0x1e0>
		EMSG("Unknown cmd 0x%x", arg->cmd);
 111b708:	2a1503e5 	mov	w5, w21
 111b70c:	d00001c4 	adrp	x4, 1155000 <__func__.3826+0xa8>
 111b710:	52800023 	mov	w3, #0x1                   	// #1
 111b714:	91165884 	add	x4, x4, #0x596
 111b718:	52800022 	mov	w2, #0x1                   	// #1
 111b71c:	528046a1 	mov	w1, #0x235                 	// #565
 111b720:	d00001c0 	adrp	x0, 1155000 <__func__.3826+0xa8>
		rv = OPTEE_SMC_RETURN_EBADCMD;
 111b724:	528000b5 	mov	w21, #0x5                   	// #5
		EMSG("Unknown cmd 0x%x", arg->cmd);
 111b728:	91179400 	add	x0, x0, #0x5e5
 111b72c:	9400a586 	bl	1144d44 <trace_printf>
	return rv;
 111b730:	17ffff6e 	b	111b4e8 <__tee_entry_std+0x178>

000000000111b734 <tee_entry_std>:
	return __tee_entry_std(arg, num_params);
 111b734:	17ffff0f 	b	111b370 <__tee_entry_std>

000000000111b738 <tee_alg_get_digest_size>:
#define TEE_MAC_SIZE_AES_CMAC
#define TEE_MAC_SIZE_DES_CBC_MAC_PKCS5

static inline size_t __tee_alg_get_digest_size(uint32_t algo)
{
	switch (algo) {
 111b738:	5280c202 	mov	w2, #0x610                 	// #1552
 111b73c:	72a60002 	movk	w2, #0x3000, lsl #16
 111b740:	6b02001f 	cmp	w0, w2
 111b744:	540009c0 	b.eq	111b87c <tee_alg_get_digest_size+0x144>  // b.none
 111b748:	528000e2 	mov	w2, #0x7                   	// #7
 111b74c:	54000488 	b.hi	111b7dc <tee_alg_get_digest_size+0xa4>  // b.pmore
 111b750:	72a60002 	movk	w2, #0x3000, lsl #16
 111b754:	6b02001f 	cmp	w0, w2
 111b758:	54000128 	b.hi	111b77c <tee_alg_get_digest_size+0x44>  // b.pmore
 111b75c:	52a60002 	mov	w2, #0x30000000            	// #805306368
 111b760:	6b02001f 	cmp	w0, w2
 111b764:	54000068 	b.hi	111b770 <tee_alg_get_digest_size+0x38>  // b.pmore
 111b768:	129ffea0 	mov	w0, #0xffff000a            	// #-65526
		return TEE_ERROR_NOT_SUPPORTED;

	*size = digest_size;

	return TEE_SUCCESS;
}
 111b76c:	d65f03c0 	ret
 111b770:	529fffc2 	mov	w2, #0xfffe                	// #65534
 111b774:	72b9ffe2 	movk	w2, #0xcfff, lsl #16
 111b778:	14000021 	b	111b7fc <tee_alg_get_digest_size+0xc4>
 111b77c:	5280a202 	mov	w2, #0x510                 	// #1296
 111b780:	72a60002 	movk	w2, #0x3000, lsl #16
 111b784:	6b02001f 	cmp	w0, w2
 111b788:	540007a0 	b.eq	111b87c <tee_alg_get_digest_size+0x144>  // b.none
 111b78c:	121e7802 	and	w2, w0, #0xfffffffd
 111b790:	540001a8 	b.hi	111b7c4 <tee_alg_get_digest_size+0x8c>  // b.pmore
 111b794:	52802223 	mov	w3, #0x111                 	// #273
 111b798:	72a60003 	movk	w3, #0x3000, lsl #16
 111b79c:	6b03005f 	cmp	w2, w3
 111b7a0:	540001a0 	b.eq	111b7d4 <tee_alg_get_digest_size+0x9c>  // b.none
 111b7a4:	52802203 	mov	w3, #0x110                 	// #272
	case TEE_ALG_MD5:
	case TEE_ALG_HMAC_MD5:
		return TEE_MD5_HASH_SIZE;
 111b7a8:	d2800202 	mov	x2, #0x10                  	// #16
	switch (algo) {
 111b7ac:	72a60003 	movk	w3, #0x3000, lsl #16
 111b7b0:	6b03001f 	cmp	w0, w3
 111b7b4:	54fffda1 	b.ne	111b768 <tee_alg_get_digest_size+0x30>  // b.any
	return TEE_SUCCESS;
 111b7b8:	52800000 	mov	w0, #0x0                   	// #0
	*size = digest_size;
 111b7bc:	f9000022 	str	x2, [x1]
	return TEE_SUCCESS;
 111b7c0:	17ffffeb 	b	111b76c <tee_alg_get_digest_size+0x34>
 111b7c4:	5280a220 	mov	w0, #0x511                 	// #1297
 111b7c8:	72a60000 	movk	w0, #0x3000, lsl #16
 111b7cc:	6b00005f 	cmp	w2, w0
 111b7d0:	54fffcc1 	b.ne	111b768 <tee_alg_get_digest_size+0x30>  // b.any
 111b7d4:	d2800102 	mov	x2, #0x8                   	// #8
 111b7d8:	17fffff8 	b	111b7b8 <tee_alg_get_digest_size+0x80>
 111b7dc:	72aa0002 	movk	w2, #0x5000, lsl #16
 111b7e0:	6b02001f 	cmp	w0, w2
 111b7e4:	540001e8 	b.hi	111b820 <tee_alg_get_digest_size+0xe8>  // b.pmore
 111b7e8:	52aa0002 	mov	w2, #0x50000000            	// #1342177280
 111b7ec:	6b02001f 	cmp	w0, w2
 111b7f0:	54fffbc9 	b.ls	111b768 <tee_alg_get_digest_size+0x30>  // b.plast
 111b7f4:	529fffc2 	mov	w2, #0xfffe                	// #65534
 111b7f8:	72b5ffe2 	movk	w2, #0xafff, lsl #16
 111b7fc:	0b020000 	add	w0, w0, w2
 111b800:	7100141f 	cmp	w0, #0x5
 111b804:	540003c8 	b.hi	111b87c <tee_alg_get_digest_size+0x144>  // b.pmore
 111b808:	f0000182 	adrp	x2, 114e000 <ldelf_data+0x8000>
 111b80c:	911ba042 	add	x2, x2, #0x6e8
 111b810:	38604840 	ldrb	w0, [x2, w0, uxtw]
 111b814:	10000062 	adr	x2, 111b820 <tee_alg_get_digest_size+0xe8>
 111b818:	8b208840 	add	x0, x2, w0, sxtb #2
 111b81c:	d61f0000 	br	x0
 111b820:	52862622 	mov	w2, #0x3131                	// #12593
 111b824:	72ae0002 	movk	w2, #0x7000, lsl #16
 111b828:	6b02001f 	cmp	w0, w2
 111b82c:	540002c0 	b.eq	111b884 <tee_alg_get_digest_size+0x14c>  // b.none
 111b830:	540000e8 	b.hi	111b84c <tee_alg_get_digest_size+0x114>  // b.pmore
 111b834:	52842622 	mov	w2, #0x2131                	// #8497
 111b838:	72ae0002 	movk	w2, #0x7000, lsl #16
 111b83c:	6b02001f 	cmp	w0, w2
 111b840:	54fff941 	b.ne	111b768 <tee_alg_get_digest_size+0x30>  // b.any
	case TEE_ALG_SHA1:
	case TEE_ALG_HMAC_SHA1:
	case TEE_ALG_DSA_SHA1:
		return TEE_SHA1_HASH_SIZE;
 111b844:	d2800282 	mov	x2, #0x14                  	// #20
 111b848:	17ffffdc 	b	111b7b8 <tee_alg_get_digest_size+0x80>
	switch (algo) {
 111b84c:	52882622 	mov	w2, #0x4131                	// #16689
 111b850:	72ae0002 	movk	w2, #0x7000, lsl #16
 111b854:	6b02001f 	cmp	w0, w2
 111b858:	540001a0 	b.eq	111b88c <tee_alg_get_digest_size+0x154>  // b.none
 111b85c:	5280c263 	mov	w3, #0x613                 	// #1555
 111b860:	d2800102 	mov	x2, #0x8                   	// #8
 111b864:	72be0003 	movk	w3, #0xf000, lsl #16
 111b868:	17ffffd2 	b	111b7b0 <tee_alg_get_digest_size+0x78>
	case TEE_ALG_HMAC_SHA256:
	case TEE_ALG_DSA_SHA256:
		return TEE_SHA256_HASH_SIZE;
	case TEE_ALG_SHA384:
	case TEE_ALG_HMAC_SHA384:
		return TEE_SHA384_HASH_SIZE;
 111b86c:	d2800602 	mov	x2, #0x30                  	// #48
 111b870:	17ffffd2 	b	111b7b8 <tee_alg_get_digest_size+0x80>
	case TEE_ALG_SHA512:
	case TEE_ALG_HMAC_SHA512:
		return TEE_SHA512_HASH_SIZE;
 111b874:	d2800802 	mov	x2, #0x40                  	// #64
 111b878:	17ffffd0 	b	111b7b8 <tee_alg_get_digest_size+0x80>
		return TEE_MD5_HASH_SIZE;
 111b87c:	d2800202 	mov	x2, #0x10                  	// #16
 111b880:	17ffffce 	b	111b7b8 <tee_alg_get_digest_size+0x80>
		return TEE_SHA224_HASH_SIZE;
 111b884:	d2800382 	mov	x2, #0x1c                  	// #28
 111b888:	17ffffcc 	b	111b7b8 <tee_alg_get_digest_size+0x80>
	case TEE_ALG_SM3:
	case TEE_ALG_HMAC_SM3:
		return TEE_SM3_HASH_SIZE;
 111b88c:	d2800402 	mov	x2, #0x20                  	// #32
 111b890:	17ffffca 	b	111b7b8 <tee_alg_get_digest_size+0x80>

000000000111b894 <tee_hash_createdigest>:

TEE_Result tee_hash_createdigest(uint32_t algo, const uint8_t *data,
				 size_t datalen, uint8_t *digest,
				 size_t digestlen)
{
 111b894:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 111b898:	910003fd 	mov	x29, sp
 111b89c:	a90153f3 	stp	x19, x20, [sp, #16]
 111b8a0:	aa0203f4 	mov	x20, x2
 111b8a4:	a9025bf5 	stp	x21, x22, [sp, #32]
 111b8a8:	aa0103f5 	mov	x21, x1
 111b8ac:	aa0303f6 	mov	x22, x3
	TEE_Result res;
	void *ctx = NULL;

	res = crypto_hash_alloc_ctx(&ctx, algo);
 111b8b0:	2a0003e1 	mov	w1, w0
 111b8b4:	910123e0 	add	x0, sp, #0x48
{
 111b8b8:	f9001bf7 	str	x23, [sp, #48]
 111b8bc:	aa0403f7 	mov	x23, x4
	void *ctx = NULL;
 111b8c0:	f90027ff 	str	xzr, [sp, #72]
	res = crypto_hash_alloc_ctx(&ctx, algo);
 111b8c4:	97ffc64e 	bl	110d1fc <crypto_hash_alloc_ctx>
	if (res)
 111b8c8:	35000340 	cbnz	w0, 111b930 <tee_hash_createdigest+0x9c>
		return res;

	res = crypto_hash_init(ctx);
 111b8cc:	f94027e0 	ldr	x0, [sp, #72]
 111b8d0:	97ffc68a 	bl	110d2f8 <crypto_hash_init>
 111b8d4:	2a0003f3 	mov	w19, w0
	if (res)
 111b8d8:	350000e0 	cbnz	w0, 111b8f4 <tee_hash_createdigest+0x60>
		goto out;

	if (datalen != 0) {
 111b8dc:	b50001d4 	cbnz	x20, 111b914 <tee_hash_createdigest+0x80>
		res = crypto_hash_update(ctx, data, datalen);
		if (res)
			goto out;
	}

	res = crypto_hash_final(ctx, digest, digestlen);
 111b8e0:	f94027e0 	ldr	x0, [sp, #72]
 111b8e4:	aa1703e2 	mov	x2, x23
 111b8e8:	aa1603e1 	mov	x1, x22
 111b8ec:	97ffc69f 	bl	110d368 <crypto_hash_final>
 111b8f0:	2a0003f3 	mov	w19, w0
out:
	crypto_hash_free_ctx(ctx);
 111b8f4:	f94027e0 	ldr	x0, [sp, #72]
 111b8f8:	97ffc666 	bl	110d290 <crypto_hash_free_ctx>

	return res;
}
 111b8fc:	2a1303e0 	mov	w0, w19
 111b900:	a94153f3 	ldp	x19, x20, [sp, #16]
 111b904:	a9425bf5 	ldp	x21, x22, [sp, #32]
 111b908:	f9401bf7 	ldr	x23, [sp, #48]
 111b90c:	a8c57bfd 	ldp	x29, x30, [sp], #80
 111b910:	d65f03c0 	ret
		res = crypto_hash_update(ctx, data, datalen);
 111b914:	f94027e0 	ldr	x0, [sp, #72]
 111b918:	aa1403e2 	mov	x2, x20
 111b91c:	aa1503e1 	mov	x1, x21
 111b920:	97ffc681 	bl	110d324 <crypto_hash_update>
 111b924:	2a0003f3 	mov	w19, w0
		if (res)
 111b928:	34fffdc0 	cbz	w0, 111b8e0 <tee_hash_createdigest+0x4c>
 111b92c:	17fffff2 	b	111b8f4 <tee_hash_createdigest+0x60>
 111b930:	2a0003f3 	mov	w19, w0
 111b934:	17fffff2 	b	111b8fc <tee_hash_createdigest+0x68>

000000000111b938 <tee_cipher_get_block_size>:

TEE_Result tee_cipher_get_block_size(uint32_t algo, size_t *size)
{
	switch (algo) {
 111b938:	52808202 	mov	w2, #0x410                 	// #1040
 111b93c:	72a20002 	movk	w2, #0x1000, lsl #16
 111b940:	6b02001f 	cmp	w0, w2
 111b944:	54000940 	b.eq	111ba6c <tee_cipher_get_block_size+0x134>  // b.none
 111b948:	54000428 	b.hi	111b9cc <tee_cipher_get_block_size+0x94>  // b.pmore
 111b94c:	52802282 	mov	w2, #0x114                 	// #276
 111b950:	72a20002 	movk	w2, #0x1000, lsl #16
 111b954:	6b02001f 	cmp	w0, w2
 111b958:	54000248 	b.hi	111b9a0 <tee_cipher_get_block_size+0x68>  // b.pmore
 111b95c:	528021e2 	mov	w2, #0x10f                 	// #271
 111b960:	72a20002 	movk	w2, #0x1000, lsl #16
 111b964:	6b02001f 	cmp	w0, w2
 111b968:	54000188 	b.hi	111b998 <tee_cipher_get_block_size+0x60>  // b.pmore
 111b96c:	529ffe02 	mov	w2, #0xfff0                	// #65520
 111b970:	72bdffe2 	movk	w2, #0xefff, lsl #16
 111b974:	0b020000 	add	w0, w0, w2
 111b978:	7100101f 	cmp	w0, #0x4
 111b97c:	54000248 	b.hi	111b9c4 <tee_cipher_get_block_size+0x8c>  // b.pmore
 111b980:	f0000182 	adrp	x2, 114e000 <ldelf_data+0x8000>
 111b984:	911bc042 	add	x2, x2, #0x6f0
 111b988:	38604840 	ldrb	w0, [x2, w0, uxtw]
 111b98c:	10000062 	adr	x2, 111b998 <tee_cipher_get_block_size+0x60>
 111b990:	8b208840 	add	x0, x2, w0, sxtb #2
 111b994:	d61f0000 	br	x0
 111b998:	529fde02 	mov	w2, #0xfef0                	// #65264
 111b99c:	17fffff5 	b	111b970 <tee_cipher_get_block_size+0x38>
 111b9a0:	52806202 	mov	w2, #0x310                 	// #784
 111b9a4:	72a20002 	movk	w2, #0x1000, lsl #16
 111b9a8:	6b02001f 	cmp	w0, w2
 111b9ac:	54000600 	b.eq	111ba6c <tee_cipher_get_block_size+0x134>  // b.none
 111b9b0:	52804202 	mov	w2, #0x210                 	// #528
 111b9b4:	121d7800 	and	w0, w0, #0xfffffffb
 111b9b8:	72a20002 	movk	w2, #0x1000, lsl #16
 111b9bc:	6b02001f 	cmp	w0, w2
 111b9c0:	54000560 	b.eq	111ba6c <tee_cipher_get_block_size+0x134>  // b.none
 111b9c4:	129ffea0 	mov	w0, #0xffff000a            	// #-65526
 111b9c8:	1400002c 	b	111ba78 <tee_cipher_get_block_size+0x140>
 111b9cc:	5280a222 	mov	w2, #0x511                 	// #1297
 111b9d0:	72a60002 	movk	w2, #0x3000, lsl #16
 111b9d4:	6b02001f 	cmp	w0, w2
 111b9d8:	540001c0 	b.eq	111ba10 <tee_cipher_get_block_size+0xd8>  // b.none
 111b9dc:	54000248 	b.hi	111ba24 <tee_cipher_get_block_size+0xec>  // b.pmore
 111b9e0:	52802262 	mov	w2, #0x113                 	// #275
 111b9e4:	72a60002 	movk	w2, #0x3000, lsl #16
 111b9e8:	6b02001f 	cmp	w0, w2
 111b9ec:	54000120 	b.eq	111ba10 <tee_cipher_get_block_size+0xd8>  // b.none
 111b9f0:	54000148 	b.hi	111ba18 <tee_cipher_get_block_size+0xe0>  // b.pmore
 111b9f4:	52802202 	mov	w2, #0x110                 	// #272
 111b9f8:	72a60002 	movk	w2, #0x3000, lsl #16
 111b9fc:	6b02001f 	cmp	w0, w2
 111ba00:	54000360 	b.eq	111ba6c <tee_cipher_get_block_size+0x134>  // b.none
 111ba04:	11000442 	add	w2, w2, #0x1
 111ba08:	6b02001f 	cmp	w0, w2
 111ba0c:	54fffdc1 	b.ne	111b9c4 <tee_cipher_get_block_size+0x8c>  // b.any
	case TEE_ALG_DES3_CBC_MAC_NOPAD:
	case TEE_ALG_DES3_CBC_MAC_PKCS5:
	case TEE_ALG_DES3_ECB_NOPAD:
	case TEE_ALG_DES3_CBC_NOPAD:
	case TEE_ALG_DES3_CMAC:
		*size = 8;
 111ba10:	d2800100 	mov	x0, #0x8                   	// #8
 111ba14:	14000017 	b	111ba70 <tee_cipher_get_block_size+0x138>
	switch (algo) {
 111ba18:	5280a202 	mov	w2, #0x510                 	// #1296
 111ba1c:	72a60002 	movk	w2, #0x3000, lsl #16
 111ba20:	17ffffe7 	b	111b9bc <tee_cipher_get_block_size+0x84>
 111ba24:	5280e202 	mov	w2, #0x710                 	// #1808
 111ba28:	72a80002 	movk	w2, #0x4000, lsl #16
 111ba2c:	6b02001f 	cmp	w0, w2
 111ba30:	540001e0 	b.eq	111ba6c <tee_cipher_get_block_size+0x134>  // b.none
 111ba34:	540000e8 	b.hi	111ba50 <tee_cipher_get_block_size+0x118>  // b.pmore
 111ba38:	5280a262 	mov	w2, #0x513                 	// #1299
 111ba3c:	72a60002 	movk	w2, #0x3000, lsl #16
 111ba40:	6b02001f 	cmp	w0, w2
 111ba44:	54fffe60 	b.eq	111ba10 <tee_cipher_get_block_size+0xd8>  // b.none
 111ba48:	1103f442 	add	w2, w2, #0xfd
 111ba4c:	17ffffdc 	b	111b9bc <tee_cipher_get_block_size+0x84>
 111ba50:	52810202 	mov	w2, #0x810                 	// #2064
 111ba54:	72a80002 	movk	w2, #0x4000, lsl #16
 111ba58:	6b02001f 	cmp	w0, w2
 111ba5c:	54000080 	b.eq	111ba6c <tee_cipher_get_block_size+0x134>  // b.none
 111ba60:	5280c262 	mov	w2, #0x613                 	// #1555
 111ba64:	72be0002 	movk	w2, #0xf000, lsl #16
 111ba68:	17ffffe8 	b	111ba08 <tee_cipher_get_block_size+0xd0>
		*size = 16;
 111ba6c:	d2800200 	mov	x0, #0x10                  	// #16
		*size = 8;
 111ba70:	f9000020 	str	x0, [x1]

	default:
		return TEE_ERROR_NOT_SUPPORTED;
	}

	return TEE_SUCCESS;
 111ba74:	52800000 	mov	w0, #0x0                   	// #0
}
 111ba78:	d65f03c0 	ret

000000000111ba7c <tee_do_cipher_update>:
				const uint8_t *data, size_t len, uint8_t *dst)
{
	TEE_Result res;
	size_t block_size;

	if (mode != TEE_MODE_ENCRYPT && mode != TEE_MODE_DECRYPT)
 111ba7c:	7100045f 	cmp	w2, #0x1
 111ba80:	54000069 	b.ls	111ba8c <tee_do_cipher_update+0x10>  // b.plast
		return TEE_ERROR_BAD_PARAMETERS;
 111ba84:	129fff20 	mov	w0, #0xffff0006            	// #-65530
			return TEE_ERROR_NOT_SUPPORTED;
		}
	}

	return crypto_cipher_update(ctx, mode, last_block, data, len, dst);
}
 111ba88:	d65f03c0 	ret
 111ba8c:	2a0103e7 	mov	w7, w1
 111ba90:	aa0003e9 	mov	x9, x0
 111ba94:	2a0203e8 	mov	w8, w2
{
 111ba98:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	res = tee_cipher_get_block_size(algo, &block_size);
 111ba9c:	2a0703e0 	mov	w0, w7
{
 111baa0:	910003fd 	mov	x29, sp
	res = tee_cipher_get_block_size(algo, &block_size);
 111baa4:	910063e1 	add	x1, sp, #0x18
 111baa8:	97ffffa4 	bl	111b938 <tee_cipher_get_block_size>
	if (res != TEE_SUCCESS)
 111baac:	350004e0 	cbnz	w0, 111bb48 <tee_do_cipher_update+0xcc>
	if ((len % block_size) != 0) {
 111bab0:	f9400fe1 	ldr	x1, [sp, #24]
 111bab4:	12001c6a 	and	w10, w3, #0xff
 111bab8:	aa0403e3 	mov	x3, x4
 111babc:	aa0503e4 	mov	x4, x5
 111bac0:	aa0603e5 	mov	x5, x6
 111bac4:	9ac10880 	udiv	x0, x4, x1
 111bac8:	9b019000 	msub	x0, x0, x1, x4
 111bacc:	b4000540 	cbz	x0, 111bb74 <tee_do_cipher_update+0xf8>
		if (!last_block && algo != TEE_ALG_AES_CTR)
 111bad0:	52804201 	mov	w1, #0x210                 	// #528
 111bad4:	52000140 	eor	w0, w10, #0x1
 111bad8:	72a20001 	movk	w1, #0x1000, lsl #16
 111badc:	6b0100ff 	cmp	w7, w1
 111bae0:	1a9f07e2 	cset	w2, ne  // ne = any
 111bae4:	6a00005f 	tst	w2, w0
 111bae8:	54000501 	b.ne	111bb88 <tee_do_cipher_update+0x10c>  // b.any
		switch (algo) {
 111baec:	52802280 	mov	w0, #0x114                 	// #276
 111baf0:	72a20000 	movk	w0, #0x1000, lsl #16
 111baf4:	6b0000ff 	cmp	w7, w0
 111baf8:	54000308 	b.hi	111bb58 <tee_do_cipher_update+0xdc>  // b.pmore
 111bafc:	52802240 	mov	w0, #0x112                 	// #274
 111bb00:	72a20000 	movk	w0, #0x1000, lsl #16
 111bb04:	6b0000ff 	cmp	w7, w0
 111bb08:	54000408 	b.hi	111bb88 <tee_do_cipher_update+0x10c>  // b.pmore
 111bb0c:	52800280 	mov	w0, #0x14                  	// #20
 111bb10:	72a20000 	movk	w0, #0x1000, lsl #16
 111bb14:	6b0000ff 	cmp	w7, w0
 111bb18:	540001c8 	b.hi	111bb50 <tee_do_cipher_update+0xd4>  // b.pmore
 111bb1c:	52800240 	mov	w0, #0x12                  	// #18
 111bb20:	72a20000 	movk	w0, #0x1000, lsl #16
 111bb24:	6b0000ff 	cmp	w7, w0
 111bb28:	54000308 	b.hi	111bb88 <tee_do_cipher_update+0x10c>  // b.pmore
 111bb2c:	529ffe01 	mov	w1, #0xfff0                	// #65520
 111bb30:	72bdffe1 	movk	w1, #0xefff, lsl #16
 111bb34:	0b0100e7 	add	w7, w7, w1
 111bb38:	710008ff 	cmp	w7, #0x2
 111bb3c:	129fff20 	mov	w0, #0xffff0006            	// #-65530
 111bb40:	129ffea1 	mov	w1, #0xffff000a            	// #-65526
 111bb44:	1a813000 	csel	w0, w0, w1, cc  // cc = lo, ul, last
}
 111bb48:	a8c27bfd 	ldp	x29, x30, [sp], #32
 111bb4c:	d65f03c0 	ret
		switch (algo) {
 111bb50:	529fde01 	mov	w1, #0xfef0                	// #65264
 111bb54:	17fffff7 	b	111bb30 <tee_do_cipher_update+0xb4>
 111bb58:	52808200 	mov	w0, #0x410                 	// #1040
 111bb5c:	72a20000 	movk	w0, #0x1000, lsl #16
 111bb60:	6b0000ff 	cmp	w7, w0
 111bb64:	54000080 	b.eq	111bb74 <tee_do_cipher_update+0xf8>  // b.none
 111bb68:	121778e7 	and	w7, w7, #0xfffffeff
 111bb6c:	6b0100ff 	cmp	w7, w1
 111bb70:	54000101 	b.ne	111bb90 <tee_do_cipher_update+0x114>  // b.any
	return crypto_cipher_update(ctx, mode, last_block, data, len, dst);
 111bb74:	2a0a03e2 	mov	w2, w10
 111bb78:	2a0803e1 	mov	w1, w8
 111bb7c:	aa0903e0 	mov	x0, x9
 111bb80:	97ffc6a6 	bl	110d618 <crypto_cipher_update>
 111bb84:	17fffff1 	b	111bb48 <tee_do_cipher_update+0xcc>
			return TEE_ERROR_BAD_PARAMETERS;
 111bb88:	129fff20 	mov	w0, #0xffff0006            	// #-65530
 111bb8c:	17ffffef 	b	111bb48 <tee_do_cipher_update+0xcc>
		switch (algo) {
 111bb90:	129ffea0 	mov	w0, #0xffff000a            	// #-65526
 111bb94:	17ffffed 	b	111bb48 <tee_do_cipher_update+0xcc>

000000000111bb98 <plat_rng_init>:
	if (tee_time_get_sys_time(&current) == TEE_SUCCESS)
		crypto_rng_add_event(sid, pnum, &current, sizeof(current));
}

__weak void plat_rng_init(void)
{
 111bb98:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 111bb9c:	910003fd 	mov	x29, sp
 111bba0:	f9000bf3 	str	x19, [sp, #16]
	 * override this function.
	 *
	 * Seeding with a saved seed will require cooperation from normal
	 * world, this is still TODO.
	 */
	res = tee_time_get_sys_time(&t);
 111bba4:	9100a3f3 	add	x19, sp, #0x28
 111bba8:	aa1303e0 	mov	x0, x19
 111bbac:	97ffa181 	bl	11041b0 <tee_time_get_sys_time>
#else
	EMSG("Warning: seeding RNG with zeroes");
	memset(&t, 0, sizeof(t));
#endif
	if (!res)
 111bbb0:	350002a0 	cbnz	w0, 111bc04 <plat_rng_init+0x6c>
		res = crypto_rng_init(&t, sizeof(t));
 111bbb4:	aa1303e0 	mov	x0, x19
 111bbb8:	d2800101 	mov	x1, #0x8                   	// #8
 111bbbc:	97ffcda7 	bl	110f258 <crypto_rng_init>
 111bbc0:	2a0003e5 	mov	w5, w0
	if (res) {
 111bbc4:	34000240 	cbz	w0, 111bc0c <plat_rng_init+0x74>
		EMSG("Failed to initialize RNG: %#" PRIx32, res);
 111bbc8:	d00001c4 	adrp	x4, 1155000 <__func__.3826+0xa8>
 111bbcc:	91181c84 	add	x4, x4, #0x607
 111bbd0:	d00001d3 	adrp	x19, 1155000 <__func__.3826+0xa8>
 111bbd4:	9119c273 	add	x19, x19, #0x670
 111bbd8:	aa1303e0 	mov	x0, x19
 111bbdc:	52800023 	mov	w3, #0x1                   	// #1
 111bbe0:	52800022 	mov	w2, #0x1                   	// #1
 111bbe4:	52801881 	mov	w1, #0xc4                  	// #196
 111bbe8:	9400a457 	bl	1144d44 <trace_printf>
		panic();
 111bbec:	d00001c0 	adrp	x0, 1155000 <__func__.3826+0xa8>
 111bbf0:	aa1303e2 	mov	x2, x19
 111bbf4:	91189400 	add	x0, x0, #0x625
 111bbf8:	d2800003 	mov	x3, #0x0                   	// #0
 111bbfc:	528018a1 	mov	w1, #0xc5                  	// #197
 111bc00:	97ffde1a 	bl	1113468 <__do_panic>
 111bc04:	2a0003e5 	mov	w5, w0
 111bc08:	17fffff0 	b	111bbc8 <plat_rng_init+0x30>
	}
}
 111bc0c:	f9400bf3 	ldr	x19, [sp, #16]
 111bc10:	a8c37bfd 	ldp	x29, x30, [sp], #48
 111bc14:	d65f03c0 	ret

000000000111bc18 <tee_cryp_init>:

static TEE_Result tee_cryp_init(void)
{
 111bc18:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 111bc1c:	910003fd 	mov	x29, sp
 111bc20:	f9000bf3 	str	x19, [sp, #16]
	TEE_Result res = crypto_init();
 111bc24:	940049c2 	bl	112e32c <crypto_init>

	if (res) {
 111bc28:	34000220 	cbz	w0, 111bc6c <tee_cryp_init+0x54>
 111bc2c:	2a0003e5 	mov	w5, w0
		EMSG("Failed to initialize crypto API: %#" PRIx32, res);
 111bc30:	d00001c4 	adrp	x4, 1155000 <__func__.3826+0xa8>
 111bc34:	9118f484 	add	x4, x4, #0x63d
 111bc38:	d00001d3 	adrp	x19, 1155000 <__func__.3826+0xa8>
 111bc3c:	9119fa73 	add	x19, x19, #0x67e
 111bc40:	52800023 	mov	w3, #0x1                   	// #1
 111bc44:	aa1303e0 	mov	x0, x19
 111bc48:	52800022 	mov	w2, #0x1                   	// #1
 111bc4c:	528019c1 	mov	w1, #0xce                  	// #206
 111bc50:	9400a43d 	bl	1144d44 <trace_printf>
		panic();
 111bc54:	d00001c0 	adrp	x0, 1155000 <__func__.3826+0xa8>
 111bc58:	aa1303e2 	mov	x2, x19
 111bc5c:	91189400 	add	x0, x0, #0x625
 111bc60:	d2800003 	mov	x3, #0x0                   	// #0
 111bc64:	528019e1 	mov	w1, #0xcf                  	// #207
 111bc68:	97ffde00 	bl	1113468 <__do_panic>
	}
	plat_rng_init();
 111bc6c:	97ffffcb 	bl	111bb98 <plat_rng_init>

	return TEE_SUCCESS;
}
 111bc70:	52800000 	mov	w0, #0x0                   	// #0
 111bc74:	f9400bf3 	ldr	x19, [sp, #16]
 111bc78:	a8c27bfd 	ldp	x29, x30, [sp], #32
 111bc7c:	d65f03c0 	ret

000000000111bc80 <tee_cryp_hkdf>:

TEE_Result tee_cryp_hkdf(uint32_t hash_id, const uint8_t *ikm, size_t ikm_len,
			 const uint8_t *salt, size_t salt_len,
			 const uint8_t *info, size_t info_len, uint8_t *okm,
			 size_t okm_len)
{
 111bc80:	a9af7bfd 	stp	x29, x30, [sp, #-272]!
	return (TEE_OPERATION_DIGEST << 28) | main_hash;
 111bc84:	71001c1f 	cmp	w0, #0x7
 111bc88:	910003fd 	mov	x29, sp
 111bc8c:	a9025bf5 	stp	x21, x22, [sp, #32]
 111bc90:	aa0103f6 	mov	x22, x1
	TEE_Result res;
	uint8_t prk[TEE_MAX_HASH_SIZE];
	size_t prk_len = sizeof(prk);
 111bc94:	d2800801 	mov	x1, #0x40                  	// #64
{
 111bc98:	a90153f3 	stp	x19, x20, [sp, #16]
 111bc9c:	52aa0014 	mov	w20, #0x50000000            	// #1342177280
 111bca0:	2a140014 	orr	w20, w0, w20
 111bca4:	a90363f7 	stp	x23, x24, [sp, #48]
 111bca8:	aa0603f5 	mov	x21, x6
 111bcac:	aa0503f7 	mov	x23, x5
 111bcb0:	a9046bf9 	stp	x25, x26, [sp, #64]
 111bcb4:	aa0703f8 	mov	x24, x7
 111bcb8:	aa0203f9 	mov	x25, x2
 111bcbc:	a90573fb 	stp	x27, x28, [sp, #80]
	uint32_t hmac_algo = (TEE_OPERATION_MAC << 28) | hash_id;
 111bcc0:	32040413 	orr	w19, w0, #0x30000000
	size_t prk_len = sizeof(prk);
 111bcc4:	f9003fe1 	str	x1, [sp, #120]
 111bcc8:	528000e1 	mov	w1, #0x7                   	// #7
 111bccc:	f90047e4 	str	x4, [sp, #136]
 111bcd0:	72aa0001 	movk	w1, #0x5000, lsl #16
	void *ctx = NULL;
 111bcd4:	f9006bff 	str	xzr, [sp, #208]
 111bcd8:	1a811294 	csel	w20, w20, w1, ne  // ne = any
	if (!salt || !salt_len) {
 111bcdc:	f100007f 	cmp	x3, #0x0
 111bce0:	fa401884 	ccmp	x4, #0x0, #0x4, ne  // ne = any
 111bce4:	54000de1 	b.ne	111bea0 <tee_cryp_hkdf+0x220>  // b.any
		res = tee_alg_get_digest_size(hash_algo, &salt_len);
 111bce8:	910223e1 	add	x1, sp, #0x88
 111bcec:	2a1403e0 	mov	w0, w20
 111bcf0:	97fffe92 	bl	111b738 <tee_alg_get_digest_size>
 111bcf4:	2a0003fb 	mov	w27, w0
		if (res != TEE_SUCCESS)
 111bcf8:	350003c0 	cbnz	w0, 111bd70 <tee_cryp_hkdf+0xf0>
		salt = zero_salt;
 111bcfc:	d00001da 	adrp	x26, 1155000 <__func__.3826+0xa8>
 111bd00:	911a335a 	add	x26, x26, #0x68c
	res = crypto_mac_alloc_ctx(&ctx, hmac_algo);
 111bd04:	2a1303e1 	mov	w1, w19
 111bd08:	910343e0 	add	x0, sp, #0xd0
 111bd0c:	97ffc68e 	bl	110d744 <crypto_mac_alloc_ctx>
 111bd10:	2a0003fb 	mov	w27, w0
	if (res)
 111bd14:	350002e0 	cbnz	w0, 111bd70 <tee_cryp_hkdf+0xf0>
	res = crypto_mac_init(ctx, salt, salt_len);
 111bd18:	f94047e2 	ldr	x2, [sp, #136]
 111bd1c:	aa1a03e1 	mov	x1, x26
 111bd20:	f9406be0 	ldr	x0, [sp, #208]
 111bd24:	97ffc700 	bl	110d924 <crypto_mac_init>
 111bd28:	2a0003fb 	mov	w27, w0
	if (res != TEE_SUCCESS)
 111bd2c:	35000220 	cbnz	w0, 111bd70 <tee_cryp_hkdf+0xf0>
	res = crypto_mac_update(ctx, ikm, ikm_len);
 111bd30:	f9406be0 	ldr	x0, [sp, #208]
 111bd34:	aa1903e2 	mov	x2, x25
 111bd38:	aa1603e1 	mov	x1, x22
 111bd3c:	97ffc70b 	bl	110d968 <crypto_mac_update>
 111bd40:	2a0003fb 	mov	w27, w0
	if (res != TEE_SUCCESS)
 111bd44:	35000160 	cbnz	w0, 111bd70 <tee_cryp_hkdf+0xf0>
	res = crypto_mac_final(ctx, prk, *prk_len);
 111bd48:	f9403fe2 	ldr	x2, [sp, #120]
 111bd4c:	910243e1 	add	x1, sp, #0x90
 111bd50:	f9406be0 	ldr	x0, [sp, #208]
 111bd54:	97ffc719 	bl	110d9b8 <crypto_mac_final>
 111bd58:	2a0003fb 	mov	w27, w0
	if (res != TEE_SUCCESS)
 111bd5c:	350000a0 	cbnz	w0, 111bd70 <tee_cryp_hkdf+0xf0>
	res = tee_alg_get_digest_size(hash_algo, prk_len);
 111bd60:	9101e3e1 	add	x1, sp, #0x78
 111bd64:	2a1403e0 	mov	w0, w20
 111bd68:	97fffe74 	bl	111b738 <tee_alg_get_digest_size>
 111bd6c:	2a0003fb 	mov	w27, w0
	crypto_mac_free_ctx(ctx);
 111bd70:	f9406be0 	ldr	x0, [sp, #208]
 111bd74:	97ffc6d2 	bl	110d8bc <crypto_mac_free_ctx>

	res = hkdf_extract(hash_id, ikm, ikm_len, salt, salt_len, prk,
			   &prk_len);
	if (res != TEE_SUCCESS)
 111bd78:	350009fb 	cbnz	w27, 111beb4 <tee_cryp_hkdf+0x234>
	res = tee_alg_get_digest_size(hash_algo, &hash_len);
 111bd7c:	910203e1 	add	x1, sp, #0x80
 111bd80:	2a1403e0 	mov	w0, w20
	void *ctx = NULL;
 111bd84:	f90047ff 	str	xzr, [sp, #136]
		return res;
	res = hkdf_expand(hash_id, prk, prk_len, info, info_len, okm,
 111bd88:	f9403ffa 	ldr	x26, [sp, #120]
	res = tee_alg_get_digest_size(hash_algo, &hash_len);
 111bd8c:	97fffe6b 	bl	111b738 <tee_alg_get_digest_size>
 111bd90:	2a0003fb 	mov	w27, w0
	if (res != TEE_SUCCESS)
 111bd94:	350008c0 	cbnz	w0, 111beac <tee_cryp_hkdf+0x22c>
	if (!okm || prk_len < hash_len) {
 111bd98:	b40009f8 	cbz	x24, 111bed4 <tee_cryp_hkdf+0x254>
 111bd9c:	f94043e0 	ldr	x0, [sp, #128]
 111bda0:	eb00035f 	cmp	x26, x0
 111bda4:	54000983 	b.cc	111bed4 <tee_cryp_hkdf+0x254>  // b.lo, b.ul, b.last
		info_len = 0;
 111bda8:	f10002ff 	cmp	x23, #0x0
	res = crypto_mac_alloc_ctx(&ctx, hmac_algo);
 111bdac:	2a1303e1 	mov	w1, w19
		info_len = 0;
 111bdb0:	9a9f12b5 	csel	x21, x21, xzr, ne  // ne = any
	res = crypto_mac_alloc_ctx(&ctx, hmac_algo);
 111bdb4:	910223e0 	add	x0, sp, #0x88
 111bdb8:	97ffc663 	bl	110d744 <crypto_mac_alloc_ctx>
 111bdbc:	2a0003fb 	mov	w27, w0
	if (res)
 111bdc0:	35000760 	cbnz	w0, 111beac <tee_cryp_hkdf+0x22c>
	n = okm_len / hash_len;
 111bdc4:	f94043e0 	ldr	x0, [sp, #128]
 111bdc8:	f9408be1 	ldr	x1, [sp, #272]
 111bdcc:	9ac00833 	udiv	x19, x1, x0
	if ((okm_len % hash_len) != 0)
 111bdd0:	9b008660 	msub	x0, x19, x0, x1
 111bdd4:	b4000040 	cbz	x0, 111bddc <tee_cryp_hkdf+0x15c>
		n++;
 111bdd8:	91000673 	add	x19, x19, #0x1
	if (n > 255) {
 111bddc:	f103fe7f 	cmp	x19, #0xff
 111bde0:	540007e8 	b.hi	111bedc <tee_cryp_hkdf+0x25c>  // b.pmore
		res = crypto_mac_init(ctx, prk, prk_len);
 111bde4:	910243e0 	add	x0, sp, #0x90
		res = crypto_mac_update(ctx, tn, tn_len);
 111bde8:	910343f9 	add	x25, sp, #0xd0
	where = 0;
 111bdec:	d2800016 	mov	x22, #0x0                   	// #0
	for (i = 1; i <= n; i++) {
 111bdf0:	d2800034 	mov	x20, #0x1                   	// #1
	tn_len = 0;
 111bdf4:	d280001c 	mov	x28, #0x0                   	// #0
		res = crypto_mac_init(ctx, prk, prk_len);
 111bdf8:	f90033e0 	str	x0, [sp, #96]
		res = crypto_mac_update(ctx, &c, 1);
 111bdfc:	9101dfe0 	add	x0, sp, #0x77
 111be00:	f90037e0 	str	x0, [sp, #104]
	for (i = 1; i <= n; i++) {
 111be04:	eb14027f 	cmp	x19, x20
 111be08:	f94047e0 	ldr	x0, [sp, #136]
 111be0c:	54000503 	b.cc	111beac <tee_cryp_hkdf+0x22c>  // b.lo, b.ul, b.last
		res = crypto_mac_init(ctx, prk, prk_len);
 111be10:	f94033e1 	ldr	x1, [sp, #96]
 111be14:	aa1a03e2 	mov	x2, x26
		uint8_t c = i;
 111be18:	3901dff4 	strb	w20, [sp, #119]
		res = crypto_mac_init(ctx, prk, prk_len);
 111be1c:	97ffc6c2 	bl	110d924 <crypto_mac_init>
		if (res != TEE_SUCCESS)
 111be20:	35000440 	cbnz	w0, 111bea8 <tee_cryp_hkdf+0x228>
		res = crypto_mac_update(ctx, tn, tn_len);
 111be24:	f94047e0 	ldr	x0, [sp, #136]
 111be28:	aa1c03e2 	mov	x2, x28
 111be2c:	aa1903e1 	mov	x1, x25
 111be30:	97ffc6ce 	bl	110d968 <crypto_mac_update>
		if (res != TEE_SUCCESS)
 111be34:	350003a0 	cbnz	w0, 111bea8 <tee_cryp_hkdf+0x228>
		res = crypto_mac_update(ctx, info, info_len);
 111be38:	f94047e0 	ldr	x0, [sp, #136]
 111be3c:	aa1503e2 	mov	x2, x21
 111be40:	aa1703e1 	mov	x1, x23
 111be44:	97ffc6c9 	bl	110d968 <crypto_mac_update>
		if (res != TEE_SUCCESS)
 111be48:	35000300 	cbnz	w0, 111bea8 <tee_cryp_hkdf+0x228>
		res = crypto_mac_update(ctx, &c, 1);
 111be4c:	f94037e1 	ldr	x1, [sp, #104]
 111be50:	d2800022 	mov	x2, #0x1                   	// #1
 111be54:	f94047e0 	ldr	x0, [sp, #136]
 111be58:	97ffc6c4 	bl	110d968 <crypto_mac_update>
		if (res != TEE_SUCCESS)
 111be5c:	35000260 	cbnz	w0, 111bea8 <tee_cryp_hkdf+0x228>
		res = crypto_mac_final(ctx, tn, sizeof(tn));
 111be60:	f94047e0 	ldr	x0, [sp, #136]
 111be64:	aa1903e1 	mov	x1, x25
 111be68:	d2800802 	mov	x2, #0x40                  	// #64
 111be6c:	97ffc6d3 	bl	110d9b8 <crypto_mac_final>
		if (res != TEE_SUCCESS)
 111be70:	350001c0 	cbnz	w0, 111bea8 <tee_cryp_hkdf+0x228>
		memcpy(okm + where, tn, (i < n) ? hash_len : (okm_len - where));
 111be74:	f9408be0 	ldr	x0, [sp, #272]
 111be78:	eb14027f 	cmp	x19, x20
 111be7c:	f94043fc 	ldr	x28, [sp, #128]
 111be80:	cb160002 	sub	x2, x0, x22
 111be84:	aa1903e1 	mov	x1, x25
 111be88:	8b160300 	add	x0, x24, x22
 111be8c:	9a9c0042 	csel	x2, x2, x28, eq  // eq = none
	for (i = 1; i <= n; i++) {
 111be90:	91000694 	add	x20, x20, #0x1
		where += hash_len;
 111be94:	8b1c02d6 	add	x22, x22, x28
		memcpy(okm + where, tn, (i < n) ? hash_len : (okm_len - where));
 111be98:	97ff9d3e 	bl	1103390 <memcpy>
	for (i = 1; i <= n; i++) {
 111be9c:	17ffffda 	b	111be04 <tee_cryp_hkdf+0x184>
 111bea0:	aa0303fa 	mov	x26, x3
 111bea4:	17ffff98 	b	111bd04 <tee_cryp_hkdf+0x84>
			goto out;
 111bea8:	2a0003fb 	mov	w27, w0
	crypto_mac_free_ctx(ctx);
 111beac:	f94047e0 	ldr	x0, [sp, #136]
 111beb0:	97ffc683 	bl	110d8bc <crypto_mac_free_ctx>
			  okm_len);

	return res;
}
 111beb4:	2a1b03e0 	mov	w0, w27
 111beb8:	a94153f3 	ldp	x19, x20, [sp, #16]
 111bebc:	a9425bf5 	ldp	x21, x22, [sp, #32]
 111bec0:	a94363f7 	ldp	x23, x24, [sp, #48]
 111bec4:	a9446bf9 	ldp	x25, x26, [sp, #64]
 111bec8:	a94573fb 	ldp	x27, x28, [sp, #80]
 111becc:	a8d17bfd 	ldp	x29, x30, [sp], #272
 111bed0:	d65f03c0 	ret
		res = TEE_ERROR_BAD_STATE;
 111bed4:	129fff1b 	mov	w27, #0xffff0007            	// #-65529
 111bed8:	17fffff5 	b	111beac <tee_cryp_hkdf+0x22c>
		res = TEE_ERROR_BAD_PARAMETERS;
 111bedc:	129fff3b 	mov	w27, #0xffff0006            	// #-65530
 111bee0:	17fffff3 	b	111beac <tee_cryp_hkdf+0x22c>

000000000111bee4 <tee_cryp_concat_kdf>:
TEE_Result tee_cryp_concat_kdf(uint32_t hash_id, const uint8_t *shared_secret,
			       size_t shared_secret_len,
			       const uint8_t *other_info,
			       size_t other_info_len, uint8_t *derived_key,
			       size_t derived_key_len)
{
 111bee4:	a9b37bfd 	stp	x29, x30, [sp, #-208]!
 111bee8:	71001c1f 	cmp	w0, #0x7
 111beec:	910003fd 	mov	x29, sp
 111bef0:	a90153f3 	stp	x19, x20, [sp, #16]
 111bef4:	52aa0014 	mov	w20, #0x50000000            	// #1342177280
 111bef8:	2a140014 	orr	w20, w0, w20
 111befc:	528000e0 	mov	w0, #0x7                   	// #7
 111bf00:	a9025bf5 	stp	x21, x22, [sp, #32]
 111bf04:	72aa0000 	movk	w0, #0x5000, lsl #16
 111bf08:	1a801294 	csel	w20, w20, w0, ne  // ne = any
 111bf0c:	aa0503f6 	mov	x22, x5
	uint8_t tmp[TEE_MAX_HASH_SIZE];
	uint32_t be_count;
	uint8_t *out = derived_key;
	uint32_t hash_algo = TEE_ALG_HASH_ALGO(hash_id);

	res = crypto_hash_alloc_ctx(&ctx, hash_algo);
 111bf10:	910223e0 	add	x0, sp, #0x88
{
 111bf14:	a90363f7 	stp	x23, x24, [sp, #48]
 111bf18:	aa0603f7 	mov	x23, x6
 111bf1c:	a9046bf9 	stp	x25, x26, [sp, #64]
 111bf20:	aa0303f9 	mov	x25, x3
 111bf24:	aa0403fa 	mov	x26, x4
 111bf28:	a90573fb 	stp	x27, x28, [sp, #80]
 111bf2c:	a9060be1 	stp	x1, x2, [sp, #96]
	res = crypto_hash_alloc_ctx(&ctx, hash_algo);
 111bf30:	2a1403e1 	mov	w1, w20
	void *ctx = NULL;
 111bf34:	f90047ff 	str	xzr, [sp, #136]
	res = crypto_hash_alloc_ctx(&ctx, hash_algo);
 111bf38:	97ffc4b1 	bl	110d1fc <crypto_hash_alloc_ctx>
	if (res != TEE_SUCCESS)
 111bf3c:	35000840 	cbnz	w0, 111c044 <tee_cryp_concat_kdf+0x160>
		return res;

	res = tee_alg_get_digest_size(hash_algo, &hash_len);
 111bf40:	910203e1 	add	x1, sp, #0x80
 111bf44:	2a1403e0 	mov	w0, w20
 111bf48:	97fffdfc 	bl	111b738 <tee_alg_get_digest_size>
 111bf4c:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 111bf50:	35000140 	cbnz	w0, 111bf78 <tee_cryp_concat_kdf+0x94>
		goto out;

	n = derived_key_len / hash_len;
 111bf54:	f94043f4 	ldr	x20, [sp, #128]
	sz = hash_len;
	for (i = 1; i <= n + 1; i++) {
 111bf58:	d2800035 	mov	x21, #0x1                   	// #1
		be_count = TEE_U32_TO_BIG_ENDIAN(i);

		res = crypto_hash_init(ctx);
		if (res != TEE_SUCCESS)
			goto out;
		res = crypto_hash_update(ctx, (uint8_t *)&be_count,
 111bf5c:	9101f3fc 	add	x28, sp, #0x7c
			res = crypto_hash_update(ctx, other_info,
						 other_info_len);
			if (res != TEE_SUCCESS)
				goto out;
		}
		res = crypto_hash_final(ctx, tmp, sizeof(tmp));
 111bf60:	910243fb 	add	x27, sp, #0x90
	n = derived_key_len / hash_len;
 111bf64:	9ad40af8 	udiv	x24, x23, x20
	for (i = 1; i <= n + 1; i++) {
 111bf68:	8b150318 	add	x24, x24, x21
 111bf6c:	eb15031f 	cmp	x24, x21
 111bf70:	f94047e0 	ldr	x0, [sp, #136]
 111bf74:	54000162 	b.cs	111bfa0 <tee_cryp_concat_kdf+0xbc>  // b.hs, b.nlast
		memcpy(out, tmp, sz);
		out += sz;
	}
	res = TEE_SUCCESS;
out:
	crypto_hash_free_ctx(ctx);
 111bf78:	f94047e0 	ldr	x0, [sp, #136]
 111bf7c:	97ffc4c5 	bl	110d290 <crypto_hash_free_ctx>
	return res;
}
 111bf80:	2a1303e0 	mov	w0, w19
 111bf84:	a94153f3 	ldp	x19, x20, [sp, #16]
 111bf88:	a9425bf5 	ldp	x21, x22, [sp, #32]
 111bf8c:	a94363f7 	ldp	x23, x24, [sp, #48]
 111bf90:	a9446bf9 	ldp	x25, x26, [sp, #64]
 111bf94:	a94573fb 	ldp	x27, x28, [sp, #80]
 111bf98:	a8cd7bfd 	ldp	x29, x30, [sp], #208
 111bf9c:	d65f03c0 	ret
		be_count = TEE_U32_TO_BIG_ENDIAN(i);
 111bfa0:	5ac00aa1 	rev	w1, w21
 111bfa4:	b9007fe1 	str	w1, [sp, #124]
		res = crypto_hash_init(ctx);
 111bfa8:	97ffc4d4 	bl	110d2f8 <crypto_hash_init>
		if (res != TEE_SUCCESS)
 111bfac:	35000240 	cbnz	w0, 111bff4 <tee_cryp_concat_kdf+0x110>
		res = crypto_hash_update(ctx, (uint8_t *)&be_count,
 111bfb0:	f94047e0 	ldr	x0, [sp, #136]
 111bfb4:	aa1c03e1 	mov	x1, x28
 111bfb8:	d2800082 	mov	x2, #0x4                   	// #4
 111bfbc:	97ffc4da 	bl	110d324 <crypto_hash_update>
		if (res != TEE_SUCCESS)
 111bfc0:	350001a0 	cbnz	w0, 111bff4 <tee_cryp_concat_kdf+0x110>
		res = crypto_hash_update(ctx, shared_secret, shared_secret_len);
 111bfc4:	a9460be1 	ldp	x1, x2, [sp, #96]
 111bfc8:	f94047e0 	ldr	x0, [sp, #136]
 111bfcc:	97ffc4d6 	bl	110d324 <crypto_hash_update>
		if (res != TEE_SUCCESS)
 111bfd0:	35000120 	cbnz	w0, 111bff4 <tee_cryp_concat_kdf+0x110>
		if (other_info && other_info_len) {
 111bfd4:	f100033f 	cmp	x25, #0x0
 111bfd8:	fa401b44 	ccmp	x26, #0x0, #0x4, ne  // ne = any
 111bfdc:	54000101 	b.ne	111bffc <tee_cryp_concat_kdf+0x118>  // b.any
		res = crypto_hash_final(ctx, tmp, sizeof(tmp));
 111bfe0:	f94047e0 	ldr	x0, [sp, #136]
 111bfe4:	aa1b03e1 	mov	x1, x27
 111bfe8:	d2800802 	mov	x2, #0x40                  	// #64
 111bfec:	97ffc4df 	bl	110d368 <crypto_hash_final>
		if (res != TEE_SUCCESS)
 111bff0:	34000120 	cbz	w0, 111c014 <tee_cryp_concat_kdf+0x130>
			res = crypto_hash_update(ctx, other_info,
 111bff4:	2a0003f3 	mov	w19, w0
 111bff8:	17ffffe0 	b	111bf78 <tee_cryp_concat_kdf+0x94>
 111bffc:	f94047e0 	ldr	x0, [sp, #136]
 111c000:	aa1a03e2 	mov	x2, x26
 111c004:	aa1903e1 	mov	x1, x25
 111c008:	97ffc4c7 	bl	110d324 <crypto_hash_update>
			if (res != TEE_SUCCESS)
 111c00c:	34fffea0 	cbz	w0, 111bfe0 <tee_cryp_concat_kdf+0xfc>
 111c010:	17fffff9 	b	111bff4 <tee_cryp_concat_kdf+0x110>
		if (i == n + 1)
 111c014:	eb15031f 	cmp	x24, x21
 111c018:	54000081 	b.ne	111c028 <tee_cryp_concat_kdf+0x144>  // b.any
			sz = derived_key_len % hash_len;
 111c01c:	f94043e0 	ldr	x0, [sp, #128]
 111c020:	9ac00af4 	udiv	x20, x23, x0
 111c024:	9b00de94 	msub	x20, x20, x0, x23
		memcpy(out, tmp, sz);
 111c028:	aa1603e0 	mov	x0, x22
 111c02c:	aa1403e2 	mov	x2, x20
 111c030:	aa1b03e1 	mov	x1, x27
		out += sz;
 111c034:	8b1402d6 	add	x22, x22, x20
	for (i = 1; i <= n + 1; i++) {
 111c038:	910006b5 	add	x21, x21, #0x1
		memcpy(out, tmp, sz);
 111c03c:	97ff9cd5 	bl	1103390 <memcpy>
	for (i = 1; i <= n + 1; i++) {
 111c040:	17ffffcb 	b	111bf6c <tee_cryp_concat_kdf+0x88>
 111c044:	2a0003f3 	mov	w19, w0
 111c048:	17ffffce 	b	111bf80 <tee_cryp_concat_kdf+0x9c>

000000000111c04c <pbkdf2_f>:
	uint32_t iteration_count;
};

static TEE_Result pbkdf2_f(uint8_t *out, size_t len, uint32_t idx,
			   struct hmac_parms *h, struct pbkdf2_parms *p)
{
 111c04c:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
 111c050:	910003fd 	mov	x29, sp
 111c054:	a9025bf5 	stp	x21, x22, [sp, #32]
 111c058:	2a0203f5 	mov	w21, w2
							p->salt_len);
				if (res != TEE_SUCCESS)
					return res;
			}

			be_index = TEE_U32_TO_BIG_ENDIAN(idx);
 111c05c:	5ac00ab5 	rev	w21, w21
{
 111c060:	a9046bf9 	stp	x25, x26, [sp, #64]
			res = crypto_mac_update(h->ctx, (uint8_t *)&be_index,
						sizeof(be_index));
			if (res != TEE_SUCCESS)
				return res;
		} else {
			res = crypto_mac_update(h->ctx, u, h->hash_len);
 111c064:	910183f9 	add	x25, sp, #0x60
			res = crypto_mac_update(h->ctx, (uint8_t *)&be_index,
 111c068:	910173fa 	add	x26, sp, #0x5c
	for (i = 1; i <= p->iteration_count; i++) {
 111c06c:	d2800036 	mov	x22, #0x1                   	// #1
	memset(out, 0, len);
 111c070:	aa0103e2 	mov	x2, x1
{
 111c074:	a90153f3 	stp	x19, x20, [sp, #16]
 111c078:	aa0303f3 	mov	x19, x3
 111c07c:	aa0403f4 	mov	x20, x4
 111c080:	a90363f7 	stp	x23, x24, [sp, #48]
 111c084:	aa0003f7 	mov	x23, x0
 111c088:	aa0103f8 	mov	x24, x1
	memset(out, 0, len);
 111c08c:	52800001 	mov	w1, #0x0                   	// #0
 111c090:	94009f14 	bl	1143ce0 <memset>
	for (i = 1; i <= p->iteration_count; i++) {
 111c094:	b9402280 	ldr	w0, [x20, #32]
 111c098:	eb16001f 	cmp	x0, x22
 111c09c:	54000062 	b.cs	111c0a8 <pbkdf2_f+0x5c>  // b.hs, b.nlast
			return res;

		for (j = 0; j < len; j++)
			out[j] ^= u[j];
	}
	return TEE_SUCCESS;
 111c0a0:	52800000 	mov	w0, #0x0                   	// #0
 111c0a4:	1400001e 	b	111c11c <pbkdf2_f+0xd0>
		res = crypto_mac_init(h->ctx, p->password, p->password_len);
 111c0a8:	a9400a81 	ldp	x1, x2, [x20]
 111c0ac:	f9400a60 	ldr	x0, [x19, #16]
 111c0b0:	97ffc61d 	bl	110d924 <crypto_mac_init>
		if (res != TEE_SUCCESS)
 111c0b4:	35000340 	cbnz	w0, 111c11c <pbkdf2_f+0xd0>
		if (i == 1) {
 111c0b8:	f10006df 	cmp	x22, #0x1
 111c0bc:	540003c1 	b.ne	111c134 <pbkdf2_f+0xe8>  // b.any
			if (p->salt && p->salt_len) {
 111c0c0:	f9400a81 	ldr	x1, [x20, #16]
 111c0c4:	b5000221 	cbnz	x1, 111c108 <pbkdf2_f+0xbc>
			res = crypto_mac_update(h->ctx, (uint8_t *)&be_index,
 111c0c8:	aa1a03e1 	mov	x1, x26
 111c0cc:	d2800082 	mov	x2, #0x4                   	// #4
			be_index = TEE_U32_TO_BIG_ENDIAN(idx);
 111c0d0:	b9005ff5 	str	w21, [sp, #92]
			res = crypto_mac_update(h->ctx, u, h->hash_len);
 111c0d4:	f9400a60 	ldr	x0, [x19, #16]
 111c0d8:	97ffc624 	bl	110d968 <crypto_mac_update>
			if (res != TEE_SUCCESS)
 111c0dc:	35000200 	cbnz	w0, 111c11c <pbkdf2_f+0xd0>
		res = crypto_mac_final(h->ctx, u, sizeof(u));
 111c0e0:	f9400a60 	ldr	x0, [x19, #16]
 111c0e4:	aa1903e1 	mov	x1, x25
 111c0e8:	d2800802 	mov	x2, #0x40                  	// #64
 111c0ec:	97ffc633 	bl	110d9b8 <crypto_mac_final>
		if (res != TEE_SUCCESS)
 111c0f0:	35000160 	cbnz	w0, 111c11c <pbkdf2_f+0xd0>
		for (j = 0; j < len; j++)
 111c0f4:	d2800000 	mov	x0, #0x0                   	// #0
 111c0f8:	eb18001f 	cmp	x0, x24
 111c0fc:	54000221 	b.ne	111c140 <pbkdf2_f+0xf4>  // b.any
	for (i = 1; i <= p->iteration_count; i++) {
 111c100:	910006d6 	add	x22, x22, #0x1
 111c104:	17ffffe4 	b	111c094 <pbkdf2_f+0x48>
			if (p->salt && p->salt_len) {
 111c108:	f9400e82 	ldr	x2, [x20, #24]
 111c10c:	b4fffde2 	cbz	x2, 111c0c8 <pbkdf2_f+0x7c>
				res = crypto_mac_update(h->ctx, p->salt,
 111c110:	f9400a60 	ldr	x0, [x19, #16]
 111c114:	97ffc615 	bl	110d968 <crypto_mac_update>
				if (res != TEE_SUCCESS)
 111c118:	34fffd80 	cbz	w0, 111c0c8 <pbkdf2_f+0x7c>
}
 111c11c:	a94153f3 	ldp	x19, x20, [sp, #16]
 111c120:	a9425bf5 	ldp	x21, x22, [sp, #32]
 111c124:	a94363f7 	ldp	x23, x24, [sp, #48]
 111c128:	a9446bf9 	ldp	x25, x26, [sp, #64]
 111c12c:	a8ca7bfd 	ldp	x29, x30, [sp], #160
 111c130:	d65f03c0 	ret
			res = crypto_mac_update(h->ctx, u, h->hash_len);
 111c134:	aa1903e1 	mov	x1, x25
 111c138:	f9400662 	ldr	x2, [x19, #8]
 111c13c:	17ffffe6 	b	111c0d4 <pbkdf2_f+0x88>
			out[j] ^= u[j];
 111c140:	38606ae1 	ldrb	w1, [x23, x0]
 111c144:	38606b22 	ldrb	w2, [x25, x0]
 111c148:	4a020021 	eor	w1, w1, w2
 111c14c:	38206ae1 	strb	w1, [x23, x0]
		for (j = 0; j < len; j++)
 111c150:	91000400 	add	x0, x0, #0x1
 111c154:	17ffffe9 	b	111c0f8 <pbkdf2_f+0xac>

000000000111c158 <tee_cryp_pbkdf2>:

TEE_Result tee_cryp_pbkdf2(uint32_t hash_id, const uint8_t *password,
			   size_t password_len, const uint8_t *salt,
			   size_t salt_len, uint32_t iteration_count,
			   uint8_t *derived_key, size_t derived_key_len)
{
 111c158:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
	size_t i, l, r;
	uint8_t *out = derived_key;
	struct pbkdf2_parms pbkdf2_parms;
	struct hmac_parms hmac_parms = {0, };

	hmac_parms.algo = TEE_ALG_HMAC_ALGO(hash_id);
 111c15c:	32040400 	orr	w0, w0, #0x30000000
{
 111c160:	910003fd 	mov	x29, sp
 111c164:	f9002bfb 	str	x27, [sp, #80]

	res = tee_alg_get_digest_size(hmac_parms.algo, &hmac_parms.hash_len);
 111c168:	910183fb 	add	x27, sp, #0x60
	struct hmac_parms hmac_parms = {0, };
 111c16c:	a9067fff 	stp	xzr, xzr, [sp, #96]
{
 111c170:	a90153f3 	stp	x19, x20, [sp, #16]
 111c174:	2a0503f3 	mov	w19, w5
 111c178:	aa0603f4 	mov	x20, x6
 111c17c:	a9025bf5 	stp	x21, x22, [sp, #32]
 111c180:	aa0403f6 	mov	x22, x4
 111c184:	a90363f7 	stp	x23, x24, [sp, #48]
 111c188:	aa0303f8 	mov	x24, x3
 111c18c:	aa0703f7 	mov	x23, x7
 111c190:	a9046bf9 	stp	x25, x26, [sp, #64]
 111c194:	aa0103fa 	mov	x26, x1
 111c198:	aa0203f9 	mov	x25, x2
	res = tee_alg_get_digest_size(hmac_parms.algo, &hmac_parms.hash_len);
 111c19c:	91002361 	add	x1, x27, #0x8
	hmac_parms.algo = TEE_ALG_HMAC_ALGO(hash_id);
 111c1a0:	b90063e0 	str	w0, [sp, #96]
	struct hmac_parms hmac_parms = {0, };
 111c1a4:	f9003bff 	str	xzr, [sp, #112]
	res = tee_alg_get_digest_size(hmac_parms.algo, &hmac_parms.hash_len);
 111c1a8:	97fffd64 	bl	111b738 <tee_alg_get_digest_size>
	if (res != TEE_SUCCESS)
 111c1ac:	35000320 	cbnz	w0, 111c210 <tee_cryp_pbkdf2+0xb8>
		return res;

	res = crypto_mac_alloc_ctx(&hmac_parms.ctx, hmac_parms.algo);
 111c1b0:	b94063e1 	ldr	w1, [sp, #96]
 111c1b4:	91004360 	add	x0, x27, #0x10
 111c1b8:	97ffc563 	bl	110d744 <crypto_mac_alloc_ctx>
	if (res != TEE_SUCCESS)
 111c1bc:	350002a0 	cbnz	w0, 111c210 <tee_cryp_pbkdf2+0xb8>
		return res;

	pbkdf2_parms.password = password;
	pbkdf2_parms.password_len = password_len;
	pbkdf2_parms.salt = salt;
	pbkdf2_parms.salt_len = salt_len;
 111c1c0:	a908dbf8 	stp	x24, x22, [sp, #136]
	pbkdf2_parms.iteration_count = iteration_count;

	l = derived_key_len / hmac_parms.hash_len;
	r = derived_key_len % hmac_parms.hash_len;

	for (i = 1; i <= l; i++) {
 111c1c4:	d2800036 	mov	x22, #0x1                   	// #1
	l = derived_key_len / hmac_parms.hash_len;
 111c1c8:	f94037f8 	ldr	x24, [sp, #104]
	pbkdf2_parms.password_len = password_len;
 111c1cc:	a907e7fa 	stp	x26, x25, [sp, #120]
		res = pbkdf2_f(out, hmac_parms.hash_len, i, &hmac_parms,
 111c1d0:	9101e3f9 	add	x25, sp, #0x78
	pbkdf2_parms.iteration_count = iteration_count;
 111c1d4:	b9009bf3 	str	w19, [sp, #152]
	l = derived_key_len / hmac_parms.hash_len;
 111c1d8:	9ad80af5 	udiv	x21, x23, x24
	for (i = 1; i <= l; i++) {
 111c1dc:	eb1502df 	cmp	x22, x21
 111c1e0:	54000269 	b.ls	111c22c <tee_cryp_pbkdf2+0xd4>  // b.plast
	r = derived_key_len % hmac_parms.hash_len;
 111c1e4:	9b18dea1 	msub	x1, x21, x24, x23
			       &pbkdf2_parms);
		if (res != TEE_SUCCESS)
			goto out;
		out += hmac_parms.hash_len;
	}
	if (r)
 111c1e8:	b40003a1 	cbz	x1, 111c25c <tee_cryp_pbkdf2+0x104>
		res = pbkdf2_f(out, r, i, &hmac_parms, &pbkdf2_parms);
 111c1ec:	9101e3e4 	add	x4, sp, #0x78
 111c1f0:	aa1b03e3 	mov	x3, x27
 111c1f4:	2a1603e2 	mov	w2, w22
 111c1f8:	aa1403e0 	mov	x0, x20
 111c1fc:	97ffff94 	bl	111c04c <pbkdf2_f>
 111c200:	2a0003f3 	mov	w19, w0

out:
	crypto_mac_free_ctx(hmac_parms.ctx);
 111c204:	f9403be0 	ldr	x0, [sp, #112]
 111c208:	97ffc5ad 	bl	110d8bc <crypto_mac_free_ctx>
	return res;
 111c20c:	2a1303e0 	mov	w0, w19
}
 111c210:	a94153f3 	ldp	x19, x20, [sp, #16]
 111c214:	a9425bf5 	ldp	x21, x22, [sp, #32]
 111c218:	a94363f7 	ldp	x23, x24, [sp, #48]
 111c21c:	a9446bf9 	ldp	x25, x26, [sp, #64]
 111c220:	f9402bfb 	ldr	x27, [sp, #80]
 111c224:	a8ca7bfd 	ldp	x29, x30, [sp], #160
 111c228:	d65f03c0 	ret
		res = pbkdf2_f(out, hmac_parms.hash_len, i, &hmac_parms,
 111c22c:	f94037e1 	ldr	x1, [sp, #104]
 111c230:	aa1903e4 	mov	x4, x25
 111c234:	aa1b03e3 	mov	x3, x27
 111c238:	2a1603e2 	mov	w2, w22
 111c23c:	aa1403e0 	mov	x0, x20
 111c240:	97ffff83 	bl	111c04c <pbkdf2_f>
 111c244:	2a0003f3 	mov	w19, w0
		if (res != TEE_SUCCESS)
 111c248:	35fffde0 	cbnz	w0, 111c204 <tee_cryp_pbkdf2+0xac>
		out += hmac_parms.hash_len;
 111c24c:	f94037e0 	ldr	x0, [sp, #104]
	for (i = 1; i <= l; i++) {
 111c250:	910006d6 	add	x22, x22, #0x1
		out += hmac_parms.hash_len;
 111c254:	8b000294 	add	x20, x20, x0
	for (i = 1; i <= l; i++) {
 111c258:	17ffffe1 	b	111c1dc <tee_cryp_pbkdf2+0x84>
out:
 111c25c:	52800013 	mov	w19, #0x0                   	// #0
 111c260:	17ffffe9 	b	111c204 <tee_cryp_pbkdf2+0xac>

000000000111c264 <tee_svc_update_out_param>:
static TEE_Result tee_svc_update_out_param(
		struct tee_ta_param *param,
		void *tmp_buf_va[TEE_NUM_PARAMS],
		size_t tmp_buf_size[TEE_NUM_PARAMS],
		struct utee_params *usr_param)
{
 111c264:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 111c268:	910003fd 	mov	x29, sp
 111c26c:	a90153f3 	stp	x19, x20, [sp, #16]
 111c270:	91002073 	add	x19, x3, #0x8
	size_t n;
	uint64_t *vals = usr_param->vals;
	size_t sz = 0;

	for (n = 0; n < TEE_NUM_PARAMS; n++) {
 111c274:	d2800014 	mov	x20, #0x0                   	// #0
{
 111c278:	a9025bf5 	stp	x21, x22, [sp, #32]
 111c27c:	aa0003f6 	mov	x22, x0
 111c280:	91002015 	add	x21, x0, #0x8
 111c284:	a90363f7 	stp	x23, x24, [sp, #48]
 111c288:	aa0103f8 	mov	x24, x1
 111c28c:	f90023f9 	str	x25, [sp, #64]
 111c290:	aa0203f9 	mov	x25, x2
		switch (TEE_PARAM_TYPE_GET(param->types, n)) {
 111c294:	b94002c4 	ldr	w4, [x22]
 111c298:	531e7683 	lsl	w3, w20, #2
 111c29c:	1ac32483 	lsr	w3, w4, w3
 111c2a0:	12000c60 	and	w0, w3, #0xf
 111c2a4:	721e047f 	tst	w3, #0xc
 111c2a8:	54000101 	b.ne	111c2c8 <tee_svc_update_out_param+0x64>  // b.any
 111c2ac:	721f087f 	tst	w3, #0xe
 111c2b0:	540001a0 	b.eq	111c2e4 <tee_svc_update_out_param+0x80>  // b.none
			usr_param->vals[n * 2 + 1] = sz;
			break;

		case TEE_PARAM_TYPE_VALUE_OUTPUT:
		case TEE_PARAM_TYPE_VALUE_INOUT:
			vals[n * 2] = param->u[n].val.a;
 111c2b4:	b94002a0 	ldr	w0, [x21]
 111c2b8:	f9000260 	str	x0, [x19]
			vals[n * 2 + 1] = param->u[n].val.b;
 111c2bc:	b94006a0 	ldr	w0, [x21, #4]
 111c2c0:	f9000660 	str	x0, [x19, #8]
			break;
 111c2c4:	14000008 	b	111c2e4 <tee_svc_update_out_param+0x80>
		switch (TEE_PARAM_TYPE_GET(param->types, n)) {
 111c2c8:	51001800 	sub	w0, w0, #0x6
 111c2cc:	7100041f 	cmp	w0, #0x1
 111c2d0:	540000a8 	b.hi	111c2e4 <tee_svc_update_out_param+0x80>  // b.pmore
			if (tmp_buf_va[n] && sz <= vals[n * 2 + 1]) {
 111c2d4:	f8747b01 	ldr	x1, [x24, x20, lsl #3]
			sz = param->u[n].mem.size;
 111c2d8:	f94006b7 	ldr	x23, [x21, #8]
			if (tmp_buf_va[n] && sz <= vals[n * 2 + 1]) {
 111c2dc:	b5000121 	cbnz	x1, 111c300 <tee_svc_update_out_param+0x9c>
			usr_param->vals[n * 2 + 1] = sz;
 111c2e0:	f9000677 	str	x23, [x19, #8]
	for (n = 0; n < TEE_NUM_PARAMS; n++) {
 111c2e4:	91000694 	add	x20, x20, #0x1
 111c2e8:	91004273 	add	x19, x19, #0x10
 111c2ec:	910062b5 	add	x21, x21, #0x18
 111c2f0:	f100129f 	cmp	x20, #0x4
 111c2f4:	54fffd01 	b.ne	111c294 <tee_svc_update_out_param+0x30>  // b.any
		default:
			continue;
		}
	}

	return TEE_SUCCESS;
 111c2f8:	52800000 	mov	w0, #0x0                   	// #0
 111c2fc:	1400000b 	b	111c328 <tee_svc_update_out_param+0xc4>
			if (tmp_buf_va[n] && sz <= vals[n * 2 + 1]) {
 111c300:	f9400660 	ldr	x0, [x19, #8]
 111c304:	eb17001f 	cmp	x0, x23
 111c308:	54fffec3 	b.cc	111c2e0 <tee_svc_update_out_param+0x7c>  // b.lo, b.ul, b.last
				if (sz <= tmp_buf_size[n]) {
 111c30c:	f8747b20 	ldr	x0, [x25, x20, lsl #3]
 111c310:	eb17001f 	cmp	x0, x23
 111c314:	54fffe63 	b.cc	111c2e0 <tee_svc_update_out_param+0x7c>  // b.lo, b.ul, b.last
					res = copy_to_user(dst, src, sz);
 111c318:	f9400260 	ldr	x0, [x19]
 111c31c:	aa1703e2 	mov	x2, x23
 111c320:	97ffe308 	bl	1114f40 <copy_to_user>
					if (res != TEE_SUCCESS)
 111c324:	34fffde0 	cbz	w0, 111c2e0 <tee_svc_update_out_param+0x7c>
}
 111c328:	a94153f3 	ldp	x19, x20, [sp, #16]
 111c32c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 111c330:	a94363f7 	ldp	x23, x24, [sp, #48]
 111c334:	f94023f9 	ldr	x25, [sp, #64]
 111c338:	a8c57bfd 	ldp	x29, x30, [sp], #80
 111c33c:	d65f03c0 	ret

000000000111c340 <get_prop_tee_dev_id>:
{
 111c340:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
	uint8_t data[5 + FVR_DIE_ID_NUM_REGS * sizeof(uint32_t)] = {
 111c344:	d28a09e0 	mov	x0, #0x504f                	// #20559
 111c348:	f2a8aa80 	movk	x0, #0x4554, lsl #16
 111c34c:	f2c008a0 	movk	x0, #0x45, lsl #32
{
 111c350:	910003fd 	mov	x29, sp
	uint8_t data[5 + FVR_DIE_ID_NUM_REGS * sizeof(uint32_t)] = {
 111c354:	a904ffe0 	stp	x0, xzr, [sp, #72]
	if (*blen < sizeof(uuid)) {
 111c358:	f9400040 	ldr	x0, [x2]
{
 111c35c:	a90153f3 	stp	x19, x20, [sp, #16]
 111c360:	d2800213 	mov	x19, #0x10                  	// #16
 111c364:	a9025bf5 	stp	x21, x22, [sp, #32]
	if (*blen < sizeof(uuid)) {
 111c368:	f1003c1f 	cmp	x0, #0xf
	uint8_t data[5 + FVR_DIE_ID_NUM_REGS * sizeof(uint32_t)] = {
 111c36c:	390163ff 	strb	wzr, [sp, #88]
	if (*blen < sizeof(uuid)) {
 111c370:	540000e8 	b.hi	111c38c <get_prop_tee_dev_id+0x4c>  // b.pmore
		return TEE_ERROR_SHORT_BUFFER;
 111c374:	129ffde0 	mov	w0, #0xffff0010            	// #-65520
		*blen = sizeof(uuid);
 111c378:	f9000053 	str	x19, [x2]
}
 111c37c:	a94153f3 	ldp	x19, x20, [sp, #16]
 111c380:	a9425bf5 	ldp	x21, x22, [sp, #32]
 111c384:	a8c67bfd 	ldp	x29, x30, [sp], #96
 111c388:	d65f03c0 	ret
	*blen = sizeof(uuid);
 111c38c:	f9000053 	str	x19, [x2]
	if (tee_otp_get_die_id(data + nslen, sizeof(data) - nslen))
 111c390:	910123f6 	add	x22, sp, #0x48
 111c394:	aa0103f4 	mov	x20, x1
 111c398:	910016c0 	add	x0, x22, #0x5
 111c39c:	d2800181 	mov	x1, #0xc                   	// #12
 111c3a0:	97ff9fbc 	bl	1104290 <tee_otp_get_die_id>
 111c3a4:	34000060 	cbz	w0, 111c3b0 <get_prop_tee_dev_id+0x70>
		return TEE_ERROR_BAD_STATE;
 111c3a8:	129fff00 	mov	w0, #0xffff0007            	// #-65529
 111c3ac:	17fffff4 	b	111c37c <get_prop_tee_dev_id+0x3c>
	res = tee_hash_createdigest(TEE_ALG_SHA256, data, sizeof(data),
 111c3b0:	9100e3f5 	add	x21, sp, #0x38
 111c3b4:	52800080 	mov	w0, #0x4                   	// #4
 111c3b8:	aa1303e4 	mov	x4, x19
 111c3bc:	aa1503e3 	mov	x3, x21
 111c3c0:	aa1603e1 	mov	x1, x22
 111c3c4:	d2800222 	mov	x2, #0x11                  	// #17
 111c3c8:	72aa0000 	movk	w0, #0x5000, lsl #16
 111c3cc:	97fffd32 	bl	111b894 <tee_hash_createdigest>
	if (res != TEE_SUCCESS)
 111c3d0:	35fffec0 	cbnz	w0, 111c3a8 <get_prop_tee_dev_id+0x68>
	uuid.timeHiAndVersion &= 0x0fff;
 111c3d4:	79407fe0 	ldrh	w0, [sp, #62]
	uuid.timeHiAndVersion |= 5 << 12;
 111c3d8:	528a0001 	mov	w1, #0x5000                	// #20480
	return copy_to_user(buf, &uuid, sizeof(TEE_UUID));
 111c3dc:	aa1303e2 	mov	x2, x19
	uuid.timeHiAndVersion &= 0x0fff;
 111c3e0:	12002c00 	and	w0, w0, #0xfff
	uuid.timeHiAndVersion |= 5 << 12;
 111c3e4:	2a010000 	orr	w0, w0, w1
 111c3e8:	79007fe0 	strh	w0, [sp, #62]
	uuid.clockSeqAndNode[0] &= 0x3f;
 111c3ec:	394103e0 	ldrb	w0, [sp, #64]
	return copy_to_user(buf, &uuid, sizeof(TEE_UUID));
 111c3f0:	aa1503e1 	mov	x1, x21
	uuid.clockSeqAndNode[0] &= 0x3f;
 111c3f4:	12001400 	and	w0, w0, #0x3f
	uuid.clockSeqAndNode[0] |= 0x80;
 111c3f8:	32196000 	orr	w0, w0, #0xffffff80
 111c3fc:	390103e0 	strb	w0, [sp, #64]
	return copy_to_user(buf, &uuid, sizeof(TEE_UUID));
 111c400:	aa1403e0 	mov	x0, x20
 111c404:	97ffe2cf 	bl	1114f40 <copy_to_user>
 111c408:	17ffffdd 	b	111c37c <get_prop_tee_dev_id+0x3c>

000000000111c40c <get_prop_set>:
	if ((TEE_PropSetHandle)prop_set == TEE_PROPSET_CURRENT_CLIENT) {
 111c40c:	b27f7be5 	mov	x5, #0xfffffffe            	// #4294967294
 111c410:	eb05001f 	cmp	x0, x5
 111c414:	540001a1 	b.ne	111c448 <get_prop_set+0x3c>  // b.any
		*props = tee_propset_client;
 111c418:	f00001e0 	adrp	x0, 115b000 <__vcore_unpg_rw_start>
 111c41c:	91218000 	add	x0, x0, #0x860
 111c420:	f9000020 	str	x0, [x1]
		*size = ARRAY_SIZE(tee_propset_client);
 111c424:	d2800020 	mov	x0, #0x1                   	// #1
 111c428:	f9000040 	str	x0, [x2]
		*vendor_props = vendor_props_client.props;
 111c42c:	d0000180 	adrp	x0, 114e000 <ldelf_data+0x8000>
 111c430:	910b0001 	add	x1, x0, #0x2c0
 111c434:	f9416000 	ldr	x0, [x0, #704]
		*vendor_props = vendor_props_tee.props;
 111c438:	f9000060 	str	x0, [x3]
		*vendor_size = vendor_props_tee.len;
 111c43c:	f9400420 	ldr	x0, [x1, #8]
 111c440:	f9000080 	str	x0, [x4]
}
 111c444:	d65f03c0 	ret
	} else if ((TEE_PropSetHandle)prop_set == TEE_PROPSET_CURRENT_TA) {
 111c448:	b2407fe5 	mov	x5, #0xffffffff            	// #4294967295
 111c44c:	eb05001f 	cmp	x0, x5
 111c450:	54000141 	b.ne	111c478 <get_prop_set+0x6c>  // b.any
		*props = tee_propset_ta;
 111c454:	f00001e0 	adrp	x0, 115b000 <__vcore_unpg_rw_start>
 111c458:	91222000 	add	x0, x0, #0x888
 111c45c:	f9000020 	str	x0, [x1]
		*size = ARRAY_SIZE(tee_propset_ta);
 111c460:	d2800020 	mov	x0, #0x1                   	// #1
 111c464:	f9000040 	str	x0, [x2]
		*vendor_props = vendor_props_ta.props;
 111c468:	d0000180 	adrp	x0, 114e000 <ldelf_data+0x8000>
 111c46c:	910b4001 	add	x1, x0, #0x2d0
 111c470:	f9416800 	ldr	x0, [x0, #720]
 111c474:	17fffff1 	b	111c438 <get_prop_set+0x2c>
	} else if ((TEE_PropSetHandle)prop_set ==
 111c478:	12800045 	mov	w5, #0xfffffffd            	// #-3
 111c47c:	eb05001f 	cmp	x0, x5
 111c480:	54000141 	b.ne	111c4a8 <get_prop_set+0x9c>  // b.any
		*props = tee_propset_tee;
 111c484:	f00001e0 	adrp	x0, 115b000 <__vcore_unpg_rw_start>
 111c488:	9122c000 	add	x0, x0, #0x8b0
 111c48c:	f9000020 	str	x0, [x1]
		*size = ARRAY_SIZE(tee_propset_tee);
 111c490:	d28001a0 	mov	x0, #0xd                   	// #13
 111c494:	f9000040 	str	x0, [x2]
		*vendor_props = vendor_props_tee.props;
 111c498:	d0000180 	adrp	x0, 114e000 <ldelf_data+0x8000>
 111c49c:	910b8001 	add	x1, x0, #0x2e0
 111c4a0:	f9417000 	ldr	x0, [x0, #736]
 111c4a4:	17ffffe5 	b	111c438 <get_prop_set+0x2c>
		*props = NULL;
 111c4a8:	f900003f 	str	xzr, [x1]
		*size = 0;
 111c4ac:	f900005f 	str	xzr, [x2]
		*vendor_props = NULL;
 111c4b0:	f900007f 	str	xzr, [x3]
		*vendor_size = 0;
 111c4b4:	f900009f 	str	xzr, [x4]
}
 111c4b8:	17ffffe3 	b	111c444 <get_prop_set+0x38>

000000000111c4bc <get_prop_client_id>:
{
 111c4bc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 111c4c0:	910003fd 	mov	x29, sp
 111c4c4:	a90153f3 	stp	x19, x20, [sp, #16]
 111c4c8:	aa0103f3 	mov	x19, x1
 111c4cc:	d2800294 	mov	x20, #0x14                  	// #20
	if (*blen < sizeof(TEE_Identity)) {
 111c4d0:	f9400041 	ldr	x1, [x2]
		*blen = sizeof(TEE_Identity);
 111c4d4:	f9000054 	str	x20, [x2]
	if (*blen < sizeof(TEE_Identity)) {
 111c4d8:	f1004c3f 	cmp	x1, #0x13
 111c4dc:	54000109 	b.ls	111c4fc <get_prop_client_id+0x40>  // b.plast
	return copy_to_user(buf, &to_ta_session(sess)->clnt_id,
 111c4e0:	97ffde98 	bl	1113f40 <to_ta_session>
 111c4e4:	9100f001 	add	x1, x0, #0x3c
 111c4e8:	aa1403e2 	mov	x2, x20
 111c4ec:	aa1303e0 	mov	x0, x19
}
 111c4f0:	a94153f3 	ldp	x19, x20, [sp, #16]
 111c4f4:	a8c27bfd 	ldp	x29, x30, [sp], #32
	return copy_to_user(buf, &to_ta_session(sess)->clnt_id,
 111c4f8:	17ffe292 	b	1114f40 <copy_to_user>
}
 111c4fc:	129ffde0 	mov	w0, #0xffff0010            	// #-65520
 111c500:	a94153f3 	ldp	x19, x20, [sp, #16]
 111c504:	a8c27bfd 	ldp	x29, x30, [sp], #32
 111c508:	d65f03c0 	ret

000000000111c50c <get_prop_ta_app_id>:
{
 111c50c:	aa0203e3 	mov	x3, x2
 111c510:	aa0003e4 	mov	x4, x0
 111c514:	aa0103e0 	mov	x0, x1
 111c518:	d2800202 	mov	x2, #0x10                  	// #16
	if (*blen < sizeof(TEE_UUID)) {
 111c51c:	f9400061 	ldr	x1, [x3]
		*blen = sizeof(TEE_UUID);
 111c520:	f9000062 	str	x2, [x3]
	if (*blen < sizeof(TEE_UUID)) {
 111c524:	f1003c3f 	cmp	x1, #0xf
 111c528:	54000069 	b.ls	111c534 <get_prop_ta_app_id+0x28>  // b.plast
	return copy_to_user(buf, &sess->ctx->uuid, sizeof(TEE_UUID));
 111c52c:	f9400881 	ldr	x1, [x4, #16]
 111c530:	17ffe284 	b	1114f40 <copy_to_user>
}
 111c534:	129ffde0 	mov	w0, #0xffff0010            	// #-65520
 111c538:	d65f03c0 	ret

000000000111c53c <get_prop_tee_sys_time_prot_level>:
{
 111c53c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 111c540:	910003fd 	mov	x29, sp
 111c544:	a90153f3 	stp	x19, x20, [sp, #16]
 111c548:	aa0103f3 	mov	x19, x1
 111c54c:	d2800094 	mov	x20, #0x4                   	// #4
	if (*blen < sizeof(prot)) {
 111c550:	f9400041 	ldr	x1, [x2]
		*blen = sizeof(prot);
 111c554:	f9000054 	str	x20, [x2]
	if (*blen < sizeof(prot)) {
 111c558:	f1000c3f 	cmp	x1, #0x3
 111c55c:	540000a8 	b.hi	111c570 <get_prop_tee_sys_time_prot_level+0x34>  // b.pmore
		return TEE_ERROR_SHORT_BUFFER;
 111c560:	129ffde0 	mov	w0, #0xffff0010            	// #-65520
}
 111c564:	a94153f3 	ldp	x19, x20, [sp, #16]
 111c568:	a8c37bfd 	ldp	x29, x30, [sp], #48
 111c56c:	d65f03c0 	ret
	prot = tee_time_get_sys_time_protection_level();
 111c570:	97ff9f15 	bl	11041c4 <tee_time_get_sys_time_protection_level>
 111c574:	b9002fe0 	str	w0, [sp, #44]
	return copy_to_user(buf, &prot, sizeof(prot));
 111c578:	aa1403e2 	mov	x2, x20
 111c57c:	9100b3e1 	add	x1, sp, #0x2c
 111c580:	aa1303e0 	mov	x0, x19
 111c584:	97ffe26f 	bl	1114f40 <copy_to_user>
 111c588:	17fffff7 	b	111c564 <get_prop_tee_sys_time_prot_level+0x28>

000000000111c58c <to_user_ta_ctx>:
{
 111c58c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 111c590:	910003fd 	mov	x29, sp
 111c594:	f9000bf3 	str	x19, [sp, #16]
 111c598:	aa0003f3 	mov	x19, x0
	assert(is_user_ta_ctx(ctx));
 111c59c:	97ffe714 	bl	11161ec <is_user_ta_ctx>
 111c5a0:	72001c1f 	tst	w0, #0xff
 111c5a4:	54000141 	b.ne	111c5cc <to_user_ta_ctx+0x40>  // b.any
 111c5a8:	b00001c3 	adrp	x3, 1155000 <__func__.3826+0xa8>
 111c5ac:	b00001a1 	adrp	x1, 1151000 <small_prime+0x168>
 111c5b0:	9122a463 	add	x3, x3, #0x8a9
 111c5b4:	91081021 	add	x1, x1, #0x204
 111c5b8:	b00001a0 	adrp	x0, 1151000 <small_prime+0x168>
 111c5bc:	91088800 	add	x0, x0, #0x222
 111c5c0:	52800702 	mov	w2, #0x38                  	// #56
 111c5c4:	97ffd73a 	bl	11122ac <_assert_log>
 111c5c8:	97ffd74a 	bl	11122f0 <_assert_break>
}
 111c5cc:	d10ba260 	sub	x0, x19, #0x2e8
 111c5d0:	f9400bf3 	ldr	x19, [sp, #16]
 111c5d4:	a8c27bfd 	ldp	x29, x30, [sp], #32
 111c5d8:	d65f03c0 	ret

000000000111c5dc <mobj_get_va.constprop.0>:
	if (mobj && mobj->ops && mobj->ops->get_va)
 111c5dc:	b4000100 	cbz	x0, 111c5fc <mobj_get_va.constprop.0+0x20>
 111c5e0:	f9400001 	ldr	x1, [x0]
 111c5e4:	b40000c1 	cbz	x1, 111c5fc <mobj_get_va.constprop.0+0x20>
 111c5e8:	f9400022 	ldr	x2, [x1]
 111c5ec:	b4000082 	cbz	x2, 111c5fc <mobj_get_va.constprop.0+0x20>
		return mobj->ops->get_va(mobj, offset);
 111c5f0:	aa0203f0 	mov	x16, x2
 111c5f4:	d2800001 	mov	x1, #0x0                   	// #0
 111c5f8:	d61f0200 	br	x16
}
 111c5fc:	d2800000 	mov	x0, #0x0                   	// #0
 111c600:	d65f03c0 	ret

000000000111c604 <mobj_put_wipe>:
{
 111c604:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 111c608:	910003fd 	mov	x29, sp
 111c60c:	f9000bf3 	str	x19, [sp, #16]
 111c610:	aa0003f3 	mov	x19, x0
	void *buf = mobj_get_va(mobj, 0);
 111c614:	97fffff2 	bl	111c5dc <mobj_get_va.constprop.0>
	if (buf)
 111c618:	b40001c0 	cbz	x0, 111c650 <mobj_put_wipe+0x4c>
		memzero_explicit(buf, mobj->size);
 111c61c:	f9400661 	ldr	x1, [x19, #8]
 111c620:	9400a278 	bl	1145000 <memzero_explicit>
	if (mobj && refcount_dec(&mobj->refc))
 111c624:	91006260 	add	x0, x19, #0x18
 111c628:	97ffdbe1 	bl	11135ac <refcount_dec>
 111c62c:	72001c1f 	tst	w0, #0xff
 111c630:	54000120 	b.eq	111c654 <mobj_put_wipe+0x50>  // b.none
		mobj->ops->free(mobj);
 111c634:	f9400260 	ldr	x0, [x19]
 111c638:	f9401401 	ldr	x1, [x0, #40]
 111c63c:	aa1303e0 	mov	x0, x19
}
 111c640:	f9400bf3 	ldr	x19, [sp, #16]
		mobj->ops->free(mobj);
 111c644:	aa0103f0 	mov	x16, x1
}
 111c648:	a8c27bfd 	ldp	x29, x30, [sp], #32
		mobj->ops->free(mobj);
 111c64c:	d61f0200 	br	x16
	if (mobj && refcount_dec(&mobj->refc))
 111c650:	b5fffeb3 	cbnz	x19, 111c624 <mobj_put_wipe+0x20>
}
 111c654:	f9400bf3 	ldr	x19, [sp, #16]
 111c658:	a8c27bfd 	ldp	x29, x30, [sp], #32
 111c65c:	d65f03c0 	ret

000000000111c660 <tee_svc_copy_param.isra.0>:
static TEE_Result tee_svc_copy_param(struct ts_session *sess,
 111c660:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
 111c664:	910003fd 	mov	x29, sp
 111c668:	a90153f3 	stp	x19, x20, [sp, #16]
 111c66c:	a9025bf5 	stp	x21, x22, [sp, #32]
 111c670:	aa0203f5 	mov	x21, x2
 111c674:	aa0303f6 	mov	x22, x3
 111c678:	a90363f7 	stp	x23, x24, [sp, #48]
 111c67c:	aa0603f7 	mov	x23, x6
 111c680:	a9046bf9 	stp	x25, x26, [sp, #64]
 111c684:	aa0103fa 	mov	x26, x1
 111c688:	aa0503f9 	mov	x25, x5
 111c68c:	a90573fb 	stp	x27, x28, [sp, #80]
 111c690:	f90037e4 	str	x4, [sp, #104]
	struct user_ta_ctx *utc = to_user_ta_ctx(sess->ctx);
 111c694:	97ffffbe 	bl	111c58c <to_user_ta_ctx>
	bool ta_private_memref[TEE_NUM_PARAMS] = { false, };
 111c698:	b9008bff 	str	wzr, [sp, #136]
	struct user_ta_ctx *utc = to_user_ta_ctx(sess->ctx);
 111c69c:	aa0003f8 	mov	x24, x0
	if (!callee_params) {
 111c6a0:	b50009f5 	cbnz	x21, 111c7dc <tee_svc_copy_param.isra.0+0x17c>
		memset(param, 0, sizeof(*param));
 111c6a4:	aa1603e0 	mov	x0, x22
 111c6a8:	d2800d02 	mov	x2, #0x68                  	// #104
 111c6ac:	52800001 	mov	w1, #0x0                   	// #0
 111c6b0:	94009d8c 	bl	1143ce0 <memset>
	if (called_sess && is_pseudo_ta_ctx(called_sess->ctx)) {
 111c6b4:	b50010fa 	cbnz	x26, 111c8d0 <tee_svc_copy_param.isra.0+0x270>
 111c6b8:	910062d4 	add	x20, x22, #0x18
		ta_private_memref[n] = false;
 111c6bc:	910223f5 	add	x21, sp, #0x88
			if (vm_buf_is_inside_um_private(&utc->uctx, va, s)) {
 111c6c0:	91014318 	add	x24, x24, #0x50
		switch (TEE_PARAM_TYPE_GET(types, n)) {
 111c6c4:	d280001a 	mov	x26, #0x0                   	// #0
 111c6c8:	d280001c 	mov	x28, #0x0                   	// #0
		switch (TEE_PARAM_TYPE_GET(param->types, n)) {
 111c6cc:	b94002c1 	ldr	w1, [x22]
 111c6d0:	531e7780 	lsl	w0, w28, #2
		ta_private_memref[n] = false;
 111c6d4:	38356b9f 	strb	wzr, [x28, x21]
		switch (TEE_PARAM_TYPE_GET(param->types, n)) {
 111c6d8:	1ac02420 	lsr	w0, w1, w0
 111c6dc:	12000c00 	and	w0, w0, #0xf
 111c6e0:	51001400 	sub	w0, w0, #0x5
 111c6e4:	7100081f 	cmp	w0, #0x2
 111c6e8:	54000088 	b.hi	111c6f8 <tee_svc_copy_param.isra.0+0x98>  // b.pmore
			va = (void *)param->u[n].mem.offs;
 111c6ec:	a97fee93 	ldp	x19, x27, [x20, #-8]
			if (!va) {
 111c6f0:	b5000fdb 	cbnz	x27, 111c8e8 <tee_svc_copy_param.isra.0+0x288>
				if (s)
 111c6f4:	b5000b13 	cbnz	x19, 111c854 <tee_svc_copy_param.isra.0+0x1f4>
	for (n = 0; n < TEE_NUM_PARAMS; n++) {
 111c6f8:	9100079c 	add	x28, x28, #0x1
 111c6fc:	91006294 	add	x20, x20, #0x18
 111c700:	f100139f 	cmp	x28, #0x4
 111c704:	54fffe41 	b.ne	111c6cc <tee_svc_copy_param.isra.0+0x6c>  // b.any
	if (req_mem == 0)
 111c708:	b4000eda 	cbz	x26, 111c8e0 <tee_svc_copy_param.isra.0+0x280>
	*mobj = mobj_mm_alloc(mobj_sec_ddr, size, &tee_mm_sec_ddr);
 111c70c:	d00001e0 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 111c710:	aa1a03e1 	mov	x1, x26
 111c714:	f9415002 	ldr	x2, [x0, #672]
 111c718:	f9412c00 	ldr	x0, [x0, #600]
 111c71c:	f9400000 	ldr	x0, [x0]
 111c720:	97ffef0e 	bl	1118358 <mobj_mm_alloc>
 111c724:	f90002e0 	str	x0, [x23]
	if (!*mobj)
 111c728:	b4001260 	cbz	x0, 111c974 <tee_svc_copy_param.isra.0+0x314>
	*va = mobj_get_va(*mobj, 0);
 111c72c:	97ffffac 	bl	111c5dc <mobj_get_va.constprop.0>
 111c730:	910022d4 	add	x20, x22, #0x8
 111c734:	aa0003fb 	mov	x27, x0
	dst_offs = 0;
 111c738:	d280001c 	mov	x28, #0x0                   	// #0
	for (n = 0; n < TEE_NUM_PARAMS; n++) {
 111c73c:	d280001a 	mov	x26, #0x0                   	// #0
		switch (TEE_PARAM_TYPE_GET(param->types, n)) {
 111c740:	528001a4 	mov	w4, #0xd                   	// #13
		if (!ta_private_memref[n])
 111c744:	387a6aa0 	ldrb	w0, [x21, x26]
 111c748:	34000400 	cbz	w0, 111c7c8 <tee_svc_copy_param.isra.0+0x168>
		switch (TEE_PARAM_TYPE_GET(param->types, n)) {
 111c74c:	b94002c1 	ldr	w1, [x22]
 111c750:	531e7740 	lsl	w0, w26, #2
		s = ROUNDUP(param->u[n].mem.size, sizeof(uint32_t));
 111c754:	f9400682 	ldr	x2, [x20, #8]
		switch (TEE_PARAM_TYPE_GET(param->types, n)) {
 111c758:	1ac02420 	lsr	w0, w1, w0
 111c75c:	12000c01 	and	w1, w0, #0xf
		s = ROUNDUP(param->u[n].mem.size, sizeof(uint32_t));
 111c760:	91000c43 	add	x3, x2, #0x3
		switch (TEE_PARAM_TYPE_GET(param->types, n)) {
 111c764:	7100183f 	cmp	w1, #0x6
		s = ROUNDUP(param->u[n].mem.size, sizeof(uint32_t));
 111c768:	927ef463 	and	x3, x3, #0xfffffffffffffffc
		switch (TEE_PARAM_TYPE_GET(param->types, n)) {
 111c76c:	54000ec0 	b.eq	111c944 <tee_svc_copy_param.isra.0+0x2e4>  // b.none
 111c770:	0a040000 	and	w0, w0, w4
 111c774:	7100141f 	cmp	w0, #0x5
 111c778:	54000281 	b.ne	111c7c8 <tee_svc_copy_param.isra.0+0x168>  // b.any
			va = (void *)param->u[n].mem.offs;
 111c77c:	f9400a81 	ldr	x1, [x20, #16]
			if (va) {
 111c780:	b4000241 	cbz	x1, 111c7c8 <tee_svc_copy_param.isra.0+0x168>
				res = copy_from_user(dst, va,
 111c784:	aa1b03e0 	mov	x0, x27
 111c788:	f9003be3 	str	x3, [sp, #112]
 111c78c:	b9007fe4 	str	w4, [sp, #124]
 111c790:	97ffe1d8 	bl	1114ef0 <copy_from_user>
 111c794:	2a0003f3 	mov	w19, w0
				if (res != TEE_SUCCESS)
 111c798:	35000600 	cbnz	w0, 111c858 <tee_svc_copy_param.isra.0+0x1f8>
				param->u[n].mem.offs = dst_offs;
 111c79c:	f9000a9c 	str	x28, [x20, #16]
				dst += s;
 111c7a0:	f9403be3 	ldr	x3, [sp, #112]
				param->u[n].mem.mobj = *mobj_tmp;
 111c7a4:	f94002e0 	ldr	x0, [x23]
 111c7a8:	f9000280 	str	x0, [x20]
				tmp_buf_va[n] = dst;
 111c7ac:	f94037e0 	ldr	x0, [sp, #104]
				dst_offs += s;
 111c7b0:	8b03039c 	add	x28, x28, x3
 111c7b4:	b9407fe4 	ldr	w4, [sp, #124]
				tmp_buf_va[n] = dst;
 111c7b8:	f83a781b 	str	x27, [x0, x26, lsl #3]
				dst += s;
 111c7bc:	8b03037b 	add	x27, x27, x3
				tmp_buf_size[n] = param->u[n].mem.size;
 111c7c0:	f9400680 	ldr	x0, [x20, #8]
 111c7c4:	f83a7b20 	str	x0, [x25, x26, lsl #3]
	for (n = 0; n < TEE_NUM_PARAMS; n++) {
 111c7c8:	9100075a 	add	x26, x26, #0x1
 111c7cc:	91006294 	add	x20, x20, #0x18
 111c7d0:	f100135f 	cmp	x26, #0x4
 111c7d4:	54fffb81 	b.ne	111c744 <tee_svc_copy_param.isra.0+0xe4>  // b.any
 111c7d8:	14000042 	b	111c8e0 <tee_svc_copy_param.isra.0+0x280>
		res = vm_check_access_rights(&utc->uctx, flags,
 111c7dc:	9101401b 	add	x27, x0, #0x50
 111c7e0:	aa1503e2 	mov	x2, x21
 111c7e4:	aa1b03e0 	mov	x0, x27
 111c7e8:	d2800903 	mov	x3, #0x48                  	// #72
 111c7ec:	528000e1 	mov	w1, #0x7                   	// #7
 111c7f0:	97fff3ff 	bl	11197ec <vm_check_access_rights>
 111c7f4:	2a0003f3 	mov	w19, w0
		if (res != TEE_SUCCESS)
 111c7f8:	35000300 	cbnz	w0, 111c858 <tee_svc_copy_param.isra.0+0x1f8>
			p->u[n].mem.mobj = &mobj_virt;
 111c7fc:	d00001e4 	adrp	x4, 115a000 <__scattered_array_1phys_mem_map+0x8>
	p->types = types;
 111c800:	aa1603f4 	mov	x20, x22
	uint32_t types = up->types;
 111c804:	f84086a0 	ldr	x0, [x21], #8
 111c808:	d000019c 	adrp	x28, 114e000 <ldelf_data+0x8000>
			p->u[n].mem.mobj = &mobj_virt;
 111c80c:	f9422484 	ldr	x4, [x4, #1096]
	uint32_t types = up->types;
 111c810:	2a0003e6 	mov	w6, w0
	p->types = types;
 111c814:	911be39c 	add	x28, x28, #0x6f8
 111c818:	b8008680 	str	w0, [x20], #8
		switch (TEE_PARAM_TYPE_GET(types, n)) {
 111c81c:	1ad324c1 	lsr	w1, w6, w19
 111c820:	12000c21 	and	w1, w1, #0xf
 111c824:	51000420 	sub	w0, w1, #0x1
 111c828:	7100181f 	cmp	w0, #0x6
		size_t b = up->vals[n * 2 + 1];
 111c82c:	a9400ea2 	ldp	x2, x3, [x21]
		switch (TEE_PARAM_TYPE_GET(types, n)) {
 111c830:	540004a8 	b.hi	111c8c4 <tee_svc_copy_param.isra.0+0x264>  // b.pmore
 111c834:	38604b80 	ldrb	w0, [x28, w0, uxtw]
 111c838:	10000065 	adr	x5, 111c844 <tee_svc_copy_param.isra.0+0x1e4>
 111c83c:	8b2088a0 	add	x0, x5, w0, sxtb #2
 111c840:	d61f0000 	br	x0
 111c844:	528000e1 	mov	w1, #0x7                   	// #7
			p->u[n].mem.offs = a;
 111c848:	a9008a83 	stp	x3, x2, [x20, #8]
			if (!p->u[n].mem.offs) {
 111c84c:	b5000242 	cbnz	x2, 111c894 <tee_svc_copy_param.isra.0+0x234>
				if (p->u[n].mem.size)
 111c850:	b4000143 	cbz	x3, 111c878 <tee_svc_copy_param.isra.0+0x218>
					return TEE_ERROR_BAD_PARAMETERS;
 111c854:	129fff33 	mov	w19, #0xffff0006            	// #-65530
}
 111c858:	2a1303e0 	mov	w0, w19
 111c85c:	a94153f3 	ldp	x19, x20, [sp, #16]
 111c860:	a9425bf5 	ldp	x21, x22, [sp, #32]
 111c864:	a94363f7 	ldp	x23, x24, [sp, #48]
 111c868:	a9446bf9 	ldp	x25, x26, [sp, #64]
 111c86c:	a94573fb 	ldp	x27, x28, [sp, #80]
 111c870:	a8c97bfd 	ldp	x29, x30, [sp], #144
 111c874:	d65f03c0 	ret
				p->u[n].mem.mobj = NULL;
 111c878:	f900029f 	str	xzr, [x20]
	for (n = 0; n < TEE_NUM_PARAMS; n++) {
 111c87c:	11001273 	add	w19, w19, #0x4
 111c880:	910042b5 	add	x21, x21, #0x10
 111c884:	91006294 	add	x20, x20, #0x18
 111c888:	7100427f 	cmp	w19, #0x10
 111c88c:	54fffc81 	b.ne	111c81c <tee_svc_copy_param.isra.0+0x1bc>  // b.any
 111c890:	17ffff89 	b	111c6b4 <tee_svc_copy_param.isra.0+0x54>
			p->u[n].mem.mobj = &mobj_virt;
 111c894:	f9000284 	str	x4, [x20]
			if (vm_check_access_rights(&utc->uctx, flags, a, b))
 111c898:	aa1b03e0 	mov	x0, x27
			p->u[n].mem.mobj = &mobj_virt;
 111c89c:	f9003be4 	str	x4, [sp, #112]
 111c8a0:	b9007fe6 	str	w6, [sp, #124]
			if (vm_check_access_rights(&utc->uctx, flags, a, b))
 111c8a4:	97fff3d2 	bl	11197ec <vm_check_access_rights>
 111c8a8:	b9407fe6 	ldr	w6, [sp, #124]
 111c8ac:	f9403be4 	ldr	x4, [sp, #112]
 111c8b0:	34fffe60 	cbz	w0, 111c87c <tee_svc_copy_param.isra.0+0x21c>
				return TEE_ERROR_ACCESS_DENIED;
 111c8b4:	129fffd3 	mov	w19, #0xffff0001            	// #-65535
 111c8b8:	17ffffe8 	b	111c858 <tee_svc_copy_param.isra.0+0x1f8>
			p->u[n].val.b = b;
 111c8bc:	29000e82 	stp	w2, w3, [x20]
			break;
 111c8c0:	17ffffef 	b	111c87c <tee_svc_copy_param.isra.0+0x21c>
			memset(&p->u[n], 0, sizeof(p->u[n]));
 111c8c4:	a9007e9f 	stp	xzr, xzr, [x20]
 111c8c8:	f9000a9f 	str	xzr, [x20, #16]
			break;
 111c8cc:	17ffffec 	b	111c87c <tee_svc_copy_param.isra.0+0x21c>
	if (called_sess && is_pseudo_ta_ctx(called_sess->ctx)) {
 111c8d0:	f9400b40 	ldr	x0, [x26, #16]
 111c8d4:	97ffebc9 	bl	11177f8 <is_pseudo_ta_ctx>
 111c8d8:	72001c1f 	tst	w0, #0xff
 111c8dc:	54ffeee0 	b.eq	111c6b8 <tee_svc_copy_param.isra.0+0x58>  // b.none
		return TEE_SUCCESS;
 111c8e0:	52800013 	mov	w19, #0x0                   	// #0
 111c8e4:	17ffffdd 	b	111c858 <tee_svc_copy_param.isra.0+0x1f8>
			if (vm_buf_is_inside_um_private(&utc->uctx, va, s)) {
 111c8e8:	aa1303e2 	mov	x2, x19
 111c8ec:	aa1b03e1 	mov	x1, x27
 111c8f0:	aa1803e0 	mov	x0, x24
 111c8f4:	97fff303 	bl	1119500 <vm_buf_is_inside_um_private>
 111c8f8:	72001c1f 	tst	w0, #0xff
 111c8fc:	54000120 	b.eq	111c920 <tee_svc_copy_param.isra.0+0x2c0>  // b.none
				s = ROUNDUP(s, sizeof(uint32_t));
 111c900:	91000e62 	add	x2, x19, #0x3
 111c904:	927ef453 	and	x19, x2, #0xfffffffffffffffc
				if (ADD_OVERFLOW(req_mem, s, &req_mem))
 111c908:	ab130353 	adds	x19, x26, x19
 111c90c:	aa1303fa 	mov	x26, x19
 111c910:	54fffa22 	b.cs	111c854 <tee_svc_copy_param.isra.0+0x1f4>  // b.hs, b.nlast
				ta_private_memref[n] = true;
 111c914:	52800020 	mov	w0, #0x1                   	// #1
 111c918:	383c6aa0 	strb	w0, [x21, x28]
				break;
 111c91c:	17ffff77 	b	111c6f8 <tee_svc_copy_param.isra.0+0x98>
			res = vm_buf_to_mboj_offs(&utc->uctx, va, s,
 111c920:	aa1303e2 	mov	x2, x19
 111c924:	aa1403e4 	mov	x4, x20
 111c928:	d1004283 	sub	x3, x20, #0x10
 111c92c:	aa1b03e1 	mov	x1, x27
 111c930:	aa1803e0 	mov	x0, x24
 111c934:	97fff30c 	bl	1119564 <vm_buf_to_mboj_offs>
 111c938:	2a0003f3 	mov	w19, w0
			if (res != TEE_SUCCESS)
 111c93c:	34ffede0 	cbz	w0, 111c6f8 <tee_svc_copy_param.isra.0+0x98>
 111c940:	17ffffc6 	b	111c858 <tee_svc_copy_param.isra.0+0x1f8>
			if (va) {
 111c944:	f9400a80 	ldr	x0, [x20, #16]
 111c948:	b4fff400 	cbz	x0, 111c7c8 <tee_svc_copy_param.isra.0+0x168>
				param->u[n].mem.offs = dst_offs;
 111c94c:	f9000a9c 	str	x28, [x20, #16]
				dst_offs += s;
 111c950:	8b03039c 	add	x28, x28, x3
				param->u[n].mem.mobj = *mobj_tmp;
 111c954:	f94002e0 	ldr	x0, [x23]
 111c958:	f9000280 	str	x0, [x20]
				tmp_buf_va[n] = dst;
 111c95c:	f94037e0 	ldr	x0, [sp, #104]
 111c960:	f83a781b 	str	x27, [x0, x26, lsl #3]
				dst += s;
 111c964:	8b03037b 	add	x27, x27, x3
				tmp_buf_size[n] = param->u[n].mem.size;
 111c968:	f9400680 	ldr	x0, [x20, #8]
 111c96c:	f83a7b20 	str	x0, [x25, x26, lsl #3]
				dst_offs += s;
 111c970:	17ffff96 	b	111c7c8 <tee_svc_copy_param.isra.0+0x168>
		return TEE_ERROR_GENERIC;
 111c974:	52bffff3 	mov	w19, #0xffff0000            	// #-65536
 111c978:	17ffffb8 	b	111c858 <tee_svc_copy_param.isra.0+0x1f8>

000000000111c97c <syscall_log>:
	if (len == 0)
 111c97c:	b4000361 	cbz	x1, 111c9e8 <syscall_log+0x6c>
{
 111c980:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 111c984:	910003fd 	mov	x29, sp
 111c988:	a90153f3 	stp	x19, x20, [sp, #16]
 111c98c:	aa0103f4 	mov	x20, x1
 111c990:	f90013f5 	str	x21, [sp, #32]
 111c994:	aa0003f5 	mov	x21, x0
	kbuf = malloc(len + 1);
 111c998:	91000420 	add	x0, x1, #0x1
 111c99c:	94009aaf 	bl	1143458 <malloc>
 111c9a0:	aa0003f3 	mov	x19, x0
	if (kbuf == NULL)
 111c9a4:	b40001a0 	cbz	x0, 111c9d8 <syscall_log+0x5c>
	if (copy_from_user(kbuf, buf, len) == TEE_SUCCESS) {
 111c9a8:	aa1403e2 	mov	x2, x20
 111c9ac:	aa1503e1 	mov	x1, x21
 111c9b0:	97ffe150 	bl	1114ef0 <copy_from_user>
 111c9b4:	35000080 	cbnz	w0, 111c9c4 <syscall_log+0x48>
		trace_ext_puts(kbuf);
 111c9b8:	aa1303e0 	mov	x0, x19
		kbuf[len] = '\0';
 111c9bc:	38346a7f 	strb	wzr, [x19, x20]
		trace_ext_puts(kbuf);
 111c9c0:	97ffacd2 	bl	1107d08 <trace_ext_puts>
	free_wipe(kbuf);
 111c9c4:	aa1303e0 	mov	x0, x19
}
 111c9c8:	a94153f3 	ldp	x19, x20, [sp, #16]
 111c9cc:	f94013f5 	ldr	x21, [sp, #32]
 111c9d0:	a8c37bfd 	ldp	x29, x30, [sp], #48
	free_wipe(kbuf);
 111c9d4:	14009b05 	b	11435e8 <free_wipe>
}
 111c9d8:	a94153f3 	ldp	x19, x20, [sp, #16]
 111c9dc:	f94013f5 	ldr	x21, [sp, #32]
 111c9e0:	a8c37bfd 	ldp	x29, x30, [sp], #48
 111c9e4:	d65f03c0 	ret
 111c9e8:	d65f03c0 	ret

000000000111c9ec <syscall_not_supported>:
}
 111c9ec:	129ffea0 	mov	w0, #0xffff000a            	// #-65526
 111c9f0:	d65f03c0 	ret

000000000111c9f4 <syscall_get_property>:
{
 111c9f4:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
 111c9f8:	910003fd 	mov	x29, sp
 111c9fc:	a90153f3 	stp	x19, x20, [sp, #16]
 111ca00:	aa0103f3 	mov	x19, x1
 111ca04:	aa0403f4 	mov	x20, x4
 111ca08:	a9025bf5 	stp	x21, x22, [sp, #32]
 111ca0c:	aa0203f6 	mov	x22, x2
 111ca10:	aa0303f5 	mov	x21, x3
 111ca14:	a90363f7 	stp	x23, x24, [sp, #48]
 111ca18:	aa0503f7 	mov	x23, x5
 111ca1c:	a9046bf9 	stp	x25, x26, [sp, #64]
 111ca20:	aa0003fa 	mov	x26, x0
 111ca24:	aa0603f9 	mov	x25, x6
	struct ts_session *sess = ts_get_current_session();
 111ca28:	97ffdfee 	bl	11149e0 <ts_get_current_session>
 111ca2c:	aa0003f8 	mov	x24, x0
	get_prop_set(prop_set, &props, &size, &vendor_props, &vendor_size);
 111ca30:	910183e1 	add	x1, sp, #0x60
 111ca34:	9101e3e4 	add	x4, sp, #0x78
 111ca38:	9101a3e3 	add	x3, sp, #0x68
 111ca3c:	9101c3e2 	add	x2, sp, #0x70
 111ca40:	aa1a03e0 	mov	x0, x26
	uint32_t elen = 0;
 111ca44:	290a7fff 	stp	wzr, wzr, [sp, #80]
	size_t klen_size = 0;
 111ca48:	f9002fff 	str	xzr, [sp, #88]
	get_prop_set(prop_set, &props, &size, &vendor_props, &vendor_size);
 111ca4c:	97fffe70 	bl	111c40c <get_prop_set>
	if (index < size)
 111ca50:	f9403be1 	ldr	x1, [sp, #112]
 111ca54:	eb01027f 	cmp	x19, x1
 111ca58:	54000442 	b.cs	111cae0 <syscall_get_property+0xec>  // b.hs, b.nlast
		return &(props[index]);
 111ca5c:	f94033e1 	ldr	x1, [sp, #96]
 111ca60:	d2800500 	mov	x0, #0x28                  	// #40
		return &(vendor_props[index]);
 111ca64:	9b000673 	madd	x19, x19, x0, x1
	if (!prop)
 111ca68:	b4000453 	cbz	x19, 111caf0 <syscall_get_property+0xfc>
	if (prop_type) {
 111ca6c:	b50004d9 	cbnz	x25, 111cb04 <syscall_get_property+0x110>
	if (buf && blen) {
 111ca70:	f100029f 	cmp	x20, #0x0
 111ca74:	fa401ae4 	ccmp	x23, #0x0, #0x4, ne  // ne = any
 111ca78:	540005c0 	b.eq	111cb30 <syscall_get_property+0x13c>  // b.none
		res = copy_from_user(&klen, blen, sizeof(klen));
 111ca7c:	910143f9 	add	x25, sp, #0x50
 111ca80:	aa1703e1 	mov	x1, x23
 111ca84:	aa1903e0 	mov	x0, x25
 111ca88:	d2800082 	mov	x2, #0x4                   	// #4
 111ca8c:	97ffe119 	bl	1114ef0 <copy_from_user>
		if (res != TEE_SUCCESS)
 111ca90:	35000440 	cbnz	w0, 111cb18 <syscall_get_property+0x124>
		if (prop->get_prop_func) {
 111ca94:	f9400a63 	ldr	x3, [x19, #16]
 111ca98:	b94053e0 	ldr	w0, [sp, #80]
 111ca9c:	b4000543 	cbz	x3, 111cb44 <syscall_get_property+0x150>
			klen_size = klen;
 111caa0:	f9002fe0 	str	x0, [sp, #88]
			res = prop->get_prop_func(sess, buf, &klen_size);
 111caa4:	aa1403e1 	mov	x1, x20
 111caa8:	910163e2 	add	x2, sp, #0x58
 111caac:	aa1803e0 	mov	x0, x24
 111cab0:	d63f0060 	blr	x3
 111cab4:	2a0003f4 	mov	w20, w0
			res2 = copy_to_user(blen, &klen, sizeof(*blen));
 111cab8:	aa1903e1 	mov	x1, x25
 111cabc:	d2800082 	mov	x2, #0x4                   	// #4
			klen = klen_size;
 111cac0:	f9402fe0 	ldr	x0, [sp, #88]
 111cac4:	b90053e0 	str	w0, [sp, #80]
			res2 = copy_to_user(blen, &prop->len, sizeof(*blen));
 111cac8:	aa1703e0 	mov	x0, x23
 111cacc:	97ffe11d 	bl	1114f40 <copy_to_user>
		if (res2 != TEE_SUCCESS)
 111cad0:	35000240 	cbnz	w0, 111cb18 <syscall_get_property+0x124>
		if (res != TEE_SUCCESS)
 111cad4:	340002f4 	cbz	w20, 111cb30 <syscall_get_property+0x13c>
 111cad8:	2a1403e0 	mov	w0, w20
 111cadc:	1400000f 	b	111cb18 <syscall_get_property+0x124>
	if (index < vendor_size)
 111cae0:	f9403fe0 	ldr	x0, [sp, #120]
	index -= size;
 111cae4:	cb010273 	sub	x19, x19, x1
	if (index < vendor_size)
 111cae8:	eb00027f 	cmp	x19, x0
 111caec:	54000063 	b.cc	111caf8 <syscall_get_property+0x104>  // b.lo, b.ul, b.last
		return TEE_ERROR_ITEM_NOT_FOUND;
 111caf0:	129ffee0 	mov	w0, #0xffff0008            	// #-65528
 111caf4:	14000009 	b	111cb18 <syscall_get_property+0x124>
		return &(vendor_props[index]);
 111caf8:	d2800500 	mov	x0, #0x28                  	// #40
 111cafc:	f94037e1 	ldr	x1, [sp, #104]
 111cb00:	17ffffd9 	b	111ca64 <syscall_get_property+0x70>
		res = copy_to_user(prop_type, &prop->prop_type,
 111cb04:	91002261 	add	x1, x19, #0x8
 111cb08:	aa1903e0 	mov	x0, x25
 111cb0c:	d2800082 	mov	x2, #0x4                   	// #4
 111cb10:	97ffe10c 	bl	1114f40 <copy_to_user>
		if (res != TEE_SUCCESS)
 111cb14:	34fffae0 	cbz	w0, 111ca70 <syscall_get_property+0x7c>
}
 111cb18:	a94153f3 	ldp	x19, x20, [sp, #16]
 111cb1c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 111cb20:	a94363f7 	ldp	x23, x24, [sp, #48]
 111cb24:	a9446bf9 	ldp	x25, x26, [sp, #64]
 111cb28:	a8c87bfd 	ldp	x29, x30, [sp], #128
 111cb2c:	d65f03c0 	ret
	if (name && name_len) {
 111cb30:	f10002df 	cmp	x22, #0x0
 111cb34:	fa401aa4 	ccmp	x21, #0x0, #0x4, ne  // ne = any
 111cb38:	540001e1 	b.ne	111cb74 <syscall_get_property+0x180>  // b.any
 111cb3c:	52800000 	mov	w0, #0x0                   	// #0
 111cb40:	17fffff6 	b	111cb18 <syscall_get_property+0x124>
			if (klen < prop->len)
 111cb44:	f9401262 	ldr	x2, [x19, #32]
 111cb48:	eb00005f 	cmp	x2, x0
 111cb4c:	54000108 	b.hi	111cb6c <syscall_get_property+0x178>  // b.pmore
				res = copy_to_user(buf, prop->data, prop->len);
 111cb50:	f9400e61 	ldr	x1, [x19, #24]
 111cb54:	aa1403e0 	mov	x0, x20
 111cb58:	97ffe0fa 	bl	1114f40 <copy_to_user>
 111cb5c:	2a0003f4 	mov	w20, w0
			res2 = copy_to_user(blen, &prop->len, sizeof(*blen));
 111cb60:	91008261 	add	x1, x19, #0x20
 111cb64:	d2800082 	mov	x2, #0x4                   	// #4
 111cb68:	17ffffd8 	b	111cac8 <syscall_get_property+0xd4>
				res = TEE_ERROR_SHORT_BUFFER;
 111cb6c:	129ffdf4 	mov	w20, #0xffff0010            	// #-65520
 111cb70:	17fffffc 	b	111cb60 <syscall_get_property+0x16c>
		res = copy_from_user(&klen, name_len, sizeof(klen));
 111cb74:	aa1503e1 	mov	x1, x21
 111cb78:	910143e0 	add	x0, sp, #0x50
 111cb7c:	d2800082 	mov	x2, #0x4                   	// #4
 111cb80:	97ffe0dc 	bl	1114ef0 <copy_from_user>
		if (res != TEE_SUCCESS)
 111cb84:	35fffca0 	cbnz	w0, 111cb18 <syscall_get_property+0x124>
		elen = strlen(prop->name) + 1;
 111cb88:	f9400273 	ldr	x19, [x19]
 111cb8c:	aa1303e0 	mov	x0, x19
 111cb90:	94009c64 	bl	1143d20 <strlen>
 111cb94:	11000402 	add	w2, w0, #0x1
		if (klen < elen)
 111cb98:	b94053e0 	ldr	w0, [sp, #80]
		elen = strlen(prop->name) + 1;
 111cb9c:	b90057e2 	str	w2, [sp, #84]
		if (klen < elen)
 111cba0:	6b00005f 	cmp	w2, w0
 111cba4:	54000188 	b.hi	111cbd4 <syscall_get_property+0x1e0>  // b.pmore
			res = copy_to_user(name, prop->name, elen);
 111cba8:	aa1303e1 	mov	x1, x19
 111cbac:	aa1603e0 	mov	x0, x22
 111cbb0:	97ffe0e4 	bl	1114f40 <copy_to_user>
 111cbb4:	2a0003f3 	mov	w19, w0
		res2 = copy_to_user(name_len, &elen, sizeof(*name_len));
 111cbb8:	910153e1 	add	x1, sp, #0x54
 111cbbc:	aa1503e0 	mov	x0, x21
 111cbc0:	d2800082 	mov	x2, #0x4                   	// #4
 111cbc4:	97ffe0df 	bl	1114f40 <copy_to_user>
		if (res2 != TEE_SUCCESS)
 111cbc8:	7100001f 	cmp	w0, #0x0
 111cbcc:	1a931000 	csel	w0, w0, w19, ne  // ne = any
 111cbd0:	17ffffd2 	b	111cb18 <syscall_get_property+0x124>
			res = TEE_ERROR_SHORT_BUFFER;
 111cbd4:	129ffdf3 	mov	w19, #0xffff0010            	// #-65520
 111cbd8:	17fffff8 	b	111cbb8 <syscall_get_property+0x1c4>

000000000111cbdc <syscall_get_property_name_to_index>:
{
 111cbdc:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
 111cbe0:	910003fd 	mov	x29, sp
	get_prop_set(prop_set, &props, &size, &vendor_props, &vendor_size);
 111cbe4:	9101e3e4 	add	x4, sp, #0x78
{
 111cbe8:	a90153f3 	stp	x19, x20, [sp, #16]
 111cbec:	aa0103f3 	mov	x19, x1
	get_prop_set(prop_set, &props, &size, &vendor_props, &vendor_size);
 111cbf0:	910183e1 	add	x1, sp, #0x60
{
 111cbf4:	a9025bf5 	stp	x21, x22, [sp, #32]
 111cbf8:	aa0203f5 	mov	x21, x2
 111cbfc:	aa0303f6 	mov	x22, x3
	get_prop_set(prop_set, &props, &size, &vendor_props, &vendor_size);
 111cc00:	9101a3e2 	add	x2, sp, #0x68
 111cc04:	9101c3e3 	add	x3, sp, #0x70
{
 111cc08:	a90363f7 	stp	x23, x24, [sp, #48]
 111cc0c:	f90023f9 	str	x25, [sp, #64]
	uint32_t i = 0;
 111cc10:	b9005fff 	str	wzr, [sp, #92]
	size_t size = 0;
 111cc14:	a9067fff 	stp	xzr, xzr, [sp, #96]
	size_t vendor_size = 0;
 111cc18:	a9077fff 	stp	xzr, xzr, [sp, #112]
	get_prop_set(prop_set, &props, &size, &vendor_props, &vendor_size);
 111cc1c:	97fffdfc 	bl	111c40c <get_prop_set>
	if (!props)
 111cc20:	f94033e0 	ldr	x0, [sp, #96]
 111cc24:	b4000820 	cbz	x0, 111cd28 <syscall_get_property_name_to_index+0x14c>
	if (!name || !name_len) {
 111cc28:	f100027f 	cmp	x19, #0x0
 111cc2c:	fa401aa4 	ccmp	x21, #0x0, #0x4, ne  // ne = any
 111cc30:	54000760 	b.eq	111cd1c <syscall_get_property_name_to_index+0x140>  // b.none
	kname = malloc(name_len);
 111cc34:	aa1503e0 	mov	x0, x21
 111cc38:	94009a08 	bl	1143458 <malloc>
 111cc3c:	aa0003f4 	mov	x20, x0
	if (!kname)
 111cc40:	b4000780 	cbz	x0, 111cd30 <syscall_get_property_name_to_index+0x154>
	res = copy_from_user(kname, name, name_len);
 111cc44:	aa1303e1 	mov	x1, x19
 111cc48:	aa1503e2 	mov	x2, x21
 111cc4c:	97ffe0a9 	bl	1114ef0 <copy_from_user>
 111cc50:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 111cc54:	350003a0 	cbnz	w0, 111ccc8 <syscall_get_property_name_to_index+0xec>
	kname[name_len - 1] = 0;
 111cc58:	8b150295 	add	x21, x20, x21
		if (!strcmp(kname, props[i].name)) {
 111cc5c:	52800518 	mov	w24, #0x28                  	// #40
	for (i = 0; i < size; i++) {
 111cc60:	b9005fff 	str	wzr, [sp, #92]
	kname[name_len - 1] = 0;
 111cc64:	381ff2bf 	sturb	wzr, [x21, #-1]
	for (i = 0; i < size; i++) {
 111cc68:	a94657f7 	ldp	x23, x21, [sp, #96]
 111cc6c:	b9405ff3 	ldr	w19, [sp, #92]
 111cc70:	eb3342bf 	cmp	x21, w19, uxtw
 111cc74:	54000168 	b.hi	111cca0 <syscall_get_property_name_to_index+0xc4>  // b.pmore
	for (i = size; i < size + vendor_size; i++) {
 111cc78:	a9475ff8 	ldp	x24, x23, [sp, #112]
		if (!strcmp(kname, vendor_props[i - size].name)) {
 111cc7c:	d2800519 	mov	x25, #0x28                  	// #40
	for (i = size; i < size + vendor_size; i++) {
 111cc80:	b9005ff5 	str	w21, [sp, #92]
 111cc84:	8b1702b7 	add	x23, x21, x23
 111cc88:	b9405ff3 	ldr	w19, [sp, #92]
 111cc8c:	2a1303e0 	mov	w0, w19
 111cc90:	eb3342ff 	cmp	x23, w19, uxtw
 111cc94:	54000328 	b.hi	111ccf8 <syscall_get_property_name_to_index+0x11c>  // b.pmore
	res = TEE_ERROR_ITEM_NOT_FOUND;
 111cc98:	129ffef3 	mov	w19, #0xffff0008            	// #-65528
out:
 111cc9c:	1400000b 	b	111ccc8 <syscall_get_property_name_to_index+0xec>
		if (!strcmp(kname, props[i].name)) {
 111cca0:	9bb87e60 	umull	x0, w19, w24
 111cca4:	f8606ae1 	ldr	x1, [x23, x0]
 111cca8:	aa1403e0 	mov	x0, x20
 111ccac:	94009c14 	bl	1143cfc <strcmp>
 111ccb0:	350001e0 	cbnz	w0, 111ccec <syscall_get_property_name_to_index+0x110>
			res = copy_to_user(index, &i, sizeof(*index));
 111ccb4:	910173e1 	add	x1, sp, #0x5c
 111ccb8:	aa1603e0 	mov	x0, x22
 111ccbc:	d2800082 	mov	x2, #0x4                   	// #4
 111ccc0:	97ffe0a0 	bl	1114f40 <copy_to_user>
 111ccc4:	2a0003f3 	mov	w19, w0
	free_wipe(kname);
 111ccc8:	aa1403e0 	mov	x0, x20
 111cccc:	94009a47 	bl	11435e8 <free_wipe>
}
 111ccd0:	2a1303e0 	mov	w0, w19
 111ccd4:	a94153f3 	ldp	x19, x20, [sp, #16]
 111ccd8:	a9425bf5 	ldp	x21, x22, [sp, #32]
 111ccdc:	a94363f7 	ldp	x23, x24, [sp, #48]
 111cce0:	f94023f9 	ldr	x25, [sp, #64]
 111cce4:	a8c87bfd 	ldp	x29, x30, [sp], #128
 111cce8:	d65f03c0 	ret
	for (i = 0; i < size; i++) {
 111ccec:	11000673 	add	w19, w19, #0x1
 111ccf0:	b9005ff3 	str	w19, [sp, #92]
 111ccf4:	17ffffde 	b	111cc6c <syscall_get_property_name_to_index+0x90>
		if (!strcmp(kname, vendor_props[i - size].name)) {
 111ccf8:	cb150000 	sub	x0, x0, x21
 111ccfc:	9b197c00 	mul	x0, x0, x25
 111cd00:	f8606b01 	ldr	x1, [x24, x0]
 111cd04:	aa1403e0 	mov	x0, x20
 111cd08:	94009bfd 	bl	1143cfc <strcmp>
 111cd0c:	34fffd40 	cbz	w0, 111ccb4 <syscall_get_property_name_to_index+0xd8>
	for (i = size; i < size + vendor_size; i++) {
 111cd10:	11000673 	add	w19, w19, #0x1
 111cd14:	b9005ff3 	str	w19, [sp, #92]
 111cd18:	17ffffdc 	b	111cc88 <syscall_get_property_name_to_index+0xac>
	char *kname = NULL;
 111cd1c:	d2800014 	mov	x20, #0x0                   	// #0
		res = TEE_ERROR_BAD_PARAMETERS;
 111cd20:	129fff33 	mov	w19, #0xffff0006            	// #-65530
 111cd24:	17ffffe9 	b	111ccc8 <syscall_get_property_name_to_index+0xec>
		return TEE_ERROR_ITEM_NOT_FOUND;
 111cd28:	129ffef3 	mov	w19, #0xffff0008            	// #-65528
 111cd2c:	17ffffe9 	b	111ccd0 <syscall_get_property_name_to_index+0xf4>
		return TEE_ERROR_OUT_OF_MEMORY;
 111cd30:	129ffe73 	mov	w19, #0xffff000c            	// #-65524
 111cd34:	17ffffe7 	b	111ccd0 <syscall_get_property_name_to_index+0xf4>

000000000111cd38 <syscall_open_ta_session>:
/* Called when a TA calls an OpenSession on another TA */
TEE_Result syscall_open_ta_session(const TEE_UUID *dest,
			unsigned long cancel_req_to,
			struct utee_params *usr_param, uint32_t *ta_sess,
			uint32_t *ret_orig)
{
 111cd38:	a9b27bfd 	stp	x29, x30, [sp, #-224]!
 111cd3c:	910003fd 	mov	x29, sp
 111cd40:	a90153f3 	stp	x19, x20, [sp, #16]
 111cd44:	a9025bf5 	stp	x21, x22, [sp, #32]
 111cd48:	a90363f7 	stp	x23, x24, [sp, #48]
 111cd4c:	aa0203f7 	mov	x23, x2
 111cd50:	a9046bf9 	stp	x25, x26, [sp, #64]
 111cd54:	a90573fb 	stp	x27, x28, [sp, #80]
 111cd58:	aa0003fc 	mov	x28, x0
 111cd5c:	a9068fe1 	stp	x1, x3, [sp, #104]
 111cd60:	f9003fe4 	str	x4, [sp, #120]
	struct ts_session *sess = ts_get_current_session();
 111cd64:	97ffdf1f 	bl	11149e0 <ts_get_current_session>
 111cd68:	aa0003f6 	mov	x22, x0
	struct user_ta_ctx *utc = to_user_ta_ctx(sess->ctx);
 111cd6c:	f9400800 	ldr	x0, [x0, #16]
 111cd70:	97fffe07 	bl	111c58c <to_user_ta_ctx>
 111cd74:	aa0003f8 	mov	x24, x0
	TEE_Result res = TEE_SUCCESS;
	uint32_t ret_o = TEE_ORIGIN_TEE;
 111cd78:	52800060 	mov	w0, #0x3                   	// #3
 111cd7c:	b9008fe0 	str	w0, [sp, #140]
	struct tee_ta_session *s = NULL;
	struct mobj *mobj_param = NULL;
	TEE_UUID *uuid = malloc(sizeof(TEE_UUID));
 111cd80:	d2800200 	mov	x0, #0x10                  	// #16
	struct mobj *mobj_param = NULL;
 111cd84:	a9097fff 	stp	xzr, xzr, [sp, #144]
	TEE_UUID *uuid = malloc(sizeof(TEE_UUID));
 111cd88:	940099b4 	bl	1143458 <malloc>
 111cd8c:	aa0003f5 	mov	x21, x0
	struct tee_ta_param *param = malloc(sizeof(struct tee_ta_param));
 111cd90:	d2800d00 	mov	x0, #0x68                  	// #104
 111cd94:	940099b1 	bl	1143458 <malloc>
 111cd98:	aa0003f3 	mov	x19, x0
	TEE_Identity *clnt_id = malloc(sizeof(TEE_Identity));
 111cd9c:	d2800280 	mov	x0, #0x14                  	// #20
 111cda0:	940099ae 	bl	1143458 <malloc>
	void *tmp_buf_va[TEE_NUM_PARAMS] = { NULL };
 111cda4:	a90a7fff 	stp	xzr, xzr, [sp, #160]
	size_t tmp_buf_size[TEE_NUM_PARAMS] = { 0 };

	if (uuid == NULL || param == NULL || clnt_id == NULL) {
 111cda8:	f10002bf 	cmp	x21, #0x0
	TEE_Identity *clnt_id = malloc(sizeof(TEE_Identity));
 111cdac:	aa0003f4 	mov	x20, x0
	void *tmp_buf_va[TEE_NUM_PARAMS] = { NULL };
 111cdb0:	a90b7fff 	stp	xzr, xzr, [sp, #176]
	if (uuid == NULL || param == NULL || clnt_id == NULL) {
 111cdb4:	fa401a64 	ccmp	x19, #0x0, #0x4, ne  // ne = any
	size_t tmp_buf_size[TEE_NUM_PARAMS] = { 0 };
 111cdb8:	a90c7fff 	stp	xzr, xzr, [sp, #192]
 111cdbc:	a90d7fff 	stp	xzr, xzr, [sp, #208]
	if (uuid == NULL || param == NULL || clnt_id == NULL) {
 111cdc0:	540009c0 	b.eq	111cef8 <syscall_open_ta_session+0x1c0>  // b.none
 111cdc4:	b40009a0 	cbz	x0, 111cef8 <syscall_open_ta_session+0x1c0>
		goto out_free_only;
	}

	memset(param, 0, sizeof(struct tee_ta_param));

	res = copy_from_user_private(uuid, dest, sizeof(TEE_UUID));
 111cdc8:	aa1c03e1 	mov	x1, x28
 111cdcc:	aa1503e0 	mov	x0, x21
 111cdd0:	d2800202 	mov	x2, #0x10                  	// #16
 111cdd4:	910233fc 	add	x28, sp, #0x8c
	memset(param, 0, sizeof(struct tee_ta_param));
 111cdd8:	a9007e7f 	stp	xzr, xzr, [x19]
 111cddc:	a9017e7f 	stp	xzr, xzr, [x19, #16]
 111cde0:	a9027e7f 	stp	xzr, xzr, [x19, #32]
 111cde4:	a9037e7f 	stp	xzr, xzr, [x19, #48]
 111cde8:	a9047e7f 	stp	xzr, xzr, [x19, #64]
 111cdec:	a9057e7f 	stp	xzr, xzr, [x19, #80]
 111cdf0:	f900327f 	str	xzr, [x19, #96]
	res = copy_from_user_private(uuid, dest, sizeof(TEE_UUID));
 111cdf4:	97ffe068 	bl	1114f94 <copy_from_user_private>
 111cdf8:	2a0003fb 	mov	w27, w0
	if (res != TEE_SUCCESS)
 111cdfc:	350004a0 	cbnz	w0, 111ce90 <syscall_open_ta_session+0x158>
		goto function_exit;

	clnt_id->login = TEE_LOGIN_TRUSTED_APP;
 111ce00:	aa1403e0 	mov	x0, x20
 111ce04:	52be0001 	mov	w1, #0xf0000000            	// #-268435456
	memcpy(&clnt_id->uuid, &sess->ctx->uuid, sizeof(TEE_UUID));
 111ce08:	d2800202 	mov	x2, #0x10                  	// #16

	res = tee_svc_copy_param(sess, NULL, usr_param, param, tmp_buf_va,
 111ce0c:	910303fa 	add	x26, sp, #0xc0
 111ce10:	910283f9 	add	x25, sp, #0xa0
	clnt_id->login = TEE_LOGIN_TRUSTED_APP;
 111ce14:	b8004401 	str	w1, [x0], #4
	memcpy(&clnt_id->uuid, &sess->ctx->uuid, sizeof(TEE_UUID));
 111ce18:	f9400ac1 	ldr	x1, [x22, #16]
 111ce1c:	97ff995d 	bl	1103390 <memcpy>
	res = tee_svc_copy_param(sess, NULL, usr_param, param, tmp_buf_va,
 111ce20:	f9400ac0 	ldr	x0, [x22, #16]
 111ce24:	910263e6 	add	x6, sp, #0x98
 111ce28:	aa1a03e5 	mov	x5, x26
 111ce2c:	aa1903e4 	mov	x4, x25
 111ce30:	aa1303e3 	mov	x3, x19
 111ce34:	aa1703e2 	mov	x2, x23
 111ce38:	d2800001 	mov	x1, #0x0                   	// #0
 111ce3c:	97fffe09 	bl	111c660 <tee_svc_copy_param.isra.0>
 111ce40:	2a0003fb 	mov	w27, w0
				 tmp_buf_size, &mobj_param);
	if (res != TEE_SUCCESS)
 111ce44:	35000260 	cbnz	w0, 111ce90 <syscall_open_ta_session+0x158>
		goto function_exit;

	res = tee_ta_open_session(&ret_o, &s, &utc->open_sessions, uuid,
 111ce48:	b9406be5 	ldr	w5, [sp, #104]
 111ce4c:	aa1303e6 	mov	x6, x19
 111ce50:	aa1403e4 	mov	x4, x20
 111ce54:	aa1503e3 	mov	x3, x21
 111ce58:	aa1803e2 	mov	x2, x24
 111ce5c:	910243e1 	add	x1, sp, #0x90
 111ce60:	aa1c03e0 	mov	x0, x28
 111ce64:	97ffdced 	bl	1114218 <tee_ta_open_session>
 111ce68:	2a0003fb 	mov	w27, w0
				  clnt_id, cancel_req_to, param);
	vm_set_ctx(&utc->ta_ctx.ts_ctx);
 111ce6c:	910ba300 	add	x0, x24, #0x2e8
 111ce70:	97fff29b 	bl	11198dc <vm_set_ctx>
	if (res != TEE_SUCCESS)
 111ce74:	350000fb 	cbnz	w27, 111ce90 <syscall_open_ta_session+0x158>
		goto function_exit;

	res = tee_svc_update_out_param(param, tmp_buf_va, tmp_buf_size,
 111ce78:	aa1703e3 	mov	x3, x23
 111ce7c:	aa1a03e2 	mov	x2, x26
 111ce80:	aa1903e1 	mov	x1, x25
 111ce84:	aa1303e0 	mov	x0, x19
 111ce88:	97fffcf7 	bl	111c264 <tee_svc_update_out_param>
 111ce8c:	2a0003fb 	mov	w27, w0
				       usr_param);

function_exit:
	mobj_put_wipe(mobj_param);
 111ce90:	f9404fe0 	ldr	x0, [sp, #152]
 111ce94:	97fffddc 	bl	111c604 <mobj_put_wipe>
	if (res == TEE_SUCCESS)
 111ce98:	350000db 	cbnz	w27, 111ceb0 <syscall_open_ta_session+0x178>
		copy_to_user_private(ta_sess, &s->id, sizeof(s->id));
 111ce9c:	f9403be0 	ldr	x0, [sp, #112]
 111cea0:	d2800082 	mov	x2, #0x4                   	// #4
 111cea4:	f9404be1 	ldr	x1, [sp, #144]
 111cea8:	9100e021 	add	x1, x1, #0x38
 111ceac:	97ffe04e 	bl	1114fe4 <copy_to_user_private>
	copy_to_user_private(ret_orig, &ret_o, sizeof(ret_o));
 111ceb0:	f9403fe0 	ldr	x0, [sp, #120]
 111ceb4:	aa1c03e1 	mov	x1, x28
 111ceb8:	d2800082 	mov	x2, #0x4                   	// #4
 111cebc:	97ffe04a 	bl	1114fe4 <copy_to_user_private>

out_free_only:
	free_wipe(param);
 111cec0:	aa1303e0 	mov	x0, x19
 111cec4:	940099c9 	bl	11435e8 <free_wipe>
	free_wipe(uuid);
 111cec8:	aa1503e0 	mov	x0, x21
 111cecc:	940099c7 	bl	11435e8 <free_wipe>
	free_wipe(clnt_id);
 111ced0:	aa1403e0 	mov	x0, x20
 111ced4:	940099c5 	bl	11435e8 <free_wipe>
	return res;
}
 111ced8:	2a1b03e0 	mov	w0, w27
 111cedc:	a94153f3 	ldp	x19, x20, [sp, #16]
 111cee0:	a9425bf5 	ldp	x21, x22, [sp, #32]
 111cee4:	a94363f7 	ldp	x23, x24, [sp, #48]
 111cee8:	a9446bf9 	ldp	x25, x26, [sp, #64]
 111ceec:	a94573fb 	ldp	x27, x28, [sp, #80]
 111cef0:	a8ce7bfd 	ldp	x29, x30, [sp], #224
 111cef4:	d65f03c0 	ret
		res = TEE_ERROR_OUT_OF_MEMORY;
 111cef8:	129ffe7b 	mov	w27, #0xffff000c            	// #-65524
 111cefc:	17fffff1 	b	111cec0 <syscall_open_ta_session+0x188>

000000000111cf00 <syscall_close_ta_session>:

TEE_Result syscall_close_ta_session(unsigned long ta_sess)
{
 111cf00:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 111cf04:	910003fd 	mov	x29, sp
 111cf08:	a90153f3 	stp	x19, x20, [sp, #16]
 111cf0c:	aa0003f4 	mov	x20, x0
 111cf10:	a9025bf5 	stp	x21, x22, [sp, #32]
	struct ts_session *sess = ts_get_current_session();
 111cf14:	97ffdeb3 	bl	11149e0 <ts_get_current_session>
 111cf18:	aa0003f5 	mov	x21, x0
	struct user_ta_ctx *utc = to_user_ta_ctx(sess->ctx);
 111cf1c:	f9400800 	ldr	x0, [x0, #16]
 111cf20:	97fffd9b 	bl	111c58c <to_user_ta_ctx>
 111cf24:	aa0003f3 	mov	x19, x0
	TEE_Identity clnt_id = { };
	struct tee_ta_session *s = NULL;

	s = tee_ta_find_session(ta_sess, &utc->open_sessions);
 111cf28:	aa0003e1 	mov	x1, x0
 111cf2c:	2a1403e0 	mov	w0, w20
	TEE_Identity clnt_id = { };
 111cf30:	a903ffff 	stp	xzr, xzr, [sp, #56]

	clnt_id.login = TEE_LOGIN_TRUSTED_APP;
	memcpy(&clnt_id.uuid, &sess->ctx->uuid, sizeof(TEE_UUID));
 111cf34:	9100e3f4 	add	x20, sp, #0x38
	TEE_Identity clnt_id = { };
 111cf38:	b9004bff 	str	wzr, [sp, #72]
	s = tee_ta_find_session(ta_sess, &utc->open_sessions);
 111cf3c:	97ffdb6c 	bl	1113cec <tee_ta_find_session>
	memcpy(&clnt_id.uuid, &sess->ctx->uuid, sizeof(TEE_UUID));
 111cf40:	f9400aa1 	ldr	x1, [x21, #16]
	s = tee_ta_find_session(ta_sess, &utc->open_sessions);
 111cf44:	aa0003f6 	mov	x22, x0
	clnt_id.login = TEE_LOGIN_TRUSTED_APP;
 111cf48:	52be0000 	mov	w0, #0xf0000000            	// #-268435456
	memcpy(&clnt_id.uuid, &sess->ctx->uuid, sizeof(TEE_UUID));
 111cf4c:	d2800202 	mov	x2, #0x10                  	// #16
	clnt_id.login = TEE_LOGIN_TRUSTED_APP;
 111cf50:	b9003be0 	str	w0, [sp, #56]
	memcpy(&clnt_id.uuid, &sess->ctx->uuid, sizeof(TEE_UUID));
 111cf54:	9100f3e0 	add	x0, sp, #0x3c
 111cf58:	97ff990e 	bl	1103390 <memcpy>

	return tee_ta_close_session(s, &utc->open_sessions, &clnt_id);
 111cf5c:	aa1403e2 	mov	x2, x20
 111cf60:	aa1303e1 	mov	x1, x19
 111cf64:	aa1603e0 	mov	x0, x22
 111cf68:	97ffdc2b 	bl	1114014 <tee_ta_close_session>
}
 111cf6c:	a94153f3 	ldp	x19, x20, [sp, #16]
 111cf70:	a9425bf5 	ldp	x21, x22, [sp, #32]
 111cf74:	a8c57bfd 	ldp	x29, x30, [sp], #80
 111cf78:	d65f03c0 	ret

000000000111cf7c <syscall_invoke_ta_command>:

TEE_Result syscall_invoke_ta_command(unsigned long ta_sess,
			unsigned long cancel_req_to, unsigned long cmd_id,
			struct utee_params *usr_param, uint32_t *ret_orig)
{
 111cf7c:	a9ac7bfd 	stp	x29, x30, [sp, #-320]!
 111cf80:	910003fd 	mov	x29, sp
 111cf84:	a90153f3 	stp	x19, x20, [sp, #16]
 111cf88:	aa0003f4 	mov	x20, x0
 111cf8c:	a9025bf5 	stp	x21, x22, [sp, #32]
 111cf90:	aa0303f5 	mov	x21, x3
 111cf94:	aa0403f6 	mov	x22, x4
 111cf98:	a90363f7 	stp	x23, x24, [sp, #48]
	struct ts_session *sess = ts_get_current_session();
	struct user_ta_ctx *utc = to_user_ta_ctx(sess->ctx);
	TEE_Result res = TEE_SUCCESS;
	TEE_Result res2 = TEE_SUCCESS;
	uint32_t ret_o = TEE_ORIGIN_TEE;
 111cf9c:	52800078 	mov	w24, #0x3                   	// #3
{
 111cfa0:	a9046bf9 	stp	x25, x26, [sp, #64]
 111cfa4:	aa0203f9 	mov	x25, x2
 111cfa8:	a90573fb 	stp	x27, x28, [sp, #80]
	struct tee_ta_param param = { 0 };
 111cfac:	910363fb 	add	x27, sp, #0xd8
{
 111cfb0:	f90033e1 	str	x1, [sp, #96]
	struct ts_session *sess = ts_get_current_session();
 111cfb4:	97ffde8b 	bl	11149e0 <ts_get_current_session>
 111cfb8:	aa0003f3 	mov	x19, x0
	struct user_ta_ctx *utc = to_user_ta_ctx(sess->ctx);
 111cfbc:	f9400800 	ldr	x0, [x0, #16]
 111cfc0:	97fffd73 	bl	111c58c <to_user_ta_ctx>
 111cfc4:	aa0003fa 	mov	x26, x0
	struct tee_ta_param param = { 0 };
 111cfc8:	d2800d02 	mov	x2, #0x68                  	// #104
 111cfcc:	52800001 	mov	w1, #0x0                   	// #0
 111cfd0:	aa1b03e0 	mov	x0, x27
	uint32_t ret_o = TEE_ORIGIN_TEE;
 111cfd4:	b90077f8 	str	w24, [sp, #116]
	struct tee_ta_param param = { 0 };
 111cfd8:	94009b42 	bl	1143ce0 <memset>
	TEE_Identity clnt_id = { };
	struct tee_ta_session *called_sess = NULL;
	struct mobj *mobj_param = NULL;
 111cfdc:	f9003fff 	str	xzr, [sp, #120]
	void *tmp_buf_va[TEE_NUM_PARAMS] = { NULL };
	size_t tmp_buf_size[TEE_NUM_PARAMS] = { };

	called_sess = tee_ta_get_session((uint32_t)ta_sess, true,
 111cfe0:	aa1a03e2 	mov	x2, x26
 111cfe4:	2a1403e0 	mov	w0, w20
 111cfe8:	52800021 	mov	w1, #0x1                   	// #1
	TEE_Identity clnt_id = { };
 111cfec:	a9087fff 	stp	xzr, xzr, [sp, #128]
 111cff0:	b90093ff 	str	wzr, [sp, #144]
	void *tmp_buf_va[TEE_NUM_PARAMS] = { NULL };
 111cff4:	a909ffff 	stp	xzr, xzr, [sp, #152]
 111cff8:	a90affff 	stp	xzr, xzr, [sp, #168]
	size_t tmp_buf_size[TEE_NUM_PARAMS] = { };
 111cffc:	a90bffff 	stp	xzr, xzr, [sp, #184]
 111d000:	a90cffff 	stp	xzr, xzr, [sp, #200]
	called_sess = tee_ta_get_session((uint32_t)ta_sess, true,
 111d004:	97ffdb4f 	bl	1113d40 <tee_ta_get_session>
				&utc->open_sessions);
	if (!called_sess)
 111d008:	b4000760 	cbz	x0, 111d0f4 <syscall_invoke_ta_command+0x178>
		return TEE_ERROR_BAD_PARAMETERS;

	clnt_id.login = TEE_LOGIN_TRUSTED_APP;
	memcpy(&clnt_id.uuid, &sess->ctx->uuid, sizeof(TEE_UUID));
 111d00c:	f9400a61 	ldr	x1, [x19, #16]
 111d010:	910203e8 	add	x8, sp, #0x80
 111d014:	aa0003f4 	mov	x20, x0
	clnt_id.login = TEE_LOGIN_TRUSTED_APP;
 111d018:	52be0000 	mov	w0, #0xf0000000            	// #-268435456
	memcpy(&clnt_id.uuid, &sess->ctx->uuid, sizeof(TEE_UUID));
 111d01c:	d2800202 	mov	x2, #0x10                  	// #16
 111d020:	f90037e8 	str	x8, [sp, #104]
	clnt_id.login = TEE_LOGIN_TRUSTED_APP;
 111d024:	b90083e0 	str	w0, [sp, #128]
	memcpy(&clnt_id.uuid, &sess->ctx->uuid, sizeof(TEE_UUID));
 111d028:	910213e0 	add	x0, sp, #0x84
 111d02c:	97ff98d9 	bl	1103390 <memcpy>

	res = tee_svc_copy_param(sess, &called_sess->ts_sess, usr_param, &param,
 111d030:	9102e3f7 	add	x23, sp, #0xb8
 111d034:	f9400a60 	ldr	x0, [x19, #16]
 111d038:	910263fc 	add	x28, sp, #0x98
 111d03c:	9101e3e6 	add	x6, sp, #0x78
 111d040:	aa1703e5 	mov	x5, x23
 111d044:	aa1c03e4 	mov	x4, x28
 111d048:	aa1b03e3 	mov	x3, x27
 111d04c:	aa1503e2 	mov	x2, x21
 111d050:	91004281 	add	x1, x20, #0x10
 111d054:	9101d3fa 	add	x26, sp, #0x74
 111d058:	97fffd82 	bl	111c660 <tee_svc_copy_param.isra.0>
 111d05c:	2a0003f3 	mov	w19, w0
				 tmp_buf_va, tmp_buf_size, &mobj_param);
	if (res != TEE_SUCCESS)
 111d060:	350002a0 	cbnz	w0, 111d0b4 <syscall_invoke_ta_command+0x138>
		goto function_exit;

	res = tee_ta_invoke_command(&ret_o, called_sess, &clnt_id,
 111d064:	b94063e3 	ldr	w3, [sp, #96]
 111d068:	aa1b03e5 	mov	x5, x27
 111d06c:	f94037e8 	ldr	x8, [sp, #104]
 111d070:	2a1903e4 	mov	w4, w25
 111d074:	aa1403e1 	mov	x1, x20
 111d078:	aa1a03e0 	mov	x0, x26
 111d07c:	aa0803e2 	mov	x2, x8
 111d080:	97ffddbe 	bl	1114778 <tee_ta_invoke_command>
 111d084:	2a0003f3 	mov	w19, w0
				    cancel_req_to, cmd_id, &param);
	if (res == TEE_ERROR_TARGET_DEAD)
 111d088:	1299fb60 	mov	w0, #0xffff3024            	// #-53212
 111d08c:	6b00027f 	cmp	w19, w0
 111d090:	54000120 	b.eq	111d0b4 <syscall_invoke_ta_command+0x138>  // b.none
		goto function_exit;

	res2 = tee_svc_update_out_param(&param, tmp_buf_va, tmp_buf_size,
 111d094:	aa1503e3 	mov	x3, x21
 111d098:	aa1703e2 	mov	x2, x23
 111d09c:	aa1c03e1 	mov	x1, x28
 111d0a0:	aa1b03e0 	mov	x0, x27
 111d0a4:	97fffc70 	bl	111c264 <tee_svc_update_out_param>
					usr_param);
	if (res2 != TEE_SUCCESS) {
 111d0a8:	34000060 	cbz	w0, 111d0b4 <syscall_invoke_ta_command+0x138>
		 *
		 * But if we can't update params to the caller we have no
		 * choice we need to return some error to indicate that
		 * parameters aren't updated as expected.
		 */
		ret_o = TEE_ORIGIN_TEE;
 111d0ac:	2a0003f3 	mov	w19, w0
 111d0b0:	b90077f8 	str	w24, [sp, #116]
		res = res2;
	}

function_exit:
	tee_ta_put_session(called_sess);
 111d0b4:	aa1403e0 	mov	x0, x20
 111d0b8:	97ffdaf6 	bl	1113c90 <tee_ta_put_session>
	mobj_put_wipe(mobj_param);
 111d0bc:	f9403fe0 	ldr	x0, [sp, #120]
 111d0c0:	97fffd51 	bl	111c604 <mobj_put_wipe>
	copy_to_user_private(ret_orig, &ret_o, sizeof(ret_o));
 111d0c4:	aa1a03e1 	mov	x1, x26
 111d0c8:	aa1603e0 	mov	x0, x22
 111d0cc:	d2800082 	mov	x2, #0x4                   	// #4
 111d0d0:	97ffdfc5 	bl	1114fe4 <copy_to_user_private>
	return res;
}
 111d0d4:	2a1303e0 	mov	w0, w19
 111d0d8:	a94153f3 	ldp	x19, x20, [sp, #16]
 111d0dc:	a9425bf5 	ldp	x21, x22, [sp, #32]
 111d0e0:	a94363f7 	ldp	x23, x24, [sp, #48]
 111d0e4:	a9446bf9 	ldp	x25, x26, [sp, #64]
 111d0e8:	a94573fb 	ldp	x27, x28, [sp, #80]
 111d0ec:	a8d47bfd 	ldp	x29, x30, [sp], #320
 111d0f0:	d65f03c0 	ret
		return TEE_ERROR_BAD_PARAMETERS;
 111d0f4:	129fff33 	mov	w19, #0xffff0006            	// #-65530
 111d0f8:	17fffff7 	b	111d0d4 <syscall_invoke_ta_command+0x158>

000000000111d0fc <syscall_check_access_rights>:

TEE_Result syscall_check_access_rights(unsigned long flags, const void *buf,
				       size_t len)
{
 111d0fc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 111d100:	910003fd 	mov	x29, sp
 111d104:	a90153f3 	stp	x19, x20, [sp, #16]
 111d108:	aa0103f4 	mov	x20, x1
 111d10c:	aa0003f3 	mov	x19, x0
 111d110:	f90013f5 	str	x21, [sp, #32]
 111d114:	aa0203f5 	mov	x21, x2
	struct ts_session *s = ts_get_current_session();
 111d118:	97ffde32 	bl	11149e0 <ts_get_current_session>

	return vm_check_access_rights(&to_user_ta_ctx(s->ctx)->uctx, flags,
 111d11c:	f9400800 	ldr	x0, [x0, #16]
 111d120:	97fffd1b 	bl	111c58c <to_user_ta_ctx>
 111d124:	91014000 	add	x0, x0, #0x50
 111d128:	aa1503e3 	mov	x3, x21
 111d12c:	aa1403e2 	mov	x2, x20
 111d130:	2a1303e1 	mov	w1, w19
				      (uaddr_t)buf, len);
}
 111d134:	a94153f3 	ldp	x19, x20, [sp, #16]
 111d138:	f94013f5 	ldr	x21, [sp, #32]
 111d13c:	a8c37bfd 	ldp	x29, x30, [sp], #48
	return vm_check_access_rights(&to_user_ta_ctx(s->ctx)->uctx, flags,
 111d140:	17fff1ab 	b	11197ec <vm_check_access_rights>

000000000111d144 <syscall_get_cancellation_flag>:

TEE_Result syscall_get_cancellation_flag(uint32_t *cancel)
{
 111d144:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 111d148:	910003fd 	mov	x29, sp
 111d14c:	f9000bf3 	str	x19, [sp, #16]
 111d150:	aa0003f3 	mov	x19, x0
	struct ts_session *s = ts_get_current_session();
 111d154:	97ffde23 	bl	11149e0 <ts_get_current_session>
	uint32_t c = 0;
 111d158:	b9002fff 	str	wzr, [sp, #44]

	c = tee_ta_session_is_cancelled(to_ta_session(s), NULL);
 111d15c:	97ffdb79 	bl	1113f40 <to_ta_session>
 111d160:	d2800001 	mov	x1, #0x0                   	// #0
 111d164:	97ffdb44 	bl	1113e74 <tee_ta_session_is_cancelled>
 111d168:	12001c00 	and	w0, w0, #0xff

	return copy_to_user(cancel, &c, sizeof(c));
 111d16c:	9100b3e1 	add	x1, sp, #0x2c
 111d170:	d2800082 	mov	x2, #0x4                   	// #4
	c = tee_ta_session_is_cancelled(to_ta_session(s), NULL);
 111d174:	b9002fe0 	str	w0, [sp, #44]
	return copy_to_user(cancel, &c, sizeof(c));
 111d178:	aa1303e0 	mov	x0, x19
 111d17c:	97ffdf71 	bl	1114f40 <copy_to_user>
}
 111d180:	f9400bf3 	ldr	x19, [sp, #16]
 111d184:	a8c37bfd 	ldp	x29, x30, [sp], #48
 111d188:	d65f03c0 	ret

000000000111d18c <syscall_unmask_cancellation>:

TEE_Result syscall_unmask_cancellation(uint32_t *old_mask)
{
 111d18c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 111d190:	910003fd 	mov	x29, sp
 111d194:	f9000bf3 	str	x19, [sp, #16]
 111d198:	aa0003f3 	mov	x19, x0
	struct ts_session *s = ts_get_current_session();
 111d19c:	97ffde11 	bl	11149e0 <ts_get_current_session>
	struct tee_ta_session *sess = NULL;
	uint32_t m = 0;
 111d1a0:	b9002fff 	str	wzr, [sp, #44]

	sess = to_ta_session(s);
 111d1a4:	97ffdb67 	bl	1113f40 <to_ta_session>
	m = sess->cancel_mask;
 111d1a8:	39417401 	ldrb	w1, [x0, #93]
	sess->cancel_mask = false;
 111d1ac:	3901741f 	strb	wzr, [x0, #93]
	return copy_to_user(old_mask, &m, sizeof(m));
 111d1b0:	d2800082 	mov	x2, #0x4                   	// #4
 111d1b4:	aa1303e0 	mov	x0, x19
	m = sess->cancel_mask;
 111d1b8:	b9002fe1 	str	w1, [sp, #44]
	return copy_to_user(old_mask, &m, sizeof(m));
 111d1bc:	9100b3e1 	add	x1, sp, #0x2c
 111d1c0:	97ffdf60 	bl	1114f40 <copy_to_user>
}
 111d1c4:	f9400bf3 	ldr	x19, [sp, #16]
 111d1c8:	a8c37bfd 	ldp	x29, x30, [sp], #48
 111d1cc:	d65f03c0 	ret

000000000111d1d0 <syscall_mask_cancellation>:

TEE_Result syscall_mask_cancellation(uint32_t *old_mask)
{
 111d1d0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 111d1d4:	910003fd 	mov	x29, sp
 111d1d8:	f9000bf3 	str	x19, [sp, #16]
 111d1dc:	aa0003f3 	mov	x19, x0
	struct ts_session *s = ts_get_current_session();
 111d1e0:	97ffde00 	bl	11149e0 <ts_get_current_session>
	struct tee_ta_session *sess = NULL;
	uint32_t m = 0;
 111d1e4:	b9002fff 	str	wzr, [sp, #44]

	sess = to_ta_session(s);
 111d1e8:	97ffdb56 	bl	1113f40 <to_ta_session>
	m = sess->cancel_mask;
 111d1ec:	39417401 	ldrb	w1, [x0, #93]
 111d1f0:	b9002fe1 	str	w1, [sp, #44]
	sess->cancel_mask = true;
	return copy_to_user(old_mask, &m, sizeof(m));
 111d1f4:	d2800082 	mov	x2, #0x4                   	// #4
	sess->cancel_mask = true;
 111d1f8:	52800021 	mov	w1, #0x1                   	// #1
 111d1fc:	39017401 	strb	w1, [x0, #93]
	return copy_to_user(old_mask, &m, sizeof(m));
 111d200:	9100b3e1 	add	x1, sp, #0x2c
 111d204:	aa1303e0 	mov	x0, x19
 111d208:	97ffdf4e 	bl	1114f40 <copy_to_user>
}
 111d20c:	f9400bf3 	ldr	x19, [sp, #16]
 111d210:	a8c37bfd 	ldp	x29, x30, [sp], #48
 111d214:	d65f03c0 	ret

000000000111d218 <syscall_wait>:

TEE_Result syscall_wait(unsigned long timeout)
{
 111d218:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 111d21c:	910003fd 	mov	x29, sp
 111d220:	a90153f3 	stp	x19, x20, [sp, #16]
 111d224:	aa0003f4 	mov	x20, x0
 111d228:	a9025bf5 	stp	x21, x22, [sp, #32]
 111d22c:	f9001bf7 	str	x23, [sp, #48]
	struct ts_session *s = ts_get_current_session();
 111d230:	97ffddec 	bl	11149e0 <ts_get_current_session>
 111d234:	aa0003f5 	mov	x21, x0
	TEE_Result res = TEE_SUCCESS;
	uint32_t mytime = 0;
	TEE_Time base_time = { };
	TEE_Time current_time = { };

	res = tee_time_get_sys_time(&base_time);
 111d238:	910103e0 	add	x0, sp, #0x40
	TEE_Time current_time = { };
 111d23c:	a9047fff 	stp	xzr, xzr, [sp, #64]
	res = tee_time_get_sys_time(&base_time);
 111d240:	97ff9bdc 	bl	11041b0 <tee_time_get_sys_time>
 111d244:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 111d248:	35000340 	cbnz	w0, 111d2b0 <syscall_wait+0x98>
		return res;

	while (true) {
		res = tee_time_get_sys_time(&current_time);
 111d24c:	910123f6 	add	x22, sp, #0x48

		if (tee_ta_session_is_cancelled(to_ta_session(s),
						&current_time))
			return TEE_ERROR_CANCEL;

		mytime = (current_time.seconds - base_time.seconds) * 1000 +
 111d250:	52807d17 	mov	w23, #0x3e8                 	// #1000
		res = tee_time_get_sys_time(&current_time);
 111d254:	aa1603e0 	mov	x0, x22
 111d258:	97ff9bd6 	bl	11041b0 <tee_time_get_sys_time>
 111d25c:	2a0003f3 	mov	w19, w0
		if (res != TEE_SUCCESS)
 111d260:	35000280 	cbnz	w0, 111d2b0 <syscall_wait+0x98>
		if (tee_ta_session_is_cancelled(to_ta_session(s),
 111d264:	aa1503e0 	mov	x0, x21
 111d268:	97ffdb36 	bl	1113f40 <to_ta_session>
 111d26c:	aa1603e1 	mov	x1, x22
 111d270:	97ffdb01 	bl	1113e74 <tee_ta_session_is_cancelled>
 111d274:	72001c1f 	tst	w0, #0xff
 111d278:	540001a1 	b.ne	111d2ac <syscall_wait+0x94>  // b.any
		    (int)current_time.millis - (int)base_time.millis;
 111d27c:	29480be0 	ldp	w0, w2, [sp, #64]
		mytime = (current_time.seconds - base_time.seconds) * 1000 +
 111d280:	b9404be1 	ldr	w1, [sp, #72]
 111d284:	4b000021 	sub	w1, w1, w0
 111d288:	b9404fe0 	ldr	w0, [sp, #76]
 111d28c:	1b170021 	madd	w1, w1, w23, w0
		if (mytime >= timeout)
 111d290:	4b020020 	sub	w0, w1, w2
 111d294:	eb14001f 	cmp	x0, x20
 111d298:	540000c2 	b.cs	111d2b0 <syscall_wait+0x98>  // b.hs, b.nlast
			return TEE_SUCCESS;

		tee_time_wait(timeout - mytime);
 111d29c:	0b140040 	add	w0, w2, w20
 111d2a0:	4b010000 	sub	w0, w0, w1
 111d2a4:	97ff9bcc 	bl	11041d4 <tee_time_wait>
		res = tee_time_get_sys_time(&current_time);
 111d2a8:	17ffffeb 	b	111d254 <syscall_wait+0x3c>
			return TEE_ERROR_CANCEL;
 111d2ac:	129fffb3 	mov	w19, #0xffff0002            	// #-65534
	}

	return res;
}
 111d2b0:	2a1303e0 	mov	w0, w19
 111d2b4:	a94153f3 	ldp	x19, x20, [sp, #16]
 111d2b8:	a9425bf5 	ldp	x21, x22, [sp, #32]
 111d2bc:	f9401bf7 	ldr	x23, [sp, #48]
 111d2c0:	a8c57bfd 	ldp	x29, x30, [sp], #80
 111d2c4:	d65f03c0 	ret

000000000111d2c8 <syscall_get_time>:

TEE_Result syscall_get_time(unsigned long cat, TEE_Time *mytime)
{
 111d2c8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 111d2cc:	910003fd 	mov	x29, sp
 111d2d0:	a90153f3 	stp	x19, x20, [sp, #16]
 111d2d4:	aa0003f3 	mov	x19, x0
 111d2d8:	aa0103f4 	mov	x20, x1
	struct ts_session *s = ts_get_current_session();
 111d2dc:	97ffddc1 	bl	11149e0 <ts_get_current_session>
	TEE_Result res = TEE_SUCCESS;
	TEE_Result res2 = TEE_SUCCESS;
	TEE_Time t = { };
 111d2e0:	f90017ff 	str	xzr, [sp, #40]

	switch (cat) {
 111d2e4:	f100067f 	cmp	x19, #0x1
 111d2e8:	540002a0 	b.eq	111d33c <syscall_get_time+0x74>  // b.none
 111d2ec:	f1000a7f 	cmp	x19, #0x2
 111d2f0:	540002e0 	b.eq	111d34c <syscall_get_time+0x84>  // b.none
 111d2f4:	b5000333 	cbnz	x19, 111d358 <syscall_get_time+0x90>
	case UTEE_TIME_CAT_SYSTEM:
		res = tee_time_get_sys_time(&t);
 111d2f8:	9100a3e0 	add	x0, sp, #0x28
 111d2fc:	97ff9bad 	bl	11041b0 <tee_time_get_sys_time>
		break;
	case UTEE_TIME_CAT_TA_PERSISTENT:
		res = tee_time_get_ta_time((const void *)&s->ctx->uuid, &t);
		break;
	case UTEE_TIME_CAT_REE:
		res = tee_time_get_ree_time(&t);
 111d300:	2a0003f3 	mov	w19, w0
	default:
		res = TEE_ERROR_BAD_PARAMETERS;
		break;
	}

	if (res == TEE_SUCCESS || res == TEE_ERROR_OVERFLOW) {
 111d304:	7100027f 	cmp	w19, #0x0
 111d308:	1299fe00 	mov	w0, #0xffff300f            	// #-53233
 111d30c:	7a401264 	ccmp	w19, w0, #0x4, ne  // ne = any
 111d310:	540000e1 	b.ne	111d32c <syscall_get_time+0x64>  // b.any
		res2 = copy_to_user_private(mytime, &t, sizeof(t));
 111d314:	9100a3e1 	add	x1, sp, #0x28
 111d318:	aa1403e0 	mov	x0, x20
 111d31c:	d2800102 	mov	x2, #0x8                   	// #8
 111d320:	97ffdf31 	bl	1114fe4 <copy_to_user_private>
		if (res2 != TEE_SUCCESS)
 111d324:	7100001f 	cmp	w0, #0x0
 111d328:	1a800273 	csel	w19, w19, w0, eq  // eq = none
			res = res2;
	}

	return res;
}
 111d32c:	2a1303e0 	mov	w0, w19
 111d330:	a94153f3 	ldp	x19, x20, [sp, #16]
 111d334:	a8c37bfd 	ldp	x29, x30, [sp], #48
 111d338:	d65f03c0 	ret
		res = tee_time_get_ta_time((const void *)&s->ctx->uuid, &t);
 111d33c:	f9400800 	ldr	x0, [x0, #16]
 111d340:	9100a3e1 	add	x1, sp, #0x28
 111d344:	9400245e 	bl	11264bc <tee_time_get_ta_time>
 111d348:	17ffffee 	b	111d300 <syscall_get_time+0x38>
		res = tee_time_get_ree_time(&t);
 111d34c:	9100a3e0 	add	x0, sp, #0x28
 111d350:	97ff9bae 	bl	1104208 <tee_time_get_ree_time>
 111d354:	17ffffeb 	b	111d300 <syscall_get_time+0x38>
	switch (cat) {
 111d358:	129fff33 	mov	w19, #0xffff0006            	// #-65530
 111d35c:	17ffffea 	b	111d304 <syscall_get_time+0x3c>

000000000111d360 <syscall_set_ta_time>:

TEE_Result syscall_set_ta_time(const TEE_Time *mytime)
{
 111d360:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 111d364:	910003fd 	mov	x29, sp
 111d368:	a90153f3 	stp	x19, x20, [sp, #16]
 111d36c:	aa0003f4 	mov	x20, x0
 111d370:	f90013f5 	str	x21, [sp, #32]
	struct ts_session *s = ts_get_current_session();
 111d374:	97ffdd9b 	bl	11149e0 <ts_get_current_session>
	TEE_Result res = TEE_SUCCESS;
	TEE_Time t = { };

	res = copy_from_user_private(&t, mytime, sizeof(t));
 111d378:	9100e3f5 	add	x21, sp, #0x38
	struct ts_session *s = ts_get_current_session();
 111d37c:	aa0003f3 	mov	x19, x0
	res = copy_from_user_private(&t, mytime, sizeof(t));
 111d380:	aa1403e1 	mov	x1, x20
 111d384:	aa1503e0 	mov	x0, x21
 111d388:	d2800102 	mov	x2, #0x8                   	// #8
	TEE_Time t = { };
 111d38c:	f9001fff 	str	xzr, [sp, #56]
	res = copy_from_user_private(&t, mytime, sizeof(t));
 111d390:	97ffdf01 	bl	1114f94 <copy_from_user_private>
	if (res != TEE_SUCCESS)
 111d394:	35000080 	cbnz	w0, 111d3a4 <syscall_set_ta_time+0x44>
		return res;

	return tee_time_set_ta_time((const void *)&s->ctx->uuid, &t);
 111d398:	f9400a60 	ldr	x0, [x19, #16]
 111d39c:	aa1503e1 	mov	x1, x21
 111d3a0:	9400248c 	bl	11265d0 <tee_time_set_ta_time>
}
 111d3a4:	a94153f3 	ldp	x19, x20, [sp, #16]
 111d3a8:	f94013f5 	ldr	x21, [sp, #32]
 111d3ac:	a8c47bfd 	ldp	x29, x30, [sp], #64
 111d3b0:	d65f03c0 	ret

000000000111d3b4 <__tee_alg_get_class>:
	if (algo == TEE_ALG_SM2_PKE)
 111d3b4:	528008a1 	mov	w1, #0x45                  	// #69
 111d3b8:	72b00001 	movk	w1, #0x8000, lsl #16
 111d3bc:	6b01001f 	cmp	w0, w1
 111d3c0:	54000200 	b.eq	111d400 <__tee_alg_get_class+0x4c>  // b.none
	if (algo == TEE_ALG_SM2_KEP)
 111d3c4:	528008a1 	mov	w1, #0x45                  	// #69
 111d3c8:	72ac0001 	movk	w1, #0x6000, lsl #16
 111d3cc:	6b01001f 	cmp	w0, w1
 111d3d0:	540001c0 	b.eq	111d408 <__tee_alg_get_class+0x54>  // b.none
	if (algo == TEE_ALG_RSASSA_PKCS1_V1_5)
 111d3d4:	52810601 	mov	w1, #0x830                 	// #2096
 111d3d8:	72be0001 	movk	w1, #0xf000, lsl #16
 111d3dc:	6b01001f 	cmp	w0, w1
 111d3e0:	54000180 	b.eq	111d410 <__tee_alg_get_class+0x5c>  // b.none
	return (algo >> 28) & 0xF; /* Bits [31:28] */
 111d3e4:	5280c262 	mov	w2, #0x613                 	// #1555
 111d3e8:	531c7c01 	lsr	w1, w0, #28
 111d3ec:	72be0002 	movk	w2, #0xf000, lsl #16
 111d3f0:	6b02001f 	cmp	w0, w2
 111d3f4:	52800060 	mov	w0, #0x3                   	// #3
 111d3f8:	1a801020 	csel	w0, w1, w0, ne  // ne = any
}
 111d3fc:	d65f03c0 	ret
		return TEE_OPERATION_ASYMMETRIC_CIPHER;
 111d400:	528000c0 	mov	w0, #0x6                   	// #6
 111d404:	17fffffe 	b	111d3fc <__tee_alg_get_class+0x48>
		return TEE_OPERATION_KEY_DERIVATION;
 111d408:	52800100 	mov	w0, #0x8                   	// #8
 111d40c:	17fffffc 	b	111d3fc <__tee_alg_get_class+0x48>
		return TEE_OPERATION_ASYMMETRIC_SIGNATURE;
 111d410:	528000e0 	mov	w0, #0x7                   	// #7
 111d414:	17fffffa 	b	111d3fc <__tee_alg_get_class+0x48>

000000000111d418 <__tee_alg_get_main_alg>:
	switch (algo) {
 111d418:	528008a1 	mov	w1, #0x45                  	// #69
 111d41c:	72ac0001 	movk	w1, #0x6000, lsl #16
 111d420:	6b01001f 	cmp	w0, w1
 111d424:	54000100 	b.eq	111d444 <__tee_alg_get_main_alg+0x2c>  // b.none
	return algo & 0xff;
 111d428:	528008a2 	mov	w2, #0x45                  	// #69
 111d42c:	12001c01 	and	w1, w0, #0xff
 111d430:	72b00002 	movk	w2, #0x8000, lsl #16
 111d434:	6b02001f 	cmp	w0, w2
 111d438:	528008e0 	mov	w0, #0x47                  	// #71
 111d43c:	1a801020 	csel	w0, w1, w0, ne  // ne = any
}
 111d440:	d65f03c0 	ret
	switch (algo) {
 111d444:	528008c0 	mov	w0, #0x46                  	// #70
 111d448:	17fffffe 	b	111d440 <__tee_alg_get_main_alg+0x28>

000000000111d44c <op_attr_value_from_obj>:
static TEE_Result op_attr_value_from_obj(void *attr, void *src_attr)
{
	uint32_t *v = attr;
	uint32_t *src_v = src_attr;

	*v = *src_v;
 111d44c:	b9400021 	ldr	w1, [x1]
 111d450:	b9000001 	str	w1, [x0]
	return TEE_SUCCESS;
}
 111d454:	52800000 	mov	w0, #0x0                   	// #0
 111d458:	d65f03c0 	ret

000000000111d45c <op_attr_value_clear>:

static void op_attr_value_clear(void *attr)
{
	uint32_t *v = attr;

	*v = 0;
 111d45c:	b900001f 	str	wzr, [x0]
}
 111d460:	d65f03c0 	ret

000000000111d464 <tee_svc_cryp_obj_find_type_attr_idx>:
		uint32_t attr_id,
		const struct tee_cryp_obj_type_props *type_props)
{
	size_t n;

	for (n = 0; n < type_props->num_type_attrs; n++) {
 111d464:	39402c23 	ldrb	w3, [x1, #11]
{
 111d468:	2a0003e2 	mov	w2, w0
		if (attr_id == type_props->type_attrs[n].attr_id)
 111d46c:	d2800184 	mov	x4, #0xc                   	// #12
	for (n = 0; n < type_props->num_type_attrs; n++) {
 111d470:	d2800000 	mov	x0, #0x0                   	// #0
 111d474:	eb00007f 	cmp	x3, x0
 111d478:	54000068 	b.hi	111d484 <tee_svc_cryp_obj_find_type_attr_idx+0x20>  // b.pmore
			return n;
	}
	return -1;
 111d47c:	12800000 	mov	w0, #0xffffffff            	// #-1
}
 111d480:	d65f03c0 	ret
		if (attr_id == type_props->type_attrs[n].attr_id)
 111d484:	9b047c05 	mul	x5, x0, x4
 111d488:	f9400826 	ldr	x6, [x1, #16]
 111d48c:	b86568c5 	ldr	w5, [x6, x5]
 111d490:	6b0200bf 	cmp	w5, w2
 111d494:	54ffff60 	b.eq	111d480 <tee_svc_cryp_obj_find_type_attr_idx+0x1c>  // b.none
	for (n = 0; n < type_props->num_type_attrs; n++) {
 111d498:	91000400 	add	x0, x0, #0x1
 111d49c:	17fffff6 	b	111d474 <tee_svc_cryp_obj_find_type_attr_idx+0x10>

000000000111d4a0 <tee_svc_find_type_props>:
		TEE_ObjectType obj_type)
{
	size_t n;

	for (n = 0; n < ARRAY_SIZE(tee_cryp_obj_props); n++) {
		if (tee_cryp_obj_props[n].obj_type == obj_type)
 111d4a0:	d00001e1 	adrp	x1, 115b000 <__vcore_unpg_rw_start>
 111d4a4:	912d8021 	add	x1, x1, #0xb60
	for (n = 0; n < ARRAY_SIZE(tee_cryp_obj_props); n++) {
 111d4a8:	d2800002 	mov	x2, #0x0                   	// #0
 111d4ac:	d2800304 	mov	x4, #0x18                  	// #24
		if (tee_cryp_obj_props[n].obj_type == obj_type)
 111d4b0:	9b047c43 	mul	x3, x2, x4
 111d4b4:	b8616865 	ldr	w5, [x3, x1]
 111d4b8:	6b0000bf 	cmp	w5, w0
 111d4bc:	54000061 	b.ne	111d4c8 <tee_svc_find_type_props+0x28>  // b.any
			return tee_cryp_obj_props + n;
 111d4c0:	8b030020 	add	x0, x1, x3
	}

	return NULL;
}
 111d4c4:	d65f03c0 	ret
	for (n = 0; n < ARRAY_SIZE(tee_cryp_obj_props); n++) {
 111d4c8:	91000442 	add	x2, x2, #0x1
 111d4cc:	f100785f 	cmp	x2, #0x1e
 111d4d0:	54ffff01 	b.ne	111d4b0 <tee_svc_find_type_props+0x10>  // b.any
	return NULL;
 111d4d4:	d2800000 	mov	x0, #0x0                   	// #0
 111d4d8:	17fffffb 	b	111d4c4 <tee_svc_find_type_props+0x24>

000000000111d4dc <is_gp_legacy_des_key_size>:
}

static bool is_gp_legacy_des_key_size(TEE_ObjectType type, size_t sz)
{
	return IS_ENABLED(CFG_COMPAT_GP10_DES) &&
	       ((type == TEE_TYPE_DES && sz == 56) ||
 111d4dc:	f100e03f 	cmp	x1, #0x38
	return IS_ENABLED(CFG_COMPAT_GP10_DES) &&
 111d4e0:	52800222 	mov	w2, #0x11                  	// #17
 111d4e4:	72b40002 	movk	w2, #0xa000, lsl #16
 111d4e8:	7a420000 	ccmp	w0, w2, #0x0, eq  // eq = none
 111d4ec:	54000120 	b.eq	111d510 <is_gp_legacy_des_key_size+0x34>  // b.none
 111d4f0:	11000842 	add	w2, w2, #0x2
 111d4f4:	6b02001f 	cmp	w0, w2
 111d4f8:	54000101 	b.ne	111d518 <is_gp_legacy_des_key_size+0x3c>  // b.any
		(type == TEE_TYPE_DES3 && (sz == 112 || sz == 168)));
 111d4fc:	f101c03f 	cmp	x1, #0x70
 111d500:	d2801500 	mov	x0, #0xa8                  	// #168
 111d504:	fa401024 	ccmp	x1, x0, #0x4, ne  // ne = any
	return IS_ENABLED(CFG_COMPAT_GP10_DES) &&
 111d508:	1a9f17e0 	cset	w0, eq  // eq = none
}
 111d50c:	d65f03c0 	ret
	return IS_ENABLED(CFG_COMPAT_GP10_DES) &&
 111d510:	52800020 	mov	w0, #0x1                   	// #1
 111d514:	17fffffe 	b	111d50c <is_gp_legacy_des_key_size+0x30>
 111d518:	52800000 	mov	w0, #0x0                   	// #0
 111d51c:	17fffffc 	b	111d50c <is_gp_legacy_des_key_size+0x30>

000000000111d520 <check_key_size>:

static TEE_Result check_key_size(const struct tee_cryp_obj_type_props *props,
				 size_t key_size)
{
 111d520:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 111d524:	aa0003e4 	mov	x4, x0
 111d528:	aa0103e3 	mov	x3, x1
 111d52c:	910003fd 	mov	x29, sp
	/*
	 * In GP Internal API Specification 1.0 the partity bits aren't
	 * counted when telling the size of the key in bits so add them
	 * here if missing.
	 */
	if (is_gp_legacy_des_key_size(props->obj_type, sz))
 111d530:	b9400000 	ldr	w0, [x0]
 111d534:	97ffffea 	bl	111d4dc <is_gp_legacy_des_key_size>
 111d538:	72001c1f 	tst	w0, #0xff
 111d53c:	54000080 	b.eq	111d54c <check_key_size+0x2c>  // b.none
		sz += sz / 7;
 111d540:	d28000e0 	mov	x0, #0x7                   	// #7
 111d544:	9ac00820 	udiv	x0, x1, x0
 111d548:	8b000023 	add	x3, x1, x0

	if (sz % props->quanta != 0)
 111d54c:	39402881 	ldrb	w1, [x4, #10]
 111d550:	9ac10860 	udiv	x0, x3, x1
 111d554:	9b018c00 	msub	x0, x0, x1, x3
 111d558:	b5000140 	cbnz	x0, 111d580 <check_key_size+0x60>
		return TEE_ERROR_NOT_SUPPORTED;
	if (sz < props->min_size)
 111d55c:	79400880 	ldrh	w0, [x4, #4]
 111d560:	eb03001f 	cmp	x0, x3
 111d564:	540000e8 	b.hi	111d580 <check_key_size+0x60>  // b.pmore
		return TEE_ERROR_NOT_SUPPORTED;
	if (sz > props->max_size)
 111d568:	79400c80 	ldrh	w0, [x4, #6]
		return TEE_ERROR_NOT_SUPPORTED;

	return TEE_SUCCESS;
 111d56c:	eb03001f 	cmp	x0, x3
 111d570:	129ffea0 	mov	w0, #0xffff000a            	// #-65526
 111d574:	1a9f3000 	csel	w0, w0, wzr, cc  // cc = lo, ul, last
}
 111d578:	a8c17bfd 	ldp	x29, x30, [sp], #16
 111d57c:	d65f03c0 	ret
		return TEE_ERROR_NOT_SUPPORTED;
 111d580:	129ffea0 	mov	w0, #0xffff000a            	// #-65526
 111d584:	17fffffd 	b	111d578 <check_key_size+0x58>

000000000111d588 <tee_svc_cryp_check_attr>:
		opt_flag = TEE_TYPE_ATTR_OPTIONAL_GROUP;
		all_opt_needed = true;
	} else {
		required_flag = TEE_TYPE_ATTR_GEN_KEY_REQ;
		opt_flag = TEE_TYPE_ATTR_GEN_KEY_OPT;
		all_opt_needed = false;
 111d588:	7100001f 	cmp	w0, #0x0

	/*
	 * First find out which attributes are required and which belong to
	 * the optional group
	 */
	for (n = 0; n < type_props->num_type_attrs; n++) {
 111d58c:	39402c27 	ldrb	w7, [x1, #11]
		all_opt_needed = false;
 111d590:	52800400 	mov	w0, #0x20                  	// #32
{
 111d594:	aa0203ec 	mov	x12, x2
		all_opt_needed = false;
 111d598:	1a9f17ed 	cset	w13, eq  // eq = none
 111d59c:	52800202 	mov	w2, #0x10                  	// #16
 111d5a0:	52800084 	mov	w4, #0x4                   	// #4
	uint32_t opt_grp_attrs = 0;
 111d5a4:	52800008 	mov	w8, #0x0                   	// #0
		all_opt_needed = false;
 111d5a8:	1a820084 	csel	w4, w4, w2, eq  // eq = none
	uint32_t req_attrs = 0;
 111d5ac:	5280000a 	mov	w10, #0x0                   	// #0
		all_opt_needed = false;
 111d5b0:	52800042 	mov	w2, #0x2                   	// #2
		bit = 1 << n;
 111d5b4:	52800029 	mov	w9, #0x1                   	// #1
		all_opt_needed = false;
 111d5b8:	1a800042 	csel	w2, w2, w0, eq  // eq = none
		flags = type_props->type_attrs[n].flags;
 111d5bc:	d280018b 	mov	x11, #0xc                   	// #12
	for (n = 0; n < type_props->num_type_attrs; n++) {
 111d5c0:	d2800000 	mov	x0, #0x0                   	// #0
 111d5c4:	eb0000ff 	cmp	x7, x0
 111d5c8:	54000248 	b.hi	111d610 <tee_svc_cryp_check_attr+0x88>  // b.pmore

	/*
	 * Verify that all required attributes are in place and
	 * that the same attribute isn't repeated.
	 */
	for (n = 0; n < attr_count; n++) {
 111d5cc:	2a0303e9 	mov	w9, w3
 111d5d0:	d280000b 	mov	x11, #0x0                   	// #0

		/*
		 * Attribute not defined in current object type for this
		 * usage.
		 */
		if (!(bit & (req_attrs | opt_grp_attrs)))
 111d5d4:	2a080152 	orr	w18, w10, w8
	for (n = 0; n < attr_count; n++) {
 111d5d8:	eb0b013f 	cmp	x9, x11
	uint32_t attrs_found = 0;
 111d5dc:	52800007 	mov	w7, #0x0                   	// #0
		idx = tee_svc_cryp_obj_find_type_attr_idx(
 111d5e0:	d280030e 	mov	x14, #0x18                  	// #24
		bit = 1 << idx;
 111d5e4:	5280002f 	mov	w15, #0x1                   	// #1
	for (n = 0; n < attr_count; n++) {
 111d5e8:	54000408 	b.hi	111d668 <tee_svc_cryp_check_attr+0xe0>  // b.pmore
			return TEE_ERROR_ITEM_NOT_FOUND;

		attrs_found |= bit;
	}
	/* Required attribute missing */
	if ((attrs_found & req_attrs) != req_attrs)
 111d5ec:	6a27015f 	bics	wzr, w10, w7
 111d5f0:	54000321 	b.ne	111d654 <tee_svc_cryp_check_attr+0xcc>  // b.any

	/*
	 * If the flag says that "if one of the optional attributes are included
	 * all of them has to be included" this must be checked.
	 */
	if (all_opt_needed && (attrs_found & opt_grp_attrs) != 0 &&
 111d5f4:	3400034d 	cbz	w13, 111d65c <tee_svc_cryp_check_attr+0xd4>
 111d5f8:	6a070100 	ands	w0, w8, w7
 111d5fc:	54000340 	b.eq	111d664 <tee_svc_cryp_check_attr+0xdc>  // b.none
	    (attrs_found & opt_grp_attrs) != opt_grp_attrs)
		return TEE_ERROR_ITEM_NOT_FOUND;
 111d600:	6b08001f 	cmp	w0, w8
 111d604:	129ffee0 	mov	w0, #0xffff0008            	// #-65528
 111d608:	1a8003e0 	csel	w0, wzr, w0, eq  // eq = none
 111d60c:	d65f03c0 	ret
		flags = type_props->type_attrs[n].flags;
 111d610:	f9400825 	ldr	x5, [x1, #16]
		bit = 1 << n;
 111d614:	1ac02126 	lsl	w6, w9, w0
		flags = type_props->type_attrs[n].flags;
 111d618:	9b0b1405 	madd	x5, x0, x11, x5
 111d61c:	794008a5 	ldrh	w5, [x5, #4]
		if (flags & required_flag)
 111d620:	6a05005f 	tst	w2, w5
 111d624:	54000080 	b.eq	111d634 <tee_svc_cryp_check_attr+0xac>  // b.none
			req_attrs |= bit;
 111d628:	2a06014a 	orr	w10, w10, w6
	for (n = 0; n < type_props->num_type_attrs; n++) {
 111d62c:	91000400 	add	x0, x0, #0x1
 111d630:	17ffffe5 	b	111d5c4 <tee_svc_cryp_check_attr+0x3c>
		else if (flags & opt_flag)
 111d634:	6a05009f 	tst	w4, w5
 111d638:	54ffffa0 	b.eq	111d62c <tee_svc_cryp_check_attr+0xa4>  // b.none
			opt_grp_attrs |= bit;
 111d63c:	2a060108 	orr	w8, w8, w6
 111d640:	17fffffb 	b	111d62c <tee_svc_cryp_check_attr+0xa4>
		return TEE_ERROR_ITEM_NOT_FOUND;
 111d644:	129ffee0 	mov	w0, #0xffff0008            	// #-65528
 111d648:	1400001f 	b	111d6c4 <tee_svc_cryp_check_attr+0x13c>

	return TEE_SUCCESS;
 111d64c:	52800000 	mov	w0, #0x0                   	// #0
 111d650:	1400001d 	b	111d6c4 <tee_svc_cryp_check_attr+0x13c>
		return TEE_ERROR_ITEM_NOT_FOUND;
 111d654:	129ffee0 	mov	w0, #0xffff0008            	// #-65528
 111d658:	d65f03c0 	ret
	return TEE_SUCCESS;
 111d65c:	52800000 	mov	w0, #0x0                   	// #0
 111d660:	d65f03c0 	ret
}
 111d664:	d65f03c0 	ret
{
 111d668:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 111d66c:	910003fd 	mov	x29, sp
		idx = tee_svc_cryp_obj_find_type_attr_idx(
 111d670:	9b0e7d60 	mul	x0, x11, x14
 111d674:	b8606980 	ldr	w0, [x12, x0]
 111d678:	97ffff7b 	bl	111d464 <tee_svc_cryp_obj_find_type_attr_idx>
		if (idx < 0)
 111d67c:	37fffe40 	tbnz	w0, #31, 111d644 <tee_svc_cryp_check_attr+0xbc>
		bit = 1 << idx;
 111d680:	1ac021e0 	lsl	w0, w15, w0
		if ((attrs_found & bit) != 0)
 111d684:	6a0000ff 	tst	w7, w0
 111d688:	54fffde1 	b.ne	111d644 <tee_svc_cryp_check_attr+0xbc>  // b.any
		if (!(bit & (req_attrs | opt_grp_attrs)))
 111d68c:	6a00025f 	tst	w18, w0
 111d690:	54fffda0 	b.eq	111d644 <tee_svc_cryp_check_attr+0xbc>  // b.none
	for (n = 0; n < attr_count; n++) {
 111d694:	9100056b 	add	x11, x11, #0x1
		attrs_found |= bit;
 111d698:	2a0000e7 	orr	w7, w7, w0
	for (n = 0; n < attr_count; n++) {
 111d69c:	eb0b013f 	cmp	x9, x11
 111d6a0:	54fffe88 	b.hi	111d670 <tee_svc_cryp_check_attr+0xe8>  // b.pmore
	if ((attrs_found & req_attrs) != req_attrs)
 111d6a4:	6a27015f 	bics	wzr, w10, w7
 111d6a8:	54fffce1 	b.ne	111d644 <tee_svc_cryp_check_attr+0xbc>  // b.any
	if (all_opt_needed && (attrs_found & opt_grp_attrs) != 0 &&
 111d6ac:	34fffd0d 	cbz	w13, 111d64c <tee_svc_cryp_check_attr+0xc4>
 111d6b0:	6a070100 	ands	w0, w8, w7
 111d6b4:	54000080 	b.eq	111d6c4 <tee_svc_cryp_check_attr+0x13c>  // b.none
		return TEE_ERROR_ITEM_NOT_FOUND;
 111d6b8:	6b08001f 	cmp	w0, w8
 111d6bc:	129ffee0 	mov	w0, #0xffff0008            	// #-65528
 111d6c0:	1a8003e0 	csel	w0, wzr, w0, eq  // eq = none
}
 111d6c4:	a8c17bfd 	ldp	x29, x30, [sp], #16
 111d6c8:	d65f03c0 	ret

000000000111d6cc <tee_svc_cryp_obj_populate_type>:
static TEE_Result tee_svc_cryp_obj_populate_type(
		struct tee_obj *o,
		const struct tee_cryp_obj_type_props *type_props,
		const TEE_Attribute *attrs,
		uint32_t attr_count)
{
 111d6cc:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
 111d6d0:	910003fd 	mov	x29, sp
 111d6d4:	a9025bf5 	stp	x21, x22, [sp, #32]
 111d6d8:	aa0103f5 	mov	x21, x1
	TEE_Result res = TEE_SUCCESS;
	uint32_t have_attrs = 0;
 111d6dc:	52800016 	mov	w22, #0x0                   	// #0
{
 111d6e0:	a90363f7 	stp	x23, x24, [sp, #48]
 111d6e4:	aa0003f8 	mov	x24, x0
	size_t n = 0;
	int idx = 0;
	const struct attr_ops *ops = NULL;
	void *attr = NULL;

	for (n = 0; n < attr_count; n++) {
 111d6e8:	d2800017 	mov	x23, #0x0                   	// #0
{
 111d6ec:	a9046bf9 	stp	x25, x26, [sp, #64]
		/* attribute not defined in current object type */
		if (idx < 0)
			return TEE_ERROR_ITEM_NOT_FOUND;

		have_attrs |= BIT32(idx);
		ops = attr_ops + type_props->type_attrs[idx].ops_index;
 111d6f0:	d00001f9 	adrp	x25, 115b000 <__vcore_unpg_rw_start>
 111d6f4:	b000019a 	adrp	x26, 114e000 <ldelf_data+0x8000>
 111d6f8:	912ae339 	add	x25, x25, #0xab8
 111d6fc:	911c435a 	add	x26, x26, #0x710
{
 111d700:	a90573fb 	stp	x27, x28, [sp, #80]

			/*
			 * For ECDSA/ECDH we need to translate curve into
			 * object size
			 */
			if (attrs[n].attributeID == TEE_ATTR_ECC_CURVE) {
 111d704:	5280883b 	mov	w27, #0x441                 	// #1089
 111d708:	9100205c 	add	x28, x2, #0x8
 111d70c:	72be001b 	movk	w27, #0xf000, lsl #16
{
 111d710:	a90153f3 	stp	x19, x20, [sp, #16]
	size_t obj_size = 0;
 111d714:	d2800013 	mov	x19, #0x0                   	// #0
{
 111d718:	b9006fe3 	str	w3, [sp, #108]
	for (n = 0; n < attr_count; n++) {
 111d71c:	b9406fe0 	ldr	w0, [sp, #108]
 111d720:	eb2042ff 	cmp	x23, w0, uxtw
 111d724:	54000183 	b.cc	111d754 <tee_svc_cryp_obj_populate_type+0x88>  // b.lo, b.ul, b.last
	/*
	 * In GP Internal API Specification 1.0 the partity bits aren't
	 * counted when telling the size of the key in bits so remove the
	 * parity bits here.
	 */
	if (is_gp_legacy_des_key_size(o->info.objectType, o->info.maxKeySize))
 111d728:	b9401300 	ldr	w0, [x24, #16]
 111d72c:	b9401b01 	ldr	w1, [x24, #24]
	o->info.keySize = obj_size;
 111d730:	b9001713 	str	w19, [x24, #20]
	o->have_attrs = have_attrs;
 111d734:	b9003316 	str	w22, [x24, #48]
	if (is_gp_legacy_des_key_size(o->info.objectType, o->info.maxKeySize))
 111d738:	97ffff69 	bl	111d4dc <is_gp_legacy_des_key_size>
 111d73c:	72001c1f 	tst	w0, #0xff
 111d740:	54000060 	b.eq	111d74c <tee_svc_cryp_obj_populate_type+0x80>  // b.none
		o->info.keySize -= o->info.keySize / 8;
 111d744:	4b530e73 	sub	w19, w19, w19, lsr #3
 111d748:	b9001713 	str	w19, [x24, #20]

	return TEE_SUCCESS;
 111d74c:	52800000 	mov	w0, #0x0                   	// #0
 111d750:	1400006b 	b	111d8fc <tee_svc_cryp_obj_populate_type+0x230>
		idx = tee_svc_cryp_obj_find_type_attr_idx(
 111d754:	b85f8387 	ldur	w7, [x28, #-8]
 111d758:	aa1503e1 	mov	x1, x21
 111d75c:	2a0703e0 	mov	w0, w7
 111d760:	97ffff41 	bl	111d464 <tee_svc_cryp_obj_find_type_attr_idx>
		if (idx < 0)
 111d764:	37f80ca0 	tbnz	w0, #31, 111d8f8 <tee_svc_cryp_obj_populate_type+0x22c>
		have_attrs |= BIT32(idx);
 111d768:	52800021 	mov	w1, #0x1                   	// #1
		ops = attr_ops + type_props->type_attrs[idx].ops_index;
 111d76c:	52800194 	mov	w20, #0xc                   	// #12
		have_attrs |= BIT32(idx);
 111d770:	1ac02021 	lsl	w1, w1, w0
 111d774:	2a0102d6 	orr	w22, w22, w1
		ops = attr_ops + type_props->type_attrs[idx].ops_index;
 111d778:	f9400aa1 	ldr	x1, [x21, #16]
 111d77c:	9b347c14 	smull	x20, w0, w20
		attr = (uint8_t *)o->attr +
 111d780:	f9401f00 	ldr	x0, [x24, #56]
		ops = attr_ops + type_props->type_attrs[idx].ops_index;
 111d784:	8b140021 	add	x1, x1, x20
		       type_props->type_attrs[idx].raw_offs;
 111d788:	79401022 	ldrh	w2, [x1, #8]
		ops = attr_ops + type_props->type_attrs[idx].ops_index;
 111d78c:	79400c21 	ldrh	w1, [x1, #6]
		attr = (uint8_t *)o->attr +
 111d790:	8b020000 	add	x0, x0, x2
		ops = attr_ops + type_props->type_attrs[idx].ops_index;
 111d794:	52800702 	mov	w2, #0x38                  	// #56
 111d798:	9ba27c21 	umull	x1, w1, w2
 111d79c:	f8616b23 	ldr	x3, [x25, x1]
		if (attrs[n].attributeID & TEE_ATTR_FLAG_VALUE)
 111d7a0:	36e80307 	tbz	w7, #29, 111d800 <tee_svc_cryp_obj_populate_type+0x134>
			res = ops->from_user(attr, &attrs[n].content.value,
 111d7a4:	aa1c03e1 	mov	x1, x28
 111d7a8:	d2800102 	mov	x2, #0x8                   	// #8
			res = ops->from_user(attr, attrs[n].content.ref.buffer,
 111d7ac:	d63f0060 	blr	x3
		if (res != TEE_SUCCESS)
 111d7b0:	35000a60 	cbnz	w0, 111d8fc <tee_svc_cryp_obj_populate_type+0x230>
		if (type_props->type_attrs[idx].flags &
 111d7b4:	f9400aa0 	ldr	x0, [x21, #16]
 111d7b8:	8b140014 	add	x20, x0, x20
 111d7bc:	79400a83 	ldrh	w3, [x20, #4]
 111d7c0:	361802e3 	tbz	w3, #3, 111d81c <tee_svc_cryp_obj_populate_type+0x150>
			if (obj_size)
 111d7c4:	b5000ab3 	cbnz	x19, 111d918 <tee_svc_cryp_obj_populate_type+0x24c>
			if (attrs[n].attributeID == TEE_ATTR_ECC_CURVE) {
 111d7c8:	b85f8380 	ldur	w0, [x28, #-8]
 111d7cc:	6b1b001f 	cmp	w0, w27
 111d7d0:	54000601 	b.ne	111d890 <tee_svc_cryp_obj_populate_type+0x1c4>  // b.any
				res = get_ec_key_size(attrs[n].content.value.a,
 111d7d4:	b9400380 	ldr	w0, [x28]
	switch (curve) {
 111d7d8:	7100141f 	cmp	w0, #0x5
 111d7dc:	540004a8 	b.hi	111d870 <tee_svc_cryp_obj_populate_type+0x1a4>  // b.pmore
 111d7e0:	340004c0 	cbz	w0, 111d878 <tee_svc_cryp_obj_populate_type+0x1ac>
 111d7e4:	51000800 	sub	w0, w0, #0x2
 111d7e8:	71000c1f 	cmp	w0, #0x3
 111d7ec:	540004e8 	b.hi	111d888 <tee_svc_cryp_obj_populate_type+0x1bc>  // b.pmore
 111d7f0:	38604b40 	ldrb	w0, [x26, w0, uxtw]
 111d7f4:	10000061 	adr	x1, 111d800 <tee_svc_cryp_obj_populate_type+0x134>
 111d7f8:	8b208820 	add	x0, x1, w0, sxtb #2
 111d7fc:	d61f0000 	br	x0
			res = ops->from_user(attr, attrs[n].content.ref.buffer,
 111d800:	b9400b82 	ldr	w2, [x28, #8]
 111d804:	f9400381 	ldr	x1, [x28]
 111d808:	17ffffe9 	b	111d7ac <tee_svc_cryp_obj_populate_type+0xe0>
	switch (curve) {
 111d80c:	d2804133 	mov	x19, #0x209                 	// #521
			if (obj_size > o->info.maxKeySize)
 111d810:	b9401b00 	ldr	w0, [x24, #24]
 111d814:	eb13001f 	cmp	x0, x19
 111d818:	54000803 	b.cc	111d918 <tee_svc_cryp_obj_populate_type+0x24c>  // b.lo, b.ul, b.last
		if (type_props->type_attrs[idx].flags &
 111d81c:	36300243 	tbz	w3, #6, 111d864 <tee_svc_cryp_obj_populate_type+0x198>
	int nbits = a->content.ref.length * 8;
 111d820:	b9400b80 	ldr	w0, [x28, #8]
 111d824:	531d7001 	lsl	w1, w0, #3
	bit_ffs(a->content.ref.buffer, nbits, &v);
 111d828:	6b000fff 	cmp	wzr, w0, lsl #3
 111d82c:	5400062a 	b.ge	111d8f0 <tee_svc_cryp_obj_populate_type+0x224>  // b.tcont
 111d830:	f9400386 	ldr	x6, [x28]
 111d834:	51000425 	sub	w5, w1, #0x1
 111d838:	d2800002 	mov	x2, #0x0                   	// #0
 111d83c:	13037ca5 	asr	w5, w5, #3
 111d840:	d10004c6 	sub	x6, x6, #0x1
 111d844:	2a0203e0 	mov	w0, w2
 111d848:	6b0200bf 	cmp	w5, w2
 111d84c:	540003ca 	b.ge	111d8c4 <tee_svc_cryp_obj_populate_type+0x1f8>  // b.tcont
 111d850:	12800000 	mov	w0, #0xffffffff            	// #-1
			if (get_used_bits(attrs + n) > o->info.maxKeySize)
 111d854:	b9401b02 	ldr	w2, [x24, #24]
	return nbits - v;
 111d858:	4b000020 	sub	w0, w1, w0
			if (get_used_bits(attrs + n) > o->info.maxKeySize)
 111d85c:	eb20c05f 	cmp	x2, w0, sxtw
 111d860:	540005c3 	b.cc	111d918 <tee_svc_cryp_obj_populate_type+0x24c>  // b.lo, b.ul, b.last
	for (n = 0; n < attr_count; n++) {
 111d864:	910006f7 	add	x23, x23, #0x1
 111d868:	9100639c 	add	x28, x28, #0x18
 111d86c:	17ffffac 	b	111d71c <tee_svc_cryp_obj_populate_type+0x50>
	switch (curve) {
 111d870:	710c001f 	cmp	w0, #0x300
 111d874:	54000240 	b.eq	111d8bc <tee_svc_cryp_obj_populate_type+0x1f0>  // b.none
 111d878:	129ffea0 	mov	w0, #0xffff000a            	// #-65526
 111d87c:	14000020 	b	111d8fc <tee_svc_cryp_obj_populate_type+0x230>
		*key_size = 224;
 111d880:	d2801c13 	mov	x19, #0xe0                  	// #224
 111d884:	17ffffe3 	b	111d810 <tee_svc_cryp_obj_populate_type+0x144>
		*key_size = 192;
 111d888:	d2801813 	mov	x19, #0xc0                  	// #192
 111d88c:	17ffffe1 	b	111d810 <tee_svc_cryp_obj_populate_type+0x144>
				if (is_gp_legacy_des_key_size(obj_type, sz))
 111d890:	b9401300 	ldr	w0, [x24, #16]
 111d894:	b9401b01 	ldr	w1, [x24, #24]
 111d898:	97ffff11 	bl	111d4dc <is_gp_legacy_des_key_size>
				obj_size = attrs[n].content.ref.length * 8;
 111d89c:	b9400b93 	ldr	w19, [x28, #8]
				if (is_gp_legacy_des_key_size(obj_type, sz))
 111d8a0:	72001c1f 	tst	w0, #0xff
				obj_size = attrs[n].content.ref.length * 8;
 111d8a4:	531d7273 	lsl	w19, w19, #3
				if (is_gp_legacy_des_key_size(obj_type, sz))
 111d8a8:	54fffb40 	b.eq	111d810 <tee_svc_cryp_obj_populate_type+0x144>  // b.none
					obj_size -= obj_size / 8;
 111d8ac:	cb530e73 	sub	x19, x19, x19, lsr #3
 111d8b0:	17ffffd8 	b	111d810 <tee_svc_cryp_obj_populate_type+0x144>
		*key_size = 384;
 111d8b4:	d2803013 	mov	x19, #0x180                 	// #384
 111d8b8:	17ffffd6 	b	111d810 <tee_svc_cryp_obj_populate_type+0x144>
		*key_size = 256;
 111d8bc:	d2802013 	mov	x19, #0x100                 	// #256
 111d8c0:	17ffffd4 	b	111d810 <tee_svc_cryp_obj_populate_type+0x144>
	bit_ffs(a->content.ref.buffer, nbits, &v);
 111d8c4:	91000442 	add	x2, x2, #0x1
 111d8c8:	386268c3 	ldrb	w3, [x6, x2]
 111d8cc:	34fffbc3 	cbz	w3, 111d844 <tee_svc_cryp_obj_populate_type+0x178>
 111d8d0:	531d7000 	lsl	w0, w0, #3
 111d8d4:	36000083 	tbz	w3, #0, 111d8e4 <tee_svc_cryp_obj_populate_type+0x218>
 111d8d8:	6b00003f 	cmp	w1, w0
 111d8dc:	5a9fc000 	csinv	w0, w0, wzr, gt
 111d8e0:	17ffffdd 	b	111d854 <tee_svc_cryp_obj_populate_type+0x188>
 111d8e4:	11000400 	add	w0, w0, #0x1
 111d8e8:	53017c63 	lsr	w3, w3, #1
 111d8ec:	17fffffa 	b	111d8d4 <tee_svc_cryp_obj_populate_type+0x208>
 111d8f0:	12800000 	mov	w0, #0xffffffff            	// #-1
 111d8f4:	17fffff9 	b	111d8d8 <tee_svc_cryp_obj_populate_type+0x20c>
			return TEE_ERROR_ITEM_NOT_FOUND;
 111d8f8:	129ffee0 	mov	w0, #0xffff0008            	// #-65528
}
 111d8fc:	a94153f3 	ldp	x19, x20, [sp, #16]
 111d900:	a9425bf5 	ldp	x21, x22, [sp, #32]
 111d904:	a94363f7 	ldp	x23, x24, [sp, #48]
 111d908:	a9446bf9 	ldp	x25, x26, [sp, #64]
 111d90c:	a94573fb 	ldp	x27, x28, [sp, #80]
 111d910:	a8c77bfd 	ldp	x29, x30, [sp], #112
 111d914:	d65f03c0 	ret
				return TEE_ERROR_BAD_STATE;
 111d918:	129fff00 	mov	w0, #0xffff0007            	// #-65529
 111d91c:	17fffff8 	b	111d8fc <tee_svc_cryp_obj_populate_type+0x230>

000000000111d920 <op_attr_value_from_user>:
	if (size != sizeof(uint32_t) * 2)
 111d920:	f100205f 	cmp	x2, #0x8
 111d924:	54000101 	b.ne	111d944 <op_attr_value_from_user+0x24>  // b.any
{
 111d928:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	memcpy(v, buffer, sizeof(uint32_t));
 111d92c:	d2800082 	mov	x2, #0x4                   	// #4
{
 111d930:	910003fd 	mov	x29, sp
	memcpy(v, buffer, sizeof(uint32_t));
 111d934:	97ff9697 	bl	1103390 <memcpy>
	return TEE_SUCCESS;
 111d938:	52800000 	mov	w0, #0x0                   	// #0
}
 111d93c:	a8c17bfd 	ldp	x29, x30, [sp], #16
 111d940:	d65f03c0 	ret
		return TEE_ERROR_GENERIC; /* "can't happen */
 111d944:	52bfffe0 	mov	w0, #0xffff0000            	// #-65536
}
 111d948:	d65f03c0 	ret

000000000111d94c <op_attr_secret_value_from_obj>:
{
 111d94c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 111d950:	910003fd 	mov	x29, sp
	if (src_key->key_size > key->alloc_size)
 111d954:	b9400022 	ldr	w2, [x1]
{
 111d958:	a90153f3 	stp	x19, x20, [sp, #16]
 111d95c:	aa0003f3 	mov	x19, x0
	if (src_key->key_size > key->alloc_size)
 111d960:	b9400400 	ldr	w0, [x0, #4]
 111d964:	6b00005f 	cmp	w2, w0
 111d968:	54000188 	b.hi	111d998 <op_attr_secret_value_from_obj+0x4c>  // b.pmore
 111d96c:	aa0103f4 	mov	x20, x1
	memcpy(key + 1, src_key + 1, src_key->key_size);
 111d970:	2a0203e2 	mov	w2, w2
 111d974:	91002021 	add	x1, x1, #0x8
 111d978:	91002260 	add	x0, x19, #0x8
 111d97c:	97ff9685 	bl	1103390 <memcpy>
	key->key_size = src_key->key_size;
 111d980:	b9400280 	ldr	w0, [x20]
 111d984:	b9000260 	str	w0, [x19]
	return TEE_SUCCESS;
 111d988:	52800000 	mov	w0, #0x0                   	// #0
}
 111d98c:	a94153f3 	ldp	x19, x20, [sp, #16]
 111d990:	a8c27bfd 	ldp	x29, x30, [sp], #32
 111d994:	d65f03c0 	ret
		return TEE_ERROR_BAD_STATE;
 111d998:	129fff00 	mov	w0, #0xffff0007            	// #-65529
 111d99c:	17fffffc 	b	111d98c <op_attr_secret_value_from_obj+0x40>

000000000111d9a0 <op_u32_from_binary_helper>:
	if (!data || (*offs + sizeof(field)) > data_len)
 111d9a0:	b4000301 	cbz	x1, 111da00 <op_u32_from_binary_helper+0x60>
{
 111d9a4:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 111d9a8:	910003fd 	mov	x29, sp
 111d9ac:	a90153f3 	stp	x19, x20, [sp, #16]
 111d9b0:	aa0003f4 	mov	x20, x0
 111d9b4:	aa0303f3 	mov	x19, x3
	if (!data || (*offs + sizeof(field)) > data_len)
 111d9b8:	f9400060 	ldr	x0, [x3]
{
 111d9bc:	f90013f5 	str	x21, [sp, #32]
	if (!data || (*offs + sizeof(field)) > data_len)
 111d9c0:	91001015 	add	x21, x0, #0x4
 111d9c4:	eb0202bf 	cmp	x21, x2
 111d9c8:	54000208 	b.hi	111da08 <op_u32_from_binary_helper+0x68>  // b.pmore
	memcpy(&field, data + *offs, sizeof(field));
 111d9cc:	8b000021 	add	x1, x1, x0
 111d9d0:	d2800082 	mov	x2, #0x4                   	// #4
 111d9d4:	9100f3e0 	add	x0, sp, #0x3c
 111d9d8:	97ff966e 	bl	1103390 <memcpy>
	*v = TEE_U32_FROM_BIG_ENDIAN(field);
 111d9dc:	b9403fe0 	ldr	w0, [sp, #60]
 111d9e0:	5ac00800 	rev	w0, w0
 111d9e4:	b9000280 	str	w0, [x20]
	return true;
 111d9e8:	52800020 	mov	w0, #0x1                   	// #1
	(*offs) += sizeof(field);
 111d9ec:	f9000275 	str	x21, [x19]
}
 111d9f0:	a94153f3 	ldp	x19, x20, [sp, #16]
 111d9f4:	f94013f5 	ldr	x21, [sp, #32]
 111d9f8:	a8c47bfd 	ldp	x29, x30, [sp], #64
 111d9fc:	d65f03c0 	ret
		return false;
 111da00:	52800000 	mov	w0, #0x0                   	// #0
}
 111da04:	d65f03c0 	ret
		return false;
 111da08:	52800000 	mov	w0, #0x0                   	// #0
 111da0c:	17fffff9 	b	111d9f0 <op_u32_from_binary_helper+0x50>

000000000111da10 <op_attr_value_from_binary>:
	return op_u32_from_binary_helper(v, data, data_len, offs);
 111da10:	17ffffe4 	b	111d9a0 <op_u32_from_binary_helper>

000000000111da14 <op_attr_secret_value_from_binary>:
{
 111da14:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 111da18:	910003fd 	mov	x29, sp
 111da1c:	a90153f3 	stp	x19, x20, [sp, #16]
 111da20:	aa0003f3 	mov	x19, x0
	if (!op_u32_from_binary_helper(&s, data, data_len, offs))
 111da24:	910133e0 	add	x0, sp, #0x4c
{
 111da28:	a9025bf5 	stp	x21, x22, [sp, #32]
 111da2c:	aa0103f6 	mov	x22, x1
 111da30:	aa0303f5 	mov	x21, x3
 111da34:	a90363f7 	stp	x23, x24, [sp, #48]
 111da38:	aa0203f7 	mov	x23, x2
	if (!op_u32_from_binary_helper(&s, data, data_len, offs))
 111da3c:	97ffffd9 	bl	111d9a0 <op_u32_from_binary_helper>
 111da40:	72001c14 	ands	w20, w0, #0xff
 111da44:	54000240 	b.eq	111da8c <op_attr_secret_value_from_binary+0x78>  // b.none
	if ((*offs + s) > data_len)
 111da48:	f94002a1 	ldr	x1, [x21]
 111da4c:	b9404fe3 	ldr	w3, [sp, #76]
 111da50:	2a0303f8 	mov	w24, w3
 111da54:	8b234020 	add	x0, x1, w3, uxtw
 111da58:	eb17001f 	cmp	x0, x23
 111da5c:	54000248 	b.hi	111daa4 <op_attr_secret_value_from_binary+0x90>  // b.pmore
	if (s > key->alloc_size)
 111da60:	b9400660 	ldr	w0, [x19, #4]
 111da64:	6b00007f 	cmp	w3, w0
 111da68:	540001e8 	b.hi	111daa4 <op_attr_secret_value_from_binary+0x90>  // b.pmore
	key->key_size = s;
 111da6c:	aa1303e0 	mov	x0, x19
	memcpy(key + 1, (const uint8_t *)data + *offs, s);
 111da70:	aa1803e2 	mov	x2, x24
 111da74:	8b0102c1 	add	x1, x22, x1
	key->key_size = s;
 111da78:	b8008403 	str	w3, [x0], #8
	memcpy(key + 1, (const uint8_t *)data + *offs, s);
 111da7c:	97ff9645 	bl	1103390 <memcpy>
	(*offs) += s;
 111da80:	f94002a0 	ldr	x0, [x21]
 111da84:	8b180000 	add	x0, x0, x24
 111da88:	f90002a0 	str	x0, [x21]
}
 111da8c:	2a1403e0 	mov	w0, w20
 111da90:	a94153f3 	ldp	x19, x20, [sp, #16]
 111da94:	a9425bf5 	ldp	x21, x22, [sp, #32]
 111da98:	a94363f7 	ldp	x23, x24, [sp, #48]
 111da9c:	a8c57bfd 	ldp	x29, x30, [sp], #80
 111daa0:	d65f03c0 	ret
		return false;
 111daa4:	52800014 	mov	w20, #0x0                   	// #0
 111daa8:	17fffff9 	b	111da8c <op_attr_secret_value_from_binary+0x78>

000000000111daac <op_u32_to_binary_helper>:
{
 111daac:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 111dab0:	910003fd 	mov	x29, sp
 111dab4:	a90153f3 	stp	x19, x20, [sp, #16]
 111dab8:	aa0303f3 	mov	x19, x3
	if (ADD_OVERFLOW(*offs, sizeof(field), &next_offs))
 111dabc:	f9400063 	ldr	x3, [x3]
 111dac0:	b1001074 	adds	x20, x3, #0x4
 111dac4:	540000c2 	b.cs	111dadc <op_u32_to_binary_helper+0x30>  // b.hs, b.nlast
 111dac8:	aa0103e4 	mov	x4, x1
	if (data && next_offs <= data_len) {
 111dacc:	b5000101 	cbnz	x1, 111daec <op_u32_to_binary_helper+0x40>
	return TEE_SUCCESS;
 111dad0:	52800000 	mov	w0, #0x0                   	// #0
	(*offs) = next_offs;
 111dad4:	f9000274 	str	x20, [x19]
	return TEE_SUCCESS;
 111dad8:	14000002 	b	111dae0 <op_u32_to_binary_helper+0x34>
		return TEE_ERROR_OVERFLOW;
 111dadc:	1299fe00 	mov	w0, #0xffff300f            	// #-53233
}
 111dae0:	a94153f3 	ldp	x19, x20, [sp, #16]
 111dae4:	a8c37bfd 	ldp	x29, x30, [sp], #48
 111dae8:	d65f03c0 	ret
	if (data && next_offs <= data_len) {
 111daec:	eb02029f 	cmp	x20, x2
 111daf0:	54ffff08 	b.hi	111dad0 <op_u32_to_binary_helper+0x24>  // b.pmore
		field = TEE_U32_TO_BIG_ENDIAN(v);
 111daf4:	5ac00802 	rev	w2, w0
		memcpy(data + *offs, &field, sizeof(field));
 111daf8:	9100b3e1 	add	x1, sp, #0x2c
 111dafc:	8b030080 	add	x0, x4, x3
		field = TEE_U32_TO_BIG_ENDIAN(v);
 111db00:	b9002fe2 	str	w2, [sp, #44]
		memcpy(data + *offs, &field, sizeof(field));
 111db04:	d2800082 	mov	x2, #0x4                   	// #4
 111db08:	97ff9622 	bl	1103390 <memcpy>
 111db0c:	17fffff1 	b	111dad0 <op_u32_to_binary_helper+0x24>

000000000111db10 <op_attr_value_to_binary>:
	return op_u32_to_binary_helper(*v, data, data_len, offs);
 111db10:	b9400000 	ldr	w0, [x0]
 111db14:	17ffffe6 	b	111daac <op_u32_to_binary_helper>

000000000111db18 <get_user_u64_as_size_t>:
{
 111db18:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	TEE_Result res = copy_from_user(&d, src, sizeof(d));
 111db1c:	d2800102 	mov	x2, #0x8                   	// #8
{
 111db20:	910003fd 	mov	x29, sp
 111db24:	f9000bf3 	str	x19, [sp, #16]
 111db28:	aa0003f3 	mov	x19, x0
	TEE_Result res = copy_from_user(&d, src, sizeof(d));
 111db2c:	9100a3e0 	add	x0, sp, #0x28
	uint64_t d = 0;
 111db30:	f90017ff 	str	xzr, [sp, #40]
	TEE_Result res = copy_from_user(&d, src, sizeof(d));
 111db34:	97ffdcef 	bl	1114ef0 <copy_from_user>
	if (!res && ADD_OVERFLOW(0, d, dst))
 111db38:	35000060 	cbnz	w0, 111db44 <get_user_u64_as_size_t+0x2c>
 111db3c:	f94017e1 	ldr	x1, [sp, #40]
 111db40:	f9000261 	str	x1, [x19]
}
 111db44:	f9400bf3 	ldr	x19, [sp, #16]
 111db48:	a8c37bfd 	ldp	x29, x30, [sp], #48
 111db4c:	d65f03c0 	ret

000000000111db50 <op_attr_value_to_user>:
{
 111db50:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 111db54:	aa0303e1 	mov	x1, x3
 111db58:	910003fd 	mov	x29, sp
	uint32_t value[2] = { *v };
 111db5c:	b9400000 	ldr	w0, [x0]
{
 111db60:	f9000bf3 	str	x19, [sp, #16]
 111db64:	aa0203f3 	mov	x19, x2
	res = copy_from_user(&s, size, sizeof(s));
 111db68:	d2800102 	mov	x2, #0x8                   	// #8
	uint32_t value[2] = { *v };
 111db6c:	29057fe0 	stp	w0, wzr, [sp, #40]
	res = copy_from_user(&s, size, sizeof(s));
 111db70:	910083e0 	add	x0, sp, #0x20
 111db74:	97ffdcdf 	bl	1114ef0 <copy_from_user>
	if (res != TEE_SUCCESS)
 111db78:	35000120 	cbnz	w0, 111db9c <op_attr_value_to_user+0x4c>
	if (s < req_size || !buffer)
 111db7c:	f94013e0 	ldr	x0, [sp, #32]
 111db80:	f1001c1f 	cmp	x0, #0x7
 111db84:	54000129 	b.ls	111dba8 <op_attr_value_to_user+0x58>  // b.plast
 111db88:	b4000113 	cbz	x19, 111dba8 <op_attr_value_to_user+0x58>
	return copy_to_user(buffer, value, req_size);
 111db8c:	9100a3e1 	add	x1, sp, #0x28
 111db90:	aa1303e0 	mov	x0, x19
 111db94:	d2800102 	mov	x2, #0x8                   	// #8
 111db98:	97ffdcea 	bl	1114f40 <copy_to_user>
}
 111db9c:	f9400bf3 	ldr	x19, [sp, #16]
 111dba0:	a8c37bfd 	ldp	x29, x30, [sp], #48
 111dba4:	d65f03c0 	ret
		return TEE_ERROR_SHORT_BUFFER;
 111dba8:	129ffde0 	mov	w0, #0xffff0010            	// #-65520
 111dbac:	17fffffc 	b	111db9c <op_attr_value_to_user+0x4c>

000000000111dbb0 <op_attr_secret_value_to_user>:
{
 111dbb0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
	res = copy_from_user(&s, size, sizeof(s));
 111dbb4:	aa0303e1 	mov	x1, x3
{
 111dbb8:	910003fd 	mov	x29, sp
 111dbbc:	a90153f3 	stp	x19, x20, [sp, #16]
 111dbc0:	aa0003f3 	mov	x19, x0
 111dbc4:	aa0203f4 	mov	x20, x2
	res = copy_from_user(&s, size, sizeof(s));
 111dbc8:	9100c3e0 	add	x0, sp, #0x30
 111dbcc:	d2800102 	mov	x2, #0x8                   	// #8
{
 111dbd0:	f90013f5 	str	x21, [sp, #32]
 111dbd4:	aa0303f5 	mov	x21, x3
	res = copy_from_user(&s, size, sizeof(s));
 111dbd8:	97ffdcc6 	bl	1114ef0 <copy_from_user>
	if (res != TEE_SUCCESS)
 111dbdc:	35000200 	cbnz	w0, 111dc1c <op_attr_secret_value_to_user+0x6c>
	key_size = key->key_size;
 111dbe0:	b9400260 	ldr	w0, [x19]
	res = copy_to_user(size, &key_size, sizeof(key_size));
 111dbe4:	9100e3e1 	add	x1, sp, #0x38
 111dbe8:	d2800102 	mov	x2, #0x8                   	// #8
	key_size = key->key_size;
 111dbec:	f9001fe0 	str	x0, [sp, #56]
	res = copy_to_user(size, &key_size, sizeof(key_size));
 111dbf0:	aa1503e0 	mov	x0, x21
 111dbf4:	97ffdcd3 	bl	1114f40 <copy_to_user>
	if (res != TEE_SUCCESS)
 111dbf8:	35000120 	cbnz	w0, 111dc1c <op_attr_secret_value_to_user+0x6c>
	if (s < key->key_size || !buffer)
 111dbfc:	f9401be0 	ldr	x0, [sp, #48]
 111dc00:	b9400262 	ldr	w2, [x19]
 111dc04:	eb00005f 	cmp	x2, x0
 111dc08:	54000128 	b.hi	111dc2c <op_attr_secret_value_to_user+0x7c>  // b.pmore
 111dc0c:	b4000114 	cbz	x20, 111dc2c <op_attr_secret_value_to_user+0x7c>
	return copy_to_user(buffer, key + 1, key->key_size);
 111dc10:	91002261 	add	x1, x19, #0x8
 111dc14:	aa1403e0 	mov	x0, x20
 111dc18:	97ffdcca 	bl	1114f40 <copy_to_user>
}
 111dc1c:	a94153f3 	ldp	x19, x20, [sp, #16]
 111dc20:	f94013f5 	ldr	x21, [sp, #32]
 111dc24:	a8c47bfd 	ldp	x29, x30, [sp], #64
 111dc28:	d65f03c0 	ret
		return TEE_ERROR_SHORT_BUFFER;
 111dc2c:	129ffde0 	mov	w0, #0xffff0010            	// #-65520
 111dc30:	17fffffb 	b	111dc1c <op_attr_secret_value_to_user+0x6c>

000000000111dc34 <put_user_u64>:
{
 111dc34:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	return copy_to_user(dst, &v, sizeof(v));
 111dc38:	d2800102 	mov	x2, #0x8                   	// #8
{
 111dc3c:	910003fd 	mov	x29, sp
	uint64_t v = value;
 111dc40:	f9000fe1 	str	x1, [sp, #24]
	return copy_to_user(dst, &v, sizeof(v));
 111dc44:	910063e1 	add	x1, sp, #0x18
 111dc48:	97ffdcbe 	bl	1114f40 <copy_to_user>
}
 111dc4c:	a8c27bfd 	ldp	x29, x30, [sp], #32
 111dc50:	d65f03c0 	ret

000000000111dc54 <op_attr_bignum_clear>:
	crypto_bignum_clear(*bn);
 111dc54:	f9400000 	ldr	x0, [x0]
 111dc58:	14004193 	b	112e2a4 <crypto_bignum_clear>

000000000111dc5c <op_attr_bignum_free>:
{
 111dc5c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 111dc60:	910003fd 	mov	x29, sp
 111dc64:	f9000bf3 	str	x19, [sp, #16]
 111dc68:	aa0003f3 	mov	x19, x0
	crypto_bignum_free(*bn);
 111dc6c:	f9400000 	ldr	x0, [x0]
 111dc70:	94004184 	bl	112e280 <crypto_bignum_free>
	*bn = NULL;
 111dc74:	f900027f 	str	xzr, [x19]
}
 111dc78:	f9400bf3 	ldr	x19, [sp, #16]
 111dc7c:	a8c27bfd 	ldp	x29, x30, [sp], #32
 111dc80:	d65f03c0 	ret

000000000111dc84 <op_attr_bignum_from_obj>:
{
 111dc84:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 111dc88:	910003fd 	mov	x29, sp
	crypto_bignum_copy(*bn, *src_bn);
 111dc8c:	f9400000 	ldr	x0, [x0]
 111dc90:	f9400021 	ldr	x1, [x1]
 111dc94:	94004156 	bl	112e1ec <crypto_bignum_copy>
}
 111dc98:	52800000 	mov	w0, #0x0                   	// #0
 111dc9c:	a8c17bfd 	ldp	x29, x30, [sp], #16
 111dca0:	d65f03c0 	ret

000000000111dca4 <op_attr_bignum_from_binary>:
{
 111dca4:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 111dca8:	910003fd 	mov	x29, sp
 111dcac:	a90153f3 	stp	x19, x20, [sp, #16]
 111dcb0:	aa0303f4 	mov	x20, x3
 111dcb4:	a9025bf5 	stp	x21, x22, [sp, #32]
 111dcb8:	aa0003f6 	mov	x22, x0
 111dcbc:	aa0103f5 	mov	x21, x1
	if (!op_u32_from_binary_helper(&n, data, data_len, offs))
 111dcc0:	910133e0 	add	x0, sp, #0x4c
{
 111dcc4:	f9001bf7 	str	x23, [sp, #48]
 111dcc8:	aa0203f7 	mov	x23, x2
	if (!op_u32_from_binary_helper(&n, data, data_len, offs))
 111dccc:	97ffff35 	bl	111d9a0 <op_u32_from_binary_helper>
 111dcd0:	72001c13 	ands	w19, w0, #0xff
 111dcd4:	54000101 	b.ne	111dcf4 <op_attr_bignum_from_binary+0x50>  // b.any
		return false;
 111dcd8:	52800013 	mov	w19, #0x0                   	// #0
}
 111dcdc:	2a1303e0 	mov	w0, w19
 111dce0:	a94153f3 	ldp	x19, x20, [sp, #16]
 111dce4:	a9425bf5 	ldp	x21, x22, [sp, #32]
 111dce8:	f9401bf7 	ldr	x23, [sp, #48]
 111dcec:	a8c57bfd 	ldp	x29, x30, [sp], #80
 111dcf0:	d65f03c0 	ret
	if ((*offs + n) > data_len)
 111dcf4:	f9400280 	ldr	x0, [x20]
 111dcf8:	b9404fe1 	ldr	w1, [sp, #76]
 111dcfc:	8b010002 	add	x2, x0, x1
 111dd00:	eb17005f 	cmp	x2, x23
 111dd04:	54fffea8 	b.hi	111dcd8 <op_attr_bignum_from_binary+0x34>  // b.pmore
	if (crypto_bignum_bin2bn((const uint8_t *)data + *offs, n, *bn))
 111dd08:	f94002c2 	ldr	x2, [x22]
 111dd0c:	8b0002a0 	add	x0, x21, x0
 111dd10:	9400412b 	bl	112e1bc <crypto_bignum_bin2bn>
 111dd14:	35fffe20 	cbnz	w0, 111dcd8 <op_attr_bignum_from_binary+0x34>
	(*offs) += n;
 111dd18:	f9400280 	ldr	x0, [x20]
 111dd1c:	b9404fe1 	ldr	w1, [sp, #76]
 111dd20:	8b010000 	add	x0, x0, x1
 111dd24:	f9000280 	str	x0, [x20]
	return true;
 111dd28:	17ffffed 	b	111dcdc <op_attr_bignum_from_binary+0x38>

000000000111dd2c <op_attr_bignum_from_user>:
{
 111dd2c:	aa0003e3 	mov	x3, x0
 111dd30:	aa0103e0 	mov	x0, x1
 111dd34:	aa0203e1 	mov	x1, x2
	return crypto_bignum_bin2bn(buffer, size, *bn);
 111dd38:	f9400062 	ldr	x2, [x3]
 111dd3c:	14004120 	b	112e1bc <crypto_bignum_bin2bn>

000000000111dd40 <op_attr_bignum_to_binary>:
{
 111dd40:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 111dd44:	910003fd 	mov	x29, sp
 111dd48:	a90363f7 	stp	x23, x24, [sp, #48]
 111dd4c:	aa0003f7 	mov	x23, x0
 111dd50:	aa0203f8 	mov	x24, x2
	uint32_t n = crypto_bignum_num_bytes(*bn);
 111dd54:	f9400000 	ldr	x0, [x0]
{
 111dd58:	a90153f3 	stp	x19, x20, [sp, #16]
 111dd5c:	a9025bf5 	stp	x21, x22, [sp, #32]
 111dd60:	aa0103f6 	mov	x22, x1
 111dd64:	aa0303f5 	mov	x21, x3
	uint32_t n = crypto_bignum_num_bytes(*bn);
 111dd68:	940040fd 	bl	112e15c <crypto_bignum_num_bytes>
 111dd6c:	aa0003f3 	mov	x19, x0
	res = op_u32_to_binary_helper(n, data, data_len, offs);
 111dd70:	aa1503e3 	mov	x3, x21
 111dd74:	aa1803e2 	mov	x2, x24
 111dd78:	aa1603e1 	mov	x1, x22
 111dd7c:	97ffff4c 	bl	111daac <op_u32_to_binary_helper>
 111dd80:	2a0003f4 	mov	w20, w0
	if (res != TEE_SUCCESS)
 111dd84:	35000120 	cbnz	w0, 111dda8 <op_attr_bignum_to_binary+0x68>
	if (ADD_OVERFLOW(*offs, n, &next_offs))
 111dd88:	f94002a1 	ldr	x1, [x21]
 111dd8c:	2a1303f3 	mov	w19, w19
 111dd90:	ab130033 	adds	x19, x1, x19
 111dd94:	54000082 	b.cs	111dda4 <op_attr_bignum_to_binary+0x64>  // b.hs, b.nlast
	if (data && next_offs <= data_len)
 111dd98:	b5000156 	cbnz	x22, 111ddc0 <op_attr_bignum_to_binary+0x80>
	(*offs) = next_offs;
 111dd9c:	f90002b3 	str	x19, [x21]
	return TEE_SUCCESS;
 111dda0:	14000002 	b	111dda8 <op_attr_bignum_to_binary+0x68>
		return TEE_ERROR_OVERFLOW;
 111dda4:	1299fe14 	mov	w20, #0xffff300f            	// #-53233
}
 111dda8:	2a1403e0 	mov	w0, w20
 111ddac:	a94153f3 	ldp	x19, x20, [sp, #16]
 111ddb0:	a9425bf5 	ldp	x21, x22, [sp, #32]
 111ddb4:	a94363f7 	ldp	x23, x24, [sp, #48]
 111ddb8:	a8c47bfd 	ldp	x29, x30, [sp], #64
 111ddbc:	d65f03c0 	ret
	if (data && next_offs <= data_len)
 111ddc0:	eb18027f 	cmp	x19, x24
 111ddc4:	54fffec8 	b.hi	111dd9c <op_attr_bignum_to_binary+0x5c>  // b.pmore
		crypto_bignum_bn2bin(*bn, (uint8_t *)data + *offs);
 111ddc8:	f94002e0 	ldr	x0, [x23]
 111ddcc:	8b0102c1 	add	x1, x22, x1
 111ddd0:	940040e4 	bl	112e160 <crypto_bignum_bn2bin>
 111ddd4:	17fffff2 	b	111dd9c <op_attr_bignum_to_binary+0x5c>

000000000111ddd8 <copy_in_attrs>:
{
 111ddd8:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 111dddc:	910003fd 	mov	x29, sp
 111dde0:	a9025bf5 	stp	x21, x22, [sp, #32]
	if (MUL_OVERFLOW(sizeof(struct utee_attribute), attr_count, &size))
 111dde4:	52800315 	mov	w21, #0x18                  	// #24
 111dde8:	9bb57c55 	umull	x21, w2, w21
{
 111ddec:	a90363f7 	stp	x23, x24, [sp, #48]
	res = vm_check_access_rights(&utc->uctx,
 111ddf0:	91014017 	add	x23, x0, #0x50
 111ddf4:	aa0103e2 	mov	x2, x1
 111ddf8:	aa1703e0 	mov	x0, x23
{
 111ddfc:	a90153f3 	stp	x19, x20, [sp, #16]
 111de00:	aa0303f3 	mov	x19, x3
	res = vm_check_access_rights(&utc->uctx,
 111de04:	aa0103f4 	mov	x20, x1
 111de08:	aa1503e3 	mov	x3, x21
 111de0c:	528000a1 	mov	w1, #0x5                   	// #5
{
 111de10:	f90023f9 	str	x25, [sp, #64]
	res = vm_check_access_rights(&utc->uctx,
 111de14:	97ffee76 	bl	11197ec <vm_check_access_rights>
 111de18:	2a0003f6 	mov	w22, w0
	if (res != TEE_SUCCESS)
 111de1c:	35000080 	cbnz	w0, 111de2c <copy_in_attrs+0x54>
 111de20:	8b150275 	add	x21, x19, x21
	for (n = 0; n < attr_count; n++) {
 111de24:	eb15027f 	cmp	x19, x21
 111de28:	54000101 	b.ne	111de48 <copy_in_attrs+0x70>  // b.any
}
 111de2c:	2a1603e0 	mov	w0, w22
 111de30:	a94153f3 	ldp	x19, x20, [sp, #16]
 111de34:	a9425bf5 	ldp	x21, x22, [sp, #32]
 111de38:	a94363f7 	ldp	x23, x24, [sp, #48]
 111de3c:	f94023f9 	ldr	x25, [sp, #64]
 111de40:	a8c57bfd 	ldp	x29, x30, [sp], #80
 111de44:	d65f03c0 	ret
		attrs[n].attributeID = usr_attrs[n].attribute_id;
 111de48:	b9401280 	ldr	w0, [x20, #16]
 111de4c:	a9406299 	ldp	x25, x24, [x20]
 111de50:	b9000260 	str	w0, [x19]
		if (attrs[n].attributeID & TEE_ATTR_FLAG_VALUE) {
 111de54:	36e800a0 	tbz	w0, #29, 111de68 <copy_in_attrs+0x90>
			attrs[n].content.value.b = usr_attrs[n].b;
 111de58:	29016279 	stp	w25, w24, [x19, #8]
	for (n = 0; n < attr_count; n++) {
 111de5c:	91006273 	add	x19, x19, #0x18
 111de60:	91006294 	add	x20, x20, #0x18
 111de64:	17fffff0 	b	111de24 <copy_in_attrs+0x4c>
			res = vm_check_access_rights(&utc->uctx, flags, buf,
 111de68:	aa1803e3 	mov	x3, x24
 111de6c:	aa1903e2 	mov	x2, x25
 111de70:	aa1703e0 	mov	x0, x23
 111de74:	528000a1 	mov	w1, #0x5                   	// #5
 111de78:	97ffee5d 	bl	11197ec <vm_check_access_rights>
			if (res != TEE_SUCCESS)
 111de7c:	35000080 	cbnz	w0, 111de8c <copy_in_attrs+0xb4>
			attrs[n].content.ref.buffer = (void *)buf;
 111de80:	f9000679 	str	x25, [x19, #8]
			attrs[n].content.ref.length = len;
 111de84:	b9001278 	str	w24, [x19, #16]
 111de88:	17fffff5 	b	111de5c <copy_in_attrs+0x84>
			res = vm_check_access_rights(&utc->uctx, flags, buf,
 111de8c:	2a0003f6 	mov	w22, w0
 111de90:	17ffffe7 	b	111de2c <copy_in_attrs+0x54>

000000000111de94 <op_attr_secret_value_clear>:
	memzero_explicit(key + 1, key->alloc_size);
 111de94:	b9400401 	ldr	w1, [x0, #4]
 111de98:	91002000 	add	x0, x0, #0x8
	key->key_size = 0;
 111de9c:	b81f801f 	stur	wzr, [x0, #-8]
	memzero_explicit(key + 1, key->alloc_size);
 111dea0:	14009c58 	b	1145000 <memzero_explicit>

000000000111dea4 <cryp_state_free>:
	}
	return TEE_ERROR_BAD_PARAMETERS;
}

static void cryp_state_free(struct user_ta_ctx *utc, struct tee_cryp_state *cs)
{
 111dea4:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 111dea8:	910003fd 	mov	x29, sp
 111deac:	a90153f3 	stp	x19, x20, [sp, #16]
 111deb0:	aa0103f3 	mov	x19, x1
 111deb4:	aa0003f4 	mov	x20, x0
	struct tee_obj *o;

	if (tee_obj_get(utc, cs->key1, &o) == TEE_SUCCESS)
 111deb8:	f9400c21 	ldr	x1, [x1, #24]
{
 111debc:	f90013f5 	str	x21, [sp, #32]
	if (tee_obj_get(utc, cs->key1, &o) == TEE_SUCCESS)
 111dec0:	9100e3f5 	add	x21, sp, #0x38
 111dec4:	aa1503e2 	mov	x2, x21
 111dec8:	9400202d 	bl	1125f7c <tee_obj_get>
 111decc:	35000080 	cbnz	w0, 111dedc <cryp_state_free+0x38>
		tee_obj_close(utc, o);
 111ded0:	f9401fe1 	ldr	x1, [sp, #56]
 111ded4:	aa1403e0 	mov	x0, x20
 111ded8:	94002044 	bl	1125fe8 <tee_obj_close>
	if (tee_obj_get(utc, cs->key2, &o) == TEE_SUCCESS)
 111dedc:	f9401261 	ldr	x1, [x19, #32]
 111dee0:	aa1503e2 	mov	x2, x21
 111dee4:	aa1403e0 	mov	x0, x20
 111dee8:	94002025 	bl	1125f7c <tee_obj_get>
 111deec:	35000080 	cbnz	w0, 111defc <cryp_state_free+0x58>
		tee_obj_close(utc, o);
 111def0:	f9401fe1 	ldr	x1, [sp, #56]
 111def4:	aa1403e0 	mov	x0, x20
 111def8:	9400203c 	bl	1125fe8 <tee_obj_close>

	TAILQ_REMOVE(&utc->cryp_states, cs, link);
 111defc:	a9400660 	ldp	x0, x1, [x19]
 111df00:	b4000280 	cbz	x0, 111df50 <cryp_state_free+0xac>
 111df04:	f9000401 	str	x1, [x0, #8]
 111df08:	f9400661 	ldr	x1, [x19, #8]
 111df0c:	f9000020 	str	x0, [x1]
	if (cs->ctx_finalize != NULL)
 111df10:	f9401a61 	ldr	x1, [x19, #48]
 111df14:	b4000061 	cbz	x1, 111df20 <cryp_state_free+0x7c>
		cs->ctx_finalize(cs->ctx);
 111df18:	f9401660 	ldr	x0, [x19, #40]
 111df1c:	d63f0020 	blr	x1

	switch (TEE_ALG_GET_CLASS(cs->algo)) {
 111df20:	b9401260 	ldr	w0, [x19, #16]
 111df24:	97fffd24 	bl	111d3b4 <__tee_alg_get_class>
 111df28:	51000401 	sub	w1, w0, #0x1
 111df2c:	7100103f 	cmp	w1, #0x4
 111df30:	f9401660 	ldr	x0, [x19, #40]
 111df34:	540002a8 	b.hi	111df88 <cryp_state_free+0xe4>  // b.pmore
 111df38:	b0000182 	adrp	x2, 114e000 <ldelf_data+0x8000>
 111df3c:	911c5042 	add	x2, x2, #0x714
 111df40:	38614841 	ldrb	w1, [x2, w1, uxtw]
 111df44:	10000062 	adr	x2, 111df50 <cryp_state_free+0xac>
 111df48:	8b218841 	add	x1, x2, w1, sxtb #2
 111df4c:	d61f0020 	br	x1
	TAILQ_REMOVE(&utc->cryp_states, cs, link);
 111df50:	f9000e81 	str	x1, [x20, #24]
 111df54:	17ffffed 	b	111df08 <cryp_state_free+0x64>
	case TEE_OPERATION_CIPHER:
		crypto_cipher_free_ctx(cs->ctx);
 111df58:	97ffbd73 	bl	110d524 <crypto_cipher_free_ctx>
		break;
	default:
		assert(!cs->ctx);
	}

	free(cs);
 111df5c:	aa1303e0 	mov	x0, x19
}
 111df60:	a94153f3 	ldp	x19, x20, [sp, #16]
 111df64:	f94013f5 	ldr	x21, [sp, #32]
 111df68:	a8c47bfd 	ldp	x29, x30, [sp], #64
	free(cs);
 111df6c:	1400959d 	b	11435e0 <free>
		crypto_authenc_free_ctx(cs->ctx);
 111df70:	97ffbf5e 	bl	110dce8 <crypto_authenc_free_ctx>
		break;
 111df74:	17fffffa 	b	111df5c <cryp_state_free+0xb8>
		crypto_hash_free_ctx(cs->ctx);
 111df78:	97ffbcc6 	bl	110d290 <crypto_hash_free_ctx>
		break;
 111df7c:	17fffff8 	b	111df5c <cryp_state_free+0xb8>
		crypto_mac_free_ctx(cs->ctx);
 111df80:	97ffbe4f 	bl	110d8bc <crypto_mac_free_ctx>
		break;
 111df84:	17fffff6 	b	111df5c <cryp_state_free+0xb8>
		assert(!cs->ctx);
 111df88:	b4fffea0 	cbz	x0, 111df5c <cryp_state_free+0xb8>
 111df8c:	900001c3 	adrp	x3, 1155000 <__func__.3826+0xa8>
 111df90:	900001c1 	adrp	x1, 1155000 <__func__.3826+0xa8>
 111df94:	9124ec63 	add	x3, x3, #0x93b
 111df98:	9123d421 	add	x1, x1, #0x8f5
 111df9c:	900001c0 	adrp	x0, 1155000 <__func__.3826+0xa8>
 111dfa0:	91243400 	add	x0, x0, #0x90d
 111dfa4:	52810042 	mov	w2, #0x802                 	// #2050
 111dfa8:	97ffd0c1 	bl	11122ac <_assert_log>
 111dfac:	97ffd0d1 	bl	11122f0 <_assert_break>

000000000111dfb0 <set_attribute.isra.0>:
static void set_attribute(struct tee_obj *o,
 111dfb0:	aa0003e7 	mov	x7, x0
 111dfb4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 111dfb8:	2a0203e0 	mov	w0, w2
 111dfbc:	910003fd 	mov	x29, sp
	int idx = tee_svc_cryp_obj_find_type_attr_idx(attr, props);
 111dfc0:	97fffd29 	bl	111d464 <tee_svc_cryp_obj_find_type_attr_idx>
	if (idx < 0)
 111dfc4:	37f800c0 	tbnz	w0, #31, 111dfdc <set_attribute.isra.0+0x2c>
	o->have_attrs |= BIT(idx);
 111dfc8:	52800021 	mov	w1, #0x1                   	// #1
 111dfcc:	1ac02021 	lsl	w1, w1, w0
 111dfd0:	b94000e0 	ldr	w0, [x7]
 111dfd4:	2a010000 	orr	w0, w0, w1
 111dfd8:	b90000e0 	str	w0, [x7]
}
 111dfdc:	a8c17bfd 	ldp	x29, x30, [sp], #16
 111dfe0:	d65f03c0 	ret

000000000111dfe4 <tee_svc_cryp_check_key_type.isra.0>:

static TEE_Result tee_svc_cryp_check_key_type(const struct tee_obj *o,
 111dfe4:	aa0003e4 	mov	x4, x0
 111dfe8:	2a0203e3 	mov	w3, w2
 111dfec:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 111dff0:	2a0103e0 	mov	w0, w1
 111dff4:	910003fd 	mov	x29, sp
					      TEE_OperationMode mode)
{
	uint32_t req_key_type;
	uint32_t req_key_type2 = 0;

	switch (TEE_ALG_GET_MAIN_ALG(algo)) {
 111dff8:	97fffd08 	bl	111d418 <__tee_alg_get_main_alg>
 111dffc:	71011c1f 	cmp	w0, #0x47
 111e000:	540004c8 	b.hi	111e098 <tee_svc_cryp_check_key_type.isra.0+0xb4>  // b.pmore
 111e004:	7100bc1f 	cmp	w0, #0x2f
 111e008:	540000c8 	b.hi	111e020 <tee_svc_cryp_check_key_type.isra.0+0x3c>  // b.pmore
 111e00c:	51000401 	sub	w1, w0, #0x1
 111e010:	71004c3f 	cmp	w1, #0x13
 111e014:	540002e9 	b.ls	111e070 <tee_svc_cryp_check_key_type.isra.0+0x8c>  // b.plast
 111e018:	129fff20 	mov	w0, #0xffff0006            	// #-65530
 111e01c:	14000013 	b	111e068 <tee_svc_cryp_check_key_type.isra.0+0x84>
 111e020:	5100c001 	sub	w1, w0, #0x30
 111e024:	71005c3f 	cmp	w1, #0x17
 111e028:	54ffff88 	b.hi	111e018 <tee_svc_cryp_check_key_type.isra.0+0x34>  // b.pmore
 111e02c:	90000180 	adrp	x0, 114e000 <ldelf_data+0x8000>
 111e030:	911c7000 	add	x0, x0, #0x71c
 111e034:	38614800 	ldrb	w0, [x0, w1, uxtw]
 111e038:	10000061 	adr	x1, 111e044 <tee_svc_cryp_check_key_type.isra.0+0x60>
 111e03c:	8b208820 	add	x0, x1, w0, sxtb #2
 111e040:	d61f0000 	br	x0
	uint32_t req_key_type2 = 0;
 111e044:	52800003 	mov	w3, #0x0                   	// #0
		req_key_type = TEE_TYPE_DSA_KEYPAIR;
		if (mode == TEE_MODE_ENCRYPT || mode == TEE_MODE_VERIFY)
			req_key_type2 = TEE_TYPE_DSA_PUBLIC_KEY;
		break;
	case TEE_MAIN_ALGO_DH:
		req_key_type = TEE_TYPE_DH_KEYPAIR;
 111e048:	52800641 	mov	w1, #0x32                  	// #50
		else
			req_key_type = TEE_TYPE_SM2_DSA_KEYPAIR;
		break;
#if defined(CFG_CRYPTO_SM2_KEP)
	case TEE_MAIN_ALGO_SM2_KEP:
		req_key_type = TEE_TYPE_SM2_KEP_KEYPAIR;
 111e04c:	72b42001 	movk	w1, #0xa100, lsl #16
#endif
	default:
		return TEE_ERROR_BAD_PARAMETERS;
	}

	if (req_key_type != o->info.objectType &&
 111e050:	b9400080 	ldr	w0, [x4]
 111e054:	6b01001f 	cmp	w0, w1
 111e058:	54000ca0 	b.eq	111e1ec <tee_svc_cryp_check_key_type.isra.0+0x208>  // b.none
	    req_key_type2 != o->info.objectType)
		return TEE_ERROR_BAD_PARAMETERS;
 111e05c:	6b03001f 	cmp	w0, w3
 111e060:	129fff20 	mov	w0, #0xffff0006            	// #-65530
 111e064:	1a8003e0 	csel	w0, wzr, w0, eq  // eq = none
	return TEE_SUCCESS;
}
 111e068:	a8c17bfd 	ldp	x29, x30, [sp], #16
 111e06c:	d65f03c0 	ret
 111e070:	90000180 	adrp	x0, 114e000 <ldelf_data+0x8000>
 111e074:	911cd000 	add	x0, x0, #0x734
 111e078:	38614800 	ldrb	w0, [x0, w1, uxtw]
 111e07c:	10000061 	adr	x1, 111e088 <tee_svc_cryp_check_key_type.isra.0+0xa4>
 111e080:	8b208820 	add	x0, x1, w0, sxtb #2
 111e084:	d61f0000 	br	x0
	switch (TEE_ALG_GET_MAIN_ALG(algo)) {
 111e088:	52800003 	mov	w3, #0x0                   	// #0
 111e08c:	52800041 	mov	w1, #0x2                   	// #2
			req_key_type = TEE_TYPE_SM2_DSA_PUBLIC_KEY;
 111e090:	72b40001 	movk	w1, #0xa000, lsl #16
 111e094:	17ffffef 	b	111e050 <tee_svc_cryp_check_key_type.isra.0+0x6c>
	switch (TEE_ALG_GET_MAIN_ALG(algo)) {
 111e098:	7103041f 	cmp	w0, #0xc1
 111e09c:	54000940 	b.eq	111e1c4 <tee_svc_cryp_check_key_type.isra.0+0x1e0>  // b.none
 111e0a0:	7103081f 	cmp	w0, #0xc2
 111e0a4:	54000960 	b.eq	111e1d0 <tee_svc_cryp_check_key_type.isra.0+0x1ec>  // b.none
 111e0a8:	7103001f 	cmp	w0, #0xc0
 111e0ac:	54fffb61 	b.ne	111e018 <tee_svc_cryp_check_key_type.isra.0+0x34>  // b.any
	uint32_t req_key_type2 = 0;
 111e0b0:	52800003 	mov	w3, #0x0                   	// #0
		req_key_type = TEE_TYPE_HKDF_IKM;
 111e0b4:	52801801 	mov	w1, #0xc0                  	// #192
 111e0b8:	17ffffe5 	b	111e04c <tee_svc_cryp_check_key_type.isra.0+0x68>
	uint32_t req_key_type2 = 0;
 111e0bc:	52800003 	mov	w3, #0x0                   	// #0
		req_key_type = TEE_TYPE_HMAC_SHA224;
 111e0c0:	52800061 	mov	w1, #0x3                   	// #3
 111e0c4:	17fffff3 	b	111e090 <tee_svc_cryp_check_key_type.isra.0+0xac>
	uint32_t req_key_type2 = 0;
 111e0c8:	52800003 	mov	w3, #0x0                   	// #0
		req_key_type = TEE_TYPE_HMAC_SHA256;
 111e0cc:	52800081 	mov	w1, #0x4                   	// #4
 111e0d0:	17fffff0 	b	111e090 <tee_svc_cryp_check_key_type.isra.0+0xac>
	uint32_t req_key_type2 = 0;
 111e0d4:	52800003 	mov	w3, #0x0                   	// #0
		req_key_type = TEE_TYPE_HMAC_SHA384;
 111e0d8:	528000a1 	mov	w1, #0x5                   	// #5
 111e0dc:	17ffffed 	b	111e090 <tee_svc_cryp_check_key_type.isra.0+0xac>
	uint32_t req_key_type2 = 0;
 111e0e0:	52800003 	mov	w3, #0x0                   	// #0
		req_key_type = TEE_TYPE_HMAC_SHA512;
 111e0e4:	528000c1 	mov	w1, #0x6                   	// #6
 111e0e8:	17ffffea 	b	111e090 <tee_svc_cryp_check_key_type.isra.0+0xac>
	uint32_t req_key_type2 = 0;
 111e0ec:	52800003 	mov	w3, #0x0                   	// #0
		req_key_type = TEE_TYPE_HMAC_SM3;
 111e0f0:	528000e1 	mov	w1, #0x7                   	// #7
 111e0f4:	17ffffe7 	b	111e090 <tee_svc_cryp_check_key_type.isra.0+0xac>
	uint32_t req_key_type2 = 0;
 111e0f8:	52800003 	mov	w3, #0x0                   	// #0
		req_key_type = TEE_TYPE_AES;
 111e0fc:	52800201 	mov	w1, #0x10                  	// #16
 111e100:	17ffffe4 	b	111e090 <tee_svc_cryp_check_key_type.isra.0+0xac>
	uint32_t req_key_type2 = 0;
 111e104:	52800003 	mov	w3, #0x0                   	// #0
		req_key_type = TEE_TYPE_DES;
 111e108:	52800221 	mov	w1, #0x11                  	// #17
 111e10c:	17ffffe1 	b	111e090 <tee_svc_cryp_check_key_type.isra.0+0xac>
	uint32_t req_key_type2 = 0;
 111e110:	52800003 	mov	w3, #0x0                   	// #0
		req_key_type = TEE_TYPE_DES3;
 111e114:	52800261 	mov	w1, #0x13                  	// #19
 111e118:	17ffffde 	b	111e090 <tee_svc_cryp_check_key_type.isra.0+0xac>
	uint32_t req_key_type2 = 0;
 111e11c:	52800003 	mov	w3, #0x0                   	// #0
		req_key_type = TEE_TYPE_SM4;
 111e120:	52800281 	mov	w1, #0x14                  	// #20
 111e124:	17ffffdb 	b	111e090 <tee_svc_cryp_check_key_type.isra.0+0xac>
		if (mode == TEE_MODE_ENCRYPT || mode == TEE_MODE_VERIFY)
 111e128:	7100007f 	cmp	w3, #0x0
			req_key_type2 = TEE_TYPE_RSA_PUBLIC_KEY;
 111e12c:	52800601 	mov	w1, #0x30                  	// #48
 111e130:	7a431864 	ccmp	w3, #0x3, #0x4, ne  // ne = any
 111e134:	52800603 	mov	w3, #0x30                  	// #48
 111e138:	72b40003 	movk	w3, #0xa000, lsl #16
 111e13c:	1a8313e3 	csel	w3, wzr, w3, ne  // ne = any
 111e140:	17ffffc3 	b	111e04c <tee_svc_cryp_check_key_type.isra.0+0x68>
		if (mode == TEE_MODE_ENCRYPT || mode == TEE_MODE_VERIFY)
 111e144:	7100007f 	cmp	w3, #0x0
			req_key_type2 = TEE_TYPE_DSA_PUBLIC_KEY;
 111e148:	52800621 	mov	w1, #0x31                  	// #49
 111e14c:	7a431864 	ccmp	w3, #0x3, #0x4, ne  // ne = any
 111e150:	52800623 	mov	w3, #0x31                  	// #49
 111e154:	72b40003 	movk	w3, #0xa000, lsl #16
 111e158:	1a8313e3 	csel	w3, wzr, w3, ne  // ne = any
 111e15c:	17ffffbc 	b	111e04c <tee_svc_cryp_check_key_type.isra.0+0x68>
		if (mode == TEE_MODE_VERIFY)
 111e160:	71000c7f 	cmp	w3, #0x3
 111e164:	540003c1 	b.ne	111e1dc <tee_svc_cryp_check_key_type.isra.0+0x1f8>  // b.any
			req_key_type2 = TEE_TYPE_ECDSA_PUBLIC_KEY;
 111e168:	52800823 	mov	w3, #0x41                  	// #65
 111e16c:	72b40003 	movk	w3, #0xa000, lsl #16
		req_key_type = TEE_TYPE_ECDSA_KEYPAIR;
 111e170:	52800821 	mov	w1, #0x41                  	// #65
 111e174:	17ffffb6 	b	111e04c <tee_svc_cryp_check_key_type.isra.0+0x68>
		if (mode == TEE_MODE_ENCRYPT)
 111e178:	34000363 	cbz	w3, 111e1e4 <tee_svc_cryp_check_key_type.isra.0+0x200>
	uint32_t req_key_type2 = 0;
 111e17c:	52800003 	mov	w3, #0x0                   	// #0
			req_key_type = TEE_TYPE_SM2_PKE_KEYPAIR;
 111e180:	528008e1 	mov	w1, #0x47                  	// #71
 111e184:	17ffffb2 	b	111e04c <tee_svc_cryp_check_key_type.isra.0+0x68>
		if (mode == TEE_MODE_VERIFY)
 111e188:	71000c7f 	cmp	w3, #0x3
			req_key_type = TEE_TYPE_SM2_DSA_PUBLIC_KEY;
 111e18c:	528008a1 	mov	w1, #0x45                  	// #69
	uint32_t req_key_type2 = 0;
 111e190:	52800003 	mov	w3, #0x0                   	// #0
		if (mode == TEE_MODE_VERIFY)
 111e194:	54fff5c1 	b.ne	111e04c <tee_svc_cryp_check_key_type.isra.0+0x68>  // b.any
 111e198:	17ffffbe 	b	111e090 <tee_svc_cryp_check_key_type.isra.0+0xac>
		req_key_type2 = TEE_TYPE_SM2_KEP_PUBLIC_KEY;
 111e19c:	528008c3 	mov	w3, #0x46                  	// #70
		req_key_type = TEE_TYPE_SM2_KEP_KEYPAIR;
 111e1a0:	528008c1 	mov	w1, #0x46                  	// #70
		req_key_type2 = TEE_TYPE_SM2_KEP_PUBLIC_KEY;
 111e1a4:	72b40003 	movk	w3, #0xa000, lsl #16
 111e1a8:	17ffffa9 	b	111e04c <tee_svc_cryp_check_key_type.isra.0+0x68>
	uint32_t req_key_type2 = 0;
 111e1ac:	52800003 	mov	w3, #0x0                   	// #0
		req_key_type = TEE_TYPE_ECDH_KEYPAIR;
 111e1b0:	52800841 	mov	w1, #0x42                  	// #66
 111e1b4:	17ffffa6 	b	111e04c <tee_svc_cryp_check_key_type.isra.0+0x68>
	uint32_t req_key_type2 = 0;
 111e1b8:	52800003 	mov	w3, #0x0                   	// #0
		req_key_type = TEE_TYPE_HMAC_MD5;
 111e1bc:	52800021 	mov	w1, #0x1                   	// #1
 111e1c0:	17ffffb4 	b	111e090 <tee_svc_cryp_check_key_type.isra.0+0xac>
	uint32_t req_key_type2 = 0;
 111e1c4:	52800003 	mov	w3, #0x0                   	// #0
		req_key_type = TEE_TYPE_CONCAT_KDF_Z;
 111e1c8:	52801821 	mov	w1, #0xc1                  	// #193
 111e1cc:	17ffffa0 	b	111e04c <tee_svc_cryp_check_key_type.isra.0+0x68>
	uint32_t req_key_type2 = 0;
 111e1d0:	52800003 	mov	w3, #0x0                   	// #0
		req_key_type = TEE_TYPE_PBKDF2_PASSWORD;
 111e1d4:	52801841 	mov	w1, #0xc2                  	// #194
 111e1d8:	17ffff9d 	b	111e04c <tee_svc_cryp_check_key_type.isra.0+0x68>
	uint32_t req_key_type2 = 0;
 111e1dc:	52800003 	mov	w3, #0x0                   	// #0
 111e1e0:	17ffffe4 	b	111e170 <tee_svc_cryp_check_key_type.isra.0+0x18c>
			req_key_type = TEE_TYPE_SM2_PKE_PUBLIC_KEY;
 111e1e4:	528008e1 	mov	w1, #0x47                  	// #71
 111e1e8:	17ffffaa 	b	111e090 <tee_svc_cryp_check_key_type.isra.0+0xac>
	return TEE_SUCCESS;
 111e1ec:	52800000 	mov	w0, #0x0                   	// #0
 111e1f0:	17ffff9e 	b	111e068 <tee_svc_cryp_check_key_type.isra.0+0x84>

000000000111e1f4 <to_user_ta_ctx>:
{
 111e1f4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 111e1f8:	910003fd 	mov	x29, sp
 111e1fc:	f9000bf3 	str	x19, [sp, #16]
 111e200:	aa0003f3 	mov	x19, x0
	assert(is_user_ta_ctx(ctx));
 111e204:	97ffdffa 	bl	11161ec <is_user_ta_ctx>
 111e208:	72001c1f 	tst	w0, #0xff
 111e20c:	54000141 	b.ne	111e234 <to_user_ta_ctx+0x40>  // b.any
 111e210:	f00001a3 	adrp	x3, 1155000 <__func__.3826+0xa8>
 111e214:	f0000181 	adrp	x1, 1151000 <small_prime+0x168>
 111e218:	9124b063 	add	x3, x3, #0x92c
 111e21c:	91081021 	add	x1, x1, #0x204
 111e220:	f0000180 	adrp	x0, 1151000 <small_prime+0x168>
 111e224:	91088800 	add	x0, x0, #0x222
 111e228:	52800702 	mov	w2, #0x38                  	// #56
 111e22c:	97ffd020 	bl	11122ac <_assert_log>
 111e230:	97ffd030 	bl	11122f0 <_assert_break>
}
 111e234:	d10ba260 	sub	x0, x19, #0x2e8
 111e238:	f9400bf3 	ldr	x19, [sp, #16]
 111e23c:	a8c27bfd 	ldp	x29, x30, [sp], #32
 111e240:	d65f03c0 	ret

000000000111e244 <op_attr_bignum_to_user>:
{
 111e244:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 111e248:	910003fd 	mov	x29, sp
 111e24c:	a90153f3 	stp	x19, x20, [sp, #16]
 111e250:	aa0203f4 	mov	x20, x2
	res = copy_from_user(&s, size, sizeof(s));
 111e254:	d2800102 	mov	x2, #0x8                   	// #8
{
 111e258:	a9025bf5 	stp	x21, x22, [sp, #32]
 111e25c:	aa0003f5 	mov	x21, x0
 111e260:	aa0303f6 	mov	x22, x3
	res = copy_from_user(&s, size, sizeof(s));
 111e264:	910123e0 	add	x0, sp, #0x48
{
 111e268:	f9001bf7 	str	x23, [sp, #48]
 111e26c:	aa0103f7 	mov	x23, x1
	res = copy_from_user(&s, size, sizeof(s));
 111e270:	aa0303e1 	mov	x1, x3
	uint64_t s = 0;
 111e274:	a9047fff 	stp	xzr, xzr, [sp, #64]
	res = copy_from_user(&s, size, sizeof(s));
 111e278:	97ffdb1e 	bl	1114ef0 <copy_from_user>
 111e27c:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 111e280:	35000380 	cbnz	w0, 111e2f0 <op_attr_bignum_to_user+0xac>
	req_size = crypto_bignum_num_bytes(*bn);
 111e284:	f94002a0 	ldr	x0, [x21]
 111e288:	94003fb5 	bl	112e15c <crypto_bignum_num_bytes>
 111e28c:	f90023e0 	str	x0, [sp, #64]
	res = copy_to_user(size, &req_size, sizeof(req_size));
 111e290:	910103e1 	add	x1, sp, #0x40
 111e294:	aa1603e0 	mov	x0, x22
 111e298:	d2800102 	mov	x2, #0x8                   	// #8
 111e29c:	97ffdb29 	bl	1114f40 <copy_to_user>
 111e2a0:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 111e2a4:	35000260 	cbnz	w0, 111e2f0 <op_attr_bignum_to_user+0xac>
	if (!req_size)
 111e2a8:	f94023e0 	ldr	x0, [sp, #64]
 111e2ac:	b4000220 	cbz	x0, 111e2f0 <op_attr_bignum_to_user+0xac>
	if (s < req_size || !buffer)
 111e2b0:	f94027e1 	ldr	x1, [sp, #72]
 111e2b4:	eb01001f 	cmp	x0, x1
 111e2b8:	54000288 	b.hi	111e308 <op_attr_bignum_to_user+0xc4>  // b.pmore
 111e2bc:	b4000274 	cbz	x20, 111e308 <op_attr_bignum_to_user+0xc4>
	res = vm_check_access_rights(&to_user_ta_ctx(sess->ctx)->uctx,
 111e2c0:	f9400ae0 	ldr	x0, [x23, #16]
 111e2c4:	97ffffcc 	bl	111e1f4 <to_user_ta_ctx>
 111e2c8:	91014000 	add	x0, x0, #0x50
 111e2cc:	f94023e3 	ldr	x3, [sp, #64]
 111e2d0:	aa1403e2 	mov	x2, x20
 111e2d4:	528000e1 	mov	w1, #0x7                   	// #7
 111e2d8:	97ffed45 	bl	11197ec <vm_check_access_rights>
 111e2dc:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 111e2e0:	35000080 	cbnz	w0, 111e2f0 <op_attr_bignum_to_user+0xac>
	crypto_bignum_bn2bin(*bn, buffer);
 111e2e4:	f94002a0 	ldr	x0, [x21]
 111e2e8:	aa1403e1 	mov	x1, x20
 111e2ec:	94003f9d 	bl	112e160 <crypto_bignum_bn2bin>
}
 111e2f0:	2a1303e0 	mov	w0, w19
 111e2f4:	a94153f3 	ldp	x19, x20, [sp, #16]
 111e2f8:	a9425bf5 	ldp	x21, x22, [sp, #32]
 111e2fc:	f9401bf7 	ldr	x23, [sp, #48]
 111e300:	a8c57bfd 	ldp	x29, x30, [sp], #80
 111e304:	d65f03c0 	ret
		return TEE_ERROR_SHORT_BUFFER;
 111e308:	129ffdf3 	mov	w19, #0xffff0010            	// #-65520
 111e30c:	17fffff9 	b	111e2f0 <op_attr_bignum_to_user+0xac>

000000000111e310 <tee_svc_cryp_get_state.isra.0>:
static TEE_Result tee_svc_cryp_get_state(struct ts_session *sess,
 111e310:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 111e314:	910003fd 	mov	x29, sp
 111e318:	a90153f3 	stp	x19, x20, [sp, #16]
 111e31c:	aa0103f3 	mov	x19, x1
 111e320:	aa0203f4 	mov	x20, x2
	struct user_ta_ctx *utc = to_user_ta_ctx(sess->ctx);
 111e324:	97ffffb4 	bl	111e1f4 <to_user_ta_ctx>
	TAILQ_FOREACH(s, &utc->cryp_states, link) {
 111e328:	f9400800 	ldr	x0, [x0, #16]
 111e32c:	b5000060 	cbnz	x0, 111e338 <tee_svc_cryp_get_state.isra.0+0x28>
	return TEE_ERROR_BAD_PARAMETERS;
 111e330:	129fff20 	mov	w0, #0xffff0006            	// #-65530
 111e334:	14000005 	b	111e348 <tee_svc_cryp_get_state.isra.0+0x38>
		if (state_id == (vaddr_t)s) {
 111e338:	eb13001f 	cmp	x0, x19
 111e33c:	540000c1 	b.ne	111e354 <tee_svc_cryp_get_state.isra.0+0x44>  // b.any
			*state = s;
 111e340:	f9000280 	str	x0, [x20]
			return TEE_SUCCESS;
 111e344:	52800000 	mov	w0, #0x0                   	// #0
}
 111e348:	a94153f3 	ldp	x19, x20, [sp, #16]
 111e34c:	a8c27bfd 	ldp	x29, x30, [sp], #32
 111e350:	d65f03c0 	ret
	TAILQ_FOREACH(s, &utc->cryp_states, link) {
 111e354:	f9400000 	ldr	x0, [x0]
 111e358:	17fffff5 	b	111e32c <tee_svc_cryp_get_state.isra.0+0x1c>

000000000111e35c <tee_svc_cipher_update_helper>:
}

static TEE_Result tee_svc_cipher_update_helper(unsigned long state,
			bool last_block, const void *src, size_t src_len,
			void *dst, uint64_t *dst_len)
{
 111e35c:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
 111e360:	910003fd 	mov	x29, sp
 111e364:	a90153f3 	stp	x19, x20, [sp, #16]
 111e368:	aa0003f3 	mov	x19, x0
 111e36c:	aa0303f4 	mov	x20, x3
 111e370:	a9025bf5 	stp	x21, x22, [sp, #32]
 111e374:	aa0203f6 	mov	x22, x2
 111e378:	aa0503f5 	mov	x21, x5
 111e37c:	a90363f7 	stp	x23, x24, [sp, #48]
 111e380:	12001c37 	and	w23, w1, #0xff
 111e384:	aa0403f8 	mov	x24, x4
 111e388:	f90023f9 	str	x25, [sp, #64]
	struct ts_session *sess = ts_get_current_session();
 111e38c:	97ffd995 	bl	11149e0 <ts_get_current_session>
 111e390:	aa0003f9 	mov	x25, x0
	struct tee_cryp_state *cs = NULL;
	TEE_Result res = TEE_SUCCESS;
	size_t dlen = 0;

	res = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);
 111e394:	2a1303e0 	mov	w0, w19
	size_t dlen = 0;
 111e398:	a9057fff 	stp	xzr, xzr, [sp, #80]
	res = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);
 111e39c:	97ffdb47 	bl	11150b8 <uref_to_vaddr>
 111e3a0:	aa0003e1 	mov	x1, x0
 111e3a4:	f9400b20 	ldr	x0, [x25, #16]
 111e3a8:	910143e2 	add	x2, sp, #0x50
 111e3ac:	97ffffd9 	bl	111e310 <tee_svc_cryp_get_state.isra.0>
 111e3b0:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 111e3b4:	350007a0 	cbnz	w0, 111e4a8 <tee_svc_cipher_update_helper+0x14c>
		return res;

	if (cs->state != CRYP_STATE_INITIALIZED)
 111e3b8:	f9402be0 	ldr	x0, [sp, #80]
 111e3bc:	b9403800 	ldr	w0, [x0, #56]
 111e3c0:	350008a0 	cbnz	w0, 111e4d4 <tee_svc_cipher_update_helper+0x178>
		return TEE_ERROR_BAD_STATE;

	res = vm_check_access_rights(&to_user_ta_ctx(sess->ctx)->uctx,
 111e3c4:	f9400b20 	ldr	x0, [x25, #16]
 111e3c8:	97ffff8b 	bl	111e1f4 <to_user_ta_ctx>
 111e3cc:	91014000 	add	x0, x0, #0x50
 111e3d0:	aa1403e3 	mov	x3, x20
 111e3d4:	aa1603e2 	mov	x2, x22
 111e3d8:	528000a1 	mov	w1, #0x5                   	// #5
 111e3dc:	97ffed04 	bl	11197ec <vm_check_access_rights>
				     TEE_MEMORY_ACCESS_READ |
				     TEE_MEMORY_ACCESS_ANY_OWNER,
				     (uaddr_t)src, src_len);
	if (res != TEE_SUCCESS)
 111e3e0:	350007e0 	cbnz	w0, 111e4dc <tee_svc_cipher_update_helper+0x180>
		return res;

	if (!dst_len) {
 111e3e4:	b5000455 	cbnz	x21, 111e46c <tee_svc_cipher_update_helper+0x110>
		dlen = 0;
 111e3e8:	f9002fff 	str	xzr, [sp, #88]
		res = vm_check_access_rights(uctx, flags, (uaddr_t)dst, dlen);
		if (res != TEE_SUCCESS)
			return res;
	}

	if (dlen < src_len) {
 111e3ec:	f9402fe0 	ldr	x0, [sp, #88]
 111e3f0:	eb14001f 	cmp	x0, x20
 111e3f4:	540006c3 	b.cc	111e4cc <tee_svc_cipher_update_helper+0x170>  // b.lo, b.ul, b.last
		res = TEE_ERROR_SHORT_BUFFER;
		goto out;
	}

	if (src_len > 0) {
 111e3f8:	b4000674 	cbz	x20, 111e4c4 <tee_svc_cipher_update_helper+0x168>
		/* Permit src_len == 0 to finalize the operation */
		res = tee_do_cipher_update(cs->ctx, cs->algo, cs->mode,
 111e3fc:	f9402be0 	ldr	x0, [sp, #80]
 111e400:	aa1803e6 	mov	x6, x24
 111e404:	aa1403e5 	mov	x5, x20
 111e408:	aa1603e4 	mov	x4, x22
 111e40c:	2a1703e3 	mov	w3, w23
 111e410:	29420801 	ldp	w1, w2, [x0, #16]
 111e414:	f9401400 	ldr	x0, [x0, #40]
 111e418:	97fff599 	bl	111ba7c <tee_do_cipher_update>
 111e41c:	2a0003f3 	mov	w19, w0
					   last_block, src, src_len, dst);
	}

	if (last_block && cs->ctx_finalize != NULL) {
 111e420:	34000117 	cbz	w23, 111e440 <tee_svc_cipher_update_helper+0xe4>
 111e424:	f9402be0 	ldr	x0, [sp, #80]
 111e428:	f9401801 	ldr	x1, [x0, #48]
 111e42c:	b40000a1 	cbz	x1, 111e440 <tee_svc_cipher_update_helper+0xe4>
		cs->ctx_finalize(cs->ctx);
 111e430:	f9401400 	ldr	x0, [x0, #40]
 111e434:	d63f0020 	blr	x1
		cs->ctx_finalize = NULL;
 111e438:	f9402be0 	ldr	x0, [sp, #80]
 111e43c:	f900181f 	str	xzr, [x0, #48]
	}

out:
	if ((res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) &&
 111e440:	7100027f 	cmp	w19, #0x0
 111e444:	129ffde0 	mov	w0, #0xffff0010            	// #-65520
 111e448:	7a401264 	ccmp	w19, w0, #0x4, ne  // ne = any
 111e44c:	540002e1 	b.ne	111e4a8 <tee_svc_cipher_update_helper+0x14c>  // b.any
 111e450:	b40002d5 	cbz	x21, 111e4a8 <tee_svc_cipher_update_helper+0x14c>
	    dst_len != NULL) {
		TEE_Result res2;

		res2 = put_user_u64(dst_len, src_len);
 111e454:	aa1403e1 	mov	x1, x20
 111e458:	aa1503e0 	mov	x0, x21
 111e45c:	97fffdf6 	bl	111dc34 <put_user_u64>
		if (res2 != TEE_SUCCESS)
 111e460:	7100001f 	cmp	w0, #0x0
 111e464:	1a800273 	csel	w19, w19, w0, eq  // eq = none
 111e468:	14000010 	b	111e4a8 <tee_svc_cipher_update_helper+0x14c>
		struct user_mode_ctx *uctx = &to_user_ta_ctx(sess->ctx)->uctx;
 111e46c:	f9400b20 	ldr	x0, [x25, #16]
 111e470:	97ffff61 	bl	111e1f4 <to_user_ta_ctx>
 111e474:	aa0003f9 	mov	x25, x0
		res = get_user_u64_as_size_t(&dlen, dst_len);
 111e478:	aa1503e1 	mov	x1, x21
 111e47c:	910163e0 	add	x0, sp, #0x58
 111e480:	97fffda6 	bl	111db18 <get_user_u64_as_size_t>
 111e484:	2a0003f3 	mov	w19, w0
		if (res != TEE_SUCCESS)
 111e488:	35000100 	cbnz	w0, 111e4a8 <tee_svc_cipher_update_helper+0x14c>
		res = vm_check_access_rights(uctx, flags, (uaddr_t)dst, dlen);
 111e48c:	f9402fe3 	ldr	x3, [sp, #88]
 111e490:	aa1803e2 	mov	x2, x24
 111e494:	91014320 	add	x0, x25, #0x50
 111e498:	528000e1 	mov	w1, #0x7                   	// #7
 111e49c:	97ffecd4 	bl	11197ec <vm_check_access_rights>
 111e4a0:	2a0003f3 	mov	w19, w0
		if (res != TEE_SUCCESS)
 111e4a4:	34fffa40 	cbz	w0, 111e3ec <tee_svc_cipher_update_helper+0x90>
			res = res2;
	}

	return res;
}
 111e4a8:	2a1303e0 	mov	w0, w19
 111e4ac:	a94153f3 	ldp	x19, x20, [sp, #16]
 111e4b0:	a9425bf5 	ldp	x21, x22, [sp, #32]
 111e4b4:	a94363f7 	ldp	x23, x24, [sp, #48]
 111e4b8:	f94023f9 	ldr	x25, [sp, #64]
 111e4bc:	a8c67bfd 	ldp	x29, x30, [sp], #96
 111e4c0:	d65f03c0 	ret
 111e4c4:	52800013 	mov	w19, #0x0                   	// #0
 111e4c8:	17ffffd6 	b	111e420 <tee_svc_cipher_update_helper+0xc4>
		res = TEE_ERROR_SHORT_BUFFER;
 111e4cc:	129ffdf3 	mov	w19, #0xffff0010            	// #-65520
 111e4d0:	17ffffdc 	b	111e440 <tee_svc_cipher_update_helper+0xe4>
		return TEE_ERROR_BAD_STATE;
 111e4d4:	129fff13 	mov	w19, #0xffff0007            	// #-65529
 111e4d8:	17fffff4 	b	111e4a8 <tee_svc_cipher_update_helper+0x14c>
 111e4dc:	2a0003f3 	mov	w19, w0
 111e4e0:	17fffff2 	b	111e4a8 <tee_svc_cipher_update_helper+0x14c>

000000000111e4e4 <pkcs1_get_salt_len>:
	return res;
}

static int pkcs1_get_salt_len(const TEE_Attribute *params, uint32_t num_params,
			      size_t default_len)
{
 111e4e4:	aa0003e3 	mov	x3, x0
 111e4e8:	aa0203e0 	mov	x0, x2
	size_t n;

	assert(default_len < INT_MAX);
 111e4ec:	b27f77e2 	mov	x2, #0x7ffffffe            	// #2147483646
 111e4f0:	eb02001f 	cmp	x0, x2
 111e4f4:	54000128 	b.hi	111e518 <pkcs1_get_salt_len+0x34>  // b.pmore

	for (n = 0; n < num_params; n++) {
		if (params[n].attributeID == TEE_ATTR_RSA_PSS_SALT_LENGTH) {
 111e4f8:	52814604 	mov	w4, #0xa30                 	// #2608
	for (n = 0; n < num_params; n++) {
 111e4fc:	2a0103e1 	mov	w1, w1
 111e500:	aa0303e2 	mov	x2, x3
		if (params[n].attributeID == TEE_ATTR_RSA_PSS_SALT_LENGTH) {
 111e504:	72be0004 	movk	w4, #0xf000, lsl #16
	for (n = 0; n < num_params; n++) {
 111e508:	d2800003 	mov	x3, #0x0                   	// #0
 111e50c:	eb03003f 	cmp	x1, x3
 111e510:	540001a8 	b.hi	111e544 <pkcs1_get_salt_len+0x60>  // b.pmore
	/*
	 * If salt length isn't provided use the default value which is
	 * the length of the digest.
	 */
	return default_len;
}
 111e514:	d65f03c0 	ret
	assert(default_len < INT_MAX);
 111e518:	f00001a3 	adrp	x3, 1155000 <__func__.3826+0xa8>
 111e51c:	f00001a1 	adrp	x1, 1155000 <__func__.3826+0xa8>
 111e520:	91252c63 	add	x3, x3, #0x94b
 111e524:	9123d421 	add	x1, x1, #0x8f5
 111e528:	f00001a0 	adrp	x0, 1155000 <__func__.3826+0xa8>
 111e52c:	91245800 	add	x0, x0, #0x916
{
 111e530:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	assert(default_len < INT_MAX);
 111e534:	5281b602 	mov	w2, #0xdb0                 	// #3504
{
 111e538:	910003fd 	mov	x29, sp
	assert(default_len < INT_MAX);
 111e53c:	97ffcf5c 	bl	11122ac <_assert_log>
 111e540:	97ffcf6c 	bl	11122f0 <_assert_break>
		if (params[n].attributeID == TEE_ATTR_RSA_PSS_SALT_LENGTH) {
 111e544:	aa0203e5 	mov	x5, x2
 111e548:	b8418446 	ldr	w6, [x2], #24
 111e54c:	6b0400df 	cmp	w6, w4
 111e550:	540000e1 	b.ne	111e56c <pkcs1_get_salt_len+0x88>  // b.any
			if (params[n].content.value.a < INT_MAX)
 111e554:	b94008a2 	ldr	w2, [x5, #8]
 111e558:	321f77e1 	mov	w1, #0x7ffffffe            	// #2147483646
 111e55c:	6b01005f 	cmp	w2, w1
 111e560:	54fffda8 	b.hi	111e514 <pkcs1_get_salt_len+0x30>  // b.pmore
				return params[n].content.value.a;
 111e564:	2a0203e0 	mov	w0, w2
 111e568:	d65f03c0 	ret
	for (n = 0; n < num_params; n++) {
 111e56c:	91000463 	add	x3, x3, #0x1
 111e570:	17ffffe7 	b	111e50c <pkcs1_get_salt_len+0x28>

000000000111e574 <op_attr_secret_value_from_user>:
{
 111e574:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 111e578:	910003fd 	mov	x29, sp
 111e57c:	a90153f3 	stp	x19, x20, [sp, #16]
 111e580:	aa0003f3 	mov	x19, x0
	if (size > key->alloc_size)
 111e584:	b9400400 	ldr	w0, [x0, #4]
 111e588:	eb02001f 	cmp	x0, x2
 111e58c:	54000123 	b.cc	111e5b0 <op_attr_secret_value_from_user+0x3c>  // b.lo, b.ul, b.last
 111e590:	aa0203f4 	mov	x20, x2
	memcpy(key + 1, buffer, size);
 111e594:	91002260 	add	x0, x19, #0x8
 111e598:	97ff937e 	bl	1103390 <memcpy>
	key->key_size = size;
 111e59c:	b9000274 	str	w20, [x19]
 111e5a0:	52800000 	mov	w0, #0x0                   	// #0
}
 111e5a4:	a94153f3 	ldp	x19, x20, [sp, #16]
 111e5a8:	a8c27bfd 	ldp	x29, x30, [sp], #32
 111e5ac:	d65f03c0 	ret
		return TEE_ERROR_SECURITY;
 111e5b0:	129ffe00 	mov	w0, #0xffff000f            	// #-65521
 111e5b4:	17fffffc 	b	111e5a4 <op_attr_secret_value_from_user+0x30>

000000000111e5b8 <op_attr_secret_value_to_binary>:
{
 111e5b8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 111e5bc:	910003fd 	mov	x29, sp
 111e5c0:	a90153f3 	stp	x19, x20, [sp, #16]
 111e5c4:	aa0003f4 	mov	x20, x0
	res = op_u32_to_binary_helper(key->key_size, data, data_len, offs);
 111e5c8:	b9400000 	ldr	w0, [x0]
{
 111e5cc:	a9025bf5 	stp	x21, x22, [sp, #32]
 111e5d0:	aa0103f6 	mov	x22, x1
 111e5d4:	aa0303f5 	mov	x21, x3
 111e5d8:	a90363f7 	stp	x23, x24, [sp, #48]
 111e5dc:	aa0203f7 	mov	x23, x2
	res = op_u32_to_binary_helper(key->key_size, data, data_len, offs);
 111e5e0:	97fffd33 	bl	111daac <op_u32_to_binary_helper>
 111e5e4:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 111e5e8:	35000120 	cbnz	w0, 111e60c <op_attr_secret_value_to_binary+0x54>
	if (ADD_OVERFLOW(*offs, key->key_size, &next_offs))
 111e5ec:	f94002a0 	ldr	x0, [x21]
 111e5f0:	b9400282 	ldr	w2, [x20]
 111e5f4:	ab020018 	adds	x24, x0, x2
 111e5f8:	54000082 	b.cs	111e608 <op_attr_secret_value_to_binary+0x50>  // b.hs, b.nlast
	if (data && next_offs <= data_len)
 111e5fc:	b5000156 	cbnz	x22, 111e624 <op_attr_secret_value_to_binary+0x6c>
	(*offs) = next_offs;
 111e600:	f90002b8 	str	x24, [x21]
	return TEE_SUCCESS;
 111e604:	14000002 	b	111e60c <op_attr_secret_value_to_binary+0x54>
		return TEE_ERROR_OVERFLOW;
 111e608:	1299fe13 	mov	w19, #0xffff300f            	// #-53233
}
 111e60c:	2a1303e0 	mov	w0, w19
 111e610:	a94153f3 	ldp	x19, x20, [sp, #16]
 111e614:	a9425bf5 	ldp	x21, x22, [sp, #32]
 111e618:	a94363f7 	ldp	x23, x24, [sp, #48]
 111e61c:	a8c47bfd 	ldp	x29, x30, [sp], #64
 111e620:	d65f03c0 	ret
	if (data && next_offs <= data_len)
 111e624:	eb1802ff 	cmp	x23, x24
 111e628:	54fffec3 	b.cc	111e600 <op_attr_secret_value_to_binary+0x48>  // b.lo, b.ul, b.last
		memcpy((uint8_t *)data + *offs, key + 1, key->key_size);
 111e62c:	91002281 	add	x1, x20, #0x8
 111e630:	8b0002c0 	add	x0, x22, x0
 111e634:	97ff9357 	bl	1103390 <memcpy>
 111e638:	17fffff2 	b	111e600 <op_attr_secret_value_to_binary+0x48>

000000000111e63c <syscall_cryp_obj_get_info>:
{
 111e63c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 111e640:	910003fd 	mov	x29, sp
 111e644:	a90153f3 	stp	x19, x20, [sp, #16]
 111e648:	aa0103f3 	mov	x19, x1
 111e64c:	f90013f5 	str	x21, [sp, #32]
 111e650:	aa0003f5 	mov	x21, x0
	struct ts_session *sess = ts_get_current_session();
 111e654:	97ffd8e3 	bl	11149e0 <ts_get_current_session>
	struct tee_obj *o = NULL;
 111e658:	f9001fff 	str	xzr, [sp, #56]
	res = tee_obj_get(to_user_ta_ctx(sess->ctx),
 111e65c:	f9400800 	ldr	x0, [x0, #16]
 111e660:	97fffee5 	bl	111e1f4 <to_user_ta_ctx>
 111e664:	aa0003f4 	mov	x20, x0
 111e668:	2a1503e0 	mov	w0, w21
 111e66c:	97ffda93 	bl	11150b8 <uref_to_vaddr>
 111e670:	9100e3e2 	add	x2, sp, #0x38
 111e674:	aa0003e1 	mov	x1, x0
 111e678:	aa1403e0 	mov	x0, x20
 111e67c:	94001e40 	bl	1125f7c <tee_obj_get>
	if (res != TEE_SUCCESS)
 111e680:	350000c0 	cbnz	w0, 111e698 <syscall_cryp_obj_get_info+0x5c>
	res = copy_to_user_private(info, &o->info, sizeof(o->info));
 111e684:	f9401fe1 	ldr	x1, [sp, #56]
 111e688:	aa1303e0 	mov	x0, x19
 111e68c:	d2800382 	mov	x2, #0x1c                  	// #28
 111e690:	91004021 	add	x1, x1, #0x10
 111e694:	97ffda54 	bl	1114fe4 <copy_to_user_private>
}
 111e698:	a94153f3 	ldp	x19, x20, [sp, #16]
 111e69c:	f94013f5 	ldr	x21, [sp, #32]
 111e6a0:	a8c47bfd 	ldp	x29, x30, [sp], #64
 111e6a4:	d65f03c0 	ret

000000000111e6a8 <syscall_cryp_obj_restrict_usage>:
{
 111e6a8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 111e6ac:	910003fd 	mov	x29, sp
 111e6b0:	a90153f3 	stp	x19, x20, [sp, #16]
 111e6b4:	aa0103f3 	mov	x19, x1
 111e6b8:	f90013f5 	str	x21, [sp, #32]
 111e6bc:	aa0003f5 	mov	x21, x0
	struct ts_session *sess = ts_get_current_session();
 111e6c0:	97ffd8c8 	bl	11149e0 <ts_get_current_session>
	struct tee_obj *o = NULL;
 111e6c4:	f9001fff 	str	xzr, [sp, #56]
	res = tee_obj_get(to_user_ta_ctx(sess->ctx), uref_to_vaddr(obj), &o);
 111e6c8:	f9400800 	ldr	x0, [x0, #16]
 111e6cc:	97fffeca 	bl	111e1f4 <to_user_ta_ctx>
 111e6d0:	aa0003f4 	mov	x20, x0
 111e6d4:	2a1503e0 	mov	w0, w21
 111e6d8:	97ffda78 	bl	11150b8 <uref_to_vaddr>
 111e6dc:	9100e3e2 	add	x2, sp, #0x38
 111e6e0:	aa0003e1 	mov	x1, x0
 111e6e4:	aa1403e0 	mov	x0, x20
 111e6e8:	94001e25 	bl	1125f7c <tee_obj_get>
	if (res != TEE_SUCCESS)
 111e6ec:	350000a0 	cbnz	w0, 111e700 <syscall_cryp_obj_restrict_usage+0x58>
	o->info.objectUsage &= usage;
 111e6f0:	f9401fe3 	ldr	x3, [sp, #56]
 111e6f4:	b9401c62 	ldr	w2, [x3, #28]
 111e6f8:	0a130041 	and	w1, w2, w19
 111e6fc:	b9001c61 	str	w1, [x3, #28]
}
 111e700:	a94153f3 	ldp	x19, x20, [sp, #16]
 111e704:	f94013f5 	ldr	x21, [sp, #32]
 111e708:	a8c47bfd 	ldp	x29, x30, [sp], #64
 111e70c:	d65f03c0 	ret

000000000111e710 <syscall_cryp_obj_get_attr>:
{
 111e710:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 111e714:	910003fd 	mov	x29, sp
 111e718:	a90153f3 	stp	x19, x20, [sp, #16]
 111e71c:	aa0103f4 	mov	x20, x1
 111e720:	a9025bf5 	stp	x21, x22, [sp, #32]
 111e724:	aa0203f5 	mov	x21, x2
 111e728:	aa0303f6 	mov	x22, x3
 111e72c:	a90363f7 	stp	x23, x24, [sp, #48]
 111e730:	aa0003f8 	mov	x24, x0
	struct ts_session *sess = ts_get_current_session();
 111e734:	97ffd8ab 	bl	11149e0 <ts_get_current_session>
 111e738:	aa0003f3 	mov	x19, x0
	struct tee_obj *o = NULL;
 111e73c:	f90027ff 	str	xzr, [sp, #72]
	res = tee_obj_get(to_user_ta_ctx(sess->ctx), uref_to_vaddr(obj), &o);
 111e740:	f9400800 	ldr	x0, [x0, #16]
 111e744:	97fffeac 	bl	111e1f4 <to_user_ta_ctx>
 111e748:	aa0003f7 	mov	x23, x0
 111e74c:	2a1803e0 	mov	w0, w24
 111e750:	97ffda5a 	bl	11150b8 <uref_to_vaddr>
 111e754:	910123e2 	add	x2, sp, #0x48
 111e758:	aa0003e1 	mov	x1, x0
 111e75c:	aa1703e0 	mov	x0, x23
 111e760:	94001e07 	bl	1125f7c <tee_obj_get>
	if (res != TEE_SUCCESS)
 111e764:	35000580 	cbnz	w0, 111e814 <syscall_cryp_obj_get_attr+0x104>
	if (!(o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED))
 111e768:	f94027e7 	ldr	x7, [sp, #72]
 111e76c:	b94028e0 	ldr	w0, [x7, #40]
 111e770:	368804a0 	tbz	w0, #17, 111e804 <syscall_cryp_obj_get_attr+0xf4>
	if (!(attr_id & TEE_ATTR_FLAG_PUBLIC) &&
 111e774:	37e00074 	tbnz	w20, #28, 111e780 <syscall_cryp_obj_get_attr+0x70>
	    !(o->info.objectUsage & TEE_USAGE_EXTRACTABLE))
 111e778:	b9401ce0 	ldr	w0, [x7, #28]
	if (!(attr_id & TEE_ATTR_FLAG_PUBLIC) &&
 111e77c:	36000440 	tbz	w0, #0, 111e804 <syscall_cryp_obj_get_attr+0xf4>
	type_props = tee_svc_find_type_props(o->info.objectType);
 111e780:	b94010e0 	ldr	w0, [x7, #16]
 111e784:	97fffb47 	bl	111d4a0 <tee_svc_find_type_props>
 111e788:	aa0003e1 	mov	x1, x0
	if (!type_props) {
 111e78c:	b4000400 	cbz	x0, 111e80c <syscall_cryp_obj_get_attr+0xfc>
	idx = tee_svc_cryp_obj_find_type_attr_idx(attr_id, type_props);
 111e790:	2a1403e0 	mov	w0, w20
 111e794:	97fffb34 	bl	111d464 <tee_svc_cryp_obj_find_type_attr_idx>
	if ((idx < 0) || ((o->have_attrs & (1 << idx)) == 0))
 111e798:	37f803e0 	tbnz	w0, #31, 111e814 <syscall_cryp_obj_get_attr+0x104>
 111e79c:	b94030e3 	ldr	w3, [x7, #48]
 111e7a0:	52800022 	mov	w2, #0x1                   	// #1
 111e7a4:	1ac02042 	lsl	w2, w2, w0
 111e7a8:	6a03005f 	tst	w2, w3
 111e7ac:	54000340 	b.eq	111e814 <syscall_cryp_obj_get_attr+0x104>  // b.none
	ops = attr_ops + type_props->type_attrs[idx].ops_index;
 111e7b0:	f9400821 	ldr	x1, [x1, #16]
 111e7b4:	52800182 	mov	w2, #0xc                   	// #12
	return ops->to_user(attr, sess, buffer, size);
 111e7b8:	52800703 	mov	w3, #0x38                  	// #56
	attr = (uint8_t *)o->attr + type_props->type_attrs[idx].raw_offs;
 111e7bc:	f9401ce5 	ldr	x5, [x7, #56]
	ops = attr_ops + type_props->type_attrs[idx].ops_index;
 111e7c0:	9b220401 	smaddl	x1, w0, w2, x1
	return ops->to_user(attr, sess, buffer, size);
 111e7c4:	b00001e2 	adrp	x2, 115b000 <__vcore_unpg_rw_start>
 111e7c8:	912ae042 	add	x2, x2, #0xab8
	attr = (uint8_t *)o->attr + type_props->type_attrs[idx].raw_offs;
 111e7cc:	79401020 	ldrh	w0, [x1, #8]
	ops = attr_ops + type_props->type_attrs[idx].ops_index;
 111e7d0:	79400c21 	ldrh	w1, [x1, #6]
	return ops->to_user(attr, sess, buffer, size);
 111e7d4:	8b0000a0 	add	x0, x5, x0
 111e7d8:	9ba30821 	umaddl	x1, w1, w3, x2
 111e7dc:	aa1603e3 	mov	x3, x22
 111e7e0:	aa1503e2 	mov	x2, x21
 111e7e4:	f9400424 	ldr	x4, [x1, #8]
 111e7e8:	aa1303e1 	mov	x1, x19
 111e7ec:	d63f0080 	blr	x4
}
 111e7f0:	a94153f3 	ldp	x19, x20, [sp, #16]
 111e7f4:	a9425bf5 	ldp	x21, x22, [sp, #32]
 111e7f8:	a94363f7 	ldp	x23, x24, [sp, #48]
 111e7fc:	a8c57bfd 	ldp	x29, x30, [sp], #80
 111e800:	d65f03c0 	ret
		return TEE_ERROR_BAD_PARAMETERS;
 111e804:	129fff20 	mov	w0, #0xffff0006            	// #-65530
 111e808:	17fffffa 	b	111e7f0 <syscall_cryp_obj_get_attr+0xe0>
		return TEE_ERROR_BAD_STATE;
 111e80c:	129fff00 	mov	w0, #0xffff0007            	// #-65529
 111e810:	17fffff8 	b	111e7f0 <syscall_cryp_obj_get_attr+0xe0>
		return TEE_ERROR_ITEM_NOT_FOUND;
 111e814:	129ffee0 	mov	w0, #0xffff0008            	// #-65528
 111e818:	17fffff6 	b	111e7f0 <syscall_cryp_obj_get_attr+0xe0>

000000000111e81c <tee_obj_attr_free>:
{
 111e81c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 111e820:	910003fd 	mov	x29, sp
 111e824:	a90153f3 	stp	x19, x20, [sp, #16]
 111e828:	aa0003f4 	mov	x20, x0
	if (!o->attr)
 111e82c:	f9401c00 	ldr	x0, [x0, #56]
{
 111e830:	a9025bf5 	stp	x21, x22, [sp, #32]
 111e834:	a90363f7 	stp	x23, x24, [sp, #48]
	if (!o->attr)
 111e838:	b40001a0 	cbz	x0, 111e86c <tee_obj_attr_free+0x50>
	tp = tee_svc_find_type_props(o->info.objectType);
 111e83c:	b9401280 	ldr	w0, [x20, #16]
 111e840:	97fffb18 	bl	111d4a0 <tee_svc_find_type_props>
 111e844:	aa0003f3 	mov	x19, x0
	if (!tp)
 111e848:	b4000120 	cbz	x0, 111e86c <tee_obj_attr_free+0x50>
		attr_ops[ta->ops_index].free((uint8_t *)o->attr + ta->raw_offs);
 111e84c:	b00001f6 	adrp	x22, 115b000 <__vcore_unpg_rw_start>
 111e850:	912ae2d6 	add	x22, x22, #0xab8
	for (n = 0; n < tp->num_type_attrs; n++) {
 111e854:	d2800015 	mov	x21, #0x0                   	// #0
		const struct tee_cryp_obj_type_attrs *ta = tp->type_attrs + n;
 111e858:	d2800197 	mov	x23, #0xc                   	// #12
		attr_ops[ta->ops_index].free((uint8_t *)o->attr + ta->raw_offs);
 111e85c:	d2800718 	mov	x24, #0x38                  	// #56
	for (n = 0; n < tp->num_type_attrs; n++) {
 111e860:	39402e60 	ldrb	w0, [x19, #11]
 111e864:	eb15001f 	cmp	x0, x21
 111e868:	540000c8 	b.hi	111e880 <tee_obj_attr_free+0x64>  // b.pmore
}
 111e86c:	a94153f3 	ldp	x19, x20, [sp, #16]
 111e870:	a9425bf5 	ldp	x21, x22, [sp, #32]
 111e874:	a94363f7 	ldp	x23, x24, [sp, #48]
 111e878:	a8c47bfd 	ldp	x29, x30, [sp], #64
 111e87c:	d65f03c0 	ret
		const struct tee_cryp_obj_type_attrs *ta = tp->type_attrs + n;
 111e880:	f9400a61 	ldr	x1, [x19, #16]
		attr_ops[ta->ops_index].free((uint8_t *)o->attr + ta->raw_offs);
 111e884:	f9401e82 	ldr	x2, [x20, #56]
		const struct tee_cryp_obj_type_attrs *ta = tp->type_attrs + n;
 111e888:	9b1706a1 	madd	x1, x21, x23, x1
	for (n = 0; n < tp->num_type_attrs; n++) {
 111e88c:	910006b5 	add	x21, x21, #0x1
		attr_ops[ta->ops_index].free((uint8_t *)o->attr + ta->raw_offs);
 111e890:	79401020 	ldrh	w0, [x1, #8]
 111e894:	79400c21 	ldrh	w1, [x1, #6]
 111e898:	8b000040 	add	x0, x2, x0
 111e89c:	9b185821 	madd	x1, x1, x24, x22
 111e8a0:	f9401421 	ldr	x1, [x1, #40]
 111e8a4:	d63f0020 	blr	x1
	for (n = 0; n < tp->num_type_attrs; n++) {
 111e8a8:	17ffffee 	b	111e860 <tee_obj_attr_free+0x44>

000000000111e8ac <tee_obj_attr_clear>:
{
 111e8ac:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 111e8b0:	910003fd 	mov	x29, sp
 111e8b4:	a90153f3 	stp	x19, x20, [sp, #16]
 111e8b8:	aa0003f4 	mov	x20, x0
	if (!o->attr)
 111e8bc:	f9401c00 	ldr	x0, [x0, #56]
{
 111e8c0:	a9025bf5 	stp	x21, x22, [sp, #32]
 111e8c4:	a90363f7 	stp	x23, x24, [sp, #48]
	if (!o->attr)
 111e8c8:	b40001a0 	cbz	x0, 111e8fc <tee_obj_attr_clear+0x50>
	tp = tee_svc_find_type_props(o->info.objectType);
 111e8cc:	b9401280 	ldr	w0, [x20, #16]
 111e8d0:	97fffaf4 	bl	111d4a0 <tee_svc_find_type_props>
 111e8d4:	aa0003f3 	mov	x19, x0
	if (!tp)
 111e8d8:	b4000120 	cbz	x0, 111e8fc <tee_obj_attr_clear+0x50>
		attr_ops[ta->ops_index].clear((uint8_t *)o->attr +
 111e8dc:	b00001f6 	adrp	x22, 115b000 <__vcore_unpg_rw_start>
 111e8e0:	912ae2d6 	add	x22, x22, #0xab8
	for (n = 0; n < tp->num_type_attrs; n++) {
 111e8e4:	d2800015 	mov	x21, #0x0                   	// #0
		const struct tee_cryp_obj_type_attrs *ta = tp->type_attrs + n;
 111e8e8:	d2800197 	mov	x23, #0xc                   	// #12
		attr_ops[ta->ops_index].clear((uint8_t *)o->attr +
 111e8ec:	d2800718 	mov	x24, #0x38                  	// #56
	for (n = 0; n < tp->num_type_attrs; n++) {
 111e8f0:	39402e60 	ldrb	w0, [x19, #11]
 111e8f4:	eb15001f 	cmp	x0, x21
 111e8f8:	540000c8 	b.hi	111e910 <tee_obj_attr_clear+0x64>  // b.pmore
}
 111e8fc:	a94153f3 	ldp	x19, x20, [sp, #16]
 111e900:	a9425bf5 	ldp	x21, x22, [sp, #32]
 111e904:	a94363f7 	ldp	x23, x24, [sp, #48]
 111e908:	a8c47bfd 	ldp	x29, x30, [sp], #64
 111e90c:	d65f03c0 	ret
		const struct tee_cryp_obj_type_attrs *ta = tp->type_attrs + n;
 111e910:	f9400a61 	ldr	x1, [x19, #16]
		attr_ops[ta->ops_index].clear((uint8_t *)o->attr +
 111e914:	f9401e82 	ldr	x2, [x20, #56]
		const struct tee_cryp_obj_type_attrs *ta = tp->type_attrs + n;
 111e918:	9b1706a1 	madd	x1, x21, x23, x1
	for (n = 0; n < tp->num_type_attrs; n++) {
 111e91c:	910006b5 	add	x21, x21, #0x1
					      ta->raw_offs);
 111e920:	79401020 	ldrh	w0, [x1, #8]
		attr_ops[ta->ops_index].clear((uint8_t *)o->attr +
 111e924:	79400c21 	ldrh	w1, [x1, #6]
 111e928:	8b000040 	add	x0, x2, x0
 111e92c:	9b185821 	madd	x1, x1, x24, x22
 111e930:	f9401821 	ldr	x1, [x1, #48]
 111e934:	d63f0020 	blr	x1
	for (n = 0; n < tp->num_type_attrs; n++) {
 111e938:	17ffffee 	b	111e8f0 <tee_obj_attr_clear+0x44>

000000000111e93c <tee_obj_attr_to_binary>:
{
 111e93c:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
 111e940:	910003fd 	mov	x29, sp
 111e944:	a90153f3 	stp	x19, x20, [sp, #16]
 111e948:	aa0103f3 	mov	x19, x1
 111e94c:	aa0203f4 	mov	x20, x2
 111e950:	a9025bf5 	stp	x21, x22, [sp, #32]
 111e954:	aa0003f6 	mov	x22, x0
 111e958:	a90363f7 	stp	x23, x24, [sp, #48]
 111e95c:	a9046bf9 	stp	x25, x26, [sp, #64]
 111e960:	a90573fb 	stp	x27, x28, [sp, #80]
	size_t offs = 0;
 111e964:	f90037ff 	str	xzr, [sp, #104]
	size_t len = data ? *data_len : 0;
 111e968:	b4000141 	cbz	x1, 111e990 <tee_obj_attr_to_binary+0x54>
 111e96c:	f9400058 	ldr	x24, [x2]
	if (o->info.objectType == TEE_TYPE_DATA) {
 111e970:	528017e1 	mov	w1, #0xbf                  	// #191
 111e974:	b94012c0 	ldr	w0, [x22, #16]
 111e978:	72b40001 	movk	w1, #0xa000, lsl #16
 111e97c:	6b01001f 	cmp	w0, w1
 111e980:	540000c1 	b.ne	111e998 <tee_obj_attr_to_binary+0x5c>  // b.any
		*data_len = 0;
 111e984:	f900029f 	str	xzr, [x20]
	return TEE_SUCCESS;
 111e988:	52800000 	mov	w0, #0x0                   	// #0
 111e98c:	14000017 	b	111e9e8 <tee_obj_attr_to_binary+0xac>
	size_t len = data ? *data_len : 0;
 111e990:	d2800018 	mov	x24, #0x0                   	// #0
 111e994:	17fffff7 	b	111e970 <tee_obj_attr_to_binary+0x34>
	if (!o->attr)
 111e998:	f9401ec1 	ldr	x1, [x22, #56]
 111e99c:	b4000521 	cbz	x1, 111ea40 <tee_obj_attr_to_binary+0x104>
	tp = tee_svc_find_type_props(o->info.objectType);
 111e9a0:	97fffac0 	bl	111d4a0 <tee_svc_find_type_props>
 111e9a4:	aa0003f5 	mov	x21, x0
	if (!tp)
 111e9a8:	b40004c0 	cbz	x0, 111ea40 <tee_obj_attr_to_binary+0x104>
		res = attr_ops[ta->ops_index].to_binary(attr, data, len, &offs);
 111e9ac:	b00001f9 	adrp	x25, 115b000 <__vcore_unpg_rw_start>
 111e9b0:	9101a3fb 	add	x27, sp, #0x68
 111e9b4:	912ae339 	add	x25, x25, #0xab8
	for (n = 0; n < tp->num_type_attrs; n++) {
 111e9b8:	d2800017 	mov	x23, #0x0                   	// #0
		const struct tee_cryp_obj_type_attrs *ta = tp->type_attrs + n;
 111e9bc:	d280019a 	mov	x26, #0xc                   	// #12
		res = attr_ops[ta->ops_index].to_binary(attr, data, len, &offs);
 111e9c0:	d280071c 	mov	x28, #0x38                  	// #56
	for (n = 0; n < tp->num_type_attrs; n++) {
 111e9c4:	39402ea0 	ldrb	w0, [x21, #11]
 111e9c8:	eb17001f 	cmp	x0, x23
 111e9cc:	540001c8 	b.hi	111ea04 <tee_obj_attr_to_binary+0xc8>  // b.pmore
	*data_len = offs;
 111e9d0:	f94037e0 	ldr	x0, [sp, #104]
 111e9d4:	f9000280 	str	x0, [x20]
	if (data && offs > len)
 111e9d8:	b4fffd93 	cbz	x19, 111e988 <tee_obj_attr_to_binary+0x4c>
		return TEE_ERROR_SHORT_BUFFER;
 111e9dc:	eb18001f 	cmp	x0, x24
 111e9e0:	129ffde0 	mov	w0, #0xffff0010            	// #-65520
 111e9e4:	1a8093e0 	csel	w0, wzr, w0, ls  // ls = plast
}
 111e9e8:	a94153f3 	ldp	x19, x20, [sp, #16]
 111e9ec:	a9425bf5 	ldp	x21, x22, [sp, #32]
 111e9f0:	a94363f7 	ldp	x23, x24, [sp, #48]
 111e9f4:	a9446bf9 	ldp	x25, x26, [sp, #64]
 111e9f8:	a94573fb 	ldp	x27, x28, [sp, #80]
 111e9fc:	a8c77bfd 	ldp	x29, x30, [sp], #112
 111ea00:	d65f03c0 	ret
		const struct tee_cryp_obj_type_attrs *ta = tp->type_attrs + n;
 111ea04:	f9400aa1 	ldr	x1, [x21, #16]
		res = attr_ops[ta->ops_index].to_binary(attr, data, len, &offs);
 111ea08:	aa1b03e3 	mov	x3, x27
		void *attr = (uint8_t *)o->attr + ta->raw_offs;
 111ea0c:	f9401ec5 	ldr	x5, [x22, #56]
		res = attr_ops[ta->ops_index].to_binary(attr, data, len, &offs);
 111ea10:	aa1803e2 	mov	x2, x24
		const struct tee_cryp_obj_type_attrs *ta = tp->type_attrs + n;
 111ea14:	9b1a06e1 	madd	x1, x23, x26, x1
		void *attr = (uint8_t *)o->attr + ta->raw_offs;
 111ea18:	79401020 	ldrh	w0, [x1, #8]
		res = attr_ops[ta->ops_index].to_binary(attr, data, len, &offs);
 111ea1c:	79400c21 	ldrh	w1, [x1, #6]
 111ea20:	8b0000a0 	add	x0, x5, x0
 111ea24:	9b1c6421 	madd	x1, x1, x28, x25
 111ea28:	f9400824 	ldr	x4, [x1, #16]
 111ea2c:	aa1303e1 	mov	x1, x19
 111ea30:	d63f0080 	blr	x4
		if (res != TEE_SUCCESS)
 111ea34:	35fffda0 	cbnz	w0, 111e9e8 <tee_obj_attr_to_binary+0xac>
	for (n = 0; n < tp->num_type_attrs; n++) {
 111ea38:	910006f7 	add	x23, x23, #0x1
 111ea3c:	17ffffe2 	b	111e9c4 <tee_obj_attr_to_binary+0x88>
		return TEE_ERROR_BAD_STATE;
 111ea40:	129fff00 	mov	w0, #0xffff0007            	// #-65529
 111ea44:	17ffffe9 	b	111e9e8 <tee_obj_attr_to_binary+0xac>

000000000111ea48 <tee_obj_attr_from_binary>:
{
 111ea48:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
 111ea4c:	910003fd 	mov	x29, sp
 111ea50:	a90153f3 	stp	x19, x20, [sp, #16]
 111ea54:	aa0003f4 	mov	x20, x0
	if (o->info.objectType == TEE_TYPE_DATA)
 111ea58:	b9401000 	ldr	w0, [x0, #16]
{
 111ea5c:	a9025bf5 	stp	x21, x22, [sp, #32]
 111ea60:	aa0103f6 	mov	x22, x1
	if (o->info.objectType == TEE_TYPE_DATA)
 111ea64:	528017e1 	mov	w1, #0xbf                  	// #191
{
 111ea68:	a90363f7 	stp	x23, x24, [sp, #48]
	if (o->info.objectType == TEE_TYPE_DATA)
 111ea6c:	72b40001 	movk	w1, #0xa000, lsl #16
 111ea70:	6b01001f 	cmp	w0, w1
{
 111ea74:	a9046bf9 	stp	x25, x26, [sp, #64]
 111ea78:	f9002bfb 	str	x27, [sp, #80]
	size_t offs = 0;
 111ea7c:	f90037ff 	str	xzr, [sp, #104]
	if (o->info.objectType == TEE_TYPE_DATA)
 111ea80:	54000121 	b.ne	111eaa4 <tee_obj_attr_from_binary+0x5c>  // b.any
		return TEE_SUCCESS; /* pure data object */
 111ea84:	52800000 	mov	w0, #0x0                   	// #0
}
 111ea88:	a94153f3 	ldp	x19, x20, [sp, #16]
 111ea8c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 111ea90:	a94363f7 	ldp	x23, x24, [sp, #48]
 111ea94:	a9446bf9 	ldp	x25, x26, [sp, #64]
 111ea98:	f9402bfb 	ldr	x27, [sp, #80]
 111ea9c:	a8c77bfd 	ldp	x29, x30, [sp], #112
 111eaa0:	d65f03c0 	ret
	if (!o->attr)
 111eaa4:	f9401e81 	ldr	x1, [x20, #56]
 111eaa8:	b40003c1 	cbz	x1, 111eb20 <tee_obj_attr_from_binary+0xd8>
 111eaac:	aa0203f7 	mov	x23, x2
	tp = tee_svc_find_type_props(o->info.objectType);
 111eab0:	97fffa7c 	bl	111d4a0 <tee_svc_find_type_props>
 111eab4:	aa0003f3 	mov	x19, x0
	if (!tp)
 111eab8:	b4000340 	cbz	x0, 111eb20 <tee_obj_attr_from_binary+0xd8>
		if (!attr_ops[ta->ops_index].from_binary(attr, data, data_len,
 111eabc:	b00001f8 	adrp	x24, 115b000 <__vcore_unpg_rw_start>
 111eac0:	9101a3fa 	add	x26, sp, #0x68
 111eac4:	912ae318 	add	x24, x24, #0xab8
	for (n = 0; n < tp->num_type_attrs; n++) {
 111eac8:	d2800015 	mov	x21, #0x0                   	// #0
		const struct tee_cryp_obj_type_attrs *ta = tp->type_attrs + n;
 111eacc:	d2800199 	mov	x25, #0xc                   	// #12
		if (!attr_ops[ta->ops_index].from_binary(attr, data, data_len,
 111ead0:	d280071b 	mov	x27, #0x38                  	// #56
	for (n = 0; n < tp->num_type_attrs; n++) {
 111ead4:	39402e60 	ldrb	w0, [x19, #11]
 111ead8:	eb15001f 	cmp	x0, x21
 111eadc:	54fffd49 	b.ls	111ea84 <tee_obj_attr_from_binary+0x3c>  // b.plast
		const struct tee_cryp_obj_type_attrs *ta = tp->type_attrs + n;
 111eae0:	f9400a64 	ldr	x4, [x19, #16]
		if (!attr_ops[ta->ops_index].from_binary(attr, data, data_len,
 111eae4:	aa1a03e3 	mov	x3, x26
		void *attr = (uint8_t *)o->attr + ta->raw_offs;
 111eae8:	f9401e85 	ldr	x5, [x20, #56]
		if (!attr_ops[ta->ops_index].from_binary(attr, data, data_len,
 111eaec:	aa1703e2 	mov	x2, x23
		const struct tee_cryp_obj_type_attrs *ta = tp->type_attrs + n;
 111eaf0:	9b1912a4 	madd	x4, x21, x25, x4
		if (!attr_ops[ta->ops_index].from_binary(attr, data, data_len,
 111eaf4:	79400c81 	ldrh	w1, [x4, #6]
		void *attr = (uint8_t *)o->attr + ta->raw_offs;
 111eaf8:	79401080 	ldrh	w0, [x4, #8]
		if (!attr_ops[ta->ops_index].from_binary(attr, data, data_len,
 111eafc:	8b0000a0 	add	x0, x5, x0
 111eb00:	9b1b6021 	madd	x1, x1, x27, x24
 111eb04:	f9400c24 	ldr	x4, [x1, #24]
 111eb08:	aa1603e1 	mov	x1, x22
 111eb0c:	d63f0080 	blr	x4
 111eb10:	72001c1f 	tst	w0, #0xff
 111eb14:	540000a0 	b.eq	111eb28 <tee_obj_attr_from_binary+0xe0>  // b.none
	for (n = 0; n < tp->num_type_attrs; n++) {
 111eb18:	910006b5 	add	x21, x21, #0x1
 111eb1c:	17ffffee 	b	111ead4 <tee_obj_attr_from_binary+0x8c>
		return TEE_ERROR_BAD_STATE;
 111eb20:	129fff00 	mov	w0, #0xffff0007            	// #-65529
 111eb24:	17ffffd9 	b	111ea88 <tee_obj_attr_from_binary+0x40>
			return TEE_ERROR_CORRUPT_OBJECT;
 111eb28:	52800020 	mov	w0, #0x1                   	// #1
 111eb2c:	72be0200 	movk	w0, #0xf010, lsl #16
 111eb30:	17ffffd6 	b	111ea88 <tee_obj_attr_from_binary+0x40>

000000000111eb34 <tee_obj_attr_copy_from>:
{
 111eb34:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
 111eb38:	910003fd 	mov	x29, sp
	if (o->info.objectType == TEE_TYPE_DATA)
 111eb3c:	b9401006 	ldr	w6, [x0, #16]
{
 111eb40:	a90153f3 	stp	x19, x20, [sp, #16]
 111eb44:	aa0003f4 	mov	x20, x0
	if (o->info.objectType == TEE_TYPE_DATA)
 111eb48:	528017e0 	mov	w0, #0xbf                  	// #191
{
 111eb4c:	a9025bf5 	stp	x21, x22, [sp, #32]
	if (o->info.objectType == TEE_TYPE_DATA)
 111eb50:	72b40000 	movk	w0, #0xa000, lsl #16
 111eb54:	6b0000df 	cmp	w6, w0
{
 111eb58:	a90363f7 	stp	x23, x24, [sp, #48]
 111eb5c:	a9046bf9 	stp	x25, x26, [sp, #64]
 111eb60:	f9002bfb 	str	x27, [sp, #80]
	if (o->info.objectType == TEE_TYPE_DATA)
 111eb64:	540003a0 	b.eq	111ebd8 <tee_obj_attr_copy_from+0xa4>  // b.none
	if (!o->attr)
 111eb68:	f9401e80 	ldr	x0, [x20, #56]
 111eb6c:	b5000120 	cbnz	x0, 111eb90 <tee_obj_attr_copy_from+0x5c>
		return TEE_ERROR_BAD_STATE;
 111eb70:	129fff00 	mov	w0, #0xffff0007            	// #-65529
}
 111eb74:	a94153f3 	ldp	x19, x20, [sp, #16]
 111eb78:	a9425bf5 	ldp	x21, x22, [sp, #32]
 111eb7c:	a94363f7 	ldp	x23, x24, [sp, #48]
 111eb80:	a9446bf9 	ldp	x25, x26, [sp, #64]
 111eb84:	f9402bfb 	ldr	x27, [sp, #80]
 111eb88:	a8c67bfd 	ldp	x29, x30, [sp], #96
 111eb8c:	d65f03c0 	ret
 111eb90:	aa0103f6 	mov	x22, x1
	tp = tee_svc_find_type_props(o->info.objectType);
 111eb94:	2a0603e0 	mov	w0, w6
 111eb98:	97fffa42 	bl	111d4a0 <tee_svc_find_type_props>
 111eb9c:	aa0003f3 	mov	x19, x0
	if (!tp)
 111eba0:	b4fffe80 	cbz	x0, 111eb70 <tee_obj_attr_copy_from+0x3c>
	if (o->info.objectType == src->info.objectType) {
 111eba4:	b94012c0 	ldr	w0, [x22, #16]
 111eba8:	6b0000df 	cmp	w6, w0
 111ebac:	54000361 	b.ne	111ec18 <tee_obj_attr_copy_from+0xe4>  // b.any
		have_attrs = src->have_attrs;
 111ebb0:	b94032d5 	ldr	w21, [x22, #48]
			res = attr_ops[ta->ops_index].from_obj(attr, src_attr);
 111ebb4:	b00001f8 	adrp	x24, 115b000 <__vcore_unpg_rw_start>
 111ebb8:	912ae318 	add	x24, x24, #0xab8
		for (n = 0; n < tp->num_type_attrs; n++) {
 111ebbc:	d2800017 	mov	x23, #0x0                   	// #0
			ta = tp->type_attrs + n;
 111ebc0:	d2800199 	mov	x25, #0xc                   	// #12
			res = attr_ops[ta->ops_index].from_obj(attr, src_attr);
 111ebc4:	d280071a 	mov	x26, #0x38                  	// #56
		for (n = 0; n < tp->num_type_attrs; n++) {
 111ebc8:	39402e60 	ldrb	w0, [x19, #11]
 111ebcc:	eb17001f 	cmp	x0, x23
 111ebd0:	54000088 	b.hi	111ebe0 <tee_obj_attr_copy_from+0xac>  // b.pmore
	o->have_attrs = have_attrs;
 111ebd4:	b9003295 	str	w21, [x20, #48]
		return TEE_SUCCESS; /* pure data object */
 111ebd8:	52800000 	mov	w0, #0x0                   	// #0
 111ebdc:	17ffffe6 	b	111eb74 <tee_obj_attr_copy_from+0x40>
			ta = tp->type_attrs + n;
 111ebe0:	f9400a62 	ldr	x2, [x19, #16]
			attr = (uint8_t *)o->attr + ta->raw_offs;
 111ebe4:	f9401e83 	ldr	x3, [x20, #56]
			ta = tp->type_attrs + n;
 111ebe8:	9b190ae2 	madd	x2, x23, x25, x2
			src_attr = (uint8_t *)src->attr + ta->raw_offs;
 111ebec:	f9401ec1 	ldr	x1, [x22, #56]
			attr = (uint8_t *)o->attr + ta->raw_offs;
 111ebf0:	79401040 	ldrh	w0, [x2, #8]
			res = attr_ops[ta->ops_index].from_obj(attr, src_attr);
 111ebf4:	79400c42 	ldrh	w2, [x2, #6]
 111ebf8:	8b000021 	add	x1, x1, x0
 111ebfc:	8b000060 	add	x0, x3, x0
 111ec00:	9b1a6042 	madd	x2, x2, x26, x24
 111ec04:	f9401042 	ldr	x2, [x2, #32]
 111ec08:	d63f0040 	blr	x2
			if (res != TEE_SUCCESS)
 111ec0c:	35fffb40 	cbnz	w0, 111eb74 <tee_obj_attr_copy_from+0x40>
		for (n = 0; n < tp->num_type_attrs; n++) {
 111ec10:	910006f7 	add	x23, x23, #0x1
 111ec14:	17ffffed 	b	111ebc8 <tee_obj_attr_copy_from+0x94>
		if (o->info.objectType == TEE_TYPE_RSA_PUBLIC_KEY) {
 111ec18:	52800601 	mov	w1, #0x30                  	// #48
 111ec1c:	72b40001 	movk	w1, #0xa000, lsl #16
 111ec20:	6b0100df 	cmp	w6, w1
 111ec24:	540002a1 	b.ne	111ec78 <tee_obj_attr_copy_from+0x144>  // b.any
			if (src->info.objectType != TEE_TYPE_RSA_KEYPAIR)
 111ec28:	52800601 	mov	w1, #0x30                  	// #48
			if (src->info.objectType != TEE_TYPE_SM2_KEP_KEYPAIR)
 111ec2c:	72b42001 	movk	w1, #0xa100, lsl #16
 111ec30:	6b01001f 	cmp	w0, w1
 111ec34:	54000981 	b.ne	111ed64 <tee_obj_attr_copy_from+0x230>  // b.any
		tp_src = tee_svc_find_type_props(src->info.objectType);
 111ec38:	97fffa1a 	bl	111d4a0 <tee_svc_find_type_props>
 111ec3c:	aa0003fa 	mov	x26, x0
		if (!tp_src)
 111ec40:	b4fff980 	cbz	x0, 111eb70 <tee_obj_attr_copy_from+0x3c>
		have_attrs = BIT32(tp->num_type_attrs) - 1;
 111ec44:	39402e79 	ldrb	w25, [x19, #11]
			res = attr_ops[ta->ops_index].from_obj(attr, src_attr);
 111ec48:	b00001f7 	adrp	x23, 115b000 <__vcore_unpg_rw_start>
 111ec4c:	912ae2f7 	add	x23, x23, #0xab8
		for (n = 0; n < tp->num_type_attrs; n++) {
 111ec50:	d280001b 	mov	x27, #0x0                   	// #0
			ta = tp->type_attrs + n;
 111ec54:	d2800198 	mov	x24, #0xc                   	// #12
			res = attr_ops[ta->ops_index].from_obj(attr, src_attr);
 111ec58:	d2800715 	mov	x21, #0x38                  	// #56
		for (n = 0; n < tp->num_type_attrs; n++) {
 111ec5c:	39402e60 	ldrb	w0, [x19, #11]
 111ec60:	eb1b001f 	cmp	x0, x27
 111ec64:	54000528 	b.hi	111ed08 <tee_obj_attr_copy_from+0x1d4>  // b.pmore
		have_attrs = BIT32(tp->num_type_attrs) - 1;
 111ec68:	52800035 	mov	w21, #0x1                   	// #1
 111ec6c:	1ad922b5 	lsl	w21, w21, w25
 111ec70:	510006b5 	sub	w21, w21, #0x1
 111ec74:	17ffffd8 	b	111ebd4 <tee_obj_attr_copy_from+0xa0>
		} else if (o->info.objectType == TEE_TYPE_DSA_PUBLIC_KEY) {
 111ec78:	52800621 	mov	w1, #0x31                  	// #49
 111ec7c:	72b40001 	movk	w1, #0xa000, lsl #16
 111ec80:	6b0100df 	cmp	w6, w1
 111ec84:	54000061 	b.ne	111ec90 <tee_obj_attr_copy_from+0x15c>  // b.any
			if (src->info.objectType != TEE_TYPE_DSA_KEYPAIR)
 111ec88:	52800621 	mov	w1, #0x31                  	// #49
 111ec8c:	17ffffe8 	b	111ec2c <tee_obj_attr_copy_from+0xf8>
		} else if (o->info.objectType == TEE_TYPE_ECDSA_PUBLIC_KEY) {
 111ec90:	52800821 	mov	w1, #0x41                  	// #65
 111ec94:	72b40001 	movk	w1, #0xa000, lsl #16
 111ec98:	6b0100df 	cmp	w6, w1
 111ec9c:	54000061 	b.ne	111eca8 <tee_obj_attr_copy_from+0x174>  // b.any
			if (src->info.objectType != TEE_TYPE_ECDSA_KEYPAIR)
 111eca0:	52800821 	mov	w1, #0x41                  	// #65
 111eca4:	17ffffe2 	b	111ec2c <tee_obj_attr_copy_from+0xf8>
		} else if (o->info.objectType == TEE_TYPE_ECDH_PUBLIC_KEY) {
 111eca8:	52800841 	mov	w1, #0x42                  	// #66
 111ecac:	72b40001 	movk	w1, #0xa000, lsl #16
 111ecb0:	6b0100df 	cmp	w6, w1
 111ecb4:	54000061 	b.ne	111ecc0 <tee_obj_attr_copy_from+0x18c>  // b.any
			if (src->info.objectType != TEE_TYPE_ECDH_KEYPAIR)
 111ecb8:	52800841 	mov	w1, #0x42                  	// #66
 111ecbc:	17ffffdc 	b	111ec2c <tee_obj_attr_copy_from+0xf8>
		} else if (o->info.objectType == TEE_TYPE_SM2_DSA_PUBLIC_KEY) {
 111ecc0:	528008a1 	mov	w1, #0x45                  	// #69
 111ecc4:	72b40001 	movk	w1, #0xa000, lsl #16
 111ecc8:	6b0100df 	cmp	w6, w1
 111eccc:	54000061 	b.ne	111ecd8 <tee_obj_attr_copy_from+0x1a4>  // b.any
			if (src->info.objectType != TEE_TYPE_SM2_DSA_KEYPAIR)
 111ecd0:	528008a1 	mov	w1, #0x45                  	// #69
 111ecd4:	17ffffd6 	b	111ec2c <tee_obj_attr_copy_from+0xf8>
		} else if (o->info.objectType == TEE_TYPE_SM2_PKE_PUBLIC_KEY) {
 111ecd8:	528008e1 	mov	w1, #0x47                  	// #71
 111ecdc:	72b40001 	movk	w1, #0xa000, lsl #16
 111ece0:	6b0100df 	cmp	w6, w1
 111ece4:	54000061 	b.ne	111ecf0 <tee_obj_attr_copy_from+0x1bc>  // b.any
			if (src->info.objectType != TEE_TYPE_SM2_PKE_KEYPAIR)
 111ece8:	528008e1 	mov	w1, #0x47                  	// #71
 111ecec:	17ffffd0 	b	111ec2c <tee_obj_attr_copy_from+0xf8>
		} else if (o->info.objectType == TEE_TYPE_SM2_KEP_PUBLIC_KEY) {
 111ecf0:	528008c1 	mov	w1, #0x46                  	// #70
 111ecf4:	72b40001 	movk	w1, #0xa000, lsl #16
 111ecf8:	6b0100df 	cmp	w6, w1
 111ecfc:	54000341 	b.ne	111ed64 <tee_obj_attr_copy_from+0x230>  // b.any
			if (src->info.objectType != TEE_TYPE_SM2_KEP_KEYPAIR)
 111ed00:	528008c1 	mov	w1, #0x46                  	// #70
 111ed04:	17ffffca 	b	111ec2c <tee_obj_attr_copy_from+0xf8>
			ta = tp->type_attrs + n;
 111ed08:	9b187f60 	mul	x0, x27, x24
			idx = tee_svc_cryp_obj_find_type_attr_idx(ta->attr_id,
 111ed0c:	aa1a03e1 	mov	x1, x26
			ta = tp->type_attrs + n;
 111ed10:	f9400a62 	ldr	x2, [x19, #16]
 111ed14:	8b000047 	add	x7, x2, x0
			idx = tee_svc_cryp_obj_find_type_attr_idx(ta->attr_id,
 111ed18:	b8606840 	ldr	w0, [x2, x0]
 111ed1c:	97fff9d2 	bl	111d464 <tee_svc_cryp_obj_find_type_attr_idx>
			if (idx < 0)
 111ed20:	37fff280 	tbnz	w0, #31, 111eb70 <tee_obj_attr_copy_from+0x3c>
			res = attr_ops[ta->ops_index].from_obj(attr, src_attr);
 111ed24:	79400ce2 	ldrh	w2, [x7, #6]
				   tp_src->type_attrs[idx].raw_offs;
 111ed28:	9b387c01 	smull	x1, w0, w24
 111ed2c:	f9400b40 	ldr	x0, [x26, #16]
			attr = (uint8_t *)o->attr + ta->raw_offs;
 111ed30:	f9401e83 	ldr	x3, [x20, #56]
			res = attr_ops[ta->ops_index].from_obj(attr, src_attr);
 111ed34:	9b155c42 	madd	x2, x2, x21, x23
				   tp_src->type_attrs[idx].raw_offs;
 111ed38:	8b010000 	add	x0, x0, x1
			src_attr = (uint8_t *)src->attr +
 111ed3c:	f9401ec4 	ldr	x4, [x22, #56]
			res = attr_ops[ta->ops_index].from_obj(attr, src_attr);
 111ed40:	f9401042 	ldr	x2, [x2, #32]
				   tp_src->type_attrs[idx].raw_offs;
 111ed44:	79401001 	ldrh	w1, [x0, #8]
			attr = (uint8_t *)o->attr + ta->raw_offs;
 111ed48:	794010e0 	ldrh	w0, [x7, #8]
			res = attr_ops[ta->ops_index].from_obj(attr, src_attr);
 111ed4c:	8b010081 	add	x1, x4, x1
 111ed50:	8b000060 	add	x0, x3, x0
 111ed54:	d63f0040 	blr	x2
			if (res != TEE_SUCCESS)
 111ed58:	35fff0e0 	cbnz	w0, 111eb74 <tee_obj_attr_copy_from+0x40>
		for (n = 0; n < tp->num_type_attrs; n++) {
 111ed5c:	9100077b 	add	x27, x27, #0x1
 111ed60:	17ffffbf 	b	111ec5c <tee_obj_attr_copy_from+0x128>
				return TEE_ERROR_BAD_PARAMETERS;
 111ed64:	129fff20 	mov	w0, #0xffff0006            	// #-65530
 111ed68:	17ffff83 	b	111eb74 <tee_obj_attr_copy_from+0x40>

000000000111ed6c <tee_obj_set_type>:
{
 111ed6c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 111ed70:	910003fd 	mov	x29, sp
 111ed74:	a9025bf5 	stp	x21, x22, [sp, #32]
 111ed78:	aa0003f5 	mov	x21, x0
	if (o->attr)
 111ed7c:	f9401c00 	ldr	x0, [x0, #56]
{
 111ed80:	a90153f3 	stp	x19, x20, [sp, #16]
	if (o->attr)
 111ed84:	b5000560 	cbnz	x0, 111ee30 <tee_obj_set_type+0xc4>
	if (obj_type == TEE_TYPE_DATA) {
 111ed88:	528017e0 	mov	w0, #0xbf                  	// #191
 111ed8c:	2a0103f3 	mov	w19, w1
 111ed90:	72b40000 	movk	w0, #0xa000, lsl #16
 111ed94:	aa0203f4 	mov	x20, x2
 111ed98:	6b00003f 	cmp	w1, w0
 111ed9c:	54000081 	b.ne	111edac <tee_obj_set_type+0x40>  // b.any
		if (max_key_size)
 111eda0:	b40006c2 	cbz	x2, 111ee78 <tee_obj_set_type+0x10c>
			return TEE_ERROR_NOT_SUPPORTED;
 111eda4:	129ffea0 	mov	w0, #0xffff000a            	// #-65526
 111eda8:	14000015 	b	111edfc <tee_obj_set_type+0x90>
		type_props = tee_svc_find_type_props(obj_type);
 111edac:	2a0103e0 	mov	w0, w1
 111edb0:	97fff9bc 	bl	111d4a0 <tee_svc_find_type_props>
 111edb4:	aa0003e5 	mov	x5, x0
		if (!type_props)
 111edb8:	b4ffff60 	cbz	x0, 111eda4 <tee_obj_set_type+0x38>
		res = check_key_size(type_props, max_key_size);
 111edbc:	aa1403e1 	mov	x1, x20
 111edc0:	97fff9d8 	bl	111d520 <check_key_size>
		if (res)
 111edc4:	350001c0 	cbnz	w0, 111edfc <tee_obj_set_type+0x90>
		o->attr = calloc(1, type_props->alloc_size);
 111edc8:	794010a1 	ldrh	w1, [x5, #8]
 111edcc:	d2800020 	mov	x0, #0x1                   	// #1
 111edd0:	794010b6 	ldrh	w22, [x5, #8]
 111edd4:	940091bf 	bl	11434d0 <calloc>
 111edd8:	f9001ea0 	str	x0, [x21, #56]
 111eddc:	aa0003e3 	mov	x3, x0
		if (!o->attr)
 111ede0:	b50002c0 	cbnz	x0, 111ee38 <tee_obj_set_type+0xcc>
			return TEE_ERROR_OUT_OF_MEMORY;
 111ede4:	129ffe60 	mov	w0, #0xffff000c            	// #-65524
 111ede8:	14000005 	b	111edfc <tee_obj_set_type+0x90>
		res = crypto_acipher_alloc_rsa_public_key(o->attr,
 111edec:	aa1403e1 	mov	x1, x20
 111edf0:	aa0303e0 	mov	x0, x3
 111edf4:	94002f56 	bl	112ab4c <crypto_acipher_alloc_rsa_public_key>
	if (res != TEE_SUCCESS)
 111edf8:	34000400 	cbz	w0, 111ee78 <tee_obj_set_type+0x10c>
}
 111edfc:	a94153f3 	ldp	x19, x20, [sp, #16]
 111ee00:	a9425bf5 	ldp	x21, x22, [sp, #32]
 111ee04:	a8c37bfd 	ldp	x29, x30, [sp], #48
 111ee08:	d65f03c0 	ret
		res = crypto_acipher_alloc_rsa_keypair(o->attr, max_key_size);
 111ee0c:	aa1403e1 	mov	x1, x20
 111ee10:	94002f8a 	bl	112ac38 <crypto_acipher_alloc_rsa_keypair>
		break;
 111ee14:	17fffff9 	b	111edf8 <tee_obj_set_type+0x8c>
		res = crypto_acipher_alloc_dsa_public_key(o->attr,
 111ee18:	aa1403e1 	mov	x1, x20
 111ee1c:	94002ac9 	bl	1129940 <crypto_acipher_alloc_dsa_public_key>
		break;
 111ee20:	17fffff6 	b	111edf8 <tee_obj_set_type+0x8c>
		res = crypto_acipher_alloc_dh_keypair(o->attr, max_key_size);
 111ee24:	aa1403e1 	mov	x1, x20
 111ee28:	94003274 	bl	112b7f8 <crypto_acipher_alloc_dh_keypair>
		break;
 111ee2c:	17fffff3 	b	111edf8 <tee_obj_set_type+0x8c>
		return TEE_ERROR_BAD_STATE;
 111ee30:	129fff00 	mov	w0, #0xffff0007            	// #-65529
 111ee34:	17fffff2 	b	111edfc <tee_obj_set_type+0x90>
	switch (obj_type) {
 111ee38:	52800601 	mov	w1, #0x30                  	// #48
 111ee3c:	72b42001 	movk	w1, #0xa100, lsl #16
 111ee40:	6b01027f 	cmp	w19, w1
 111ee44:	54fffe40 	b.eq	111ee0c <tee_obj_set_type+0xa0>  // b.none
 111ee48:	54000488 	b.hi	111eed8 <tee_obj_set_type+0x16c>  // b.pmore
 111ee4c:	52800621 	mov	w1, #0x31                  	// #49
 111ee50:	72b40001 	movk	w1, #0xa000, lsl #16
 111ee54:	6b01027f 	cmp	w19, w1
 111ee58:	54fffe00 	b.eq	111ee18 <tee_obj_set_type+0xac>  // b.none
 111ee5c:	54000188 	b.hi	111ee8c <tee_obj_set_type+0x120>  // b.pmore
 111ee60:	52800600 	mov	w0, #0x30                  	// #48
 111ee64:	72b40000 	movk	w0, #0xa000, lsl #16
 111ee68:	6b00027f 	cmp	w19, w0
 111ee6c:	54fffc00 	b.eq	111edec <tee_obj_set_type+0x80>  // b.none
			key->alloc_size = type_props->alloc_size -
 111ee70:	510022d6 	sub	w22, w22, #0x8
 111ee74:	b9000476 	str	w22, [x3, #4]
	o->info.objectUsage = TEE_USAGE_DEFAULT;
 111ee78:	12800000 	mov	w0, #0xffffffff            	// #-1
	o->info.objectType = obj_type;
 111ee7c:	b90012b3 	str	w19, [x21, #16]
	o->info.objectUsage = TEE_USAGE_DEFAULT;
 111ee80:	290302b4 	stp	w20, w0, [x21, #24]
	return TEE_SUCCESS;
 111ee84:	52800000 	mov	w0, #0x0                   	// #0
 111ee88:	17ffffdd 	b	111edfc <tee_obj_set_type+0x90>
	switch (obj_type) {
 111ee8c:	52800840 	mov	w0, #0x42                  	// #66
 111ee90:	72b40000 	movk	w0, #0xa000, lsl #16
 111ee94:	6b00027f 	cmp	w19, w0
 111ee98:	54000148 	b.hi	111eec0 <tee_obj_set_type+0x154>  // b.pmore
 111ee9c:	52800800 	mov	w0, #0x40                  	// #64
 111eea0:	72b40000 	movk	w0, #0xa000, lsl #16
 111eea4:	6b00027f 	cmp	w19, w0
 111eea8:	54fffe49 	b.ls	111ee70 <tee_obj_set_type+0x104>  // b.plast
		res = crypto_acipher_alloc_ecc_public_key(o->attr, obj_type,
 111eeac:	aa1403e2 	mov	x2, x20
 111eeb0:	2a1303e1 	mov	w1, w19
 111eeb4:	aa0303e0 	mov	x0, x3
 111eeb8:	97ffbba6 	bl	110dd50 <crypto_acipher_alloc_ecc_public_key>
		break;
 111eebc:	17ffffcf 	b	111edf8 <tee_obj_set_type+0x8c>
	switch (obj_type) {
 111eec0:	529ff760 	mov	w0, #0xffbb                	// #65467
 111eec4:	72abffe0 	movk	w0, #0x5fff, lsl #16
 111eec8:	0b000260 	add	w0, w19, w0
 111eecc:	7100081f 	cmp	w0, #0x2
 111eed0:	54fffee9 	b.ls	111eeac <tee_obj_set_type+0x140>  // b.plast
 111eed4:	17ffffe7 	b	111ee70 <tee_obj_set_type+0x104>
 111eed8:	52800641 	mov	w1, #0x32                  	// #50
 111eedc:	72b42001 	movk	w1, #0xa100, lsl #16
 111eee0:	6b01027f 	cmp	w19, w1
 111eee4:	54fffa00 	b.eq	111ee24 <tee_obj_set_type+0xb8>  // b.none
 111eee8:	54000128 	b.hi	111ef0c <tee_obj_set_type+0x1a0>  // b.pmore
 111eeec:	52800620 	mov	w0, #0x31                  	// #49
 111eef0:	72b42000 	movk	w0, #0xa100, lsl #16
 111eef4:	6b00027f 	cmp	w19, w0
 111eef8:	54fffbc1 	b.ne	111ee70 <tee_obj_set_type+0x104>  // b.any
		res = crypto_acipher_alloc_dsa_keypair(o->attr, max_key_size);
 111eefc:	aa1403e1 	mov	x1, x20
 111ef00:	aa0303e0 	mov	x0, x3
 111ef04:	94002a66 	bl	112989c <crypto_acipher_alloc_dsa_keypair>
		break;
 111ef08:	17ffffbc 	b	111edf8 <tee_obj_set_type+0x8c>
	switch (obj_type) {
 111ef0c:	52800840 	mov	w0, #0x42                  	// #66
 111ef10:	72b42000 	movk	w0, #0xa100, lsl #16
 111ef14:	6b00027f 	cmp	w19, w0
 111ef18:	54000148 	b.hi	111ef40 <tee_obj_set_type+0x1d4>  // b.pmore
 111ef1c:	52800800 	mov	w0, #0x40                  	// #64
 111ef20:	72b42000 	movk	w0, #0xa100, lsl #16
 111ef24:	6b00027f 	cmp	w19, w0
 111ef28:	54fffa49 	b.ls	111ee70 <tee_obj_set_type+0x104>  // b.plast
		res = crypto_acipher_alloc_ecc_keypair(o->attr, obj_type,
 111ef2c:	aa1403e2 	mov	x2, x20
 111ef30:	2a1303e1 	mov	w1, w19
 111ef34:	aa0303e0 	mov	x0, x3
 111ef38:	97ffbb87 	bl	110dd54 <crypto_acipher_alloc_ecc_keypair>
		break;
 111ef3c:	17ffffaf 	b	111edf8 <tee_obj_set_type+0x8c>
	switch (obj_type) {
 111ef40:	529ff760 	mov	w0, #0xffbb                	// #65467
 111ef44:	72abdfe0 	movk	w0, #0x5eff, lsl #16
 111ef48:	0b000260 	add	w0, w19, w0
 111ef4c:	7100081f 	cmp	w0, #0x2
 111ef50:	54fffee9 	b.ls	111ef2c <tee_obj_set_type+0x1c0>  // b.plast
 111ef54:	17ffffc7 	b	111ee70 <tee_obj_set_type+0x104>

000000000111ef58 <syscall_cryp_obj_alloc>:
{
 111ef58:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 111ef5c:	910003fd 	mov	x29, sp
 111ef60:	a90153f3 	stp	x19, x20, [sp, #16]
 111ef64:	aa0003f3 	mov	x19, x0
 111ef68:	a9025bf5 	stp	x21, x22, [sp, #32]
 111ef6c:	aa0203f6 	mov	x22, x2
 111ef70:	f9001bf7 	str	x23, [sp, #48]
 111ef74:	aa0103f7 	mov	x23, x1
	struct ts_session *sess = ts_get_current_session();
 111ef78:	97ffd69a 	bl	11149e0 <ts_get_current_session>
 111ef7c:	aa0003f5 	mov	x21, x0
	o = tee_obj_alloc();
 111ef80:	94001c0a 	bl	1125fa8 <tee_obj_alloc>
	if (!o)
 111ef84:	b40003a0 	cbz	x0, 111eff8 <syscall_cryp_obj_alloc+0xa0>
	res = tee_obj_set_type(o, obj_type, max_key_size);
 111ef88:	2a1303e1 	mov	w1, w19
 111ef8c:	aa0003f4 	mov	x20, x0
 111ef90:	aa1703e2 	mov	x2, x23
 111ef94:	97ffff76 	bl	111ed6c <tee_obj_set_type>
 111ef98:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS) {
 111ef9c:	34000120 	cbz	w0, 111efc0 <syscall_cryp_obj_alloc+0x68>
		tee_obj_free(o);
 111efa0:	aa1403e0 	mov	x0, x20
 111efa4:	94001c04 	bl	1125fb4 <tee_obj_free>
}
 111efa8:	2a1303e0 	mov	w0, w19
 111efac:	a94153f3 	ldp	x19, x20, [sp, #16]
 111efb0:	a9425bf5 	ldp	x21, x22, [sp, #32]
 111efb4:	f9401bf7 	ldr	x23, [sp, #48]
 111efb8:	a8c47bfd 	ldp	x29, x30, [sp], #64
 111efbc:	d65f03c0 	ret
	tee_obj_add(to_user_ta_ctx(sess->ctx), o);
 111efc0:	f9400aa0 	ldr	x0, [x21, #16]
 111efc4:	97fffc8c 	bl	111e1f4 <to_user_ta_ctx>
 111efc8:	aa1403e1 	mov	x1, x20
 111efcc:	94001be7 	bl	1125f68 <tee_obj_add>
	res = copy_kaddr_to_uref(obj, o);
 111efd0:	aa1403e1 	mov	x1, x20
 111efd4:	aa1603e0 	mov	x0, x22
 111efd8:	97ffd82a 	bl	1115080 <copy_kaddr_to_uref>
 111efdc:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 111efe0:	34fffe40 	cbz	w0, 111efa8 <syscall_cryp_obj_alloc+0x50>
		tee_obj_close(to_user_ta_ctx(sess->ctx), o);
 111efe4:	f9400aa0 	ldr	x0, [x21, #16]
 111efe8:	97fffc83 	bl	111e1f4 <to_user_ta_ctx>
 111efec:	aa1403e1 	mov	x1, x20
 111eff0:	94001bfe 	bl	1125fe8 <tee_obj_close>
 111eff4:	17ffffed 	b	111efa8 <syscall_cryp_obj_alloc+0x50>
		return TEE_ERROR_OUT_OF_MEMORY;
 111eff8:	129ffe73 	mov	w19, #0xffff000c            	// #-65524
 111effc:	17ffffeb 	b	111efa8 <syscall_cryp_obj_alloc+0x50>

000000000111f000 <syscall_cryp_obj_close>:
{
 111f000:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 111f004:	910003fd 	mov	x29, sp
 111f008:	a90153f3 	stp	x19, x20, [sp, #16]
 111f00c:	f90013f5 	str	x21, [sp, #32]
 111f010:	aa0003f5 	mov	x21, x0
	struct ts_session *sess = ts_get_current_session();
 111f014:	97ffd673 	bl	11149e0 <ts_get_current_session>
 111f018:	aa0003f4 	mov	x20, x0
	res = tee_obj_get(to_user_ta_ctx(sess->ctx), uref_to_vaddr(obj), &o);
 111f01c:	f9400800 	ldr	x0, [x0, #16]
	struct tee_obj *o = NULL;
 111f020:	f9001fff 	str	xzr, [sp, #56]
	res = tee_obj_get(to_user_ta_ctx(sess->ctx), uref_to_vaddr(obj), &o);
 111f024:	97fffc74 	bl	111e1f4 <to_user_ta_ctx>
 111f028:	aa0003f3 	mov	x19, x0
 111f02c:	2a1503e0 	mov	w0, w21
 111f030:	97ffd822 	bl	11150b8 <uref_to_vaddr>
 111f034:	9100e3e2 	add	x2, sp, #0x38
 111f038:	aa0003e1 	mov	x1, x0
 111f03c:	aa1303e0 	mov	x0, x19
 111f040:	94001bcf 	bl	1125f7c <tee_obj_get>
 111f044:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 111f048:	35000100 	cbnz	w0, 111f068 <syscall_cryp_obj_close+0x68>
	if (o->busy)
 111f04c:	f9401fe0 	ldr	x0, [sp, #56]
 111f050:	3940b000 	ldrb	w0, [x0, #44]
 111f054:	35000140 	cbnz	w0, 111f07c <syscall_cryp_obj_close+0x7c>
	tee_obj_close(to_user_ta_ctx(sess->ctx), o);
 111f058:	f9400a80 	ldr	x0, [x20, #16]
 111f05c:	97fffc66 	bl	111e1f4 <to_user_ta_ctx>
 111f060:	f9401fe1 	ldr	x1, [sp, #56]
 111f064:	94001be1 	bl	1125fe8 <tee_obj_close>
}
 111f068:	2a1303e0 	mov	w0, w19
 111f06c:	a94153f3 	ldp	x19, x20, [sp, #16]
 111f070:	f94013f5 	ldr	x21, [sp, #32]
 111f074:	a8c47bfd 	ldp	x29, x30, [sp], #64
 111f078:	d65f03c0 	ret
		return TEE_ERROR_ITEM_NOT_FOUND;
 111f07c:	129ffef3 	mov	w19, #0xffff0008            	// #-65528
 111f080:	17fffffa 	b	111f068 <syscall_cryp_obj_close+0x68>

000000000111f084 <syscall_cryp_obj_reset>:
{
 111f084:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 111f088:	910003fd 	mov	x29, sp
 111f08c:	a90153f3 	stp	x19, x20, [sp, #16]
 111f090:	aa0003f4 	mov	x20, x0
	struct ts_session *sess = ts_get_current_session();
 111f094:	97ffd653 	bl	11149e0 <ts_get_current_session>
	res = tee_obj_get(to_user_ta_ctx(sess->ctx), uref_to_vaddr(obj), &o);
 111f098:	f9400800 	ldr	x0, [x0, #16]
	struct tee_obj *o = NULL;
 111f09c:	f90017ff 	str	xzr, [sp, #40]
	res = tee_obj_get(to_user_ta_ctx(sess->ctx), uref_to_vaddr(obj), &o);
 111f0a0:	97fffc55 	bl	111e1f4 <to_user_ta_ctx>
 111f0a4:	aa0003f3 	mov	x19, x0
 111f0a8:	2a1403e0 	mov	w0, w20
 111f0ac:	97ffd803 	bl	11150b8 <uref_to_vaddr>
 111f0b0:	9100a3e2 	add	x2, sp, #0x28
 111f0b4:	aa0003e1 	mov	x1, x0
 111f0b8:	aa1303e0 	mov	x0, x19
 111f0bc:	94001bb0 	bl	1125f7c <tee_obj_get>
 111f0c0:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 111f0c4:	350001a0 	cbnz	w0, 111f0f8 <syscall_cryp_obj_reset+0x74>
	if ((o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) == 0) {
 111f0c8:	f94017e0 	ldr	x0, [sp, #40]
 111f0cc:	b9402801 	ldr	w1, [x0, #40]
 111f0d0:	12100033 	and	w19, w1, #0x10000
 111f0d4:	378001a1 	tbnz	w1, #16, 111f108 <syscall_cryp_obj_reset+0x84>
		tee_obj_attr_clear(o);
 111f0d8:	97fffdf5 	bl	111e8ac <tee_obj_attr_clear>
		o->info.keySize = 0;
 111f0dc:	f94017e0 	ldr	x0, [sp, #40]
		o->info.objectUsage = TEE_USAGE_DEFAULT;
 111f0e0:	12800001 	mov	w1, #0xffffffff            	// #-1
 111f0e4:	b9001c01 	str	w1, [x0, #28]
	o->info.handleFlags &= ~TEE_HANDLE_FLAG_INITIALIZED;
 111f0e8:	b9402801 	ldr	w1, [x0, #40]
		o->info.keySize = 0;
 111f0ec:	b900141f 	str	wzr, [x0, #20]
	o->info.handleFlags &= ~TEE_HANDLE_FLAG_INITIALIZED;
 111f0f0:	120e7821 	and	w1, w1, #0xfffdffff
 111f0f4:	b9002801 	str	w1, [x0, #40]
}
 111f0f8:	2a1303e0 	mov	w0, w19
 111f0fc:	a94153f3 	ldp	x19, x20, [sp, #16]
 111f100:	a8c37bfd 	ldp	x29, x30, [sp], #48
 111f104:	d65f03c0 	ret
		return TEE_ERROR_BAD_PARAMETERS;
 111f108:	129fff33 	mov	w19, #0xffff0006            	// #-65530
 111f10c:	17fffffb 	b	111f0f8 <syscall_cryp_obj_reset+0x74>

000000000111f110 <syscall_cryp_obj_populate>:
{
 111f110:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 111f114:	910003fd 	mov	x29, sp
 111f118:	a90153f3 	stp	x19, x20, [sp, #16]
 111f11c:	aa0003f4 	mov	x20, x0
 111f120:	a9025bf5 	stp	x21, x22, [sp, #32]
 111f124:	aa0203f5 	mov	x21, x2
 111f128:	a90363f7 	stp	x23, x24, [sp, #48]
 111f12c:	aa0103f8 	mov	x24, x1
	struct ts_session *sess = ts_get_current_session();
 111f130:	97ffd62c 	bl	11149e0 <ts_get_current_session>
 111f134:	aa0003f7 	mov	x23, x0
	struct tee_obj *o = NULL;
 111f138:	f90027ff 	str	xzr, [sp, #72]
	res = tee_obj_get(to_user_ta_ctx(sess->ctx), uref_to_vaddr(obj), &o);
 111f13c:	f9400800 	ldr	x0, [x0, #16]
 111f140:	97fffc2d 	bl	111e1f4 <to_user_ta_ctx>
 111f144:	aa0003f3 	mov	x19, x0
 111f148:	2a1403e0 	mov	w0, w20
 111f14c:	97ffd7db 	bl	11150b8 <uref_to_vaddr>
 111f150:	910123e2 	add	x2, sp, #0x48
 111f154:	aa0003e1 	mov	x1, x0
 111f158:	aa1303e0 	mov	x0, x19
 111f15c:	94001b88 	bl	1125f7c <tee_obj_get>
 111f160:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 111f164:	35000260 	cbnz	w0, 111f1b0 <syscall_cryp_obj_populate+0xa0>
	if ((o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) != 0)
 111f168:	f94027e0 	ldr	x0, [sp, #72]
	if ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) != 0)
 111f16c:	b9402801 	ldr	w1, [x0, #40]
 111f170:	7210043f 	tst	w1, #0x30000
 111f174:	54000601 	b.ne	111f234 <syscall_cryp_obj_populate+0x124>  // b.any
	type_props = tee_svc_find_type_props(o->info.objectType);
 111f178:	b9401000 	ldr	w0, [x0, #16]
 111f17c:	97fff8c9 	bl	111d4a0 <tee_svc_find_type_props>
 111f180:	aa0003f6 	mov	x22, x0
	if (!type_props)
 111f184:	b40005c0 	cbz	x0, 111f23c <syscall_cryp_obj_populate+0x12c>
	if (MUL_OVERFLOW(sizeof(TEE_Attribute), attr_count, &alloc_size))
 111f188:	d2800302 	mov	x2, #0x18                  	// #24
 111f18c:	9b027ea0 	mul	x0, x21, x2
 111f190:	9bc27ea2 	umulh	x2, x21, x2
 111f194:	b50000c2 	cbnz	x2, 111f1ac <syscall_cryp_obj_populate+0x9c>
	attrs = malloc(alloc_size);
 111f198:	940090b0 	bl	1143458 <malloc>
 111f19c:	aa0003f4 	mov	x20, x0
	if (!attrs)
 111f1a0:	b5000140 	cbnz	x0, 111f1c8 <syscall_cryp_obj_populate+0xb8>
		return TEE_ERROR_OUT_OF_MEMORY;
 111f1a4:	129ffe73 	mov	w19, #0xffff000c            	// #-65524
 111f1a8:	14000002 	b	111f1b0 <syscall_cryp_obj_populate+0xa0>
		return TEE_ERROR_OVERFLOW;
 111f1ac:	1299fe13 	mov	w19, #0xffff300f            	// #-53233
}
 111f1b0:	2a1303e0 	mov	w0, w19
 111f1b4:	a94153f3 	ldp	x19, x20, [sp, #16]
 111f1b8:	a9425bf5 	ldp	x21, x22, [sp, #32]
 111f1bc:	a94363f7 	ldp	x23, x24, [sp, #48]
 111f1c0:	a8c57bfd 	ldp	x29, x30, [sp], #80
 111f1c4:	d65f03c0 	ret
	res = copy_in_attrs(to_user_ta_ctx(sess->ctx), usr_attrs, attr_count,
 111f1c8:	f9400ae0 	ldr	x0, [x23, #16]
 111f1cc:	97fffc0a 	bl	111e1f4 <to_user_ta_ctx>
 111f1d0:	aa1403e3 	mov	x3, x20
 111f1d4:	2a1503e2 	mov	w2, w21
 111f1d8:	aa1803e1 	mov	x1, x24
 111f1dc:	97fffaff 	bl	111ddd8 <copy_in_attrs>
 111f1e0:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 111f1e4:	35000220 	cbnz	w0, 111f228 <syscall_cryp_obj_populate+0x118>
	res = tee_svc_cryp_check_attr(ATTR_USAGE_POPULATE, type_props,
 111f1e8:	2a1503e3 	mov	w3, w21
 111f1ec:	aa1403e2 	mov	x2, x20
 111f1f0:	aa1603e1 	mov	x1, x22
 111f1f4:	97fff8e5 	bl	111d588 <tee_svc_cryp_check_attr>
 111f1f8:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 111f1fc:	35000160 	cbnz	w0, 111f228 <syscall_cryp_obj_populate+0x118>
	res = tee_svc_cryp_obj_populate_type(o, type_props, attrs, attr_count);
 111f200:	f94027e0 	ldr	x0, [sp, #72]
 111f204:	2a1503e3 	mov	w3, w21
 111f208:	aa1403e2 	mov	x2, x20
 111f20c:	97fff930 	bl	111d6cc <tee_svc_cryp_obj_populate_type>
 111f210:	2a0003f3 	mov	w19, w0
	if (res == TEE_SUCCESS)
 111f214:	350000a0 	cbnz	w0, 111f228 <syscall_cryp_obj_populate+0x118>
		o->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;
 111f218:	f94027e1 	ldr	x1, [sp, #72]
 111f21c:	b9402820 	ldr	w0, [x1, #40]
 111f220:	320f0000 	orr	w0, w0, #0x20000
 111f224:	b9002820 	str	w0, [x1, #40]
	free_wipe(attrs);
 111f228:	aa1403e0 	mov	x0, x20
 111f22c:	940090ef 	bl	11435e8 <free_wipe>
	return res;
 111f230:	17ffffe0 	b	111f1b0 <syscall_cryp_obj_populate+0xa0>
		return TEE_ERROR_BAD_PARAMETERS;
 111f234:	129fff33 	mov	w19, #0xffff0006            	// #-65530
 111f238:	17ffffde 	b	111f1b0 <syscall_cryp_obj_populate+0xa0>
		return TEE_ERROR_NOT_IMPLEMENTED;
 111f23c:	129ffed3 	mov	w19, #0xffff0009            	// #-65527
 111f240:	17ffffdc 	b	111f1b0 <syscall_cryp_obj_populate+0xa0>

000000000111f244 <syscall_cryp_obj_copy>:
{
 111f244:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 111f248:	910003fd 	mov	x29, sp
 111f24c:	a90153f3 	stp	x19, x20, [sp, #16]
 111f250:	aa0103f4 	mov	x20, x1
 111f254:	a9025bf5 	stp	x21, x22, [sp, #32]
 111f258:	aa0003f6 	mov	x22, x0
	struct ts_session *sess = ts_get_current_session();
 111f25c:	97ffd5e1 	bl	11149e0 <ts_get_current_session>
 111f260:	aa0003f3 	mov	x19, x0
	struct tee_obj *src_o = NULL;
 111f264:	a9037fff 	stp	xzr, xzr, [sp, #48]
	res = tee_obj_get(to_user_ta_ctx(sess->ctx),
 111f268:	f9400800 	ldr	x0, [x0, #16]
 111f26c:	97fffbe2 	bl	111e1f4 <to_user_ta_ctx>
 111f270:	aa0003f5 	mov	x21, x0
 111f274:	2a1603e0 	mov	w0, w22
 111f278:	97ffd790 	bl	11150b8 <uref_to_vaddr>
 111f27c:	9100c3e2 	add	x2, sp, #0x30
 111f280:	aa0003e1 	mov	x1, x0
 111f284:	aa1503e0 	mov	x0, x21
 111f288:	94001b3d 	bl	1125f7c <tee_obj_get>
	if (res != TEE_SUCCESS)
 111f28c:	350003a0 	cbnz	w0, 111f300 <syscall_cryp_obj_copy+0xbc>
	res = tee_obj_get(to_user_ta_ctx(sess->ctx),
 111f290:	f9400a60 	ldr	x0, [x19, #16]
 111f294:	97fffbd8 	bl	111e1f4 <to_user_ta_ctx>
 111f298:	aa0003f3 	mov	x19, x0
 111f29c:	2a1403e0 	mov	w0, w20
 111f2a0:	97ffd786 	bl	11150b8 <uref_to_vaddr>
 111f2a4:	9100e3e2 	add	x2, sp, #0x38
 111f2a8:	aa0003e1 	mov	x1, x0
 111f2ac:	aa1303e0 	mov	x0, x19
 111f2b0:	94001b33 	bl	1125f7c <tee_obj_get>
	if (res != TEE_SUCCESS)
 111f2b4:	35000260 	cbnz	w0, 111f300 <syscall_cryp_obj_copy+0xbc>
	if ((src_o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)
 111f2b8:	f9401fe1 	ldr	x1, [sp, #56]
 111f2bc:	b9402820 	ldr	w0, [x1, #40]
 111f2c0:	36880280 	tbz	w0, #17, 111f310 <syscall_cryp_obj_copy+0xcc>
	if ((dst_o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) != 0)
 111f2c4:	f9401be0 	ldr	x0, [sp, #48]
	if ((dst_o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) != 0)
 111f2c8:	b9402802 	ldr	w2, [x0, #40]
 111f2cc:	7210045f 	tst	w2, #0x30000
 111f2d0:	54000201 	b.ne	111f310 <syscall_cryp_obj_copy+0xcc>  // b.any
	res = tee_obj_attr_copy_from(dst_o, src_o);
 111f2d4:	97fffe18 	bl	111eb34 <tee_obj_attr_copy_from>
	if (res != TEE_SUCCESS)
 111f2d8:	35000140 	cbnz	w0, 111f300 <syscall_cryp_obj_copy+0xbc>
	dst_o->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;
 111f2dc:	f9401be1 	ldr	x1, [sp, #48]
 111f2e0:	b9402822 	ldr	w2, [x1, #40]
 111f2e4:	320f0042 	orr	w2, w2, #0x20000
 111f2e8:	b9002822 	str	w2, [x1, #40]
	dst_o->info.keySize = src_o->info.keySize;
 111f2ec:	f9401fe2 	ldr	x2, [sp, #56]
 111f2f0:	b9401443 	ldr	w3, [x2, #20]
	dst_o->info.objectUsage = src_o->info.objectUsage;
 111f2f4:	b9401c42 	ldr	w2, [x2, #28]
	dst_o->info.keySize = src_o->info.keySize;
 111f2f8:	b9001423 	str	w3, [x1, #20]
	dst_o->info.objectUsage = src_o->info.objectUsage;
 111f2fc:	b9001c22 	str	w2, [x1, #28]
}
 111f300:	a94153f3 	ldp	x19, x20, [sp, #16]
 111f304:	a9425bf5 	ldp	x21, x22, [sp, #32]
 111f308:	a8c47bfd 	ldp	x29, x30, [sp], #64
 111f30c:	d65f03c0 	ret
		return TEE_ERROR_BAD_PARAMETERS;
 111f310:	129fff20 	mov	w0, #0xffff0006            	// #-65530
 111f314:	17fffffb 	b	111f300 <syscall_cryp_obj_copy+0xbc>

000000000111f318 <syscall_obj_generate_key>:
{
 111f318:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
 111f31c:	910003fd 	mov	x29, sp
 111f320:	a90153f3 	stp	x19, x20, [sp, #16]
 111f324:	a9025bf5 	stp	x21, x22, [sp, #32]
 111f328:	aa0103f6 	mov	x22, x1
 111f32c:	aa0003f5 	mov	x21, x0
 111f330:	a90363f7 	stp	x23, x24, [sp, #48]
 111f334:	aa0203f8 	mov	x24, x2
 111f338:	f90023f9 	str	x25, [sp, #64]
 111f33c:	aa0303f9 	mov	x25, x3
	struct ts_session *sess = ts_get_current_session();
 111f340:	97ffd5a8 	bl	11149e0 <ts_get_current_session>
 111f344:	aa0003f4 	mov	x20, x0
	res = tee_obj_get(to_user_ta_ctx(sess->ctx), uref_to_vaddr(obj), &o);
 111f348:	f9400800 	ldr	x0, [x0, #16]
	struct tee_obj *o = NULL;
 111f34c:	f9002fff 	str	xzr, [sp, #88]
	res = tee_obj_get(to_user_ta_ctx(sess->ctx), uref_to_vaddr(obj), &o);
 111f350:	97fffba9 	bl	111e1f4 <to_user_ta_ctx>
 111f354:	aa0003f3 	mov	x19, x0
 111f358:	2a1503e0 	mov	w0, w21
 111f35c:	97ffd757 	bl	11150b8 <uref_to_vaddr>
 111f360:	910163e2 	add	x2, sp, #0x58
 111f364:	aa0003e1 	mov	x1, x0
 111f368:	aa1303e0 	mov	x0, x19
 111f36c:	94001b04 	bl	1125f7c <tee_obj_get>
 111f370:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 111f374:	350002e0 	cbnz	w0, 111f3d0 <syscall_obj_generate_key+0xb8>
	if ((o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) != 0)
 111f378:	f9402fe0 	ldr	x0, [sp, #88]
	if ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) != 0)
 111f37c:	b9402801 	ldr	w1, [x0, #40]
 111f380:	7210043f 	tst	w1, #0x30000
 111f384:	540022c1 	b.ne	111f7dc <syscall_obj_generate_key+0x4c4>  // b.any
	type_props = tee_svc_find_type_props(o->info.objectType);
 111f388:	b9401000 	ldr	w0, [x0, #16]
 111f38c:	97fff845 	bl	111d4a0 <tee_svc_find_type_props>
 111f390:	aa0003f5 	mov	x21, x0
	if (!type_props)
 111f394:	b4002280 	cbz	x0, 111f7e4 <syscall_obj_generate_key+0x4cc>
	res = check_key_size(type_props, key_size);
 111f398:	aa1603e1 	mov	x1, x22
 111f39c:	97fff861 	bl	111d520 <check_key_size>
 111f3a0:	2a0003f3 	mov	w19, w0
	if (res)
 111f3a4:	35000160 	cbnz	w0, 111f3d0 <syscall_obj_generate_key+0xb8>
	if (MUL_OVERFLOW(sizeof(TEE_Attribute), param_count, &alloc_size))
 111f3a8:	d2800301 	mov	x1, #0x18                  	// #24
 111f3ac:	9b017f20 	mul	x0, x25, x1
 111f3b0:	9bc17f21 	umulh	x1, x25, x1
 111f3b4:	b50000c1 	cbnz	x1, 111f3cc <syscall_obj_generate_key+0xb4>
	params = malloc(alloc_size);
 111f3b8:	94009028 	bl	1143458 <malloc>
 111f3bc:	aa0003f7 	mov	x23, x0
	if (!params)
 111f3c0:	b5000160 	cbnz	x0, 111f3ec <syscall_obj_generate_key+0xd4>
		return TEE_ERROR_OUT_OF_MEMORY;
 111f3c4:	129ffe73 	mov	w19, #0xffff000c            	// #-65524
 111f3c8:	14000002 	b	111f3d0 <syscall_obj_generate_key+0xb8>
		return TEE_ERROR_OVERFLOW;
 111f3cc:	1299fe13 	mov	w19, #0xffff300f            	// #-53233
}
 111f3d0:	2a1303e0 	mov	w0, w19
 111f3d4:	a94153f3 	ldp	x19, x20, [sp, #16]
 111f3d8:	a9425bf5 	ldp	x21, x22, [sp, #32]
 111f3dc:	a94363f7 	ldp	x23, x24, [sp, #48]
 111f3e0:	f94023f9 	ldr	x25, [sp, #64]
 111f3e4:	a8c87bfd 	ldp	x29, x30, [sp], #128
 111f3e8:	d65f03c0 	ret
	res = copy_in_attrs(to_user_ta_ctx(sess->ctx), usr_params, param_count,
 111f3ec:	f9400a80 	ldr	x0, [x20, #16]
 111f3f0:	97fffb81 	bl	111e1f4 <to_user_ta_ctx>
 111f3f4:	aa1703e3 	mov	x3, x23
 111f3f8:	2a1903e2 	mov	w2, w25
 111f3fc:	aa1803e1 	mov	x1, x24
 111f400:	97fffa76 	bl	111ddd8 <copy_in_attrs>
 111f404:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 111f408:	35001920 	cbnz	w0, 111f72c <syscall_obj_generate_key+0x414>
	res = tee_svc_cryp_check_attr(ATTR_USAGE_GENERATE_KEY, type_props,
 111f40c:	2a1903e3 	mov	w3, w25
 111f410:	aa1703e2 	mov	x2, x23
 111f414:	aa1503e1 	mov	x1, x21
 111f418:	52800020 	mov	w0, #0x1                   	// #1
 111f41c:	97fff85b 	bl	111d588 <tee_svc_cryp_check_attr>
 111f420:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 111f424:	35001840 	cbnz	w0, 111f72c <syscall_obj_generate_key+0x414>
	switch (o->info.objectType) {
 111f428:	f9402ff4 	ldr	x20, [sp, #88]
 111f42c:	52800621 	mov	w1, #0x31                  	// #49
 111f430:	72b42001 	movk	w1, #0xa100, lsl #16
 111f434:	b9401280 	ldr	w0, [x20, #16]
 111f438:	6b01001f 	cmp	w0, w1
 111f43c:	54001b20 	b.eq	111f7a0 <syscall_obj_generate_key+0x488>  // b.none
 111f440:	54000848 	b.hi	111f548 <syscall_obj_generate_key+0x230>  // b.pmore
 111f444:	52800281 	mov	w1, #0x14                  	// #20
 111f448:	72b40001 	movk	w1, #0xa000, lsl #16
 111f44c:	6b01001f 	cmp	w0, w1
 111f450:	54000188 	b.hi	111f480 <syscall_obj_generate_key+0x168>  // b.pmore
 111f454:	12ac0001 	mov	w1, #0x9fffffff            	// #-1610612737
 111f458:	6b01001f 	cmp	w0, w1
 111f45c:	540000e9 	b.ls	111f478 <syscall_obj_generate_key+0x160>  // b.plast
 111f460:	d2800021 	mov	x1, #0x1                   	// #1
 111f464:	d2801fe2 	mov	x2, #0xff                  	// #255
 111f468:	9ac02021 	lsl	x1, x1, x0
 111f46c:	f2a00362 	movk	x2, #0x1b, lsl #16
 111f470:	ea02003f 	tst	x1, x2
 111f474:	54001321 	b.ne	111f6d8 <syscall_obj_generate_key+0x3c0>  // b.any
 111f478:	129fff53 	mov	w19, #0xffff0005            	// #-65531
 111f47c:	140000ac 	b	111f72c <syscall_obj_generate_key+0x414>
 111f480:	52800601 	mov	w1, #0x30                  	// #48
 111f484:	72b42001 	movk	w1, #0xa100, lsl #16
 111f488:	6b01001f 	cmp	w0, w1
 111f48c:	54ffff61 	b.ne	111f478 <syscall_obj_generate_key+0x160>  // b.any
	uint32_t e = TEE_U32_TO_BIG_ENDIAN(65537);
 111f490:	320883e0 	mov	w0, #0x1000100             	// #16777472
	res = tee_svc_cryp_obj_populate_type(o, type_props, params,
 111f494:	2a1903e3 	mov	w3, w25
 111f498:	aa1703e2 	mov	x2, x23
 111f49c:	aa1503e1 	mov	x1, x21
	uint32_t e = TEE_U32_TO_BIG_ENDIAN(65537);
 111f4a0:	b90057e0 	str	w0, [sp, #84]
	res = tee_svc_cryp_obj_populate_type(o, type_props, params,
 111f4a4:	aa1403e0 	mov	x0, x20
	struct rsa_keypair *key = o->attr;
 111f4a8:	f9401e98 	ldr	x24, [x20, #56]
	res = tee_svc_cryp_obj_populate_type(o, type_props, params,
 111f4ac:	97fff888 	bl	111d6cc <tee_svc_cryp_obj_populate_type>
 111f4b0:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 111f4b4:	350013c0 	cbnz	w0, 111f72c <syscall_obj_generate_key+0x414>
	int idx = tee_svc_cryp_obj_find_type_attr_idx(attr, props);
 111f4b8:	52804600 	mov	w0, #0x230                 	// #560
 111f4bc:	aa1503e1 	mov	x1, x21
 111f4c0:	72ba0000 	movk	w0, #0xd000, lsl #16
 111f4c4:	97fff7e8 	bl	111d464 <tee_svc_cryp_obj_find_type_attr_idx>
	if (idx < 0)
 111f4c8:	f9400319 	ldr	x25, [x24]
 111f4cc:	37f814c0 	tbnz	w0, #31, 111f764 <syscall_obj_generate_key+0x44c>
	return o->have_attrs & BIT(idx);
 111f4d0:	52800021 	mov	w1, #0x1                   	// #1
 111f4d4:	1ac02020 	lsl	w0, w1, w0
 111f4d8:	b9403281 	ldr	w1, [x20, #48]
	if (get_attribute(o, type_props, TEE_ATTR_RSA_PUBLIC_EXPONENT)) {
 111f4dc:	6a01001f 	tst	w0, w1
 111f4e0:	54001420 	b.eq	111f764 <syscall_obj_generate_key+0x44c>  // b.none
	size_t n = crypto_bignum_num_bytes(e);
 111f4e4:	aa1903e0 	mov	x0, x25
 111f4e8:	94003b1d 	bl	112e15c <crypto_bignum_num_bytes>
	uint8_t bin_key[256 / 8] = { 0 };
 111f4ec:	a9067fff 	stp	xzr, xzr, [sp, #96]
	size_t n = crypto_bignum_num_bytes(e);
 111f4f0:	aa0003f3 	mov	x19, x0
	if (n > sizeof(bin_key) || n < 3)
 111f4f4:	d1000c00 	sub	x0, x0, #0x3
	uint8_t bin_key[256 / 8] = { 0 };
 111f4f8:	a9077fff 	stp	xzr, xzr, [sp, #112]
	if (n > sizeof(bin_key) || n < 3)
 111f4fc:	f100741f 	cmp	x0, #0x1d
 111f500:	54000208 	b.hi	111f540 <syscall_obj_generate_key+0x228>  // b.pmore
	crypto_bignum_bn2bin(e, bin_key);
 111f504:	aa1903e0 	mov	x0, x25
 111f508:	910183e1 	add	x1, sp, #0x60
 111f50c:	94003b15 	bl	112e160 <crypto_bignum_bn2bin>
	if (!(bin_key[n - 1] & 1)) /* key must be odd */
 111f510:	91017fe0 	add	x0, sp, #0x5f
 111f514:	38736800 	ldrb	w0, [x0, x19]
 111f518:	36000140 	tbz	w0, #0, 111f540 <syscall_obj_generate_key+0x228>
	if (n == 3) {
 111f51c:	f1000e7f 	cmp	x19, #0x3
 111f520:	540012a1 	b.ne	111f774 <syscall_obj_generate_key+0x45c>  // b.any
			key <<= 8;
 111f524:	7940c3e0 	ldrh	w0, [sp, #96]
			key |= bin_key[n];
 111f528:	39418be1 	ldrb	w1, [sp, #98]
 111f52c:	5ac00400 	rev16	w0, w0
			key <<= 8;
 111f530:	53183c00 	ubfiz	w0, w0, #8, #16
			key |= bin_key[n];
 111f534:	2a000020 	orr	w0, w1, w0
		if (key < 65537)
 111f538:	7140401f 	cmp	w0, #0x10, lsl #12
 111f53c:	540011c8 	b.hi	111f774 <syscall_obj_generate_key+0x45c>  // b.pmore
			return TEE_ERROR_BAD_PARAMETERS;
 111f540:	129fff33 	mov	w19, #0xffff0006            	// #-65530
 111f544:	1400007a 	b	111f72c <syscall_obj_generate_key+0x414>
	switch (o->info.objectType) {
 111f548:	52800841 	mov	w1, #0x42                  	// #66
 111f54c:	72b42001 	movk	w1, #0xa100, lsl #16
 111f550:	6b01001f 	cmp	w0, w1
 111f554:	540007e8 	b.hi	111f650 <syscall_obj_generate_key+0x338>  // b.pmore
 111f558:	52800801 	mov	w1, #0x40                  	// #64
 111f55c:	72b42001 	movk	w1, #0xa100, lsl #16
 111f560:	6b01001f 	cmp	w0, w1
 111f564:	540007e8 	b.hi	111f660 <syscall_obj_generate_key+0x348>  // b.pmore
 111f568:	52800641 	mov	w1, #0x32                  	// #50
 111f56c:	72b42001 	movk	w1, #0xa100, lsl #16
 111f570:	6b01001f 	cmp	w0, w1
 111f574:	54fff821 	b.ne	111f478 <syscall_obj_generate_key+0x160>  // b.any
	res = tee_svc_cryp_obj_populate_type(o, type_props, params,
 111f578:	2a1903e3 	mov	w3, w25
 111f57c:	aa1703e2 	mov	x2, x23
 111f580:	aa1503e1 	mov	x1, x21
 111f584:	aa1403e0 	mov	x0, x20
 111f588:	97fff851 	bl	111d6cc <tee_svc_cryp_obj_populate_type>
 111f58c:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 111f590:	35000ce0 	cbnz	w0, 111f72c <syscall_obj_generate_key+0x414>
	tee_dh_key = (struct dh_keypair *)o->attr;
 111f594:	f9401e87 	ldr	x7, [x20, #56]
	int idx = tee_svc_cryp_obj_find_type_attr_idx(attr, props);
 111f598:	52822640 	mov	w0, #0x1132                	// #4402
 111f59c:	aa1503e1 	mov	x1, x21
 111f5a0:	72ba0000 	movk	w0, #0xd000, lsl #16
 111f5a4:	97fff7b0 	bl	111d464 <tee_svc_cryp_obj_find_type_attr_idx>
	if (idx < 0)
 111f5a8:	37f81120 	tbnz	w0, #31, 111f7cc <syscall_obj_generate_key+0x4b4>
	return o->have_attrs & BIT(idx);
 111f5ac:	52800021 	mov	w1, #0x1                   	// #1
 111f5b0:	1ac02020 	lsl	w0, w1, w0
 111f5b4:	b9403281 	ldr	w1, [x20, #48]
	if (get_attribute(o, type_props, TEE_ATTR_DH_SUBPRIME))
 111f5b8:	6a01001f 	tst	w0, w1
 111f5bc:	54001080 	b.eq	111f7cc <syscall_obj_generate_key+0x4b4>  // b.none
		dh_q = tee_dh_key->q;
 111f5c0:	f94010e8 	ldr	x8, [x7, #32]
	int idx = tee_svc_cryp_obj_find_type_attr_idx(attr, props);
 111f5c4:	52826640 	mov	w0, #0x1332                	// #4914
 111f5c8:	aa1503e1 	mov	x1, x21
 111f5cc:	72be0000 	movk	w0, #0xf000, lsl #16
 111f5d0:	97fff7a5 	bl	111d464 <tee_svc_cryp_obj_find_type_attr_idx>
	if (idx < 0)
 111f5d4:	37f800e0 	tbnz	w0, #31, 111f5f0 <syscall_obj_generate_key+0x2d8>
	return o->have_attrs & BIT(idx);
 111f5d8:	52800033 	mov	w19, #0x1                   	// #1
 111f5dc:	1ac02260 	lsl	w0, w19, w0
 111f5e0:	b9403293 	ldr	w19, [x20, #48]
	if (get_attribute(o, type_props, TEE_ATTR_DH_X_BITS))
 111f5e4:	6a130013 	ands	w19, w0, w19
 111f5e8:	54000040 	b.eq	111f5f0 <syscall_obj_generate_key+0x2d8>  // b.none
		dh_xbits = tee_dh_key->xbits;
 111f5ec:	b94028f3 	ldr	w19, [x7, #40]
	res = crypto_acipher_gen_dh_key(tee_dh_key, dh_q, dh_xbits, key_size);
 111f5f0:	2a1303e2 	mov	w2, w19
 111f5f4:	2a1603e3 	mov	w3, w22
 111f5f8:	aa0803e1 	mov	x1, x8
 111f5fc:	aa0703e0 	mov	x0, x7
 111f600:	940030a7 	bl	112b89c <crypto_acipher_gen_dh_key>
 111f604:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 111f608:	35000920 	cbnz	w0, 111f72c <syscall_obj_generate_key+0x414>
 111f60c:	9100c294 	add	x20, x20, #0x30
	set_attribute(o, type_props, TEE_ATTR_DH_PUBLIC_VALUE);
 111f610:	52802642 	mov	w2, #0x132                 	// #306
 111f614:	aa1503e1 	mov	x1, x21
 111f618:	aa1403e0 	mov	x0, x20
 111f61c:	72ba0002 	movk	w2, #0xd000, lsl #16
 111f620:	97fffa64 	bl	111dfb0 <set_attribute.isra.0>
	set_attribute(o, type_props, TEE_ATTR_DH_PRIVATE_VALUE);
 111f624:	52804642 	mov	w2, #0x232                 	// #562
 111f628:	aa1503e1 	mov	x1, x21
 111f62c:	72b80002 	movk	w2, #0xc000, lsl #16
 111f630:	aa1403e0 	mov	x0, x20
 111f634:	97fffa5f 	bl	111dfb0 <set_attribute.isra.0>
	set_attribute(o, type_props, TEE_ATTR_DH_X_BITS);
 111f638:	52826642 	mov	w2, #0x1332                	// #4914
	set_attribute(o, type_props, TEE_ATTR_ECC_CURVE);
 111f63c:	aa1503e1 	mov	x1, x21
 111f640:	aa1403e0 	mov	x0, x20
 111f644:	72be0002 	movk	w2, #0xf000, lsl #16
 111f648:	97fffa5a 	bl	111dfb0 <set_attribute.isra.0>
	return TEE_SUCCESS;
 111f64c:	14000038 	b	111f72c <syscall_obj_generate_key+0x414>
	switch (o->info.objectType) {
 111f650:	528008e1 	mov	w1, #0x47                  	// #71
 111f654:	72b42001 	movk	w1, #0xa100, lsl #16
 111f658:	6b01001f 	cmp	w0, w1
 111f65c:	54fff0e1 	b.ne	111f478 <syscall_obj_generate_key+0x160>  // b.any
	res = tee_svc_cryp_obj_populate_type(o, type_props, params,
 111f660:	2a1903e3 	mov	w3, w25
 111f664:	aa1703e2 	mov	x2, x23
 111f668:	aa1503e1 	mov	x1, x21
 111f66c:	aa1403e0 	mov	x0, x20
 111f670:	97fff817 	bl	111d6cc <tee_svc_cryp_obj_populate_type>
 111f674:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 111f678:	350005a0 	cbnz	w0, 111f72c <syscall_obj_generate_key+0x414>
	res = crypto_acipher_gen_ecc_key(tee_ecc_key, key_size);
 111f67c:	f9401e80 	ldr	x0, [x20, #56]
 111f680:	2a1603e1 	mov	w1, w22
 111f684:	97ffb9c6 	bl	110dd9c <crypto_acipher_gen_ecc_key>
 111f688:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 111f68c:	35000500 	cbnz	w0, 111f72c <syscall_obj_generate_key+0x414>
	set_attribute(o, type_props, TEE_ATTR_ECC_PRIVATE_VALUE);
 111f690:	9100c294 	add	x20, x20, #0x30
 111f694:	52806822 	mov	w2, #0x341                 	// #833
 111f698:	aa1503e1 	mov	x1, x21
 111f69c:	aa1403e0 	mov	x0, x20
 111f6a0:	72b80002 	movk	w2, #0xc000, lsl #16
 111f6a4:	97fffa43 	bl	111dfb0 <set_attribute.isra.0>
	set_attribute(o, type_props, TEE_ATTR_ECC_PUBLIC_VALUE_X);
 111f6a8:	52802822 	mov	w2, #0x141                 	// #321
 111f6ac:	aa1503e1 	mov	x1, x21
 111f6b0:	aa1403e0 	mov	x0, x20
 111f6b4:	72ba0002 	movk	w2, #0xd000, lsl #16
 111f6b8:	97fffa3e 	bl	111dfb0 <set_attribute.isra.0>
	set_attribute(o, type_props, TEE_ATTR_ECC_PUBLIC_VALUE_Y);
 111f6bc:	52804822 	mov	w2, #0x241                 	// #577
 111f6c0:	aa1503e1 	mov	x1, x21
 111f6c4:	72ba0002 	movk	w2, #0xd000, lsl #16
 111f6c8:	aa1403e0 	mov	x0, x20
 111f6cc:	97fffa39 	bl	111dfb0 <set_attribute.isra.0>
	set_attribute(o, type_props, TEE_ATTR_ECC_CURVE);
 111f6d0:	52808822 	mov	w2, #0x441                 	// #1089
 111f6d4:	17ffffda 	b	111f63c <syscall_obj_generate_key+0x324>
		if (is_gp_legacy_des_key_size(o->info.objectType, key_size))
 111f6d8:	aa1603e1 	mov	x1, x22
 111f6dc:	97fff780 	bl	111d4dc <is_gp_legacy_des_key_size>
 111f6e0:	72001c1f 	tst	w0, #0xff
 111f6e4:	54000361 	b.ne	111f750 <syscall_obj_generate_key+0x438>  // b.any
		byte_size = key_size / 8;
 111f6e8:	d343fed8 	lsr	x24, x22, #3
		key = (struct tee_cryp_obj_secret *)o->attr;
 111f6ec:	f9401e94 	ldr	x20, [x20, #56]
		if (byte_size > key->alloc_size) {
 111f6f0:	b9400680 	ldr	w0, [x20, #4]
 111f6f4:	eb18001f 	cmp	x0, x24
 111f6f8:	540006e3 	b.cc	111f7d4 <syscall_obj_generate_key+0x4bc>  // b.lo, b.ul, b.last
		res = crypto_rng_read((void *)(key + 1), byte_size);
 111f6fc:	aa1803e1 	mov	x1, x24
 111f700:	91002280 	add	x0, x20, #0x8
 111f704:	97ffbfaa 	bl	110f5ac <crypto_rng_read>
 111f708:	2a0003f3 	mov	w19, w0
		if (res != TEE_SUCCESS)
 111f70c:	35000100 	cbnz	w0, 111f72c <syscall_obj_generate_key+0x414>
		key->key_size = byte_size;
 111f710:	b9000298 	str	w24, [x20]
		o->have_attrs = (1 << type_props->num_type_attrs) - 1;
 111f714:	52800020 	mov	w0, #0x1                   	// #1
 111f718:	39402ea1 	ldrb	w1, [x21, #11]
 111f71c:	1ac12000 	lsl	w0, w0, w1
 111f720:	51000400 	sub	w0, w0, #0x1
 111f724:	f9402fe1 	ldr	x1, [sp, #88]
 111f728:	b9003020 	str	w0, [x1, #48]
	free_wipe(params);
 111f72c:	aa1703e0 	mov	x0, x23
 111f730:	94008fae 	bl	11435e8 <free_wipe>
	if (res == TEE_SUCCESS) {
 111f734:	35ffe4f3 	cbnz	w19, 111f3d0 <syscall_obj_generate_key+0xb8>
		o->info.keySize = key_size;
 111f738:	f9402fe0 	ldr	x0, [sp, #88]
		o->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;
 111f73c:	b9402801 	ldr	w1, [x0, #40]
		o->info.keySize = key_size;
 111f740:	b9001416 	str	w22, [x0, #20]
		o->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;
 111f744:	320f0021 	orr	w1, w1, #0x20000
 111f748:	b9002801 	str	w1, [x0, #40]
 111f74c:	17ffff21 	b	111f3d0 <syscall_obj_generate_key+0xb8>
			byte_size = (key_size + key_size / 7) / 8;
 111f750:	d28000f8 	mov	x24, #0x7                   	// #7
 111f754:	9ad80ad8 	udiv	x24, x22, x24
 111f758:	8b160318 	add	x24, x24, x22
 111f75c:	d343ff18 	lsr	x24, x24, #3
 111f760:	17ffffe3 	b	111f6ec <syscall_obj_generate_key+0x3d4>
		crypto_bignum_bin2bn((const uint8_t *)&e, sizeof(e), key->e);
 111f764:	aa1903e2 	mov	x2, x25
 111f768:	910153e0 	add	x0, sp, #0x54
 111f76c:	d2800081 	mov	x1, #0x4                   	// #4
 111f770:	94003a93 	bl	112e1bc <crypto_bignum_bin2bn>
	res = crypto_acipher_gen_rsa_key(key, key_size);
 111f774:	2a1603e1 	mov	w1, w22
 111f778:	aa1803e0 	mov	x0, x24
 111f77c:	94002d5e 	bl	112acf4 <crypto_acipher_gen_rsa_key>
	res = crypto_acipher_gen_dsa_key(o->attr, key_size);
 111f780:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 111f784:	35fffd40 	cbnz	w0, 111f72c <syscall_obj_generate_key+0x414>
	o->have_attrs = (1 << type_props->num_type_attrs) - 1;
 111f788:	39402ea1 	ldrb	w1, [x21, #11]
 111f78c:	52800020 	mov	w0, #0x1                   	// #1
 111f790:	1ac12000 	lsl	w0, w0, w1
 111f794:	51000400 	sub	w0, w0, #0x1
 111f798:	b9003280 	str	w0, [x20, #48]
	return TEE_SUCCESS;
 111f79c:	17ffffe4 	b	111f72c <syscall_obj_generate_key+0x414>
	res = tee_svc_cryp_obj_populate_type(o, type_props, params,
 111f7a0:	2a1903e3 	mov	w3, w25
 111f7a4:	aa1703e2 	mov	x2, x23
 111f7a8:	aa1503e1 	mov	x1, x21
 111f7ac:	aa1403e0 	mov	x0, x20
 111f7b0:	97fff7c7 	bl	111d6cc <tee_svc_cryp_obj_populate_type>
 111f7b4:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 111f7b8:	35fffba0 	cbnz	w0, 111f72c <syscall_obj_generate_key+0x414>
	res = crypto_acipher_gen_dsa_key(o->attr, key_size);
 111f7bc:	f9401e80 	ldr	x0, [x20, #56]
 111f7c0:	2a1603e1 	mov	w1, w22
 111f7c4:	94002882 	bl	11299cc <crypto_acipher_gen_dsa_key>
 111f7c8:	17ffffee 	b	111f780 <syscall_obj_generate_key+0x468>
	struct bignum *dh_q = NULL;
 111f7cc:	d2800008 	mov	x8, #0x0                   	// #0
 111f7d0:	17ffff7d 	b	111f5c4 <syscall_obj_generate_key+0x2ac>
			res = TEE_ERROR_EXCESS_DATA;
 111f7d4:	129fff73 	mov	w19, #0xffff0004            	// #-65532
 111f7d8:	17ffffd5 	b	111f72c <syscall_obj_generate_key+0x414>
		return TEE_ERROR_BAD_STATE;
 111f7dc:	129fff13 	mov	w19, #0xffff0007            	// #-65529
 111f7e0:	17fffefc 	b	111f3d0 <syscall_obj_generate_key+0xb8>
		return TEE_ERROR_NOT_SUPPORTED;
 111f7e4:	129ffeb3 	mov	w19, #0xffff000a            	// #-65526
 111f7e8:	17fffefa 	b	111f3d0 <syscall_obj_generate_key+0xb8>

000000000111f7ec <syscall_cryp_state_alloc>:
{
 111f7ec:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
 111f7f0:	910003fd 	mov	x29, sp
 111f7f4:	a90153f3 	stp	x19, x20, [sp, #16]
 111f7f8:	a9025bf5 	stp	x21, x22, [sp, #32]
 111f7fc:	aa0303f6 	mov	x22, x3
 111f800:	aa0403f5 	mov	x21, x4
 111f804:	a90363f7 	stp	x23, x24, [sp, #48]
 111f808:	aa0203f8 	mov	x24, x2
 111f80c:	aa0003f7 	mov	x23, x0
 111f810:	a9046bf9 	stp	x25, x26, [sp, #64]
 111f814:	aa0103f9 	mov	x25, x1
	struct ts_session *sess = ts_get_current_session();
 111f818:	97ffd472 	bl	11149e0 <ts_get_current_session>
	struct user_ta_ctx *utc = to_user_ta_ctx(sess->ctx);
 111f81c:	f9400800 	ldr	x0, [x0, #16]
 111f820:	97fffa75 	bl	111e1f4 <to_user_ta_ctx>
	struct tee_obj *o2 = NULL;
 111f824:	a9057fff 	stp	xzr, xzr, [sp, #80]
	struct user_ta_ctx *utc = to_user_ta_ctx(sess->ctx);
 111f828:	aa0003f4 	mov	x20, x0
	if (key1 != 0) {
 111f82c:	b5000138 	cbnz	x24, 111f850 <syscall_cryp_state_alloc+0x64>
	if (key2 != 0) {
 111f830:	b5000456 	cbnz	x22, 111f8b8 <syscall_cryp_state_alloc+0xcc>
	cs = calloc(1, sizeof(struct tee_cryp_state));
 111f834:	d2800801 	mov	x1, #0x40                  	// #64
 111f838:	d2800020 	mov	x0, #0x1                   	// #1
 111f83c:	94008f25 	bl	11434d0 <calloc>
 111f840:	aa0003fa 	mov	x26, x0
	if (!cs)
 111f844:	b50005e0 	cbnz	x0, 111f900 <syscall_cryp_state_alloc+0x114>
		return TEE_ERROR_OUT_OF_MEMORY;
 111f848:	129ffe73 	mov	w19, #0xffff000c            	// #-65524
 111f84c:	1400000d 	b	111f880 <syscall_cryp_state_alloc+0x94>
		res = tee_obj_get(utc, uref_to_vaddr(key1), &o1);
 111f850:	2a1803e0 	mov	w0, w24
 111f854:	97ffd619 	bl	11150b8 <uref_to_vaddr>
 111f858:	910143e2 	add	x2, sp, #0x50
 111f85c:	aa0003e1 	mov	x1, x0
 111f860:	aa1403e0 	mov	x0, x20
 111f864:	940019c6 	bl	1125f7c <tee_obj_get>
 111f868:	2a0003f3 	mov	w19, w0
		if (res != TEE_SUCCESS)
 111f86c:	350000a0 	cbnz	w0, 111f880 <syscall_cryp_state_alloc+0x94>
		if (o1->busy)
 111f870:	f9402be0 	ldr	x0, [sp, #80]
 111f874:	3940b001 	ldrb	w1, [x0, #44]
 111f878:	34000121 	cbz	w1, 111f89c <syscall_cryp_state_alloc+0xb0>
			return TEE_ERROR_BAD_PARAMETERS;
 111f87c:	129fff33 	mov	w19, #0xffff0006            	// #-65530
}
 111f880:	2a1303e0 	mov	w0, w19
 111f884:	a94153f3 	ldp	x19, x20, [sp, #16]
 111f888:	a9425bf5 	ldp	x21, x22, [sp, #32]
 111f88c:	a94363f7 	ldp	x23, x24, [sp, #48]
 111f890:	a9446bf9 	ldp	x25, x26, [sp, #64]
 111f894:	a8c67bfd 	ldp	x29, x30, [sp], #96
 111f898:	d65f03c0 	ret
		res = tee_svc_cryp_check_key_type(o1, algo, mode);
 111f89c:	2a1903e2 	mov	w2, w25
 111f8a0:	2a1703e1 	mov	w1, w23
 111f8a4:	91004000 	add	x0, x0, #0x10
 111f8a8:	97fff9cf 	bl	111dfe4 <tee_svc_cryp_check_key_type.isra.0>
 111f8ac:	2a0003f3 	mov	w19, w0
		if (res != TEE_SUCCESS)
 111f8b0:	34fffc00 	cbz	w0, 111f830 <syscall_cryp_state_alloc+0x44>
 111f8b4:	17fffff3 	b	111f880 <syscall_cryp_state_alloc+0x94>
		res = tee_obj_get(utc, uref_to_vaddr(key2), &o2);
 111f8b8:	2a1603e0 	mov	w0, w22
 111f8bc:	97ffd5ff 	bl	11150b8 <uref_to_vaddr>
 111f8c0:	910163e2 	add	x2, sp, #0x58
 111f8c4:	aa0003e1 	mov	x1, x0
 111f8c8:	aa1403e0 	mov	x0, x20
 111f8cc:	940019ac 	bl	1125f7c <tee_obj_get>
 111f8d0:	2a0003f3 	mov	w19, w0
		if (res != TEE_SUCCESS)
 111f8d4:	35fffd60 	cbnz	w0, 111f880 <syscall_cryp_state_alloc+0x94>
		if (o2->busy)
 111f8d8:	f9402fe0 	ldr	x0, [sp, #88]
 111f8dc:	3940b001 	ldrb	w1, [x0, #44]
 111f8e0:	35fffce1 	cbnz	w1, 111f87c <syscall_cryp_state_alloc+0x90>
		res = tee_svc_cryp_check_key_type(o2, algo, mode);
 111f8e4:	2a1903e2 	mov	w2, w25
 111f8e8:	2a1703e1 	mov	w1, w23
 111f8ec:	91004000 	add	x0, x0, #0x10
 111f8f0:	97fff9bd 	bl	111dfe4 <tee_svc_cryp_check_key_type.isra.0>
 111f8f4:	2a0003f3 	mov	w19, w0
		if (res != TEE_SUCCESS)
 111f8f8:	34fff9e0 	cbz	w0, 111f834 <syscall_cryp_state_alloc+0x48>
 111f8fc:	17ffffe1 	b	111f880 <syscall_cryp_state_alloc+0x94>
	TAILQ_INSERT_TAIL(&utc->cryp_states, cs, link);
 111f900:	f9400e80 	ldr	x0, [x20, #24]
 111f904:	a900035f 	stp	xzr, x0, [x26]
 111f908:	f900001a 	str	x26, [x0]
	cs->state = CRYP_STATE_UNINITIALIZED;
 111f90c:	52800020 	mov	w0, #0x1                   	// #1
	TAILQ_INSERT_TAIL(&utc->cryp_states, cs, link);
 111f910:	f9000e9a 	str	x26, [x20, #24]
	cs->mode = mode;
 111f914:	29026757 	stp	w23, w25, [x26, #16]
	cs->state = CRYP_STATE_UNINITIALIZED;
 111f918:	b9003b40 	str	w0, [x26, #56]
	switch (TEE_ALG_GET_CLASS(algo)) {
 111f91c:	2a1703e0 	mov	w0, w23
 111f920:	97fff6a5 	bl	111d3b4 <__tee_alg_get_class>
 111f924:	51000400 	sub	w0, w0, #0x1
 111f928:	71001c1f 	cmp	w0, #0x7
 111f92c:	54000a28 	b.hi	111fa70 <syscall_cryp_state_alloc+0x284>  // b.pmore
 111f930:	f0000161 	adrp	x1, 114e000 <ldelf_data+0x8000>
 111f934:	911d2021 	add	x1, x1, #0x748
 111f938:	38604820 	ldrb	w0, [x1, w0, uxtw]
 111f93c:	10000061 	adr	x1, 111f948 <syscall_cryp_state_alloc+0x15c>
 111f940:	8b208820 	add	x0, x1, w0, sxtb #2
 111f944:	d61f0000 	br	x0
		if ((algo == TEE_ALG_AES_XTS && (key1 == 0 || key2 == 0)) ||
 111f948:	f100031f 	cmp	x24, #0x0
 111f94c:	d2808201 	mov	x1, #0x410                 	// #1040
 111f950:	1a9f17e0 	cset	w0, eq  // eq = none
 111f954:	f2a20001 	movk	x1, #0x1000, lsl #16
 111f958:	eb0102ff 	cmp	x23, x1
 111f95c:	54000241 	b.ne	111f9a4 <syscall_cryp_state_alloc+0x1b8>  // b.any
 111f960:	f10002df 	cmp	x22, #0x0
 111f964:	7a401800 	ccmp	w0, #0x0, #0x0, ne  // ne = any
		    (algo != TEE_ALG_AES_XTS && (key1 == 0 || key2 != 0))) {
 111f968:	54000521 	b.ne	111fa0c <syscall_cryp_state_alloc+0x220>  // b.any
			res = crypto_cipher_alloc_ctx(&cs->ctx, algo);
 111f96c:	2a1703e1 	mov	w1, w23
 111f970:	9100a340 	add	x0, x26, #0x28
 111f974:	97ffb68e 	bl	110d3ac <crypto_cipher_alloc_ctx>
			res = crypto_hash_alloc_ctx(&cs->ctx, algo);
 111f978:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 111f97c:	350000c0 	cbnz	w0, 111f994 <syscall_cryp_state_alloc+0x1a8>
	res = copy_kaddr_to_uref(state, cs);
 111f980:	aa1a03e1 	mov	x1, x26
 111f984:	aa1503e0 	mov	x0, x21
 111f988:	97ffd5be 	bl	1115080 <copy_kaddr_to_uref>
 111f98c:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 111f990:	340005a0 	cbz	w0, 111fa44 <syscall_cryp_state_alloc+0x258>
		cryp_state_free(utc, cs);
 111f994:	aa1a03e1 	mov	x1, x26
 111f998:	aa1403e0 	mov	x0, x20
 111f99c:	97fff942 	bl	111dea4 <cryp_state_free>
 111f9a0:	17ffffb8 	b	111f880 <syscall_cryp_state_alloc+0x94>
		    (algo != TEE_ALG_AES_XTS && (key1 == 0 || key2 != 0))) {
 111f9a4:	f10002df 	cmp	x22, #0x0
 111f9a8:	7a400800 	ccmp	w0, #0x0, #0x0, eq  // eq = none
 111f9ac:	17ffffef 	b	111f968 <syscall_cryp_state_alloc+0x17c>
		if (key1 == 0 || key2 != 0) {
 111f9b0:	f100031f 	cmp	x24, #0x0
 111f9b4:	fa401ac0 	ccmp	x22, #0x0, #0x0, ne  // ne = any
 111f9b8:	540002a1 	b.ne	111fa0c <syscall_cryp_state_alloc+0x220>  // b.any
			res = crypto_authenc_alloc_ctx(&cs->ctx, algo);
 111f9bc:	2a1703e1 	mov	w1, w23
 111f9c0:	9100a340 	add	x0, x26, #0x28
 111f9c4:	97ffb80e 	bl	110d9fc <crypto_authenc_alloc_ctx>
 111f9c8:	17ffffec 	b	111f978 <syscall_cryp_state_alloc+0x18c>
		if (key1 == 0 || key2 != 0) {
 111f9cc:	f100031f 	cmp	x24, #0x0
 111f9d0:	fa401ac0 	ccmp	x22, #0x0, #0x0, ne  // ne = any
 111f9d4:	540001c1 	b.ne	111fa0c <syscall_cryp_state_alloc+0x220>  // b.any
			res = crypto_mac_alloc_ctx(&cs->ctx, algo);
 111f9d8:	2a1703e1 	mov	w1, w23
 111f9dc:	9100a340 	add	x0, x26, #0x28
 111f9e0:	97ffb759 	bl	110d744 <crypto_mac_alloc_ctx>
 111f9e4:	17ffffe5 	b	111f978 <syscall_cryp_state_alloc+0x18c>
		if (key1 != 0 || key2 != 0) {
 111f9e8:	aa160316 	orr	x22, x24, x22
 111f9ec:	b5000116 	cbnz	x22, 111fa0c <syscall_cryp_state_alloc+0x220>
			res = crypto_hash_alloc_ctx(&cs->ctx, algo);
 111f9f0:	2a1703e1 	mov	w1, w23
 111f9f4:	9100a340 	add	x0, x26, #0x28
 111f9f8:	97ffb601 	bl	110d1fc <crypto_hash_alloc_ctx>
 111f9fc:	17ffffdf 	b	111f978 <syscall_cryp_state_alloc+0x18c>
		if (key1 == 0 || key2 != 0)
 111fa00:	f100031f 	cmp	x24, #0x0
 111fa04:	fa401ac0 	ccmp	x22, #0x0, #0x0, ne  // ne = any
 111fa08:	54fffbc0 	b.eq	111f980 <syscall_cryp_state_alloc+0x194>  // b.none
			res = TEE_ERROR_BAD_PARAMETERS;
 111fa0c:	129fff33 	mov	w19, #0xffff0006            	// #-65530
 111fa10:	17ffffe1 	b	111f994 <syscall_cryp_state_alloc+0x1a8>
		if (algo == TEE_ALG_SM2_KEP) {
 111fa14:	f100031f 	cmp	x24, #0x0
 111fa18:	d28008a1 	mov	x1, #0x45                  	// #69
 111fa1c:	1a9f17e0 	cset	w0, eq  // eq = none
 111fa20:	f2ac0001 	movk	x1, #0x6000, lsl #16
 111fa24:	eb0102ff 	cmp	x23, x1
 111fa28:	54000081 	b.ne	111fa38 <syscall_cryp_state_alloc+0x24c>  // b.any
			if (key1 == 0 || key2 == 0)
 111fa2c:	f10002df 	cmp	x22, #0x0
 111fa30:	7a401800 	ccmp	w0, #0x0, #0x0, ne  // ne = any
 111fa34:	17fffff5 	b	111fa08 <syscall_cryp_state_alloc+0x21c>
			if (key1 == 0 || key2 != 0)
 111fa38:	f10002df 	cmp	x22, #0x0
 111fa3c:	7a400800 	ccmp	w0, #0x0, #0x0, eq  // eq = none
 111fa40:	17fffff2 	b	111fa08 <syscall_cryp_state_alloc+0x21c>
	if (o1 != NULL) {
 111fa44:	f9402be0 	ldr	x0, [sp, #80]
 111fa48:	b4000080 	cbz	x0, 111fa58 <syscall_cryp_state_alloc+0x26c>
		o1->busy = true;
 111fa4c:	52800021 	mov	w1, #0x1                   	// #1
 111fa50:	3900b001 	strb	w1, [x0, #44]
		cs->key1 = (vaddr_t)o1;
 111fa54:	f9000f40 	str	x0, [x26, #24]
	if (o2 != NULL) {
 111fa58:	f9402fe0 	ldr	x0, [sp, #88]
 111fa5c:	b4fff120 	cbz	x0, 111f880 <syscall_cryp_state_alloc+0x94>
		o2->busy = true;
 111fa60:	52800021 	mov	w1, #0x1                   	// #1
 111fa64:	3900b001 	strb	w1, [x0, #44]
		cs->key2 = (vaddr_t)o2;
 111fa68:	f9001340 	str	x0, [x26, #32]
	if (res != TEE_SUCCESS)
 111fa6c:	17ffff85 	b	111f880 <syscall_cryp_state_alloc+0x94>
	switch (TEE_ALG_GET_CLASS(algo)) {
 111fa70:	129ffeb3 	mov	w19, #0xffff000a            	// #-65526
 111fa74:	17ffffc8 	b	111f994 <syscall_cryp_state_alloc+0x1a8>

000000000111fa78 <syscall_cryp_state_copy>:
{
 111fa78:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 111fa7c:	910003fd 	mov	x29, sp
 111fa80:	a90153f3 	stp	x19, x20, [sp, #16]
 111fa84:	aa0003f3 	mov	x19, x0
 111fa88:	f90013f5 	str	x21, [sp, #32]
 111fa8c:	aa0103f5 	mov	x21, x1
	struct ts_session *sess = ts_get_current_session();
 111fa90:	97ffd3d4 	bl	11149e0 <ts_get_current_session>
 111fa94:	aa0003f4 	mov	x20, x0
	res = tee_svc_cryp_get_state(sess, uref_to_vaddr(dst), &cs_dst);
 111fa98:	2a1303e0 	mov	w0, w19
	struct tee_cryp_state *cs_src = NULL;
 111fa9c:	a9037fff 	stp	xzr, xzr, [sp, #48]
	res = tee_svc_cryp_get_state(sess, uref_to_vaddr(dst), &cs_dst);
 111faa0:	97ffd586 	bl	11150b8 <uref_to_vaddr>
 111faa4:	aa0003e1 	mov	x1, x0
 111faa8:	9100c3e2 	add	x2, sp, #0x30
 111faac:	f9400a80 	ldr	x0, [x20, #16]
 111fab0:	97fffa18 	bl	111e310 <tee_svc_cryp_get_state.isra.0>
 111fab4:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 111fab8:	35000420 	cbnz	w0, 111fb3c <syscall_cryp_state_copy+0xc4>
	res = tee_svc_cryp_get_state(sess, uref_to_vaddr(src), &cs_src);
 111fabc:	2a1503e0 	mov	w0, w21
 111fac0:	97ffd57e 	bl	11150b8 <uref_to_vaddr>
 111fac4:	aa0003e1 	mov	x1, x0
 111fac8:	9100e3e2 	add	x2, sp, #0x38
 111facc:	f9400a80 	ldr	x0, [x20, #16]
 111fad0:	97fffa10 	bl	111e310 <tee_svc_cryp_get_state.isra.0>
 111fad4:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 111fad8:	35000320 	cbnz	w0, 111fb3c <syscall_cryp_state_copy+0xc4>
	if (cs_dst->algo != cs_src->algo || cs_dst->mode != cs_src->mode)
 111fadc:	a9430fe4 	ldp	x4, x3, [sp, #48]
 111fae0:	f9400860 	ldr	x0, [x3, #16]
 111fae4:	f9400881 	ldr	x1, [x4, #16]
 111fae8:	eb00003f 	cmp	x1, x0
 111faec:	540004a1 	b.ne	111fb80 <syscall_cryp_state_copy+0x108>  // b.any
	switch (TEE_ALG_GET_CLASS(cs_src->algo)) {
 111faf0:	b9401060 	ldr	w0, [x3, #16]
 111faf4:	97fff630 	bl	111d3b4 <__tee_alg_get_class>
 111faf8:	51000400 	sub	w0, w0, #0x1
 111fafc:	7100101f 	cmp	w0, #0x4
 111fb00:	54000448 	b.hi	111fb88 <syscall_cryp_state_copy+0x110>  // b.pmore
 111fb04:	f0000161 	adrp	x1, 114e000 <ldelf_data+0x8000>
 111fb08:	911d4021 	add	x1, x1, #0x750
 111fb0c:	38604820 	ldrb	w0, [x1, w0, uxtw]
 111fb10:	10000061 	adr	x1, 111fb1c <syscall_cryp_state_copy+0xa4>
 111fb14:	8b208820 	add	x0, x1, w0, sxtb #2
 111fb18:	d61f0000 	br	x0
		crypto_cipher_copy_state(cs_dst->ctx, cs_src->ctx);
 111fb1c:	f9401461 	ldr	x1, [x3, #40]
 111fb20:	f9401480 	ldr	x0, [x4, #40]
 111fb24:	97ffb68d 	bl	110d558 <crypto_cipher_copy_state>
	cs_dst->state = cs_src->state;
 111fb28:	a94307e0 	ldp	x0, x1, [sp, #48]
 111fb2c:	b9403822 	ldr	w2, [x1, #56]
	cs_dst->ctx_finalize = cs_src->ctx_finalize;
 111fb30:	f9401821 	ldr	x1, [x1, #48]
 111fb34:	f9001801 	str	x1, [x0, #48]
	cs_dst->state = cs_src->state;
 111fb38:	b9003802 	str	w2, [x0, #56]
}
 111fb3c:	2a1303e0 	mov	w0, w19
 111fb40:	a94153f3 	ldp	x19, x20, [sp, #16]
 111fb44:	f94013f5 	ldr	x21, [sp, #32]
 111fb48:	a8c47bfd 	ldp	x29, x30, [sp], #64
 111fb4c:	d65f03c0 	ret
		crypto_authenc_copy_state(cs_dst->ctx, cs_src->ctx);
 111fb50:	f9401461 	ldr	x1, [x3, #40]
 111fb54:	f9401480 	ldr	x0, [x4, #40]
 111fb58:	97ffb871 	bl	110dd1c <crypto_authenc_copy_state>
		break;
 111fb5c:	17fffff3 	b	111fb28 <syscall_cryp_state_copy+0xb0>
		crypto_hash_copy_state(cs_dst->ctx, cs_src->ctx);
 111fb60:	f9401461 	ldr	x1, [x3, #40]
 111fb64:	f9401480 	ldr	x0, [x4, #40]
 111fb68:	97ffb5d7 	bl	110d2c4 <crypto_hash_copy_state>
		break;
 111fb6c:	17ffffef 	b	111fb28 <syscall_cryp_state_copy+0xb0>
		crypto_mac_copy_state(cs_dst->ctx, cs_src->ctx);
 111fb70:	f9401461 	ldr	x1, [x3, #40]
 111fb74:	f9401480 	ldr	x0, [x4, #40]
 111fb78:	97ffb75e 	bl	110d8f0 <crypto_mac_copy_state>
		break;
 111fb7c:	17ffffeb 	b	111fb28 <syscall_cryp_state_copy+0xb0>
		return TEE_ERROR_BAD_PARAMETERS;
 111fb80:	129fff33 	mov	w19, #0xffff0006            	// #-65530
 111fb84:	17ffffee 	b	111fb3c <syscall_cryp_state_copy+0xc4>
	switch (TEE_ALG_GET_CLASS(cs_src->algo)) {
 111fb88:	129fff13 	mov	w19, #0xffff0007            	// #-65529
 111fb8c:	17ffffec 	b	111fb3c <syscall_cryp_state_copy+0xc4>

000000000111fb90 <tee_svc_cryp_free_states>:
{
 111fb90:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 111fb94:	910003fd 	mov	x29, sp
 111fb98:	f9000bf3 	str	x19, [sp, #16]
 111fb9c:	aa0003f3 	mov	x19, x0
	while (!TAILQ_EMPTY(states))
 111fba0:	f9400a61 	ldr	x1, [x19, #16]
 111fba4:	b5000081 	cbnz	x1, 111fbb4 <tee_svc_cryp_free_states+0x24>
}
 111fba8:	f9400bf3 	ldr	x19, [sp, #16]
 111fbac:	a8c27bfd 	ldp	x29, x30, [sp], #32
 111fbb0:	d65f03c0 	ret
		cryp_state_free(utc, TAILQ_FIRST(states));
 111fbb4:	aa1303e0 	mov	x0, x19
 111fbb8:	97fff8bb 	bl	111dea4 <cryp_state_free>
 111fbbc:	17fffff9 	b	111fba0 <tee_svc_cryp_free_states+0x10>

000000000111fbc0 <syscall_cryp_state_free>:
{
 111fbc0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 111fbc4:	910003fd 	mov	x29, sp
 111fbc8:	a90153f3 	stp	x19, x20, [sp, #16]
 111fbcc:	aa0003f3 	mov	x19, x0
	struct ts_session *sess = ts_get_current_session();
 111fbd0:	97ffd384 	bl	11149e0 <ts_get_current_session>
 111fbd4:	aa0003f4 	mov	x20, x0
	res = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);
 111fbd8:	2a1303e0 	mov	w0, w19
	struct tee_cryp_state *cs = NULL;
 111fbdc:	f90017ff 	str	xzr, [sp, #40]
	res = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);
 111fbe0:	97ffd536 	bl	11150b8 <uref_to_vaddr>
 111fbe4:	aa0003e1 	mov	x1, x0
 111fbe8:	9100a3e2 	add	x2, sp, #0x28
 111fbec:	f9400a80 	ldr	x0, [x20, #16]
 111fbf0:	97fff9c8 	bl	111e310 <tee_svc_cryp_get_state.isra.0>
 111fbf4:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 111fbf8:	350000a0 	cbnz	w0, 111fc0c <syscall_cryp_state_free+0x4c>
	cryp_state_free(to_user_ta_ctx(sess->ctx), cs);
 111fbfc:	f9400a80 	ldr	x0, [x20, #16]
 111fc00:	97fff97d 	bl	111e1f4 <to_user_ta_ctx>
 111fc04:	f94017e1 	ldr	x1, [sp, #40]
 111fc08:	97fff8a7 	bl	111dea4 <cryp_state_free>
}
 111fc0c:	2a1303e0 	mov	w0, w19
 111fc10:	a94153f3 	ldp	x19, x20, [sp, #16]
 111fc14:	a8c37bfd 	ldp	x29, x30, [sp], #48
 111fc18:	d65f03c0 	ret

000000000111fc1c <syscall_hash_init>:
{
 111fc1c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 111fc20:	910003fd 	mov	x29, sp
 111fc24:	a90153f3 	stp	x19, x20, [sp, #16]
 111fc28:	aa0003f3 	mov	x19, x0
	struct ts_session *sess = ts_get_current_session();
 111fc2c:	97ffd36d 	bl	11149e0 <ts_get_current_session>
 111fc30:	aa0003f4 	mov	x20, x0
	res = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);
 111fc34:	2a1303e0 	mov	w0, w19
	struct tee_cryp_state *cs = NULL;
 111fc38:	f90013ff 	str	xzr, [sp, #32]
	res = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);
 111fc3c:	97ffd51f 	bl	11150b8 <uref_to_vaddr>
 111fc40:	aa0003e1 	mov	x1, x0
 111fc44:	910083e2 	add	x2, sp, #0x20
 111fc48:	f9400a80 	ldr	x0, [x20, #16]
 111fc4c:	97fff9b1 	bl	111e310 <tee_svc_cryp_get_state.isra.0>
 111fc50:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 111fc54:	35000420 	cbnz	w0, 111fcd8 <syscall_hash_init+0xbc>
	switch (TEE_ALG_GET_CLASS(cs->algo)) {
 111fc58:	f94013e3 	ldr	x3, [sp, #32]
 111fc5c:	b9401060 	ldr	w0, [x3, #16]
 111fc60:	97fff5d5 	bl	111d3b4 <__tee_alg_get_class>
 111fc64:	71000c1f 	cmp	w0, #0x3
 111fc68:	54000100 	b.eq	111fc88 <syscall_hash_init+0x6c>  // b.none
 111fc6c:	7100141f 	cmp	w0, #0x5
 111fc70:	540003c1 	b.ne	111fce8 <syscall_hash_init+0xcc>  // b.any
		res = crypto_hash_init(cs->ctx);
 111fc74:	f9401460 	ldr	x0, [x3, #40]
 111fc78:	97ffb5a0 	bl	110d2f8 <crypto_hash_init>
			if (res != TEE_SUCCESS)
 111fc7c:	340002a0 	cbz	w0, 111fcd0 <syscall_hash_init+0xb4>
 111fc80:	2a0003f3 	mov	w19, w0
 111fc84:	14000015 	b	111fcd8 <syscall_hash_init+0xbc>
			res = tee_obj_get(to_user_ta_ctx(sess->ctx),
 111fc88:	f9400a80 	ldr	x0, [x20, #16]
 111fc8c:	97fff95a 	bl	111e1f4 <to_user_ta_ctx>
 111fc90:	f94013e1 	ldr	x1, [sp, #32]
 111fc94:	9100a3e2 	add	x2, sp, #0x28
 111fc98:	f9400c21 	ldr	x1, [x1, #24]
 111fc9c:	940018b8 	bl	1125f7c <tee_obj_get>
			if (res != TEE_SUCCESS)
 111fca0:	35ffff00 	cbnz	w0, 111fc80 <syscall_hash_init+0x64>
			if ((o->info.handleFlags &
 111fca4:	f94017e0 	ldr	x0, [sp, #40]
 111fca8:	b9402801 	ldr	w1, [x0, #40]
 111fcac:	368800e1 	tbz	w1, #17, 111fcc8 <syscall_hash_init+0xac>
			res = crypto_mac_init(cs->ctx, (void *)(key + 1),
 111fcb0:	f9401c01 	ldr	x1, [x0, #56]
 111fcb4:	f94013e0 	ldr	x0, [sp, #32]
 111fcb8:	b8408422 	ldr	w2, [x1], #8
 111fcbc:	f9401400 	ldr	x0, [x0, #40]
 111fcc0:	97ffb719 	bl	110d924 <crypto_mac_init>
 111fcc4:	17ffffee 	b	111fc7c <syscall_hash_init+0x60>
				return TEE_ERROR_BAD_PARAMETERS;
 111fcc8:	129fff20 	mov	w0, #0xffff0006            	// #-65530
 111fccc:	17ffffed 	b	111fc80 <syscall_hash_init+0x64>
	cs->state = CRYP_STATE_INITIALIZED;
 111fcd0:	f94013e0 	ldr	x0, [sp, #32]
 111fcd4:	b900381f 	str	wzr, [x0, #56]
}
 111fcd8:	2a1303e0 	mov	w0, w19
 111fcdc:	a94153f3 	ldp	x19, x20, [sp, #16]
 111fce0:	a8c37bfd 	ldp	x29, x30, [sp], #48
 111fce4:	d65f03c0 	ret
	switch (TEE_ALG_GET_CLASS(cs->algo)) {
 111fce8:	129fff33 	mov	w19, #0xffff0006            	// #-65530
 111fcec:	17fffffb 	b	111fcd8 <syscall_hash_init+0xbc>

000000000111fcf0 <syscall_hash_update>:
{
 111fcf0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 111fcf4:	910003fd 	mov	x29, sp
 111fcf8:	a90153f3 	stp	x19, x20, [sp, #16]
 111fcfc:	aa0103f4 	mov	x20, x1
 111fd00:	aa0203f3 	mov	x19, x2
 111fd04:	a9025bf5 	stp	x21, x22, [sp, #32]
 111fd08:	aa0003f6 	mov	x22, x0
	struct ts_session *sess = ts_get_current_session();
 111fd0c:	97ffd335 	bl	11149e0 <ts_get_current_session>
	struct tee_cryp_state *cs = NULL;
 111fd10:	f9001fff 	str	xzr, [sp, #56]
	if (!chunk && chunk_size)
 111fd14:	f100029f 	cmp	x20, #0x0
 111fd18:	fa400a64 	ccmp	x19, #0x0, #0x4, eq  // eq = none
 111fd1c:	54000581 	b.ne	111fdcc <syscall_hash_update+0xdc>  // b.any
	if (!chunk_size)
 111fd20:	b40004f3 	cbz	x19, 111fdbc <syscall_hash_update+0xcc>
 111fd24:	aa0003f5 	mov	x21, x0
	res = vm_check_access_rights(&to_user_ta_ctx(sess->ctx)->uctx,
 111fd28:	f9400800 	ldr	x0, [x0, #16]
 111fd2c:	97fff932 	bl	111e1f4 <to_user_ta_ctx>
 111fd30:	91014000 	add	x0, x0, #0x50
 111fd34:	aa1303e3 	mov	x3, x19
 111fd38:	aa1403e2 	mov	x2, x20
 111fd3c:	528000a1 	mov	w1, #0x5                   	// #5
 111fd40:	97ffe6ab 	bl	11197ec <vm_check_access_rights>
	if (res != TEE_SUCCESS)
 111fd44:	350002a0 	cbnz	w0, 111fd98 <syscall_hash_update+0xa8>
	res = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);
 111fd48:	2a1603e0 	mov	w0, w22
 111fd4c:	97ffd4db 	bl	11150b8 <uref_to_vaddr>
 111fd50:	aa0003e1 	mov	x1, x0
 111fd54:	9100e3e2 	add	x2, sp, #0x38
 111fd58:	f9400aa0 	ldr	x0, [x21, #16]
 111fd5c:	97fff96d 	bl	111e310 <tee_svc_cryp_get_state.isra.0>
	if (res != TEE_SUCCESS)
 111fd60:	350001c0 	cbnz	w0, 111fd98 <syscall_hash_update+0xa8>
	if (cs->state != CRYP_STATE_INITIALIZED)
 111fd64:	f9401fe3 	ldr	x3, [sp, #56]
 111fd68:	b9403860 	ldr	w0, [x3, #56]
 111fd6c:	350002c0 	cbnz	w0, 111fdc4 <syscall_hash_update+0xd4>
	switch (TEE_ALG_GET_CLASS(cs->algo)) {
 111fd70:	b9401060 	ldr	w0, [x3, #16]
 111fd74:	97fff590 	bl	111d3b4 <__tee_alg_get_class>
 111fd78:	71000c1f 	cmp	w0, #0x3
 111fd7c:	54000160 	b.eq	111fda8 <syscall_hash_update+0xb8>  // b.none
 111fd80:	7100141f 	cmp	w0, #0x5
 111fd84:	54000241 	b.ne	111fdcc <syscall_hash_update+0xdc>  // b.any
		res = crypto_hash_update(cs->ctx, chunk, chunk_size);
 111fd88:	f9401460 	ldr	x0, [x3, #40]
 111fd8c:	aa1303e2 	mov	x2, x19
 111fd90:	aa1403e1 	mov	x1, x20
 111fd94:	97ffb564 	bl	110d324 <crypto_hash_update>
}
 111fd98:	a94153f3 	ldp	x19, x20, [sp, #16]
 111fd9c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 111fda0:	a8c47bfd 	ldp	x29, x30, [sp], #64
 111fda4:	d65f03c0 	ret
		res = crypto_mac_update(cs->ctx, chunk, chunk_size);
 111fda8:	f9401460 	ldr	x0, [x3, #40]
 111fdac:	aa1303e2 	mov	x2, x19
 111fdb0:	aa1403e1 	mov	x1, x20
 111fdb4:	97ffb6ed 	bl	110d968 <crypto_mac_update>
		if (res != TEE_SUCCESS)
 111fdb8:	17fffff8 	b	111fd98 <syscall_hash_update+0xa8>
		return TEE_SUCCESS;
 111fdbc:	52800000 	mov	w0, #0x0                   	// #0
 111fdc0:	17fffff6 	b	111fd98 <syscall_hash_update+0xa8>
		return TEE_ERROR_BAD_STATE;
 111fdc4:	129fff00 	mov	w0, #0xffff0007            	// #-65529
 111fdc8:	17fffff4 	b	111fd98 <syscall_hash_update+0xa8>
	switch (TEE_ALG_GET_CLASS(cs->algo)) {
 111fdcc:	129fff20 	mov	w0, #0xffff0006            	// #-65530
 111fdd0:	17fffff2 	b	111fd98 <syscall_hash_update+0xa8>

000000000111fdd4 <syscall_hash_final>:
{
 111fdd4:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
 111fdd8:	910003fd 	mov	x29, sp
 111fddc:	a90153f3 	stp	x19, x20, [sp, #16]
 111fde0:	aa0403f4 	mov	x20, x4
 111fde4:	a9025bf5 	stp	x21, x22, [sp, #32]
 111fde8:	aa0203f6 	mov	x22, x2
 111fdec:	aa0303f5 	mov	x21, x3
 111fdf0:	a90363f7 	stp	x23, x24, [sp, #48]
 111fdf4:	aa0103f7 	mov	x23, x1
 111fdf8:	f90023f9 	str	x25, [sp, #64]
 111fdfc:	aa0003f9 	mov	x25, x0
	struct ts_session *sess = ts_get_current_session();
 111fe00:	97ffd2f8 	bl	11149e0 <ts_get_current_session>
	size_t hash_size = 0;
 111fe04:	a905ffff 	stp	xzr, xzr, [sp, #88]
	if (!chunk && chunk_size)
 111fe08:	f10002ff 	cmp	x23, #0x0
	size_t hlen = 0;
 111fe0c:	f90037ff 	str	xzr, [sp, #104]
	if (!chunk && chunk_size)
 111fe10:	fa400ac4 	ccmp	x22, #0x0, #0x4, eq  // eq = none
 111fe14:	54000d21 	b.ne	111ffb8 <syscall_hash_final+0x1e4>  // b.any
 111fe18:	aa0003f8 	mov	x24, x0
	res = vm_check_access_rights(&to_user_ta_ctx(sess->ctx)->uctx,
 111fe1c:	f9400800 	ldr	x0, [x0, #16]
 111fe20:	97fff8f5 	bl	111e1f4 <to_user_ta_ctx>
 111fe24:	91014000 	add	x0, x0, #0x50
 111fe28:	aa1603e3 	mov	x3, x22
 111fe2c:	aa1703e2 	mov	x2, x23
 111fe30:	528000a1 	mov	w1, #0x5                   	// #5
 111fe34:	97ffe66e 	bl	11197ec <vm_check_access_rights>
 111fe38:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 111fe3c:	35000800 	cbnz	w0, 111ff3c <syscall_hash_final+0x168>
	res = get_user_u64_as_size_t(&hlen, hash_len);
 111fe40:	aa1403e1 	mov	x1, x20
 111fe44:	9101a3e0 	add	x0, sp, #0x68
 111fe48:	97fff734 	bl	111db18 <get_user_u64_as_size_t>
 111fe4c:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 111fe50:	35000760 	cbnz	w0, 111ff3c <syscall_hash_final+0x168>
	res = vm_check_access_rights(&to_user_ta_ctx(sess->ctx)->uctx,
 111fe54:	f9400b00 	ldr	x0, [x24, #16]
 111fe58:	97fff8e7 	bl	111e1f4 <to_user_ta_ctx>
 111fe5c:	91014000 	add	x0, x0, #0x50
 111fe60:	f94037e3 	ldr	x3, [sp, #104]
 111fe64:	aa1503e2 	mov	x2, x21
 111fe68:	528000e1 	mov	w1, #0x7                   	// #7
 111fe6c:	97ffe660 	bl	11197ec <vm_check_access_rights>
 111fe70:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 111fe74:	35000640 	cbnz	w0, 111ff3c <syscall_hash_final+0x168>
	res = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);
 111fe78:	2a1903e0 	mov	w0, w25
 111fe7c:	97ffd48f 	bl	11150b8 <uref_to_vaddr>
 111fe80:	aa0003e1 	mov	x1, x0
 111fe84:	910163e2 	add	x2, sp, #0x58
 111fe88:	f9400b00 	ldr	x0, [x24, #16]
 111fe8c:	97fff921 	bl	111e310 <tee_svc_cryp_get_state.isra.0>
 111fe90:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 111fe94:	35000540 	cbnz	w0, 111ff3c <syscall_hash_final+0x168>
	if (cs->state != CRYP_STATE_INITIALIZED)
 111fe98:	f9402fe0 	ldr	x0, [sp, #88]
 111fe9c:	b9403801 	ldr	w1, [x0, #56]
 111fea0:	35000881 	cbnz	w1, 111ffb0 <syscall_hash_final+0x1dc>
	switch (TEE_ALG_GET_CLASS(cs->algo)) {
 111fea4:	b9401003 	ldr	w3, [x0, #16]
 111fea8:	2a0303e0 	mov	w0, w3
 111feac:	97fff542 	bl	111d3b4 <__tee_alg_get_class>
 111feb0:	71000c1f 	cmp	w0, #0x3
 111feb4:	54000520 	b.eq	111ff58 <syscall_hash_final+0x184>  // b.none
 111feb8:	7100141f 	cmp	w0, #0x5
 111febc:	540007e1 	b.ne	111ffb8 <syscall_hash_final+0x1e4>  // b.any
		res = tee_alg_get_digest_size(cs->algo, &hash_size);
 111fec0:	910183e1 	add	x1, sp, #0x60
 111fec4:	2a0303e0 	mov	w0, w3
 111fec8:	97ffee1c 	bl	111b738 <tee_alg_get_digest_size>
 111fecc:	2a0003f3 	mov	w19, w0
		if (res != TEE_SUCCESS)
 111fed0:	35000360 	cbnz	w0, 111ff3c <syscall_hash_final+0x168>
		if (hlen < hash_size) {
 111fed4:	a94607e0 	ldp	x0, x1, [sp, #96]
 111fed8:	eb00003f 	cmp	x1, x0
 111fedc:	54000102 	b.cs	111fefc <syscall_hash_final+0x128>  // b.hs, b.nlast
			res = TEE_ERROR_SHORT_BUFFER;
 111fee0:	129ffdf3 	mov	w19, #0xffff0010            	// #-65520
	res2 = put_user_u64(hash_len, hash_size);
 111fee4:	f94033e1 	ldr	x1, [sp, #96]
 111fee8:	aa1403e0 	mov	x0, x20
 111feec:	97fff752 	bl	111dc34 <put_user_u64>
	if (res2 != TEE_SUCCESS)
 111fef0:	7100001f 	cmp	w0, #0x0
 111fef4:	1a800273 	csel	w19, w19, w0, eq  // eq = none
 111fef8:	14000011 	b	111ff3c <syscall_hash_final+0x168>
		if (chunk_size) {
 111fefc:	b5000136 	cbnz	x22, 111ff20 <syscall_hash_final+0x14c>
		res = crypto_hash_final(cs->ctx, hash, hash_size);
 111ff00:	a9458be0 	ldp	x0, x2, [sp, #88]
 111ff04:	aa1503e1 	mov	x1, x21
 111ff08:	f9401400 	ldr	x0, [x0, #40]
 111ff0c:	97ffb517 	bl	110d368 <crypto_hash_final>
		res = crypto_mac_final(cs->ctx, hash, hash_size);
 111ff10:	2a0003f3 	mov	w19, w0
		if (res != TEE_SUCCESS)
 111ff14:	35000140 	cbnz	w0, 111ff3c <syscall_hash_final+0x168>
{
 111ff18:	52800013 	mov	w19, #0x0                   	// #0
 111ff1c:	17fffff2 	b	111fee4 <syscall_hash_final+0x110>
			res = crypto_hash_update(cs->ctx, chunk, chunk_size);
 111ff20:	f9402fe0 	ldr	x0, [sp, #88]
 111ff24:	aa1603e2 	mov	x2, x22
 111ff28:	aa1703e1 	mov	x1, x23
 111ff2c:	f9401400 	ldr	x0, [x0, #40]
 111ff30:	97ffb4fd 	bl	110d324 <crypto_hash_update>
 111ff34:	2a0003f3 	mov	w19, w0
			if (res != TEE_SUCCESS)
 111ff38:	34fffe40 	cbz	w0, 111ff00 <syscall_hash_final+0x12c>
}
 111ff3c:	2a1303e0 	mov	w0, w19
 111ff40:	a94153f3 	ldp	x19, x20, [sp, #16]
 111ff44:	a9425bf5 	ldp	x21, x22, [sp, #32]
 111ff48:	a94363f7 	ldp	x23, x24, [sp, #48]
 111ff4c:	f94023f9 	ldr	x25, [sp, #64]
 111ff50:	a8c77bfd 	ldp	x29, x30, [sp], #112
 111ff54:	d65f03c0 	ret
		res = tee_alg_get_digest_size(cs->algo, &hash_size);
 111ff58:	910183e1 	add	x1, sp, #0x60
 111ff5c:	2a0303e0 	mov	w0, w3
 111ff60:	97ffedf6 	bl	111b738 <tee_alg_get_digest_size>
 111ff64:	2a0003f3 	mov	w19, w0
		if (res != TEE_SUCCESS)
 111ff68:	35fffea0 	cbnz	w0, 111ff3c <syscall_hash_final+0x168>
		if (hlen < hash_size) {
 111ff6c:	a94607e0 	ldp	x0, x1, [sp, #96]
 111ff70:	eb00003f 	cmp	x1, x0
 111ff74:	54fffb63 	b.cc	111fee0 <syscall_hash_final+0x10c>  // b.lo, b.ul, b.last
		if (chunk_size) {
 111ff78:	b50000d6 	cbnz	x22, 111ff90 <syscall_hash_final+0x1bc>
		res = crypto_mac_final(cs->ctx, hash, hash_size);
 111ff7c:	a9458be0 	ldp	x0, x2, [sp, #88]
 111ff80:	aa1503e1 	mov	x1, x21
 111ff84:	f9401400 	ldr	x0, [x0, #40]
 111ff88:	97ffb68c 	bl	110d9b8 <crypto_mac_final>
 111ff8c:	17ffffe1 	b	111ff10 <syscall_hash_final+0x13c>
			res = crypto_mac_update(cs->ctx, chunk, chunk_size);
 111ff90:	f9402fe0 	ldr	x0, [sp, #88]
 111ff94:	aa1603e2 	mov	x2, x22
 111ff98:	aa1703e1 	mov	x1, x23
 111ff9c:	f9401400 	ldr	x0, [x0, #40]
 111ffa0:	97ffb672 	bl	110d968 <crypto_mac_update>
 111ffa4:	2a0003f3 	mov	w19, w0
			if (res != TEE_SUCCESS)
 111ffa8:	34fffea0 	cbz	w0, 111ff7c <syscall_hash_final+0x1a8>
 111ffac:	17ffffe4 	b	111ff3c <syscall_hash_final+0x168>
		return TEE_ERROR_BAD_STATE;
 111ffb0:	129fff13 	mov	w19, #0xffff0007            	// #-65529
 111ffb4:	17ffffe2 	b	111ff3c <syscall_hash_final+0x168>
	switch (TEE_ALG_GET_CLASS(cs->algo)) {
 111ffb8:	129fff33 	mov	w19, #0xffff0006            	// #-65530
 111ffbc:	17ffffe0 	b	111ff3c <syscall_hash_final+0x168>

000000000111ffc0 <syscall_cipher_init>:
{
 111ffc0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 111ffc4:	910003fd 	mov	x29, sp
 111ffc8:	a90153f3 	stp	x19, x20, [sp, #16]
 111ffcc:	aa0103f4 	mov	x20, x1
 111ffd0:	a9025bf5 	stp	x21, x22, [sp, #32]
 111ffd4:	aa0203f5 	mov	x21, x2
 111ffd8:	f9001bf7 	str	x23, [sp, #48]
 111ffdc:	aa0003f7 	mov	x23, x0
	struct ts_session *sess = ts_get_current_session();
 111ffe0:	97ffd280 	bl	11149e0 <ts_get_current_session>
 111ffe4:	aa0003f3 	mov	x19, x0
	struct user_ta_ctx *utc = to_user_ta_ctx(sess->ctx);
 111ffe8:	f9400800 	ldr	x0, [x0, #16]
 111ffec:	97fff882 	bl	111e1f4 <to_user_ta_ctx>
 111fff0:	aa0003f6 	mov	x22, x0
	res = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);
 111fff4:	2a1703e0 	mov	w0, w23
	struct tee_obj *o = NULL;
 111fff8:	a9047fff 	stp	xzr, xzr, [sp, #64]
	res = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);
 111fffc:	97ffd42f 	bl	11150b8 <uref_to_vaddr>
 1120000:	aa0003e1 	mov	x1, x0
 1120004:	910103e2 	add	x2, sp, #0x40
 1120008:	f9400a60 	ldr	x0, [x19, #16]
 112000c:	97fff8c1 	bl	111e310 <tee_svc_cryp_get_state.isra.0>
	if (res != TEE_SUCCESS)
 1120010:	350002e0 	cbnz	w0, 112006c <syscall_cipher_init+0xac>
	if (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_CIPHER)
 1120014:	f94023e0 	ldr	x0, [sp, #64]
 1120018:	b9401000 	ldr	w0, [x0, #16]
 112001c:	97fff4e6 	bl	111d3b4 <__tee_alg_get_class>
 1120020:	7100041f 	cmp	w0, #0x1
 1120024:	54000721 	b.ne	1120108 <syscall_cipher_init+0x148>  // b.any
	res = vm_check_access_rights(&utc->uctx,
 1120028:	aa1503e3 	mov	x3, x21
 112002c:	aa1403e2 	mov	x2, x20
 1120030:	910142c0 	add	x0, x22, #0x50
 1120034:	528000a1 	mov	w1, #0x5                   	// #5
 1120038:	97ffe5ed 	bl	11197ec <vm_check_access_rights>
	if (res != TEE_SUCCESS)
 112003c:	35000180 	cbnz	w0, 112006c <syscall_cipher_init+0xac>
	res = tee_obj_get(utc, cs->key1, &o);
 1120040:	f94023e0 	ldr	x0, [sp, #64]
 1120044:	910123f7 	add	x23, sp, #0x48
 1120048:	aa1703e2 	mov	x2, x23
 112004c:	f9400c01 	ldr	x1, [x0, #24]
 1120050:	aa1603e0 	mov	x0, x22
 1120054:	940017ca 	bl	1125f7c <tee_obj_get>
	if (res != TEE_SUCCESS)
 1120058:	350000a0 	cbnz	w0, 112006c <syscall_cipher_init+0xac>
	if ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)
 112005c:	f94027e0 	ldr	x0, [sp, #72]
 1120060:	b9402801 	ldr	w1, [x0, #40]
 1120064:	378800e1 	tbnz	w1, #17, 1120080 <syscall_cipher_init+0xc0>
		return TEE_ERROR_BAD_PARAMETERS;
 1120068:	129fff20 	mov	w0, #0xffff0006            	// #-65530
}
 112006c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1120070:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1120074:	f9401bf7 	ldr	x23, [sp, #48]
 1120078:	a8c57bfd 	ldp	x29, x30, [sp], #80
 112007c:	d65f03c0 	ret
	key1 = o->attr;
 1120080:	f9401c13 	ldr	x19, [x0, #56]
	if (tee_obj_get(utc, cs->key2, &o) == TEE_SUCCESS) {
 1120084:	aa1703e2 	mov	x2, x23
 1120088:	f94023e0 	ldr	x0, [sp, #64]
 112008c:	f9401001 	ldr	x1, [x0, #32]
 1120090:	aa1603e0 	mov	x0, x22
 1120094:	940017ba 	bl	1125f7c <tee_obj_get>
 1120098:	350002a0 	cbnz	w0, 11200ec <syscall_cipher_init+0x12c>
		struct tee_cryp_obj_secret *key2 = o->attr;
 112009c:	f94027e1 	ldr	x1, [sp, #72]
		if ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)
 11200a0:	b9402820 	ldr	w0, [x1, #40]
 11200a4:	368ffe20 	tbz	w0, #17, 1120068 <syscall_cipher_init+0xa8>
		res = crypto_cipher_init(cs->ctx, cs->mode,
 11200a8:	f9401c24 	ldr	x4, [x1, #56]
 11200ac:	aa1303e2 	mov	x2, x19
 11200b0:	f94023e0 	ldr	x0, [sp, #64]
 11200b4:	aa1503e7 	mov	x7, x21
 11200b8:	b8408485 	ldr	w5, [x4], #8
 11200bc:	aa1403e6 	mov	x6, x20
		res = crypto_cipher_init(cs->ctx, cs->mode,
 11200c0:	b9401401 	ldr	w1, [x0, #20]
 11200c4:	b8408443 	ldr	w3, [x2], #8
 11200c8:	f9401400 	ldr	x0, [x0, #40]
 11200cc:	97ffb530 	bl	110d58c <crypto_cipher_init>
	if (res != TEE_SUCCESS)
 11200d0:	35fffce0 	cbnz	w0, 112006c <syscall_cipher_init+0xac>
	cs->ctx_finalize = crypto_cipher_final;
 11200d4:	f94023e2 	ldr	x2, [sp, #64]
 11200d8:	d00001c1 	adrp	x1, 115a000 <__scattered_array_1phys_mem_map+0x8>
 11200dc:	f9418c21 	ldr	x1, [x1, #792]
 11200e0:	f9001841 	str	x1, [x2, #48]
	cs->state = CRYP_STATE_INITIALIZED;
 11200e4:	b900385f 	str	wzr, [x2, #56]
	return TEE_SUCCESS;
 11200e8:	17ffffe1 	b	112006c <syscall_cipher_init+0xac>
		res = crypto_cipher_init(cs->ctx, cs->mode,
 11200ec:	aa1303e2 	mov	x2, x19
 11200f0:	aa1503e7 	mov	x7, x21
 11200f4:	aa1403e6 	mov	x6, x20
 11200f8:	d2800005 	mov	x5, #0x0                   	// #0
 11200fc:	d2800004 	mov	x4, #0x0                   	// #0
 1120100:	f94023e0 	ldr	x0, [sp, #64]
 1120104:	17ffffef 	b	11200c0 <syscall_cipher_init+0x100>
		return TEE_ERROR_BAD_STATE;
 1120108:	129fff00 	mov	w0, #0xffff0007            	// #-65529
 112010c:	17ffffd8 	b	112006c <syscall_cipher_init+0xac>

0000000001120110 <syscall_cipher_update>:
	return tee_svc_cipher_update_helper(state, false /* last_block */,
 1120110:	aa0403e5 	mov	x5, x4
 1120114:	aa0303e4 	mov	x4, x3
 1120118:	aa0203e3 	mov	x3, x2
 112011c:	aa0103e2 	mov	x2, x1
 1120120:	52800001 	mov	w1, #0x0                   	// #0
 1120124:	17fff88e 	b	111e35c <tee_svc_cipher_update_helper>

0000000001120128 <syscall_cipher_final>:
	return tee_svc_cipher_update_helper(state, true /* last_block */,
 1120128:	aa0403e5 	mov	x5, x4
 112012c:	aa0303e4 	mov	x4, x3
 1120130:	aa0203e3 	mov	x3, x2
 1120134:	aa0103e2 	mov	x2, x1
 1120138:	52800021 	mov	w1, #0x1                   	// #1
 112013c:	17fff888 	b	111e35c <tee_svc_cipher_update_helper>

0000000001120140 <syscall_cryp_derive_key>:
{
 1120140:	d104c3ff 	sub	sp, sp, #0x130
 1120144:	a9017bfd 	stp	x29, x30, [sp, #16]
 1120148:	910043fd 	add	x29, sp, #0x10
 112014c:	a90253f3 	stp	x19, x20, [sp, #32]
 1120150:	aa0203f4 	mov	x20, x2
 1120154:	a9035bf5 	stp	x21, x22, [sp, #48]
 1120158:	aa0103f6 	mov	x22, x1
 112015c:	aa0303f5 	mov	x21, x3
 1120160:	a90463f7 	stp	x23, x24, [sp, #64]
 1120164:	aa0003f7 	mov	x23, x0
 1120168:	a9056bf9 	stp	x25, x26, [sp, #80]
 112016c:	a90673fb 	stp	x27, x28, [sp, #96]
	struct ts_session *sess = ts_get_current_session();
 1120170:	97ffd21c 	bl	11149e0 <ts_get_current_session>
 1120174:	aa0003f3 	mov	x19, x0
	struct user_ta_ctx *utc = to_user_ta_ctx(sess->ctx);
 1120178:	f9400800 	ldr	x0, [x0, #16]
 112017c:	97fff81e 	bl	111e1f4 <to_user_ta_ctx>
 1120180:	aa0003f8 	mov	x24, x0
	res = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);
 1120184:	2a1703e0 	mov	w0, w23
	struct tee_obj *so = NULL;
 1120188:	a907ffff 	stp	xzr, xzr, [sp, #120]
	struct tee_cryp_state *cs = NULL;
 112018c:	f90047ff 	str	xzr, [sp, #136]
	res = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);
 1120190:	97ffd3ca 	bl	11150b8 <uref_to_vaddr>
 1120194:	aa0003e1 	mov	x1, x0
 1120198:	910223e2 	add	x2, sp, #0x88
 112019c:	f9400a60 	ldr	x0, [x19, #16]
 11201a0:	97fff85c 	bl	111e310 <tee_svc_cryp_get_state.isra.0>
 11201a4:	2a0003fa 	mov	w26, w0
	if (res != TEE_SUCCESS)
 11201a8:	35000ba0 	cbnz	w0, 112031c <syscall_cryp_derive_key+0x1dc>
	if (MUL_OVERFLOW(sizeof(TEE_Attribute), param_count, &alloc_size))
 11201ac:	d2800302 	mov	x2, #0x18                  	// #24
 11201b0:	9b027e80 	mul	x0, x20, x2
 11201b4:	9bc27e82 	umulh	x2, x20, x2
 11201b8:	f100005f 	cmp	x2, #0x0
 11201bc:	9a9f07f7 	cset	x23, ne  // ne = any
 11201c0:	540042c1 	b.ne	1120a18 <syscall_cryp_derive_key+0x8d8>  // b.any
	params = malloc(alloc_size);
 11201c4:	94008ca5 	bl	1143458 <malloc>
 11201c8:	aa0003f3 	mov	x19, x0
	if (!params)
 11201cc:	b40042a0 	cbz	x0, 1120a20 <syscall_cryp_derive_key+0x8e0>
	res = copy_in_attrs(utc, usr_params, param_count, params);
 11201d0:	aa0003e3 	mov	x3, x0
 11201d4:	2a1403e2 	mov	w2, w20
 11201d8:	aa1603e1 	mov	x1, x22
 11201dc:	aa1803e0 	mov	x0, x24
 11201e0:	97fff6fe 	bl	111ddd8 <copy_in_attrs>
 11201e4:	2a0003fa 	mov	w26, w0
	if (res != TEE_SUCCESS)
 11201e8:	35000960 	cbnz	w0, 1120314 <syscall_cryp_derive_key+0x1d4>
	res = tee_obj_get(utc, cs->key1, &ko);
 11201ec:	f94047e0 	ldr	x0, [sp, #136]
 11201f0:	9101e3e2 	add	x2, sp, #0x78
 11201f4:	f9400c01 	ldr	x1, [x0, #24]
 11201f8:	aa1803e0 	mov	x0, x24
 11201fc:	94001760 	bl	1125f7c <tee_obj_get>
 1120200:	2a0003fa 	mov	w26, w0
	if (res != TEE_SUCCESS)
 1120204:	35000880 	cbnz	w0, 1120314 <syscall_cryp_derive_key+0x1d4>
	res = tee_obj_get(utc, uref_to_vaddr(derived_key), &so);
 1120208:	2a1503e0 	mov	w0, w21
 112020c:	97ffd3ab 	bl	11150b8 <uref_to_vaddr>
 1120210:	910203e2 	add	x2, sp, #0x80
 1120214:	aa0003e1 	mov	x1, x0
 1120218:	aa1803e0 	mov	x0, x24
 112021c:	94001758 	bl	1125f7c <tee_obj_get>
 1120220:	2a0003fa 	mov	w26, w0
	if (res != TEE_SUCCESS)
 1120224:	35000780 	cbnz	w0, 1120314 <syscall_cryp_derive_key+0x1d4>
	sk = so->attr;
 1120228:	f94043f9 	ldr	x25, [sp, #128]
	type_props = tee_svc_find_type_props(so->info.objectType);
 112022c:	b9401320 	ldr	w0, [x25, #16]
 1120230:	97fff49c 	bl	111d4a0 <tee_svc_find_type_props>
 1120234:	aa0003f6 	mov	x22, x0
	if (!type_props) {
 1120238:	b4003ec0 	cbz	x0, 1120a10 <syscall_cryp_derive_key+0x8d0>
	if (cs->algo == TEE_ALG_DH_DERIVE_SHARED_SECRET) {
 112023c:	f94047fa 	ldr	x26, [sp, #136]
 1120240:	52800640 	mov	w0, #0x32                  	// #50
 1120244:	72b00000 	movk	w0, #0x8000, lsl #16
	sk = so->attr;
 1120248:	f9401f35 	ldr	x21, [x25, #56]
	if (cs->algo == TEE_ALG_DH_DERIVE_SHARED_SECRET) {
 112024c:	b9401343 	ldr	w3, [x26, #16]
 1120250:	6b00007f 	cmp	w3, w0
 1120254:	540007a1 	b.ne	1120348 <syscall_cryp_derive_key+0x208>  // b.any
		if (param_count != 1 ||
 1120258:	f100069f 	cmp	x20, #0x1
 112025c:	54001f81 	b.ne	112064c <syscall_cryp_derive_key+0x50c>  // b.any
 1120260:	b9400261 	ldr	w1, [x19]
 1120264:	52802640 	mov	w0, #0x132                 	// #306
 1120268:	72ba0000 	movk	w0, #0xd000, lsl #16
 112026c:	6b00003f 	cmp	w1, w0
 1120270:	54001ee1 	b.ne	112064c <syscall_cryp_derive_key+0x50c>  // b.any
		size_t bin_size = params[0].content.ref.length;
 1120274:	b9401278 	ldr	w24, [x19, #16]
		if (MUL_OVERFLOW(bin_size, 8, &alloc_size)) {
 1120278:	d37df314 	lsl	x20, x24, #3
		pub = crypto_bignum_allocate(alloc_size);
 112027c:	aa1403e0 	mov	x0, x20
 1120280:	940037ea 	bl	112e228 <crypto_bignum_allocate>
 1120284:	aa0003f7 	mov	x23, x0
		ss = crypto_bignum_allocate(alloc_size);
 1120288:	aa1403e0 	mov	x0, x20
 112028c:	940037e7 	bl	112e228 <crypto_bignum_allocate>
 1120290:	aa0003f4 	mov	x20, x0
		if (pub && ss) {
 1120294:	f10002ff 	cmp	x23, #0x0
 1120298:	fa401804 	ccmp	x0, #0x0, #0x4, ne  // ne = any
 112029c:	54000520 	b.eq	1120340 <syscall_cryp_derive_key+0x200>  // b.none
			crypto_bignum_bin2bn(params[0].content.ref.buffer,
 11202a0:	f9400660 	ldr	x0, [x19, #8]
 11202a4:	aa1703e2 	mov	x2, x23
 11202a8:	aa1803e1 	mov	x1, x24
 11202ac:	940037c4 	bl	112e1bc <crypto_bignum_bin2bn>
			res = crypto_acipher_dh_shared_secret(ko->attr,
 11202b0:	f9403fe0 	ldr	x0, [sp, #120]
 11202b4:	aa1403e2 	mov	x2, x20
 11202b8:	aa1703e1 	mov	x1, x23
 11202bc:	f9401c00 	ldr	x0, [x0, #56]
 11202c0:	94002db9 	bl	112b9a4 <crypto_acipher_dh_shared_secret>
 11202c4:	2a0003fa 	mov	w26, w0
			if (res == TEE_SUCCESS) {
 11202c8:	350001e0 	cbnz	w0, 1120304 <syscall_cryp_derive_key+0x1c4>
				sk->key_size = crypto_bignum_num_bytes(ss);
 11202cc:	aa1403e0 	mov	x0, x20
 11202d0:	940037a3 	bl	112e15c <crypto_bignum_num_bytes>
 11202d4:	aa1503e1 	mov	x1, x21
 11202d8:	b8008420 	str	w0, [x1], #8
				crypto_bignum_bn2bin(ss, (uint8_t *)(sk + 1));
 11202dc:	aa1403e0 	mov	x0, x20
 11202e0:	940037a0 	bl	112e160 <crypto_bignum_bn2bin>
				so->info.handleFlags |=
 11202e4:	f94043e0 	ldr	x0, [sp, #128]
				set_attribute(so, type_props,
 11202e8:	52b80002 	mov	w2, #0xc0000000            	// #-1073741824
 11202ec:	9100c000 	add	x0, x0, #0x30
				so->info.handleFlags |=
 11202f0:	b85f8001 	ldur	w1, [x0, #-8]
 11202f4:	320f0021 	orr	w1, w1, #0x20000
 11202f8:	b81f8001 	stur	w1, [x0, #-8]
				set_attribute(so, type_props,
 11202fc:	aa1603e1 	mov	x1, x22
 1120300:	97fff72c 	bl	111dfb0 <set_attribute.isra.0>
		crypto_bignum_free(pub);
 1120304:	aa1703e0 	mov	x0, x23
 1120308:	940037de 	bl	112e280 <crypto_bignum_free>
		crypto_bignum_free(ss);
 112030c:	aa1403e0 	mov	x0, x20
 1120310:	940037dc 	bl	112e280 <crypto_bignum_free>
	free_wipe(params);
 1120314:	aa1303e0 	mov	x0, x19
 1120318:	94008cb4 	bl	11435e8 <free_wipe>
}
 112031c:	2a1a03e0 	mov	w0, w26
 1120320:	a9417bfd 	ldp	x29, x30, [sp, #16]
 1120324:	a94253f3 	ldp	x19, x20, [sp, #32]
 1120328:	a9435bf5 	ldp	x21, x22, [sp, #48]
 112032c:	a94463f7 	ldp	x23, x24, [sp, #64]
 1120330:	a9456bf9 	ldp	x25, x26, [sp, #80]
 1120334:	a94673fb 	ldp	x27, x28, [sp, #96]
 1120338:	9104c3ff 	add	sp, sp, #0x130
 112033c:	d65f03c0 	ret
			res = TEE_ERROR_OUT_OF_MEMORY;
 1120340:	129ffe7a 	mov	w26, #0xffff000c            	// #-65524
 1120344:	17fffff0 	b	1120304 <syscall_cryp_derive_key+0x1c4>
	} else if (TEE_ALG_GET_MAIN_ALG(cs->algo) == TEE_MAIN_ALGO_ECDH) {
 1120348:	2a0303e0 	mov	w0, w3
 112034c:	97fff433 	bl	111d418 <__tee_alg_get_main_alg>
 1120350:	7101081f 	cmp	w0, #0x42
 1120354:	54000a61 	b.ne	11204a0 <syscall_cryp_derive_key+0x360>  // b.any
		if (param_count != 2 ||
 1120358:	f1000a9f 	cmp	x20, #0x2
 112035c:	54001781 	b.ne	112064c <syscall_cryp_derive_key+0x50c>  // b.any
 1120360:	b9400261 	ldr	w1, [x19]
 1120364:	52802820 	mov	w0, #0x141                 	// #321
 1120368:	72ba0000 	movk	w0, #0xd000, lsl #16
 112036c:	6b00003f 	cmp	w1, w0
 1120370:	540016e1 	b.ne	112064c <syscall_cryp_derive_key+0x50c>  // b.any
		    params[0].attributeID != TEE_ATTR_ECC_PUBLIC_VALUE_X ||
 1120374:	b9401a61 	ldr	w1, [x19, #24]
 1120378:	11040000 	add	w0, w0, #0x100
 112037c:	6b00003f 	cmp	w1, w0
 1120380:	54001661 	b.ne	112064c <syscall_cryp_derive_key+0x50c>  // b.any
		switch (cs->algo) {
 1120384:	52860840 	mov	w0, #0x3042                	// #12354
 1120388:	72b00000 	movk	w0, #0x8000, lsl #16
 112038c:	6b00007f 	cmp	w3, w0
 1120390:	540007c0 	b.eq	1120488 <syscall_cryp_derive_key+0x348>  // b.none
 1120394:	54000168 	b.hi	11203c0 <syscall_cryp_derive_key+0x280>  // b.pmore
 1120398:	52820840 	mov	w0, #0x1042                	// #4162
 112039c:	72b00000 	movk	w0, #0x8000, lsl #16
 11203a0:	6b00007f 	cmp	w3, w0
 11203a4:	54000760 	b.eq	1120490 <syscall_cryp_derive_key+0x350>  // b.none
 11203a8:	11400400 	add	w0, w0, #0x1, lsl #12
 11203ac:	d2801c02 	mov	x2, #0xe0                  	// #224
 11203b0:	6b00007f 	cmp	w3, w0
 11203b4:	54000160 	b.eq	11203e0 <syscall_cryp_derive_key+0x2a0>  // b.none
 11203b8:	129ffeda 	mov	w26, #0xffff0009            	// #-65527
 11203bc:	17ffffd6 	b	1120314 <syscall_cryp_derive_key+0x1d4>
 11203c0:	52880840 	mov	w0, #0x4042                	// #16450
 11203c4:	72b00000 	movk	w0, #0x8000, lsl #16
 11203c8:	6b00007f 	cmp	w3, w0
 11203cc:	54000660 	b.eq	1120498 <syscall_cryp_derive_key+0x358>  // b.none
 11203d0:	11400400 	add	w0, w0, #0x1, lsl #12
 11203d4:	6b00007f 	cmp	w3, w0
 11203d8:	54ffff01 	b.ne	11203b8 <syscall_cryp_derive_key+0x278>  // b.any
			alloc_size = 521;
 11203dc:	d2804122 	mov	x2, #0x209                 	// #521
		res = crypto_acipher_alloc_ecc_public_key(&key_public, key_type,
 11203e0:	910363f4 	add	x20, sp, #0xd8
 11203e4:	52800841 	mov	w1, #0x42                  	// #66
 11203e8:	aa1403e0 	mov	x0, x20
 11203ec:	72b40001 	movk	w1, #0xa000, lsl #16
 11203f0:	97ffb658 	bl	110dd50 <crypto_acipher_alloc_ecc_public_key>
 11203f4:	2a0003fa 	mov	w26, w0
		if (res != TEE_SUCCESS)
 11203f8:	35fff8e0 	cbnz	w0, 1120314 <syscall_cryp_derive_key+0x1d4>
		key_public.curve = ((struct ecc_keypair *)ko->attr)->curve;
 11203fc:	f9403fe0 	ldr	x0, [sp, #120]
		crypto_bignum_bin2bn(params[0].content.ref.buffer,
 1120400:	b9401261 	ldr	w1, [x19, #16]
 1120404:	f9406fe2 	ldr	x2, [sp, #216]
		key_public.curve = ((struct ecc_keypair *)ko->attr)->curve;
 1120408:	f9401c00 	ldr	x0, [x0, #56]
 112040c:	b9401800 	ldr	w0, [x0, #24]
 1120410:	b900ebe0 	str	w0, [sp, #232]
		crypto_bignum_bin2bn(params[0].content.ref.buffer,
 1120414:	f9400660 	ldr	x0, [x19, #8]
 1120418:	94003769 	bl	112e1bc <crypto_bignum_bin2bn>
		crypto_bignum_bin2bn(params[1].content.ref.buffer,
 112041c:	b9402a61 	ldr	w1, [x19, #40]
 1120420:	f9401260 	ldr	x0, [x19, #32]
 1120424:	f94073e2 	ldr	x2, [sp, #224]
 1120428:	94003765 	bl	112e1bc <crypto_bignum_bin2bn>
		pt_secret_len = sk->alloc_size;
 112042c:	b94006a0 	ldr	w0, [x21, #4]
		res = crypto_acipher_ecc_shared_secret(ko->attr, &key_public,
 1120430:	9102e3e3 	add	x3, sp, #0xb8
		pt_secret_len = sk->alloc_size;
 1120434:	f9005fe0 	str	x0, [sp, #184]
		res = crypto_acipher_ecc_shared_secret(ko->attr, &key_public,
 1120438:	910022a2 	add	x2, x21, #0x8
 112043c:	f9403fe0 	ldr	x0, [sp, #120]
 1120440:	aa1403e1 	mov	x1, x20
 1120444:	f9401c00 	ldr	x0, [x0, #56]
 1120448:	97ffb68c 	bl	110de78 <crypto_acipher_ecc_shared_secret>
 112044c:	2a0003fa 	mov	w26, w0
		if (res == TEE_SUCCESS) {
 1120450:	35000160 	cbnz	w0, 112047c <syscall_cryp_derive_key+0x33c>
			sk->key_size = pt_secret_len;
 1120454:	f9405fe0 	ldr	x0, [sp, #184]
 1120458:	b90002a0 	str	w0, [x21]
			so->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;
 112045c:	f94043e0 	ldr	x0, [sp, #128]
			set_attribute(so, type_props, TEE_ATTR_SECRET_VALUE);
 1120460:	52b80002 	mov	w2, #0xc0000000            	// #-1073741824
 1120464:	9100c000 	add	x0, x0, #0x30
			so->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;
 1120468:	b85f8001 	ldur	w1, [x0, #-8]
 112046c:	320f0021 	orr	w1, w1, #0x20000
 1120470:	b81f8001 	stur	w1, [x0, #-8]
			set_attribute(so, type_props, TEE_ATTR_SECRET_VALUE);
 1120474:	aa1603e1 	mov	x1, x22
 1120478:	97fff6ce 	bl	111dfb0 <set_attribute.isra.0>
		crypto_acipher_free_ecc_public_key(&key_public);
 112047c:	aa1403e0 	mov	x0, x20
	crypto_acipher_free_ecc_public_key(peer_key);
 1120480:	97ffb636 	bl	110dd58 <crypto_acipher_free_ecc_public_key>
	return res;
 1120484:	17ffffa4 	b	1120314 <syscall_cryp_derive_key+0x1d4>
			alloc_size = 256;
 1120488:	d2802002 	mov	x2, #0x100                 	// #256
 112048c:	17ffffd5 	b	11203e0 <syscall_cryp_derive_key+0x2a0>
			alloc_size = 192;
 1120490:	d2801802 	mov	x2, #0xc0                  	// #192
 1120494:	17ffffd3 	b	11203e0 <syscall_cryp_derive_key+0x2a0>
			alloc_size = 384;
 1120498:	d2803002 	mov	x2, #0x180                 	// #384
 112049c:	17ffffd1 	b	11203e0 <syscall_cryp_derive_key+0x2a0>
	else if (TEE_ALG_GET_MAIN_ALG(cs->algo) == TEE_MAIN_ALGO_HKDF) {
 11204a0:	7103001f 	cmp	w0, #0xc0
 11204a4:	540008a1 	b.ne	11205b8 <syscall_cryp_derive_key+0x478>  // b.any
	return (algo >> 12) & 0xF;
 11204a8:	528c08a1 	mov	w1, #0x6045                	// #24645
 11204ac:	d34c3c60 	ubfx	x0, x3, #12, #4
 11204b0:	72ae0001 	movk	w1, #0x7000, lsl #16
		switch (params[n].attributeID) {
 11204b4:	52807802 	mov	w2, #0x3c0                 	// #960
 11204b8:	6b01007f 	cmp	w3, w1
 11204bc:	52809809 	mov	w9, #0x4c0                 	// #1216
 11204c0:	528000e1 	mov	w1, #0x7                   	// #7
 11204c4:	5280580a 	mov	w10, #0x2c0                 	// #704
 11204c8:	aa1303e4 	mov	x4, x19
	for (n = 0; n < param_count; n++) {
 11204cc:	92407e94 	and	x20, x20, #0xffffffff
 11204d0:	1a811000 	csel	w0, w0, w1, ne  // ne = any
	*salt_len = *info_len = *okm_len = 0;
 11204d4:	d2800018 	mov	x24, #0x0                   	// #0
 11204d8:	d2800006 	mov	x6, #0x0                   	// #0
	for (n = 0; n < param_count; n++) {
 11204dc:	d2800007 	mov	x7, #0x0                   	// #0
	*salt = *info = NULL;
 11204e0:	d2800005 	mov	x5, #0x0                   	// #0
 11204e4:	d2800003 	mov	x3, #0x0                   	// #0
	uint8_t found = 0;
 11204e8:	52800001 	mov	w1, #0x0                   	// #0
		switch (params[n].attributeID) {
 11204ec:	72ba0002 	movk	w2, #0xd000, lsl #16
 11204f0:	72be0009 	movk	w9, #0xf000, lsl #16
 11204f4:	72ba000a 	movk	w10, #0xd000, lsl #16
	for (n = 0; n < param_count; n++) {
 11204f8:	eb1400ff 	cmp	x7, x20
 11204fc:	54000303 	b.cc	112055c <syscall_cryp_derive_key+0x41c>  // b.lo, b.ul, b.last
	if (!(found & LENGTH))
 1120500:	36080a61 	tbz	w1, #1, 112064c <syscall_cryp_derive_key+0x50c>
		struct tee_cryp_obj_secret *ik = ko->attr;
 1120504:	f9403fe1 	ldr	x1, [sp, #120]
 1120508:	f9401c21 	ldr	x1, [x1, #56]
		if (okm_len > ik->alloc_size) {
 112050c:	b9400422 	ldr	w2, [x1, #4]
 1120510:	eb18005f 	cmp	x2, x24
 1120514:	540009c3 	b.cc	112064c <syscall_cryp_derive_key+0x50c>  // b.lo, b.ul, b.last
		res = tee_cryp_hkdf(hash_id, ikm, ik->key_size, salt, salt_len,
 1120518:	b8408422 	ldr	w2, [x1], #8
 112051c:	910022a7 	add	x7, x21, #0x8
 1120520:	f90003f8 	str	x24, [sp]
 1120524:	aa1703e4 	mov	x4, x23
 1120528:	97ffedd6 	bl	111bc80 <tee_cryp_hkdf>
		res = tee_cryp_pbkdf2(hash_id, password, ss->key_size, salt,
 112052c:	2a0003fa 	mov	w26, w0
		if (res == TEE_SUCCESS) {
 1120530:	35ffef20 	cbnz	w0, 1120314 <syscall_cryp_derive_key+0x1d4>
			so->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;
 1120534:	f94043e0 	ldr	x0, [sp, #128]
			sk->key_size = derived_key_len;
 1120538:	b90002b8 	str	w24, [x21]
			set_attribute(so, type_props, TEE_ATTR_SECRET_VALUE);
 112053c:	52b80002 	mov	w2, #0xc0000000            	// #-1073741824
 1120540:	9100c000 	add	x0, x0, #0x30
			so->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;
 1120544:	b85f8001 	ldur	w1, [x0, #-8]
 1120548:	320f0021 	orr	w1, w1, #0x20000
 112054c:	b81f8001 	stur	w1, [x0, #-8]
			set_attribute(so, type_props, TEE_ATTR_SECRET_VALUE);
 1120550:	aa1603e1 	mov	x1, x22
 1120554:	97fff697 	bl	111dfb0 <set_attribute.isra.0>
 1120558:	17ffff6f 	b	1120314 <syscall_cryp_derive_key+0x1d4>
		switch (params[n].attributeID) {
 112055c:	b9400088 	ldr	w8, [x4]
 1120560:	6b02011f 	cmp	w8, w2
 1120564:	54000200 	b.eq	11205a4 <syscall_cryp_derive_key+0x464>  // b.none
 1120568:	6b09011f 	cmp	w8, w9
 112056c:	54000140 	b.eq	1120594 <syscall_cryp_derive_key+0x454>  // b.none
 1120570:	6b0a011f 	cmp	w8, w10
 1120574:	540006c1 	b.ne	112064c <syscall_cryp_derive_key+0x50c>  // b.any
			if (!(found & SALT)) {
 1120578:	37000081 	tbnz	w1, #0, 1120588 <syscall_cryp_derive_key+0x448>
				*salt_len = params[n].content.ref.length;
 112057c:	b9401097 	ldr	w23, [x4, #16]
				found |= SALT;
 1120580:	32000021 	orr	w1, w1, #0x1
				*salt = params[n].content.ref.buffer;
 1120584:	f9400483 	ldr	x3, [x4, #8]
	for (n = 0; n < param_count; n++) {
 1120588:	910004e7 	add	x7, x7, #0x1
 112058c:	91006084 	add	x4, x4, #0x18
 1120590:	17ffffda 	b	11204f8 <syscall_cryp_derive_key+0x3b8>
			if (!(found & LENGTH)) {
 1120594:	370fffa1 	tbnz	w1, #1, 1120588 <syscall_cryp_derive_key+0x448>
				*okm_len = params[n].content.value.a;
 1120598:	b9400898 	ldr	w24, [x4, #8]
				found |= LENGTH;
 112059c:	321f0021 	orr	w1, w1, #0x2
 11205a0:	17fffffa 	b	1120588 <syscall_cryp_derive_key+0x448>
			if (!(found & INFO)) {
 11205a4:	3717ff21 	tbnz	w1, #2, 1120588 <syscall_cryp_derive_key+0x448>
				*info_len = params[n].content.ref.length;
 11205a8:	b9401086 	ldr	w6, [x4, #16]
				found |= INFO;
 11205ac:	321e0021 	orr	w1, w1, #0x4
				*info = params[n].content.ref.buffer;
 11205b0:	f9400485 	ldr	x5, [x4, #8]
				found |= INFO;
 11205b4:	17fffff5 	b	1120588 <syscall_cryp_derive_key+0x448>
	else if (TEE_ALG_GET_MAIN_ALG(cs->algo) == TEE_MAIN_ALGO_CONCAT_KDF) {
 11205b8:	7103041f 	cmp	w0, #0xc1
 11205bc:	54000621 	b.ne	1120680 <syscall_cryp_derive_key+0x540>  // b.any
 11205c0:	528c08a1 	mov	w1, #0x6045                	// #24645
 11205c4:	d34c3c60 	ubfx	x0, x3, #12, #4
 11205c8:	72ae0001 	movk	w1, #0x7000, lsl #16
		switch (params[n].attributeID) {
 11205cc:	52805822 	mov	w2, #0x2c1                 	// #705
 11205d0:	6b01007f 	cmp	w3, w1
 11205d4:	52807827 	mov	w7, #0x3c1                 	// #961
 11205d8:	528000e1 	mov	w1, #0x7                   	// #7
 11205dc:	aa1303e4 	mov	x4, x19
	for (n = 0; n < param_count; n++) {
 11205e0:	92407e94 	and	x20, x20, #0xffffffff
 11205e4:	1a811000 	csel	w0, w0, w1, ne  // ne = any
	*other_info_len = *derived_key_len = 0;
 11205e8:	d2800018 	mov	x24, #0x0                   	// #0
	for (n = 0; n < param_count; n++) {
 11205ec:	d2800005 	mov	x5, #0x0                   	// #0
	*other_info = NULL;
 11205f0:	d2800003 	mov	x3, #0x0                   	// #0
	uint8_t found = 0;
 11205f4:	52800001 	mov	w1, #0x0                   	// #0
		switch (params[n].attributeID) {
 11205f8:	72ba0002 	movk	w2, #0xd000, lsl #16
 11205fc:	72be0007 	movk	w7, #0xf000, lsl #16
	for (n = 0; n < param_count; n++) {
 1120600:	eb1400bf 	cmp	x5, x20
 1120604:	540001a3 	b.cc	1120638 <syscall_cryp_derive_key+0x4f8>  // b.lo, b.ul, b.last
	if (!(found & LENGTH))
 1120608:	36000221 	tbz	w1, #0, 112064c <syscall_cryp_derive_key+0x50c>
		struct tee_cryp_obj_secret *ss = ko->attr;
 112060c:	f9403fe1 	ldr	x1, [sp, #120]
 1120610:	f9401c21 	ldr	x1, [x1, #56]
		if (derived_key_len > ss->alloc_size) {
 1120614:	b9400422 	ldr	w2, [x1, #4]
 1120618:	eb18005f 	cmp	x2, x24
 112061c:	54000183 	b.cc	112064c <syscall_cryp_derive_key+0x50c>  // b.lo, b.ul, b.last
		res = tee_cryp_concat_kdf(hash_id, shared_secret, ss->key_size,
 1120620:	b8408422 	ldr	w2, [x1], #8
 1120624:	aa1803e6 	mov	x6, x24
 1120628:	910022a5 	add	x5, x21, #0x8
 112062c:	aa1703e4 	mov	x4, x23
 1120630:	97ffee2d 	bl	111bee4 <tee_cryp_concat_kdf>
 1120634:	17ffffbe 	b	112052c <syscall_cryp_derive_key+0x3ec>
		switch (params[n].attributeID) {
 1120638:	b9400086 	ldr	w6, [x4]
 112063c:	6b0200df 	cmp	w6, w2
 1120640:	540000a0 	b.eq	1120654 <syscall_cryp_derive_key+0x514>  // b.none
 1120644:	6b0700df 	cmp	w6, w7
 1120648:	54000140 	b.eq	1120670 <syscall_cryp_derive_key+0x530>  // b.none
			res = TEE_ERROR_BAD_PARAMETERS;
 112064c:	129fff3a 	mov	w26, #0xffff0006            	// #-65530
 1120650:	17ffff31 	b	1120314 <syscall_cryp_derive_key+0x1d4>
			if (!(found & INFO)) {
 1120654:	37080081 	tbnz	w1, #1, 1120664 <syscall_cryp_derive_key+0x524>
				*other_info_len = params[n].content.ref.length;
 1120658:	b9401097 	ldr	w23, [x4, #16]
				found |= INFO;
 112065c:	321f0021 	orr	w1, w1, #0x2
				*other_info = params[n].content.ref.buffer;
 1120660:	f9400483 	ldr	x3, [x4, #8]
	for (n = 0; n < param_count; n++) {
 1120664:	910004a5 	add	x5, x5, #0x1
 1120668:	91006084 	add	x4, x4, #0x18
 112066c:	17ffffe5 	b	1120600 <syscall_cryp_derive_key+0x4c0>
			if (!(found & LENGTH)) {
 1120670:	3707ffa1 	tbnz	w1, #0, 1120664 <syscall_cryp_derive_key+0x524>
				*derived_key_len = params[n].content.value.a;
 1120674:	b9400898 	ldr	w24, [x4, #8]
				found |= LENGTH;
 1120678:	32000021 	orr	w1, w1, #0x1
 112067c:	17fffffa 	b	1120664 <syscall_cryp_derive_key+0x524>
	else if (TEE_ALG_GET_MAIN_ALG(cs->algo) == TEE_MAIN_ALGO_PBKDF2) {
 1120680:	7103081f 	cmp	w0, #0xc2
 1120684:	54000741 	b.ne	112076c <syscall_cryp_derive_key+0x62c>  // b.any
 1120688:	528c08a1 	mov	w1, #0x6045                	// #24645
 112068c:	d34c3c60 	ubfx	x0, x3, #12, #4
 1120690:	72ae0001 	movk	w1, #0x7000, lsl #16
		switch (params[n].attributeID) {
 1120694:	52807842 	mov	w2, #0x3c2                 	// #962
 1120698:	6b01007f 	cmp	w3, w1
 112069c:	52809848 	mov	w8, #0x4c2                 	// #1218
 11206a0:	528000e1 	mov	w1, #0x7                   	// #7
 11206a4:	52805849 	mov	w9, #0x2c2                 	// #706
 11206a8:	aa1303e4 	mov	x4, x19
	for (n = 0; n < param_count; n++) {
 11206ac:	92407e94 	and	x20, x20, #0xffffffff
 11206b0:	1a811000 	csel	w0, w0, w1, ne  // ne = any
	*salt_len = *derived_key_len = *iteration_count = 0;
 11206b4:	d2800018 	mov	x24, #0x0                   	// #0
 11206b8:	d2800005 	mov	x5, #0x0                   	// #0
	for (n = 0; n < param_count; n++) {
 11206bc:	d2800006 	mov	x6, #0x0                   	// #0
	*salt = NULL;
 11206c0:	d2800003 	mov	x3, #0x0                   	// #0
	uint8_t found = 0;
 11206c4:	52800001 	mov	w1, #0x0                   	// #0
		switch (params[n].attributeID) {
 11206c8:	72be0002 	movk	w2, #0xf000, lsl #16
 11206cc:	72be0008 	movk	w8, #0xf000, lsl #16
 11206d0:	72ba0009 	movk	w9, #0xd000, lsl #16
	for (n = 0; n < param_count; n++) {
 11206d4:	eb06029f 	cmp	x20, x6
 11206d8:	540001e8 	b.hi	1120714 <syscall_cryp_derive_key+0x5d4>  // b.pmore
	if ((found & (LENGTH|COUNT)) != (LENGTH|COUNT))
 11206dc:	121f0421 	and	w1, w1, #0x6
 11206e0:	7100183f 	cmp	w1, #0x6
 11206e4:	54fffb41 	b.ne	112064c <syscall_cryp_derive_key+0x50c>  // b.any
		struct tee_cryp_obj_secret *ss = ko->attr;
 11206e8:	f9403fe1 	ldr	x1, [sp, #120]
 11206ec:	f9401c21 	ldr	x1, [x1, #56]
		if (derived_key_len > ss->alloc_size) {
 11206f0:	b9400422 	ldr	w2, [x1, #4]
 11206f4:	eb18005f 	cmp	x2, x24
 11206f8:	54fffaa3 	b.cc	112064c <syscall_cryp_derive_key+0x50c>  // b.lo, b.ul, b.last
		res = tee_cryp_pbkdf2(hash_id, password, ss->key_size, salt,
 11206fc:	b8408422 	ldr	w2, [x1], #8
 1120700:	aa1803e7 	mov	x7, x24
 1120704:	910022a6 	add	x6, x21, #0x8
 1120708:	aa1703e4 	mov	x4, x23
 112070c:	97ffee93 	bl	111c158 <tee_cryp_pbkdf2>
 1120710:	17ffff87 	b	112052c <syscall_cryp_derive_key+0x3ec>
		switch (params[n].attributeID) {
 1120714:	b9400087 	ldr	w7, [x4]
 1120718:	6b0200ff 	cmp	w7, w2
 112071c:	54000200 	b.eq	112075c <syscall_cryp_derive_key+0x61c>  // b.none
 1120720:	6b0800ff 	cmp	w7, w8
 1120724:	54000140 	b.eq	112074c <syscall_cryp_derive_key+0x60c>  // b.none
 1120728:	6b0900ff 	cmp	w7, w9
 112072c:	54fff901 	b.ne	112064c <syscall_cryp_derive_key+0x50c>  // b.any
			if (!(found & SALT)) {
 1120730:	37000081 	tbnz	w1, #0, 1120740 <syscall_cryp_derive_key+0x600>
				*salt_len = params[n].content.ref.length;
 1120734:	b9401097 	ldr	w23, [x4, #16]
				found |= SALT;
 1120738:	32000021 	orr	w1, w1, #0x1
				*salt = params[n].content.ref.buffer;
 112073c:	f9400483 	ldr	x3, [x4, #8]
	for (n = 0; n < param_count; n++) {
 1120740:	910004c6 	add	x6, x6, #0x1
 1120744:	91006084 	add	x4, x4, #0x18
 1120748:	17ffffe3 	b	11206d4 <syscall_cryp_derive_key+0x594>
			if (!(found & LENGTH)) {
 112074c:	370fffa1 	tbnz	w1, #1, 1120740 <syscall_cryp_derive_key+0x600>
				*derived_key_len = params[n].content.value.a;
 1120750:	b9400898 	ldr	w24, [x4, #8]
				found |= LENGTH;
 1120754:	321f0021 	orr	w1, w1, #0x2
 1120758:	17fffffa 	b	1120740 <syscall_cryp_derive_key+0x600>
			if (!(found & COUNT)) {
 112075c:	3717ff21 	tbnz	w1, #2, 1120740 <syscall_cryp_derive_key+0x600>
				*iteration_count = params[n].content.value.a;
 1120760:	b9400885 	ldr	w5, [x4, #8]
				found |= COUNT;
 1120764:	321e0021 	orr	w1, w1, #0x4
 1120768:	17fffff6 	b	1120740 <syscall_cryp_derive_key+0x600>
	else if (cs->algo == TEE_ALG_SM2_KEP) {
 112076c:	528008a0 	mov	w0, #0x45                  	// #69
 1120770:	72ac0000 	movk	w0, #0x6000, lsl #16
 1120774:	6b00007f 	cmp	w3, w0
 1120778:	540014c1 	b.ne	1120a10 <syscall_cryp_derive_key+0x8d0>  // b.any
		struct sm2_kep_parms kep_parms = {
 112077c:	d2800902 	mov	x2, #0x48                  	// #72
 1120780:	52800001 	mov	w1, #0x0                   	// #0
 1120784:	9103a3e0 	add	x0, sp, #0xe8
		struct ecc_public_key peer_eph_key = { };
 1120788:	a909ffff 	stp	xzr, xzr, [sp, #152]
 112078c:	a90affff 	stp	xzr, xzr, [sp, #168]
		struct ecc_public_key peer_key = { };
 1120790:	a90bffff 	stp	xzr, xzr, [sp, #184]
 1120794:	a90cffff 	stp	xzr, xzr, [sp, #200]
		struct sm2_kep_parms kep_parms = {
 1120798:	94008d52 	bl	1143ce0 <memset>
			.out = (uint8_t *)(sk + 1),
 112079c:	910022a0 	add	x0, x21, #0x8
		res = tee_obj_get(utc, cs->key2, &ko2);
 11207a0:	f9401341 	ldr	x1, [x26, #32]
		struct sm2_kep_parms kep_parms = {
 11207a4:	f9006fe0 	str	x0, [sp, #216]
			.out_len = so->info.maxKeySize,
 11207a8:	b9401b20 	ldr	w0, [x25, #24]
		res = tee_obj_get(utc, cs->key2, &ko2);
 11207ac:	910243e2 	add	x2, sp, #0x90
		struct tee_obj *ko2 = NULL;
 11207b0:	f9004bff 	str	xzr, [sp, #144]
			.out_len = so->info.maxKeySize,
 11207b4:	f90073e0 	str	x0, [sp, #224]
		res = tee_obj_get(utc, cs->key2, &ko2);
 11207b8:	aa1803e0 	mov	x0, x24
 11207bc:	940015f0 	bl	1125f7c <tee_obj_get>
 11207c0:	2a0003fa 	mov	w26, w0
		if (res != TEE_SUCCESS)
 11207c4:	35ffda80 	cbnz	w0, 1120314 <syscall_cryp_derive_key+0x1d4>
	res = crypto_acipher_alloc_ecc_public_key(peer_key,
 11207c8:	9102e3f9 	add	x25, sp, #0xb8
 11207cc:	528008c1 	mov	w1, #0x46                  	// #70
 11207d0:	aa1903e0 	mov	x0, x25
 11207d4:	d2802002 	mov	x2, #0x100                 	// #256
 11207d8:	72b40001 	movk	w1, #0xa000, lsl #16
 11207dc:	97ffb55d 	bl	110dd50 <crypto_acipher_alloc_ecc_public_key>
 11207e0:	2a0003fa 	mov	w26, w0
	if (res)
 11207e4:	35ffd980 	cbnz	w0, 1120314 <syscall_cryp_derive_key+0x1d4>
	res = crypto_acipher_alloc_ecc_public_key(peer_eph_key,
 11207e8:	910263f8 	add	x24, sp, #0x98
 11207ec:	528008c1 	mov	w1, #0x46                  	// #70
 11207f0:	aa1803e0 	mov	x0, x24
 11207f4:	d2802002 	mov	x2, #0x100                 	// #256
 11207f8:	72b40001 	movk	w1, #0xa000, lsl #16
 11207fc:	97ffb555 	bl	110dd50 <crypto_acipher_alloc_ecc_public_key>
 1120800:	2a0003fa 	mov	w26, w0
	if (res)
 1120804:	35000700 	cbnz	w0, 11208e4 <syscall_cryp_derive_key+0x7a4>
		switch (p->attributeID) {
 1120808:	528128dc 	mov	w28, #0x946                 	// #2374
 112080c:	aa1303fb 	mov	x27, x19
	peer_key->curve = TEE_ECC_CURVE_SM2;
 1120810:	52806000 	mov	w0, #0x300                 	// #768
		switch (p->attributeID) {
 1120814:	72ba001c 	movk	w28, #0xd000, lsl #16
	peer_eph_key->curve = TEE_ECC_CURVE_SM2;
 1120818:	b900abe0 	str	w0, [sp, #168]
	peer_key->curve = TEE_ECC_CURVE_SM2;
 112081c:	b900cbe0 	str	w0, [sp, #200]
	for (n = 0; n < param_count; n++) {
 1120820:	eb3442ff 	cmp	x23, w20, uxtw
 1120824:	54000363 	b.cc	1120890 <syscall_cryp_derive_key+0x750>  // b.lo, b.ul, b.last
	if ((found & mandatory) != mandatory) {
 1120828:	7101ff5f 	cmp	w26, #0x7f
 112082c:	54000561 	b.ne	11208d8 <syscall_cryp_derive_key+0x798>  // b.any
		res = crypto_acipher_sm2_kep_derive(ko->attr, /* key1 */
 1120830:	f9404be0 	ldr	x0, [sp, #144]
 1120834:	910363e4 	add	x4, sp, #0xd8
 1120838:	aa1803e3 	mov	x3, x24
 112083c:	aa1903e2 	mov	x2, x25
 1120840:	f9401c01 	ldr	x1, [x0, #56]
 1120844:	f9403fe0 	ldr	x0, [sp, #120]
 1120848:	f9401c00 	ldr	x0, [x0, #56]
 112084c:	940031cf 	bl	112cf88 <crypto_acipher_sm2_kep_derive>
 1120850:	2a0003fa 	mov	w26, w0
		if (res == TEE_SUCCESS) {
 1120854:	35000160 	cbnz	w0, 1120880 <syscall_cryp_derive_key+0x740>
			sk->key_size = kep_parms.out_len;
 1120858:	f94073e0 	ldr	x0, [sp, #224]
 112085c:	b90002a0 	str	w0, [x21]
			so->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;
 1120860:	f94043e0 	ldr	x0, [sp, #128]
			set_attribute(so, type_props, TEE_ATTR_SECRET_VALUE);
 1120864:	52b80002 	mov	w2, #0xc0000000            	// #-1073741824
 1120868:	9100c000 	add	x0, x0, #0x30
			so->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;
 112086c:	b85f8001 	ldur	w1, [x0, #-8]
 1120870:	320f0021 	orr	w1, w1, #0x20000
 1120874:	b81f8001 	stur	w1, [x0, #-8]
			set_attribute(so, type_props, TEE_ATTR_SECRET_VALUE);
 1120878:	aa1603e1 	mov	x1, x22
 112087c:	97fff5cd 	bl	111dfb0 <set_attribute.isra.0>
		crypto_acipher_free_ecc_public_key(&peer_key);
 1120880:	aa1903e0 	mov	x0, x25
 1120884:	97ffb535 	bl	110dd58 <crypto_acipher_free_ecc_public_key>
		crypto_acipher_free_ecc_public_key(&peer_eph_key);
 1120888:	aa1803e0 	mov	x0, x24
 112088c:	17fffefd 	b	1120480 <syscall_cryp_derive_key+0x340>
		switch (p->attributeID) {
 1120890:	b9400360 	ldr	w0, [x27]
 1120894:	5280e8c1 	mov	w1, #0x746                 	// #1862
 1120898:	72ba0001 	movk	w1, #0xd000, lsl #16
 112089c:	6b01001f 	cmp	w0, w1
 11208a0:	54000a40 	b.eq	11209e8 <syscall_cryp_derive_key+0x8a8>  // b.none
 11208a4:	54000388 	b.hi	1120914 <syscall_cryp_derive_key+0x7d4>  // b.pmore
 11208a8:	528088c1 	mov	w1, #0x446                 	// #1094
 11208ac:	72ba0001 	movk	w1, #0xd000, lsl #16
 11208b0:	6b01001f 	cmp	w0, w1
 11208b4:	540008e0 	b.eq	11209d0 <syscall_cryp_derive_key+0x890>  // b.none
 11208b8:	540001a8 	b.hi	11208ec <syscall_cryp_derive_key+0x7ac>  // b.pmore
 11208bc:	52802821 	mov	w1, #0x141                 	// #321
 11208c0:	72ba0001 	movk	w1, #0xd000, lsl #16
 11208c4:	6b01001f 	cmp	w0, w1
 11208c8:	54000600 	b.eq	1120988 <syscall_cryp_derive_key+0x848>  // b.none
 11208cc:	11040021 	add	w1, w1, #0x100
 11208d0:	6b01001f 	cmp	w0, w1
 11208d4:	54000660 	b.eq	11209a0 <syscall_cryp_derive_key+0x860>  // b.none
	crypto_acipher_free_ecc_public_key(peer_eph_key);
 11208d8:	129fff3a 	mov	w26, #0xffff0006            	// #-65530
 11208dc:	aa1803e0 	mov	x0, x24
 11208e0:	97ffb51e 	bl	110dd58 <crypto_acipher_free_ecc_public_key>
	crypto_acipher_free_ecc_public_key(peer_key);
 11208e4:	aa1903e0 	mov	x0, x25
 11208e8:	17fffee6 	b	1120480 <syscall_cryp_derive_key+0x340>
		switch (p->attributeID) {
 11208ec:	5280a8c1 	mov	w1, #0x546                 	// #1350
 11208f0:	72ba0001 	movk	w1, #0xd000, lsl #16
 11208f4:	6b01001f 	cmp	w0, w1
 11208f8:	54ffff01 	b.ne	11208d8 <syscall_cryp_derive_key+0x798>  // b.any
			kep_parms->responder_id = p->content.ref.buffer;
 11208fc:	f9400760 	ldr	x0, [x27, #8]
 1120900:	f90083e0 	str	x0, [sp, #256]
			kep_parms->responder_id_len = p->content.ref.length;
 1120904:	b9401360 	ldr	w0, [x27, #16]
			found |= BIT(RESPONDER_ID);
 1120908:	321a035a 	orr	w26, w26, #0x40
			kep_parms->responder_id_len = p->content.ref.length;
 112090c:	f90087e0 	str	x0, [sp, #264]
			break;
 1120910:	1400001b 	b	112097c <syscall_cryp_derive_key+0x83c>
		switch (p->attributeID) {
 1120914:	528148c1 	mov	w1, #0xa46                 	// #2630
 1120918:	72ba0001 	movk	w1, #0xd000, lsl #16
 112091c:	6b01001f 	cmp	w0, w1
 1120920:	540004c0 	b.eq	11209b8 <syscall_cryp_derive_key+0x878>  // b.none
 1120924:	540001a8 	b.hi	1120958 <syscall_cryp_derive_key+0x818>  // b.pmore
 1120928:	528108c1 	mov	w1, #0x846                 	// #2118
 112092c:	72ba0001 	movk	w1, #0xd000, lsl #16
 1120930:	6b01001f 	cmp	w0, w1
 1120934:	54000640 	b.eq	11209fc <syscall_cryp_derive_key+0x8bc>  // b.none
 1120938:	6b1c001f 	cmp	w0, w28
 112093c:	54fffce1 	b.ne	11208d8 <syscall_cryp_derive_key+0x798>  // b.any
			crypto_bignum_bin2bn(p->content.ref.buffer,
 1120940:	b9401361 	ldr	w1, [x27, #16]
			found |= BIT(PEER_EPH_KEY_X);
 1120944:	321d035a 	orr	w26, w26, #0x8
			crypto_bignum_bin2bn(p->content.ref.buffer,
 1120948:	f9400760 	ldr	x0, [x27, #8]
 112094c:	f9404fe2 	ldr	x2, [sp, #152]
 1120950:	9400361b 	bl	112e1bc <crypto_bignum_bin2bn>
			break;
 1120954:	1400000a 	b	112097c <syscall_cryp_derive_key+0x83c>
		switch (p->attributeID) {
 1120958:	5280c8c1 	mov	w1, #0x646                 	// #1606
 112095c:	72be0001 	movk	w1, #0xf000, lsl #16
 1120960:	6b01001f 	cmp	w0, w1
 1120964:	54fffba1 	b.ne	11208d8 <syscall_cryp_derive_key+0x798>  // b.any
			kep_parms->is_initiator = !p->content.value.a;
 1120968:	b9400b60 	ldr	w0, [x27, #8]
			found |= BIT(IS_INITIATOR);
 112096c:	3200035a 	orr	w26, w26, #0x1
			kep_parms->is_initiator = !p->content.value.a;
 1120970:	7100001f 	cmp	w0, #0x0
 1120974:	1a9f17e0 	cset	w0, eq  // eq = none
 1120978:	3903a3e0 	strb	w0, [sp, #232]
	for (n = 0; n < param_count; n++) {
 112097c:	910006f7 	add	x23, x23, #0x1
 1120980:	9100637b 	add	x27, x27, #0x18
 1120984:	17ffffa7 	b	1120820 <syscall_cryp_derive_key+0x6e0>
			crypto_bignum_bin2bn(p->content.ref.buffer,
 1120988:	b9401361 	ldr	w1, [x27, #16]
			found |= BIT(PEER_KEY_X);
 112098c:	321f035a 	orr	w26, w26, #0x2
			crypto_bignum_bin2bn(p->content.ref.buffer,
 1120990:	f9400760 	ldr	x0, [x27, #8]
 1120994:	f9405fe2 	ldr	x2, [sp, #184]
 1120998:	94003609 	bl	112e1bc <crypto_bignum_bin2bn>
			break;
 112099c:	17fffff8 	b	112097c <syscall_cryp_derive_key+0x83c>
			crypto_bignum_bin2bn(p->content.ref.buffer,
 11209a0:	b9401361 	ldr	w1, [x27, #16]
			found |= BIT(PEER_KEY_Y);
 11209a4:	321e035a 	orr	w26, w26, #0x4
			crypto_bignum_bin2bn(p->content.ref.buffer,
 11209a8:	f9400760 	ldr	x0, [x27, #8]
 11209ac:	f94063e2 	ldr	x2, [sp, #192]
 11209b0:	94003603 	bl	112e1bc <crypto_bignum_bin2bn>
			break;
 11209b4:	17fffff2 	b	112097c <syscall_cryp_derive_key+0x83c>
			crypto_bignum_bin2bn(p->content.ref.buffer,
 11209b8:	b9401361 	ldr	w1, [x27, #16]
			found |= BIT(PEER_EPH_KEY_Y);
 11209bc:	321c035a 	orr	w26, w26, #0x10
			crypto_bignum_bin2bn(p->content.ref.buffer,
 11209c0:	f9400760 	ldr	x0, [x27, #8]
 11209c4:	f94053e2 	ldr	x2, [sp, #160]
 11209c8:	940035fd 	bl	112e1bc <crypto_bignum_bin2bn>
			break;
 11209cc:	17ffffec 	b	112097c <syscall_cryp_derive_key+0x83c>
			kep_parms->initiator_id = p->content.ref.buffer;
 11209d0:	f9400760 	ldr	x0, [x27, #8]
 11209d4:	f9007be0 	str	x0, [sp, #240]
			kep_parms->initiator_id_len = p->content.ref.length;
 11209d8:	b9401360 	ldr	w0, [x27, #16]
			found |= BIT(INITIATOR_ID);
 11209dc:	321b035a 	orr	w26, w26, #0x20
			kep_parms->initiator_id_len = p->content.ref.length;
 11209e0:	f9007fe0 	str	x0, [sp, #248]
			break;
 11209e4:	17ffffe6 	b	112097c <syscall_cryp_derive_key+0x83c>
			kep_parms->conf_in = p->content.ref.buffer;
 11209e8:	f9400760 	ldr	x0, [x27, #8]
 11209ec:	f9008be0 	str	x0, [sp, #272]
			kep_parms->conf_in_len = p->content.ref.length;
 11209f0:	b9401360 	ldr	w0, [x27, #16]
 11209f4:	f9008fe0 	str	x0, [sp, #280]
			break;
 11209f8:	17ffffe1 	b	112097c <syscall_cryp_derive_key+0x83c>
			kep_parms->conf_out = p->content.ref.buffer;
 11209fc:	f9400760 	ldr	x0, [x27, #8]
 1120a00:	f90093e0 	str	x0, [sp, #288]
			kep_parms->conf_out_len = p->content.ref.length;
 1120a04:	b9401360 	ldr	w0, [x27, #16]
 1120a08:	f90097e0 	str	x0, [sp, #296]
			break;
 1120a0c:	17ffffdc 	b	112097c <syscall_cryp_derive_key+0x83c>
		res = TEE_ERROR_NOT_SUPPORTED;
 1120a10:	129ffeba 	mov	w26, #0xffff000a            	// #-65526
 1120a14:	17fffe40 	b	1120314 <syscall_cryp_derive_key+0x1d4>
		return TEE_ERROR_OVERFLOW;
 1120a18:	1299fe1a 	mov	w26, #0xffff300f            	// #-53233
 1120a1c:	17fffe40 	b	112031c <syscall_cryp_derive_key+0x1dc>
		return TEE_ERROR_OUT_OF_MEMORY;
 1120a20:	129ffe7a 	mov	w26, #0xffff000c            	// #-65524
 1120a24:	17fffe3e 	b	112031c <syscall_cryp_derive_key+0x1dc>

0000000001120a28 <syscall_cryp_random_number_generate>:
{
 1120a28:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1120a2c:	910003fd 	mov	x29, sp
 1120a30:	a90153f3 	stp	x19, x20, [sp, #16]
 1120a34:	aa0103f4 	mov	x20, x1
 1120a38:	aa0003f3 	mov	x19, x0
	struct ts_session *sess = ts_get_current_session();
 1120a3c:	97ffcfe9 	bl	11149e0 <ts_get_current_session>
	res = vm_check_access_rights(&to_user_ta_ctx(sess->ctx)->uctx,
 1120a40:	f9400800 	ldr	x0, [x0, #16]
 1120a44:	97fff5ec 	bl	111e1f4 <to_user_ta_ctx>
 1120a48:	91014000 	add	x0, x0, #0x50
 1120a4c:	aa1403e3 	mov	x3, x20
 1120a50:	aa1303e2 	mov	x2, x19
 1120a54:	52800041 	mov	w1, #0x2                   	// #2
 1120a58:	97ffe365 	bl	11197ec <vm_check_access_rights>
	if (res != TEE_SUCCESS)
 1120a5c:	350000c0 	cbnz	w0, 1120a74 <syscall_cryp_random_number_generate+0x4c>
	res = crypto_rng_read(buf, blen);
 1120a60:	aa1403e1 	mov	x1, x20
 1120a64:	aa1303e0 	mov	x0, x19
}
 1120a68:	a94153f3 	ldp	x19, x20, [sp, #16]
 1120a6c:	a8c27bfd 	ldp	x29, x30, [sp], #32
	res = crypto_rng_read(buf, blen);
 1120a70:	17ffbacf 	b	110f5ac <crypto_rng_read>
}
 1120a74:	a94153f3 	ldp	x19, x20, [sp, #16]
 1120a78:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1120a7c:	d65f03c0 	ret

0000000001120a80 <syscall_authenc_init>:
{
 1120a80:	d101c3ff 	sub	sp, sp, #0x70
 1120a84:	a9017bfd 	stp	x29, x30, [sp, #16]
 1120a88:	910043fd 	add	x29, sp, #0x10
 1120a8c:	a90253f3 	stp	x19, x20, [sp, #32]
 1120a90:	aa0103f4 	mov	x20, x1
 1120a94:	a9035bf5 	stp	x21, x22, [sp, #48]
 1120a98:	aa0203f5 	mov	x21, x2
 1120a9c:	aa0303f6 	mov	x22, x3
 1120aa0:	a90463f7 	stp	x23, x24, [sp, #64]
 1120aa4:	aa0403f7 	mov	x23, x4
 1120aa8:	aa0503f8 	mov	x24, x5
 1120aac:	f9002bf9 	str	x25, [sp, #80]
 1120ab0:	aa0003f9 	mov	x25, x0
	struct ts_session *sess = ts_get_current_session();
 1120ab4:	97ffcfcb 	bl	11149e0 <ts_get_current_session>
 1120ab8:	aa0003f3 	mov	x19, x0
	res = vm_check_access_rights(&to_user_ta_ctx(sess->ctx)->uctx,
 1120abc:	f9400800 	ldr	x0, [x0, #16]
	struct tee_obj *o = NULL;
 1120ac0:	a9067fff 	stp	xzr, xzr, [sp, #96]
	res = vm_check_access_rights(&to_user_ta_ctx(sess->ctx)->uctx,
 1120ac4:	97fff5cc 	bl	111e1f4 <to_user_ta_ctx>
 1120ac8:	91014000 	add	x0, x0, #0x50
 1120acc:	aa1503e3 	mov	x3, x21
 1120ad0:	aa1403e2 	mov	x2, x20
 1120ad4:	528000a1 	mov	w1, #0x5                   	// #5
 1120ad8:	97ffe345 	bl	11197ec <vm_check_access_rights>
	if (res != TEE_SUCCESS)
 1120adc:	35000460 	cbnz	w0, 1120b68 <syscall_authenc_init+0xe8>
	res = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);
 1120ae0:	2a1903e0 	mov	w0, w25
 1120ae4:	97ffd175 	bl	11150b8 <uref_to_vaddr>
 1120ae8:	aa0003e1 	mov	x1, x0
 1120aec:	910183e2 	add	x2, sp, #0x60
 1120af0:	f9400a60 	ldr	x0, [x19, #16]
 1120af4:	97fff607 	bl	111e310 <tee_svc_cryp_get_state.isra.0>
	if (res != TEE_SUCCESS)
 1120af8:	35000380 	cbnz	w0, 1120b68 <syscall_authenc_init+0xe8>
	res = tee_obj_get(to_user_ta_ctx(sess->ctx), cs->key1, &o);
 1120afc:	f9400a60 	ldr	x0, [x19, #16]
 1120b00:	97fff5bd 	bl	111e1f4 <to_user_ta_ctx>
 1120b04:	f94033e1 	ldr	x1, [sp, #96]
 1120b08:	9101a3e2 	add	x2, sp, #0x68
 1120b0c:	f9400c21 	ldr	x1, [x1, #24]
 1120b10:	9400151b 	bl	1125f7c <tee_obj_get>
	if (res != TEE_SUCCESS)
 1120b14:	350002a0 	cbnz	w0, 1120b68 <syscall_authenc_init+0xe8>
	if ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)
 1120b18:	f94037e1 	ldr	x1, [sp, #104]
 1120b1c:	b9402820 	ldr	w0, [x1, #40]
 1120b20:	36880320 	tbz	w0, #17, 1120b84 <syscall_authenc_init+0x104>
	res = crypto_authenc_init(cs->ctx, cs->mode, (uint8_t *)(key + 1),
 1120b24:	f9401c22 	ldr	x2, [x1, #56]
 1120b28:	aa1703e7 	mov	x7, x23
 1120b2c:	f94033e0 	ldr	x0, [sp, #96]
 1120b30:	aa1603e6 	mov	x6, x22
 1120b34:	b8408443 	ldr	w3, [x2], #8
 1120b38:	aa1503e5 	mov	x5, x21
 1120b3c:	f90003f8 	str	x24, [sp]
 1120b40:	aa1403e4 	mov	x4, x20
 1120b44:	b9401401 	ldr	w1, [x0, #20]
 1120b48:	f9401400 	ldr	x0, [x0, #40]
 1120b4c:	97ffb3c5 	bl	110da60 <crypto_authenc_init>
	if (res != TEE_SUCCESS)
 1120b50:	350000c0 	cbnz	w0, 1120b68 <syscall_authenc_init+0xe8>
	cs->ctx_finalize = crypto_authenc_final;
 1120b54:	f94033e2 	ldr	x2, [sp, #96]
 1120b58:	d00001c1 	adrp	x1, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1120b5c:	f941d021 	ldr	x1, [x1, #928]
 1120b60:	f9001841 	str	x1, [x2, #48]
	cs->state = CRYP_STATE_INITIALIZED;
 1120b64:	b900385f 	str	wzr, [x2, #56]
}
 1120b68:	a9417bfd 	ldp	x29, x30, [sp, #16]
 1120b6c:	a94253f3 	ldp	x19, x20, [sp, #32]
 1120b70:	a9435bf5 	ldp	x21, x22, [sp, #48]
 1120b74:	a94463f7 	ldp	x23, x24, [sp, #64]
 1120b78:	f9402bf9 	ldr	x25, [sp, #80]
 1120b7c:	9101c3ff 	add	sp, sp, #0x70
 1120b80:	d65f03c0 	ret
		return TEE_ERROR_BAD_PARAMETERS;
 1120b84:	129fff20 	mov	w0, #0xffff0006            	// #-65530
 1120b88:	17fffff8 	b	1120b68 <syscall_authenc_init+0xe8>

0000000001120b8c <syscall_authenc_update_aad>:
{
 1120b8c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 1120b90:	910003fd 	mov	x29, sp
 1120b94:	a90153f3 	stp	x19, x20, [sp, #16]
 1120b98:	aa0103f3 	mov	x19, x1
 1120b9c:	aa0203f4 	mov	x20, x2
 1120ba0:	a9025bf5 	stp	x21, x22, [sp, #32]
 1120ba4:	aa0003f6 	mov	x22, x0
	struct ts_session *sess = ts_get_current_session();
 1120ba8:	97ffcf8e 	bl	11149e0 <ts_get_current_session>
 1120bac:	aa0003f5 	mov	x21, x0
	struct tee_cryp_state *cs = NULL;
 1120bb0:	f9001fff 	str	xzr, [sp, #56]
	res = vm_check_access_rights(&to_user_ta_ctx(sess->ctx)->uctx,
 1120bb4:	f9400800 	ldr	x0, [x0, #16]
 1120bb8:	97fff58f 	bl	111e1f4 <to_user_ta_ctx>
 1120bbc:	91014000 	add	x0, x0, #0x50
 1120bc0:	aa1403e3 	mov	x3, x20
 1120bc4:	aa1303e2 	mov	x2, x19
 1120bc8:	528000a1 	mov	w1, #0x5                   	// #5
 1120bcc:	97ffe308 	bl	11197ec <vm_check_access_rights>
	if (res != TEE_SUCCESS)
 1120bd0:	35000280 	cbnz	w0, 1120c20 <syscall_authenc_update_aad+0x94>
	res = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);
 1120bd4:	2a1603e0 	mov	w0, w22
 1120bd8:	97ffd138 	bl	11150b8 <uref_to_vaddr>
 1120bdc:	aa0003e1 	mov	x1, x0
 1120be0:	9100e3e2 	add	x2, sp, #0x38
 1120be4:	f9400aa0 	ldr	x0, [x21, #16]
 1120be8:	97fff5ca 	bl	111e310 <tee_svc_cryp_get_state.isra.0>
	if (res != TEE_SUCCESS)
 1120bec:	350001a0 	cbnz	w0, 1120c20 <syscall_authenc_update_aad+0x94>
	if (cs->state != CRYP_STATE_INITIALIZED)
 1120bf0:	f9401fe4 	ldr	x4, [sp, #56]
 1120bf4:	b9403880 	ldr	w0, [x4, #56]
 1120bf8:	350001c0 	cbnz	w0, 1120c30 <syscall_authenc_update_aad+0xa4>
	if (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)
 1120bfc:	b9401080 	ldr	w0, [x4, #16]
 1120c00:	97fff1ed 	bl	111d3b4 <__tee_alg_get_class>
 1120c04:	7100101f 	cmp	w0, #0x4
 1120c08:	54000141 	b.ne	1120c30 <syscall_authenc_update_aad+0xa4>  // b.any
	res = crypto_authenc_update_aad(cs->ctx, cs->mode, aad_data,
 1120c0c:	b9401481 	ldr	w1, [x4, #20]
 1120c10:	aa1403e3 	mov	x3, x20
 1120c14:	f9401480 	ldr	x0, [x4, #40]
 1120c18:	aa1303e2 	mov	x2, x19
 1120c1c:	97ffb3b0 	bl	110dadc <crypto_authenc_update_aad>
}
 1120c20:	a94153f3 	ldp	x19, x20, [sp, #16]
 1120c24:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1120c28:	a8c47bfd 	ldp	x29, x30, [sp], #64
 1120c2c:	d65f03c0 	ret
		return TEE_ERROR_BAD_STATE;
 1120c30:	129fff00 	mov	w0, #0xffff0007            	// #-65529
 1120c34:	17fffffb 	b	1120c20 <syscall_authenc_update_aad+0x94>

0000000001120c38 <syscall_authenc_update_payload>:
{
 1120c38:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
 1120c3c:	910003fd 	mov	x29, sp
 1120c40:	a90153f3 	stp	x19, x20, [sp, #16]
 1120c44:	aa0003f3 	mov	x19, x0
 1120c48:	aa0203f4 	mov	x20, x2
 1120c4c:	a9025bf5 	stp	x21, x22, [sp, #32]
 1120c50:	aa0403f6 	mov	x22, x4
 1120c54:	a90363f7 	stp	x23, x24, [sp, #48]
 1120c58:	aa0103f7 	mov	x23, x1
 1120c5c:	aa0303f8 	mov	x24, x3
 1120c60:	f90023f9 	str	x25, [sp, #64]
	struct ts_session *sess = ts_get_current_session();
 1120c64:	97ffcf5f 	bl	11149e0 <ts_get_current_session>
 1120c68:	aa0003f5 	mov	x21, x0
	res = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);
 1120c6c:	2a1303e0 	mov	w0, w19
	size_t dlen = 0;
 1120c70:	a9057fff 	stp	xzr, xzr, [sp, #80]
	res = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);
 1120c74:	97ffd111 	bl	11150b8 <uref_to_vaddr>
 1120c78:	aa0003e1 	mov	x1, x0
 1120c7c:	f9400aa0 	ldr	x0, [x21, #16]
 1120c80:	910143e2 	add	x2, sp, #0x50
 1120c84:	97fff5a3 	bl	111e310 <tee_svc_cryp_get_state.isra.0>
 1120c88:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 1120c8c:	350006a0 	cbnz	w0, 1120d60 <syscall_authenc_update_payload+0x128>
	if (cs->state != CRYP_STATE_INITIALIZED)
 1120c90:	f9402be0 	ldr	x0, [sp, #80]
 1120c94:	b9403801 	ldr	w1, [x0, #56]
 1120c98:	35000761 	cbnz	w1, 1120d84 <syscall_authenc_update_payload+0x14c>
	if (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)
 1120c9c:	b9401000 	ldr	w0, [x0, #16]
 1120ca0:	97fff1c5 	bl	111d3b4 <__tee_alg_get_class>
 1120ca4:	7100101f 	cmp	w0, #0x4
 1120ca8:	540006e1 	b.ne	1120d84 <syscall_authenc_update_payload+0x14c>  // b.any
	res = vm_check_access_rights(&to_user_ta_ctx(sess->ctx)->uctx,
 1120cac:	f9400aa0 	ldr	x0, [x21, #16]
 1120cb0:	97fff551 	bl	111e1f4 <to_user_ta_ctx>
 1120cb4:	91014000 	add	x0, x0, #0x50
 1120cb8:	aa1403e3 	mov	x3, x20
 1120cbc:	aa1703e2 	mov	x2, x23
 1120cc0:	528000a1 	mov	w1, #0x5                   	// #5
 1120cc4:	97ffe2ca 	bl	11197ec <vm_check_access_rights>
 1120cc8:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 1120ccc:	350004a0 	cbnz	w0, 1120d60 <syscall_authenc_update_payload+0x128>
	res = get_user_u64_as_size_t(&dlen, dst_len);
 1120cd0:	910163f9 	add	x25, sp, #0x58
 1120cd4:	aa1603e1 	mov	x1, x22
 1120cd8:	aa1903e0 	mov	x0, x25
 1120cdc:	97fff38f 	bl	111db18 <get_user_u64_as_size_t>
 1120ce0:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 1120ce4:	350003e0 	cbnz	w0, 1120d60 <syscall_authenc_update_payload+0x128>
	res = vm_check_access_rights(&to_user_ta_ctx(sess->ctx)->uctx,
 1120ce8:	f9400aa0 	ldr	x0, [x21, #16]
 1120cec:	97fff542 	bl	111e1f4 <to_user_ta_ctx>
 1120cf0:	91014000 	add	x0, x0, #0x50
 1120cf4:	f9402fe3 	ldr	x3, [sp, #88]
 1120cf8:	aa1803e2 	mov	x2, x24
 1120cfc:	528000e1 	mov	w1, #0x7                   	// #7
 1120d00:	97ffe2bb 	bl	11197ec <vm_check_access_rights>
 1120d04:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 1120d08:	350002c0 	cbnz	w0, 1120d60 <syscall_authenc_update_payload+0x128>
	if (dlen < src_len) {
 1120d0c:	f9402fe0 	ldr	x0, [sp, #88]
 1120d10:	eb14001f 	cmp	x0, x20
 1120d14:	54000343 	b.cc	1120d7c <syscall_authenc_update_payload+0x144>  // b.lo, b.ul, b.last
	res = crypto_authenc_update_payload(cs->ctx, cs->mode, src_data,
 1120d18:	f9402be0 	ldr	x0, [sp, #80]
 1120d1c:	aa1903e5 	mov	x5, x25
 1120d20:	aa1803e4 	mov	x4, x24
 1120d24:	aa1403e3 	mov	x3, x20
 1120d28:	aa1703e2 	mov	x2, x23
 1120d2c:	b9401401 	ldr	w1, [x0, #20]
 1120d30:	f9401400 	ldr	x0, [x0, #40]
 1120d34:	97ffb37b 	bl	110db20 <crypto_authenc_update_payload>
 1120d38:	2a0003f3 	mov	w19, w0
	if (res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) {
 1120d3c:	7100027f 	cmp	w19, #0x0
 1120d40:	129ffde0 	mov	w0, #0xffff0010            	// #-65520
 1120d44:	7a401264 	ccmp	w19, w0, #0x4, ne  // ne = any
 1120d48:	540000c1 	b.ne	1120d60 <syscall_authenc_update_payload+0x128>  // b.any
		TEE_Result res2 = put_user_u64(dst_len, dlen);
 1120d4c:	f9402fe1 	ldr	x1, [sp, #88]
 1120d50:	aa1603e0 	mov	x0, x22
 1120d54:	97fff3b8 	bl	111dc34 <put_user_u64>
		if (res2 != TEE_SUCCESS)
 1120d58:	7100001f 	cmp	w0, #0x0
 1120d5c:	1a800273 	csel	w19, w19, w0, eq  // eq = none
}
 1120d60:	2a1303e0 	mov	w0, w19
 1120d64:	a94153f3 	ldp	x19, x20, [sp, #16]
 1120d68:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1120d6c:	a94363f7 	ldp	x23, x24, [sp, #48]
 1120d70:	f94023f9 	ldr	x25, [sp, #64]
 1120d74:	a8c67bfd 	ldp	x29, x30, [sp], #96
 1120d78:	d65f03c0 	ret
		res = TEE_ERROR_SHORT_BUFFER;
 1120d7c:	129ffdf3 	mov	w19, #0xffff0010            	// #-65520
 1120d80:	17ffffef 	b	1120d3c <syscall_authenc_update_payload+0x104>
		return TEE_ERROR_BAD_STATE;
 1120d84:	129fff13 	mov	w19, #0xffff0007            	// #-65529
 1120d88:	17fffff6 	b	1120d60 <syscall_authenc_update_payload+0x128>

0000000001120d8c <syscall_authenc_enc_final>:
{
 1120d8c:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
 1120d90:	910003fd 	mov	x29, sp
 1120d94:	a90153f3 	stp	x19, x20, [sp, #16]
 1120d98:	aa0403f4 	mov	x20, x4
 1120d9c:	a9025bf5 	stp	x21, x22, [sp, #32]
 1120da0:	aa0203f5 	mov	x21, x2
 1120da4:	aa0603f6 	mov	x22, x6
 1120da8:	a90363f7 	stp	x23, x24, [sp, #48]
 1120dac:	aa0103f7 	mov	x23, x1
 1120db0:	aa0303f8 	mov	x24, x3
 1120db4:	a9046bf9 	stp	x25, x26, [sp, #64]
 1120db8:	aa0503f9 	mov	x25, x5
 1120dbc:	f9002bfb 	str	x27, [sp, #80]
 1120dc0:	aa0003fb 	mov	x27, x0
	struct ts_session *sess = ts_get_current_session();
 1120dc4:	97ffcf07 	bl	11149e0 <ts_get_current_session>
 1120dc8:	aa0003f3 	mov	x19, x0
	struct user_mode_ctx *uctx = &to_user_ta_ctx(sess->ctx)->uctx;
 1120dcc:	f9400800 	ldr	x0, [x0, #16]
 1120dd0:	97fff509 	bl	111e1f4 <to_user_ta_ctx>
 1120dd4:	aa0003fa 	mov	x26, x0
	res = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);
 1120dd8:	2a1b03e0 	mov	w0, w27
	size_t dlen = 0;
 1120ddc:	a906ffff 	stp	xzr, xzr, [sp, #104]
	size_t tlen = 0;
 1120de0:	f9003fff 	str	xzr, [sp, #120]
	res = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);
 1120de4:	97ffd0b5 	bl	11150b8 <uref_to_vaddr>
 1120de8:	aa0003e1 	mov	x1, x0
 1120dec:	9101a3e2 	add	x2, sp, #0x68
 1120df0:	f9400a60 	ldr	x0, [x19, #16]
 1120df4:	97fff547 	bl	111e310 <tee_svc_cryp_get_state.isra.0>
 1120df8:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 1120dfc:	350008a0 	cbnz	w0, 1120f10 <syscall_authenc_enc_final+0x184>
	if (cs->state != CRYP_STATE_INITIALIZED)
 1120e00:	f94037e0 	ldr	x0, [sp, #104]
 1120e04:	b9403801 	ldr	w1, [x0, #56]
 1120e08:	35000a81 	cbnz	w1, 1120f58 <syscall_authenc_enc_final+0x1cc>
	if (cs->mode != TEE_MODE_ENCRYPT)
 1120e0c:	b9401401 	ldr	w1, [x0, #20]
 1120e10:	35000a01 	cbnz	w1, 1120f50 <syscall_authenc_enc_final+0x1c4>
	if (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)
 1120e14:	b9401000 	ldr	w0, [x0, #16]
 1120e18:	97fff167 	bl	111d3b4 <__tee_alg_get_class>
 1120e1c:	7100101f 	cmp	w0, #0x4
 1120e20:	540009c1 	b.ne	1120f58 <syscall_authenc_enc_final+0x1cc>  // b.any
	struct user_mode_ctx *uctx = &to_user_ta_ctx(sess->ctx)->uctx;
 1120e24:	9101435a 	add	x26, x26, #0x50
	res = vm_check_access_rights(uctx,
 1120e28:	aa1503e3 	mov	x3, x21
 1120e2c:	aa1703e2 	mov	x2, x23
 1120e30:	aa1a03e0 	mov	x0, x26
 1120e34:	528000a1 	mov	w1, #0x5                   	// #5
 1120e38:	97ffe26d 	bl	11197ec <vm_check_access_rights>
 1120e3c:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 1120e40:	35000680 	cbnz	w0, 1120f10 <syscall_authenc_enc_final+0x184>
	if (!dst_len) {
 1120e44:	b50004f4 	cbnz	x20, 1120ee0 <syscall_authenc_enc_final+0x154>
		dlen = 0;
 1120e48:	f9003bff 	str	xzr, [sp, #112]
	if (dlen < src_len) {
 1120e4c:	f9403be0 	ldr	x0, [sp, #112]
 1120e50:	eb15001f 	cmp	x0, x21
 1120e54:	540006e3 	b.cc	1120f30 <syscall_authenc_enc_final+0x1a4>  // b.lo, b.ul, b.last
	res = get_user_u64_as_size_t(&tlen, tag_len);
 1120e58:	9101e3fb 	add	x27, sp, #0x78
 1120e5c:	aa1603e1 	mov	x1, x22
 1120e60:	aa1b03e0 	mov	x0, x27
 1120e64:	97fff32d 	bl	111db18 <get_user_u64_as_size_t>
 1120e68:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 1120e6c:	35000520 	cbnz	w0, 1120f10 <syscall_authenc_enc_final+0x184>
	res = vm_check_access_rights(uctx,
 1120e70:	f9403fe3 	ldr	x3, [sp, #120]
 1120e74:	aa1903e2 	mov	x2, x25
 1120e78:	aa1a03e0 	mov	x0, x26
 1120e7c:	528000e1 	mov	w1, #0x7                   	// #7
 1120e80:	97ffe25b 	bl	11197ec <vm_check_access_rights>
 1120e84:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 1120e88:	35000440 	cbnz	w0, 1120f10 <syscall_authenc_enc_final+0x184>
	res = crypto_authenc_enc_final(cs->ctx, src_data, src_len, dst_data,
 1120e8c:	f94037e0 	ldr	x0, [sp, #104]
 1120e90:	aa1b03e6 	mov	x6, x27
 1120e94:	aa1903e5 	mov	x5, x25
 1120e98:	9101c3e4 	add	x4, sp, #0x70
 1120e9c:	aa1803e3 	mov	x3, x24
 1120ea0:	aa1503e2 	mov	x2, x21
 1120ea4:	f9401400 	ldr	x0, [x0, #40]
 1120ea8:	aa1703e1 	mov	x1, x23
 1120eac:	97ffb33e 	bl	110dba4 <crypto_authenc_enc_final>
 1120eb0:	2a0003f3 	mov	w19, w0
	if (res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) {
 1120eb4:	7100027f 	cmp	w19, #0x0
 1120eb8:	129ffde0 	mov	w0, #0xffff0010            	// #-65520
 1120ebc:	7a401264 	ccmp	w19, w0, #0x4, ne  // ne = any
 1120ec0:	54000281 	b.ne	1120f10 <syscall_authenc_enc_final+0x184>  // b.any
		if (dst_len != NULL) {
 1120ec4:	b50003b4 	cbnz	x20, 1120f38 <syscall_authenc_enc_final+0x1ac>
		res2 = put_user_u64(tag_len, tlen);
 1120ec8:	f9403fe1 	ldr	x1, [sp, #120]
 1120ecc:	aa1603e0 	mov	x0, x22
 1120ed0:	97fff359 	bl	111dc34 <put_user_u64>
		if (res2 != TEE_SUCCESS)
 1120ed4:	7100001f 	cmp	w0, #0x0
 1120ed8:	1a800273 	csel	w19, w19, w0, eq  // eq = none
 1120edc:	1400000d 	b	1120f10 <syscall_authenc_enc_final+0x184>
		res = get_user_u64_as_size_t(&dlen, dst_len);
 1120ee0:	aa1403e1 	mov	x1, x20
 1120ee4:	9101c3e0 	add	x0, sp, #0x70
 1120ee8:	97fff30c 	bl	111db18 <get_user_u64_as_size_t>
 1120eec:	2a0003f3 	mov	w19, w0
		if (res != TEE_SUCCESS)
 1120ef0:	35000100 	cbnz	w0, 1120f10 <syscall_authenc_enc_final+0x184>
		res = vm_check_access_rights(uctx,
 1120ef4:	f9403be3 	ldr	x3, [sp, #112]
 1120ef8:	aa1803e2 	mov	x2, x24
 1120efc:	aa1a03e0 	mov	x0, x26
 1120f00:	528000e1 	mov	w1, #0x7                   	// #7
 1120f04:	97ffe23a 	bl	11197ec <vm_check_access_rights>
 1120f08:	2a0003f3 	mov	w19, w0
		if (res != TEE_SUCCESS)
 1120f0c:	34fffa00 	cbz	w0, 1120e4c <syscall_authenc_enc_final+0xc0>
}
 1120f10:	2a1303e0 	mov	w0, w19
 1120f14:	a94153f3 	ldp	x19, x20, [sp, #16]
 1120f18:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1120f1c:	a94363f7 	ldp	x23, x24, [sp, #48]
 1120f20:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1120f24:	f9402bfb 	ldr	x27, [sp, #80]
 1120f28:	a8c87bfd 	ldp	x29, x30, [sp], #128
 1120f2c:	d65f03c0 	ret
		res = TEE_ERROR_SHORT_BUFFER;
 1120f30:	129ffdf3 	mov	w19, #0xffff0010            	// #-65520
 1120f34:	17ffffe0 	b	1120eb4 <syscall_authenc_enc_final+0x128>
			res2 = put_user_u64(dst_len, dlen);
 1120f38:	f9403be1 	ldr	x1, [sp, #112]
 1120f3c:	aa1403e0 	mov	x0, x20
 1120f40:	97fff33d 	bl	111dc34 <put_user_u64>
			if (res2 != TEE_SUCCESS)
 1120f44:	34fffc20 	cbz	w0, 1120ec8 <syscall_authenc_enc_final+0x13c>
 1120f48:	2a0003f3 	mov	w19, w0
 1120f4c:	17fffff1 	b	1120f10 <syscall_authenc_enc_final+0x184>
		return TEE_ERROR_BAD_PARAMETERS;
 1120f50:	129fff33 	mov	w19, #0xffff0006            	// #-65530
 1120f54:	17ffffef 	b	1120f10 <syscall_authenc_enc_final+0x184>
		return TEE_ERROR_BAD_STATE;
 1120f58:	129fff13 	mov	w19, #0xffff0007            	// #-65529
 1120f5c:	17ffffed 	b	1120f10 <syscall_authenc_enc_final+0x184>

0000000001120f60 <syscall_authenc_dec_final>:
{
 1120f60:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
 1120f64:	910003fd 	mov	x29, sp
 1120f68:	a90153f3 	stp	x19, x20, [sp, #16]
 1120f6c:	aa0403f4 	mov	x20, x4
 1120f70:	a9025bf5 	stp	x21, x22, [sp, #32]
 1120f74:	aa0103f6 	mov	x22, x1
 1120f78:	aa0203f5 	mov	x21, x2
 1120f7c:	a90363f7 	stp	x23, x24, [sp, #48]
 1120f80:	aa0303f7 	mov	x23, x3
 1120f84:	aa0503f8 	mov	x24, x5
 1120f88:	a9046bf9 	stp	x25, x26, [sp, #64]
 1120f8c:	aa0603f9 	mov	x25, x6
 1120f90:	f9002bfb 	str	x27, [sp, #80]
 1120f94:	aa0003fb 	mov	x27, x0
	struct ts_session *sess = ts_get_current_session();
 1120f98:	97ffce92 	bl	11149e0 <ts_get_current_session>
 1120f9c:	aa0003f3 	mov	x19, x0
	struct user_mode_ctx *uctx = &to_user_ta_ctx(sess->ctx)->uctx;
 1120fa0:	f9400800 	ldr	x0, [x0, #16]
 1120fa4:	97fff494 	bl	111e1f4 <to_user_ta_ctx>
 1120fa8:	aa0003fa 	mov	x26, x0
	res = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);
 1120fac:	2a1b03e0 	mov	w0, w27
	size_t dlen = 0;
 1120fb0:	a9067fff 	stp	xzr, xzr, [sp, #96]
	res = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);
 1120fb4:	97ffd041 	bl	11150b8 <uref_to_vaddr>
 1120fb8:	aa0003e1 	mov	x1, x0
 1120fbc:	910183e2 	add	x2, sp, #0x60
 1120fc0:	f9400a60 	ldr	x0, [x19, #16]
 1120fc4:	97fff4d3 	bl	111e310 <tee_svc_cryp_get_state.isra.0>
 1120fc8:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 1120fcc:	35000800 	cbnz	w0, 11210cc <syscall_authenc_dec_final+0x16c>
	if (cs->state != CRYP_STATE_INITIALIZED)
 1120fd0:	f94033e0 	ldr	x0, [sp, #96]
 1120fd4:	b9403801 	ldr	w1, [x0, #56]
 1120fd8:	35000921 	cbnz	w1, 11210fc <syscall_authenc_dec_final+0x19c>
	if (cs->mode != TEE_MODE_DECRYPT)
 1120fdc:	b9401401 	ldr	w1, [x0, #20]
 1120fe0:	7100043f 	cmp	w1, #0x1
 1120fe4:	54000881 	b.ne	11210f4 <syscall_authenc_dec_final+0x194>  // b.any
	if (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)
 1120fe8:	b9401000 	ldr	w0, [x0, #16]
 1120fec:	97fff0f2 	bl	111d3b4 <__tee_alg_get_class>
 1120ff0:	7100101f 	cmp	w0, #0x4
 1120ff4:	54000841 	b.ne	11210fc <syscall_authenc_dec_final+0x19c>  // b.any
	struct user_mode_ctx *uctx = &to_user_ta_ctx(sess->ctx)->uctx;
 1120ff8:	9101435a 	add	x26, x26, #0x50
	res = vm_check_access_rights(uctx,
 1120ffc:	aa1503e3 	mov	x3, x21
 1121000:	aa1603e2 	mov	x2, x22
 1121004:	aa1a03e0 	mov	x0, x26
 1121008:	528000a1 	mov	w1, #0x5                   	// #5
 112100c:	97ffe1f8 	bl	11197ec <vm_check_access_rights>
 1121010:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 1121014:	350005c0 	cbnz	w0, 11210cc <syscall_authenc_dec_final+0x16c>
	if (!dst_len) {
 1121018:	b5000434 	cbnz	x20, 112109c <syscall_authenc_dec_final+0x13c>
		dlen = 0;
 112101c:	f90037ff 	str	xzr, [sp, #104]
	if (dlen < src_len) {
 1121020:	f94037e0 	ldr	x0, [sp, #104]
 1121024:	eb15001f 	cmp	x0, x21
 1121028:	54000623 	b.cc	11210ec <syscall_authenc_dec_final+0x18c>  // b.lo, b.ul, b.last
	res = vm_check_access_rights(uctx, TEE_MEMORY_ACCESS_READ,
 112102c:	aa1903e3 	mov	x3, x25
 1121030:	aa1803e2 	mov	x2, x24
 1121034:	aa1a03e0 	mov	x0, x26
 1121038:	52800021 	mov	w1, #0x1                   	// #1
 112103c:	97ffe1ec 	bl	11197ec <vm_check_access_rights>
 1121040:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 1121044:	35000440 	cbnz	w0, 11210cc <syscall_authenc_dec_final+0x16c>
	res = crypto_authenc_dec_final(cs->ctx, src_data, src_len, dst_data,
 1121048:	f94033e0 	ldr	x0, [sp, #96]
 112104c:	aa1903e6 	mov	x6, x25
 1121050:	aa1803e5 	mov	x5, x24
 1121054:	9101a3e4 	add	x4, sp, #0x68
 1121058:	aa1703e3 	mov	x3, x23
 112105c:	aa1503e2 	mov	x2, x21
 1121060:	f9401400 	ldr	x0, [x0, #40]
 1121064:	aa1603e1 	mov	x1, x22
 1121068:	97ffb2f2 	bl	110dc30 <crypto_authenc_dec_final>
 112106c:	2a0003f3 	mov	w19, w0
	if ((res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) &&
 1121070:	7100027f 	cmp	w19, #0x0
 1121074:	129ffde0 	mov	w0, #0xffff0010            	// #-65520
 1121078:	7a401264 	ccmp	w19, w0, #0x4, ne  // ne = any
 112107c:	54000281 	b.ne	11210cc <syscall_authenc_dec_final+0x16c>  // b.any
 1121080:	b4000274 	cbz	x20, 11210cc <syscall_authenc_dec_final+0x16c>
		TEE_Result res2 = put_user_u64(dst_len, dlen);
 1121084:	f94037e1 	ldr	x1, [sp, #104]
 1121088:	aa1403e0 	mov	x0, x20
 112108c:	97fff2ea 	bl	111dc34 <put_user_u64>
		if (res2 != TEE_SUCCESS)
 1121090:	7100001f 	cmp	w0, #0x0
 1121094:	1a800273 	csel	w19, w19, w0, eq  // eq = none
 1121098:	1400000d 	b	11210cc <syscall_authenc_dec_final+0x16c>
		res = get_user_u64_as_size_t(&dlen, dst_len);
 112109c:	aa1403e1 	mov	x1, x20
 11210a0:	9101a3e0 	add	x0, sp, #0x68
 11210a4:	97fff29d 	bl	111db18 <get_user_u64_as_size_t>
 11210a8:	2a0003f3 	mov	w19, w0
		if (res != TEE_SUCCESS)
 11210ac:	35000100 	cbnz	w0, 11210cc <syscall_authenc_dec_final+0x16c>
		res = vm_check_access_rights(uctx,
 11210b0:	f94037e3 	ldr	x3, [sp, #104]
 11210b4:	aa1703e2 	mov	x2, x23
 11210b8:	aa1a03e0 	mov	x0, x26
 11210bc:	528000e1 	mov	w1, #0x7                   	// #7
 11210c0:	97ffe1cb 	bl	11197ec <vm_check_access_rights>
 11210c4:	2a0003f3 	mov	w19, w0
		if (res != TEE_SUCCESS)
 11210c8:	34fffac0 	cbz	w0, 1121020 <syscall_authenc_dec_final+0xc0>
}
 11210cc:	2a1303e0 	mov	w0, w19
 11210d0:	a94153f3 	ldp	x19, x20, [sp, #16]
 11210d4:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11210d8:	a94363f7 	ldp	x23, x24, [sp, #48]
 11210dc:	a9446bf9 	ldp	x25, x26, [sp, #64]
 11210e0:	f9402bfb 	ldr	x27, [sp, #80]
 11210e4:	a8c77bfd 	ldp	x29, x30, [sp], #112
 11210e8:	d65f03c0 	ret
		res = TEE_ERROR_SHORT_BUFFER;
 11210ec:	129ffdf3 	mov	w19, #0xffff0010            	// #-65520
 11210f0:	17ffffe0 	b	1121070 <syscall_authenc_dec_final+0x110>
		return TEE_ERROR_BAD_PARAMETERS;
 11210f4:	129fff33 	mov	w19, #0xffff0006            	// #-65530
 11210f8:	17fffff5 	b	11210cc <syscall_authenc_dec_final+0x16c>
		return TEE_ERROR_BAD_STATE;
 11210fc:	129fff13 	mov	w19, #0xffff0007            	// #-65529
 1121100:	17fffff3 	b	11210cc <syscall_authenc_dec_final+0x16c>

0000000001121104 <syscall_asymm_operate>:

TEE_Result syscall_asymm_operate(unsigned long state,
			const struct utee_attribute *usr_params,
			size_t num_params, const void *src_data, size_t src_len,
			void *dst_data, uint64_t *dst_len)
{
 1121104:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
 1121108:	910003fd 	mov	x29, sp
 112110c:	a90153f3 	stp	x19, x20, [sp, #16]
 1121110:	aa0603f4 	mov	x20, x6
 1121114:	a9025bf5 	stp	x21, x22, [sp, #32]
 1121118:	aa0203f6 	mov	x22, x2
 112111c:	aa0003f5 	mov	x21, x0
 1121120:	a90363f7 	stp	x23, x24, [sp, #48]
 1121124:	a9046bf9 	stp	x25, x26, [sp, #64]
 1121128:	aa0403fa 	mov	x26, x4
 112112c:	a90573fb 	stp	x27, x28, [sp, #80]
 1121130:	aa0303fb 	mov	x27, x3
 1121134:	aa0503fc 	mov	x28, x5
 1121138:	f90037e1 	str	x1, [sp, #104]
	struct ts_session *sess = ts_get_current_session();
 112113c:	97ffce29 	bl	11149e0 <ts_get_current_session>
 1121140:	aa0003f3 	mov	x19, x0
	struct user_ta_ctx *utc = to_user_ta_ctx(sess->ctx);
 1121144:	f9400800 	ldr	x0, [x0, #16]
 1121148:	97fff42b 	bl	111e1f4 <to_user_ta_ctx>
 112114c:	aa0003f7 	mov	x23, x0
	size_t label_len = 0;
	size_t n = 0;
	int salt_len = 0;
	TEE_Attribute *params = NULL;

	res = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);
 1121150:	2a1503e0 	mov	w0, w21
	size_t dlen = 0;
 1121154:	a907ffff 	stp	xzr, xzr, [sp, #120]
	struct tee_obj *o = NULL;
 1121158:	f90047ff 	str	xzr, [sp, #136]
	res = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);
 112115c:	97ffcfd7 	bl	11150b8 <uref_to_vaddr>
 1121160:	aa0003e1 	mov	x1, x0
 1121164:	9101e3e2 	add	x2, sp, #0x78
 1121168:	f9400a60 	ldr	x0, [x19, #16]
 112116c:	97fff469 	bl	111e310 <tee_svc_cryp_get_state.isra.0>
 1121170:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 1121174:	35001b40 	cbnz	w0, 11214dc <syscall_asymm_operate+0x3d8>
		return res;

	res = vm_check_access_rights(&utc->uctx,
 1121178:	910142f5 	add	x21, x23, #0x50
 112117c:	aa1a03e3 	mov	x3, x26
 1121180:	aa1b03e2 	mov	x2, x27
 1121184:	aa1503e0 	mov	x0, x21
 1121188:	528000a1 	mov	w1, #0x5                   	// #5
 112118c:	97ffe198 	bl	11197ec <vm_check_access_rights>
 1121190:	2a0003f3 	mov	w19, w0
				     TEE_MEMORY_ACCESS_READ |
				     TEE_MEMORY_ACCESS_ANY_OWNER,
				     (uaddr_t)src_data, src_len);
	if (res != TEE_SUCCESS)
 1121194:	35001a40 	cbnz	w0, 11214dc <syscall_asymm_operate+0x3d8>
		return res;

	res = get_user_u64_as_size_t(&dlen, dst_len);
 1121198:	910203f8 	add	x24, sp, #0x80
 112119c:	aa1403e1 	mov	x1, x20
 11211a0:	aa1803e0 	mov	x0, x24
 11211a4:	97fff25d 	bl	111db18 <get_user_u64_as_size_t>
 11211a8:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 11211ac:	35001980 	cbnz	w0, 11214dc <syscall_asymm_operate+0x3d8>
		return res;

	res = vm_check_access_rights(&utc->uctx,
 11211b0:	f94043e3 	ldr	x3, [sp, #128]
 11211b4:	aa1c03e2 	mov	x2, x28
 11211b8:	aa1503e0 	mov	x0, x21
 11211bc:	528000e1 	mov	w1, #0x7                   	// #7
 11211c0:	97ffe18b 	bl	11197ec <vm_check_access_rights>
 11211c4:	2a0003f3 	mov	w19, w0
				     TEE_MEMORY_ACCESS_READ |
				     TEE_MEMORY_ACCESS_WRITE |
				     TEE_MEMORY_ACCESS_ANY_OWNER,
				     (uaddr_t)dst_data, dlen);
	if (res != TEE_SUCCESS)
 11211c8:	350018a0 	cbnz	w0, 11214dc <syscall_asymm_operate+0x3d8>
		return res;

	size_t alloc_size = 0;

	if (MUL_OVERFLOW(sizeof(TEE_Attribute), num_params, &alloc_size))
 11211cc:	d2800301 	mov	x1, #0x18                  	// #24
 11211d0:	9b017ec0 	mul	x0, x22, x1
 11211d4:	9bc17ec1 	umulh	x1, x22, x1
 11211d8:	f100003f 	cmp	x1, #0x0
 11211dc:	9a9f07f9 	cset	x25, ne  // ne = any
 11211e0:	54002141 	b.ne	1121608 <syscall_asymm_operate+0x504>  // b.any
		return TEE_ERROR_OVERFLOW;

	params = malloc(alloc_size);
 11211e4:	9400889d 	bl	1143458 <malloc>
 11211e8:	aa0003f5 	mov	x21, x0
	if (!params)
 11211ec:	b4002120 	cbz	x0, 1121610 <syscall_asymm_operate+0x50c>
		return TEE_ERROR_OUT_OF_MEMORY;
	res = copy_in_attrs(utc, usr_params, num_params, params);
 11211f0:	f94037e1 	ldr	x1, [sp, #104]
 11211f4:	aa0003e3 	mov	x3, x0
 11211f8:	2a1603e2 	mov	w2, w22
 11211fc:	aa1703e0 	mov	x0, x23
 1121200:	97fff2f6 	bl	111ddd8 <copy_in_attrs>
 1121204:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 1121208:	35001540 	cbnz	w0, 11214b0 <syscall_asymm_operate+0x3ac>
		goto out;

	res = tee_obj_get(utc, cs->key1, &o);
 112120c:	f9403fe0 	ldr	x0, [sp, #120]
 1121210:	910223e2 	add	x2, sp, #0x88
 1121214:	f9400c01 	ldr	x1, [x0, #24]
 1121218:	aa1703e0 	mov	x0, x23
 112121c:	94001358 	bl	1125f7c <tee_obj_get>
 1121220:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 1121224:	35001460 	cbnz	w0, 11214b0 <syscall_asymm_operate+0x3ac>
		goto out;
	if ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0) {
 1121228:	f94047f7 	ldr	x23, [sp, #136]
 112122c:	b9402ae0 	ldr	w0, [x23, #40]
 1121230:	36881e80 	tbz	w0, #17, 1121600 <syscall_asymm_operate+0x4fc>
		res = TEE_ERROR_GENERIC;
		goto out;
	}

	switch (cs->algo) {
 1121234:	f9403fe0 	ldr	x0, [sp, #120]
 1121238:	52862621 	mov	w1, #0x3131                	// #12593
 112123c:	72ae0001 	movk	w1, #0x7000, lsl #16
 1121240:	b9401013 	ldr	w19, [x0, #16]
 1121244:	6b01027f 	cmp	w19, w1
 1121248:	54001cc0 	b.eq	11215e0 <syscall_asymm_operate+0x4dc>  // b.none
 112124c:	54000a88 	b.hi	112139c <syscall_asymm_operate+0x298>  // b.pmore
 1121250:	52804601 	mov	w1, #0x230                 	// #560
 1121254:	72ac0621 	movk	w1, #0x6031, lsl #16
 1121258:	6b01027f 	cmp	w19, w1
 112125c:	54001080 	b.eq	112146c <syscall_asymm_operate+0x368>  // b.none
 1121260:	54000248 	b.hi	11212a8 <syscall_asymm_operate+0x1a4>  // b.pmore
 1121264:	52800601 	mov	w1, #0x30                  	// #48
 1121268:	72ac0001 	movk	w1, #0x6000, lsl #16
 112126c:	6b01027f 	cmp	w19, w1
 1121270:	540010e0 	b.eq	112148c <syscall_asymm_operate+0x388>  // b.none
 1121274:	528005e1 	mov	w1, #0x2f                  	// #47
 1121278:	72ac0001 	movk	w1, #0x6000, lsl #16
 112127c:	6b01027f 	cmp	w19, w1
 1121280:	54000109 	b.ls	11212a0 <syscall_asymm_operate+0x19c>  // b.plast
 1121284:	11040421 	add	w1, w1, #0x101
 1121288:	6b01027f 	cmp	w19, w1
 112128c:	54000f00 	b.eq	112146c <syscall_asymm_operate+0x368>  // b.none
 1121290:	52804601 	mov	w1, #0x230                 	// #560
 1121294:	72ac0421 	movk	w1, #0x6021, lsl #16
 1121298:	6b01027f 	cmp	w19, w1
 112129c:	54000e80 	b.eq	112146c <syscall_asymm_operate+0x368>  // b.none
		} else if (cs->mode == TEE_MODE_DECRYPT) {
			res = crypto_acipher_rsaes_decrypt(
					cs->algo, o->attr, label, label_len,
					src_data, src_len, dst_data, &dlen);
		} else {
			res = TEE_ERROR_BAD_PARAMETERS;
 11212a0:	129fff33 	mov	w19, #0xffff0006            	// #-65530
 11212a4:	14000083 	b	11214b0 <syscall_asymm_operate+0x3ac>
	switch (cs->algo) {
 11212a8:	52840821 	mov	w1, #0x2041                	// #8257
 11212ac:	72ae0001 	movk	w1, #0x7000, lsl #16
 11212b0:	6b01027f 	cmp	w19, w1
 11212b4:	54000640 	b.eq	112137c <syscall_asymm_operate+0x278>  // b.none
 11212b8:	54000448 	b.hi	1121340 <syscall_asymm_operate+0x23c>  // b.pmore
 11212bc:	52804601 	mov	w1, #0x230                 	// #560
 11212c0:	72ac0c21 	movk	w1, #0x6061, lsl #16
 11212c4:	6b01027f 	cmp	w19, w1
 11212c8:	54000d20 	b.eq	112146c <syscall_asymm_operate+0x368>  // b.none
 11212cc:	540000c8 	b.hi	11212e4 <syscall_asymm_operate+0x1e0>  // b.pmore
 11212d0:	120b7a62 	and	w2, w19, #0xffefffff
 11212d4:	52804601 	mov	w1, #0x230                 	// #560
 11212d8:	72ac0821 	movk	w1, #0x6041, lsl #16
 11212dc:	6b01005f 	cmp	w2, w1
 11212e0:	17ffffef 	b	112129c <syscall_asymm_operate+0x198>
 11212e4:	52820821 	mov	w1, #0x1041                	// #4161
 11212e8:	72ae0001 	movk	w1, #0x7000, lsl #16
 11212ec:	6b01027f 	cmp	w19, w1
 11212f0:	54000460 	b.eq	112137c <syscall_asymm_operate+0x278>  // b.none
 11212f4:	111fbc21 	add	w1, w1, #0x7ef
 11212f8:	6b01027f 	cmp	w19, w1
 11212fc:	54fffd21 	b.ne	11212a0 <syscall_asymm_operate+0x19c>  // b.any
	case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1:
	case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224:
	case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256:
	case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384:
	case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512:
		if (cs->mode != TEE_MODE_SIGN) {
 1121300:	b9401400 	ldr	w0, [x0, #20]
 1121304:	7100081f 	cmp	w0, #0x2
 1121308:	54fffcc1 	b.ne	11212a0 <syscall_asymm_operate+0x19c>  // b.any
			res = TEE_ERROR_BAD_PARAMETERS;
			break;
		}
		salt_len = pkcs1_get_salt_len(params, num_params, src_len);
 112130c:	aa1a03e2 	mov	x2, x26
 1121310:	2a1603e1 	mov	w1, w22
 1121314:	aa1503e0 	mov	x0, x21
 1121318:	97fff473 	bl	111e4e4 <pkcs1_get_salt_len>
		res = crypto_acipher_rsassa_sign(cs->algo, o->attr, salt_len,
 112131c:	f9401ee1 	ldr	x1, [x23, #56]
 1121320:	2a0003e2 	mov	w2, w0
 1121324:	aa1803e6 	mov	x6, x24
 1121328:	aa1c03e5 	mov	x5, x28
 112132c:	aa1a03e4 	mov	x4, x26
 1121330:	aa1b03e3 	mov	x3, x27
 1121334:	2a1303e0 	mov	w0, w19
 1121338:	940027fd 	bl	112b32c <crypto_acipher_rsassa_sign>
 112133c:	1400005c 	b	11214ac <syscall_asymm_operate+0x3a8>
	switch (cs->algo) {
 1121340:	52842621 	mov	w1, #0x2131                	// #8497
 1121344:	72ae0001 	movk	w1, #0x7000, lsl #16
 1121348:	6b01027f 	cmp	w19, w1
 112134c:	540014a0 	b.eq	11215e0 <syscall_asymm_operate+0x4dc>  // b.none
 1121350:	52842601 	mov	w1, #0x2130                	// #8496
 1121354:	72ae0001 	movk	w1, #0x7000, lsl #16
 1121358:	6b01027f 	cmp	w19, w1
 112135c:	54fffa29 	b.ls	11212a0 <syscall_asymm_operate+0x19c>  // b.plast
 1121360:	111c0021 	add	w1, w1, #0x700
 1121364:	6b01027f 	cmp	w19, w1
 1121368:	54fffcc0 	b.eq	1121300 <syscall_asymm_operate+0x1fc>  // b.none
 112136c:	52860820 	mov	w0, #0x3041                	// #12353
 1121370:	72ae0000 	movk	w0, #0x7000, lsl #16
 1121374:	6b00027f 	cmp	w19, w0
 1121378:	54fff941 	b.ne	11212a0 <syscall_asymm_operate+0x19c>  // b.any
	case TEE_ALG_ECDSA_P224:
	case TEE_ALG_ECDSA_P256:
	case TEE_ALG_ECDSA_P384:
	case TEE_ALG_ECDSA_P521:
	case TEE_ALG_SM2_DSA_SM3:
		res = crypto_acipher_ecc_sign(cs->algo, o->attr, src_data,
 112137c:	f9401ee1 	ldr	x1, [x23, #56]
 1121380:	aa1803e5 	mov	x5, x24
 1121384:	aa1c03e4 	mov	x4, x28
 1121388:	aa1a03e3 	mov	x3, x26
 112138c:	aa1b03e2 	mov	x2, x27
 1121390:	2a1303e0 	mov	w0, w19
 1121394:	97ffb293 	bl	110dde0 <crypto_acipher_ecc_sign>
 1121398:	14000045 	b	11214ac <syscall_asymm_operate+0x3a8>
	switch (cs->algo) {
 112139c:	52892601 	mov	w1, #0x4930                	// #18736
 11213a0:	72ae0821 	movk	w1, #0x7041, lsl #16
 11213a4:	6b01027f 	cmp	w19, w1
 11213a8:	54fffac0 	b.eq	1121300 <syscall_asymm_operate+0x1fc>  // b.none
 11213ac:	540004a8 	b.hi	1121440 <syscall_asymm_operate+0x33c>  // b.pmore
 11213b0:	528a0821 	mov	w1, #0x5041                	// #20545
 11213b4:	72ae0001 	movk	w1, #0x7000, lsl #16
 11213b8:	6b01027f 	cmp	w19, w1
 11213bc:	54fffe00 	b.eq	112137c <syscall_asymm_operate+0x278>  // b.none
 11213c0:	540001e8 	b.hi	11213fc <syscall_asymm_operate+0x2f8>  // b.pmore
 11213c4:	52882621 	mov	w1, #0x4131                	// #16689
 11213c8:	72ae0001 	movk	w1, #0x7000, lsl #16
 11213cc:	6b01027f 	cmp	w19, w1
 11213d0:	54001080 	b.eq	11215e0 <syscall_asymm_operate+0x4dc>  // b.none
 11213d4:	540000e8 	b.hi	11213f0 <syscall_asymm_operate+0x2ec>  // b.pmore
 11213d8:	52870601 	mov	w1, #0x3830                	// #14384
 11213dc:	72ae0001 	movk	w1, #0x7000, lsl #16
 11213e0:	6b01027f 	cmp	w19, w1
 11213e4:	54fff8e0 	b.eq	1121300 <syscall_asymm_operate+0x1fc>  // b.none
 11213e8:	52880820 	mov	w0, #0x4041                	// #16449
 11213ec:	17ffffe1 	b	1121370 <syscall_asymm_operate+0x26c>
 11213f0:	52890601 	mov	w1, #0x4830                	// #18480
 11213f4:	72ae0001 	movk	w1, #0x7000, lsl #16
 11213f8:	17ffffc0 	b	11212f8 <syscall_asymm_operate+0x1f4>
 11213fc:	528d0601 	mov	w1, #0x6830                	// #26672
 1121400:	72ae0001 	movk	w1, #0x7000, lsl #16
 1121404:	6b01027f 	cmp	w19, w1
 1121408:	54fff7c0 	b.eq	1121300 <syscall_asymm_operate+0x1fc>  // b.none
 112140c:	540000e8 	b.hi	1121428 <syscall_asymm_operate+0x324>  // b.pmore
 1121410:	528b0601 	mov	w1, #0x5830                	// #22576
 1121414:	72ae0001 	movk	w1, #0x7000, lsl #16
 1121418:	6b01027f 	cmp	w19, w1
 112141c:	54fff720 	b.eq	1121300 <syscall_asymm_operate+0x1fc>  // b.none
 1121420:	528c08a0 	mov	w0, #0x6045                	// #24645
 1121424:	17ffffd3 	b	1121370 <syscall_asymm_operate+0x26c>
 1121428:	52852601 	mov	w1, #0x2930                	// #10544
 112142c:	72ae0421 	movk	w1, #0x7021, lsl #16
 1121430:	6b01027f 	cmp	w19, w1
 1121434:	54fff660 	b.eq	1121300 <syscall_asymm_operate+0x1fc>  // b.none
 1121438:	11440421 	add	w1, w1, #0x101, lsl #12
 112143c:	17ffffaf 	b	11212f8 <syscall_asymm_operate+0x1f4>
 1121440:	528008a1 	mov	w1, #0x45                  	// #69
 1121444:	72b00001 	movk	w1, #0x8000, lsl #16
 1121448:	6b01027f 	cmp	w19, w1
 112144c:	540006a0 	b.eq	1121520 <syscall_asymm_operate+0x41c>  // b.none
 1121450:	54000088 	b.hi	1121460 <syscall_asymm_operate+0x35c>  // b.pmore
 1121454:	528b2601 	mov	w1, #0x5930                	// #22832
 1121458:	72ae0a21 	movk	w1, #0x7051, lsl #16
 112145c:	17fffff5 	b	1121430 <syscall_asymm_operate+0x32c>
 1121460:	52810601 	mov	w1, #0x830                 	// #2096
 1121464:	72be0001 	movk	w1, #0xf000, lsl #16
 1121468:	17ffffa4 	b	11212f8 <syscall_asymm_operate+0x1f4>
			if (params[n].attributeID == TEE_ATTR_RSA_OAEP_LABEL) {
 112146c:	52812605 	mov	w5, #0x930                 	// #2352
 1121470:	aa1503e2 	mov	x2, x21
		for (n = 0; n < num_params; n++) {
 1121474:	d2800001 	mov	x1, #0x0                   	// #0
			if (params[n].attributeID == TEE_ATTR_RSA_OAEP_LABEL) {
 1121478:	72ba0005 	movk	w5, #0xd000, lsl #16
		for (n = 0; n < num_params; n++) {
 112147c:	eb16003f 	cmp	x1, x22
 1121480:	54000741 	b.ne	1121568 <syscall_asymm_operate+0x464>  // b.any
	void *label = NULL;
 1121484:	d2800002 	mov	x2, #0x0                   	// #0
 1121488:	1400003e 	b	1121580 <syscall_asymm_operate+0x47c>
		if (cs->mode == TEE_MODE_ENCRYPT) {
 112148c:	b9401400 	ldr	w0, [x0, #20]
 1121490:	35000360 	cbnz	w0, 11214fc <syscall_asymm_operate+0x3f8>
			res = crypto_acipher_rsanopad_encrypt(o->attr, src_data,
 1121494:	f9401ee0 	ldr	x0, [x23, #56]
 1121498:	aa1803e4 	mov	x4, x24
 112149c:	aa1c03e3 	mov	x3, x28
 11214a0:	aa1a03e2 	mov	x2, x26
 11214a4:	aa1b03e1 	mov	x1, x27
 11214a8:	9400265c 	bl	112ae18 <crypto_acipher_rsanopad_encrypt>
			res = crypto_acipher_sm2_pke_encrypt(o->attr, src_data,
 11214ac:	2a0003f3 	mov	w19, w0
		res = TEE_ERROR_BAD_PARAMETERS;
		break;
	}

out:
	free_wipe(params);
 11214b0:	aa1503e0 	mov	x0, x21
 11214b4:	9400884d 	bl	11435e8 <free_wipe>

	if (res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) {
 11214b8:	7100027f 	cmp	w19, #0x0
 11214bc:	129ffde0 	mov	w0, #0xffff0010            	// #-65520
 11214c0:	7a401264 	ccmp	w19, w0, #0x4, ne  // ne = any
 11214c4:	540000c1 	b.ne	11214dc <syscall_asymm_operate+0x3d8>  // b.any
		TEE_Result res2 = put_user_u64(dst_len, dlen);
 11214c8:	f94043e1 	ldr	x1, [sp, #128]
 11214cc:	aa1403e0 	mov	x0, x20
 11214d0:	97fff1d9 	bl	111dc34 <put_user_u64>

		if (res2 != TEE_SUCCESS)
 11214d4:	7100001f 	cmp	w0, #0x0
 11214d8:	1a800273 	csel	w19, w19, w0, eq  // eq = none
			return res2;
	}

	return res;
}
 11214dc:	2a1303e0 	mov	w0, w19
 11214e0:	a94153f3 	ldp	x19, x20, [sp, #16]
 11214e4:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11214e8:	a94363f7 	ldp	x23, x24, [sp, #48]
 11214ec:	a9446bf9 	ldp	x25, x26, [sp, #64]
 11214f0:	a94573fb 	ldp	x27, x28, [sp, #80]
 11214f4:	a8c97bfd 	ldp	x29, x30, [sp], #144
 11214f8:	d65f03c0 	ret
		} else if (cs->mode == TEE_MODE_DECRYPT) {
 11214fc:	7100041f 	cmp	w0, #0x1
 1121500:	54000801 	b.ne	1121600 <syscall_asymm_operate+0x4fc>  // b.any
			res = crypto_acipher_rsanopad_decrypt(o->attr, src_data,
 1121504:	f9401ee0 	ldr	x0, [x23, #56]
 1121508:	aa1803e4 	mov	x4, x24
 112150c:	aa1c03e3 	mov	x3, x28
 1121510:	aa1a03e2 	mov	x2, x26
 1121514:	aa1b03e1 	mov	x1, x27
 1121518:	9400265f 	bl	112ae94 <crypto_acipher_rsanopad_decrypt>
 112151c:	17ffffe4 	b	11214ac <syscall_asymm_operate+0x3a8>
		if (cs->mode == TEE_MODE_ENCRYPT) {
 1121520:	b9401400 	ldr	w0, [x0, #20]
 1121524:	35000100 	cbnz	w0, 1121544 <syscall_asymm_operate+0x440>
			res = crypto_acipher_sm2_pke_encrypt(o->attr, src_data,
 1121528:	f9401ee0 	ldr	x0, [x23, #56]
 112152c:	aa1803e4 	mov	x4, x24
 1121530:	aa1c03e3 	mov	x3, x28
 1121534:	aa1a03e2 	mov	x2, x26
 1121538:	aa1b03e1 	mov	x1, x27
 112153c:	97ffb275 	bl	110df10 <crypto_acipher_sm2_pke_encrypt>
 1121540:	17ffffdb 	b	11214ac <syscall_asymm_operate+0x3a8>
		} else if (cs->mode == TEE_MODE_DECRYPT) {
 1121544:	7100041f 	cmp	w0, #0x1
 1121548:	540005c1 	b.ne	1121600 <syscall_asymm_operate+0x4fc>  // b.any
			res = crypto_acipher_sm2_pke_decrypt(o->attr, src_data,
 112154c:	f9401ee0 	ldr	x0, [x23, #56]
 1121550:	aa1803e4 	mov	x4, x24
 1121554:	aa1c03e3 	mov	x3, x28
 1121558:	aa1a03e2 	mov	x2, x26
 112155c:	aa1b03e1 	mov	x1, x27
 1121560:	97ffb259 	bl	110dec4 <crypto_acipher_sm2_pke_decrypt>
 1121564:	17ffffd2 	b	11214ac <syscall_asymm_operate+0x3a8>
			if (params[n].attributeID == TEE_ATTR_RSA_OAEP_LABEL) {
 1121568:	aa0203e3 	mov	x3, x2
 112156c:	b8418446 	ldr	w6, [x2], #24
 1121570:	6b0500df 	cmp	w6, w5
 1121574:	540001c1 	b.ne	11215ac <syscall_asymm_operate+0x4a8>  // b.any
				label_len = params[n].content.ref.length;
 1121578:	b9401079 	ldr	w25, [x3, #16]
				label = params[n].content.ref.buffer;
 112157c:	f9400462 	ldr	x2, [x3, #8]
		if (cs->mode == TEE_MODE_ENCRYPT) {
 1121580:	b9401400 	ldr	w0, [x0, #20]
 1121584:	35000180 	cbnz	w0, 11215b4 <syscall_asymm_operate+0x4b0>
			res = crypto_acipher_rsaes_encrypt(cs->algo, o->attr,
 1121588:	f9401ee1 	ldr	x1, [x23, #56]
 112158c:	aa1803e7 	mov	x7, x24
 1121590:	aa1c03e6 	mov	x6, x28
 1121594:	aa1a03e5 	mov	x5, x26
 1121598:	aa1b03e4 	mov	x4, x27
 112159c:	aa1903e3 	mov	x3, x25
 11215a0:	2a1303e0 	mov	w0, w19
 11215a4:	94002706 	bl	112b1bc <crypto_acipher_rsaes_encrypt>
 11215a8:	17ffffc1 	b	11214ac <syscall_asymm_operate+0x3a8>
		for (n = 0; n < num_params; n++) {
 11215ac:	91000421 	add	x1, x1, #0x1
 11215b0:	17ffffb3 	b	112147c <syscall_asymm_operate+0x378>
		} else if (cs->mode == TEE_MODE_DECRYPT) {
 11215b4:	7100041f 	cmp	w0, #0x1
 11215b8:	54ffe741 	b.ne	11212a0 <syscall_asymm_operate+0x19c>  // b.any
			res = crypto_acipher_rsaes_decrypt(
 11215bc:	f9401ee1 	ldr	x1, [x23, #56]
 11215c0:	aa1803e7 	mov	x7, x24
 11215c4:	aa1c03e6 	mov	x6, x28
 11215c8:	aa1a03e5 	mov	x5, x26
 11215cc:	aa1b03e4 	mov	x4, x27
 11215d0:	aa1903e3 	mov	x3, x25
 11215d4:	2a1303e0 	mov	w0, w19
 11215d8:	9400265f 	bl	112af54 <crypto_acipher_rsaes_decrypt>
 11215dc:	17ffffb4 	b	11214ac <syscall_asymm_operate+0x3a8>
		res = crypto_acipher_dsa_sign(cs->algo, o->attr, src_data,
 11215e0:	f9401ee1 	ldr	x1, [x23, #56]
 11215e4:	aa1803e5 	mov	x5, x24
 11215e8:	aa1c03e4 	mov	x4, x28
 11215ec:	aa1a03e3 	mov	x3, x26
 11215f0:	aa1b03e2 	mov	x2, x27
 11215f4:	2a1303e0 	mov	w0, w19
 11215f8:	94002135 	bl	1129acc <crypto_acipher_dsa_sign>
 11215fc:	17ffffac 	b	11214ac <syscall_asymm_operate+0x3a8>
		res = TEE_ERROR_GENERIC;
 1121600:	52bffff3 	mov	w19, #0xffff0000            	// #-65536
 1121604:	17ffffab 	b	11214b0 <syscall_asymm_operate+0x3ac>
		return TEE_ERROR_OVERFLOW;
 1121608:	1299fe13 	mov	w19, #0xffff300f            	// #-53233
 112160c:	17ffffb4 	b	11214dc <syscall_asymm_operate+0x3d8>
		return TEE_ERROR_OUT_OF_MEMORY;
 1121610:	129ffe73 	mov	w19, #0xffff000c            	// #-65524
 1121614:	17ffffb2 	b	11214dc <syscall_asymm_operate+0x3d8>

0000000001121618 <syscall_asymm_verify>:

TEE_Result syscall_asymm_verify(unsigned long state,
			const struct utee_attribute *usr_params,
			size_t num_params, const void *data, size_t data_len,
			const void *sig, size_t sig_len)
{
 1121618:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
 112161c:	910003fd 	mov	x29, sp
 1121620:	a90153f3 	stp	x19, x20, [sp, #16]
 1121624:	aa0403f4 	mov	x20, x4
 1121628:	a9025bf5 	stp	x21, x22, [sp, #32]
 112162c:	aa0303f6 	mov	x22, x3
 1121630:	aa0003f5 	mov	x21, x0
 1121634:	a90363f7 	stp	x23, x24, [sp, #48]
 1121638:	aa0503f7 	mov	x23, x5
 112163c:	aa0603f8 	mov	x24, x6
 1121640:	a9046bf9 	stp	x25, x26, [sp, #64]
 1121644:	aa0203f9 	mov	x25, x2
 1121648:	f9002bfb 	str	x27, [sp, #80]
 112164c:	aa0103fb 	mov	x27, x1
	struct ts_session *sess = ts_get_current_session();
 1121650:	97ffcce4 	bl	11149e0 <ts_get_current_session>
 1121654:	aa0003f3 	mov	x19, x0
	struct user_ta_ctx *utc = to_user_ta_ctx(sess->ctx);
 1121658:	f9400800 	ldr	x0, [x0, #16]
 112165c:	97fff2e6 	bl	111e1f4 <to_user_ta_ctx>
 1121660:	aa0003fa 	mov	x26, x0
	struct tee_obj *o = NULL;
	size_t hash_size = 0;
	uint32_t hash_algo = 0;
	int salt_len = 0;

	res = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);
 1121664:	2a1503e0 	mov	w0, w21
	struct tee_obj *o = NULL;
 1121668:	a906ffff 	stp	xzr, xzr, [sp, #104]
	size_t hash_size = 0;
 112166c:	f9003fff 	str	xzr, [sp, #120]
	res = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);
 1121670:	97ffce92 	bl	11150b8 <uref_to_vaddr>
 1121674:	aa0003e1 	mov	x1, x0
 1121678:	9101a3e2 	add	x2, sp, #0x68
 112167c:	f9400a60 	ldr	x0, [x19, #16]
 1121680:	97fff324 	bl	111e310 <tee_svc_cryp_get_state.isra.0>
 1121684:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 1121688:	350003c0 	cbnz	w0, 1121700 <syscall_asymm_verify+0xe8>
		return res;

	if (cs->mode != TEE_MODE_VERIFY)
 112168c:	f94037e0 	ldr	x0, [sp, #104]
 1121690:	b9401400 	ldr	w0, [x0, #20]
 1121694:	71000c1f 	cmp	w0, #0x3
 1121698:	540013c1 	b.ne	1121910 <syscall_asymm_verify+0x2f8>  // b.any
		return TEE_ERROR_BAD_PARAMETERS;

	res = vm_check_access_rights(&utc->uctx,
 112169c:	91014355 	add	x21, x26, #0x50
 11216a0:	aa1403e3 	mov	x3, x20
 11216a4:	aa1603e2 	mov	x2, x22
 11216a8:	aa1503e0 	mov	x0, x21
 11216ac:	528000a1 	mov	w1, #0x5                   	// #5
 11216b0:	97ffe04f 	bl	11197ec <vm_check_access_rights>
 11216b4:	2a0003f3 	mov	w19, w0
				     TEE_MEMORY_ACCESS_READ |
				     TEE_MEMORY_ACCESS_ANY_OWNER,
				     (uaddr_t)data, data_len);
	if (res != TEE_SUCCESS)
 11216b8:	35000240 	cbnz	w0, 1121700 <syscall_asymm_verify+0xe8>
		return res;

	res = vm_check_access_rights(&utc->uctx,
 11216bc:	aa1803e3 	mov	x3, x24
 11216c0:	aa1703e2 	mov	x2, x23
 11216c4:	aa1503e0 	mov	x0, x21
 11216c8:	528000a1 	mov	w1, #0x5                   	// #5
 11216cc:	97ffe048 	bl	11197ec <vm_check_access_rights>
 11216d0:	2a0003f3 	mov	w19, w0
				     TEE_MEMORY_ACCESS_READ |
				     TEE_MEMORY_ACCESS_ANY_OWNER,
				     (uaddr_t)sig, sig_len);
	if (res != TEE_SUCCESS)
 11216d4:	35000160 	cbnz	w0, 1121700 <syscall_asymm_verify+0xe8>
		return res;

	size_t alloc_size = 0;

	if (MUL_OVERFLOW(sizeof(TEE_Attribute), num_params, &alloc_size))
 11216d8:	d2800301 	mov	x1, #0x18                  	// #24
 11216dc:	9b017f20 	mul	x0, x25, x1
 11216e0:	9bc17f21 	umulh	x1, x25, x1
 11216e4:	b50000c1 	cbnz	x1, 11216fc <syscall_asymm_verify+0xe4>
		return TEE_ERROR_OVERFLOW;

	params = malloc(alloc_size);
 11216e8:	9400875c 	bl	1143458 <malloc>
 11216ec:	aa0003f5 	mov	x21, x0
	if (!params)
 11216f0:	b5000180 	cbnz	x0, 1121720 <syscall_asymm_verify+0x108>
		return TEE_ERROR_OUT_OF_MEMORY;
 11216f4:	129ffe73 	mov	w19, #0xffff000c            	// #-65524
 11216f8:	14000002 	b	1121700 <syscall_asymm_verify+0xe8>
		return TEE_ERROR_OVERFLOW;
 11216fc:	1299fe13 	mov	w19, #0xffff300f            	// #-53233
	}

out:
	free_wipe(params);
	return res;
}
 1121700:	2a1303e0 	mov	w0, w19
 1121704:	a94153f3 	ldp	x19, x20, [sp, #16]
 1121708:	a9425bf5 	ldp	x21, x22, [sp, #32]
 112170c:	a94363f7 	ldp	x23, x24, [sp, #48]
 1121710:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1121714:	f9402bfb 	ldr	x27, [sp, #80]
 1121718:	a8c87bfd 	ldp	x29, x30, [sp], #128
 112171c:	d65f03c0 	ret
	res = copy_in_attrs(utc, usr_params, num_params, params);
 1121720:	aa0003e3 	mov	x3, x0
 1121724:	2a1903e2 	mov	w2, w25
 1121728:	aa1b03e1 	mov	x1, x27
 112172c:	aa1a03e0 	mov	x0, x26
 1121730:	97fff1aa 	bl	111ddd8 <copy_in_attrs>
 1121734:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 1121738:	35000180 	cbnz	w0, 1121768 <syscall_asymm_verify+0x150>
	res = tee_obj_get(utc, cs->key1, &o);
 112173c:	f94037e0 	ldr	x0, [sp, #104]
 1121740:	9101c3e2 	add	x2, sp, #0x70
 1121744:	f9400c01 	ldr	x1, [x0, #24]
 1121748:	aa1a03e0 	mov	x0, x26
 112174c:	9400120c 	bl	1125f7c <tee_obj_get>
 1121750:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 1121754:	350000a0 	cbnz	w0, 1121768 <syscall_asymm_verify+0x150>
	if ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0) {
 1121758:	f9403be7 	ldr	x7, [sp, #112]
 112175c:	b94028e0 	ldr	w0, [x7, #40]
 1121760:	378800a0 	tbnz	w0, #17, 1121774 <syscall_asymm_verify+0x15c>
		res = TEE_ERROR_BAD_PARAMETERS;
 1121764:	129fff33 	mov	w19, #0xffff0006            	// #-65530
	free_wipe(params);
 1121768:	aa1503e0 	mov	x0, x21
 112176c:	9400879f 	bl	11435e8 <free_wipe>
	return res;
 1121770:	17ffffe4 	b	1121700 <syscall_asymm_verify+0xe8>
	switch (TEE_ALG_GET_MAIN_ALG(cs->algo)) {
 1121774:	f94037e0 	ldr	x0, [sp, #104]
 1121778:	b9401006 	ldr	w6, [x0, #16]
 112177c:	2a0603e0 	mov	w0, w6
 1121780:	97ffef26 	bl	111d418 <__tee_alg_get_main_alg>
 1121784:	7100c41f 	cmp	w0, #0x31
 1121788:	54000780 	b.eq	1121878 <syscall_asymm_verify+0x260>  // b.none
 112178c:	540000a8 	b.hi	11217a0 <syscall_asymm_verify+0x188>  // b.pmore
 1121790:	7100c01f 	cmp	w0, #0x30
 1121794:	540001c0 	b.eq	11217cc <syscall_asymm_verify+0x1b4>  // b.none
 1121798:	129ffeb3 	mov	w19, #0xffff000a            	// #-65526
 112179c:	17fffff3 	b	1121768 <syscall_asymm_verify+0x150>
 11217a0:	121d7800 	and	w0, w0, #0xfffffffb
 11217a4:	7101041f 	cmp	w0, #0x41
 11217a8:	54ffff81 	b.ne	1121798 <syscall_asymm_verify+0x180>  // b.any
		res = crypto_acipher_ecc_verify(cs->algo, o->attr, data,
 11217ac:	f9401ce1 	ldr	x1, [x7, #56]
 11217b0:	aa1803e5 	mov	x5, x24
 11217b4:	aa1703e4 	mov	x4, x23
 11217b8:	aa1403e3 	mov	x3, x20
 11217bc:	aa1603e2 	mov	x2, x22
 11217c0:	2a0603e0 	mov	w0, w6
 11217c4:	97ffb19a 	bl	110de2c <crypto_acipher_ecc_verify>
 11217c8:	14000025 	b	112185c <syscall_asymm_verify+0x244>
		if (cs->algo != TEE_ALG_RSASSA_PKCS1_V1_5) {
 11217cc:	52810600 	mov	w0, #0x830                 	// #2096
 11217d0:	72be0000 	movk	w0, #0xf000, lsl #16
 11217d4:	6b0000df 	cmp	w6, w0
 11217d8:	540004c0 	b.eq	1121870 <syscall_asymm_verify+0x258>  // b.none
	if (algo == TEE_ALG_SM2_DSA_SM3)
 11217dc:	528c08a0 	mov	w0, #0x6045                	// #24645
 11217e0:	72ae0000 	movk	w0, #0x7000, lsl #16
 11217e4:	6b0000df 	cmp	w6, w0
 11217e8:	540003e0 	b.eq	1121864 <syscall_asymm_verify+0x24c>  // b.none
	return (algo >> 12) & 0xF;
 11217ec:	d34c3cc6 	ubfx	x6, x6, #12, #4
	return (TEE_OPERATION_DIGEST << 28) | main_hash;
 11217f0:	52aa0000 	mov	w0, #0x50000000            	// #1342177280
 11217f4:	71001cdf 	cmp	w6, #0x7
 11217f8:	2a0000c0 	orr	w0, w6, w0
 11217fc:	528000e1 	mov	w1, #0x7                   	// #7
 1121800:	72aa0001 	movk	w1, #0x5000, lsl #16
 1121804:	1a811000 	csel	w0, w0, w1, ne  // ne = any
			res = tee_alg_get_digest_size(hash_algo, &hash_size);
 1121808:	9101e3e1 	add	x1, sp, #0x78
 112180c:	97ffe7cb 	bl	111b738 <tee_alg_get_digest_size>
 1121810:	2a0003f3 	mov	w19, w0
			if (res != TEE_SUCCESS)
 1121814:	35fffaa0 	cbnz	w0, 1121768 <syscall_asymm_verify+0x150>
			if (data_len != hash_size) {
 1121818:	f9403fe0 	ldr	x0, [sp, #120]
 112181c:	eb14001f 	cmp	x0, x20
 1121820:	54fffa21 	b.ne	1121764 <syscall_asymm_verify+0x14c>  // b.any
			salt_len = pkcs1_get_salt_len(params, num_params,
 1121824:	aa1403e2 	mov	x2, x20
 1121828:	2a1903e1 	mov	w1, w25
 112182c:	aa1503e0 	mov	x0, x21
 1121830:	97fff32d 	bl	111e4e4 <pkcs1_get_salt_len>
 1121834:	2a0003e2 	mov	w2, w0
		res = crypto_acipher_rsassa_verify(cs->algo, o->attr, salt_len,
 1121838:	f9403be0 	ldr	x0, [sp, #112]
 112183c:	aa1803e6 	mov	x6, x24
 1121840:	aa1703e5 	mov	x5, x23
 1121844:	aa1403e4 	mov	x4, x20
 1121848:	aa1603e3 	mov	x3, x22
 112184c:	f9401c01 	ldr	x1, [x0, #56]
 1121850:	f94037e0 	ldr	x0, [sp, #104]
 1121854:	b9401000 	ldr	w0, [x0, #16]
 1121858:	94002751 	bl	112b59c <crypto_acipher_rsassa_verify>
		res = crypto_acipher_ecc_verify(cs->algo, o->attr, data,
 112185c:	2a0003f3 	mov	w19, w0
		break;
 1121860:	17ffffc2 	b	1121768 <syscall_asymm_verify+0x150>
		return TEE_ALG_SM3;
 1121864:	528000e0 	mov	w0, #0x7                   	// #7
 1121868:	72aa0000 	movk	w0, #0x5000, lsl #16
 112186c:	17ffffe7 	b	1121808 <syscall_asymm_verify+0x1f0>
	int salt_len = 0;
 1121870:	52800002 	mov	w2, #0x0                   	// #0
 1121874:	17fffff1 	b	1121838 <syscall_asymm_verify+0x220>
	if (algo == TEE_ALG_SM2_DSA_SM3)
 1121878:	528c08a0 	mov	w0, #0x6045                	// #24645
 112187c:	72ae0000 	movk	w0, #0x7000, lsl #16
 1121880:	6b0000df 	cmp	w6, w0
 1121884:	54000320 	b.eq	11218e8 <syscall_asymm_verify+0x2d0>  // b.none
	return (algo >> 12) & 0xF;
 1121888:	d34c3cc6 	ubfx	x6, x6, #12, #4
	return (TEE_OPERATION_DIGEST << 28) | main_hash;
 112188c:	52aa0000 	mov	w0, #0x50000000            	// #1342177280
 1121890:	71001cdf 	cmp	w6, #0x7
 1121894:	2a0000c0 	orr	w0, w6, w0
 1121898:	528000e1 	mov	w1, #0x7                   	// #7
 112189c:	72aa0001 	movk	w1, #0x5000, lsl #16
 11218a0:	1a811000 	csel	w0, w0, w1, ne  // ne = any
		res = tee_alg_get_digest_size(hash_algo, &hash_size);
 11218a4:	9101e3e1 	add	x1, sp, #0x78
 11218a8:	97ffe7a4 	bl	111b738 <tee_alg_get_digest_size>
 11218ac:	2a0003f3 	mov	w19, w0
		if (res != TEE_SUCCESS)
 11218b0:	35fff5c0 	cbnz	w0, 1121768 <syscall_asymm_verify+0x150>
		if (data_len != hash_size) {
 11218b4:	f9403fe0 	ldr	x0, [sp, #120]
 11218b8:	eb14001f 	cmp	x0, x20
 11218bc:	540001c1 	b.ne	11218f4 <syscall_asymm_verify+0x2dc>  // b.any
		res = crypto_acipher_dsa_verify(cs->algo, o->attr, data,
 11218c0:	f9403be0 	ldr	x0, [sp, #112]
 11218c4:	aa1803e5 	mov	x5, x24
 11218c8:	aa1703e4 	mov	x4, x23
 11218cc:	aa1403e3 	mov	x3, x20
 11218d0:	aa1603e2 	mov	x2, x22
 11218d4:	f9401c01 	ldr	x1, [x0, #56]
 11218d8:	f94037e0 	ldr	x0, [sp, #104]
 11218dc:	b9401000 	ldr	w0, [x0, #16]
 11218e0:	9400210a 	bl	1129d08 <crypto_acipher_dsa_verify>
 11218e4:	17ffffde 	b	112185c <syscall_asymm_verify+0x244>
		return TEE_ALG_SM3;
 11218e8:	528000e0 	mov	w0, #0x7                   	// #7
 11218ec:	72aa0000 	movk	w0, #0x5000, lsl #16
 11218f0:	17ffffed 	b	11218a4 <syscall_asymm_verify+0x28c>
			if (data_len != crypto_bignum_num_bytes(key->q)) {
 11218f4:	f9403be0 	ldr	x0, [sp, #112]
 11218f8:	f9401c00 	ldr	x0, [x0, #56]
 11218fc:	f9400800 	ldr	x0, [x0, #16]
 1121900:	94003217 	bl	112e15c <crypto_bignum_num_bytes>
 1121904:	eb14001f 	cmp	x0, x20
 1121908:	54fff2e1 	b.ne	1121764 <syscall_asymm_verify+0x14c>  // b.any
 112190c:	17ffffed 	b	11218c0 <syscall_asymm_verify+0x2a8>
		return TEE_ERROR_BAD_PARAMETERS;
 1121910:	129fff33 	mov	w19, #0xffff0006            	// #-65530
 1121914:	17ffff7b 	b	1121700 <syscall_asymm_verify+0xe8>

0000000001121918 <tee_svc_close_enum>:
}

static TEE_Result tee_svc_close_enum(struct user_ta_ctx *utc,
				     struct tee_storage_enum *e)
{
	if (e == NULL || utc == NULL)
 1121918:	f100003f 	cmp	x1, #0x0
 112191c:	fa401804 	ccmp	x0, #0x0, #0x4, ne  // ne = any
 1121920:	540002e0 	b.eq	112197c <tee_svc_close_enum+0x64>  // b.none
{
 1121924:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1121928:	910003fd 	mov	x29, sp
 112192c:	f9000bf3 	str	x19, [sp, #16]
 1121930:	aa0103f3 	mov	x19, x1
		return TEE_ERROR_BAD_PARAMETERS;

	TAILQ_REMOVE(&utc->storage_enums, e, link);
 1121934:	a9400821 	ldp	x1, x2, [x1]
 1121938:	b40001e1 	cbz	x1, 1121974 <tee_svc_close_enum+0x5c>
 112193c:	f9000422 	str	x2, [x1, #8]
 1121940:	f9400660 	ldr	x0, [x19, #8]
 1121944:	f9000001 	str	x1, [x0]

	if (e->fops)
 1121948:	f9400e60 	ldr	x0, [x19, #24]
 112194c:	b4000080 	cbz	x0, 112195c <tee_svc_close_enum+0x44>
		e->fops->closedir(e->dir);
 1121950:	f9402801 	ldr	x1, [x0, #80]
 1121954:	f9400a60 	ldr	x0, [x19, #16]
 1121958:	d63f0020 	blr	x1

	e->dir = NULL;
	e->fops = NULL;

	free(e);
 112195c:	aa1303e0 	mov	x0, x19
 1121960:	94008720 	bl	11435e0 <free>

	return TEE_SUCCESS;
 1121964:	52800000 	mov	w0, #0x0                   	// #0
}
 1121968:	f9400bf3 	ldr	x19, [sp, #16]
 112196c:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1121970:	d65f03c0 	ret
	TAILQ_REMOVE(&utc->storage_enums, e, link);
 1121974:	f9001c02 	str	x2, [x0, #56]
 1121978:	17fffff2 	b	1121940 <tee_svc_close_enum+0x28>
		return TEE_ERROR_BAD_PARAMETERS;
 112197c:	129fff20 	mov	w0, #0xffff0006            	// #-65530
}
 1121980:	d65f03c0 	ret

0000000001121984 <tee_svc_storage_read_head>:

	return TEE_SUCCESS;
}

static TEE_Result tee_svc_storage_read_head(struct tee_obj *o)
{
 1121984:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
 1121988:	910003fd 	mov	x29, sp
 112198c:	a90153f3 	stp	x19, x20, [sp, #16]
 1121990:	aa0003f4 	mov	x20, x0
	TEE_Result res = TEE_SUCCESS;
	size_t bytes;
	struct tee_svc_storage_head head;
	const struct tee_file_operations *fops = o->pobj->fops;
 1121994:	f9402400 	ldr	x0, [x0, #72]
{
 1121998:	a9025bf5 	stp	x21, x22, [sp, #32]
	void *attr = NULL;
	size_t size;
	size_t tmp = 0;

	assert(!o->fh);
 112199c:	f9402a95 	ldr	x21, [x20, #80]
{
 11219a0:	a90363f7 	stp	x23, x24, [sp, #48]
	const struct tee_file_operations *fops = o->pobj->fops;
 11219a4:	f9402017 	ldr	x23, [x0, #64]
{
 11219a8:	f90023f9 	str	x25, [sp, #64]
	assert(!o->fh);
 11219ac:	b4000155 	cbz	x21, 11219d4 <tee_svc_storage_read_head+0x50>
 11219b0:	900001a3 	adrp	x3, 1155000 <__func__.3826+0xa8>
 11219b4:	900001a1 	adrp	x1, 1155000 <__func__.3826+0xa8>
 11219b8:	9127b863 	add	x3, x3, #0x9ee
 11219bc:	91257821 	add	x1, x1, #0x95e
 11219c0:	900001a0 	adrp	x0, 1155000 <__func__.3826+0xa8>
 11219c4:	9125e400 	add	x0, x0, #0x979
 11219c8:	528017c2 	mov	w2, #0xbe                  	// #190
 11219cc:	97ffc238 	bl	11122ac <_assert_log>
 11219d0:	97ffc248 	bl	11122f0 <_assert_break>
	res = fops->open(o->pobj, &size, &o->fh);
 11219d4:	f94002e3 	ldr	x3, [x23]
 11219d8:	91014282 	add	x2, x20, #0x50
 11219dc:	910183e1 	add	x1, sp, #0x60
 11219e0:	d63f0060 	blr	x3
 11219e4:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 11219e8:	35000300 	cbnz	w0, 1121a48 <tee_svc_storage_read_head+0xc4>
		goto exit;

	/* read head */
	bytes = sizeof(struct tee_svc_storage_head);
 11219ec:	d2800300 	mov	x0, #0x18                  	// #24
 11219f0:	f9002fe0 	str	x0, [sp, #88]
	res = fops->read(o->fh, 0, &head, &bytes);
 11219f4:	f9400ee4 	ldr	x4, [x23, #24]
 11219f8:	910163f8 	add	x24, sp, #0x58
 11219fc:	f9402a80 	ldr	x0, [x20, #80]
 1121a00:	aa1803e3 	mov	x3, x24
 1121a04:	9101a3e2 	add	x2, sp, #0x68
 1121a08:	d2800001 	mov	x1, #0x0                   	// #0
 1121a0c:	d63f0080 	blr	x4
 1121a10:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS) {
 1121a14:	340002c0 	cbz	w0, 1121a6c <tee_svc_storage_read_head+0xe8>
		if (res == TEE_ERROR_CORRUPT_OBJECT)
 1121a18:	52800020 	mov	w0, #0x1                   	// #1
 1121a1c:	72be0200 	movk	w0, #0xf010, lsl #16
 1121a20:	6b00027f 	cmp	w19, w0
 1121a24:	54000121 	b.ne	1121a48 <tee_svc_storage_read_head+0xc4>  // b.any
			EMSG("Head corrupt");
 1121a28:	900001a4 	adrp	x4, 1155000 <__func__.3826+0xa8>
 1121a2c:	900001a0 	adrp	x0, 1155000 <__func__.3826+0xa8>
 1121a30:	91260084 	add	x4, x4, #0x980
 1121a34:	9127b800 	add	x0, x0, #0x9ee
 1121a38:	52800023 	mov	w3, #0x1                   	// #1
 1121a3c:	52800022 	mov	w2, #0x1                   	// #1
 1121a40:	52801901 	mov	w1, #0xc8                  	// #200
 1121a44:	94008cc0 	bl	1144d44 <trace_printf>
	o->info.objectUsage = head.objectUsage;
	o->info.objectType = head.objectType;
	o->have_attrs = head.have_attrs;

exit:
	free(attr);
 1121a48:	aa1503e0 	mov	x0, x21
 1121a4c:	940086e5 	bl	11435e0 <free>

	return res;
}
 1121a50:	2a1303e0 	mov	w0, w19
 1121a54:	a94153f3 	ldp	x19, x20, [sp, #16]
 1121a58:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1121a5c:	a94363f7 	ldp	x23, x24, [sp, #48]
 1121a60:	f94023f9 	ldr	x25, [sp, #64]
 1121a64:	a8c87bfd 	ldp	x29, x30, [sp], #128
 1121a68:	d65f03c0 	ret
	if (ADD_OVERFLOW(sizeof(head), head.attr_size, &tmp)) {
 1121a6c:	b9406bf6 	ldr	w22, [sp, #104]
	if (tmp > size) {
 1121a70:	f94033e0 	ldr	x0, [sp, #96]
	if (ADD_OVERFLOW(sizeof(head), head.attr_size, &tmp)) {
 1121a74:	910062d6 	add	x22, x22, #0x18
	if (tmp > size) {
 1121a78:	eb0002df 	cmp	x22, x0
 1121a7c:	54000748 	b.hi	1121b64 <tee_svc_storage_read_head+0x1e0>  // b.pmore
	if (bytes != sizeof(struct tee_svc_storage_head)) {
 1121a80:	f9402ff9 	ldr	x25, [sp, #88]
 1121a84:	f100633f 	cmp	x25, #0x18
 1121a88:	54000661 	b.ne	1121b54 <tee_svc_storage_read_head+0x1d0>  // b.any
	res = tee_obj_set_type(o, head.objectType, head.maxKeySize);
 1121a8c:	b94073e2 	ldr	w2, [sp, #112]
 1121a90:	aa1403e0 	mov	x0, x20
 1121a94:	b9407be1 	ldr	w1, [sp, #120]
 1121a98:	97fff4b5 	bl	111ed6c <tee_obj_set_type>
 1121a9c:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 1121aa0:	35fffd40 	cbnz	w0, 1121a48 <tee_svc_storage_read_head+0xc4>
	if (head.attr_size) {
 1121aa4:	b9406bf3 	ldr	w19, [sp, #104]
	o->ds_pos = tmp;
 1121aa8:	f9002296 	str	x22, [x20, #64]
	if (head.attr_size) {
 1121aac:	340002d3 	cbz	w19, 1121b04 <tee_svc_storage_read_head+0x180>
 1121ab0:	2a1303f3 	mov	w19, w19
		attr = malloc(head.attr_size);
 1121ab4:	aa1303e0 	mov	x0, x19
 1121ab8:	94008668 	bl	1143458 <malloc>
 1121abc:	aa0003f5 	mov	x21, x0
		if (!attr) {
 1121ac0:	b40004e0 	cbz	x0, 1121b5c <tee_svc_storage_read_head+0x1d8>
		res = fops->read(o->fh, sizeof(struct tee_svc_storage_head),
 1121ac4:	aa0003e2 	mov	x2, x0
		bytes = head.attr_size;
 1121ac8:	f9002ff3 	str	x19, [sp, #88]
		res = fops->read(o->fh, sizeof(struct tee_svc_storage_head),
 1121acc:	f9400ee4 	ldr	x4, [x23, #24]
 1121ad0:	aa1803e3 	mov	x3, x24
 1121ad4:	f9402a80 	ldr	x0, [x20, #80]
 1121ad8:	aa1903e1 	mov	x1, x25
 1121adc:	d63f0080 	blr	x4
 1121ae0:	2a0003f3 	mov	w19, w0
		if (res == TEE_ERROR_OUT_OF_MEMORY)
 1121ae4:	129ffe60 	mov	w0, #0xffff000c            	// #-65524
 1121ae8:	6b00027f 	cmp	w19, w0
 1121aec:	54fffae0 	b.eq	1121a48 <tee_svc_storage_read_head+0xc4>  // b.none
		if (res != TEE_SUCCESS || bytes != head.attr_size)
 1121af0:	350003b3 	cbnz	w19, 1121b64 <tee_svc_storage_read_head+0x1e0>
 1121af4:	f9402fe0 	ldr	x0, [sp, #88]
 1121af8:	b9406be1 	ldr	w1, [sp, #104]
 1121afc:	eb00003f 	cmp	x1, x0
 1121b00:	54000321 	b.ne	1121b64 <tee_svc_storage_read_head+0x1e0>  // b.any
	res = tee_obj_attr_from_binary(o, attr, head.attr_size);
 1121b04:	b9406be2 	ldr	w2, [sp, #104]
 1121b08:	aa1503e1 	mov	x1, x21
 1121b0c:	aa1403e0 	mov	x0, x20
 1121b10:	97fff3ce 	bl	111ea48 <tee_obj_attr_from_binary>
 1121b14:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 1121b18:	35fff980 	cbnz	w0, 1121a48 <tee_svc_storage_read_head+0xc4>
	o->info.dataSize = size - sizeof(head) - head.attr_size;
 1121b1c:	f94033e0 	ldr	x0, [sp, #96]
 1121b20:	b9406be1 	ldr	w1, [sp, #104]
 1121b24:	4b010000 	sub	w0, w0, w1
 1121b28:	51006000 	sub	w0, w0, #0x18
 1121b2c:	b9002280 	str	w0, [x20, #32]
	o->info.keySize = head.keySize;
 1121b30:	b9406fe0 	ldr	w0, [sp, #108]
 1121b34:	b9001680 	str	w0, [x20, #20]
	o->info.objectUsage = head.objectUsage;
 1121b38:	b94077e0 	ldr	w0, [sp, #116]
 1121b3c:	b9001e80 	str	w0, [x20, #28]
	o->info.objectType = head.objectType;
 1121b40:	b9407be0 	ldr	w0, [sp, #120]
 1121b44:	b9001280 	str	w0, [x20, #16]
	o->have_attrs = head.have_attrs;
 1121b48:	b9407fe0 	ldr	w0, [sp, #124]
 1121b4c:	b9003280 	str	w0, [x20, #48]
 1121b50:	17ffffbe 	b	1121a48 <tee_svc_storage_read_head+0xc4>
		res = TEE_ERROR_BAD_FORMAT;
 1121b54:	129fff53 	mov	w19, #0xffff0005            	// #-65531
 1121b58:	17ffffbc 	b	1121a48 <tee_svc_storage_read_head+0xc4>
			res = TEE_ERROR_OUT_OF_MEMORY;
 1121b5c:	129ffe73 	mov	w19, #0xffff000c            	// #-65524
 1121b60:	17ffffba 	b	1121a48 <tee_svc_storage_read_head+0xc4>
 1121b64:	52800033 	mov	w19, #0x1                   	// #1
 1121b68:	72be0213 	movk	w19, #0xf010, lsl #16
 1121b6c:	17ffffb7 	b	1121a48 <tee_svc_storage_read_head+0xc4>

0000000001121b70 <to_user_ta_ctx>:
{
 1121b70:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1121b74:	910003fd 	mov	x29, sp
 1121b78:	f9000bf3 	str	x19, [sp, #16]
 1121b7c:	aa0003f3 	mov	x19, x0
	assert(is_user_ta_ctx(ctx));
 1121b80:	97ffd19b 	bl	11161ec <is_user_ta_ctx>
 1121b84:	72001c1f 	tst	w0, #0xff
 1121b88:	54000141 	b.ne	1121bb0 <to_user_ta_ctx+0x40>  // b.any
 1121b8c:	900001a3 	adrp	x3, 1155000 <__func__.3826+0xa8>
 1121b90:	90000181 	adrp	x1, 1151000 <small_prime+0x168>
 1121b94:	91277c63 	add	x3, x3, #0x9df
 1121b98:	91081021 	add	x1, x1, #0x204
 1121b9c:	90000180 	adrp	x0, 1151000 <small_prime+0x168>
 1121ba0:	91088800 	add	x0, x0, #0x222
 1121ba4:	52800702 	mov	w2, #0x38                  	// #56
 1121ba8:	97ffc1c1 	bl	11122ac <_assert_log>
 1121bac:	97ffc1d1 	bl	11122f0 <_assert_break>
}
 1121bb0:	d10ba260 	sub	x0, x19, #0x2e8
 1121bb4:	f9400bf3 	ldr	x19, [sp, #16]
 1121bb8:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1121bbc:	d65f03c0 	ret

0000000001121bc0 <tee_svc_storage_remove_corrupt_obj.isra.0>:
static TEE_Result tee_svc_storage_remove_corrupt_obj(struct ts_session *sess,
 1121bc0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1121bc4:	910003fd 	mov	x29, sp
 1121bc8:	a90153f3 	stp	x19, x20, [sp, #16]
 1121bcc:	aa0003f4 	mov	x20, x0
 1121bd0:	aa0103f3 	mov	x19, x1
	o->pobj->fops->remove(o->pobj);
 1121bd4:	f9402420 	ldr	x0, [x1, #72]
 1121bd8:	f9402001 	ldr	x1, [x0, #64]
 1121bdc:	f9401821 	ldr	x1, [x1, #48]
 1121be0:	d63f0020 	blr	x1
	tee_obj_close(to_user_ta_ctx(sess->ctx), o);
 1121be4:	f9400280 	ldr	x0, [x20]
 1121be8:	97ffffe2 	bl	1121b70 <to_user_ta_ctx>
 1121bec:	aa1303e1 	mov	x1, x19
 1121bf0:	940010fe 	bl	1125fe8 <tee_obj_close>
}
 1121bf4:	52800000 	mov	w0, #0x0                   	// #0
 1121bf8:	a94153f3 	ldp	x19, x20, [sp, #16]
 1121bfc:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1121c00:	d65f03c0 	ret

0000000001121c04 <tee_svc_storage_file_ops>:
	switch (storage_id) {
 1121c04:	7100041f 	cmp	w0, #0x1
		return &ree_fs_ops;
 1121c08:	b00001c1 	adrp	x1, 115a000 <__scattered_array_1phys_mem_map+0x8>
	switch (storage_id) {
 1121c0c:	540000c0 	b.eq	1121c24 <tee_svc_storage_file_ops+0x20>  // b.none
		return &ree_fs_ops;
 1121c10:	f9423c21 	ldr	x1, [x1, #1144]
 1121c14:	52b00002 	mov	w2, #0x80000000            	// #-2147483648
 1121c18:	6b02001f 	cmp	w0, w2
 1121c1c:	9a9f0020 	csel	x0, x1, xzr, eq  // eq = none
}
 1121c20:	d65f03c0 	ret
		return &ree_fs_ops;
 1121c24:	f9423c20 	ldr	x0, [x1, #1144]
 1121c28:	17fffffe 	b	1121c20 <tee_svc_storage_file_ops+0x1c>

0000000001121c2c <tee_svc_storage_create_filename_dfh>:
	if (pos >= blen)
 1121c2c:	b5000061 	cbnz	x1, 1121c38 <tee_svc_storage_create_filename_dfh+0xc>
		return TEE_ERROR_SHORT_BUFFER;
 1121c30:	129ffde0 	mov	w0, #0xffff0010            	// #-65520
}
 1121c34:	d65f03c0 	ret
 1121c38:	aa0003e3 	mov	x3, x0
 1121c3c:	aa0203e0 	mov	x0, x2
	file[pos] = '/';
 1121c40:	528005e2 	mov	w2, #0x2f                  	// #47
	if (pos >= blen)
 1121c44:	f100043f 	cmp	x1, #0x1
	file[pos] = '/';
 1121c48:	39000062 	strb	w2, [x3]
	if (pos >= blen)
 1121c4c:	54ffff29 	b.ls	1121c30 <tee_svc_storage_create_filename_dfh+0x4>  // b.plast
{
 1121c50:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	l = blen - pos;
 1121c54:	d1000421 	sub	x1, x1, #0x1
{
 1121c58:	910003fd 	mov	x29, sp
	return tee_fs_dirfile_fileh_to_fname(dfh, file + pos, &l);
 1121c5c:	910063e2 	add	x2, sp, #0x18
	l = blen - pos;
 1121c60:	f9000fe1 	str	x1, [sp, #24]
	return tee_fs_dirfile_fileh_to_fname(dfh, file + pos, &l);
 1121c64:	91000461 	add	x1, x3, #0x1
 1121c68:	94000e19 	bl	11254cc <tee_fs_dirfile_fileh_to_fname>
}
 1121c6c:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1121c70:	d65f03c0 	ret

0000000001121c74 <syscall_storage_obj_open>:

TEE_Result syscall_storage_obj_open(unsigned long storage_id, void *object_id,
				    size_t object_id_len, unsigned long flags,
				    uint32_t *obj)
{
 1121c74:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
 1121c78:	910003fd 	mov	x29, sp
 1121c7c:	a90153f3 	stp	x19, x20, [sp, #16]
 1121c80:	aa0203f4 	mov	x20, x2
 1121c84:	a9025bf5 	stp	x21, x22, [sp, #32]
 1121c88:	aa0303f5 	mov	x21, x3
 1121c8c:	a90363f7 	stp	x23, x24, [sp, #48]
 1121c90:	aa0403f8 	mov	x24, x4
 1121c94:	a9046bf9 	stp	x25, x26, [sp, #64]
 1121c98:	aa0103f9 	mov	x25, x1
					  TEE_DATA_FLAG_ACCESS_WRITE |
					  TEE_DATA_FLAG_ACCESS_WRITE_META |
					  TEE_DATA_FLAG_SHARE_READ |
					  TEE_DATA_FLAG_SHARE_WRITE;
	const struct tee_file_operations *fops =
			tee_svc_storage_file_ops(storage_id);
 1121c9c:	97ffffda 	bl	1121c04 <tee_svc_storage_file_ops>
 1121ca0:	aa0003fa 	mov	x26, x0
	struct ts_session *sess = ts_get_current_session();
 1121ca4:	97ffcb4f 	bl	11149e0 <ts_get_current_session>
 1121ca8:	aa0003f6 	mov	x22, x0
	struct user_ta_ctx *utc = to_user_ta_ctx(sess->ctx);
 1121cac:	f9400800 	ldr	x0, [x0, #16]
 1121cb0:	97ffffb0 	bl	1121b70 <to_user_ta_ctx>
	TEE_Result res = TEE_SUCCESS;
	struct tee_pobj *po = NULL;
 1121cb4:	f9002fff 	str	xzr, [sp, #88]
	struct user_ta_ctx *utc = to_user_ta_ctx(sess->ctx);
 1121cb8:	aa0003f7 	mov	x23, x0
	struct tee_obj *o = NULL;
	char *file = NULL;

	if (flags & ~valid_flags)
 1121cbc:	928006e0 	mov	x0, #0xffffffffffffffc8    	// #-56
 1121cc0:	ea0002bf 	tst	x21, x0
 1121cc4:	54000a61 	b.ne	1121e10 <syscall_storage_obj_open+0x19c>  // b.any
		return TEE_ERROR_BAD_PARAMETERS;

	if (!fops) {
 1121cc8:	b4000a1a 	cbz	x26, 1121e08 <syscall_storage_obj_open+0x194>
		res = TEE_ERROR_ITEM_NOT_FOUND;
		goto exit;
	}

	if (object_id_len > TEE_OBJECT_ID_MAX_LEN) {
 1121ccc:	f101029f 	cmp	x20, #0x40
 1121cd0:	54000a08 	b.hi	1121e10 <syscall_storage_obj_open+0x19c>  // b.pmore
		res = TEE_ERROR_BAD_PARAMETERS;
		goto exit;
	}

	res = vm_check_access_rights(&utc->uctx, TEE_MEMORY_ACCESS_READ,
 1121cd4:	aa1403e3 	mov	x3, x20
 1121cd8:	aa1903e2 	mov	x2, x25
 1121cdc:	910142e0 	add	x0, x23, #0x50
 1121ce0:	52800021 	mov	w1, #0x1                   	// #1
 1121ce4:	97ffdec2 	bl	11197ec <vm_check_access_rights>
 1121ce8:	2a0003f3 	mov	w19, w0
				     (uaddr_t)object_id, object_id_len);
	if (res != TEE_SUCCESS)
 1121cec:	350008a0 	cbnz	w0, 1121e00 <syscall_storage_obj_open+0x18c>
		goto err;

	res = tee_pobj_get((void *)&sess->ctx->uuid, object_id,
 1121cf0:	f9400ac0 	ldr	x0, [x22, #16]
 1121cf4:	910163e6 	add	x6, sp, #0x58
 1121cf8:	aa1a03e5 	mov	x5, x26
 1121cfc:	2a1503e3 	mov	w3, w21
 1121d00:	2a1403e2 	mov	w2, w20
 1121d04:	aa1903e1 	mov	x1, x25
 1121d08:	52800004 	mov	w4, #0x0                   	// #0
 1121d0c:	940010dc 	bl	112607c <tee_pobj_get>
 1121d10:	2a0003f3 	mov	w19, w0
			   object_id_len, flags, TEE_POBJ_USAGE_OPEN, fops,
			   &po);
	if (res != TEE_SUCCESS)
 1121d14:	35000760 	cbnz	w0, 1121e00 <syscall_storage_obj_open+0x18c>
		goto err;

	o = tee_obj_alloc();
 1121d18:	940010a4 	bl	1125fa8 <tee_obj_alloc>
 1121d1c:	aa0003f4 	mov	x20, x0
	if (o == NULL) {
 1121d20:	b5000300 	cbnz	x0, 1121d80 <syscall_storage_obj_open+0x10c>
		tee_pobj_release(po);
 1121d24:	f9402fe0 	ldr	x0, [sp, #88]
		res = TEE_ERROR_OUT_OF_MEMORY;
 1121d28:	129ffe73 	mov	w19, #0xffff000c            	// #-65524
		tee_pobj_release(po);
 1121d2c:	94001158 	bl	112628c <tee_pobj_release>
oclose:
	tee_obj_close(utc, o);
	o = NULL;

err:
	if (res == TEE_ERROR_NO_DATA || res == TEE_ERROR_BAD_FORMAT)
 1121d30:	129ffe80 	mov	w0, #0xffff000b            	// #-65525
 1121d34:	6b00027f 	cmp	w19, w0
		res = TEE_ERROR_CORRUPT_OBJECT;
 1121d38:	129fff41 	mov	w1, #0xffff0005            	// #-65531
 1121d3c:	52800020 	mov	w0, #0x1                   	// #1
 1121d40:	7a411264 	ccmp	w19, w1, #0x4, ne  // ne = any
 1121d44:	72be0200 	movk	w0, #0xf010, lsl #16
 1121d48:	1a801273 	csel	w19, w19, w0, ne  // ne = any
	if (res == TEE_ERROR_CORRUPT_OBJECT && o)
 1121d4c:	f100029f 	cmp	x20, #0x0
 1121d50:	7a401260 	ccmp	w19, w0, #0x0, ne  // ne = any
 1121d54:	54000081 	b.ne	1121d64 <syscall_storage_obj_open+0xf0>  // b.any
		tee_svc_storage_remove_corrupt_obj(sess, o);
 1121d58:	aa1403e1 	mov	x1, x20
 1121d5c:	910042c0 	add	x0, x22, #0x10
 1121d60:	97ffff98 	bl	1121bc0 <tee_svc_storage_remove_corrupt_obj.isra.0>

exit:
	free(file);
	file = NULL;
	return res;
}
 1121d64:	2a1303e0 	mov	w0, w19
 1121d68:	a94153f3 	ldp	x19, x20, [sp, #16]
 1121d6c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1121d70:	a94363f7 	ldp	x23, x24, [sp, #48]
 1121d74:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1121d78:	a8c67bfd 	ldp	x29, x30, [sp], #96
 1121d7c:	d65f03c0 	ret
	tee_obj_add(utc, o);
 1121d80:	aa0003e1 	mov	x1, x0
			      TEE_HANDLE_FLAG_INITIALIZED | flags;
 1121d84:	321006b5 	orr	w21, w21, #0x30000
	o->pobj = po;
 1121d88:	f9402fe0 	ldr	x0, [sp, #88]
	o->info.handleFlags = TEE_HANDLE_FLAG_PERSISTENT |
 1121d8c:	b9002a95 	str	w21, [x20, #40]
	o->pobj = po;
 1121d90:	f9002680 	str	x0, [x20, #72]
	tee_obj_add(utc, o);
 1121d94:	aa1703e0 	mov	x0, x23
 1121d98:	94001074 	bl	1125f68 <tee_obj_add>
	res = tee_svc_storage_read_head(o);
 1121d9c:	aa1403e0 	mov	x0, x20
 1121da0:	97fffef9 	bl	1121984 <tee_svc_storage_read_head>
 1121da4:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS) {
 1121da8:	340001c0 	cbz	w0, 1121de0 <syscall_storage_obj_open+0x16c>
		if (res == TEE_ERROR_CORRUPT_OBJECT) {
 1121dac:	52800020 	mov	w0, #0x1                   	// #1
 1121db0:	72be0200 	movk	w0, #0xf010, lsl #16
 1121db4:	6b00027f 	cmp	w19, w0
 1121db8:	540001e1 	b.ne	1121df4 <syscall_storage_obj_open+0x180>  // b.any
			EMSG("Object corrupt");
 1121dbc:	900001a4 	adrp	x4, 1155000 <__func__.3826+0xa8>
 1121dc0:	52800023 	mov	w3, #0x1                   	// #1
 1121dc4:	91263484 	add	x4, x4, #0x98d
 1121dc8:	52800022 	mov	w2, #0x1                   	// #1
 1121dcc:	52802781 	mov	w1, #0x13c                 	// #316
 1121dd0:	900001a0 	adrp	x0, 1155000 <__func__.3826+0xa8>
 1121dd4:	91282000 	add	x0, x0, #0xa08
 1121dd8:	94008bdb 	bl	1144d44 <trace_printf>
			goto err;
 1121ddc:	17ffffd5 	b	1121d30 <syscall_storage_obj_open+0xbc>
	res = copy_kaddr_to_uref(obj, o);
 1121de0:	aa1403e1 	mov	x1, x20
 1121de4:	aa1803e0 	mov	x0, x24
 1121de8:	97ffcca6 	bl	1115080 <copy_kaddr_to_uref>
 1121dec:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 1121df0:	34fffba0 	cbz	w0, 1121d64 <syscall_storage_obj_open+0xf0>
	tee_obj_close(utc, o);
 1121df4:	aa1403e1 	mov	x1, x20
 1121df8:	aa1703e0 	mov	x0, x23
 1121dfc:	9400107b 	bl	1125fe8 <tee_obj_close>
	struct tee_obj *o = NULL;
 1121e00:	d2800014 	mov	x20, #0x0                   	// #0
 1121e04:	17ffffcb 	b	1121d30 <syscall_storage_obj_open+0xbc>
		res = TEE_ERROR_ITEM_NOT_FOUND;
 1121e08:	129ffef3 	mov	w19, #0xffff0008            	// #-65528
 1121e0c:	17ffffd6 	b	1121d64 <syscall_storage_obj_open+0xf0>
		return TEE_ERROR_BAD_PARAMETERS;
 1121e10:	129fff33 	mov	w19, #0xffff0006            	// #-65530
 1121e14:	17ffffd4 	b	1121d64 <syscall_storage_obj_open+0xf0>

0000000001121e18 <syscall_storage_obj_create>:

TEE_Result syscall_storage_obj_create(unsigned long storage_id, void *object_id,
			size_t object_id_len, unsigned long flags,
			unsigned long attr, void *data, size_t len,
			uint32_t *obj)
{
 1121e18:	d102c3ff 	sub	sp, sp, #0xb0
 1121e1c:	a9017bfd 	stp	x29, x30, [sp, #16]
 1121e20:	910043fd 	add	x29, sp, #0x10
 1121e24:	a90253f3 	stp	x19, x20, [sp, #32]
 1121e28:	a9035bf5 	stp	x21, x22, [sp, #48]
 1121e2c:	aa0603f6 	mov	x22, x6
 1121e30:	a90463f7 	stp	x23, x24, [sp, #64]
 1121e34:	aa0303f7 	mov	x23, x3
 1121e38:	aa0503f8 	mov	x24, x5
 1121e3c:	a9056bf9 	stp	x25, x26, [sp, #80]
 1121e40:	aa0103fa 	mov	x26, x1
 1121e44:	a90673fb 	stp	x27, x28, [sp, #96]
 1121e48:	aa0203fc 	mov	x28, x2
 1121e4c:	a9071fe4 	stp	x4, x7, [sp, #112]
					  TEE_DATA_FLAG_ACCESS_WRITE_META |
					  TEE_DATA_FLAG_SHARE_READ |
					  TEE_DATA_FLAG_SHARE_WRITE |
					  TEE_DATA_FLAG_OVERWRITE;
	const struct tee_file_operations *fops =
			tee_svc_storage_file_ops(storage_id);
 1121e50:	97ffff6d 	bl	1121c04 <tee_svc_storage_file_ops>
 1121e54:	aa0003f4 	mov	x20, x0
	struct ts_session *sess = ts_get_current_session();
 1121e58:	97ffcae2 	bl	11149e0 <ts_get_current_session>
 1121e5c:	aa0003fb 	mov	x27, x0
	struct user_ta_ctx *utc = to_user_ta_ctx(sess->ctx);
 1121e60:	f9400800 	ldr	x0, [x0, #16]
 1121e64:	97ffff43 	bl	1121b70 <to_user_ta_ctx>
	struct tee_obj *attr_o = NULL;
	TEE_Result res = TEE_SUCCESS;
	struct tee_pobj *po = NULL;
 1121e68:	a9087fff 	stp	xzr, xzr, [sp, #128]
	struct user_ta_ctx *utc = to_user_ta_ctx(sess->ctx);
 1121e6c:	aa0003f5 	mov	x21, x0
	struct tee_obj *o = NULL;

	if (flags & ~valid_flags)
 1121e70:	928086e0 	mov	x0, #0xfffffffffffffbc8    	// #-1080
 1121e74:	ea0002ff 	tst	x23, x0
 1121e78:	54001761 	b.ne	1122164 <syscall_storage_obj_create+0x34c>  // b.any
		return TEE_ERROR_BAD_PARAMETERS;

	if (!fops)
 1121e7c:	b4001714 	cbz	x20, 112215c <syscall_storage_obj_create+0x344>
		return TEE_ERROR_ITEM_NOT_FOUND;

	if (object_id_len > TEE_OBJECT_ID_MAX_LEN)
 1121e80:	f101039f 	cmp	x28, #0x40
 1121e84:	54001708 	b.hi	1122164 <syscall_storage_obj_create+0x34c>  // b.pmore
		return TEE_ERROR_BAD_PARAMETERS;

	res = vm_check_access_rights(&utc->uctx, TEE_MEMORY_ACCESS_READ,
 1121e88:	910142b9 	add	x25, x21, #0x50
 1121e8c:	aa1c03e3 	mov	x3, x28
 1121e90:	aa1a03e2 	mov	x2, x26
 1121e94:	aa1903e0 	mov	x0, x25
 1121e98:	52800021 	mov	w1, #0x1                   	// #1
 1121e9c:	97ffde54 	bl	11197ec <vm_check_access_rights>
 1121ea0:	2a0003f3 	mov	w19, w0
				     (uaddr_t)object_id, object_id_len);
	if (res != TEE_SUCCESS)
 1121ea4:	35000620 	cbnz	w0, 1121f68 <syscall_storage_obj_create+0x150>
		goto err;

	res = tee_pobj_get((void *)&sess->ctx->uuid, object_id,
 1121ea8:	f9400b60 	ldr	x0, [x27, #16]
 1121eac:	910223e6 	add	x6, sp, #0x88
 1121eb0:	aa1403e5 	mov	x5, x20
 1121eb4:	2a1703e3 	mov	w3, w23
 1121eb8:	2a1c03e2 	mov	w2, w28
 1121ebc:	aa1a03e1 	mov	x1, x26
 1121ec0:	52800044 	mov	w4, #0x2                   	// #2
 1121ec4:	9400106e 	bl	112607c <tee_pobj_get>
 1121ec8:	2a0003f3 	mov	w19, w0
			   object_id_len, flags, TEE_POBJ_USAGE_CREATE,
			   fops, &po);
	if (res != TEE_SUCCESS)
 1121ecc:	350004e0 	cbnz	w0, 1121f68 <syscall_storage_obj_create+0x150>
		goto err;

	/* check rights of the provided buffer */
	if (len) {
 1121ed0:	b50003d6 	cbnz	x22, 1121f48 <syscall_storage_obj_create+0x130>
			res = TEE_ERROR_BAD_PARAMETERS;
			goto err;
		}
	}

	o = tee_obj_alloc();
 1121ed4:	94001035 	bl	1125fa8 <tee_obj_alloc>
 1121ed8:	aa0003fb 	mov	x27, x0
	if (o == NULL) {
 1121edc:	b50004a0 	cbnz	x0, 1121f70 <syscall_storage_obj_create+0x158>
		res = TEE_ERROR_OUT_OF_MEMORY;
 1121ee0:	129ffe73 	mov	w19, #0xffff000c            	// #-65524
oclose:
	tee_obj_close(utc, o);
	return res;

err:
	if (res == TEE_ERROR_NO_DATA || res == TEE_ERROR_BAD_FORMAT)
 1121ee4:	129ffe80 	mov	w0, #0xffff000b            	// #-65525
 1121ee8:	6b00027f 	cmp	w19, w0
 1121eec:	129fff40 	mov	w0, #0xffff0005            	// #-65531
 1121ef0:	7a401264 	ccmp	w19, w0, #0x4, ne  // ne = any
 1121ef4:	540000a0 	b.eq	1121f08 <syscall_storage_obj_create+0xf0>  // b.none
		res = TEE_ERROR_CORRUPT_OBJECT;
	if (res == TEE_ERROR_CORRUPT_OBJECT && po)
 1121ef8:	52800020 	mov	w0, #0x1                   	// #1
 1121efc:	72be0200 	movk	w0, #0xf010, lsl #16
 1121f00:	6b00027f 	cmp	w19, w0
 1121f04:	540000e1 	b.ne	1121f20 <syscall_storage_obj_create+0x108>  // b.any
 1121f08:	f94047e0 	ldr	x0, [sp, #136]
 1121f0c:	b4000060 	cbz	x0, 1121f18 <syscall_storage_obj_create+0x100>
		fops->remove(po);
 1121f10:	f9401a81 	ldr	x1, [x20, #48]
 1121f14:	d63f0020 	blr	x1
 1121f18:	52800033 	mov	w19, #0x1                   	// #1
 1121f1c:	72be0213 	movk	w19, #0xf010, lsl #16
	if (o) {
 1121f20:	b40000db 	cbz	x27, 1121f38 <syscall_storage_obj_create+0x120>
		fops->close(&o->fh);
 1121f24:	f9400a81 	ldr	x1, [x20, #16]
 1121f28:	91014360 	add	x0, x27, #0x50
 1121f2c:	d63f0020 	blr	x1
		tee_obj_free(o);
 1121f30:	aa1b03e0 	mov	x0, x27
 1121f34:	94001020 	bl	1125fb4 <tee_obj_free>
	}
	if (po)
 1121f38:	f94047e0 	ldr	x0, [sp, #136]
 1121f3c:	b4000f40 	cbz	x0, 1122124 <syscall_storage_obj_create+0x30c>
		tee_pobj_release(po);
 1121f40:	940010d3 	bl	112628c <tee_pobj_release>
 1121f44:	14000078 	b	1122124 <syscall_storage_obj_create+0x30c>
		if (data) {
 1121f48:	b4001078 	cbz	x24, 1122154 <syscall_storage_obj_create+0x33c>
			res = vm_check_access_rights(&utc->uctx, f,
 1121f4c:	aa1603e3 	mov	x3, x22
 1121f50:	aa1803e2 	mov	x2, x24
 1121f54:	aa1903e0 	mov	x0, x25
 1121f58:	528000a1 	mov	w1, #0x5                   	// #5
 1121f5c:	97ffde24 	bl	11197ec <vm_check_access_rights>
 1121f60:	2a0003f3 	mov	w19, w0
			if (res != TEE_SUCCESS)
 1121f64:	34fffb80 	cbz	w0, 1121ed4 <syscall_storage_obj_create+0xbc>
	struct tee_obj *o = NULL;
 1121f68:	d280001b 	mov	x27, #0x0                   	// #0
 1121f6c:	17ffffde 	b	1121ee4 <syscall_storage_obj_create+0xcc>
			      TEE_HANDLE_FLAG_INITIALIZED | flags;
 1121f70:	321006e0 	orr	w0, w23, #0x30000
	o->info.handleFlags = TEE_HANDLE_FLAG_PERSISTENT |
 1121f74:	b9002b60 	str	w0, [x27, #40]
	o->pobj = po;
 1121f78:	f94047e0 	ldr	x0, [sp, #136]
 1121f7c:	f9002760 	str	x0, [x27, #72]
	if (attr != TEE_HANDLE_NULL) {
 1121f80:	f9403be0 	ldr	x0, [sp, #112]
 1121f84:	b50001c0 	cbnz	x0, 1121fbc <syscall_storage_obj_create+0x1a4>
	const struct tee_file_operations *fops = o->pobj->fops;
 1121f88:	f9402760 	ldr	x0, [x27, #72]
	size_t attr_size = 0;
 1121f8c:	f9004bff 	str	xzr, [sp, #144]
	res = tee_svc_storage_init_file(o, flags & TEE_DATA_FLAG_OVERWRITE,
 1121f90:	f94043fc 	ldr	x28, [sp, #128]
	const struct tee_file_operations *fops = o->pobj->fops;
 1121f94:	f9402019 	ldr	x25, [x0, #64]
	if (attr_o) {
 1121f98:	b50002dc 	cbnz	x28, 1121ff0 <syscall_storage_obj_create+0x1d8>
		res = tee_obj_set_type(o, TEE_TYPE_DATA, 0);
 1121f9c:	528017e1 	mov	w1, #0xbf                  	// #191
 1121fa0:	aa1b03e0 	mov	x0, x27
 1121fa4:	d2800002 	mov	x2, #0x0                   	// #0
 1121fa8:	72b40001 	movk	w1, #0xa000, lsl #16
 1121fac:	97fff370 	bl	111ed6c <tee_obj_set_type>
 1121fb0:	2a0003f3 	mov	w19, w0
		if (res != TEE_SUCCESS)
 1121fb4:	34000520 	cbz	w0, 1122058 <syscall_storage_obj_create+0x240>
 1121fb8:	1400004c 	b	11220e8 <syscall_storage_obj_create+0x2d0>
		res = tee_obj_get(utc, uref_to_vaddr(attr), &attr_o);
 1121fbc:	b94073e0 	ldr	w0, [sp, #112]
 1121fc0:	97ffcc3e 	bl	11150b8 <uref_to_vaddr>
 1121fc4:	aa0003e1 	mov	x1, x0
 1121fc8:	910203e2 	add	x2, sp, #0x80
 1121fcc:	aa1503e0 	mov	x0, x21
 1121fd0:	94000feb 	bl	1125f7c <tee_obj_get>
 1121fd4:	2a0003f3 	mov	w19, w0
		if (res != TEE_SUCCESS)
 1121fd8:	35fff860 	cbnz	w0, 1121ee4 <syscall_storage_obj_create+0xcc>
		if (!(attr_o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED)) {
 1121fdc:	f94043e0 	ldr	x0, [sp, #128]
 1121fe0:	b9402800 	ldr	w0, [x0, #40]
 1121fe4:	378ffd20 	tbnz	w0, #17, 1121f88 <syscall_storage_obj_create+0x170>
			res = TEE_ERROR_BAD_PARAMETERS;
 1121fe8:	129fff33 	mov	w19, #0xffff0006            	// #-65530
 1121fec:	17ffffbe 	b	1121ee4 <syscall_storage_obj_create+0xcc>
		res = tee_obj_set_type(o, attr_o->info.objectType,
 1121ff0:	b9401381 	ldr	w1, [x28, #16]
 1121ff4:	aa1b03e0 	mov	x0, x27
 1121ff8:	b9401b82 	ldr	w2, [x28, #24]
 1121ffc:	97fff35c 	bl	111ed6c <tee_obj_set_type>
 1122000:	2a0003f3 	mov	w19, w0
		if (res)
 1122004:	35fff700 	cbnz	w0, 1121ee4 <syscall_storage_obj_create+0xcc>
		res = tee_obj_attr_copy_from(o, attr_o);
 1122008:	aa1c03e1 	mov	x1, x28
 112200c:	aa1b03e0 	mov	x0, x27
 1122010:	97fff2c9 	bl	111eb34 <tee_obj_attr_copy_from>
 1122014:	2a0003f3 	mov	w19, w0
		if (res)
 1122018:	35fff660 	cbnz	w0, 1121ee4 <syscall_storage_obj_create+0xcc>
		o->have_attrs = attr_o->have_attrs;
 112201c:	b9403380 	ldr	w0, [x28, #48]
		res = tee_obj_attr_to_binary(o, NULL, &attr_size);
 1122020:	910243fa 	add	x26, sp, #0x90
		o->have_attrs = attr_o->have_attrs;
 1122024:	b9003360 	str	w0, [x27, #48]
		res = tee_obj_attr_to_binary(o, NULL, &attr_size);
 1122028:	aa1a03e2 	mov	x2, x26
		o->info.objectUsage = attr_o->info.objectUsage;
 112202c:	b9401f80 	ldr	w0, [x28, #28]
		res = tee_obj_attr_to_binary(o, NULL, &attr_size);
 1122030:	d2800001 	mov	x1, #0x0                   	// #0
		o->info.objectUsage = attr_o->info.objectUsage;
 1122034:	b9001f60 	str	w0, [x27, #28]
		o->info.keySize = attr_o->info.keySize;
 1122038:	b9401780 	ldr	w0, [x28, #20]
 112203c:	b9001760 	str	w0, [x27, #20]
		res = tee_obj_attr_to_binary(o, NULL, &attr_size);
 1122040:	aa1b03e0 	mov	x0, x27
 1122044:	97fff23e 	bl	111e93c <tee_obj_attr_to_binary>
 1122048:	2a0003f3 	mov	w19, w0
		if (res)
 112204c:	35fff4c0 	cbnz	w0, 1121ee4 <syscall_storage_obj_create+0xcc>
		if (attr_size) {
 1122050:	f9404be0 	ldr	x0, [sp, #144]
 1122054:	b5000380 	cbnz	x0, 11220c4 <syscall_storage_obj_create+0x2ac>
	void *attr = NULL;
 1122058:	d280001c 	mov	x28, #0x0                   	// #0
	o->ds_pos = sizeof(struct tee_svc_storage_head) + attr_size;
 112205c:	f9404be5 	ldr	x5, [sp, #144]
	res = fops->create(o->pobj, overwrite, &head, sizeof(head), attr,
 1122060:	2a1603e7 	mov	w7, w22
 1122064:	aa1803e6 	mov	x6, x24
 1122068:	aa1c03e4 	mov	x4, x28
	o->ds_pos = sizeof(struct tee_svc_storage_head) + attr_size;
 112206c:	910060a0 	add	x0, x5, #0x18
 1122070:	f9002360 	str	x0, [x27, #64]
	head.keySize = o->info.keySize;
 1122074:	b9401760 	ldr	w0, [x27, #20]
	res = fops->create(o->pobj, overwrite, &head, sizeof(head), attr,
 1122078:	910263e2 	add	x2, sp, #0x98
	head.keySize = o->info.keySize;
 112207c:	291303e5 	stp	w5, w0, [sp, #152]
	res = fops->create(o->pobj, overwrite, &head, sizeof(head), attr,
 1122080:	530a2ae1 	ubfx	w1, w23, #10, #1
	head.maxKeySize = o->info.maxKeySize;
 1122084:	f9400f60 	ldr	x0, [x27, #24]
 1122088:	f90053e0 	str	x0, [sp, #160]
	head.objectType = o->info.objectType;
 112208c:	b9401360 	ldr	w0, [x27, #16]
	res = fops->create(o->pobj, overwrite, &head, sizeof(head), attr,
 1122090:	d2800303 	mov	x3, #0x18                  	// #24
	head.objectType = o->info.objectType;
 1122094:	b900abe0 	str	w0, [sp, #168]
	head.have_attrs = o->have_attrs;
 1122098:	b9403360 	ldr	w0, [x27, #48]
 112209c:	b900afe0 	str	w0, [sp, #172]
	res = fops->create(o->pobj, overwrite, &head, sizeof(head), attr,
 11220a0:	91014360 	add	x0, x27, #0x50
 11220a4:	f90003e0 	str	x0, [sp]
 11220a8:	f9400728 	ldr	x8, [x25, #8]
 11220ac:	f9402760 	ldr	x0, [x27, #72]
 11220b0:	d63f0100 	blr	x8
 11220b4:	2a0003f3 	mov	w19, w0
	if (!res)
 11220b8:	35000180 	cbnz	w0, 11220e8 <syscall_storage_obj_create+0x2d0>
	res = tee_svc_storage_init_file(o, flags & TEE_DATA_FLAG_OVERWRITE,
 11220bc:	b9002376 	str	w22, [x27, #32]
 11220c0:	1400000a 	b	11220e8 <syscall_storage_obj_create+0x2d0>
			attr = malloc(attr_size);
 11220c4:	940084e5 	bl	1143458 <malloc>
 11220c8:	aa0003fc 	mov	x28, x0
			if (!attr)
 11220cc:	b4fff0a0 	cbz	x0, 1121ee0 <syscall_storage_obj_create+0xc8>
			res = tee_obj_attr_to_binary(o, attr, &attr_size);
 11220d0:	aa0003e1 	mov	x1, x0
 11220d4:	aa1a03e2 	mov	x2, x26
 11220d8:	aa1b03e0 	mov	x0, x27
 11220dc:	97fff218 	bl	111e93c <tee_obj_attr_to_binary>
 11220e0:	2a0003f3 	mov	w19, w0
			if (res != TEE_SUCCESS)
 11220e4:	34fffbc0 	cbz	w0, 112205c <syscall_storage_obj_create+0x244>
	free(attr);
 11220e8:	aa1c03e0 	mov	x0, x28
 11220ec:	9400853d 	bl	11435e0 <free>
	if (res != TEE_SUCCESS)
 11220f0:	35ffefb3 	cbnz	w19, 1121ee4 <syscall_storage_obj_create+0xcc>
	tee_obj_add(utc, o);
 11220f4:	aa1b03e1 	mov	x1, x27
 11220f8:	aa1503e0 	mov	x0, x21
	po = NULL; /* o owns it from now on */
 11220fc:	f90047ff 	str	xzr, [sp, #136]
	tee_obj_add(utc, o);
 1122100:	94000f9a 	bl	1125f68 <tee_obj_add>
	res = copy_kaddr_to_uref(obj, o);
 1122104:	f9403fe0 	ldr	x0, [sp, #120]
 1122108:	aa1b03e1 	mov	x1, x27
 112210c:	97ffcbdd 	bl	1115080 <copy_kaddr_to_uref>
 1122110:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 1122114:	340001a0 	cbz	w0, 1122148 <syscall_storage_obj_create+0x330>
	tee_obj_close(utc, o);
 1122118:	aa1b03e1 	mov	x1, x27
 112211c:	aa1503e0 	mov	x0, x21
 1122120:	94000fb2 	bl	1125fe8 <tee_obj_close>

	return res;
}
 1122124:	2a1303e0 	mov	w0, w19
 1122128:	a9417bfd 	ldp	x29, x30, [sp, #16]
 112212c:	a94253f3 	ldp	x19, x20, [sp, #32]
 1122130:	a9435bf5 	ldp	x21, x22, [sp, #48]
 1122134:	a94463f7 	ldp	x23, x24, [sp, #64]
 1122138:	a9456bf9 	ldp	x25, x26, [sp, #80]
 112213c:	a94673fb 	ldp	x27, x28, [sp, #96]
 1122140:	9102c3ff 	add	sp, sp, #0xb0
 1122144:	d65f03c0 	ret
	tee_pobj_create_final(o->pobj);
 1122148:	f9402760 	ldr	x0, [x27, #72]
 112214c:	94001043 	bl	1126258 <tee_pobj_create_final>
	return TEE_SUCCESS;
 1122150:	17fffff5 	b	1122124 <syscall_storage_obj_create+0x30c>
	struct tee_obj *o = NULL;
 1122154:	d280001b 	mov	x27, #0x0                   	// #0
 1122158:	17ffffa4 	b	1121fe8 <syscall_storage_obj_create+0x1d0>
		return TEE_ERROR_ITEM_NOT_FOUND;
 112215c:	129ffef3 	mov	w19, #0xffff0008            	// #-65528
 1122160:	17fffff1 	b	1122124 <syscall_storage_obj_create+0x30c>
		return TEE_ERROR_BAD_PARAMETERS;
 1122164:	129fff33 	mov	w19, #0xffff0006            	// #-65530
 1122168:	17ffffef 	b	1122124 <syscall_storage_obj_create+0x30c>

000000000112216c <syscall_storage_obj_del>:

TEE_Result syscall_storage_obj_del(unsigned long obj)
{
 112216c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1122170:	910003fd 	mov	x29, sp
 1122174:	a90153f3 	stp	x19, x20, [sp, #16]
 1122178:	aa0003f3 	mov	x19, x0
	struct ts_session *sess = ts_get_current_session();
 112217c:	97ffca19 	bl	11149e0 <ts_get_current_session>
	struct user_ta_ctx *utc = to_user_ta_ctx(sess->ctx);
 1122180:	f9400800 	ldr	x0, [x0, #16]
 1122184:	97fffe7b 	bl	1121b70 <to_user_ta_ctx>
 1122188:	aa0003f4 	mov	x20, x0
	TEE_Result res = TEE_SUCCESS;
	struct tee_obj *o = NULL;
	uint8_t *data = NULL;
	size_t len = 0;

	res = tee_obj_get(utc, uref_to_vaddr(obj), &o);
 112218c:	2a1303e0 	mov	w0, w19
	struct tee_obj *o = NULL;
 1122190:	f90017ff 	str	xzr, [sp, #40]
	res = tee_obj_get(utc, uref_to_vaddr(obj), &o);
 1122194:	97ffcbc9 	bl	11150b8 <uref_to_vaddr>
 1122198:	aa0003e1 	mov	x1, x0
 112219c:	9100a3e2 	add	x2, sp, #0x28
 11221a0:	aa1403e0 	mov	x0, x20
 11221a4:	94000f76 	bl	1125f7c <tee_obj_get>
 11221a8:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 11221ac:	350001e0 	cbnz	w0, 11221e8 <syscall_storage_obj_del+0x7c>
		return res;

	if (!(o->info.handleFlags & TEE_DATA_FLAG_ACCESS_WRITE_META))
 11221b0:	f94017e0 	ldr	x0, [sp, #40]
 11221b4:	b9402801 	ldr	w1, [x0, #40]
 11221b8:	36100201 	tbz	w1, #2, 11221f8 <syscall_storage_obj_del+0x8c>
		return TEE_ERROR_ACCESS_CONFLICT;

	if (o->pobj == NULL || o->pobj->obj_id == NULL)
 11221bc:	f9402400 	ldr	x0, [x0, #72]
 11221c0:	b4000200 	cbz	x0, 1122200 <syscall_storage_obj_del+0x94>
 11221c4:	f9401401 	ldr	x1, [x0, #40]
 11221c8:	b40001c1 	cbz	x1, 1122200 <syscall_storage_obj_del+0x94>
		if (res == TEE_SUCCESS)
			crypto_storage_obj_del(data, len);
		free(data);
	}

	res = o->pobj->fops->remove(o->pobj);
 11221cc:	f9402001 	ldr	x1, [x0, #64]
 11221d0:	f9401821 	ldr	x1, [x1, #48]
 11221d4:	d63f0020 	blr	x1
 11221d8:	2a0003f3 	mov	w19, w0
	tee_obj_close(utc, o);
 11221dc:	f94017e1 	ldr	x1, [sp, #40]
 11221e0:	aa1403e0 	mov	x0, x20
 11221e4:	94000f81 	bl	1125fe8 <tee_obj_close>

	return res;
}
 11221e8:	2a1303e0 	mov	w0, w19
 11221ec:	a94153f3 	ldp	x19, x20, [sp, #16]
 11221f0:	a8c37bfd 	ldp	x29, x30, [sp], #48
 11221f4:	d65f03c0 	ret
		return TEE_ERROR_ACCESS_CONFLICT;
 11221f8:	129fff93 	mov	w19, #0xffff0003            	// #-65533
 11221fc:	17fffffb 	b	11221e8 <syscall_storage_obj_del+0x7c>
		return TEE_ERROR_BAD_STATE;
 1122200:	129fff13 	mov	w19, #0xffff0007            	// #-65529
 1122204:	17fffff9 	b	11221e8 <syscall_storage_obj_del+0x7c>

0000000001122208 <syscall_storage_obj_rename>:

TEE_Result syscall_storage_obj_rename(unsigned long obj, void *object_id,
				      size_t object_id_len)
{
 1122208:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 112220c:	910003fd 	mov	x29, sp
 1122210:	a90153f3 	stp	x19, x20, [sp, #16]
 1122214:	aa0203f4 	mov	x20, x2
 1122218:	aa0003f3 	mov	x19, x0
 112221c:	a9025bf5 	stp	x21, x22, [sp, #32]
 1122220:	aa0103f5 	mov	x21, x1
 1122224:	f9001bf7 	str	x23, [sp, #48]
	const struct tee_file_operations *fops = NULL;
	struct ts_session *sess = ts_get_current_session();
 1122228:	97ffc9ee 	bl	11149e0 <ts_get_current_session>
 112222c:	aa0003f6 	mov	x22, x0
	struct user_ta_ctx *utc = to_user_ta_ctx(sess->ctx);
 1122230:	f9400800 	ldr	x0, [x0, #16]
 1122234:	97fffe4f 	bl	1121b70 <to_user_ta_ctx>
	TEE_Result res = TEE_SUCCESS;
	struct tee_pobj *po = NULL;
	struct tee_obj *o = NULL;
 1122238:	a9047fff 	stp	xzr, xzr, [sp, #64]
	char *new_file = NULL;
	char *old_file = NULL;

	if (object_id_len > TEE_OBJECT_ID_MAX_LEN)
 112223c:	f101029f 	cmp	x20, #0x40
 1122240:	540007e8 	b.hi	112233c <syscall_storage_obj_rename+0x134>  // b.pmore
 1122244:	aa0003f7 	mov	x23, x0
		return TEE_ERROR_BAD_PARAMETERS;

	res = tee_obj_get(utc, uref_to_vaddr(obj), &o);
 1122248:	2a1303e0 	mov	w0, w19
 112224c:	97ffcb9b 	bl	11150b8 <uref_to_vaddr>
 1122250:	aa0003e1 	mov	x1, x0
 1122254:	910123e2 	add	x2, sp, #0x48
 1122258:	aa1703e0 	mov	x0, x23
 112225c:	94000f48 	bl	1125f7c <tee_obj_get>
 1122260:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 1122264:	350005c0 	cbnz	w0, 112231c <syscall_storage_obj_rename+0x114>
		return res;

	if (!(o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT)) {
 1122268:	f94027e0 	ldr	x0, [sp, #72]
		res = TEE_ERROR_BAD_STATE;
		goto exit;
	}

	if (!(o->info.handleFlags & TEE_DATA_FLAG_ACCESS_WRITE_META)) {
 112226c:	52800081 	mov	w1, #0x4                   	// #4
 1122270:	72a00021 	movk	w1, #0x1, lsl #16
 1122274:	b9402802 	ldr	w2, [x0, #40]
 1122278:	6a22003f 	bics	wzr, w1, w2
 112227c:	540005c1 	b.ne	1122334 <syscall_storage_obj_rename+0x12c>  // b.any
		res = TEE_ERROR_BAD_STATE;
		goto exit;
	}

	if (o->pobj == NULL || o->pobj->obj_id == NULL) {
 1122280:	f9402400 	ldr	x0, [x0, #72]
 1122284:	b4000580 	cbz	x0, 1122334 <syscall_storage_obj_rename+0x12c>
 1122288:	f9401400 	ldr	x0, [x0, #40]
 112228c:	b4000540 	cbz	x0, 1122334 <syscall_storage_obj_rename+0x12c>
		res = TEE_ERROR_BAD_STATE;
		goto exit;
	}

	res = vm_check_access_rights(&utc->uctx, TEE_MEMORY_ACCESS_READ,
 1122290:	aa1403e3 	mov	x3, x20
 1122294:	aa1503e2 	mov	x2, x21
 1122298:	910142e0 	add	x0, x23, #0x50
 112229c:	52800021 	mov	w1, #0x1                   	// #1
 11222a0:	97ffdd53 	bl	11197ec <vm_check_access_rights>
 11222a4:	2a0003f3 	mov	w19, w0
				     (uaddr_t)object_id, object_id_len);
	if (res != TEE_SUCCESS)
 11222a8:	35000360 	cbnz	w0, 1122314 <syscall_storage_obj_rename+0x10c>
		goto exit;

	/* reserve dest name */
	fops = o->pobj->fops;
 11222ac:	f94027e0 	ldr	x0, [sp, #72]
	res = tee_pobj_get((void *)&sess->ctx->uuid, object_id,
 11222b0:	910103e6 	add	x6, sp, #0x40
 11222b4:	2a1403e2 	mov	w2, w20
 11222b8:	aa1503e1 	mov	x1, x21
 11222bc:	52800024 	mov	w4, #0x1                   	// #1
 11222c0:	52800083 	mov	w3, #0x4                   	// #4
	fops = o->pobj->fops;
 11222c4:	f9402400 	ldr	x0, [x0, #72]
 11222c8:	f9402017 	ldr	x23, [x0, #64]
	res = tee_pobj_get((void *)&sess->ctx->uuid, object_id,
 11222cc:	f9400ac0 	ldr	x0, [x22, #16]
 11222d0:	aa1703e5 	mov	x5, x23
 11222d4:	94000f6a 	bl	112607c <tee_pobj_get>
 11222d8:	2a0003f3 	mov	w19, w0
			   object_id_len, TEE_DATA_FLAG_ACCESS_WRITE_META,
			   TEE_POBJ_USAGE_RENAME, fops, &po);
	if (res != TEE_SUCCESS)
 11222dc:	350001c0 	cbnz	w0, 1122314 <syscall_storage_obj_rename+0x10c>
		goto exit;

	/* move */
	res = fops->rename(o->pobj, po, false /* no overwrite */);
 11222e0:	a94403e1 	ldp	x1, x0, [sp, #64]
 11222e4:	52800002 	mov	w2, #0x0                   	// #0
 11222e8:	f94016e3 	ldr	x3, [x23, #40]
 11222ec:	f9402400 	ldr	x0, [x0, #72]
 11222f0:	d63f0060 	blr	x3
 11222f4:	2a0003f3 	mov	w19, w0
	if (res)
 11222f8:	350000e0 	cbnz	w0, 1122314 <syscall_storage_obj_rename+0x10c>
		goto exit;

	res = tee_pobj_rename(o->pobj, object_id, object_id_len);
 11222fc:	f94027e0 	ldr	x0, [sp, #72]
 1122300:	2a1403e2 	mov	w2, w20
 1122304:	aa1503e1 	mov	x1, x21
 1122308:	f9402400 	ldr	x0, [x0, #72]
 112230c:	94001000 	bl	112630c <tee_pobj_rename>
 1122310:	2a0003f3 	mov	w19, w0

exit:
	tee_pobj_release(po);
 1122314:	f94023e0 	ldr	x0, [sp, #64]
 1122318:	94000fdd 	bl	112628c <tee_pobj_release>

	free(new_file);
	free(old_file);

	return res;
}
 112231c:	2a1303e0 	mov	w0, w19
 1122320:	a94153f3 	ldp	x19, x20, [sp, #16]
 1122324:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1122328:	f9401bf7 	ldr	x23, [sp, #48]
 112232c:	a8c57bfd 	ldp	x29, x30, [sp], #80
 1122330:	d65f03c0 	ret
		res = TEE_ERROR_BAD_STATE;
 1122334:	129fff13 	mov	w19, #0xffff0007            	// #-65529
 1122338:	17fffff7 	b	1122314 <syscall_storage_obj_rename+0x10c>
		return TEE_ERROR_BAD_PARAMETERS;
 112233c:	129fff33 	mov	w19, #0xffff0006            	// #-65530
 1122340:	17fffff7 	b	112231c <syscall_storage_obj_rename+0x114>

0000000001122344 <syscall_storage_alloc_enum>:

TEE_Result syscall_storage_alloc_enum(uint32_t *obj_enum)
{
 1122344:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1122348:	910003fd 	mov	x29, sp
 112234c:	a90153f3 	stp	x19, x20, [sp, #16]
 1122350:	aa0003f3 	mov	x19, x0
	struct ts_session *sess = ts_get_current_session();
 1122354:	97ffc9a3 	bl	11149e0 <ts_get_current_session>
	struct user_ta_ctx *utc = to_user_ta_ctx(sess->ctx);
 1122358:	f9400800 	ldr	x0, [x0, #16]
 112235c:	97fffe05 	bl	1121b70 <to_user_ta_ctx>
	struct tee_storage_enum *e = NULL;

	if (obj_enum == NULL)
 1122360:	b40001f3 	cbz	x19, 112239c <syscall_storage_alloc_enum+0x58>
 1122364:	aa0003f4 	mov	x20, x0
		return TEE_ERROR_BAD_PARAMETERS;

	e = malloc(sizeof(struct tee_storage_enum));
 1122368:	d2800400 	mov	x0, #0x20                  	// #32
 112236c:	9400843b 	bl	1143458 <malloc>
 1122370:	aa0003e1 	mov	x1, x0
	if (e == NULL)
 1122374:	b40001c0 	cbz	x0, 11223ac <syscall_storage_alloc_enum+0x68>
		return TEE_ERROR_OUT_OF_MEMORY;

	e->dir = NULL;
	e->fops = NULL;
	TAILQ_INSERT_TAIL(&utc->storage_enums, e, link);
 1122378:	f9401e80 	ldr	x0, [x20, #56]
 112237c:	a900003f 	stp	xzr, x0, [x1]
	e->fops = NULL;
 1122380:	a9017c3f 	stp	xzr, xzr, [x1, #16]
	TAILQ_INSERT_TAIL(&utc->storage_enums, e, link);
 1122384:	f9000001 	str	x1, [x0]

	return copy_kaddr_to_uref(obj_enum, e);
 1122388:	aa1303e0 	mov	x0, x19
	TAILQ_INSERT_TAIL(&utc->storage_enums, e, link);
 112238c:	f9001e81 	str	x1, [x20, #56]
}
 1122390:	a94153f3 	ldp	x19, x20, [sp, #16]
 1122394:	a8c27bfd 	ldp	x29, x30, [sp], #32
	return copy_kaddr_to_uref(obj_enum, e);
 1122398:	17ffcb3a 	b	1115080 <copy_kaddr_to_uref>
		return TEE_ERROR_BAD_PARAMETERS;
 112239c:	129fff20 	mov	w0, #0xffff0006            	// #-65530
}
 11223a0:	a94153f3 	ldp	x19, x20, [sp, #16]
 11223a4:	a8c27bfd 	ldp	x29, x30, [sp], #32
 11223a8:	d65f03c0 	ret
		return TEE_ERROR_OUT_OF_MEMORY;
 11223ac:	129ffe60 	mov	w0, #0xffff000c            	// #-65524
 11223b0:	17fffffc 	b	11223a0 <syscall_storage_alloc_enum+0x5c>

00000000011223b4 <syscall_storage_free_enum>:

TEE_Result syscall_storage_free_enum(unsigned long obj_enum)
{
 11223b4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 11223b8:	910003fd 	mov	x29, sp
 11223bc:	a90153f3 	stp	x19, x20, [sp, #16]
 11223c0:	aa0003f4 	mov	x20, x0
	struct ts_session *sess = ts_get_current_session();
 11223c4:	97ffc987 	bl	11149e0 <ts_get_current_session>
	struct user_ta_ctx *utc = to_user_ta_ctx(sess->ctx);
 11223c8:	f9400800 	ldr	x0, [x0, #16]
 11223cc:	97fffde9 	bl	1121b70 <to_user_ta_ctx>
 11223d0:	aa0003f3 	mov	x19, x0
	struct tee_storage_enum *e = NULL;
	TEE_Result res = TEE_SUCCESS;

	res = tee_svc_storage_get_enum(utc,
 11223d4:	2a1403e0 	mov	w0, w20
 11223d8:	97ffcb38 	bl	11150b8 <uref_to_vaddr>
 11223dc:	f9401a61 	ldr	x1, [x19, #48]
	TAILQ_FOREACH(e, &utc->storage_enums, link) {
 11223e0:	b50000a1 	cbnz	x1, 11223f4 <syscall_storage_free_enum+0x40>
			uref_to_vaddr(obj_enum), &e);
	if (res != TEE_SUCCESS)
		return res;

	return tee_svc_close_enum(utc, e);
}
 11223e4:	129fff20 	mov	w0, #0xffff0006            	// #-65530
 11223e8:	a94153f3 	ldp	x19, x20, [sp, #16]
 11223ec:	a8c27bfd 	ldp	x29, x30, [sp], #32
 11223f0:	d65f03c0 	ret
		if (enum_id == (vaddr_t)e) {
 11223f4:	eb00003f 	cmp	x1, x0
 11223f8:	54000060 	b.eq	1122404 <syscall_storage_free_enum+0x50>  // b.none
	TAILQ_FOREACH(e, &utc->storage_enums, link) {
 11223fc:	f9400021 	ldr	x1, [x1]
 1122400:	17fffff8 	b	11223e0 <syscall_storage_free_enum+0x2c>
	return tee_svc_close_enum(utc, e);
 1122404:	aa1303e0 	mov	x0, x19
}
 1122408:	a94153f3 	ldp	x19, x20, [sp, #16]
 112240c:	a8c27bfd 	ldp	x29, x30, [sp], #32
	return tee_svc_close_enum(utc, e);
 1122410:	17fffd42 	b	1121918 <tee_svc_close_enum>

0000000001122414 <syscall_storage_reset_enum>:

TEE_Result syscall_storage_reset_enum(unsigned long obj_enum)
{
 1122414:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1122418:	910003fd 	mov	x29, sp
 112241c:	a90153f3 	stp	x19, x20, [sp, #16]
 1122420:	aa0003f4 	mov	x20, x0
	struct ts_session *sess = ts_get_current_session();
 1122424:	97ffc96f 	bl	11149e0 <ts_get_current_session>
	struct tee_storage_enum *e = NULL;
	TEE_Result res = TEE_SUCCESS;

	res = tee_svc_storage_get_enum(to_user_ta_ctx(sess->ctx),
 1122428:	f9400800 	ldr	x0, [x0, #16]
 112242c:	97fffdd1 	bl	1121b70 <to_user_ta_ctx>
 1122430:	aa0003f3 	mov	x19, x0
 1122434:	2a1403e0 	mov	w0, w20
 1122438:	97ffcb20 	bl	11150b8 <uref_to_vaddr>
 112243c:	f9401a73 	ldr	x19, [x19, #48]
	TAILQ_FOREACH(e, &utc->storage_enums, link) {
 1122440:	b50000b3 	cbnz	x19, 1122454 <syscall_storage_reset_enum+0x40>
	return TEE_ERROR_BAD_PARAMETERS;
 1122444:	129fff20 	mov	w0, #0xffff0006            	// #-65530
		e->dir = NULL;
	}
	assert(!e->dir);

	return TEE_SUCCESS;
}
 1122448:	a94153f3 	ldp	x19, x20, [sp, #16]
 112244c:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1122450:	d65f03c0 	ret
		if (enum_id == (vaddr_t)e) {
 1122454:	eb00027f 	cmp	x19, x0
 1122458:	54000120 	b.eq	112247c <syscall_storage_reset_enum+0x68>  // b.none
	TAILQ_FOREACH(e, &utc->storage_enums, link) {
 112245c:	f9400273 	ldr	x19, [x19]
 1122460:	17fffff8 	b	1122440 <syscall_storage_reset_enum+0x2c>
		e->fops->closedir(e->dir);
 1122464:	f9402802 	ldr	x2, [x0, #80]
 1122468:	aa0103e0 	mov	x0, x1
 112246c:	d63f0040 	blr	x2
		e->fops = NULL;
 1122470:	a9017e7f 	stp	xzr, xzr, [x19, #16]
	return TEE_SUCCESS;
 1122474:	52800000 	mov	w0, #0x0                   	// #0
 1122478:	17fffff4 	b	1122448 <syscall_storage_reset_enum+0x34>
	if (e->fops) {
 112247c:	a9410261 	ldp	x1, x0, [x19, #16]
 1122480:	b5ffff20 	cbnz	x0, 1122464 <syscall_storage_reset_enum+0x50>
	return TEE_SUCCESS;
 1122484:	52800000 	mov	w0, #0x0                   	// #0
	assert(!e->dir);
 1122488:	b4fffe01 	cbz	x1, 1122448 <syscall_storage_reset_enum+0x34>
 112248c:	f0000183 	adrp	x3, 1155000 <__func__.3826+0xa8>
 1122490:	f0000181 	adrp	x1, 1155000 <__func__.3826+0xa8>
 1122494:	91288463 	add	x3, x3, #0xa21
 1122498:	91257821 	add	x1, x1, #0x95e
 112249c:	f0000180 	adrp	x0, 1155000 <__func__.3826+0xa8>
 11224a0:	91267000 	add	x0, x0, #0x99c
 11224a4:	52805342 	mov	w2, #0x29a                 	// #666
 11224a8:	97ffbf81 	bl	11122ac <_assert_log>
 11224ac:	97ffbf91 	bl	11122f0 <_assert_break>

00000000011224b0 <syscall_storage_start_enum>:

TEE_Result syscall_storage_start_enum(unsigned long obj_enum,
				      unsigned long storage_id)
{
 11224b0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 11224b4:	910003fd 	mov	x29, sp
 11224b8:	a90153f3 	stp	x19, x20, [sp, #16]
 11224bc:	a9025bf5 	stp	x21, x22, [sp, #32]
 11224c0:	aa0103f5 	mov	x21, x1
 11224c4:	aa0003f6 	mov	x22, x0
	struct ts_session *sess = ts_get_current_session();
 11224c8:	97ffc946 	bl	11149e0 <ts_get_current_session>
 11224cc:	aa0003f4 	mov	x20, x0
	struct tee_storage_enum *e = NULL;
	TEE_Result res = TEE_SUCCESS;
	const struct tee_file_operations *fops =
			tee_svc_storage_file_ops(storage_id);

	res = tee_svc_storage_get_enum(to_user_ta_ctx(sess->ctx),
 11224d0:	f9400800 	ldr	x0, [x0, #16]
 11224d4:	97fffda7 	bl	1121b70 <to_user_ta_ctx>
 11224d8:	aa0003f3 	mov	x19, x0
 11224dc:	2a1603e0 	mov	w0, w22
 11224e0:	97ffcaf6 	bl	11150b8 <uref_to_vaddr>
 11224e4:	f9401a73 	ldr	x19, [x19, #48]
	TAILQ_FOREACH(e, &utc->storage_enums, link) {
 11224e8:	b50000d3 	cbnz	x19, 1122500 <syscall_storage_start_enum+0x50>
	return TEE_ERROR_BAD_PARAMETERS;
 11224ec:	129fff20 	mov	w0, #0xffff0006            	// #-65530
		return TEE_ERROR_ITEM_NOT_FOUND;

	e->fops = fops;

	return fops->opendir(&sess->ctx->uuid, &e->dir);
}
 11224f0:	a94153f3 	ldp	x19, x20, [sp, #16]
 11224f4:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11224f8:	a8c37bfd 	ldp	x29, x30, [sp], #48
 11224fc:	d65f03c0 	ret
		if (enum_id == (vaddr_t)e) {
 1122500:	eb00027f 	cmp	x19, x0
 1122504:	540000a0 	b.eq	1122518 <syscall_storage_start_enum+0x68>  // b.none
	TAILQ_FOREACH(e, &utc->storage_enums, link) {
 1122508:	f9400273 	ldr	x19, [x19]
 112250c:	17fffff7 	b	11224e8 <syscall_storage_start_enum+0x38>
		return TEE_ERROR_ITEM_NOT_FOUND;
 1122510:	129ffee0 	mov	w0, #0xffff0008            	// #-65528
 1122514:	17fffff7 	b	11224f0 <syscall_storage_start_enum+0x40>
	if (e->dir) {
 1122518:	f9400a60 	ldr	x0, [x19, #16]
 112251c:	b40000a0 	cbz	x0, 1122530 <syscall_storage_start_enum+0x80>
		e->fops->closedir(e->dir);
 1122520:	f9400e61 	ldr	x1, [x19, #24]
 1122524:	f9402821 	ldr	x1, [x1, #80]
 1122528:	d63f0020 	blr	x1
		e->dir = NULL;
 112252c:	f9000a7f 	str	xzr, [x19, #16]
			tee_svc_storage_file_ops(storage_id);
 1122530:	2a1503e0 	mov	w0, w21
 1122534:	97fffdb4 	bl	1121c04 <tee_svc_storage_file_ops>
	if (!fops)
 1122538:	b4fffec0 	cbz	x0, 1122510 <syscall_storage_start_enum+0x60>
}
 112253c:	a9425bf5 	ldp	x21, x22, [sp, #32]
	return fops->opendir(&sess->ctx->uuid, &e->dir);
 1122540:	91004261 	add	x1, x19, #0x10
 1122544:	f9402002 	ldr	x2, [x0, #64]
	e->fops = fops;
 1122548:	f9000e60 	str	x0, [x19, #24]
	return fops->opendir(&sess->ctx->uuid, &e->dir);
 112254c:	f9400a80 	ldr	x0, [x20, #16]
 1122550:	aa0203f0 	mov	x16, x2
}
 1122554:	a94153f3 	ldp	x19, x20, [sp, #16]
 1122558:	a8c37bfd 	ldp	x29, x30, [sp], #48
	return fops->opendir(&sess->ctx->uuid, &e->dir);
 112255c:	d61f0200 	br	x16

0000000001122560 <syscall_storage_next_enum>:

TEE_Result syscall_storage_next_enum(unsigned long obj_enum,
			TEE_ObjectInfo *info, void *obj_id, uint64_t *len)
{
 1122560:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
 1122564:	910003fd 	mov	x29, sp
 1122568:	a90153f3 	stp	x19, x20, [sp, #16]
 112256c:	aa0003f3 	mov	x19, x0
 1122570:	a9025bf5 	stp	x21, x22, [sp, #32]
 1122574:	aa0103f5 	mov	x21, x1
 1122578:	aa0203f6 	mov	x22, x2
 112257c:	a90363f7 	stp	x23, x24, [sp, #48]
 1122580:	aa0303f7 	mov	x23, x3
 1122584:	f90023f9 	str	x25, [sp, #64]
	struct ts_session *sess = ts_get_current_session();
 1122588:	97ffc916 	bl	11149e0 <ts_get_current_session>
 112258c:	aa0003f8 	mov	x24, x0
	struct user_ta_ctx *utc = to_user_ta_ctx(sess->ctx);
 1122590:	f9400800 	ldr	x0, [x0, #16]
 1122594:	97fffd77 	bl	1121b70 <to_user_ta_ctx>
 1122598:	aa0003f4 	mov	x20, x0
	struct tee_fs_dirent *d = NULL;
	TEE_Result res = TEE_SUCCESS;
	struct tee_obj *o = NULL;
	uint64_t l = 0;

	res = tee_svc_storage_get_enum(utc, uref_to_vaddr(obj_enum), &e);
 112259c:	2a1303e0 	mov	w0, w19
	uint64_t l = 0;
 11225a0:	a9057fff 	stp	xzr, xzr, [sp, #80]
	res = tee_svc_storage_get_enum(utc, uref_to_vaddr(obj_enum), &e);
 11225a4:	97ffcac5 	bl	11150b8 <uref_to_vaddr>
 11225a8:	f9401a99 	ldr	x25, [x20, #48]
	TAILQ_FOREACH(e, &utc->storage_enums, link) {
 11225ac:	b5000139 	cbnz	x25, 11225d0 <syscall_storage_next_enum+0x70>
	return TEE_ERROR_BAD_PARAMETERS;
 11225b0:	129fff33 	mov	w19, #0xffff0006            	// #-65530
		}
		tee_obj_free(o);
	}

	return res;
}
 11225b4:	2a1303e0 	mov	w0, w19
 11225b8:	a94153f3 	ldp	x19, x20, [sp, #16]
 11225bc:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11225c0:	a94363f7 	ldp	x23, x24, [sp, #48]
 11225c4:	f94023f9 	ldr	x25, [sp, #64]
 11225c8:	a8c67bfd 	ldp	x29, x30, [sp], #96
 11225cc:	d65f03c0 	ret
		if (enum_id == (vaddr_t)e) {
 11225d0:	eb00033f 	cmp	x25, x0
 11225d4:	540000e0 	b.eq	11225f0 <syscall_storage_next_enum+0x90>  // b.none
	TAILQ_FOREACH(e, &utc->storage_enums, link) {
 11225d8:	f9400339 	ldr	x25, [x25]
 11225dc:	17fffff4 	b	11225ac <syscall_storage_next_enum+0x4c>
		res = TEE_ERROR_ITEM_NOT_FOUND;
 11225e0:	129ffef3 	mov	w19, #0xffff0008            	// #-65528
 11225e4:	17fffff4 	b	11225b4 <syscall_storage_next_enum+0x54>
		res = TEE_ERROR_OUT_OF_MEMORY;
 11225e8:	129ffe73 	mov	w19, #0xffff000c            	// #-65524
	return res;
 11225ec:	17fffff2 	b	11225b4 <syscall_storage_next_enum+0x54>
	res = vm_check_access_rights(&utc->uctx, TEE_MEMORY_ACCESS_WRITE,
 11225f0:	91014294 	add	x20, x20, #0x50
 11225f4:	aa1503e2 	mov	x2, x21
 11225f8:	aa1403e0 	mov	x0, x20
 11225fc:	d2800383 	mov	x3, #0x1c                  	// #28
 1122600:	52800041 	mov	w1, #0x2                   	// #2
 1122604:	97ffdc7a 	bl	11197ec <vm_check_access_rights>
 1122608:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 112260c:	35fffd40 	cbnz	w0, 11225b4 <syscall_storage_next_enum+0x54>
	res = vm_check_access_rights(&utc->uctx, TEE_MEMORY_ACCESS_WRITE,
 1122610:	aa1603e2 	mov	x2, x22
 1122614:	aa1403e0 	mov	x0, x20
 1122618:	d2800803 	mov	x3, #0x40                  	// #64
 112261c:	52800041 	mov	w1, #0x2                   	// #2
 1122620:	97ffdc73 	bl	11197ec <vm_check_access_rights>
 1122624:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 1122628:	35fffc60 	cbnz	w0, 11225b4 <syscall_storage_next_enum+0x54>
	if (!e->fops) {
 112262c:	f9400f20 	ldr	x0, [x25, #24]
 1122630:	b4fffd80 	cbz	x0, 11225e0 <syscall_storage_next_enum+0x80>
	res = e->fops->readdir(e->dir, &d);
 1122634:	f9402402 	ldr	x2, [x0, #72]
 1122638:	910143e1 	add	x1, sp, #0x50
 112263c:	f9400b20 	ldr	x0, [x25, #16]
 1122640:	d63f0040 	blr	x2
 1122644:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 1122648:	35fffb60 	cbnz	w0, 11225b4 <syscall_storage_next_enum+0x54>
	o = tee_obj_alloc();
 112264c:	94000e57 	bl	1125fa8 <tee_obj_alloc>
 1122650:	aa0003f4 	mov	x20, x0
	if (o == NULL) {
 1122654:	b4fffca0 	cbz	x0, 11225e8 <syscall_storage_next_enum+0x88>
	res = tee_pobj_get(&sess->ctx->uuid, d->oid, d->oidlen, 0,
 1122658:	f9402be1 	ldr	x1, [sp, #80]
 112265c:	91012006 	add	x6, x0, #0x48
 1122660:	f9400b00 	ldr	x0, [x24, #16]
 1122664:	52800064 	mov	w4, #0x3                   	// #3
 1122668:	b9404022 	ldr	w2, [x1, #64]
 112266c:	52800003 	mov	w3, #0x0                   	// #0
 1122670:	f9400f25 	ldr	x5, [x25, #24]
 1122674:	94000e82 	bl	112607c <tee_pobj_get>
 1122678:	2a0003f3 	mov	w19, w0
	if (res)
 112267c:	35000340 	cbnz	w0, 11226e4 <syscall_storage_next_enum+0x184>
	o->info.handleFlags = o->pobj->flags | TEE_HANDLE_FLAG_PERSISTENT |
 1122680:	f9402680 	ldr	x0, [x20, #72]
 1122684:	b9403400 	ldr	w0, [x0, #52]
 1122688:	32100400 	orr	w0, w0, #0x30000
 112268c:	b9002a80 	str	w0, [x20, #40]
	res = tee_svc_storage_read_head(o);
 1122690:	aa1403e0 	mov	x0, x20
 1122694:	97fffcbc 	bl	1121984 <tee_svc_storage_read_head>
 1122698:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 112269c:	35000240 	cbnz	w0, 11226e4 <syscall_storage_next_enum+0x184>
	memcpy(info, &o->info, sizeof(TEE_ObjectInfo));
 11226a0:	91004281 	add	x1, x20, #0x10
 11226a4:	d2800382 	mov	x2, #0x1c                  	// #28
 11226a8:	aa1503e0 	mov	x0, x21
 11226ac:	97ff8339 	bl	1103390 <memcpy>
	memcpy(obj_id, o->pobj->obj_id, o->pobj->obj_id_len);
 11226b0:	f9402680 	ldr	x0, [x20, #72]
 11226b4:	b9403002 	ldr	w2, [x0, #48]
 11226b8:	f9401401 	ldr	x1, [x0, #40]
 11226bc:	aa1603e0 	mov	x0, x22
 11226c0:	97ff8334 	bl	1103390 <memcpy>
	l = o->pobj->obj_id_len;
 11226c4:	f9402680 	ldr	x0, [x20, #72]
	res = copy_to_user_private(len, &l, sizeof(*len));
 11226c8:	910163e1 	add	x1, sp, #0x58
 11226cc:	d2800102 	mov	x2, #0x8                   	// #8
	l = o->pobj->obj_id_len;
 11226d0:	b9403000 	ldr	w0, [x0, #48]
 11226d4:	f9002fe0 	str	x0, [sp, #88]
	res = copy_to_user_private(len, &l, sizeof(*len));
 11226d8:	aa1703e0 	mov	x0, x23
 11226dc:	97ffca42 	bl	1114fe4 <copy_to_user_private>
 11226e0:	2a0003f3 	mov	w19, w0
		if (o->pobj) {
 11226e4:	f9402680 	ldr	x0, [x20, #72]
 11226e8:	b40000e0 	cbz	x0, 1122704 <syscall_storage_next_enum+0x1a4>
			o->pobj->fops->close(&o->fh);
 11226ec:	f9402000 	ldr	x0, [x0, #64]
 11226f0:	f9400801 	ldr	x1, [x0, #16]
 11226f4:	91014280 	add	x0, x20, #0x50
 11226f8:	d63f0020 	blr	x1
			tee_pobj_release(o->pobj);
 11226fc:	f9402680 	ldr	x0, [x20, #72]
 1122700:	94000ee3 	bl	112628c <tee_pobj_release>
		tee_obj_free(o);
 1122704:	aa1403e0 	mov	x0, x20
 1122708:	94000e2b 	bl	1125fb4 <tee_obj_free>
 112270c:	17ffffaa 	b	11225b4 <syscall_storage_next_enum+0x54>

0000000001122710 <syscall_storage_obj_read>:

TEE_Result syscall_storage_obj_read(unsigned long obj, void *data, size_t len,
				    uint64_t *count)
{
 1122710:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
 1122714:	910003fd 	mov	x29, sp
 1122718:	a90153f3 	stp	x19, x20, [sp, #16]
 112271c:	aa0203f4 	mov	x20, x2
 1122720:	aa0003f3 	mov	x19, x0
 1122724:	a9025bf5 	stp	x21, x22, [sp, #32]
 1122728:	aa0303f6 	mov	x22, x3
 112272c:	a90363f7 	stp	x23, x24, [sp, #48]
 1122730:	aa0103f7 	mov	x23, x1
	struct ts_session *sess = ts_get_current_session();
 1122734:	97ffc8ab 	bl	11149e0 <ts_get_current_session>
 1122738:	aa0003f5 	mov	x21, x0
	struct user_ta_ctx *utc = to_user_ta_ctx(sess->ctx);
 112273c:	f9400800 	ldr	x0, [x0, #16]
 1122740:	97fffd0c 	bl	1121b70 <to_user_ta_ctx>
 1122744:	aa0003f8 	mov	x24, x0
	struct tee_obj *o = NULL;
	uint64_t u_count = 0;
	size_t pos_tmp = 0;
	size_t bytes = 0;

	res = tee_obj_get(utc, uref_to_vaddr(obj), &o);
 1122748:	2a1303e0 	mov	w0, w19
	uint64_t u_count = 0;
 112274c:	a904ffff 	stp	xzr, xzr, [sp, #72]
	size_t bytes = 0;
 1122750:	f9002fff 	str	xzr, [sp, #88]
	res = tee_obj_get(utc, uref_to_vaddr(obj), &o);
 1122754:	97ffca59 	bl	11150b8 <uref_to_vaddr>
 1122758:	910123e2 	add	x2, sp, #0x48
 112275c:	aa0003e1 	mov	x1, x0
 1122760:	aa1803e0 	mov	x0, x24
 1122764:	94000e06 	bl	1125f7c <tee_obj_get>
 1122768:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 112276c:	350001e0 	cbnz	w0, 11227a8 <syscall_storage_obj_read+0x98>
		goto exit;

	if (!(o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT)) {
 1122770:	f94027e0 	ldr	x0, [sp, #72]
 1122774:	b9402801 	ldr	w1, [x0, #40]
 1122778:	368007c1 	tbz	w1, #16, 1122870 <syscall_storage_obj_read+0x160>
		res = TEE_ERROR_BAD_STATE;
		goto exit;
	}

	if (!(o->info.handleFlags & TEE_DATA_FLAG_ACCESS_READ)) {
 112277c:	360007e1 	tbz	w1, #0, 1122878 <syscall_storage_obj_read+0x168>
		res = TEE_ERROR_ACCESS_CONFLICT;
		goto exit;
	}

	/* Guard o->info.dataPosition += bytes below from overflowing */
	if (ADD_OVERFLOW(o->info.dataPosition, len, &pos_tmp)) {
 1122780:	b9402400 	ldr	w0, [x0, #36]
 1122784:	ab140000 	adds	x0, x0, x20
 1122788:	540001c2 	b.cs	11227c0 <syscall_storage_obj_read+0xb0>  // b.hs, b.nlast
		res = TEE_ERROR_OVERFLOW;
		goto exit;
	}

	/* check rights of the provided buffer */
	res = vm_check_access_rights(&utc->uctx, TEE_MEMORY_ACCESS_WRITE,
 112278c:	aa1403e3 	mov	x3, x20
 1122790:	aa1703e2 	mov	x2, x23
 1122794:	91014300 	add	x0, x24, #0x50
 1122798:	52800041 	mov	w1, #0x2                   	// #2
 112279c:	97ffdc14 	bl	11197ec <vm_check_access_rights>
 11227a0:	2a0003f3 	mov	w19, w0
				     (uaddr_t)data, len);
	if (res != TEE_SUCCESS)
 11227a4:	34000120 	cbz	w0, 11227c8 <syscall_storage_obj_read+0xb8>

	u_count = bytes;
	res = copy_to_user_private(count, &u_count, sizeof(*count));
exit:
	return res;
}
 11227a8:	2a1303e0 	mov	w0, w19
 11227ac:	a94153f3 	ldp	x19, x20, [sp, #16]
 11227b0:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11227b4:	a94363f7 	ldp	x23, x24, [sp, #48]
 11227b8:	a8c67bfd 	ldp	x29, x30, [sp], #96
 11227bc:	d65f03c0 	ret
		res = TEE_ERROR_OVERFLOW;
 11227c0:	1299fe13 	mov	w19, #0xffff300f            	// #-53233
 11227c4:	17fffff9 	b	11227a8 <syscall_storage_obj_read+0x98>
	if (ADD_OVERFLOW(o->ds_pos, o->info.dataPosition, &pos_tmp)) {
 11227c8:	f94027e0 	ldr	x0, [sp, #72]
	bytes = len;
 11227cc:	f9002ff4 	str	x20, [sp, #88]
	if (ADD_OVERFLOW(o->ds_pos, o->info.dataPosition, &pos_tmp)) {
 11227d0:	f9402002 	ldr	x2, [x0, #64]
 11227d4:	b9402401 	ldr	w1, [x0, #36]
 11227d8:	ab010041 	adds	x1, x2, x1
 11227dc:	54ffff22 	b.cs	11227c0 <syscall_storage_obj_read+0xb0>  // b.hs, b.nlast
	res = o->pobj->fops->read(o->fh, pos_tmp, data, &bytes);
 11227e0:	a9448002 	ldp	x2, x0, [x0, #72]
 11227e4:	910163e3 	add	x3, sp, #0x58
 11227e8:	f9402042 	ldr	x2, [x2, #64]
 11227ec:	f9400c44 	ldr	x4, [x2, #24]
 11227f0:	aa1703e2 	mov	x2, x23
 11227f4:	d63f0080 	blr	x4
 11227f8:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS) {
 11227fc:	34000220 	cbz	w0, 1122840 <syscall_storage_obj_read+0x130>
		if (res == TEE_ERROR_CORRUPT_OBJECT) {
 1122800:	52800020 	mov	w0, #0x1                   	// #1
 1122804:	72be0200 	movk	w0, #0xf010, lsl #16
 1122808:	6b00027f 	cmp	w19, w0
 112280c:	54fffce1 	b.ne	11227a8 <syscall_storage_obj_read+0x98>  // b.any
			EMSG("Object corrupt");
 1122810:	52800023 	mov	w3, #0x1                   	// #1
 1122814:	52800022 	mov	w2, #0x1                   	// #1
 1122818:	528065c1 	mov	w1, #0x32e                 	// #814
 112281c:	f0000184 	adrp	x4, 1155000 <__func__.3826+0xa8>
 1122820:	f0000180 	adrp	x0, 1155000 <__func__.3826+0xa8>
 1122824:	91263484 	add	x4, x4, #0x98d
 1122828:	9128f000 	add	x0, x0, #0xa3c
 112282c:	94008946 	bl	1144d44 <trace_printf>
			tee_svc_storage_remove_corrupt_obj(sess, o);
 1122830:	f94027e1 	ldr	x1, [sp, #72]
 1122834:	910042a0 	add	x0, x21, #0x10
 1122838:	97fffce2 	bl	1121bc0 <tee_svc_storage_remove_corrupt_obj.isra.0>
 112283c:	17ffffdb 	b	11227a8 <syscall_storage_obj_read+0x98>
	o->info.dataPosition += bytes;
 1122840:	f94027e2 	ldr	x2, [sp, #72]
 1122844:	f9402fe1 	ldr	x1, [sp, #88]
	u_count = bytes;
 1122848:	f9002be1 	str	x1, [sp, #80]
	o->info.dataPosition += bytes;
 112284c:	b9402440 	ldr	w0, [x2, #36]
 1122850:	0b010000 	add	w0, w0, w1
 1122854:	b9002440 	str	w0, [x2, #36]
	res = copy_to_user_private(count, &u_count, sizeof(*count));
 1122858:	910143e1 	add	x1, sp, #0x50
 112285c:	aa1603e0 	mov	x0, x22
 1122860:	d2800102 	mov	x2, #0x8                   	// #8
 1122864:	97ffc9e0 	bl	1114fe4 <copy_to_user_private>
 1122868:	2a0003f3 	mov	w19, w0
 112286c:	17ffffcf 	b	11227a8 <syscall_storage_obj_read+0x98>
		res = TEE_ERROR_BAD_STATE;
 1122870:	129fff13 	mov	w19, #0xffff0007            	// #-65529
 1122874:	17ffffcd 	b	11227a8 <syscall_storage_obj_read+0x98>
		res = TEE_ERROR_ACCESS_CONFLICT;
 1122878:	129fff93 	mov	w19, #0xffff0003            	// #-65533
	return res;
 112287c:	17ffffcb 	b	11227a8 <syscall_storage_obj_read+0x98>

0000000001122880 <syscall_storage_obj_write>:

TEE_Result syscall_storage_obj_write(unsigned long obj, void *data, size_t len)
{
 1122880:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 1122884:	910003fd 	mov	x29, sp
 1122888:	a90153f3 	stp	x19, x20, [sp, #16]
 112288c:	aa0103f4 	mov	x20, x1
 1122890:	aa0203f3 	mov	x19, x2
 1122894:	a9025bf5 	stp	x21, x22, [sp, #32]
 1122898:	aa0003f6 	mov	x22, x0
	struct ts_session *sess = ts_get_current_session();
 112289c:	97ffc851 	bl	11149e0 <ts_get_current_session>
	struct user_ta_ctx *utc = to_user_ta_ctx(sess->ctx);
 11228a0:	f9400800 	ldr	x0, [x0, #16]
 11228a4:	97fffcb3 	bl	1121b70 <to_user_ta_ctx>
 11228a8:	aa0003f5 	mov	x21, x0
	TEE_Result res = TEE_SUCCESS;
	struct tee_obj *o = NULL;
	size_t pos_tmp = 0;

	res = tee_obj_get(utc, uref_to_vaddr(obj), &o);
 11228ac:	2a1603e0 	mov	w0, w22
	struct tee_obj *o = NULL;
 11228b0:	f9001fff 	str	xzr, [sp, #56]
	res = tee_obj_get(utc, uref_to_vaddr(obj), &o);
 11228b4:	97ffca01 	bl	11150b8 <uref_to_vaddr>
 11228b8:	aa0003e1 	mov	x1, x0
 11228bc:	9100e3e2 	add	x2, sp, #0x38
 11228c0:	aa1503e0 	mov	x0, x21
 11228c4:	94000dae 	bl	1125f7c <tee_obj_get>
	if (res != TEE_SUCCESS)
 11228c8:	350000c0 	cbnz	w0, 11228e0 <syscall_storage_obj_write+0x60>
		goto exit;

	if (!(o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT)) {
 11228cc:	f9401fe0 	ldr	x0, [sp, #56]
 11228d0:	b9402801 	ldr	w1, [x0, #40]
 11228d4:	368004e1 	tbz	w1, #16, 1122970 <syscall_storage_obj_write+0xf0>
		res = TEE_ERROR_BAD_STATE;
		goto exit;
	}

	if (!(o->info.handleFlags & TEE_DATA_FLAG_ACCESS_WRITE)) {
 11228d8:	370800c1 	tbnz	w1, #1, 11228f0 <syscall_storage_obj_write+0x70>
		res = TEE_ERROR_ACCESS_CONFLICT;
 11228dc:	129fff80 	mov	w0, #0xffff0003            	// #-65533
	if (o->info.dataPosition > o->info.dataSize)
		o->info.dataSize = o->info.dataPosition;

exit:
	return res;
}
 11228e0:	a94153f3 	ldp	x19, x20, [sp, #16]
 11228e4:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11228e8:	a8c47bfd 	ldp	x29, x30, [sp], #64
 11228ec:	d65f03c0 	ret
	if (ADD_OVERFLOW(o->info.dataPosition, len, &pos_tmp)) {
 11228f0:	b9402400 	ldr	w0, [x0, #36]
 11228f4:	ab130000 	adds	x0, x0, x19
 11228f8:	54000382 	b.cs	1122968 <syscall_storage_obj_write+0xe8>  // b.hs, b.nlast
	res = vm_check_access_rights(&utc->uctx, TEE_MEMORY_ACCESS_READ,
 11228fc:	aa1303e3 	mov	x3, x19
 1122900:	aa1403e2 	mov	x2, x20
 1122904:	910142a0 	add	x0, x21, #0x50
 1122908:	52800021 	mov	w1, #0x1                   	// #1
 112290c:	97ffdbb8 	bl	11197ec <vm_check_access_rights>
	if (res != TEE_SUCCESS)
 1122910:	35fffe80 	cbnz	w0, 11228e0 <syscall_storage_obj_write+0x60>
	if (ADD_OVERFLOW(o->ds_pos, o->info.dataPosition, &pos_tmp)) {
 1122914:	f9401fe4 	ldr	x4, [sp, #56]
 1122918:	f9402080 	ldr	x0, [x4, #64]
 112291c:	b9402481 	ldr	w1, [x4, #36]
 1122920:	ab010001 	adds	x1, x0, x1
 1122924:	54fffdc2 	b.cs	11228dc <syscall_storage_obj_write+0x5c>  // b.hs, b.nlast
	res = o->pobj->fops->write(o->fh, pos_tmp, data, len);
 1122928:	f9402480 	ldr	x0, [x4, #72]
 112292c:	aa1303e3 	mov	x3, x19
 1122930:	aa1403e2 	mov	x2, x20
 1122934:	f9402000 	ldr	x0, [x0, #64]
 1122938:	f9401005 	ldr	x5, [x0, #32]
 112293c:	f9402880 	ldr	x0, [x4, #80]
 1122940:	d63f00a0 	blr	x5
	if (res != TEE_SUCCESS)
 1122944:	35fffce0 	cbnz	w0, 11228e0 <syscall_storage_obj_write+0x60>
	o->info.dataPosition += len;
 1122948:	f9401fe1 	ldr	x1, [sp, #56]
 112294c:	29440c22 	ldp	w2, w3, [x1, #32]
 1122950:	0b130073 	add	w19, w3, w19
 1122954:	b9002433 	str	w19, [x1, #36]
	if (o->info.dataPosition > o->info.dataSize)
 1122958:	6b02027f 	cmp	w19, w2
 112295c:	54fffc29 	b.ls	11228e0 <syscall_storage_obj_write+0x60>  // b.plast
		o->info.dataSize = o->info.dataPosition;
 1122960:	b9002033 	str	w19, [x1, #32]
 1122964:	17ffffdf 	b	11228e0 <syscall_storage_obj_write+0x60>
		res = TEE_ERROR_OVERFLOW;
 1122968:	1299fe00 	mov	w0, #0xffff300f            	// #-53233
	return res;
 112296c:	17ffffdd 	b	11228e0 <syscall_storage_obj_write+0x60>
		res = TEE_ERROR_BAD_STATE;
 1122970:	129fff00 	mov	w0, #0xffff0007            	// #-65529
 1122974:	17ffffdb 	b	11228e0 <syscall_storage_obj_write+0x60>

0000000001122978 <syscall_storage_obj_trunc>:

TEE_Result syscall_storage_obj_trunc(unsigned long obj, size_t len)
{
 1122978:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 112297c:	910003fd 	mov	x29, sp
 1122980:	a90153f3 	stp	x19, x20, [sp, #16]
 1122984:	aa0103f4 	mov	x20, x1
 1122988:	a9025bf5 	stp	x21, x22, [sp, #32]
 112298c:	aa0003f6 	mov	x22, x0
	struct ts_session *sess = ts_get_current_session();
 1122990:	97ffc814 	bl	11149e0 <ts_get_current_session>
 1122994:	aa0003f5 	mov	x21, x0
	TEE_Result res = TEE_SUCCESS;
	struct tee_obj *o = NULL;
	size_t off = 0;
	size_t attr_size = 0;
 1122998:	a9037fff 	stp	xzr, xzr, [sp, #48]

	res = tee_obj_get(to_user_ta_ctx(sess->ctx), uref_to_vaddr(obj), &o);
 112299c:	f9400800 	ldr	x0, [x0, #16]
 11229a0:	97fffc74 	bl	1121b70 <to_user_ta_ctx>
 11229a4:	aa0003f3 	mov	x19, x0
 11229a8:	2a1603e0 	mov	w0, w22
 11229ac:	97ffc9c3 	bl	11150b8 <uref_to_vaddr>
 11229b0:	9100c3e2 	add	x2, sp, #0x30
 11229b4:	aa0003e1 	mov	x1, x0
 11229b8:	aa1303e0 	mov	x0, x19
 11229bc:	94000d70 	bl	1125f7c <tee_obj_get>
 11229c0:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 11229c4:	35000200 	cbnz	w0, 1122a04 <syscall_storage_obj_trunc+0x8c>
		goto exit;

	if (!(o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT)) {
 11229c8:	f9401be0 	ldr	x0, [sp, #48]
 11229cc:	b9402801 	ldr	w1, [x0, #40]
 11229d0:	368005c1 	tbz	w1, #16, 1122a88 <syscall_storage_obj_trunc+0x110>
		res = TEE_ERROR_BAD_STATE;
		goto exit;
	}

	if (!(o->info.handleFlags & TEE_DATA_FLAG_ACCESS_WRITE)) {
 11229d4:	360805e1 	tbz	w1, #1, 1122a90 <syscall_storage_obj_trunc+0x118>
		res = TEE_ERROR_ACCESS_CONFLICT;
		goto exit;
	}

	res = tee_obj_attr_to_binary(o, NULL, &attr_size);
 11229d8:	9100e3e2 	add	x2, sp, #0x38
 11229dc:	d2800001 	mov	x1, #0x0                   	// #0
 11229e0:	97ffefd7 	bl	111e93c <tee_obj_attr_to_binary>
 11229e4:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 11229e8:	350000e0 	cbnz	w0, 1122a04 <syscall_storage_obj_trunc+0x8c>
		goto exit;

	if (ADD_OVERFLOW(sizeof(struct tee_svc_storage_head), attr_size,
 11229ec:	f9401fe2 	ldr	x2, [sp, #56]
 11229f0:	b1006042 	adds	x2, x2, #0x18
 11229f4:	54000062 	b.cs	1122a00 <syscall_storage_obj_trunc+0x88>  // b.hs, b.nlast
				&off)) {
		res = TEE_ERROR_OVERFLOW;
		goto exit;
	}
	if (ADD_OVERFLOW(len, off, &off)) {
 11229f8:	ab020281 	adds	x1, x20, x2
 11229fc:	540000e3 	b.cc	1122a18 <syscall_storage_obj_trunc+0xa0>  // b.lo, b.ul, b.last
		res = TEE_ERROR_OVERFLOW;
 1122a00:	1299fe13 	mov	w19, #0xffff300f            	// #-53233
		break;
	}

exit:
	return res;
}
 1122a04:	2a1303e0 	mov	w0, w19
 1122a08:	a94153f3 	ldp	x19, x20, [sp, #16]
 1122a0c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1122a10:	a8c47bfd 	ldp	x29, x30, [sp], #64
 1122a14:	d65f03c0 	ret
	res = o->pobj->fops->truncate(o->fh, off);
 1122a18:	f9401be0 	ldr	x0, [sp, #48]
 1122a1c:	a9448002 	ldp	x2, x0, [x0, #72]
 1122a20:	f9402042 	ldr	x2, [x2, #64]
 1122a24:	f9401c42 	ldr	x2, [x2, #56]
 1122a28:	d63f0040 	blr	x2
 1122a2c:	2a0003f3 	mov	w19, w0
	switch (res) {
 1122a30:	35000080 	cbnz	w0, 1122a40 <syscall_storage_obj_trunc+0xc8>
		o->info.dataSize = len;
 1122a34:	f9401be0 	ldr	x0, [sp, #48]
 1122a38:	b9002014 	str	w20, [x0, #32]
		break;
 1122a3c:	17fffff2 	b	1122a04 <syscall_storage_obj_trunc+0x8c>
	switch (res) {
 1122a40:	52800020 	mov	w0, #0x1                   	// #1
 1122a44:	72be0200 	movk	w0, #0xf010, lsl #16
 1122a48:	6b00027f 	cmp	w19, w0
 1122a4c:	54000060 	b.eq	1122a58 <syscall_storage_obj_trunc+0xe0>  // b.none
 1122a50:	52bffff3 	mov	w19, #0xffff0000            	// #-65536
 1122a54:	17ffffec 	b	1122a04 <syscall_storage_obj_trunc+0x8c>
		EMSG("Object corruption");
 1122a58:	52800023 	mov	w3, #0x1                   	// #1
 1122a5c:	52800022 	mov	w2, #0x1                   	// #1
 1122a60:	528072e1 	mov	w1, #0x397                 	// #919
 1122a64:	f0000184 	adrp	x4, 1155000 <__func__.3826+0xa8>
 1122a68:	f0000180 	adrp	x0, 1155000 <__func__.3826+0xa8>
 1122a6c:	91269084 	add	x4, x4, #0x9a4
 1122a70:	91295400 	add	x0, x0, #0xa55
 1122a74:	940088b4 	bl	1144d44 <trace_printf>
		(void)tee_svc_storage_remove_corrupt_obj(sess, o);
 1122a78:	f9401be1 	ldr	x1, [sp, #48]
 1122a7c:	910042a0 	add	x0, x21, #0x10
 1122a80:	97fffc50 	bl	1121bc0 <tee_svc_storage_remove_corrupt_obj.isra.0>
		break;
 1122a84:	17ffffe0 	b	1122a04 <syscall_storage_obj_trunc+0x8c>
		res = TEE_ERROR_BAD_STATE;
 1122a88:	129fff13 	mov	w19, #0xffff0007            	// #-65529
 1122a8c:	17ffffde 	b	1122a04 <syscall_storage_obj_trunc+0x8c>
		res = TEE_ERROR_ACCESS_CONFLICT;
 1122a90:	129fff93 	mov	w19, #0xffff0003            	// #-65533
 1122a94:	17ffffdc 	b	1122a04 <syscall_storage_obj_trunc+0x8c>

0000000001122a98 <syscall_storage_obj_seek>:

TEE_Result syscall_storage_obj_seek(unsigned long obj, int32_t offset,
				    unsigned long whence)
{
 1122a98:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 1122a9c:	910003fd 	mov	x29, sp
 1122aa0:	a90153f3 	stp	x19, x20, [sp, #16]
 1122aa4:	2a0103f3 	mov	w19, w1
 1122aa8:	aa0203f4 	mov	x20, x2
 1122aac:	a9025bf5 	stp	x21, x22, [sp, #32]
 1122ab0:	aa0003f6 	mov	x22, x0
	struct ts_session *sess = ts_get_current_session();
 1122ab4:	97ffc7cb 	bl	11149e0 <ts_get_current_session>
	TEE_Result res = TEE_SUCCESS;
	struct tee_obj *o = NULL;
	tee_fs_off_t new_pos = 0;

	res = tee_obj_get(to_user_ta_ctx(sess->ctx), uref_to_vaddr(obj), &o);
 1122ab8:	f9400800 	ldr	x0, [x0, #16]
	struct tee_obj *o = NULL;
 1122abc:	f9001fff 	str	xzr, [sp, #56]
	res = tee_obj_get(to_user_ta_ctx(sess->ctx), uref_to_vaddr(obj), &o);
 1122ac0:	97fffc2c 	bl	1121b70 <to_user_ta_ctx>
 1122ac4:	aa0003f5 	mov	x21, x0
 1122ac8:	2a1603e0 	mov	w0, w22
 1122acc:	97ffc97b 	bl	11150b8 <uref_to_vaddr>
 1122ad0:	9100e3e2 	add	x2, sp, #0x38
 1122ad4:	aa0003e1 	mov	x1, x0
 1122ad8:	aa1503e0 	mov	x0, x21
 1122adc:	94000d28 	bl	1125f7c <tee_obj_get>
	if (res != TEE_SUCCESS)
 1122ae0:	350001a0 	cbnz	w0, 1122b14 <syscall_storage_obj_seek+0x7c>
		return res;

	if (!(o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT))
 1122ae4:	f9401fe2 	ldr	x2, [sp, #56]
 1122ae8:	b9402841 	ldr	w1, [x2, #40]
 1122aec:	36800441 	tbz	w1, #16, 1122b74 <syscall_storage_obj_seek+0xdc>
		return TEE_ERROR_BAD_STATE;

	switch (whence) {
 1122af0:	f100069f 	cmp	x20, #0x1
 1122af4:	54000180 	b.eq	1122b24 <syscall_storage_obj_seek+0x8c>  // b.none
 1122af8:	f1000a9f 	cmp	x20, #0x2
 1122afc:	54000340 	b.eq	1122b64 <syscall_storage_obj_seek+0xcc>  // b.none
 1122b00:	b50002f4 	cbnz	x20, 1122b5c <syscall_storage_obj_seek+0xc4>
	case TEE_DATA_SEEK_SET:
		new_pos = offset;
 1122b04:	93407e61 	sxtw	x1, w19
 1122b08:	f100003f 	cmp	x1, #0x0
 1122b0c:	9a9fa021 	csel	x1, x1, xzr, ge  // ge = tcont
	if (new_pos > TEE_DATA_MAX_POSITION) {
		EMSG("Position is beyond TEE_DATA_MAX_POSITION");
		return TEE_ERROR_BAD_PARAMETERS;
	}

	o->info.dataPosition = new_pos;
 1122b10:	b9002441 	str	w1, [x2, #36]

	return TEE_SUCCESS;
}
 1122b14:	a94153f3 	ldp	x19, x20, [sp, #16]
 1122b18:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1122b1c:	a8c47bfd 	ldp	x29, x30, [sp], #64
 1122b20:	d65f03c0 	ret
		if (ADD_OVERFLOW(o->info.dataPosition, offset, &new_pos))
 1122b24:	b9402441 	ldr	w1, [x2, #36]
		if (ADD_OVERFLOW(o->info.dataSize, offset, &new_pos))
 1122b28:	8b33c021 	add	x1, x1, w19, sxtw
	if (new_pos < 0)
 1122b2c:	b7f80201 	tbnz	x1, #63, 1122b6c <syscall_storage_obj_seek+0xd4>
	if (new_pos > TEE_DATA_MAX_POSITION) {
 1122b30:	b2407fe3 	mov	x3, #0xffffffff            	// #4294967295
 1122b34:	eb03003f 	cmp	x1, x3
 1122b38:	54fffecd 	b.le	1122b10 <syscall_storage_obj_seek+0x78>
		EMSG("Position is beyond TEE_DATA_MAX_POSITION");
 1122b3c:	f0000184 	adrp	x4, 1155000 <__func__.3826+0xa8>
 1122b40:	f0000180 	adrp	x0, 1155000 <__func__.3826+0xa8>
 1122b44:	9126d884 	add	x4, x4, #0x9b6
 1122b48:	9129bc00 	add	x0, x0, #0xa6f
 1122b4c:	52800023 	mov	w3, #0x1                   	// #1
 1122b50:	52800022 	mov	w2, #0x1                   	// #1
 1122b54:	528078c1 	mov	w1, #0x3c6                 	// #966
 1122b58:	9400887b 	bl	1144d44 <trace_printf>
	switch (whence) {
 1122b5c:	129fff20 	mov	w0, #0xffff0006            	// #-65530
 1122b60:	17ffffed 	b	1122b14 <syscall_storage_obj_seek+0x7c>
		if (ADD_OVERFLOW(o->info.dataSize, offset, &new_pos))
 1122b64:	b9402041 	ldr	w1, [x2, #32]
 1122b68:	17fffff0 	b	1122b28 <syscall_storage_obj_seek+0x90>
		new_pos = 0;
 1122b6c:	d2800001 	mov	x1, #0x0                   	// #0
 1122b70:	17ffffe8 	b	1122b10 <syscall_storage_obj_seek+0x78>
		return TEE_ERROR_BAD_STATE;
 1122b74:	129fff00 	mov	w0, #0xffff0007            	// #-65529
 1122b78:	17ffffe7 	b	1122b14 <syscall_storage_obj_seek+0x7c>

0000000001122b7c <tee_svc_storage_close_all_enum>:

void tee_svc_storage_close_all_enum(struct user_ta_ctx *utc)
{
 1122b7c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1122b80:	910003fd 	mov	x29, sp
 1122b84:	f9000bf3 	str	x19, [sp, #16]
 1122b88:	aa0003f3 	mov	x19, x0
	struct tee_storage_enum_head *eh = &utc->storage_enums;

	/* disregard return value */
	while (!TAILQ_EMPTY(eh))
 1122b8c:	f9401a61 	ldr	x1, [x19, #48]
 1122b90:	b5000081 	cbnz	x1, 1122ba0 <tee_svc_storage_close_all_enum+0x24>
		tee_svc_close_enum(utc, TAILQ_FIRST(eh));
}
 1122b94:	f9400bf3 	ldr	x19, [sp, #16]
 1122b98:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1122b9c:	d65f03c0 	ret
		tee_svc_close_enum(utc, TAILQ_FIRST(eh));
 1122ba0:	aa1303e0 	mov	x0, x19
 1122ba4:	97fffb5d 	bl	1121918 <tee_svc_close_enum>
 1122ba8:	17fffff9 	b	1122b8c <tee_svc_storage_close_all_enum+0x10>

0000000001122bac <ree_fs_readdir_rpc>:
	}
}

static TEE_Result ree_fs_readdir_rpc(struct tee_fs_dir *d,
				     struct tee_fs_dirent **ent)
{
 1122bac:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1122bb0:	910003fd 	mov	x29, sp
 1122bb4:	a90153f3 	stp	x19, x20, [sp, #16]
 1122bb8:	aa0003f3 	mov	x19, x0
	TEE_Result res;

	mutex_lock(&ree_fs_mutex);
 1122bbc:	900001f4 	adrp	x20, 115e000 <state+0x80>
 1122bc0:	9105e280 	add	x0, x20, #0x178
{
 1122bc4:	a9025bf5 	stp	x21, x22, [sp, #32]
 1122bc8:	aa0103f5 	mov	x21, x1
	mutex_lock(&ree_fs_mutex);
 1122bcc:	97ffca62 	bl	1115554 <mutex_lock>

	d->d.oidlen = sizeof(d->d.oid);
	res = tee_fs_dirfile_get_next(d->dirh, d->uuid, &d->idx, d->d.oid,
 1122bd0:	91004276 	add	x22, x19, #0x10
	d->d.oidlen = sizeof(d->d.oid);
 1122bd4:	d2800800 	mov	x0, #0x40                  	// #64
 1122bd8:	f9002a60 	str	x0, [x19, #80]
	res = tee_fs_dirfile_get_next(d->dirh, d->uuid, &d->idx, d->d.oid,
 1122bdc:	f9400260 	ldr	x0, [x19]
 1122be0:	91014264 	add	x4, x19, #0x50
 1122be4:	f9402e61 	ldr	x1, [x19, #88]
 1122be8:	91002262 	add	x2, x19, #0x8
 1122bec:	aa1603e3 	mov	x3, x22
 1122bf0:	94000b10 	bl	1125830 <tee_fs_dirfile_get_next>
 1122bf4:	2a0003f3 	mov	w19, w0
				      &d->d.oidlen);
	if (res == TEE_SUCCESS)
 1122bf8:	35000040 	cbnz	w0, 1122c00 <ree_fs_readdir_rpc+0x54>
		*ent = &d->d;
 1122bfc:	f90002b6 	str	x22, [x21]

	mutex_unlock(&ree_fs_mutex);
 1122c00:	9105e280 	add	x0, x20, #0x178
 1122c04:	97ffca33 	bl	11154d0 <mutex_unlock>

	return res;
}
 1122c08:	2a1303e0 	mov	w0, w19
 1122c0c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1122c10:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1122c14:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1122c18:	d65f03c0 	ret

0000000001122c1c <ree_dirf_commit_writes>:
{
 1122c1c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1122c20:	910003fd 	mov	x29, sp
 1122c24:	f90013f5 	str	x21, [sp, #32]
	res = tee_fs_htree_sync_to_storage(&fdp->ht, fdp->dfh.hash);
 1122c28:	91004015 	add	x21, x0, #0x10
{
 1122c2c:	a90153f3 	stp	x19, x20, [sp, #16]
 1122c30:	aa0103f4 	mov	x20, x1
	res = tee_fs_htree_sync_to_storage(&fdp->ht, fdp->dfh.hash);
 1122c34:	aa1503e1 	mov	x1, x21
 1122c38:	940006a1 	bl	11246bc <tee_fs_htree_sync_to_storage>
	if (!res && hash)
 1122c3c:	7100001f 	cmp	w0, #0x0
	res = tee_fs_htree_sync_to_storage(&fdp->ht, fdp->dfh.hash);
 1122c40:	2a0003f3 	mov	w19, w0
	if (!res && hash)
 1122c44:	fa400a84 	ccmp	x20, #0x0, #0x4, eq  // eq = none
 1122c48:	540000a0 	b.eq	1122c5c <ree_dirf_commit_writes+0x40>  // b.none
		memcpy(hash, fdp->dfh.hash, sizeof(fdp->dfh.hash));
 1122c4c:	aa1503e1 	mov	x1, x21
 1122c50:	aa1403e0 	mov	x0, x20
 1122c54:	d2800402 	mov	x2, #0x20                  	// #32
 1122c58:	97ff81ce 	bl	1103390 <memcpy>
}
 1122c5c:	2a1303e0 	mov	w0, w19
 1122c60:	a94153f3 	ldp	x19, x20, [sp, #16]
 1122c64:	f94013f5 	ldr	x21, [sp, #32]
 1122c68:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1122c6c:	d65f03c0 	ret

0000000001122c70 <ree_fs_read_primitive>:
{
 1122c70:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
 1122c74:	910003fd 	mov	x29, sp
 1122c78:	a9046bf9 	stp	x25, x26, [sp, #64]
 1122c7c:	aa0003f9 	mov	x25, x0
	struct tee_fs_htree_meta *meta = tee_fs_htree_get_meta(fdp->ht);
 1122c80:	f9400000 	ldr	x0, [x0]
{
 1122c84:	a9025bf5 	stp	x21, x22, [sp, #32]
 1122c88:	aa0303f5 	mov	x21, x3
 1122c8c:	a90153f3 	stp	x19, x20, [sp, #16]
 1122c90:	aa0103f4 	mov	x20, x1
 1122c94:	a90363f7 	stp	x23, x24, [sp, #48]
 1122c98:	aa0203f7 	mov	x23, x2
 1122c9c:	a90573fb 	stp	x27, x28, [sp, #80]
	struct tee_fs_htree_meta *meta = tee_fs_htree_get_meta(fdp->ht);
 1122ca0:	9400066d 	bl	1124654 <tee_fs_htree_get_meta>
	remain_bytes = *len;
 1122ca4:	f94002b3 	ldr	x19, [x21]
	if ((pos + remain_bytes) < remain_bytes || pos > meta->length)
 1122ca8:	ab140261 	adds	x1, x19, x20
 1122cac:	54000082 	b.cs	1122cbc <ree_fs_read_primitive+0x4c>  // b.hs, b.nlast
 1122cb0:	f9400000 	ldr	x0, [x0]
 1122cb4:	eb14001f 	cmp	x0, x20
 1122cb8:	54000162 	b.cs	1122ce4 <ree_fs_read_primitive+0x74>  // b.hs, b.nlast
	*len = remain_bytes;
 1122cbc:	f90002bf 	str	xzr, [x21]
		res = TEE_SUCCESS;
 1122cc0:	52800015 	mov	w21, #0x0                   	// #0
}
 1122cc4:	2a1503e0 	mov	w0, w21
 1122cc8:	a94153f3 	ldp	x19, x20, [sp, #16]
 1122ccc:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1122cd0:	a94363f7 	ldp	x23, x24, [sp, #48]
 1122cd4:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1122cd8:	a94573fb 	ldp	x27, x28, [sp, #80]
 1122cdc:	a8c77bfd 	ldp	x29, x30, [sp], #112
 1122ce0:	d65f03c0 	ret
	else if (pos + remain_bytes > meta->length)
 1122ce4:	eb00003f 	cmp	x1, x0
 1122ce8:	54000049 	b.ls	1122cf0 <ree_fs_read_primitive+0x80>  // b.plast
		remain_bytes = meta->length - pos;
 1122cec:	cb140013 	sub	x19, x0, x20
	*len = remain_bytes;
 1122cf0:	f90002b3 	str	x19, [x21]
	if (!remain_bytes) {
 1122cf4:	b4fffe73 	cbz	x19, 1122cc0 <ree_fs_read_primitive+0x50>
	return mempool_alloc(mempool_default, BLOCK_SIZE);
 1122cf8:	900001c3 	adrp	x3, 115a000 <__scattered_array_1phys_mem_map+0x8>
	end_block_num = pos_to_block_num(pos + remain_bytes - 1);
 1122cfc:	51000696 	sub	w22, w20, #0x1
 1122d00:	0b1302d6 	add	w22, w22, w19
	return mempool_alloc(mempool_default, BLOCK_SIZE);
 1122d04:	d2820001 	mov	x1, #0x1000                	// #4096
 1122d08:	f9418863 	ldr	x3, [x3, #784]
	return position >> BLOCK_SHIFT;
 1122d0c:	130c7ec0 	asr	w0, w22, #12
 1122d10:	b90067e0 	str	w0, [sp, #100]
 1122d14:	130c7e98 	asr	w24, w20, #12
	return mempool_alloc(mempool_default, BLOCK_SIZE);
 1122d18:	f9400060 	ldr	x0, [x3]
 1122d1c:	94008859 	bl	1144e80 <mempool_alloc>
 1122d20:	aa0003fa 	mov	x26, x0
	if (!block) {
 1122d24:	b40004c0 	cbz	x0, 1122dbc <ree_fs_read_primitive+0x14c>
 1122d28:	93407f16 	sxtw	x22, w24
		size_t size_to_read = MIN(remain_bytes, (size_t)BLOCK_SIZE);
 1122d2c:	d282001b 	mov	x27, #0x1000                	// #4096
	while (start_block_num <= end_block_num) {
 1122d30:	b94067e0 	ldr	w0, [sp, #100]
 1122d34:	6b00031f 	cmp	w24, w0
 1122d38:	5400010d 	b.le	1122d58 <ree_fs_read_primitive+0xe8>
	res = TEE_SUCCESS;
 1122d3c:	52800015 	mov	w21, #0x0                   	// #0
	mempool_free(mempool_default, tmp_block);
 1122d40:	900001c3 	adrp	x3, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1122d44:	aa1a03e1 	mov	x1, x26
 1122d48:	f9418863 	ldr	x3, [x3, #784]
 1122d4c:	f9400060 	ldr	x0, [x3]
 1122d50:	9400887e 	bl	1144f48 <mempool_free>
}
 1122d54:	17ffffdc 	b	1122cc4 <ree_fs_read_primitive+0x54>
		size_t size_to_read = MIN(remain_bytes, (size_t)BLOCK_SIZE);
 1122d58:	f140067f 	cmp	x19, #0x1, lsl #12
		size_t offset = pos % BLOCK_SIZE;
 1122d5c:	92402e84 	and	x4, x20, #0xfff
		size_t size_to_read = MIN(remain_bytes, (size_t)BLOCK_SIZE);
 1122d60:	9a9b927c 	csel	x28, x19, x27, ls  // ls = plast
		if (size_to_read + offset > BLOCK_SIZE)
 1122d64:	8b1c0080 	add	x0, x4, x28
 1122d68:	f140041f 	cmp	x0, #0x1, lsl #12
 1122d6c:	54000049 	b.ls	1122d74 <ree_fs_read_primitive+0x104>  // b.plast
			size_to_read = BLOCK_SIZE - offset;
 1122d70:	cb04037c 	sub	x28, x27, x4
		res = tee_fs_htree_read_block(&fdp->ht, start_block_num, block);
 1122d74:	aa1603e1 	mov	x1, x22
 1122d78:	aa1a03e2 	mov	x2, x26
 1122d7c:	aa1903e0 	mov	x0, x25
 1122d80:	910006d6 	add	x22, x22, #0x1
 1122d84:	f90037e4 	str	x4, [sp, #104]
 1122d88:	940007eb 	bl	1124d34 <tee_fs_htree_read_block>
 1122d8c:	2a0003f5 	mov	w21, w0
		if (res != TEE_SUCCESS)
 1122d90:	35fffd80 	cbnz	w0, 1122d40 <ree_fs_read_primitive+0xd0>
		memcpy(data_ptr, block + offset, size_to_read);
 1122d94:	f94037e4 	ldr	x4, [sp, #104]
 1122d98:	aa1c03e2 	mov	x2, x28
 1122d9c:	aa1703e0 	mov	x0, x23
		remain_bytes -= size_to_read;
 1122da0:	cb1c0273 	sub	x19, x19, x28
		data_ptr += size_to_read;
 1122da4:	8b1c02f7 	add	x23, x23, x28
		pos += size_to_read;
 1122da8:	8b1c0294 	add	x20, x20, x28
		start_block_num++;
 1122dac:	11000718 	add	w24, w24, #0x1
		memcpy(data_ptr, block + offset, size_to_read);
 1122db0:	8b040341 	add	x1, x26, x4
 1122db4:	97ff8177 	bl	1103390 <memcpy>
		start_block_num++;
 1122db8:	17ffffde 	b	1122d30 <ree_fs_read_primitive+0xc0>
		res = TEE_ERROR_OUT_OF_MEMORY;
 1122dbc:	129ffe75 	mov	w21, #0xffff000c            	// #-65524
	return res;
 1122dc0:	17ffffc1 	b	1122cc4 <ree_fs_read_primitive+0x54>

0000000001122dc4 <ree_fs_read>:
{
 1122dc4:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 1122dc8:	910003fd 	mov	x29, sp
 1122dcc:	a90153f3 	stp	x19, x20, [sp, #16]
	mutex_lock(&ree_fs_mutex);
 1122dd0:	900001f3 	adrp	x19, 115e000 <state+0x80>
 1122dd4:	9105e273 	add	x19, x19, #0x178
{
 1122dd8:	aa0003f4 	mov	x20, x0
	mutex_lock(&ree_fs_mutex);
 1122ddc:	aa1303e0 	mov	x0, x19
{
 1122de0:	a9025bf5 	stp	x21, x22, [sp, #32]
 1122de4:	aa0103f5 	mov	x21, x1
 1122de8:	aa0203f6 	mov	x22, x2
 1122dec:	f9001bf7 	str	x23, [sp, #48]
 1122df0:	aa0303f7 	mov	x23, x3
	mutex_lock(&ree_fs_mutex);
 1122df4:	97ffc9d8 	bl	1115554 <mutex_lock>
	res = ree_fs_read_primitive(fh, pos, buf, len);
 1122df8:	aa1703e3 	mov	x3, x23
 1122dfc:	aa1603e2 	mov	x2, x22
 1122e00:	aa1503e1 	mov	x1, x21
 1122e04:	aa1403e0 	mov	x0, x20
 1122e08:	97ffff9a 	bl	1122c70 <ree_fs_read_primitive>
 1122e0c:	2a0003f4 	mov	w20, w0
	mutex_unlock(&ree_fs_mutex);
 1122e10:	aa1303e0 	mov	x0, x19
 1122e14:	97ffc9af 	bl	11154d0 <mutex_unlock>
}
 1122e18:	2a1403e0 	mov	w0, w20
 1122e1c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1122e20:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1122e24:	f9401bf7 	ldr	x23, [sp, #48]
 1122e28:	a8c47bfd 	ldp	x29, x30, [sp], #64
 1122e2c:	d65f03c0 	ret

0000000001122e30 <ree_fs_open_primitive>:
{
 1122e30:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 1122e34:	910003fd 	mov	x29, sp
 1122e38:	a90153f3 	stp	x19, x20, [sp, #16]
 1122e3c:	a9025bf5 	stp	x21, x22, [sp, #32]
 1122e40:	aa0203f6 	mov	x22, x2
 1122e44:	aa0303f5 	mov	x21, x3
 1122e48:	a90363f7 	stp	x23, x24, [sp, #48]
 1122e4c:	12001c17 	and	w23, w0, #0xff
 1122e50:	aa0403f8 	mov	x24, x4
	fdp = calloc(1, sizeof(struct tee_fs_fd));
 1122e54:	d2800020 	mov	x0, #0x1                   	// #1
{
 1122e58:	f90023f9 	str	x25, [sp, #64]
 1122e5c:	aa0103f9 	mov	x25, x1
	fdp = calloc(1, sizeof(struct tee_fs_fd));
 1122e60:	d2800801 	mov	x1, #0x40                  	// #64
 1122e64:	9400819b 	bl	11434d0 <calloc>
	if (!fdp)
 1122e68:	b40007e0 	cbz	x0, 1122f64 <ree_fs_open_primitive+0x134>
 1122e6c:	aa0003f4 	mov	x20, x0
	fdp->fd = -1;
 1122e70:	12800000 	mov	w0, #0xffffffff            	// #-1
 1122e74:	91002282 	add	x2, x20, #0x8
		res = tee_fs_rpc_create_dfh(OPTEE_RPC_CMD_FS,
 1122e78:	aa1503e1 	mov	x1, x21
	fdp->fd = -1;
 1122e7c:	b9000a80 	str	w0, [x20, #8]
		res = tee_fs_rpc_create_dfh(OPTEE_RPC_CMD_FS,
 1122e80:	52800040 	mov	w0, #0x2                   	// #2
	fdp->uuid = uuid;
 1122e84:	f9001e96 	str	x22, [x20, #56]
	if (create)
 1122e88:	34000377 	cbz	w23, 1122ef4 <ree_fs_open_primitive+0xc4>
		res = tee_fs_rpc_create_dfh(OPTEE_RPC_CMD_FS,
 1122e8c:	94000ad3 	bl	11259d8 <tee_fs_rpc_create_dfh>
		res = tee_fs_rpc_open_dfh(OPTEE_RPC_CMD_FS, dfh, &fdp->fd);
 1122e90:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 1122e94:	350003a0 	cbnz	w0, 1122f08 <ree_fs_open_primitive+0xd8>
	res = tee_fs_htree_open(create, hash, uuid, &ree_fs_storage_ops,
 1122e98:	aa1403e5 	mov	x5, x20
 1122e9c:	aa1403e4 	mov	x4, x20
 1122ea0:	aa1603e2 	mov	x2, x22
 1122ea4:	aa1903e1 	mov	x1, x25
 1122ea8:	2a1703e0 	mov	w0, w23
 1122eac:	b00001c3 	adrp	x3, 115b000 <__vcore_unpg_rw_start>
 1122eb0:	913ac063 	add	x3, x3, #0xeb0
 1122eb4:	94000651 	bl	11247f8 <tee_fs_htree_open>
 1122eb8:	2a0003f3 	mov	w19, w0
	if (res == TEE_SUCCESS) {
 1122ebc:	35000260 	cbnz	w0, 1122f08 <ree_fs_open_primitive+0xd8>
		if (dfh)
 1122ec0:	b40001f5 	cbz	x21, 1122efc <ree_fs_open_primitive+0xcc>
			fdp->dfh = *dfh;
 1122ec4:	aa1503e1 	mov	x1, x21
 1122ec8:	91003280 	add	x0, x20, #0xc
 1122ecc:	d2800502 	mov	x2, #0x28                  	// #40
 1122ed0:	97ff8130 	bl	1103390 <memcpy>
		*fh = (struct tee_file_handle *)fdp;
 1122ed4:	f9000314 	str	x20, [x24]
}
 1122ed8:	2a1303e0 	mov	w0, w19
 1122edc:	a94153f3 	ldp	x19, x20, [sp, #16]
 1122ee0:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1122ee4:	a94363f7 	ldp	x23, x24, [sp, #48]
 1122ee8:	f94023f9 	ldr	x25, [sp, #64]
 1122eec:	a8c57bfd 	ldp	x29, x30, [sp], #80
 1122ef0:	d65f03c0 	ret
		res = tee_fs_rpc_open_dfh(OPTEE_RPC_CMD_FS, dfh, &fdp->fd);
 1122ef4:	94000ab5 	bl	11259c8 <tee_fs_rpc_open_dfh>
 1122ef8:	17ffffe6 	b	1122e90 <ree_fs_open_primitive+0x60>
			fdp->dfh.idx = -1;
 1122efc:	12800000 	mov	w0, #0xffffffff            	// #-1
 1122f00:	b9003280 	str	w0, [x20, #48]
 1122f04:	17fffff4 	b	1122ed4 <ree_fs_open_primitive+0xa4>
		if (res == TEE_ERROR_SECURITY)
 1122f08:	129ffe00 	mov	w0, #0xffff000f            	// #-65521
 1122f0c:	6b00027f 	cmp	w19, w0
 1122f10:	54000121 	b.ne	1122f34 <ree_fs_open_primitive+0x104>  // b.any
			DMSG("Secure storage corruption detected");
 1122f14:	f0000184 	adrp	x4, 1155000 <__func__.3826+0xa8>
 1122f18:	f0000180 	adrp	x0, 1155000 <__func__.3826+0xa8>
 1122f1c:	912a2084 	add	x4, x4, #0xa88
 1122f20:	912d5800 	add	x0, x0, #0xb56
 1122f24:	52800023 	mov	w3, #0x1                   	// #1
 1122f28:	52800062 	mov	w2, #0x3                   	// #3
 1122f2c:	52803561 	mov	w1, #0x1ab                 	// #427
 1122f30:	94008785 	bl	1144d44 <trace_printf>
		if (fdp->fd != -1)
 1122f34:	b9400a81 	ldr	w1, [x20, #8]
 1122f38:	3100043f 	cmn	w1, #0x1
 1122f3c:	54000060 	b.eq	1122f48 <ree_fs_open_primitive+0x118>  // b.none
			tee_fs_rpc_close(OPTEE_RPC_CMD_FS, fdp->fd);
 1122f40:	52800040 	mov	w0, #0x2                   	// #2
 1122f44:	94000aa9 	bl	11259e8 <tee_fs_rpc_close>
		if (create)
 1122f48:	34000097 	cbz	w23, 1122f58 <ree_fs_open_primitive+0x128>
			tee_fs_rpc_remove_dfh(OPTEE_RPC_CMD_FS, dfh);
 1122f4c:	aa1503e1 	mov	x1, x21
 1122f50:	52800040 	mov	w0, #0x2                   	// #2
 1122f54:	94000b44 	bl	1125c64 <tee_fs_rpc_remove_dfh>
		free(fdp);
 1122f58:	aa1403e0 	mov	x0, x20
 1122f5c:	940081a1 	bl	11435e0 <free>
 1122f60:	17ffffde 	b	1122ed8 <ree_fs_open_primitive+0xa8>
		return TEE_ERROR_OUT_OF_MEMORY;
 1122f64:	129ffe73 	mov	w19, #0xffff000c            	// #-65524
 1122f68:	17ffffdc 	b	1122ed8 <ree_fs_open_primitive+0xa8>

0000000001122f6c <get_offs_size>:
{
 1122f6c:	12001c42 	and	w2, w2, #0xff
	assert(vers == 0 || vers == 1);
 1122f70:	7100045f 	cmp	w2, #0x1
 1122f74:	54000189 	b.ls	1122fa4 <get_offs_size+0x38>  // b.plast
 1122f78:	f0000183 	adrp	x3, 1155000 <__func__.3826+0xa8>
 1122f7c:	f0000181 	adrp	x1, 1155000 <__func__.3826+0xa8>
 1122f80:	912d2063 	add	x3, x3, #0xb48
 1122f84:	912aac21 	add	x1, x1, #0xaab
 1122f88:	f0000180 	adrp	x0, 1155000 <__func__.3826+0xa8>
 1122f8c:	912b0400 	add	x0, x0, #0xac1
{
 1122f90:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	assert(vers == 0 || vers == 1);
 1122f94:	52801162 	mov	w2, #0x8b                  	// #139
{
 1122f98:	910003fd 	mov	x29, sp
	assert(vers == 0 || vers == 1);
 1122f9c:	97ffbcc4 	bl	11122ac <_assert_log>
 1122fa0:	97ffbcd4 	bl	11122f0 <_assert_break>
	switch (type) {
 1122fa4:	7100041f 	cmp	w0, #0x1
 1122fa8:	54000140 	b.eq	1122fd0 <get_offs_size+0x64>  // b.none
 1122fac:	7100081f 	cmp	w0, #0x2
 1122fb0:	54000300 	b.eq	1123010 <get_offs_size+0xa4>  // b.none
 1122fb4:	35000420 	cbnz	w0, 1123038 <get_offs_size+0xcc>
		*offs = sizeof(struct tee_fs_htree_image) * vers;
 1122fb8:	52800881 	mov	w1, #0x44                  	// #68
 1122fbc:	9ba17c42 	umull	x2, w2, w1
		*size = sizeof(struct tee_fs_htree_image);
 1122fc0:	d2800881 	mov	x1, #0x44                  	// #68
		*offs = sizeof(struct tee_fs_htree_image) * vers;
 1122fc4:	f9000062 	str	x2, [x3]
		*size = sizeof(struct tee_fs_htree_image);
 1122fc8:	f9000081 	str	x1, [x4]
		return TEE_SUCCESS;
 1122fcc:	d65f03c0 	ret
		pbn = 1 + ((idx / block_nodes) * block_nodes * 2);
 1122fd0:	d28003e6 	mov	x6, #0x1f                  	// #31
 1122fd4:	d28007c0 	mov	x0, #0x3e                  	// #62
			node_size * vers;
 1122fd8:	52800847 	mov	w7, #0x42                  	// #66
		pbn = 1 + ((idx / block_nodes) * block_nodes * 2);
 1122fdc:	9ac60825 	udiv	x5, x1, x6
			node_size * vers;
 1122fe0:	9ba77c42 	umull	x2, w2, w7
		pbn = 1 + ((idx / block_nodes) * block_nodes * 2);
 1122fe4:	9b007ca0 	mul	x0, x5, x0
			2 * node_size * (idx % block_nodes) +
 1122fe8:	9b0684a1 	msub	x1, x5, x6, x1
		pbn = 1 + ((idx / block_nodes) * block_nodes * 2);
 1122fec:	91000400 	add	x0, x0, #0x1
			2 * node_size * (idx % block_nodes) +
 1122ff0:	8b003042 	add	x2, x2, x0, lsl #12
 1122ff4:	d2801080 	mov	x0, #0x84                  	// #132
 1122ff8:	9b000822 	madd	x2, x1, x0, x2
		*size = node_size;
 1122ffc:	d2800840 	mov	x0, #0x42                  	// #66
		*offs = pbn * BLOCK_SIZE +
 1123000:	f9000062 	str	x2, [x3]
		*size = BLOCK_SIZE;
 1123004:	f9000080 	str	x0, [x4]
		return TEE_SUCCESS;
 1123008:	52800000 	mov	w0, #0x0                   	// #0
 112300c:	d65f03c0 	ret
		bidx = 2 * idx + vers;
 1123010:	92401c42 	and	x2, x2, #0xff
		pbn = 2 + bidx + bidx / (block_nodes * 2 - 1);
 1123014:	d28007a0 	mov	x0, #0x3d                  	// #61
		bidx = 2 * idx + vers;
 1123018:	8b010441 	add	x1, x2, x1, lsl #1
		pbn = 2 + bidx + bidx / (block_nodes * 2 - 1);
 112301c:	9ac00820 	udiv	x0, x1, x0
 1123020:	91000821 	add	x1, x1, #0x2
 1123024:	8b010001 	add	x1, x0, x1
		*size = BLOCK_SIZE;
 1123028:	d2820000 	mov	x0, #0x1000                	// #4096
		*offs = pbn * BLOCK_SIZE;
 112302c:	d374cc21 	lsl	x1, x1, #12
 1123030:	f9000061 	str	x1, [x3]
		*size = BLOCK_SIZE;
 1123034:	17fffff4 	b	1123004 <get_offs_size+0x98>
	switch (type) {
 1123038:	52bfffe0 	mov	w0, #0xffff0000            	// #-65536
}
 112303c:	d65f03c0 	ret

0000000001123040 <ree_fs_rpc_write_init>:
{
 1123040:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 1123044:	910003fd 	mov	x29, sp
 1123048:	a90153f3 	stp	x19, x20, [sp, #16]
 112304c:	aa0003f4 	mov	x20, x0
 1123050:	aa0103f3 	mov	x19, x1
 1123054:	2a0203e0 	mov	w0, w2
 1123058:	aa0303e1 	mov	x1, x3
 112305c:	12001c82 	and	w2, w4, #0xff
	res = get_offs_size(type, idx, vers, &offs, &size);
 1123060:	9100c3e3 	add	x3, sp, #0x30
 1123064:	9100e3e4 	add	x4, sp, #0x38
{
 1123068:	f90013f5 	str	x21, [sp, #32]
 112306c:	aa0503f5 	mov	x21, x5
	res = get_offs_size(type, idx, vers, &offs, &size);
 1123070:	97ffffbf 	bl	1122f6c <get_offs_size>
	if (res != TEE_SUCCESS)
 1123074:	350000e0 	cbnz	w0, 1123090 <ree_fs_rpc_write_init+0x50>
	return tee_fs_rpc_write_init(op, OPTEE_RPC_CMD_FS, fdp->fd,
 1123078:	a94313e3 	ldp	x3, x4, [sp, #48]
 112307c:	aa1503e5 	mov	x5, x21
 1123080:	b9400a82 	ldr	w2, [x20, #8]
 1123084:	aa1303e0 	mov	x0, x19
 1123088:	52800041 	mov	w1, #0x2                   	// #2
 112308c:	94000aab 	bl	1125b38 <tee_fs_rpc_write_init>
}
 1123090:	a94153f3 	ldp	x19, x20, [sp, #16]
 1123094:	f94013f5 	ldr	x21, [sp, #32]
 1123098:	a8c47bfd 	ldp	x29, x30, [sp], #64
 112309c:	d65f03c0 	ret

00000000011230a0 <ree_fs_rpc_read_init>:
{
 11230a0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 11230a4:	910003fd 	mov	x29, sp
 11230a8:	a90153f3 	stp	x19, x20, [sp, #16]
 11230ac:	aa0003f4 	mov	x20, x0
 11230b0:	aa0103f3 	mov	x19, x1
 11230b4:	2a0203e0 	mov	w0, w2
 11230b8:	aa0303e1 	mov	x1, x3
 11230bc:	12001c82 	and	w2, w4, #0xff
	res = get_offs_size(type, idx, vers, &offs, &size);
 11230c0:	9100c3e3 	add	x3, sp, #0x30
 11230c4:	9100e3e4 	add	x4, sp, #0x38
{
 11230c8:	f90013f5 	str	x21, [sp, #32]
 11230cc:	aa0503f5 	mov	x21, x5
	res = get_offs_size(type, idx, vers, &offs, &size);
 11230d0:	97ffffa7 	bl	1122f6c <get_offs_size>
	if (res != TEE_SUCCESS)
 11230d4:	350000e0 	cbnz	w0, 11230f0 <ree_fs_rpc_read_init+0x50>
	return tee_fs_rpc_read_init(op, OPTEE_RPC_CMD_FS, fdp->fd,
 11230d8:	a94313e3 	ldp	x3, x4, [sp, #48]
 11230dc:	aa1503e5 	mov	x5, x21
 11230e0:	b9400a82 	ldr	w2, [x20, #8]
 11230e4:	aa1303e0 	mov	x0, x19
 11230e8:	52800041 	mov	w1, #0x2                   	// #2
 11230ec:	94000a57 	bl	1125a48 <tee_fs_rpc_read_init>
}
 11230f0:	a94153f3 	ldp	x19, x20, [sp, #16]
 11230f4:	f94013f5 	ldr	x21, [sp, #32]
 11230f8:	a8c47bfd 	ldp	x29, x30, [sp], #64
 11230fc:	d65f03c0 	ret

0000000001123100 <ree_fs_close_primitive>:
	if (fdp) {
 1123100:	b40001a0 	cbz	x0, 1123134 <ree_fs_close_primitive+0x34>
{
 1123104:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1123108:	910003fd 	mov	x29, sp
 112310c:	f9000bf3 	str	x19, [sp, #16]
 1123110:	aa0003f3 	mov	x19, x0
		tee_fs_htree_close(&fdp->ht);
 1123114:	94000556 	bl	112466c <tee_fs_htree_close>
		tee_fs_rpc_close(OPTEE_RPC_CMD_FS, fdp->fd);
 1123118:	52800040 	mov	w0, #0x2                   	// #2
 112311c:	b9400a61 	ldr	w1, [x19, #8]
 1123120:	94000a32 	bl	11259e8 <tee_fs_rpc_close>
		free(fdp);
 1123124:	aa1303e0 	mov	x0, x19
}
 1123128:	f9400bf3 	ldr	x19, [sp, #16]
 112312c:	a8c27bfd 	ldp	x29, x30, [sp], #32
		free(fdp);
 1123130:	1400812c 	b	11435e0 <free>
 1123134:	d65f03c0 	ret

0000000001123138 <put_dirh_primitive>:
{
 1123138:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	assert(ree_fs_dirh_refcount);
 112313c:	f00001c2 	adrp	x2, 115e000 <state+0x80>
{
 1123140:	910003fd 	mov	x29, sp
	assert(ree_fs_dirh_refcount);
 1123144:	f940b841 	ldr	x1, [x2, #368]
{
 1123148:	f9000bf3 	str	x19, [sp, #16]
	assert(ree_fs_dirh_refcount);
 112314c:	b5000141 	cbnz	x1, 1123174 <put_dirh_primitive+0x3c>
 1123150:	d0000183 	adrp	x3, 1155000 <__func__.3826+0xa8>
 1123154:	d0000181 	adrp	x1, 1155000 <__func__.3826+0xa8>
 1123158:	912dd463 	add	x3, x3, #0xb75
 112315c:	912aac21 	add	x1, x1, #0xaab
 1123160:	d0000180 	adrp	x0, 1155000 <__func__.3826+0xa8>
 1123164:	912b6000 	add	x0, x0, #0xad8
 1123168:	52804742 	mov	w2, #0x23a                 	// #570
 112316c:	97ffbc50 	bl	11122ac <_assert_log>
 1123170:	97ffbc60 	bl	11122f0 <_assert_break>
	ree_fs_dirh_refcount--;
 1123174:	d1000421 	sub	x1, x1, #0x1
 1123178:	f900b841 	str	x1, [x2, #368]
	if (ree_fs_dirh && (!ree_fs_dirh_refcount || close))
 112317c:	f00001c2 	adrp	x2, 115e000 <state+0x80>
 1123180:	12001c03 	and	w3, w0, #0xff
 1123184:	aa0203f3 	mov	x19, x2
 1123188:	f940b440 	ldr	x0, [x2, #360]
 112318c:	b40000a0 	cbz	x0, 11231a0 <put_dirh_primitive+0x68>
 1123190:	b4000041 	cbz	x1, 1123198 <put_dirh_primitive+0x60>
 1123194:	34000063 	cbz	w3, 11231a0 <put_dirh_primitive+0x68>
	tee_fs_dirfile_close(*dirh);
 1123198:	940007f0 	bl	1125158 <tee_fs_dirfile_close>
	*dirh = NULL;
 112319c:	f900b67f 	str	xzr, [x19, #360]
}
 11231a0:	f9400bf3 	ldr	x19, [sp, #16]
 11231a4:	a8c27bfd 	ldp	x29, x30, [sp], #32
 11231a8:	d65f03c0 	ret

00000000011231ac <put_dirh>:
{
 11231ac:	aa0003e2 	mov	x2, x0
	if (dirh) {
 11231b0:	b4000240 	cbz	x0, 11231f8 <put_dirh+0x4c>
 11231b4:	12001c20 	and	w0, w1, #0xff
		assert(dirh == ree_fs_dirh);
 11231b8:	f00001c1 	adrp	x1, 115e000 <state+0x80>
 11231bc:	f940b421 	ldr	x1, [x1, #360]
 11231c0:	eb02003f 	cmp	x1, x2
 11231c4:	54000180 	b.eq	11231f4 <put_dirh+0x48>  // b.none
 11231c8:	d0000183 	adrp	x3, 1155000 <__func__.3826+0xa8>
 11231cc:	d0000181 	adrp	x1, 1155000 <__func__.3826+0xa8>
 11231d0:	912e2063 	add	x3, x3, #0xb88
 11231d4:	912aac21 	add	x1, x1, #0xaab
 11231d8:	d0000180 	adrp	x0, 1155000 <__func__.3826+0xa8>
 11231dc:	912bb400 	add	x0, x0, #0xaed
{
 11231e0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
		assert(dirh == ree_fs_dirh);
 11231e4:	52804a02 	mov	w2, #0x250                 	// #592
{
 11231e8:	910003fd 	mov	x29, sp
		assert(dirh == ree_fs_dirh);
 11231ec:	97ffbc30 	bl	11122ac <_assert_log>
 11231f0:	97ffbc40 	bl	11122f0 <_assert_break>
		put_dirh_primitive(close);
 11231f4:	17ffffd1 	b	1123138 <put_dirh_primitive>
 11231f8:	d65f03c0 	ret

00000000011231fc <ree_fs_closedir_rpc>:
	if (d) {
 11231fc:	b4000240 	cbz	x0, 1123244 <ree_fs_closedir_rpc+0x48>
{
 1123200:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1123204:	910003fd 	mov	x29, sp
 1123208:	a90153f3 	stp	x19, x20, [sp, #16]
 112320c:	aa0003f3 	mov	x19, x0
		mutex_lock(&ree_fs_mutex);
 1123210:	f00001d4 	adrp	x20, 115e000 <state+0x80>
 1123214:	9105e294 	add	x20, x20, #0x178
 1123218:	aa1403e0 	mov	x0, x20
 112321c:	97ffc8ce 	bl	1115554 <mutex_lock>
		put_dirh(d->dirh, false);
 1123220:	f9400260 	ldr	x0, [x19]
 1123224:	52800001 	mov	w1, #0x0                   	// #0
 1123228:	97ffffe1 	bl	11231ac <put_dirh>
		free(d);
 112322c:	aa1303e0 	mov	x0, x19
 1123230:	940080ec 	bl	11435e0 <free>
		mutex_unlock(&ree_fs_mutex);
 1123234:	aa1403e0 	mov	x0, x20
}
 1123238:	a94153f3 	ldp	x19, x20, [sp, #16]
 112323c:	a8c27bfd 	ldp	x29, x30, [sp], #32
		mutex_unlock(&ree_fs_mutex);
 1123240:	17ffc8a4 	b	11154d0 <mutex_unlock>
 1123244:	d65f03c0 	ret

0000000001123248 <ree_fs_close>:
{
 1123248:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 112324c:	910003fd 	mov	x29, sp
 1123250:	a90153f3 	stp	x19, x20, [sp, #16]
 1123254:	aa0003f3 	mov	x19, x0
	if (*fh) {
 1123258:	f9400000 	ldr	x0, [x0]
 112325c:	b40001c0 	cbz	x0, 1123294 <ree_fs_close+0x4c>
		mutex_lock(&ree_fs_mutex);
 1123260:	f00001d4 	adrp	x20, 115e000 <state+0x80>
 1123264:	9105e294 	add	x20, x20, #0x178
 1123268:	aa1403e0 	mov	x0, x20
 112326c:	97ffc8ba 	bl	1115554 <mutex_lock>
		put_dirh_primitive(false);
 1123270:	52800000 	mov	w0, #0x0                   	// #0
 1123274:	97ffffb1 	bl	1123138 <put_dirh_primitive>
		ree_fs_close_primitive(*fh);
 1123278:	f9400260 	ldr	x0, [x19]
 112327c:	97ffffa1 	bl	1123100 <ree_fs_close_primitive>
		*fh = NULL;
 1123280:	f900027f 	str	xzr, [x19]
		mutex_unlock(&ree_fs_mutex);
 1123284:	aa1403e0 	mov	x0, x20
}
 1123288:	a94153f3 	ldp	x19, x20, [sp, #16]
 112328c:	a8c27bfd 	ldp	x29, x30, [sp], #32
		mutex_unlock(&ree_fs_mutex);
 1123290:	17ffc890 	b	11154d0 <mutex_unlock>
}
 1123294:	a94153f3 	ldp	x19, x20, [sp, #16]
 1123298:	a8c27bfd 	ldp	x29, x30, [sp], #32
 112329c:	d65f03c0 	ret

00000000011232a0 <get_dirh>:
{
 11232a0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	if (!ree_fs_dirh) {
 11232a4:	f00001c1 	adrp	x1, 115e000 <state+0x80>
{
 11232a8:	910003fd 	mov	x29, sp
 11232ac:	a9025bf5 	stp	x21, x22, [sp, #32]
 11232b0:	aa0003f5 	mov	x21, x0
	if (!ree_fs_dirh) {
 11232b4:	f940b420 	ldr	x0, [x1, #360]
{
 11232b8:	a90153f3 	stp	x19, x20, [sp, #16]
 11232bc:	aa0103f4 	mov	x20, x1
	if (!ree_fs_dirh) {
 11232c0:	b50002c0 	cbnz	x0, 1123318 <get_dirh+0x78>
 11232c4:	9105a036 	add	x22, x1, #0x168
	res = tee_fs_dirfile_open(false, NULL, &ree_dirf_ops, dirh);
 11232c8:	900001d3 	adrp	x19, 115b000 <__vcore_unpg_rw_start>
 11232cc:	9138c273 	add	x19, x19, #0xe30
 11232d0:	d2800001 	mov	x1, #0x0                   	// #0
 11232d4:	aa1603e3 	mov	x3, x22
 11232d8:	aa1303e2 	mov	x2, x19
 11232dc:	940007af 	bl	1125198 <tee_fs_dirfile_open>
	if (res == TEE_ERROR_ITEM_NOT_FOUND)
 11232e0:	129ffee1 	mov	w1, #0xffff0008            	// #-65528
 11232e4:	6b01001f 	cmp	w0, w1
 11232e8:	540000c1 	b.ne	1123300 <get_dirh+0x60>  // b.any
		return tee_fs_dirfile_open(true, NULL, &ree_dirf_ops, dirh);
 11232ec:	aa1603e3 	mov	x3, x22
 11232f0:	aa1303e2 	mov	x2, x19
 11232f4:	d2800001 	mov	x1, #0x0                   	// #0
 11232f8:	52800020 	mov	w0, #0x1                   	// #1
 11232fc:	940007a7 	bl	1125198 <tee_fs_dirfile_open>
		if (res) {
 1123300:	340000c0 	cbz	w0, 1123318 <get_dirh+0x78>
			*dirh = NULL;
 1123304:	f90002bf 	str	xzr, [x21]
}
 1123308:	a94153f3 	ldp	x19, x20, [sp, #16]
 112330c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1123310:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1123314:	d65f03c0 	ret
	ree_fs_dirh_refcount++;
 1123318:	f00001c0 	adrp	x0, 115e000 <state+0x80>
 112331c:	f940b801 	ldr	x1, [x0, #368]
 1123320:	91000421 	add	x1, x1, #0x1
 1123324:	f900b801 	str	x1, [x0, #368]
	assert(ree_fs_dirh);
 1123328:	f940b680 	ldr	x0, [x20, #360]
 112332c:	b5000140 	cbnz	x0, 1123354 <get_dirh+0xb4>
 1123330:	d0000183 	adrp	x3, 1155000 <__func__.3826+0xa8>
 1123334:	d0000181 	adrp	x1, 1155000 <__func__.3826+0xa8>
 1123338:	d0000180 	adrp	x0, 1155000 <__func__.3826+0xa8>
 112333c:	912db063 	add	x3, x3, #0xb6c
 1123340:	912aac21 	add	x1, x1, #0xaab
 1123344:	912bd400 	add	x0, x0, #0xaf5
 1123348:	52804642 	mov	w2, #0x232                 	// #562
	assert(ree_fs_dirh_refcount);
 112334c:	97ffbbd8 	bl	11122ac <_assert_log>
 1123350:	97ffbbe8 	bl	11122f0 <_assert_break>
 1123354:	b5000121 	cbnz	x1, 1123378 <get_dirh+0xd8>
 1123358:	d0000183 	adrp	x3, 1155000 <__func__.3826+0xa8>
 112335c:	d0000181 	adrp	x1, 1155000 <__func__.3826+0xa8>
 1123360:	d0000180 	adrp	x0, 1155000 <__func__.3826+0xa8>
 1123364:	912db063 	add	x3, x3, #0xb6c
 1123368:	912aac21 	add	x1, x1, #0xaab
 112336c:	912b6000 	add	x0, x0, #0xad8
 1123370:	52804662 	mov	w2, #0x233                 	// #563
 1123374:	17fffff6 	b	112334c <get_dirh+0xac>
	*dirh = ree_fs_dirh;
 1123378:	f90002a0 	str	x0, [x21]
	return TEE_SUCCESS;
 112337c:	52800000 	mov	w0, #0x0                   	// #0
 1123380:	17ffffe2 	b	1123308 <get_dirh+0x68>

0000000001123384 <ree_fs_opendir_rpc>:
{
 1123384:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 1123388:	910003fd 	mov	x29, sp
 112338c:	a90153f3 	stp	x19, x20, [sp, #16]
 1123390:	aa0003f4 	mov	x20, x0
	struct tee_fs_dir *d = calloc(1, sizeof(*d));
 1123394:	d2800020 	mov	x0, #0x1                   	// #1
{
 1123398:	a9025bf5 	stp	x21, x22, [sp, #32]
 112339c:	aa0103f6 	mov	x22, x1
	struct tee_fs_dir *d = calloc(1, sizeof(*d));
 11233a0:	d2800c01 	mov	x1, #0x60                  	// #96
{
 11233a4:	f9001bf7 	str	x23, [sp, #48]
	struct tee_fs_dir *d = calloc(1, sizeof(*d));
 11233a8:	9400804a 	bl	11434d0 <calloc>
	if (!d)
 11233ac:	b40004c0 	cbz	x0, 1123444 <ree_fs_opendir_rpc+0xc0>
 11233b0:	aa0003f3 	mov	x19, x0
	mutex_lock(&ree_fs_mutex);
 11233b4:	f00001d5 	adrp	x21, 115e000 <state+0x80>
 11233b8:	9105e2a0 	add	x0, x21, #0x178
	d->uuid = uuid;
 11233bc:	f9002e74 	str	x20, [x19, #88]
	mutex_lock(&ree_fs_mutex);
 11233c0:	97ffc865 	bl	1115554 <mutex_lock>
	res = get_dirh(&d->dirh);
 11233c4:	aa1303e0 	mov	x0, x19
 11233c8:	97ffffb6 	bl	11232a0 <get_dirh>
 11233cc:	2a0003f4 	mov	w20, w0
	if (res)
 11233d0:	350002e0 	cbnz	w0, 112342c <ree_fs_opendir_rpc+0xa8>
	d->d.oidlen = sizeof(d->d.oid);
 11233d4:	aa1303e4 	mov	x4, x19
	d->idx = -1;
 11233d8:	12800017 	mov	w23, #0xffffffff            	// #-1
	d->d.oidlen = sizeof(d->d.oid);
 11233dc:	d2800800 	mov	x0, #0x40                  	// #64
	d->idx = -1;
 11233e0:	b9000a77 	str	w23, [x19, #8]
	res = tee_fs_dirfile_get_next(d->dirh, d->uuid, &d->idx, d->d.oid,
 11233e4:	f9402e61 	ldr	x1, [x19, #88]
	d->d.oidlen = sizeof(d->d.oid);
 11233e8:	f8050c80 	str	x0, [x4, #80]!
	res = tee_fs_dirfile_get_next(d->dirh, d->uuid, &d->idx, d->d.oid,
 11233ec:	f9400260 	ldr	x0, [x19]
 11233f0:	91004263 	add	x3, x19, #0x10
 11233f4:	91002262 	add	x2, x19, #0x8
 11233f8:	9400090e 	bl	1125830 <tee_fs_dirfile_get_next>
	d->idx = -1;
 11233fc:	b9000a77 	str	w23, [x19, #8]
	res = tee_fs_dirfile_get_next(d->dirh, d->uuid, &d->idx, d->d.oid,
 1123400:	2a0003f4 	mov	w20, w0
	if (!res) {
 1123404:	35000140 	cbnz	w0, 112342c <ree_fs_opendir_rpc+0xa8>
		*dir = d;
 1123408:	f90002d3 	str	x19, [x22]
	mutex_unlock(&ree_fs_mutex);
 112340c:	9105e2a0 	add	x0, x21, #0x178
 1123410:	97ffc830 	bl	11154d0 <mutex_unlock>
}
 1123414:	2a1403e0 	mov	w0, w20
 1123418:	a94153f3 	ldp	x19, x20, [sp, #16]
 112341c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1123420:	f9401bf7 	ldr	x23, [sp, #48]
 1123424:	a8c47bfd 	ldp	x29, x30, [sp], #64
 1123428:	d65f03c0 	ret
			put_dirh(d->dirh, false);
 112342c:	f9400260 	ldr	x0, [x19]
 1123430:	52800001 	mov	w1, #0x0                   	// #0
 1123434:	97ffff5e 	bl	11231ac <put_dirh>
		free(d);
 1123438:	aa1303e0 	mov	x0, x19
 112343c:	94008069 	bl	11435e0 <free>
 1123440:	17fffff3 	b	112340c <ree_fs_opendir_rpc+0x88>
		return TEE_ERROR_OUT_OF_MEMORY;
 1123444:	129ffe74 	mov	w20, #0xffff000c            	// #-65524
 1123448:	17fffff3 	b	1123414 <ree_fs_opendir_rpc+0x90>

000000000112344c <ree_fs_open>:
{
 112344c:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
 1123450:	910003fd 	mov	x29, sp
 1123454:	a90153f3 	stp	x19, x20, [sp, #16]
 1123458:	aa0003f4 	mov	x20, x0
 112345c:	a9025bf5 	stp	x21, x22, [sp, #32]
 1123460:	aa0103f5 	mov	x21, x1
 1123464:	aa0203f6 	mov	x22, x2
 1123468:	a90363f7 	stp	x23, x24, [sp, #48]
 112346c:	f90023f9 	str	x25, [sp, #64]
	mutex_lock(&ree_fs_mutex);
 1123470:	f00001d9 	adrp	x25, 115e000 <state+0x80>
 1123474:	9105e320 	add	x0, x25, #0x178
	struct tee_fs_dirfile_dirh *dirh = NULL;
 1123478:	f9002bff 	str	xzr, [sp, #80]
	mutex_lock(&ree_fs_mutex);
 112347c:	97ffc836 	bl	1115554 <mutex_lock>
	res = get_dirh(&dirh);
 1123480:	910143e0 	add	x0, sp, #0x50
 1123484:	97ffff87 	bl	11232a0 <get_dirh>
 1123488:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 112348c:	35000500 	cbnz	w0, 112352c <ree_fs_open+0xe0>
	res = tee_fs_dirfile_find(dirh, &po->uuid, po->obj_id, po->obj_id_len,
 1123490:	b9403283 	ldr	w3, [x20, #48]
 1123494:	91005297 	add	x23, x20, #0x14
 1123498:	f9401682 	ldr	x2, [x20, #40]
 112349c:	910163f8 	add	x24, sp, #0x58
 11234a0:	f9402be0 	ldr	x0, [sp, #80]
 11234a4:	aa1803e4 	mov	x4, x24
 11234a8:	aa1703e1 	mov	x1, x23
 11234ac:	940007b7 	bl	1125388 <tee_fs_dirfile_find>
 11234b0:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 11234b4:	350003c0 	cbnz	w0, 112352c <ree_fs_open+0xe0>
	res = ree_fs_open_primitive(false, dfh.hash, &po->uuid, &dfh, fh);
 11234b8:	aa1603e4 	mov	x4, x22
 11234bc:	aa1803e3 	mov	x3, x24
 11234c0:	aa1703e2 	mov	x2, x23
 11234c4:	91001301 	add	x1, x24, #0x4
 11234c8:	52800000 	mov	w0, #0x0                   	// #0
 11234cc:	97fffe59 	bl	1122e30 <ree_fs_open_primitive>
 11234d0:	2a0003f3 	mov	w19, w0
	if (res == TEE_ERROR_ITEM_NOT_FOUND) {
 11234d4:	129ffee0 	mov	w0, #0xffff0008            	// #-65528
 11234d8:	6b00027f 	cmp	w19, w0
 11234dc:	54000300 	b.eq	112353c <ree_fs_open+0xf0>  // b.none
	} else if (!res && size) {
 11234e0:	7100027f 	cmp	w19, #0x0
 11234e4:	fa400aa4 	ccmp	x21, #0x0, #0x4, eq  // eq = none
 11234e8:	54000200 	b.eq	1123528 <ree_fs_open+0xdc>  // b.none
		*size = tee_fs_htree_get_meta(fdp->ht)->length;
 11234ec:	f94002c0 	ldr	x0, [x22]
	res = ree_fs_open_primitive(false, dfh.hash, &po->uuid, &dfh, fh);
 11234f0:	52800013 	mov	w19, #0x0                   	// #0
		*size = tee_fs_htree_get_meta(fdp->ht)->length;
 11234f4:	f9400000 	ldr	x0, [x0]
 11234f8:	94000457 	bl	1124654 <tee_fs_htree_get_meta>
 11234fc:	f9400000 	ldr	x0, [x0]
 1123500:	f90002a0 	str	x0, [x21]
	mutex_unlock(&ree_fs_mutex);
 1123504:	9105e320 	add	x0, x25, #0x178
 1123508:	97ffc7f2 	bl	11154d0 <mutex_unlock>
}
 112350c:	2a1303e0 	mov	w0, w19
 1123510:	a94153f3 	ldp	x19, x20, [sp, #16]
 1123514:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1123518:	a94363f7 	ldp	x23, x24, [sp, #48]
 112351c:	f94023f9 	ldr	x25, [sp, #64]
 1123520:	a8c87bfd 	ldp	x29, x30, [sp], #128
 1123524:	d65f03c0 	ret
	if (res)
 1123528:	34fffef3 	cbz	w19, 1123504 <ree_fs_open+0xb8>
		put_dirh(dirh, false);
 112352c:	f9402be0 	ldr	x0, [sp, #80]
 1123530:	52800001 	mov	w1, #0x0                   	// #0
 1123534:	97ffff1e 	bl	11231ac <put_dirh>
 1123538:	17fffff3 	b	1123504 <ree_fs_open+0xb8>
		res = TEE_ERROR_CORRUPT_OBJECT;
 112353c:	52800033 	mov	w19, #0x1                   	// #1
 1123540:	72be0213 	movk	w19, #0xf010, lsl #16
 1123544:	17fffffa 	b	112352c <ree_fs_open+0xe0>

0000000001123548 <ree_fs_rename>:
{
 1123548:	a9b57bfd 	stp	x29, x30, [sp, #-176]!
 112354c:	910003fd 	mov	x29, sp
 1123550:	a90153f3 	stp	x19, x20, [sp, #16]
 1123554:	a9025bf5 	stp	x21, x22, [sp, #32]
 1123558:	aa0003f5 	mov	x21, x0
	struct tee_fs_dirfile_fileh remove_dfh = { .idx = -1 };
 112355c:	12800000 	mov	w0, #0xffffffff            	// #-1
{
 1123560:	a90363f7 	stp	x23, x24, [sp, #48]
 1123564:	f90023f9 	str	x25, [sp, #64]
	struct tee_fs_dirfile_dirh *dirh = NULL;
 1123568:	f9002fff 	str	xzr, [sp, #88]
	struct tee_fs_dirfile_fileh remove_dfh = { .idx = -1 };
 112356c:	a908ffff 	stp	xzr, xzr, [sp, #136]
 1123570:	a909ffff 	stp	xzr, xzr, [sp, #152]
 1123574:	291503ff 	stp	wzr, w0, [sp, #168]
	if (!new)
 1123578:	b4000981 	cbz	x1, 11236a8 <ree_fs_rename+0x160>
 112357c:	aa0103f4 	mov	x20, x1
 1123580:	12001c58 	and	w24, w2, #0xff
	mutex_lock(&ree_fs_mutex);
 1123584:	f00001d6 	adrp	x22, 115e000 <state+0x80>
 1123588:	9105e2c0 	add	x0, x22, #0x178
 112358c:	97ffc7f2 	bl	1115554 <mutex_lock>
	res = get_dirh(&dirh);
 1123590:	910163e0 	add	x0, sp, #0x58
 1123594:	97ffff43 	bl	11232a0 <get_dirh>
 1123598:	2a0003f3 	mov	w19, w0
	if (res)
 112359c:	350004e0 	cbnz	w0, 1123638 <ree_fs_rename+0xf0>
	res = tee_fs_dirfile_find(dirh, &new->uuid, new->obj_id,
 11235a0:	b9403283 	ldr	w3, [x20, #48]
 11235a4:	91005299 	add	x25, x20, #0x14
 11235a8:	f9401682 	ldr	x2, [x20, #40]
 11235ac:	910223f7 	add	x23, sp, #0x88
 11235b0:	f9402fe0 	ldr	x0, [sp, #88]
 11235b4:	aa1703e4 	mov	x4, x23
 11235b8:	aa1903e1 	mov	x1, x25
	if (!res && !overwrite) {
 11235bc:	52000318 	eor	w24, w24, #0x1
	res = tee_fs_dirfile_find(dirh, &new->uuid, new->obj_id,
 11235c0:	94000772 	bl	1125388 <tee_fs_dirfile_find>
	if (!res && !overwrite) {
 11235c4:	7100001f 	cmp	w0, #0x0
 11235c8:	1a9f17e0 	cset	w0, eq  // eq = none
 11235cc:	6a18001f 	tst	w0, w24
 11235d0:	54000681 	b.ne	11236a0 <ree_fs_rename+0x158>  // b.any
	res = tee_fs_dirfile_find(dirh, &old->uuid, old->obj_id,
 11235d4:	b94032a3 	ldr	w3, [x21, #48]
 11235d8:	910183f8 	add	x24, sp, #0x60
 11235dc:	f94016a2 	ldr	x2, [x21, #40]
 11235e0:	aa1803e4 	mov	x4, x24
 11235e4:	f9402fe0 	ldr	x0, [sp, #88]
 11235e8:	910052a1 	add	x1, x21, #0x14
 11235ec:	94000767 	bl	1125388 <tee_fs_dirfile_find>
 11235f0:	2a0003f3 	mov	w19, w0
	if (res)
 11235f4:	35000220 	cbnz	w0, 1123638 <ree_fs_rename+0xf0>
	res = tee_fs_dirfile_rename(dirh, &new->uuid, &dfh, new->obj_id,
 11235f8:	b9403284 	ldr	w4, [x20, #48]
 11235fc:	aa1803e2 	mov	x2, x24
 1123600:	f9401683 	ldr	x3, [x20, #40]
 1123604:	aa1903e1 	mov	x1, x25
 1123608:	f9402fe0 	ldr	x0, [sp, #88]
 112360c:	940007ce 	bl	1125544 <tee_fs_dirfile_rename>
 1123610:	2a0003f3 	mov	w19, w0
	if (res)
 1123614:	35000120 	cbnz	w0, 1123638 <ree_fs_rename+0xf0>
	if (remove_dfh.idx != -1) {
 1123618:	b940afe0 	ldr	w0, [sp, #172]
 112361c:	3100041f 	cmn	w0, #0x1
 1123620:	54000261 	b.ne	112366c <ree_fs_rename+0x124>  // b.any
	return tee_fs_dirfile_commit_writes(dirh, NULL);
 1123624:	f9402fe0 	ldr	x0, [sp, #88]
 1123628:	d2800001 	mov	x1, #0x0                   	// #0
 112362c:	9400072e 	bl	11252e4 <tee_fs_dirfile_commit_writes>
 1123630:	2a0003f3 	mov	w19, w0
	if (res)
 1123634:	34000280 	cbz	w0, 1123684 <ree_fs_rename+0x13c>
	put_dirh(dirh, res);
 1123638:	f9402fe0 	ldr	x0, [sp, #88]
 112363c:	7100027f 	cmp	w19, #0x0
 1123640:	1a9f07e1 	cset	w1, ne  // ne = any
 1123644:	97fffeda 	bl	11231ac <put_dirh>
	mutex_unlock(&ree_fs_mutex);
 1123648:	9105e2c0 	add	x0, x22, #0x178
 112364c:	97ffc7a1 	bl	11154d0 <mutex_unlock>
}
 1123650:	2a1303e0 	mov	w0, w19
 1123654:	a94153f3 	ldp	x19, x20, [sp, #16]
 1123658:	a9425bf5 	ldp	x21, x22, [sp, #32]
 112365c:	a94363f7 	ldp	x23, x24, [sp, #48]
 1123660:	f94023f9 	ldr	x25, [sp, #64]
 1123664:	a8cb7bfd 	ldp	x29, x30, [sp], #176
 1123668:	d65f03c0 	ret
		res = tee_fs_dirfile_remove(dirh, &remove_dfh);
 112366c:	f9402fe0 	ldr	x0, [sp, #88]
 1123670:	aa1703e1 	mov	x1, x23
 1123674:	940007f9 	bl	1125658 <tee_fs_dirfile_remove>
 1123678:	2a0003f3 	mov	w19, w0
		if (res)
 112367c:	34fffd40 	cbz	w0, 1123624 <ree_fs_rename+0xdc>
 1123680:	17ffffee 	b	1123638 <ree_fs_rename+0xf0>
	if (remove_dfh.idx != -1)
 1123684:	b940afe0 	ldr	w0, [sp, #172]
 1123688:	3100041f 	cmn	w0, #0x1
 112368c:	54fffd60 	b.eq	1123638 <ree_fs_rename+0xf0>  // b.none
		tee_fs_rpc_remove_dfh(OPTEE_RPC_CMD_FS, &remove_dfh);
 1123690:	aa1703e1 	mov	x1, x23
 1123694:	52800040 	mov	w0, #0x2                   	// #2
 1123698:	94000973 	bl	1125c64 <tee_fs_rpc_remove_dfh>
 112369c:	17ffffe7 	b	1123638 <ree_fs_rename+0xf0>
		res = TEE_ERROR_ACCESS_CONFLICT;
 11236a0:	129fff93 	mov	w19, #0xffff0003            	// #-65533
 11236a4:	17ffffe5 	b	1123638 <ree_fs_rename+0xf0>
		return TEE_ERROR_BAD_PARAMETERS;
 11236a8:	129fff33 	mov	w19, #0xffff0006            	// #-65530
 11236ac:	17ffffe9 	b	1123650 <ree_fs_rename+0x108>

00000000011236b0 <out_of_place_write>:
{
 11236b0:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
 11236b4:	910003fd 	mov	x29, sp
 11236b8:	a9046bf9 	stp	x25, x26, [sp, #64]
 11236bc:	aa0003fa 	mov	x26, x0
	struct tee_fs_htree_meta *meta = tee_fs_htree_get_meta(fdp->ht);
 11236c0:	f9400000 	ldr	x0, [x0]
{
 11236c4:	a90153f3 	stp	x19, x20, [sp, #16]
 11236c8:	aa0103f3 	mov	x19, x1
 11236cc:	a9025bf5 	stp	x21, x22, [sp, #32]
 11236d0:	aa0303f6 	mov	x22, x3
 11236d4:	a90363f7 	stp	x23, x24, [sp, #48]
 11236d8:	aa0203f8 	mov	x24, x2
 11236dc:	a90573fb 	stp	x27, x28, [sp, #80]
	struct tee_fs_htree_meta *meta = tee_fs_htree_get_meta(fdp->ht);
 11236e0:	940003dd 	bl	1124654 <tee_fs_htree_get_meta>
	if (!len)
 11236e4:	b4000a96 	cbz	x22, 1123834 <out_of_place_write+0x184>
 11236e8:	aa0003fb 	mov	x27, x0
	return mempool_alloc(mempool_default, BLOCK_SIZE);
 11236ec:	f00001a0 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 11236f0:	d2820001 	mov	x1, #0x1000                	// #4096
 11236f4:	f9418800 	ldr	x0, [x0, #784]
 11236f8:	f9400000 	ldr	x0, [x0]
 11236fc:	940085e1 	bl	1144e80 <mempool_alloc>
 1123700:	aa0003f4 	mov	x20, x0
	if (!block)
 1123704:	b40009c0 	cbz	x0, 112383c <out_of_place_write+0x18c>
	size_t end_block_num = pos_to_block_num(pos + len - 1);
 1123708:	510006d7 	sub	w23, w22, #0x1
	return position >> BLOCK_SHIFT;
 112370c:	130c7e75 	asr	w21, w19, #12
	size_t end_block_num = pos_to_block_num(pos + len - 1);
 1123710:	0b1302f7 	add	w23, w23, w19
		size_t size_to_write = MIN(remain_bytes, (size_t)BLOCK_SIZE);
 1123714:	d282001c 	mov	x28, #0x1000                	// #4096
	size_t start_block_num = pos_to_block_num(pos);
 1123718:	93407eb5 	sxtw	x21, w21
	return position >> BLOCK_SHIFT;
 112371c:	130c7ef7 	asr	w23, w23, #12
	size_t end_block_num = pos_to_block_num(pos + len - 1);
 1123720:	93407ee0 	sxtw	x0, w23
 1123724:	f90037e0 	str	x0, [sp, #104]
	while (start_block_num <= end_block_num) {
 1123728:	f94037e0 	ldr	x0, [sp, #104]
 112372c:	eb0002bf 	cmp	x21, x0
 1123730:	f9400360 	ldr	x0, [x27]
 1123734:	54000109 	b.ls	1123754 <out_of_place_write+0xa4>  // b.plast
	if (pos > meta->length) {
 1123738:	eb13001f 	cmp	x0, x19
 112373c:	54000082 	b.cs	112374c <out_of_place_write+0x9c>  // b.hs, b.nlast
		tee_fs_htree_meta_set_dirty(fdp->ht);
 1123740:	f9400340 	ldr	x0, [x26]
		meta->length = pos;
 1123744:	f9000373 	str	x19, [x27]
		tee_fs_htree_meta_set_dirty(fdp->ht);
 1123748:	940003c5 	bl	112465c <tee_fs_htree_meta_set_dirty>
exit:
 112374c:	52800002 	mov	w2, #0x0                   	// #0
 1123750:	14000012 	b	1123798 <out_of_place_write+0xe8>
		size_t size_to_write = MIN(remain_bytes, (size_t)BLOCK_SIZE);
 1123754:	f14006df 	cmp	x22, #0x1, lsl #12
		size_t offset = pos % BLOCK_SIZE;
 1123758:	92402e77 	and	x23, x19, #0xfff
		size_t size_to_write = MIN(remain_bytes, (size_t)BLOCK_SIZE);
 112375c:	9a9c92d9 	csel	x25, x22, x28, ls  // ls = plast
		if (size_to_write + offset > BLOCK_SIZE)
 1123760:	8b1902e1 	add	x1, x23, x25
 1123764:	f140043f 	cmp	x1, #0x1, lsl #12
 1123768:	54000049 	b.ls	1123770 <out_of_place_write+0xc0>  // b.plast
			size_to_write = BLOCK_SIZE - offset;
 112376c:	cb170399 	sub	x25, x28, x23
		    ROUNDUP(meta->length, BLOCK_SIZE)) {
 1123770:	913ffc00 	add	x0, x0, #0xfff
 1123774:	9274cc00 	and	x0, x0, #0xfffffffffffff000
		if (start_block_num * BLOCK_SIZE <
 1123778:	eb15301f 	cmp	x0, x21, lsl #12
 112377c:	540002c9 	b.ls	11237d4 <out_of_place_write+0x124>  // b.plast
			res = tee_fs_htree_read_block(&fdp->ht,
 1123780:	aa1403e2 	mov	x2, x20
 1123784:	aa1503e1 	mov	x1, x21
 1123788:	aa1a03e0 	mov	x0, x26
 112378c:	9400056a 	bl	1124d34 <tee_fs_htree_read_block>
 1123790:	2a0003e2 	mov	w2, w0
			if (res != TEE_SUCCESS)
 1123794:	34000280 	cbz	w0, 11237e4 <out_of_place_write+0x134>
	mempool_free(mempool_default, tmp_block);
 1123798:	f00001a0 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 112379c:	aa1403e1 	mov	x1, x20
 11237a0:	b9006be2 	str	w2, [sp, #104]
 11237a4:	f9418800 	ldr	x0, [x0, #784]
 11237a8:	f9400000 	ldr	x0, [x0]
 11237ac:	940085e7 	bl	1144f48 <mempool_free>
}
 11237b0:	b9406be2 	ldr	w2, [sp, #104]
}
 11237b4:	2a0203e0 	mov	w0, w2
 11237b8:	a94153f3 	ldp	x19, x20, [sp, #16]
 11237bc:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11237c0:	a94363f7 	ldp	x23, x24, [sp, #48]
 11237c4:	a9446bf9 	ldp	x25, x26, [sp, #64]
 11237c8:	a94573fb 	ldp	x27, x28, [sp, #80]
 11237cc:	a8c77bfd 	ldp	x29, x30, [sp], #112
 11237d0:	d65f03c0 	ret
			memset(block, 0, BLOCK_SIZE);
 11237d4:	aa1403e0 	mov	x0, x20
 11237d8:	d2820002 	mov	x2, #0x1000                	// #4096
 11237dc:	52800001 	mov	w1, #0x0                   	// #0
 11237e0:	94008140 	bl	1143ce0 <memset>
		if (data_ptr)
 11237e4:	8b170280 	add	x0, x20, x23
			memcpy(block + offset, data_ptr, size_to_write);
 11237e8:	aa1903e2 	mov	x2, x25
		if (data_ptr)
 11237ec:	b40001f8 	cbz	x24, 1123828 <out_of_place_write+0x178>
			memcpy(block + offset, data_ptr, size_to_write);
 11237f0:	aa1803e1 	mov	x1, x24
 11237f4:	97ff7ee7 	bl	1103390 <memcpy>
		res = tee_fs_htree_write_block(&fdp->ht, start_block_num,
 11237f8:	aa1403e2 	mov	x2, x20
 11237fc:	aa1503e1 	mov	x1, x21
 1123800:	aa1a03e0 	mov	x0, x26
 1123804:	940004ff 	bl	1124c00 <tee_fs_htree_write_block>
 1123808:	2a0003e2 	mov	w2, w0
		if (res != TEE_SUCCESS)
 112380c:	35fffc60 	cbnz	w0, 1123798 <out_of_place_write+0xe8>
		if (data_ptr)
 1123810:	b4000058 	cbz	x24, 1123818 <out_of_place_write+0x168>
			data_ptr += size_to_write;
 1123814:	8b190318 	add	x24, x24, x25
		remain_bytes -= size_to_write;
 1123818:	cb1902d6 	sub	x22, x22, x25
		start_block_num++;
 112381c:	910006b5 	add	x21, x21, #0x1
		pos += size_to_write;
 1123820:	8b190273 	add	x19, x19, x25
 1123824:	17ffffc1 	b	1123728 <out_of_place_write+0x78>
			memset(block + offset, 0, size_to_write);
 1123828:	52800001 	mov	w1, #0x0                   	// #0
 112382c:	9400812d 	bl	1143ce0 <memset>
 1123830:	17fffff2 	b	11237f8 <out_of_place_write+0x148>
		return TEE_ERROR_BAD_PARAMETERS;
 1123834:	129fff22 	mov	w2, #0xffff0006            	// #-65530
 1123838:	17ffffdf 	b	11237b4 <out_of_place_write+0x104>
		return TEE_ERROR_OUT_OF_MEMORY;
 112383c:	129ffe62 	mov	w2, #0xffff000c            	// #-65524
 1123840:	17ffffdd 	b	11237b4 <out_of_place_write+0x104>

0000000001123844 <ree_fs_ftruncate_internal>:
{
 1123844:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1123848:	910003fd 	mov	x29, sp
 112384c:	a90153f3 	stp	x19, x20, [sp, #16]
 1123850:	aa0003f4 	mov	x20, x0
	struct tee_fs_htree_meta *meta = tee_fs_htree_get_meta(fdp->ht);
 1123854:	f9400000 	ldr	x0, [x0]
{
 1123858:	a9025bf5 	stp	x21, x22, [sp, #32]
 112385c:	aa0103f5 	mov	x21, x1
	struct tee_fs_htree_meta *meta = tee_fs_htree_get_meta(fdp->ht);
 1123860:	9400037d 	bl	1124654 <tee_fs_htree_get_meta>
	if ((size_t)new_file_len > meta->length) {
 1123864:	f9400001 	ldr	x1, [x0]
 1123868:	eb15003f 	cmp	x1, x21
 112386c:	54000102 	b.cs	112388c <ree_fs_ftruncate_internal+0x48>  // b.hs, b.nlast
		res = out_of_place_write(fdp, meta->length, NULL, ext_len);
 1123870:	cb0102a3 	sub	x3, x21, x1
 1123874:	aa1403e0 	mov	x0, x20
}
 1123878:	a94153f3 	ldp	x19, x20, [sp, #16]
		res = out_of_place_write(fdp, meta->length, NULL, ext_len);
 112387c:	d2800002 	mov	x2, #0x0                   	// #0
}
 1123880:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1123884:	a8c37bfd 	ldp	x29, x30, [sp], #48
		res = out_of_place_write(fdp, meta->length, NULL, ext_len);
 1123888:	17ffff8a 	b	11236b0 <out_of_place_write>
		res = tee_fs_htree_truncate(&fdp->ht,
 112388c:	d2820001 	mov	x1, #0x1000                	// #4096
 1123890:	aa0003f6 	mov	x22, x0
 1123894:	aa1403e0 	mov	x0, x20
 1123898:	9ac10ea1 	sdiv	x1, x21, x1
 112389c:	94000570 	bl	1124e5c <tee_fs_htree_truncate>
 11238a0:	2a0003f3 	mov	w19, w0
		if (res != TEE_SUCCESS)
 11238a4:	35000240 	cbnz	w0, 11238ec <ree_fs_ftruncate_internal+0xa8>
				    ROUNDUP(new_file_len, BLOCK_SIZE) /
 11238a8:	913ffea4 	add	x4, x21, #0xfff
		pbn = 2 + bidx + bidx / (block_nodes * 2 - 1);
 11238ac:	d28007a0 	mov	x0, #0x3d                  	// #61
		res = tee_fs_rpc_truncate(OPTEE_RPC_CMD_FS, fdp->fd,
 11238b0:	b9400a81 	ldr	w1, [x20, #8]
				    ROUNDUP(new_file_len, BLOCK_SIZE) /
 11238b4:	934cfc84 	asr	x4, x4, #12
		bidx = 2 * idx + vers;
 11238b8:	d37ff884 	lsl	x4, x4, #1
 11238bc:	91000482 	add	x2, x4, #0x1
		res = tee_fs_rpc_truncate(OPTEE_RPC_CMD_FS, fdp->fd,
 11238c0:	91001084 	add	x4, x4, #0x4
		pbn = 2 + bidx + bidx / (block_nodes * 2 - 1);
 11238c4:	9ac00842 	udiv	x2, x2, x0
		res = tee_fs_rpc_truncate(OPTEE_RPC_CMD_FS, fdp->fd,
 11238c8:	52800040 	mov	w0, #0x2                   	// #2
 11238cc:	8b040042 	add	x2, x2, x4
 11238d0:	d374cc42 	lsl	x2, x2, #12
 11238d4:	940008c9 	bl	1125bf8 <tee_fs_rpc_truncate>
 11238d8:	2a0003f3 	mov	w19, w0
		if (res != TEE_SUCCESS)
 11238dc:	35000080 	cbnz	w0, 11238ec <ree_fs_ftruncate_internal+0xa8>
		tee_fs_htree_meta_set_dirty(fdp->ht);
 11238e0:	f9400280 	ldr	x0, [x20]
		meta->length = new_file_len;
 11238e4:	f90002d5 	str	x21, [x22]
		tee_fs_htree_meta_set_dirty(fdp->ht);
 11238e8:	9400035d 	bl	112465c <tee_fs_htree_meta_set_dirty>
}
 11238ec:	2a1303e0 	mov	w0, w19
 11238f0:	a94153f3 	ldp	x19, x20, [sp, #16]
 11238f4:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11238f8:	a8c37bfd 	ldp	x29, x30, [sp], #48
 11238fc:	d65f03c0 	ret

0000000001123900 <ree_fs_write_primitive>:
	if (!len)
 1123900:	b4000403 	cbz	x3, 1123980 <ree_fs_write_primitive+0x80>
{
 1123904:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1123908:	910003fd 	mov	x29, sp
 112390c:	a9025bf5 	stp	x21, x22, [sp, #32]
 1123910:	aa0003f5 	mov	x21, x0
 1123914:	aa0203f6 	mov	x22, x2
	file_size = tee_fs_htree_get_meta(fdp->ht)->length;
 1123918:	f9400000 	ldr	x0, [x0]
{
 112391c:	a90153f3 	stp	x19, x20, [sp, #16]
 1123920:	aa0103f3 	mov	x19, x1
 1123924:	aa0303f4 	mov	x20, x3
	file_size = tee_fs_htree_get_meta(fdp->ht)->length;
 1123928:	9400034b 	bl	1124654 <tee_fs_htree_get_meta>
	if ((pos + len) < len)
 112392c:	ab13029f 	cmn	x20, x19
 1123930:	540002c2 	b.cs	1123988 <ree_fs_write_primitive+0x88>  // b.hs, b.nlast
	if (file_size < pos) {
 1123934:	f9400000 	ldr	x0, [x0]
 1123938:	eb00027f 	cmp	x19, x0
 112393c:	54000128 	b.hi	1123960 <ree_fs_write_primitive+0x60>  // b.pmore
	return out_of_place_write(fdp, pos, buf, len);
 1123940:	aa1403e3 	mov	x3, x20
 1123944:	aa1603e2 	mov	x2, x22
 1123948:	aa1303e1 	mov	x1, x19
 112394c:	aa1503e0 	mov	x0, x21
}
 1123950:	a94153f3 	ldp	x19, x20, [sp, #16]
 1123954:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1123958:	a8c37bfd 	ldp	x29, x30, [sp], #48
	return out_of_place_write(fdp, pos, buf, len);
 112395c:	17ffff55 	b	11236b0 <out_of_place_write>
		res = ree_fs_ftruncate_internal(fdp, pos);
 1123960:	aa1303e1 	mov	x1, x19
 1123964:	aa1503e0 	mov	x0, x21
 1123968:	97ffffb7 	bl	1123844 <ree_fs_ftruncate_internal>
		if (res != TEE_SUCCESS)
 112396c:	34fffea0 	cbz	w0, 1123940 <ree_fs_write_primitive+0x40>
}
 1123970:	a94153f3 	ldp	x19, x20, [sp, #16]
 1123974:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1123978:	a8c37bfd 	ldp	x29, x30, [sp], #48
 112397c:	d65f03c0 	ret
		return TEE_SUCCESS;
 1123980:	52800000 	mov	w0, #0x0                   	// #0
}
 1123984:	d65f03c0 	ret
		return TEE_ERROR_BAD_PARAMETERS;
 1123988:	129fff20 	mov	w0, #0xffff0006            	// #-65530
 112398c:	17fffff9 	b	1123970 <ree_fs_write_primitive+0x70>

0000000001123990 <ree_fs_create>:
{
 1123990:	a9b27bfd 	stp	x29, x30, [sp, #-224]!
 1123994:	910003fd 	mov	x29, sp
 1123998:	a90153f3 	stp	x19, x20, [sp, #16]
 112399c:	aa0003f4 	mov	x20, x0
 11239a0:	12001c20 	and	w0, w1, #0xff
 11239a4:	f94073f3 	ldr	x19, [sp, #224]
 11239a8:	a9025bf5 	stp	x21, x22, [sp, #32]
 11239ac:	aa0503f5 	mov	x21, x5
 11239b0:	a90363f7 	stp	x23, x24, [sp, #48]
	mutex_lock(&ree_fs_mutex);
 11239b4:	f00001d6 	adrp	x22, 115e000 <state+0x80>
{
 11239b8:	aa0303f7 	mov	x23, x3
 11239bc:	a9046bf9 	stp	x25, x26, [sp, #64]
 11239c0:	aa0703f8 	mov	x24, x7
 11239c4:	aa0203fa 	mov	x26, x2
 11239c8:	a90573fb 	stp	x27, x28, [sp, #80]
 11239cc:	aa0403f9 	mov	x25, x4
	*fh = NULL;
 11239d0:	f900027f 	str	xzr, [x19]
{
 11239d4:	f90037e6 	str	x6, [sp, #104]
 11239d8:	b90077e0 	str	w0, [sp, #116]
	mutex_lock(&ree_fs_mutex);
 11239dc:	9105e2c0 	add	x0, x22, #0x178
	struct tee_fs_dirfile_dirh *dirh = NULL;
 11239e0:	f90047ff 	str	xzr, [sp, #136]
	mutex_lock(&ree_fs_mutex);
 11239e4:	97ffc6dc 	bl	1115554 <mutex_lock>
	res = get_dirh(&dirh);
 11239e8:	910223e0 	add	x0, sp, #0x88
 11239ec:	97fffe2d 	bl	11232a0 <get_dirh>
 11239f0:	2a0003fc 	mov	w28, w0
	if (res)
 11239f4:	35000360 	cbnz	w0, 1123a60 <ree_fs_create+0xd0>
	res = tee_fs_dirfile_get_tmp(dirh, &dfh);
 11239f8:	f94047e0 	ldr	x0, [sp, #136]
 11239fc:	910243e3 	add	x3, sp, #0x90
 1123a00:	aa0303e1 	mov	x1, x3
 1123a04:	f9003fe3 	str	x3, [sp, #120]
 1123a08:	9400063b 	bl	11252f4 <tee_fs_dirfile_get_tmp>
 1123a0c:	2a0003fc 	mov	w28, w0
	if (res)
 1123a10:	35000280 	cbnz	w0, 1123a60 <ree_fs_create+0xd0>
	res = ree_fs_open_primitive(true, dfh.hash, &po->uuid, &dfh, fh);
 1123a14:	f9403fe3 	ldr	x3, [sp, #120]
 1123a18:	9100529b 	add	x27, x20, #0x14
 1123a1c:	aa1303e4 	mov	x4, x19
 1123a20:	aa1b03e2 	mov	x2, x27
 1123a24:	91001061 	add	x1, x3, #0x4
 1123a28:	52800020 	mov	w0, #0x1                   	// #1
 1123a2c:	97fffd01 	bl	1122e30 <ree_fs_open_primitive>
 1123a30:	2a0003fc 	mov	w28, w0
	if (res)
 1123a34:	35000160 	cbnz	w0, 1123a60 <ree_fs_create+0xd0>
	if (head && head_size) {
 1123a38:	f100035f 	cmp	x26, #0x0
 1123a3c:	fa401ae4 	ccmp	x23, #0x0, #0x4, ne  // ne = any
 1123a40:	54000220 	b.eq	1123a84 <ree_fs_create+0xf4>  // b.none
		res = ree_fs_write_primitive(*fh, pos, head, head_size);
 1123a44:	f9400260 	ldr	x0, [x19]
 1123a48:	aa1703e3 	mov	x3, x23
 1123a4c:	aa1a03e2 	mov	x2, x26
 1123a50:	d2800001 	mov	x1, #0x0                   	// #0
 1123a54:	97ffffab 	bl	1123900 <ree_fs_write_primitive>
 1123a58:	2a0003fc 	mov	w28, w0
		if (res)
 1123a5c:	34000160 	cbz	w0, 1123a88 <ree_fs_create+0xf8>
		put_dirh(dirh, true);
 1123a60:	f94047e0 	ldr	x0, [sp, #136]
 1123a64:	52800021 	mov	w1, #0x1                   	// #1
 1123a68:	97fffdd1 	bl	11231ac <put_dirh>
		if (*fh) {
 1123a6c:	f9400260 	ldr	x0, [x19]
 1123a70:	b4000980 	cbz	x0, 1123ba0 <ree_fs_create+0x210>
			ree_fs_close_primitive(*fh);
 1123a74:	97fffda3 	bl	1123100 <ree_fs_close_primitive>
			*fh = NULL;
 1123a78:	f900027f 	str	xzr, [x19]
			tee_fs_rpc_remove_dfh(OPTEE_RPC_CMD_FS, &dfh);
 1123a7c:	910243e1 	add	x1, sp, #0x90
 1123a80:	14000046 	b	1123b98 <ree_fs_create+0x208>
	size_t pos = 0;
 1123a84:	d2800017 	mov	x23, #0x0                   	// #0
	if (attr && attr_size) {
 1123a88:	f100033f 	cmp	x25, #0x0
 1123a8c:	fa401aa4 	ccmp	x21, #0x0, #0x4, ne  // ne = any
 1123a90:	54000120 	b.eq	1123ab4 <ree_fs_create+0x124>  // b.none
		res = ree_fs_write_primitive(*fh, pos, attr, attr_size);
 1123a94:	f9400260 	ldr	x0, [x19]
 1123a98:	aa1503e3 	mov	x3, x21
 1123a9c:	aa1903e2 	mov	x2, x25
 1123aa0:	aa1703e1 	mov	x1, x23
 1123aa4:	97ffff97 	bl	1123900 <ree_fs_write_primitive>
 1123aa8:	2a0003fc 	mov	w28, w0
		if (res)
 1123aac:	35fffda0 	cbnz	w0, 1123a60 <ree_fs_create+0xd0>
		pos += attr_size;
 1123ab0:	8b1502f7 	add	x23, x23, x21
	if (data && data_size) {
 1123ab4:	f94037e0 	ldr	x0, [sp, #104]
 1123ab8:	f100001f 	cmp	x0, #0x0
 1123abc:	fa401b04 	ccmp	x24, #0x0, #0x4, ne  // ne = any
 1123ac0:	54000381 	b.ne	1123b30 <ree_fs_create+0x1a0>  // b.any
	fdp = (struct tee_fs_fd *)*fh;
 1123ac4:	f9400278 	ldr	x24, [x19]
	res = tee_fs_htree_sync_to_storage(&fdp->ht, fdp->dfh.hash);
 1123ac8:	91004301 	add	x1, x24, #0x10
 1123acc:	aa1803e0 	mov	x0, x24
 1123ad0:	940002fb 	bl	11246bc <tee_fs_htree_sync_to_storage>
 1123ad4:	2a0003fc 	mov	w28, w0
	if (res)
 1123ad8:	35fffc40 	cbnz	w0, 1123a60 <ree_fs_create+0xd0>
	res = tee_fs_dirfile_find(dirh, &po->uuid, po->obj_id, po->obj_id_len,
 1123adc:	b9403283 	ldr	w3, [x20, #48]
 1123ae0:	9102e3f7 	add	x23, sp, #0xb8
 1123ae4:	f9401682 	ldr	x2, [x20, #40]
 1123ae8:	aa1703e4 	mov	x4, x23
	res = set_name(dirh, fdp, po, overwrite);
 1123aec:	f94047f9 	ldr	x25, [sp, #136]
	res = tee_fs_dirfile_find(dirh, &po->uuid, po->obj_id, po->obj_id_len,
 1123af0:	aa1b03e1 	mov	x1, x27
	struct tee_fs_dirfile_fileh old_dfh = { .idx = -1 };
 1123af4:	1280001a 	mov	w26, #0xffffffff            	// #-1
 1123af8:	a90bffff 	stp	xzr, xzr, [sp, #184]
	res = tee_fs_dirfile_find(dirh, &po->uuid, po->obj_id, po->obj_id_len,
 1123afc:	aa1903e0 	mov	x0, x25
	struct tee_fs_dirfile_fileh old_dfh = { .idx = -1 };
 1123b00:	a90cffff 	stp	xzr, xzr, [sp, #200]
 1123b04:	291b6bff 	stp	wzr, w26, [sp, #216]
	res = tee_fs_dirfile_find(dirh, &po->uuid, po->obj_id, po->obj_id_len,
 1123b08:	94000620 	bl	1125388 <tee_fs_dirfile_find>
	if (!overwrite && !res)
 1123b0c:	7100001f 	cmp	w0, #0x0
	res = tee_fs_dirfile_find(dirh, &po->uuid, po->obj_id, po->obj_id_len,
 1123b10:	2a0003f5 	mov	w21, w0
	if (!overwrite && !res)
 1123b14:	b94077e0 	ldr	w0, [sp, #116]
 1123b18:	5200001c 	eor	w28, w0, #0x1
 1123b1c:	1a9f17e0 	cset	w0, eq  // eq = none
 1123b20:	6a1c001f 	tst	w0, w28
 1123b24:	54000160 	b.eq	1123b50 <ree_fs_create+0x1c0>  // b.none
		return TEE_ERROR_ACCESS_CONFLICT;
 1123b28:	129fff9c 	mov	w28, #0xffff0003            	// #-65533
 1123b2c:	17ffffcd 	b	1123a60 <ree_fs_create+0xd0>
		res = ree_fs_write_primitive(*fh, pos, data, data_size);
 1123b30:	f9400260 	ldr	x0, [x19]
 1123b34:	aa1803e3 	mov	x3, x24
 1123b38:	f94037e2 	ldr	x2, [sp, #104]
 1123b3c:	aa1703e1 	mov	x1, x23
 1123b40:	97ffff70 	bl	1123900 <ree_fs_write_primitive>
 1123b44:	2a0003fc 	mov	w28, w0
		if (res)
 1123b48:	34fffbe0 	cbz	w0, 1123ac4 <ree_fs_create+0x134>
 1123b4c:	17ffffc5 	b	1123a60 <ree_fs_create+0xd0>
	res = tee_fs_dirfile_rename(dirh, &po->uuid, &fdp->dfh,
 1123b50:	b9403284 	ldr	w4, [x20, #48]
 1123b54:	91003302 	add	x2, x24, #0xc
 1123b58:	f9401683 	ldr	x3, [x20, #40]
 1123b5c:	aa1b03e1 	mov	x1, x27
	fdp->dfh.idx = old_dfh.idx;
 1123b60:	b940dfe0 	ldr	w0, [sp, #220]
 1123b64:	b9003300 	str	w0, [x24, #48]
	res = tee_fs_dirfile_rename(dirh, &po->uuid, &fdp->dfh,
 1123b68:	aa1903e0 	mov	x0, x25
	old_dfh.idx = -1;
 1123b6c:	b900dffa 	str	w26, [sp, #220]
	res = tee_fs_dirfile_rename(dirh, &po->uuid, &fdp->dfh,
 1123b70:	94000675 	bl	1125544 <tee_fs_dirfile_rename>
 1123b74:	2a0003fc 	mov	w28, w0
	if (res)
 1123b78:	35fff740 	cbnz	w0, 1123a60 <ree_fs_create+0xd0>
	return tee_fs_dirfile_commit_writes(dirh, NULL);
 1123b7c:	aa1903e0 	mov	x0, x25
 1123b80:	d2800001 	mov	x1, #0x0                   	// #0
 1123b84:	940005d8 	bl	11252e4 <tee_fs_dirfile_commit_writes>
 1123b88:	2a0003fc 	mov	w28, w0
	if (res)
 1123b8c:	35fff6a0 	cbnz	w0, 1123a60 <ree_fs_create+0xd0>
	if (have_old_dfh)
 1123b90:	35000095 	cbnz	w21, 1123ba0 <ree_fs_create+0x210>
		tee_fs_rpc_remove_dfh(OPTEE_RPC_CMD_FS, &old_dfh);
 1123b94:	aa1703e1 	mov	x1, x23
			tee_fs_rpc_remove_dfh(OPTEE_RPC_CMD_FS, &dfh);
 1123b98:	52800040 	mov	w0, #0x2                   	// #2
 1123b9c:	94000832 	bl	1125c64 <tee_fs_rpc_remove_dfh>
	mutex_unlock(&ree_fs_mutex);
 1123ba0:	9105e2c0 	add	x0, x22, #0x178
 1123ba4:	97ffc64b 	bl	11154d0 <mutex_unlock>
}
 1123ba8:	2a1c03e0 	mov	w0, w28
 1123bac:	a94153f3 	ldp	x19, x20, [sp, #16]
 1123bb0:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1123bb4:	a94363f7 	ldp	x23, x24, [sp, #48]
 1123bb8:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1123bbc:	a94573fb 	ldp	x27, x28, [sp, #80]
 1123bc0:	a8ce7bfd 	ldp	x29, x30, [sp], #224
 1123bc4:	d65f03c0 	ret

0000000001123bc8 <ree_fs_remove>:
{
 1123bc8:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
 1123bcc:	910003fd 	mov	x29, sp
 1123bd0:	a90153f3 	stp	x19, x20, [sp, #16]
 1123bd4:	aa0003f4 	mov	x20, x0
 1123bd8:	a9025bf5 	stp	x21, x22, [sp, #32]
	mutex_lock(&ree_fs_mutex);
 1123bdc:	f00001d5 	adrp	x21, 115e000 <state+0x80>
 1123be0:	9105e2a0 	add	x0, x21, #0x178
{
 1123be4:	f9001bf7 	str	x23, [sp, #48]
	struct tee_fs_dirfile_dirh *dirh = NULL;
 1123be8:	f90023ff 	str	xzr, [sp, #64]
	mutex_lock(&ree_fs_mutex);
 1123bec:	97ffc65a 	bl	1115554 <mutex_lock>
	res = get_dirh(&dirh);
 1123bf0:	910103e0 	add	x0, sp, #0x40
 1123bf4:	97fffdab 	bl	11232a0 <get_dirh>
 1123bf8:	2a0003f3 	mov	w19, w0
	if (res)
 1123bfc:	35000500 	cbnz	w0, 1123c9c <ree_fs_remove+0xd4>
	res = tee_fs_dirfile_find(dirh, &po->uuid, po->obj_id, po->obj_id_len,
 1123c00:	b9403283 	ldr	w3, [x20, #48]
 1123c04:	91005297 	add	x23, x20, #0x14
 1123c08:	f9401682 	ldr	x2, [x20, #40]
 1123c0c:	910123f6 	add	x22, sp, #0x48
 1123c10:	f94023e0 	ldr	x0, [sp, #64]
 1123c14:	aa1603e4 	mov	x4, x22
 1123c18:	aa1703e1 	mov	x1, x23
 1123c1c:	940005db 	bl	1125388 <tee_fs_dirfile_find>
 1123c20:	2a0003f3 	mov	w19, w0
	if (res)
 1123c24:	350003c0 	cbnz	w0, 1123c9c <ree_fs_remove+0xd4>
	res = tee_fs_dirfile_remove(dirh, &dfh);
 1123c28:	f94023e0 	ldr	x0, [sp, #64]
 1123c2c:	aa1603e1 	mov	x1, x22
 1123c30:	9400068a 	bl	1125658 <tee_fs_dirfile_remove>
 1123c34:	2a0003f3 	mov	w19, w0
	if (res)
 1123c38:	35000320 	cbnz	w0, 1123c9c <ree_fs_remove+0xd4>
	return tee_fs_dirfile_commit_writes(dirh, NULL);
 1123c3c:	f94023e0 	ldr	x0, [sp, #64]
 1123c40:	d2800001 	mov	x1, #0x0                   	// #0
 1123c44:	940005a8 	bl	11252e4 <tee_fs_dirfile_commit_writes>
 1123c48:	2a0003f3 	mov	w19, w0
	if (res)
 1123c4c:	35000280 	cbnz	w0, 1123c9c <ree_fs_remove+0xd4>
	tee_fs_rpc_remove_dfh(OPTEE_RPC_CMD_FS, &dfh);
 1123c50:	aa1603e1 	mov	x1, x22
 1123c54:	52800040 	mov	w0, #0x2                   	// #2
 1123c58:	94000803 	bl	1125c64 <tee_fs_rpc_remove_dfh>
	assert(tee_fs_dirfile_find(dirh, &po->uuid, po->obj_id, po->obj_id_len,
 1123c5c:	b9403283 	ldr	w3, [x20, #48]
 1123c60:	aa1603e4 	mov	x4, x22
 1123c64:	f9401682 	ldr	x2, [x20, #40]
 1123c68:	aa1703e1 	mov	x1, x23
 1123c6c:	f94023e0 	ldr	x0, [sp, #64]
 1123c70:	940005c6 	bl	1125388 <tee_fs_dirfile_find>
 1123c74:	35000140 	cbnz	w0, 1123c9c <ree_fs_remove+0xd4>
 1123c78:	d0000183 	adrp	x3, 1155000 <__func__.3826+0xa8>
 1123c7c:	d0000181 	adrp	x1, 1155000 <__func__.3826+0xa8>
 1123c80:	912e4463 	add	x3, x3, #0xb91
 1123c84:	912aac21 	add	x1, x1, #0xaab
 1123c88:	d0000180 	adrp	x0, 1155000 <__func__.3826+0xa8>
 1123c8c:	912c0400 	add	x0, x0, #0xb01
 1123c90:	52806c02 	mov	w2, #0x360                 	// #864
 1123c94:	97ffb986 	bl	11122ac <_assert_log>
 1123c98:	97ffb996 	bl	11122f0 <_assert_break>
	put_dirh(dirh, res);
 1123c9c:	f94023e0 	ldr	x0, [sp, #64]
 1123ca0:	7100027f 	cmp	w19, #0x0
 1123ca4:	1a9f07e1 	cset	w1, ne  // ne = any
 1123ca8:	97fffd41 	bl	11231ac <put_dirh>
	mutex_unlock(&ree_fs_mutex);
 1123cac:	9105e2a0 	add	x0, x21, #0x178
 1123cb0:	97ffc608 	bl	11154d0 <mutex_unlock>
}
 1123cb4:	2a1303e0 	mov	w0, w19
 1123cb8:	a94153f3 	ldp	x19, x20, [sp, #16]
 1123cbc:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1123cc0:	f9401bf7 	ldr	x23, [sp, #48]
 1123cc4:	a8c77bfd 	ldp	x29, x30, [sp], #112
 1123cc8:	d65f03c0 	ret

0000000001123ccc <ree_fs_truncate>:
{
 1123ccc:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 1123cd0:	910003fd 	mov	x29, sp
 1123cd4:	a90153f3 	stp	x19, x20, [sp, #16]
 1123cd8:	aa0003f4 	mov	x20, x0
 1123cdc:	a9025bf5 	stp	x21, x22, [sp, #32]
 1123ce0:	aa0103f6 	mov	x22, x1
	mutex_lock(&ree_fs_mutex);
 1123ce4:	f00001d5 	adrp	x21, 115e000 <state+0x80>
 1123ce8:	9105e2a0 	add	x0, x21, #0x178
	struct tee_fs_dirfile_dirh *dirh = NULL;
 1123cec:	f9001fff 	str	xzr, [sp, #56]
	mutex_lock(&ree_fs_mutex);
 1123cf0:	97ffc619 	bl	1115554 <mutex_lock>
	res = get_dirh(&dirh);
 1123cf4:	9100e3e0 	add	x0, sp, #0x38
 1123cf8:	97fffd6a 	bl	11232a0 <get_dirh>
 1123cfc:	2a0003f3 	mov	w19, w0
	if (res)
 1123d00:	35000280 	cbnz	w0, 1123d50 <ree_fs_truncate+0x84>
	res = ree_fs_ftruncate_internal(fdp, len);
 1123d04:	aa1603e1 	mov	x1, x22
 1123d08:	aa1403e0 	mov	x0, x20
 1123d0c:	97fffece 	bl	1123844 <ree_fs_ftruncate_internal>
 1123d10:	2a0003f3 	mov	w19, w0
	if (res)
 1123d14:	350001e0 	cbnz	w0, 1123d50 <ree_fs_truncate+0x84>
	res = tee_fs_htree_sync_to_storage(&fdp->ht, fdp->dfh.hash);
 1123d18:	91004281 	add	x1, x20, #0x10
 1123d1c:	aa1403e0 	mov	x0, x20
 1123d20:	94000267 	bl	11246bc <tee_fs_htree_sync_to_storage>
 1123d24:	2a0003f3 	mov	w19, w0
	if (res)
 1123d28:	35000140 	cbnz	w0, 1123d50 <ree_fs_truncate+0x84>
	res = tee_fs_dirfile_update_hash(dirh, &fdp->dfh);
 1123d2c:	f9401fe0 	ldr	x0, [sp, #56]
 1123d30:	91003281 	add	x1, x20, #0xc
 1123d34:	9400068f 	bl	1125770 <tee_fs_dirfile_update_hash>
 1123d38:	2a0003f3 	mov	w19, w0
	if (res)
 1123d3c:	350000a0 	cbnz	w0, 1123d50 <ree_fs_truncate+0x84>
	return tee_fs_dirfile_commit_writes(dirh, NULL);
 1123d40:	f9401fe0 	ldr	x0, [sp, #56]
 1123d44:	d2800001 	mov	x1, #0x0                   	// #0
 1123d48:	94000567 	bl	11252e4 <tee_fs_dirfile_commit_writes>
 1123d4c:	2a0003f3 	mov	w19, w0
	put_dirh(dirh, res);
 1123d50:	f9401fe0 	ldr	x0, [sp, #56]
 1123d54:	7100027f 	cmp	w19, #0x0
 1123d58:	1a9f07e1 	cset	w1, ne  // ne = any
 1123d5c:	97fffd14 	bl	11231ac <put_dirh>
	mutex_unlock(&ree_fs_mutex);
 1123d60:	9105e2a0 	add	x0, x21, #0x178
 1123d64:	97ffc5db 	bl	11154d0 <mutex_unlock>
}
 1123d68:	2a1303e0 	mov	w0, w19
 1123d6c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1123d70:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1123d74:	a8c47bfd 	ldp	x29, x30, [sp], #64
 1123d78:	d65f03c0 	ret

0000000001123d7c <ree_fs_write>:
{
 1123d7c:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 1123d80:	910003fd 	mov	x29, sp
 1123d84:	a90153f3 	stp	x19, x20, [sp, #16]
 1123d88:	aa0003f4 	mov	x20, x0
 1123d8c:	a9025bf5 	stp	x21, x22, [sp, #32]
 1123d90:	aa0103f6 	mov	x22, x1
	mutex_lock(&ree_fs_mutex);
 1123d94:	f00001d5 	adrp	x21, 115e000 <state+0x80>
 1123d98:	9105e2a0 	add	x0, x21, #0x178
{
 1123d9c:	a90363f7 	stp	x23, x24, [sp, #48]
 1123da0:	aa0203f7 	mov	x23, x2
 1123da4:	aa0303f8 	mov	x24, x3
	struct tee_fs_dirfile_dirh *dirh = NULL;
 1123da8:	f90027ff 	str	xzr, [sp, #72]
	mutex_lock(&ree_fs_mutex);
 1123dac:	97ffc5ea 	bl	1115554 <mutex_lock>
	res = get_dirh(&dirh);
 1123db0:	910123e0 	add	x0, sp, #0x48
 1123db4:	97fffd3b 	bl	11232a0 <get_dirh>
 1123db8:	2a0003f3 	mov	w19, w0
	if (res)
 1123dbc:	350002c0 	cbnz	w0, 1123e14 <ree_fs_write+0x98>
	res = ree_fs_write_primitive(fh, pos, buf, len);
 1123dc0:	aa1803e3 	mov	x3, x24
 1123dc4:	aa1703e2 	mov	x2, x23
 1123dc8:	aa1603e1 	mov	x1, x22
 1123dcc:	aa1403e0 	mov	x0, x20
 1123dd0:	97fffecc 	bl	1123900 <ree_fs_write_primitive>
 1123dd4:	2a0003f3 	mov	w19, w0
	if (res)
 1123dd8:	350001e0 	cbnz	w0, 1123e14 <ree_fs_write+0x98>
	res = tee_fs_htree_sync_to_storage(&fdp->ht, fdp->dfh.hash);
 1123ddc:	91004281 	add	x1, x20, #0x10
 1123de0:	aa1403e0 	mov	x0, x20
 1123de4:	94000236 	bl	11246bc <tee_fs_htree_sync_to_storage>
 1123de8:	2a0003f3 	mov	w19, w0
	if (res)
 1123dec:	35000140 	cbnz	w0, 1123e14 <ree_fs_write+0x98>
	res = tee_fs_dirfile_update_hash(dirh, &fdp->dfh);
 1123df0:	f94027e0 	ldr	x0, [sp, #72]
 1123df4:	91003281 	add	x1, x20, #0xc
 1123df8:	9400065e 	bl	1125770 <tee_fs_dirfile_update_hash>
 1123dfc:	2a0003f3 	mov	w19, w0
	if (res)
 1123e00:	350000a0 	cbnz	w0, 1123e14 <ree_fs_write+0x98>
	return tee_fs_dirfile_commit_writes(dirh, NULL);
 1123e04:	f94027e0 	ldr	x0, [sp, #72]
 1123e08:	d2800001 	mov	x1, #0x0                   	// #0
 1123e0c:	94000536 	bl	11252e4 <tee_fs_dirfile_commit_writes>
 1123e10:	2a0003f3 	mov	w19, w0
	put_dirh(dirh, res);
 1123e14:	f94027e0 	ldr	x0, [sp, #72]
 1123e18:	7100027f 	cmp	w19, #0x0
 1123e1c:	1a9f07e1 	cset	w1, ne  // ne = any
 1123e20:	97fffce3 	bl	11231ac <put_dirh>
	mutex_unlock(&ree_fs_mutex);
 1123e24:	9105e2a0 	add	x0, x21, #0x178
 1123e28:	97ffc5aa 	bl	11154d0 <mutex_unlock>
}
 1123e2c:	2a1303e0 	mov	w0, w19
 1123e30:	a94153f3 	ldp	x19, x20, [sp, #16]
 1123e34:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1123e38:	a94363f7 	ldp	x23, x24, [sp, #48]
 1123e3c:	a8c57bfd 	ldp	x29, x30, [sp], #80
 1123e40:	d65f03c0 	ret

0000000001123e44 <traverse_post_order>:
	/*
	 * This function is recursing but not very deep, only with Log(N)
	 * maximum depth.
	 */

	if (!node)
 1123e44:	b4000281 	cbz	x1, 1123e94 <traverse_post_order+0x50>
{
 1123e48:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1123e4c:	910003fd 	mov	x29, sp
 1123e50:	a90153f3 	stp	x19, x20, [sp, #16]
 1123e54:	aa0103f3 	mov	x19, x1
		return TEE_SUCCESS;

	res = traverse_post_order(targ, node->child[0]);
 1123e58:	aa0003f4 	mov	x20, x0
 1123e5c:	f9402c21 	ldr	x1, [x1, #88]
 1123e60:	97fffff9 	bl	1123e44 <traverse_post_order>
	if (res != TEE_SUCCESS)
 1123e64:	350001c0 	cbnz	w0, 1123e9c <traverse_post_order+0x58>
		return res;

	res = traverse_post_order(targ, node->child[1]);
 1123e68:	f9403261 	ldr	x1, [x19, #96]
 1123e6c:	aa1403e0 	mov	x0, x20
 1123e70:	97fffff5 	bl	1123e44 <traverse_post_order>
	if (res != TEE_SUCCESS)
 1123e74:	35000140 	cbnz	w0, 1123e9c <traverse_post_order+0x58>
		return res;

	return targ->cb(targ, node);
 1123e78:	aa1303e1 	mov	x1, x19
 1123e7c:	aa1403e0 	mov	x0, x20
 1123e80:	f9400682 	ldr	x2, [x20, #8]
}
 1123e84:	a94153f3 	ldp	x19, x20, [sp, #16]
	return targ->cb(targ, node);
 1123e88:	aa0203f0 	mov	x16, x2
}
 1123e8c:	a8c27bfd 	ldp	x29, x30, [sp], #32
	return targ->cb(targ, node);
 1123e90:	d61f0200 	br	x16
		return TEE_SUCCESS;
 1123e94:	52800000 	mov	w0, #0x0                   	// #0
}
 1123e98:	d65f03c0 	ret
 1123e9c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1123ea0:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1123ea4:	d65f03c0 	ret

0000000001123ea8 <rpc_write>:
{
 1123ea8:	a9b37bfd 	stp	x29, x30, [sp, #-208]!
 1123eac:	910003fd 	mov	x29, sp
 1123eb0:	a90153f3 	stp	x19, x20, [sp, #16]
 1123eb4:	aa0003f3 	mov	x19, x0
 1123eb8:	aa0403f4 	mov	x20, x4
	res = ht->stor->rpc_write_init(ht->stor_aux, &op, type, idx, vers, &p);
 1123ebc:	f9407000 	ldr	x0, [x0, #224]
{
 1123ec0:	a9025bf5 	stp	x21, x22, [sp, #32]
	res = ht->stor->rpc_write_init(ht->stor_aux, &op, type, idx, vers, &p);
 1123ec4:	910103f6 	add	x22, sp, #0x40
{
 1123ec8:	aa0503f5 	mov	x21, x5
	res = ht->stor->rpc_write_init(ht->stor_aux, &op, type, idx, vers, &p);
 1123ecc:	2a0303e4 	mov	w4, w3
 1123ed0:	f9400c06 	ldr	x6, [x0, #24]
 1123ed4:	aa0203e3 	mov	x3, x2
 1123ed8:	f9407660 	ldr	x0, [x19, #232]
 1123edc:	2a0103e2 	mov	w2, w1
 1123ee0:	9100e3e5 	add	x5, sp, #0x38
 1123ee4:	aa1603e1 	mov	x1, x22
 1123ee8:	d63f00c0 	blr	x6
	if (res != TEE_SUCCESS)
 1123eec:	35000120 	cbnz	w0, 1123f10 <rpc_write+0x68>
	memcpy(p, data, dlen);
 1123ef0:	f9401fe0 	ldr	x0, [sp, #56]
 1123ef4:	aa1403e1 	mov	x1, x20
 1123ef8:	aa1503e2 	mov	x2, x21
 1123efc:	97ff7d25 	bl	1103390 <memcpy>
	return ht->stor->rpc_write_final(&op);
 1123f00:	f9407260 	ldr	x0, [x19, #224]
 1123f04:	f9401001 	ldr	x1, [x0, #32]
 1123f08:	aa1603e0 	mov	x0, x22
 1123f0c:	d63f0020 	blr	x1
}
 1123f10:	a94153f3 	ldp	x19, x20, [sp, #16]
 1123f14:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1123f18:	a8cd7bfd 	ldp	x29, x30, [sp], #208
 1123f1c:	d65f03c0 	ret

0000000001123f20 <rpc_read>:
{
 1123f20:	a9b27bfd 	stp	x29, x30, [sp, #-224]!
 1123f24:	910003fd 	mov	x29, sp
 1123f28:	a90153f3 	stp	x19, x20, [sp, #16]
 1123f2c:	aa0003f4 	mov	x20, x0
	res = ht->stor->rpc_read_init(ht->stor_aux, &op, type, idx, vers, &p);
 1123f30:	f9407000 	ldr	x0, [x0, #224]
{
 1123f34:	a9025bf5 	stp	x21, x22, [sp, #32]
 1123f38:	aa0403f5 	mov	x21, x4
 1123f3c:	aa0503f6 	mov	x22, x5
	res = ht->stor->rpc_read_init(ht->stor_aux, &op, type, idx, vers, &p);
 1123f40:	2a0303e4 	mov	w4, w3
 1123f44:	f9400406 	ldr	x6, [x0, #8]
 1123f48:	aa0203e3 	mov	x3, x2
 1123f4c:	f9407680 	ldr	x0, [x20, #232]
{
 1123f50:	f9001bf7 	str	x23, [sp, #48]
	res = ht->stor->rpc_read_init(ht->stor_aux, &op, type, idx, vers, &p);
 1123f54:	910143f7 	add	x23, sp, #0x50
 1123f58:	2a0103e2 	mov	w2, w1
 1123f5c:	910123e5 	add	x5, sp, #0x48
 1123f60:	aa1703e1 	mov	x1, x23
 1123f64:	d63f00c0 	blr	x6
 1123f68:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 1123f6c:	350001c0 	cbnz	w0, 1123fa4 <rpc_read+0x84>
	res = ht->stor->rpc_read_final(&op, &bytes);
 1123f70:	f9407280 	ldr	x0, [x20, #224]
 1123f74:	910103e1 	add	x1, sp, #0x40
 1123f78:	f9400802 	ldr	x2, [x0, #16]
 1123f7c:	aa1703e0 	mov	x0, x23
 1123f80:	d63f0040 	blr	x2
 1123f84:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 1123f88:	350000e0 	cbnz	w0, 1123fa4 <rpc_read+0x84>
	if (bytes != dlen)
 1123f8c:	f94023e2 	ldr	x2, [sp, #64]
 1123f90:	eb16005f 	cmp	x2, x22
 1123f94:	54000141 	b.ne	1123fbc <rpc_read+0x9c>  // b.any
	memcpy(data, p, dlen);
 1123f98:	f94027e1 	ldr	x1, [sp, #72]
 1123f9c:	aa1503e0 	mov	x0, x21
 1123fa0:	97ff7cfc 	bl	1103390 <memcpy>
}
 1123fa4:	2a1303e0 	mov	w0, w19
 1123fa8:	a94153f3 	ldp	x19, x20, [sp, #16]
 1123fac:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1123fb0:	f9401bf7 	ldr	x23, [sp, #48]
 1123fb4:	a8ce7bfd 	ldp	x29, x30, [sp], #224
 1123fb8:	d65f03c0 	ret
		return TEE_ERROR_CORRUPT_OBJECT;
 1123fbc:	52800033 	mov	w19, #0x1                   	// #1
 1123fc0:	72be0213 	movk	w19, #0xf010, lsl #16
 1123fc4:	17fffff8 	b	1123fa4 <rpc_read+0x84>

0000000001123fc8 <authenc_init>:

static TEE_Result authenc_init(void **ctx_ret, TEE_OperationMode mode,
			       struct tee_fs_htree *ht,
			       struct tee_fs_htree_node_image *ni,
			       size_t payload_len)
{
 1123fc8:	d101c3ff 	sub	sp, sp, #0x70
 1123fcc:	a9017bfd 	stp	x29, x30, [sp, #16]
 1123fd0:	910043fd 	add	x29, sp, #0x10
 1123fd4:	a90253f3 	stp	x19, x20, [sp, #32]
 1123fd8:	2a0103f4 	mov	w20, w1
 1123fdc:	a9035bf5 	stp	x21, x22, [sp, #48]
 1123fe0:	aa0003f5 	mov	x21, x0
 1123fe4:	a90463f7 	stp	x23, x24, [sp, #64]
 1123fe8:	aa0203f7 	mov	x23, x2
 1123fec:	aa0303f8 	mov	x24, x3
 1123ff0:	a9056bf9 	stp	x25, x26, [sp, #80]
 1123ff4:	aa0403f9 	mov	x25, x4
	const uint32_t alg = TEE_FS_HTREE_AUTH_ENC_ALG;
	void *ctx;
	size_t aad_len = TEE_FS_HTREE_FEK_SIZE + TEE_FS_HTREE_IV_SIZE;
	uint8_t *iv;

	if (ni) {
 1123ff8:	b4000503 	cbz	x3, 1124098 <authenc_init+0xd0>
		iv = ni->iv;
 1123ffc:	91008076 	add	x22, x3, #0x20
	size_t aad_len = TEE_FS_HTREE_FEK_SIZE + TEE_FS_HTREE_IV_SIZE;
 1124000:	d280041a 	mov	x26, #0x20                  	// #32
	} else {
		iv = ht->head.iv;
		aad_len += TEE_FS_HTREE_HASH_SIZE + sizeof(ht->head.counter);
	}

	if (mode == TEE_MODE_ENCRYPT) {
 1124004:	34000514 	cbz	w20, 11240a4 <authenc_init+0xdc>
		res = crypto_rng_read(iv, TEE_FS_HTREE_IV_SIZE);
		if (res != TEE_SUCCESS)
			return res;
	}

	res = crypto_authenc_alloc_ctx(&ctx, alg);
 1124008:	52810201 	mov	w1, #0x810                 	// #2064
 112400c:	9101a3e0 	add	x0, sp, #0x68
 1124010:	72a80001 	movk	w1, #0x4000, lsl #16
 1124014:	97ffa67a 	bl	110d9fc <crypto_authenc_alloc_ctx>
 1124018:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 112401c:	350004e0 	cbnz	w0, 11240b8 <authenc_init+0xf0>
		return res;

	res = crypto_authenc_init(ctx, mode, ht->fek, TEE_FS_HTREE_FEK_SIZE, iv,
 1124020:	f94037e0 	ldr	x0, [sp, #104]
 1124024:	f90003f9 	str	x25, [sp]
 1124028:	d2800206 	mov	x6, #0x10                  	// #16
 112402c:	aa1a03e7 	mov	x7, x26
 1124030:	aa0603e5 	mov	x5, x6
 1124034:	aa1603e4 	mov	x4, x22
 1124038:	aa0603e3 	mov	x3, x6
 112403c:	9102b2e2 	add	x2, x23, #0xac
 1124040:	2a1403e1 	mov	w1, w20
 1124044:	97ffa687 	bl	110da60 <crypto_authenc_init>
 1124048:	2a0003f3 	mov	w19, w0
				  TEE_FS_HTREE_IV_SIZE, TEE_FS_HTREE_TAG_SIZE,
				  aad_len, payload_len);
	if (res != TEE_SUCCESS)
 112404c:	35000660 	cbnz	w0, 1124118 <authenc_init+0x150>
		goto err_free;

	if (!ni) {
 1124050:	b4000458 	cbz	x24, 11240d8 <authenc_init+0x110>
						sizeof(ht->head.counter));
		if (res != TEE_SUCCESS)
			goto err;
	}

	res = crypto_authenc_update_aad(ctx, mode, ht->head.enc_fek,
 1124054:	f94037e0 	ldr	x0, [sp, #104]
 1124058:	910222e2 	add	x2, x23, #0x88
 112405c:	2a1403e1 	mov	w1, w20
 1124060:	d2800203 	mov	x3, #0x10                  	// #16
 1124064:	97ffa69e 	bl	110dadc <crypto_authenc_update_aad>
 1124068:	2a0003f3 	mov	w19, w0
					TEE_FS_HTREE_FEK_SIZE);
	if (res != TEE_SUCCESS)
 112406c:	35000520 	cbnz	w0, 1124110 <authenc_init+0x148>
		goto err;

	res = crypto_authenc_update_aad(ctx, mode, iv, TEE_FS_HTREE_IV_SIZE);
 1124070:	f94037e0 	ldr	x0, [sp, #104]
 1124074:	aa1603e2 	mov	x2, x22
 1124078:	2a1403e1 	mov	w1, w20
 112407c:	d2800203 	mov	x3, #0x10                  	// #16
 1124080:	97ffa697 	bl	110dadc <crypto_authenc_update_aad>
 1124084:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 1124088:	35000440 	cbnz	w0, 1124110 <authenc_init+0x148>
		goto err;

	*ctx_ret = ctx;
 112408c:	f94037e0 	ldr	x0, [sp, #104]
 1124090:	f90002a0 	str	x0, [x21]

	return TEE_SUCCESS;
 1124094:	14000009 	b	11240b8 <authenc_init+0xf0>
		iv = ht->head.iv;
 1124098:	9101a056 	add	x22, x2, #0x68
		aad_len += TEE_FS_HTREE_HASH_SIZE + sizeof(ht->head.counter);
 112409c:	d280089a 	mov	x26, #0x44                  	// #68
 11240a0:	17ffffd9 	b	1124004 <authenc_init+0x3c>
		res = crypto_rng_read(iv, TEE_FS_HTREE_IV_SIZE);
 11240a4:	aa1603e0 	mov	x0, x22
 11240a8:	d2800201 	mov	x1, #0x10                  	// #16
 11240ac:	97ffad40 	bl	110f5ac <crypto_rng_read>
 11240b0:	2a0003f3 	mov	w19, w0
		if (res != TEE_SUCCESS)
 11240b4:	34fffaa0 	cbz	w0, 1124008 <authenc_init+0x40>
err:
	crypto_authenc_final(ctx);
err_free:
	crypto_authenc_free_ctx(ctx);
	return res;
}
 11240b8:	2a1303e0 	mov	w0, w19
 11240bc:	a9417bfd 	ldp	x29, x30, [sp, #16]
 11240c0:	a94253f3 	ldp	x19, x20, [sp, #32]
 11240c4:	a9435bf5 	ldp	x21, x22, [sp, #48]
 11240c8:	a94463f7 	ldp	x23, x24, [sp, #64]
 11240cc:	a9456bf9 	ldp	x25, x26, [sp, #80]
 11240d0:	9101c3ff 	add	sp, sp, #0x70
 11240d4:	d65f03c0 	ret
		res = crypto_authenc_update_aad(ctx, mode, ht->root.node.hash,
 11240d8:	f94037e0 	ldr	x0, [sp, #104]
 11240dc:	91002ae2 	add	x2, x23, #0xa
 11240e0:	2a1403e1 	mov	w1, w20
 11240e4:	d2800203 	mov	x3, #0x10                  	// #16
 11240e8:	97ffa67d 	bl	110dadc <crypto_authenc_update_aad>
 11240ec:	2a0003f3 	mov	w19, w0
		if (res != TEE_SUCCESS)
 11240f0:	35000100 	cbnz	w0, 1124110 <authenc_init+0x148>
		res = crypto_authenc_update_aad(ctx, mode,
 11240f4:	f94037e0 	ldr	x0, [sp, #104]
 11240f8:	9102a2e2 	add	x2, x23, #0xa8
 11240fc:	2a1403e1 	mov	w1, w20
 1124100:	d2800083 	mov	x3, #0x4                   	// #4
 1124104:	97ffa676 	bl	110dadc <crypto_authenc_update_aad>
 1124108:	2a0003f3 	mov	w19, w0
		if (res != TEE_SUCCESS)
 112410c:	34fffa40 	cbz	w0, 1124054 <authenc_init+0x8c>
	crypto_authenc_final(ctx);
 1124110:	f94037e0 	ldr	x0, [sp, #104]
 1124114:	97ffa6ea 	bl	110dcbc <crypto_authenc_final>
	crypto_authenc_free_ctx(ctx);
 1124118:	f94037e0 	ldr	x0, [sp, #104]
 112411c:	97ffa6f3 	bl	110dce8 <crypto_authenc_free_ctx>
	return res;
 1124120:	17ffffe6 	b	11240b8 <authenc_init+0xf0>

0000000001124124 <authenc_decrypt_final>:

static TEE_Result authenc_decrypt_final(void *ctx, const uint8_t *tag,
					const void *crypt, size_t len,
					void *plain)
{
 1124124:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 1124128:	aa0103e5 	mov	x5, x1
 112412c:	aa0203e1 	mov	x1, x2
 1124130:	910003fd 	mov	x29, sp
 1124134:	a90153f3 	stp	x19, x20, [sp, #16]
 1124138:	aa0303f4 	mov	x20, x3
	TEE_Result res;
	size_t out_size = len;

	res = crypto_authenc_dec_final(ctx, crypt, len, plain, &out_size, tag,
 112413c:	aa1403e2 	mov	x2, x20
{
 1124140:	aa0403e3 	mov	x3, x4
	res = crypto_authenc_dec_final(ctx, crypt, len, plain, &out_size, tag,
 1124144:	9100e3e4 	add	x4, sp, #0x38
 1124148:	d2800206 	mov	x6, #0x10                  	// #16
{
 112414c:	f90013f5 	str	x21, [sp, #32]
 1124150:	aa0003f5 	mov	x21, x0
	size_t out_size = len;
 1124154:	f9001ff4 	str	x20, [sp, #56]
	res = crypto_authenc_dec_final(ctx, crypt, len, plain, &out_size, tag,
 1124158:	97ffa6b6 	bl	110dc30 <crypto_authenc_dec_final>
 112415c:	2a0003f3 	mov	w19, w0
				       TEE_FS_HTREE_TAG_SIZE);
	crypto_authenc_final(ctx);
 1124160:	aa1503e0 	mov	x0, x21
 1124164:	97ffa6d6 	bl	110dcbc <crypto_authenc_final>
	crypto_authenc_free_ctx(ctx);
 1124168:	aa1503e0 	mov	x0, x21
 112416c:	97ffa6df 	bl	110dce8 <crypto_authenc_free_ctx>

	if (res == TEE_SUCCESS && out_size != len)
 1124170:	35000153 	cbnz	w19, 1124198 <authenc_decrypt_final+0x74>
		return TEE_ERROR_GENERIC;
 1124174:	f9401fe0 	ldr	x0, [sp, #56]
 1124178:	52bffff3 	mov	w19, #0xffff0000            	// #-65536
 112417c:	eb14001f 	cmp	x0, x20
 1124180:	1a9303f3 	csel	w19, wzr, w19, eq  // eq = none
	if (res == TEE_ERROR_MAC_INVALID)
		return TEE_ERROR_CORRUPT_OBJECT;

	return res;
}
 1124184:	2a1303e0 	mov	w0, w19
 1124188:	a94153f3 	ldp	x19, x20, [sp, #16]
 112418c:	f94013f5 	ldr	x21, [sp, #32]
 1124190:	a8c47bfd 	ldp	x29, x30, [sp], #64
 1124194:	d65f03c0 	ret
		return TEE_ERROR_CORRUPT_OBJECT;
 1124198:	1299f1c0 	mov	w0, #0xffff3071            	// #-53135
 112419c:	6b00027f 	cmp	w19, w0
 11241a0:	52800020 	mov	w0, #0x1                   	// #1
 11241a4:	72be0200 	movk	w0, #0xf010, lsl #16
 11241a8:	1a801273 	csel	w19, w19, w0, ne  // ne = any
 11241ac:	17fffff6 	b	1124184 <authenc_decrypt_final+0x60>

00000000011241b0 <find_closest_node>:
	assert(node_id && node_id < UINT_MAX);
 11241b0:	d1000423 	sub	x3, x1, #0x1
 11241b4:	12800042 	mov	w2, #0xfffffffd            	// #-3
 11241b8:	eb02007f 	cmp	x3, x2
 11241bc:	54000189 	b.ls	11241ec <find_closest_node+0x3c>  // b.plast
 11241c0:	b0000183 	adrp	x3, 1155000 <__func__.3826+0xa8>
 11241c4:	b0000181 	adrp	x1, 1155000 <__func__.3826+0xa8>
 11241c8:	91328463 	add	x3, x3, #0xca1
 11241cc:	912e7c21 	add	x1, x1, #0xb9f
 11241d0:	b0000180 	adrp	x0, 1155000 <__func__.3826+0xa8>
 11241d4:	912ecc00 	add	x0, x0, #0xbb3
{
 11241d8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	assert(node_id && node_id < UINT_MAX);
 11241dc:	52801a62 	mov	w2, #0xd3                  	// #211
{
 11241e0:	910003fd 	mov	x29, sp
	assert(node_id && node_id < UINT_MAX);
 11241e4:	97ffb832 	bl	11122ac <_assert_log>
 11241e8:	97ffb842 	bl	11122f0 <_assert_break>
	return sizeof(unsigned int) * 8 - __builtin_clz(node_id);
 11241ec:	5ac01023 	clz	w3, w1
 11241f0:	d2800404 	mov	x4, #0x20                  	// #32
 11241f4:	2a0303e2 	mov	w2, w3
	for (n = 1; n < level; n++) {
 11241f8:	d2800025 	mov	x5, #0x1                   	// #1
	return sizeof(unsigned int) * 8 - __builtin_clz(node_id);
 11241fc:	cb23c084 	sub	x4, x4, w3, sxtw
	for (n = 1; n < level; n++) {
 1124200:	d28003c3 	mov	x3, #0x1e                  	// #30
 1124204:	4b020063 	sub	w3, w3, w2
 1124208:	eb0400bf 	cmp	x5, x4
 112420c:	54000041 	b.ne	1124214 <find_closest_node+0x64>  // b.any
}
 1124210:	d65f03c0 	ret
		child = node->child[((node_id >> bit_idx) & 1)];
 1124214:	9ac32422 	lsr	x2, x1, x3
 1124218:	92400042 	and	x2, x2, #0x1
 112421c:	91002842 	add	x2, x2, #0xa
 1124220:	51000463 	sub	w3, w3, #0x1
 1124224:	8b020c02 	add	x2, x0, x2, lsl #3
 1124228:	f9400442 	ldr	x2, [x2, #8]
		if (!child)
 112422c:	b4ffff22 	cbz	x2, 1124210 <find_closest_node+0x60>
	for (n = 1; n < level; n++) {
 1124230:	910004a5 	add	x5, x5, #0x1
 1124234:	aa0203e0 	mov	x0, x2
 1124238:	17fffff4 	b	1124208 <find_closest_node+0x58>

000000000112423c <get_node>:
{
 112423c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 1124240:	910003fd 	mov	x29, sp
 1124244:	a90153f3 	stp	x19, x20, [sp, #16]
 1124248:	a9025bf5 	stp	x21, x22, [sp, #32]
 112424c:	aa0003f5 	mov	x21, x0
 1124250:	aa0203f6 	mov	x22, x2
 1124254:	a90363f7 	stp	x23, x24, [sp, #48]
 1124258:	12001c38 	and	w24, w1, #0xff
 112425c:	aa0303f7 	mov	x23, x3
	node = find_closest_node(ht, node_id);
 1124260:	aa0203e1 	mov	x1, x2
 1124264:	97ffffd3 	bl	11241b0 <find_closest_node>
	if (!node)
 1124268:	b4000780 	cbz	x0, 1124358 <get_node+0x11c>
	if (node->id == node_id)
 112426c:	f9400014 	ldr	x20, [x0]
 1124270:	aa0003f3 	mov	x19, x0
 1124274:	eb16029f 	cmp	x20, x22
 1124278:	54000140 	b.eq	11242a0 <get_node+0x64>  // b.none
	if (!create)
 112427c:	340006f8 	cbz	w24, 1124358 <get_node+0x11c>
	for (n = node->id + 1; n <= node_id; n++) {
 1124280:	91000694 	add	x20, x20, #0x1
 1124284:	eb16029f 	cmp	x20, x22
 1124288:	540001a9 	b.ls	11242bc <get_node+0x80>  // b.plast
	if (node->id > ht->imeta.max_node_id)
 112428c:	f9400260 	ldr	x0, [x19]
 1124290:	b940caa1 	ldr	w1, [x21, #200]
 1124294:	eb01001f 	cmp	x0, x1
 1124298:	54000049 	b.ls	11242a0 <get_node+0x64>  // b.plast
		ht->imeta.max_node_id = node->id;
 112429c:	b900caa0 	str	w0, [x21, #200]
	return TEE_SUCCESS;
 11242a0:	52800000 	mov	w0, #0x0                   	// #0
	*node_ret = node;
 11242a4:	f90002f3 	str	x19, [x23]
}
 11242a8:	a94153f3 	ldp	x19, x20, [sp, #16]
 11242ac:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11242b0:	a94363f7 	ldp	x23, x24, [sp, #48]
 11242b4:	a8c47bfd 	ldp	x29, x30, [sp], #64
 11242b8:	d65f03c0 	ret
		node = find_closest_node(ht, n);
 11242bc:	aa1403e1 	mov	x1, x20
 11242c0:	aa1503e0 	mov	x0, x21
 11242c4:	97ffffbb 	bl	11241b0 <find_closest_node>
 11242c8:	aa0003f3 	mov	x19, x0
		if (node->id == n)
 11242cc:	f9400000 	ldr	x0, [x0]
 11242d0:	eb14001f 	cmp	x0, x20
 11242d4:	54fffd60 	b.eq	1124280 <get_node+0x44>  // b.none
		assert((n >> 1) == node->id);
 11242d8:	eb54041f 	cmp	x0, x20, lsr #1
 11242dc:	54000140 	b.eq	1124304 <get_node+0xc8>  // b.none
 11242e0:	b0000183 	adrp	x3, 1155000 <__func__.3826+0xa8>
 11242e4:	b0000181 	adrp	x1, 1155000 <__func__.3826+0xa8>
 11242e8:	b0000180 	adrp	x0, 1155000 <__func__.3826+0xa8>
 11242ec:	9132c863 	add	x3, x3, #0xcb2
 11242f0:	912e7c21 	add	x1, x1, #0xb9f
 11242f4:	912f4400 	add	x0, x0, #0xbd1
 11242f8:	52802362 	mov	w2, #0x11b                 	// #283
		assert(!node->child[n & 1]);
 11242fc:	97ffb7ec 	bl	11122ac <_assert_log>
 1124300:	97ffb7fc 	bl	11122f0 <_assert_break>
 1124304:	d37d0298 	ubfiz	x24, x20, #3, #1
 1124308:	8b180278 	add	x24, x19, x24
 112430c:	f9402f00 	ldr	x0, [x24, #88]
 1124310:	b4000120 	cbz	x0, 1124334 <get_node+0xf8>
 1124314:	b0000183 	adrp	x3, 1155000 <__func__.3826+0xa8>
 1124318:	b0000181 	adrp	x1, 1155000 <__func__.3826+0xa8>
 112431c:	b0000180 	adrp	x0, 1155000 <__func__.3826+0xa8>
 1124320:	9132c863 	add	x3, x3, #0xcb2
 1124324:	912e7c21 	add	x1, x1, #0xb9f
 1124328:	912f9800 	add	x0, x0, #0xbe6
 112432c:	52802382 	mov	w2, #0x11c                 	// #284
 1124330:	17fffff3 	b	11242fc <get_node+0xc0>
		nc = calloc(1, sizeof(*nc));
 1124334:	d2800d01 	mov	x1, #0x68                  	// #104
 1124338:	d2800020 	mov	x0, #0x1                   	// #1
 112433c:	94007c65 	bl	11434d0 <calloc>
		if (!nc)
 1124340:	b4000100 	cbz	x0, 1124360 <get_node+0x124>
		nc->id = n;
 1124344:	f9000014 	str	x20, [x0]
		nc->parent = node;
 1124348:	f9002813 	str	x19, [x0, #80]
		node->child[n & 1] = nc;
 112434c:	aa0003f3 	mov	x19, x0
 1124350:	f9002f00 	str	x0, [x24, #88]
		node = nc;
 1124354:	17ffffcb 	b	1124280 <get_node+0x44>
		return TEE_ERROR_GENERIC;
 1124358:	52bfffe0 	mov	w0, #0xffff0000            	// #-65536
 112435c:	17ffffd3 	b	11242a8 <get_node+0x6c>
			return TEE_ERROR_OUT_OF_MEMORY;
 1124360:	129ffe60 	mov	w0, #0xffff000c            	// #-65524
 1124364:	17ffffd1 	b	11242a8 <get_node+0x6c>

0000000001124368 <free_node>:
	ht->root.dirty = true;
}

static TEE_Result free_node(struct traverse_arg *targ __unused,
			    struct htree_node *node)
{
 1124368:	aa0103e0 	mov	x0, x1
	if (node->parent)
 112436c:	f9402821 	ldr	x1, [x1, #80]
 1124370:	b40000e1 	cbz	x1, 112438c <free_node+0x24>
{
 1124374:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 1124378:	910003fd 	mov	x29, sp
		free(node);
 112437c:	94007c99 	bl	11435e0 <free>
	return TEE_SUCCESS;
}
 1124380:	52800000 	mov	w0, #0x0                   	// #0
 1124384:	a8c17bfd 	ldp	x29, x30, [sp], #16
 1124388:	d65f03c0 	ret
 112438c:	52800000 	mov	w0, #0x0                   	// #0
 1124390:	d65f03c0 	ret

0000000001124394 <authenc_encrypt_final>:
{
 1124394:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 1124398:	aa0103e5 	mov	x5, x1
 112439c:	aa0203e1 	mov	x1, x2
 11243a0:	910003fd 	mov	x29, sp
	size_t out_tag_size = TEE_FS_HTREE_TAG_SIZE;
 11243a4:	d2800202 	mov	x2, #0x10                  	// #16
{
 11243a8:	a90153f3 	stp	x19, x20, [sp, #16]
 11243ac:	aa0303f4 	mov	x20, x3
	res = crypto_authenc_enc_final(ctx, plain, len, crypt, &out_size, tag,
 11243b0:	9100e3e6 	add	x6, sp, #0x38
{
 11243b4:	aa0403e3 	mov	x3, x4
	res = crypto_authenc_enc_final(ctx, plain, len, crypt, &out_size, tag,
 11243b8:	9100c3e4 	add	x4, sp, #0x30
	size_t out_tag_size = TEE_FS_HTREE_TAG_SIZE;
 11243bc:	a9030bf4 	stp	x20, x2, [sp, #48]
	res = crypto_authenc_enc_final(ctx, plain, len, crypt, &out_size, tag,
 11243c0:	aa1403e2 	mov	x2, x20
{
 11243c4:	f90013f5 	str	x21, [sp, #32]
 11243c8:	aa0003f5 	mov	x21, x0
	res = crypto_authenc_enc_final(ctx, plain, len, crypt, &out_size, tag,
 11243cc:	97ffa5f6 	bl	110dba4 <crypto_authenc_enc_final>
 11243d0:	2a0003f3 	mov	w19, w0
	crypto_authenc_final(ctx);
 11243d4:	aa1503e0 	mov	x0, x21
 11243d8:	97ffa639 	bl	110dcbc <crypto_authenc_final>
	crypto_authenc_free_ctx(ctx);
 11243dc:	aa1503e0 	mov	x0, x21
 11243e0:	97ffa642 	bl	110dce8 <crypto_authenc_free_ctx>
	if (res == TEE_SUCCESS &&
 11243e4:	35000113 	cbnz	w19, 1124404 <authenc_encrypt_final+0x70>
 11243e8:	f9401be0 	ldr	x0, [sp, #48]
 11243ec:	eb14001f 	cmp	x0, x20
 11243f0:	54000141 	b.ne	1124418 <authenc_encrypt_final+0x84>  // b.any
		return TEE_ERROR_GENERIC;
 11243f4:	f9401fe0 	ldr	x0, [sp, #56]
 11243f8:	52bffff3 	mov	w19, #0xffff0000            	// #-65536
 11243fc:	f100401f 	cmp	x0, #0x10
 1124400:	1a9303f3 	csel	w19, wzr, w19, eq  // eq = none
}
 1124404:	2a1303e0 	mov	w0, w19
 1124408:	a94153f3 	ldp	x19, x20, [sp, #16]
 112440c:	f94013f5 	ldr	x21, [sp, #32]
 1124410:	a8c47bfd 	ldp	x29, x30, [sp], #64
 1124414:	d65f03c0 	ret
		return TEE_ERROR_GENERIC;
 1124418:	52bffff3 	mov	w19, #0xffff0000            	// #-65536
 112441c:	17fffffa 	b	1124404 <authenc_encrypt_final+0x70>

0000000001124420 <calc_node_hash>:
{
 1124420:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1124424:	910003fd 	mov	x29, sp
 1124428:	a90153f3 	stp	x19, x20, [sp, #16]
 112442c:	aa0003f4 	mov	x20, x0
 1124430:	aa0203f3 	mov	x19, x2
	res = crypto_hash_init(ctx);
 1124434:	aa0203e0 	mov	x0, x2
{
 1124438:	a9025bf5 	stp	x21, x22, [sp, #32]
 112443c:	aa0103f5 	mov	x21, x1
 1124440:	aa0303f6 	mov	x22, x3
	res = crypto_hash_init(ctx);
 1124444:	97ffa3ad 	bl	110d2f8 <crypto_hash_init>
	if (res != TEE_SUCCESS)
 1124448:	350002e0 	cbnz	w0, 11244a4 <calc_node_hash+0x84>
	res = crypto_hash_update(ctx, ndata, nsize);
 112444c:	9100aa81 	add	x1, x20, #0x2a
 1124450:	aa1303e0 	mov	x0, x19
 1124454:	d2800442 	mov	x2, #0x22                  	// #34
 1124458:	97ffa3b3 	bl	110d324 <crypto_hash_update>
	if (res != TEE_SUCCESS)
 112445c:	35000240 	cbnz	w0, 11244a4 <calc_node_hash+0x84>
	if (meta) {
 1124460:	b5000195 	cbnz	x21, 1124490 <calc_node_hash+0x70>
	if (node->child[0]) {
 1124464:	f9402e81 	ldr	x1, [x20, #88]
 1124468:	b5000261 	cbnz	x1, 11244b4 <calc_node_hash+0x94>
	if (node->child[1]) {
 112446c:	f9403281 	ldr	x1, [x20, #96]
 1124470:	b50002e1 	cbnz	x1, 11244cc <calc_node_hash+0xac>
	return crypto_hash_final(ctx, digest, TEE_FS_HTREE_HASH_SIZE);
 1124474:	aa1603e1 	mov	x1, x22
 1124478:	aa1303e0 	mov	x0, x19
}
 112447c:	a94153f3 	ldp	x19, x20, [sp, #16]
	return crypto_hash_final(ctx, digest, TEE_FS_HTREE_HASH_SIZE);
 1124480:	d2800402 	mov	x2, #0x20                  	// #32
}
 1124484:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1124488:	a8c37bfd 	ldp	x29, x30, [sp], #48
	return crypto_hash_final(ctx, digest, TEE_FS_HTREE_HASH_SIZE);
 112448c:	17ffa3b7 	b	110d368 <crypto_hash_final>
		res = crypto_hash_update(ctx, (void *)meta, sizeof(*meta));
 1124490:	aa1503e1 	mov	x1, x21
 1124494:	aa1303e0 	mov	x0, x19
 1124498:	d2800102 	mov	x2, #0x8                   	// #8
 112449c:	97ffa3a2 	bl	110d324 <crypto_hash_update>
		if (res != TEE_SUCCESS)
 11244a0:	34fffe20 	cbz	w0, 1124464 <calc_node_hash+0x44>
}
 11244a4:	a94153f3 	ldp	x19, x20, [sp, #16]
 11244a8:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11244ac:	a8c37bfd 	ldp	x29, x30, [sp], #48
 11244b0:	d65f03c0 	ret
		res = crypto_hash_update(ctx, node->child[0]->node.hash,
 11244b4:	91002821 	add	x1, x1, #0xa
 11244b8:	aa1303e0 	mov	x0, x19
 11244bc:	d2800402 	mov	x2, #0x20                  	// #32
 11244c0:	97ffa399 	bl	110d324 <crypto_hash_update>
		if (res != TEE_SUCCESS)
 11244c4:	34fffd40 	cbz	w0, 112446c <calc_node_hash+0x4c>
 11244c8:	17fffff7 	b	11244a4 <calc_node_hash+0x84>
		res = crypto_hash_update(ctx, node->child[1]->node.hash,
 11244cc:	91002821 	add	x1, x1, #0xa
 11244d0:	aa1303e0 	mov	x0, x19
 11244d4:	d2800402 	mov	x2, #0x20                  	// #32
 11244d8:	97ffa393 	bl	110d324 <crypto_hash_update>
		if (res != TEE_SUCCESS)
 11244dc:	34fffcc0 	cbz	w0, 1124474 <calc_node_hash+0x54>
 11244e0:	17fffff1 	b	11244a4 <calc_node_hash+0x84>

00000000011244e4 <verify_node>:
{
 11244e4:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 11244e8:	910003fd 	mov	x29, sp
 11244ec:	a90153f3 	stp	x19, x20, [sp, #16]
 11244f0:	aa0103f3 	mov	x19, x1
 11244f4:	910083f4 	add	x20, sp, #0x20
	if (node->parent)
 11244f8:	f9402821 	ldr	x1, [x1, #80]
	void *ctx = targ->arg;
 11244fc:	f9400802 	ldr	x2, [x0, #16]
	if (node->parent)
 1124500:	b4000221 	cbz	x1, 1124544 <verify_node+0x60>
		res = calc_node_hash(node, NULL, ctx, digest);
 1124504:	aa1403e3 	mov	x3, x20
 1124508:	d2800001 	mov	x1, #0x0                   	// #0
		res = calc_node_hash(node, &targ->ht->imeta.meta, ctx, digest);
 112450c:	aa1303e0 	mov	x0, x19
 1124510:	97ffffc4 	bl	1124420 <calc_node_hash>
	if (res == TEE_SUCCESS &&
 1124514:	35000120 	cbnz	w0, 1124538 <verify_node+0x54>
	    consttime_memcmp(digest, node->node.hash, sizeof(digest)))
 1124518:	91002a61 	add	x1, x19, #0xa
 112451c:	aa1403e0 	mov	x0, x20
 1124520:	d2800402 	mov	x2, #0x20                  	// #32
 1124524:	9400829b 	bl	1144f90 <consttime_memcmp>
		return TEE_ERROR_CORRUPT_OBJECT;
 1124528:	7100001f 	cmp	w0, #0x0
 112452c:	52800020 	mov	w0, #0x1                   	// #1
 1124530:	72be0200 	movk	w0, #0xf010, lsl #16
 1124534:	1a8003e0 	csel	w0, wzr, w0, eq  // eq = none
}
 1124538:	a94153f3 	ldp	x19, x20, [sp, #16]
 112453c:	a8c47bfd 	ldp	x29, x30, [sp], #64
 1124540:	d65f03c0 	ret
		res = calc_node_hash(node, &targ->ht->imeta.meta, ctx, digest);
 1124544:	f9400001 	ldr	x1, [x0]
 1124548:	aa1403e3 	mov	x3, x20
 112454c:	91030021 	add	x1, x1, #0xc0
 1124550:	17ffffef 	b	112450c <verify_node+0x28>

0000000001124554 <htree_sync_node_to_storage>:
	*ht = NULL;
}

static TEE_Result htree_sync_node_to_storage(struct traverse_arg *targ,
					     struct htree_node *node)
{
 1124554:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1124558:	910003fd 	mov	x29, sp
 112455c:	a90153f3 	stp	x19, x20, [sp, #16]
 1124560:	aa0103f3 	mov	x19, x1
 1124564:	a9025bf5 	stp	x21, x22, [sp, #32]
 1124568:	aa0003f5 	mov	x21, x0
	/*
	 * The node can be dirty while the block isn't updated due to
	 * updated children, but if block is updated the node has to be
	 * dirty.
	 */
	assert(node->dirty >= node->block_updated);
 112456c:	39402020 	ldrb	w0, [x1, #8]
 1124570:	39402421 	ldrb	w1, [x1, #9]
 1124574:	6b00003f 	cmp	w1, w0
 1124578:	54000149 	b.ls	11245a0 <htree_sync_node_to_storage+0x4c>  // b.plast
 112457c:	b0000183 	adrp	x3, 1155000 <__func__.3826+0xa8>
 1124580:	b0000181 	adrp	x1, 1155000 <__func__.3826+0xa8>
 1124584:	9132ec63 	add	x3, x3, #0xcbb
 1124588:	912e7c21 	add	x1, x1, #0xb9f
 112458c:	b0000180 	adrp	x0, 1155000 <__func__.3826+0xa8>
 1124590:	912fe800 	add	x0, x0, #0xbfa
 1124594:	52805902 	mov	w2, #0x2c8                 	// #712
 1124598:	97ffb745 	bl	11122ac <_assert_log>
 112459c:	97ffb755 	bl	11122f0 <_assert_break>

	if (!node->dirty)
 11245a0:	34000500 	cbz	w0, 1124640 <htree_sync_node_to_storage+0xec>
		return TEE_SUCCESS;

	if (node->parent) {
 11245a4:	f9402a60 	ldr	x0, [x19, #80]
 11245a8:	b4000400 	cbz	x0, 1124628 <htree_sync_node_to_storage+0xd4>
		uint32_t f = HTREE_NODE_COMMITTED_CHILD(node->id & 1);
 11245ac:	f9400261 	ldr	x1, [x19]
 11245b0:	52800022 	mov	w2, #0x1                   	// #1

		node->parent->dirty = true;
 11245b4:	39002002 	strb	w2, [x0, #8]
		uint32_t f = HTREE_NODE_COMMITTED_CHILD(node->id & 1);
 11245b8:	12000021 	and	w1, w1, #0x1
 11245bc:	11000421 	add	w1, w1, #0x1
 11245c0:	1ac12041 	lsl	w1, w2, w1
		node->parent->node.flags ^= f;
 11245c4:	79409402 	ldrh	w2, [x0, #74]
 11245c8:	4a020022 	eor	w2, w1, w2
 11245cc:	12003c42 	and	w2, w2, #0xffff
 11245d0:	79009402 	strh	w2, [x0, #74]
		vers = !!(node->parent->node.flags & f);
 11245d4:	6a01005f 	tst	w2, w1
	struct tee_fs_htree_meta *meta = NULL;
 11245d8:	d2800001 	mov	x1, #0x0                   	// #0
		vers = !!(node->parent->node.flags & f);
 11245dc:	1a9f07f4 	cset	w20, ne  // ne = any
		 */
		vers = !(targ->ht->head.counter & 1);
		meta = &targ->ht->imeta.meta;
	}

	res = calc_node_hash(node, meta, targ->arg, node->node.hash);
 11245e0:	f9400aa2 	ldr	x2, [x21, #16]
 11245e4:	91002a76 	add	x22, x19, #0xa
 11245e8:	aa1603e3 	mov	x3, x22
 11245ec:	aa1303e0 	mov	x0, x19
 11245f0:	97ffff8c 	bl	1124420 <calc_node_hash>
	if (res != TEE_SUCCESS)
 11245f4:	35000280 	cbnz	w0, 1124644 <htree_sync_node_to_storage+0xf0>
		return res;

	node->dirty = false;
 11245f8:	7900127f 	strh	wzr, [x19, #8]
	return rpc_write(ht, TEE_FS_HTREE_TYPE_NODE, node_id - 1, vers,
 11245fc:	aa1603e4 	mov	x4, x22
 1124600:	92400283 	and	x3, x20, #0x1
 1124604:	d2800845 	mov	x5, #0x42                  	// #66
 1124608:	f9400262 	ldr	x2, [x19]
 112460c:	52800021 	mov	w1, #0x1                   	// #1
 1124610:	f94002a0 	ldr	x0, [x21]
 1124614:	d1000442 	sub	x2, x2, #0x1
	node->block_updated = false;

	return rpc_write_node(targ->ht, node->id, vers, &node->node);
}
 1124618:	a94153f3 	ldp	x19, x20, [sp, #16]
 112461c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1124620:	a8c37bfd 	ldp	x29, x30, [sp], #48
	return rpc_write(ht, TEE_FS_HTREE_TYPE_NODE, node_id - 1, vers,
 1124624:	17fffe21 	b	1123ea8 <rpc_write>
		vers = !(targ->ht->head.counter & 1);
 1124628:	f94002a1 	ldr	x1, [x21]
		meta = &targ->ht->imeta.meta;
 112462c:	91030021 	add	x1, x1, #0xc0
		vers = !(targ->ht->head.counter & 1);
 1124630:	b85e8034 	ldur	w20, [x1, #-24]
 1124634:	2a3403f4 	mvn	w20, w20
 1124638:	12000294 	and	w20, w20, #0x1
		meta = &targ->ht->imeta.meta;
 112463c:	17ffffe9 	b	11245e0 <htree_sync_node_to_storage+0x8c>
		return TEE_SUCCESS;
 1124640:	52800000 	mov	w0, #0x0                   	// #0
}
 1124644:	a94153f3 	ldp	x19, x20, [sp, #16]
 1124648:	a9425bf5 	ldp	x21, x22, [sp, #32]
 112464c:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1124650:	d65f03c0 	ret

0000000001124654 <tee_fs_htree_get_meta>:
}
 1124654:	91030000 	add	x0, x0, #0xc0
 1124658:	d65f03c0 	ret

000000000112465c <tee_fs_htree_meta_set_dirty>:
	ht->dirty = true;
 112465c:	52800021 	mov	w1, #0x1                   	// #1
	ht->root.dirty = true;
 1124660:	39002001 	strb	w1, [x0, #8]
	ht->dirty = true;
 1124664:	39034001 	strb	w1, [x0, #208]
}
 1124668:	d65f03c0 	ret

000000000112466c <tee_fs_htree_close>:
	if (!*ht)
 112466c:	f9400001 	ldr	x1, [x0]
 1124670:	b4000241 	cbz	x1, 11246b8 <tee_fs_htree_close+0x4c>
{
 1124674:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 1124678:	910003fd 	mov	x29, sp
 112467c:	f9000bf3 	str	x19, [sp, #16]
 1124680:	aa0003f3 	mov	x19, x0
	struct traverse_arg targ = { ht, cb, arg };
 1124684:	90000000 	adrp	x0, 1124000 <authenc_init+0x38>
 1124688:	910da000 	add	x0, x0, #0x368
 112468c:	f90017e1 	str	x1, [sp, #40]
 1124690:	f9001be0 	str	x0, [sp, #48]
	return traverse_post_order(&targ, &ht->root);
 1124694:	9100a3e0 	add	x0, sp, #0x28
	struct traverse_arg targ = { ht, cb, arg };
 1124698:	f9001fff 	str	xzr, [sp, #56]
	return traverse_post_order(&targ, &ht->root);
 112469c:	97fffdea 	bl	1123e44 <traverse_post_order>
	free(*ht);
 11246a0:	f9400260 	ldr	x0, [x19]
 11246a4:	94007bcf 	bl	11435e0 <free>
	*ht = NULL;
 11246a8:	f900027f 	str	xzr, [x19]
}
 11246ac:	f9400bf3 	ldr	x19, [sp, #16]
 11246b0:	a8c47bfd 	ldp	x29, x30, [sp], #64
 11246b4:	d65f03c0 	ret
 11246b8:	d65f03c0 	ret

00000000011246bc <tee_fs_htree_sync_to_storage>:
				     sizeof(ht->imeta), &ht->head.imeta);
}

TEE_Result tee_fs_htree_sync_to_storage(struct tee_fs_htree **ht_arg,
					uint8_t *hash)
{
 11246bc:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
 11246c0:	910003fd 	mov	x29, sp
 11246c4:	a90153f3 	stp	x19, x20, [sp, #16]
	TEE_Result res;
	struct tee_fs_htree *ht = *ht_arg;
 11246c8:	f9400014 	ldr	x20, [x0]
{
 11246cc:	a9025bf5 	stp	x21, x22, [sp, #32]
 11246d0:	f9001bf7 	str	x23, [sp, #48]
	void *ctx;

	if (!ht)
 11246d4:	b4000894 	cbz	x20, 11247e4 <tee_fs_htree_sync_to_storage+0x128>
 11246d8:	aa0003f5 	mov	x21, x0
		return TEE_ERROR_CORRUPT_OBJECT;

	if (!ht->dirty)
 11246dc:	39434280 	ldrb	w0, [x20, #208]
 11246e0:	34000880 	cbz	w0, 11247f0 <tee_fs_htree_sync_to_storage+0x134>
 11246e4:	aa0103f6 	mov	x22, x1
		return TEE_SUCCESS;

	res = crypto_hash_alloc_ctx(&ctx, TEE_FS_HTREE_HASH_ALG);
 11246e8:	52800081 	mov	w1, #0x4                   	// #4
 11246ec:	910103e0 	add	x0, sp, #0x40
 11246f0:	72aa0001 	movk	w1, #0x5000, lsl #16
 11246f4:	97ffa2c2 	bl	110d1fc <crypto_hash_alloc_ctx>
 11246f8:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 11246fc:	35000680 	cbnz	w0, 11247cc <tee_fs_htree_sync_to_storage+0x110>
	struct traverse_arg targ = { ht, cb, arg };
 1124700:	90000000 	adrp	x0, 1124000 <authenc_init+0x38>
 1124704:	91155000 	add	x0, x0, #0x554
	return traverse_post_order(&targ, &ht->root);
 1124708:	910123f7 	add	x23, sp, #0x48
	struct traverse_arg targ = { ht, cb, arg };
 112470c:	a90483f4 	stp	x20, x0, [sp, #72]
	return traverse_post_order(&targ, &ht->root);
 1124710:	aa1403e1 	mov	x1, x20
	struct traverse_arg targ = { ht, cb, arg };
 1124714:	f94023e0 	ldr	x0, [sp, #64]
 1124718:	f9002fe0 	str	x0, [sp, #88]
	return traverse_post_order(&targ, &ht->root);
 112471c:	aa1703e0 	mov	x0, x23
 1124720:	97fffdc9 	bl	1123e44 <traverse_post_order>
 1124724:	2a0003f3 	mov	w19, w0
		return res;

	res = htree_traverse_post_order(ht, htree_sync_node_to_storage, ctx);
	if (res != TEE_SUCCESS)
 1124728:	35000480 	cbnz	w0, 11247b8 <tee_fs_htree_sync_to_storage+0xfc>
	ht->head.counter++;
 112472c:	b940aa80 	ldr	w0, [x20, #168]
	res = authenc_init(&ctx, TEE_MODE_ENCRYPT, ht, NULL, sizeof(ht->imeta));
 1124730:	aa1403e2 	mov	x2, x20
 1124734:	d2800204 	mov	x4, #0x10                  	// #16
 1124738:	d2800003 	mov	x3, #0x0                   	// #0
	ht->head.counter++;
 112473c:	11000400 	add	w0, w0, #0x1
 1124740:	b900aa80 	str	w0, [x20, #168]
	res = authenc_init(&ctx, TEE_MODE_ENCRYPT, ht, NULL, sizeof(ht->imeta));
 1124744:	52800001 	mov	w1, #0x0                   	// #0
 1124748:	aa1703e0 	mov	x0, x23
 112474c:	97fffe1f 	bl	1123fc8 <authenc_init>
 1124750:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 1124754:	35000320 	cbnz	w0, 11247b8 <tee_fs_htree_sync_to_storage+0xfc>
	return authenc_encrypt_final(ctx, ht->head.tag, &ht->imeta,
 1124758:	f94027e0 	ldr	x0, [sp, #72]
 112475c:	91026284 	add	x4, x20, #0x98
 1124760:	91030282 	add	x2, x20, #0xc0
 1124764:	9101e281 	add	x1, x20, #0x78
 1124768:	d2800203 	mov	x3, #0x10                  	// #16
 112476c:	97ffff0a 	bl	1124394 <authenc_encrypt_final>
 1124770:	2a0003f3 	mov	w19, w0
		goto out;

	/* All the nodes are written to storage now. Time to update root. */
	res = update_root(ht);
	if (res != TEE_SUCCESS)
 1124774:	35000220 	cbnz	w0, 11247b8 <tee_fs_htree_sync_to_storage+0xfc>
		goto out;

	res = rpc_write_head(ht, ht->head.counter & 1, &ht->head);
 1124778:	b940aa83 	ldr	w3, [x20, #168]
	return rpc_write(ht, TEE_FS_HTREE_TYPE_HEAD, 0, vers,
 112477c:	9101a284 	add	x4, x20, #0x68
 1124780:	aa1403e0 	mov	x0, x20
 1124784:	d2800885 	mov	x5, #0x44                  	// #68
 1124788:	92400063 	and	x3, x3, #0x1
 112478c:	d2800002 	mov	x2, #0x0                   	// #0
 1124790:	52800001 	mov	w1, #0x0                   	// #0
 1124794:	97fffdc5 	bl	1123ea8 <rpc_write>
 1124798:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 112479c:	350000e0 	cbnz	w0, 11247b8 <tee_fs_htree_sync_to_storage+0xfc>
		goto out;

	ht->dirty = false;
 11247a0:	3903429f 	strb	wzr, [x20, #208]
	if (hash)
 11247a4:	b40000b6 	cbz	x22, 11247b8 <tee_fs_htree_sync_to_storage+0xfc>
		memcpy(hash, ht->root.node.hash, sizeof(ht->root.node.hash));
 11247a8:	91002a81 	add	x1, x20, #0xa
 11247ac:	aa1603e0 	mov	x0, x22
 11247b0:	d2800402 	mov	x2, #0x20                  	// #32
 11247b4:	97ff7af7 	bl	1103390 <memcpy>
out:
	crypto_hash_free_ctx(ctx);
 11247b8:	f94023e0 	ldr	x0, [sp, #64]
 11247bc:	97ffa2b5 	bl	110d290 <crypto_hash_free_ctx>
	if (res != TEE_SUCCESS)
 11247c0:	34000073 	cbz	w19, 11247cc <tee_fs_htree_sync_to_storage+0x110>
		tee_fs_htree_close(ht_arg);
 11247c4:	aa1503e0 	mov	x0, x21
 11247c8:	97ffffa9 	bl	112466c <tee_fs_htree_close>
	return res;
}
 11247cc:	2a1303e0 	mov	w0, w19
 11247d0:	a94153f3 	ldp	x19, x20, [sp, #16]
 11247d4:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11247d8:	f9401bf7 	ldr	x23, [sp, #48]
 11247dc:	a8c67bfd 	ldp	x29, x30, [sp], #96
 11247e0:	d65f03c0 	ret
		return TEE_ERROR_CORRUPT_OBJECT;
 11247e4:	52800033 	mov	w19, #0x1                   	// #1
 11247e8:	72be0213 	movk	w19, #0xf010, lsl #16
 11247ec:	17fffff8 	b	11247cc <tee_fs_htree_sync_to_storage+0x110>
		return TEE_SUCCESS;
 11247f0:	52800013 	mov	w19, #0x0                   	// #0
 11247f4:	17fffff6 	b	11247cc <tee_fs_htree_sync_to_storage+0x110>

00000000011247f8 <tee_fs_htree_open>:
{
 11247f8:	a9b17bfd 	stp	x29, x30, [sp, #-240]!
 11247fc:	910003fd 	mov	x29, sp
 1124800:	a90153f3 	stp	x19, x20, [sp, #16]
 1124804:	aa0403f3 	mov	x19, x4
 1124808:	aa0503f4 	mov	x20, x5
 112480c:	a9025bf5 	stp	x21, x22, [sp, #32]
 1124810:	aa0103f6 	mov	x22, x1
	struct tee_fs_htree *ht = calloc(1, sizeof(*ht));
 1124814:	d2801e01 	mov	x1, #0xf0                  	// #240
{
 1124818:	a90363f7 	stp	x23, x24, [sp, #48]
 112481c:	aa0203f8 	mov	x24, x2
 1124820:	aa0303f7 	mov	x23, x3
 1124824:	f90023f9 	str	x25, [sp, #64]
 1124828:	12001c19 	and	w25, w0, #0xff
	struct tee_fs_htree *ht = calloc(1, sizeof(*ht));
 112482c:	d2800020 	mov	x0, #0x1                   	// #1
 1124830:	94007b28 	bl	11434d0 <calloc>
 1124834:	f9002fe0 	str	x0, [sp, #88]
	if (!ht)
 1124838:	b4001dc0 	cbz	x0, 1124bf0 <tee_fs_htree_open+0x3f8>
	ht->stor = stor;
 112483c:	a90ddc18 	stp	x24, x23, [x0, #216]
 1124840:	aa0003f5 	mov	x21, x0
	ht->stor_aux = stor_aux;
 1124844:	f9007413 	str	x19, [x0, #232]
	if (create) {
 1124848:	34000819 	cbz	w25, 1124948 <tee_fs_htree_open+0x150>
		const struct tee_fs_htree_image dummy_head = { .counter = 0 };
 112484c:	d2800882 	mov	x2, #0x44                  	// #68
 1124850:	9101a3f7 	add	x23, sp, #0x68
 1124854:	52800001 	mov	w1, #0x0                   	// #0
 1124858:	aa1703e0 	mov	x0, x23
 112485c:	94007d21 	bl	1143ce0 <memset>
		res = crypto_rng_read(ht->fek, sizeof(ht->fek));
 1124860:	9102b2a0 	add	x0, x21, #0xac
 1124864:	d2800201 	mov	x1, #0x10                  	// #16
 1124868:	97ffab51 	bl	110f5ac <crypto_rng_read>
 112486c:	2a0003f3 	mov	w19, w0
		if (res != TEE_SUCCESS)
 1124870:	35000d60 	cbnz	w0, 1124a1c <tee_fs_htree_open+0x224>
		res = tee_fs_fek_crypt(ht->uuid, TEE_MODE_ENCRYPT, ht->fek,
 1124874:	f9402fe0 	ldr	x0, [sp, #88]
 1124878:	d2800203 	mov	x3, #0x10                  	// #16
 112487c:	52800001 	mov	w1, #0x0                   	// #0
 1124880:	91022004 	add	x4, x0, #0x88
 1124884:	9102b002 	add	x2, x0, #0xac
 1124888:	f9406c00 	ldr	x0, [x0, #216]
 112488c:	94000563 	bl	1125e18 <tee_fs_fek_crypt>
 1124890:	2a0003f3 	mov	w19, w0
		if (res != TEE_SUCCESS)
 1124894:	35000c40 	cbnz	w0, 1124a1c <tee_fs_htree_open+0x224>
	res = crypto_hash_alloc_ctx(&ctx, TEE_FS_HTREE_HASH_ALG);
 1124898:	52800081 	mov	w1, #0x4                   	// #4
 112489c:	910183e0 	add	x0, sp, #0x60
 11248a0:	72aa0001 	movk	w1, #0x5000, lsl #16
		res = init_root_node(ht);
 11248a4:	f9402ff5 	ldr	x21, [sp, #88]
	res = crypto_hash_alloc_ctx(&ctx, TEE_FS_HTREE_HASH_ALG);
 11248a8:	97ffa255 	bl	110d1fc <crypto_hash_alloc_ctx>
 11248ac:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 11248b0:	35000b60 	cbnz	w0, 1124a1c <tee_fs_htree_open+0x224>
	res = calc_node_hash(&ht->root, &ht->imeta.meta, ctx,
 11248b4:	f94033e2 	ldr	x2, [sp, #96]
	ht->root.id = 1;
 11248b8:	d2800038 	mov	x24, #0x1                   	// #1
 11248bc:	f90002b8 	str	x24, [x21]
	res = calc_node_hash(&ht->root, &ht->imeta.meta, ctx,
 11248c0:	91002aa3 	add	x3, x21, #0xa
	ht->root.dirty = true;
 11248c4:	390022b8 	strb	w24, [x21, #8]
	res = calc_node_hash(&ht->root, &ht->imeta.meta, ctx,
 11248c8:	910302a1 	add	x1, x21, #0xc0
 11248cc:	aa1503e0 	mov	x0, x21
 11248d0:	97fffed4 	bl	1124420 <calc_node_hash>
 11248d4:	2a0003f3 	mov	w19, w0
	crypto_hash_free_ctx(ctx);
 11248d8:	f94033e0 	ldr	x0, [sp, #96]
 11248dc:	97ffa26d 	bl	110d290 <crypto_hash_free_ctx>
		if (res != TEE_SUCCESS)
 11248e0:	350009f3 	cbnz	w19, 1124a1c <tee_fs_htree_open+0x224>
		ht->dirty = true;
 11248e4:	f9402fe0 	ldr	x0, [sp, #88]
		res = tee_fs_htree_sync_to_storage(&ht, hash);
 11248e8:	aa1603e1 	mov	x1, x22
		ht->dirty = true;
 11248ec:	39034018 	strb	w24, [x0, #208]
		res = tee_fs_htree_sync_to_storage(&ht, hash);
 11248f0:	910163e0 	add	x0, sp, #0x58
 11248f4:	97ffff72 	bl	11246bc <tee_fs_htree_sync_to_storage>
 11248f8:	2a0003f3 	mov	w19, w0
		if (res != TEE_SUCCESS)
 11248fc:	35000900 	cbnz	w0, 1124a1c <tee_fs_htree_open+0x224>
	return rpc_write(ht, TEE_FS_HTREE_TYPE_HEAD, 0, vers,
 1124900:	f9402fe0 	ldr	x0, [sp, #88]
 1124904:	aa1703e4 	mov	x4, x23
 1124908:	d2800885 	mov	x5, #0x44                  	// #68
 112490c:	d2800003 	mov	x3, #0x0                   	// #0
 1124910:	d2800002 	mov	x2, #0x0                   	// #0
 1124914:	52800001 	mov	w1, #0x0                   	// #0
 1124918:	97fffd64 	bl	1123ea8 <rpc_write>
 112491c:	2a0003f3 	mov	w19, w0
	if (res == TEE_SUCCESS)
 1124920:	350007f3 	cbnz	w19, 1124a1c <tee_fs_htree_open+0x224>
		*ht_ret = ht;
 1124924:	f9402fe0 	ldr	x0, [sp, #88]
 1124928:	f9000280 	str	x0, [x20]
}
 112492c:	2a1303e0 	mov	w0, w19
 1124930:	a94153f3 	ldp	x19, x20, [sp, #16]
 1124934:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1124938:	a94363f7 	ldp	x23, x24, [sp, #48]
 112493c:	f94023f9 	ldr	x25, [sp, #64]
 1124940:	a8cf7bfd 	ldp	x29, x30, [sp], #240
 1124944:	d65f03c0 	ret
	if (hash) {
 1124948:	b5000356 	cbnz	x22, 11249b0 <tee_fs_htree_open+0x1b8>
	return rpc_read(ht, TEE_FS_HTREE_TYPE_HEAD, 0, vers,
 112494c:	9101a3f7 	add	x23, sp, #0x68
 1124950:	d2800885 	mov	x5, #0x44                  	// #68
 1124954:	aa1703e4 	mov	x4, x23
 1124958:	d2800003 	mov	x3, #0x0                   	// #0
 112495c:	d2800002 	mov	x2, #0x0                   	// #0
 1124960:	52800001 	mov	w1, #0x0                   	// #0
 1124964:	97fffd6f 	bl	1123f20 <rpc_read>
 1124968:	2a0003f3 	mov	w19, w0
			if (res != TEE_SUCCESS)
 112496c:	35000580 	cbnz	w0, 1124a1c <tee_fs_htree_open+0x224>
	return rpc_read(ht, TEE_FS_HTREE_TYPE_HEAD, 0, vers,
 1124970:	d2800885 	mov	x5, #0x44                  	// #68
 1124974:	aa1503e0 	mov	x0, x21
 1124978:	8b0502e4 	add	x4, x23, x5
 112497c:	d2800023 	mov	x3, #0x1                   	// #1
 1124980:	d2800002 	mov	x2, #0x0                   	// #0
 1124984:	52800001 	mov	w1, #0x0                   	// #0
 1124988:	97fffd66 	bl	1123f20 <rpc_read>
 112498c:	2a0003f3 	mov	w19, w0
			if (res != TEE_SUCCESS)
 1124990:	35000460 	cbnz	w0, 1124a1c <tee_fs_htree_open+0x224>
		idx = get_idx_from_counter(head[0].counter, head[1].counter);
 1124994:	b940abe2 	ldr	w2, [sp, #168]
 1124998:	b940efe1 	ldr	w1, [sp, #236]
	if (!(counter0 & 1)) {
 112499c:	12000020 	and	w0, w1, #0x1
 11249a0:	360004e2 	tbz	w2, #0, 1124a3c <tee_fs_htree_open+0x244>
	if (counter1 & 1)
 11249a4:	35000dc0 	cbnz	w0, 1124b5c <tee_fs_htree_open+0x364>
				return TEE_ERROR_SECURITY;
 11249a8:	129ffe13 	mov	w19, #0xffff000f            	// #-65521
 11249ac:	1400001c 	b	1124a1c <tee_fs_htree_open+0x224>
			res = rpc_read_node(ht, 1, idx, &ht->root.node);
 11249b0:	91002819 	add	x25, x0, #0xa
 11249b4:	52800058 	mov	w24, #0x2                   	// #2
		for (idx = 0;; idx++) {
 11249b8:	52800003 	mov	w3, #0x0                   	// #0
			res = rpc_read_node(ht, 1, idx, &ht->root.node);
 11249bc:	93407c77 	sxtw	x23, w3
	return rpc_read(ht, TEE_FS_HTREE_TYPE_NODE, node_id - 1, vers,
 11249c0:	aa1903e4 	mov	x4, x25
 11249c4:	aa1703e3 	mov	x3, x23
 11249c8:	aa1503e0 	mov	x0, x21
 11249cc:	d2800845 	mov	x5, #0x42                  	// #66
 11249d0:	d2800002 	mov	x2, #0x0                   	// #0
 11249d4:	52800021 	mov	w1, #0x1                   	// #1
 11249d8:	97fffd52 	bl	1123f20 <rpc_read>
 11249dc:	2a0003f3 	mov	w19, w0
			if (res != TEE_SUCCESS)
 11249e0:	350001e0 	cbnz	w0, 1124a1c <tee_fs_htree_open+0x224>
			if (!memcmp(ht->root.node.hash, hash,
 11249e4:	aa1603e1 	mov	x1, x22
 11249e8:	aa1903e0 	mov	x0, x25
 11249ec:	d2800402 	mov	x2, #0x20                  	// #32
 11249f0:	94007c98 	bl	1143c50 <memcmp>
 11249f4:	350001a0 	cbnz	w0, 1124a28 <tee_fs_htree_open+0x230>
	return rpc_read(ht, TEE_FS_HTREE_TYPE_HEAD, 0, vers,
 11249f8:	9101a2a4 	add	x4, x21, #0x68
 11249fc:	aa1703e3 	mov	x3, x23
 1124a00:	aa1503e0 	mov	x0, x21
 1124a04:	d2800885 	mov	x5, #0x44                  	// #68
 1124a08:	d2800002 	mov	x2, #0x0                   	// #0
 1124a0c:	52800001 	mov	w1, #0x0                   	// #0
 1124a10:	97fffd44 	bl	1123f20 <rpc_read>
 1124a14:	2a0003f3 	mov	w19, w0
				if (res != TEE_SUCCESS)
 1124a18:	34000340 	cbz	w0, 1124a80 <tee_fs_htree_open+0x288>
		tee_fs_htree_close(&ht);
 1124a1c:	910163e0 	add	x0, sp, #0x58
 1124a20:	97ffff13 	bl	112466c <tee_fs_htree_close>
 1124a24:	17ffffc2 	b	112492c <tee_fs_htree_open+0x134>
		for (idx = 0;; idx++) {
 1124a28:	52800023 	mov	w3, #0x1                   	// #1
			if (idx)
 1124a2c:	6b03031f 	cmp	w24, w3
 1124a30:	54fffbc0 	b.eq	11249a8 <tee_fs_htree_open+0x1b0>  // b.none
 1124a34:	2a0303f8 	mov	w24, w3
 1124a38:	17ffffe1 	b	11249bc <tee_fs_htree_open+0x1c4>
		if (!(counter1 & 1))
 1124a3c:	340008c0 	cbz	w0, 1124b54 <tee_fs_htree_open+0x35c>
		if (counter0 > counter1)
 1124a40:	6b01005f 	cmp	w2, w1
 1124a44:	1a9f87e3 	cset	w3, ls  // ls = plast
		res = rpc_read_node(ht, 1, idx, &ht->root.node);
 1124a48:	93407c76 	sxtw	x22, w3
	return rpc_read(ht, TEE_FS_HTREE_TYPE_NODE, node_id - 1, vers,
 1124a4c:	91002aa4 	add	x4, x21, #0xa
 1124a50:	aa1603e3 	mov	x3, x22
 1124a54:	aa1503e0 	mov	x0, x21
 1124a58:	d2800845 	mov	x5, #0x42                  	// #66
 1124a5c:	d2800002 	mov	x2, #0x0                   	// #0
 1124a60:	52800021 	mov	w1, #0x1                   	// #1
 1124a64:	97fffd2f 	bl	1123f20 <rpc_read>
 1124a68:	2a0003f3 	mov	w19, w0
		if (res != TEE_SUCCESS)
 1124a6c:	35fffd80 	cbnz	w0, 1124a1c <tee_fs_htree_open+0x224>
		ht->head = head[idx];
 1124a70:	d2800882 	mov	x2, #0x44                  	// #68
 1124a74:	9101a2a0 	add	x0, x21, #0x68
 1124a78:	9b025ec1 	madd	x1, x22, x2, x23
 1124a7c:	97ff7a45 	bl	1103390 <memcpy>
	ht->root.id = 1;
 1124a80:	d2800037 	mov	x23, #0x1                   	// #1
 1124a84:	f90002b7 	str	x23, [x21]
		res = verify_root(ht);
 1124a88:	f9402ff5 	ldr	x21, [sp, #88]
	res = tee_fs_fek_crypt(ht->uuid, TEE_MODE_DECRYPT, ht->head.enc_fek,
 1124a8c:	2a1703e1 	mov	w1, w23
 1124a90:	d2800203 	mov	x3, #0x10                  	// #16
 1124a94:	9102b2a4 	add	x4, x21, #0xac
 1124a98:	910222a2 	add	x2, x21, #0x88
 1124a9c:	f9406ea0 	ldr	x0, [x21, #216]
 1124aa0:	940004de 	bl	1125e18 <tee_fs_fek_crypt>
 1124aa4:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 1124aa8:	35fffba0 	cbnz	w0, 1124a1c <tee_fs_htree_open+0x224>
	res = authenc_init(&ctx, TEE_MODE_DECRYPT, ht, NULL, sizeof(ht->imeta));
 1124aac:	9101a3f6 	add	x22, sp, #0x68
 1124ab0:	aa1503e2 	mov	x2, x21
 1124ab4:	2a1703e1 	mov	w1, w23
 1124ab8:	aa1603e0 	mov	x0, x22
 1124abc:	d2800204 	mov	x4, #0x10                  	// #16
 1124ac0:	d2800003 	mov	x3, #0x0                   	// #0
 1124ac4:	97fffd41 	bl	1123fc8 <authenc_init>
 1124ac8:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 1124acc:	35fffa80 	cbnz	w0, 1124a1c <tee_fs_htree_open+0x224>
	return authenc_decrypt_final(ctx, ht->head.tag, ht->head.imeta,
 1124ad0:	f94037e0 	ldr	x0, [sp, #104]
 1124ad4:	910302a4 	add	x4, x21, #0xc0
 1124ad8:	910262a2 	add	x2, x21, #0x98
 1124adc:	9101e2a1 	add	x1, x21, #0x78
 1124ae0:	d2800203 	mov	x3, #0x10                  	// #16
 1124ae4:	97fffd90 	bl	1124124 <authenc_decrypt_final>
 1124ae8:	2a0003f3 	mov	w19, w0
		if (res != TEE_SUCCESS)
 1124aec:	35fff980 	cbnz	w0, 1124a1c <tee_fs_htree_open+0x224>
		res = init_tree_from_data(ht);
 1124af0:	f9402ff7 	ldr	x23, [sp, #88]
		res = get_node(ht, true, node_id, &nc);
 1124af4:	910183f8 	add	x24, sp, #0x60
	size_t node_id = 2;
 1124af8:	d2800055 	mov	x21, #0x2                   	// #2
	while (node_id <= ht->imeta.max_node_id) {
 1124afc:	b940cae0 	ldr	w0, [x23, #200]
 1124b00:	eb0002bf 	cmp	x21, x0
 1124b04:	54000309 	b.ls	1124b64 <tee_fs_htree_open+0x36c>  // b.plast
	res = crypto_hash_alloc_ctx(&ctx, TEE_FS_HTREE_HASH_ALG);
 1124b08:	52800081 	mov	w1, #0x4                   	// #4
 1124b0c:	910183e0 	add	x0, sp, #0x60
 1124b10:	72aa0001 	movk	w1, #0x5000, lsl #16
		res = verify_tree(ht);
 1124b14:	f9402ff5 	ldr	x21, [sp, #88]
	res = crypto_hash_alloc_ctx(&ctx, TEE_FS_HTREE_HASH_ALG);
 1124b18:	97ffa1b9 	bl	110d1fc <crypto_hash_alloc_ctx>
 1124b1c:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 1124b20:	35fff7e0 	cbnz	w0, 1124a1c <tee_fs_htree_open+0x224>
	struct traverse_arg targ = { ht, cb, arg };
 1124b24:	90000000 	adrp	x0, 1124000 <authenc_init+0x38>
 1124b28:	91139000 	add	x0, x0, #0x4e4
 1124b2c:	a90683f5 	stp	x21, x0, [sp, #104]
	return traverse_post_order(&targ, &ht->root);
 1124b30:	aa1503e1 	mov	x1, x21
	struct traverse_arg targ = { ht, cb, arg };
 1124b34:	f94033e0 	ldr	x0, [sp, #96]
 1124b38:	f9003fe0 	str	x0, [sp, #120]
	return traverse_post_order(&targ, &ht->root);
 1124b3c:	aa1603e0 	mov	x0, x22
 1124b40:	97fffcc1 	bl	1123e44 <traverse_post_order>
 1124b44:	2a0003f3 	mov	w19, w0
	crypto_hash_free_ctx(ctx);
 1124b48:	f94033e0 	ldr	x0, [sp, #96]
 1124b4c:	97ffa1d1 	bl	110d290 <crypto_hash_free_ctx>
	return res;
 1124b50:	17ffff74 	b	1124920 <tee_fs_htree_open+0x128>
			return 0;
 1124b54:	52800003 	mov	w3, #0x0                   	// #0
 1124b58:	17ffffbc 	b	1124a48 <tee_fs_htree_open+0x250>
		return 1;
 1124b5c:	52800023 	mov	w3, #0x1                   	// #1
 1124b60:	17ffffba 	b	1124a48 <tee_fs_htree_open+0x250>
		node = find_node(ht, node_id >> 1);
 1124b64:	d341feb3 	lsr	x19, x21, #1
	struct htree_node *node = find_closest_node(ht, node_id);
 1124b68:	aa1703e0 	mov	x0, x23
 1124b6c:	aa1303e1 	mov	x1, x19
 1124b70:	97fffd90 	bl	11241b0 <find_closest_node>
	if (node && node->id == node_id)
 1124b74:	b4000420 	cbz	x0, 1124bf8 <tee_fs_htree_open+0x400>
 1124b78:	f9400001 	ldr	x1, [x0]
 1124b7c:	eb01027f 	cmp	x19, x1
 1124b80:	540003c1 	b.ne	1124bf8 <tee_fs_htree_open+0x400>  // b.any
		committed_version = !!(node->node.flags &
 1124b84:	79409403 	ldrh	w3, [x0, #74]
				    HTREE_NODE_COMMITTED_CHILD(node_id & 1));
 1124b88:	120002a0 	and	w0, w21, #0x1
 1124b8c:	11000400 	add	w0, w0, #0x1
	return rpc_read(ht, TEE_FS_HTREE_TYPE_NODE, node_id - 1, vers,
 1124b90:	aa1603e4 	mov	x4, x22
 1124b94:	d10006a2 	sub	x2, x21, #0x1
 1124b98:	d2800845 	mov	x5, #0x42                  	// #66
		committed_version = !!(node->node.flags &
 1124b9c:	1ac02463 	lsr	w3, w3, w0
	return rpc_read(ht, TEE_FS_HTREE_TYPE_NODE, node_id - 1, vers,
 1124ba0:	52800021 	mov	w1, #0x1                   	// #1
 1124ba4:	92400063 	and	x3, x3, #0x1
 1124ba8:	aa1703e0 	mov	x0, x23
 1124bac:	97fffcdd 	bl	1123f20 <rpc_read>
 1124bb0:	2a0003f3 	mov	w19, w0
		if (res != TEE_SUCCESS)
 1124bb4:	35fff340 	cbnz	w0, 1124a1c <tee_fs_htree_open+0x224>
		res = get_node(ht, true, node_id, &nc);
 1124bb8:	aa1803e3 	mov	x3, x24
 1124bbc:	aa1503e2 	mov	x2, x21
 1124bc0:	aa1703e0 	mov	x0, x23
 1124bc4:	52800021 	mov	w1, #0x1                   	// #1
 1124bc8:	97fffd9d 	bl	112423c <get_node>
 1124bcc:	2a0003f3 	mov	w19, w0
		if (res != TEE_SUCCESS)
 1124bd0:	35fff260 	cbnz	w0, 1124a1c <tee_fs_htree_open+0x224>
		nc->node = node_image;
 1124bd4:	f94033e0 	ldr	x0, [sp, #96]
 1124bd8:	aa1603e1 	mov	x1, x22
		node_id++;
 1124bdc:	910006b5 	add	x21, x21, #0x1
		nc->node = node_image;
 1124be0:	d2800842 	mov	x2, #0x42                  	// #66
 1124be4:	91002800 	add	x0, x0, #0xa
 1124be8:	97ff79ea 	bl	1103390 <memcpy>
		node_id++;
 1124bec:	17ffffc4 	b	1124afc <tee_fs_htree_open+0x304>
		return TEE_ERROR_OUT_OF_MEMORY;
 1124bf0:	129ffe73 	mov	w19, #0xffff000c            	// #-65524
 1124bf4:	17ffff4e 	b	112492c <tee_fs_htree_open+0x134>
			return TEE_ERROR_GENERIC;
 1124bf8:	52bffff3 	mov	w19, #0xffff0000            	// #-65536
		if (res != TEE_SUCCESS)
 1124bfc:	17ffff88 	b	1124a1c <tee_fs_htree_open+0x224>

0000000001124c00 <tee_fs_htree_write_block>:
	return res;
}

TEE_Result tee_fs_htree_write_block(struct tee_fs_htree **ht_arg,
				    size_t block_num, const void *block)
{
 1124c00:	a9b17bfd 	stp	x29, x30, [sp, #-240]!
 1124c04:	910003fd 	mov	x29, sp
 1124c08:	a90153f3 	stp	x19, x20, [sp, #16]
	struct tee_fs_htree *ht = *ht_arg;
 1124c0c:	f9400014 	ldr	x20, [x0]
{
 1124c10:	a9025bf5 	stp	x21, x22, [sp, #32]
 1124c14:	a90363f7 	stp	x23, x24, [sp, #48]
 1124c18:	f90023f9 	str	x25, [sp, #64]
	struct htree_node *node = NULL;
	uint8_t block_vers;
	void *ctx;
	void *enc_block;

	if (!ht)
 1124c1c:	b4000814 	cbz	x20, 1124d1c <tee_fs_htree_write_block+0x11c>
	res = get_node(ht, create, BLOCK_NUM_TO_NODE_ID(block_num), &nd);
 1124c20:	910183f8 	add	x24, sp, #0x60
 1124c24:	aa0003f6 	mov	x22, x0
 1124c28:	aa0103f7 	mov	x23, x1
 1124c2c:	aa0203f9 	mov	x25, x2
 1124c30:	aa1803e3 	mov	x3, x24
 1124c34:	91000422 	add	x2, x1, #0x1
 1124c38:	aa1403e0 	mov	x0, x20
 1124c3c:	52800021 	mov	w1, #0x1                   	// #1
 1124c40:	97fffd7f 	bl	112423c <get_node>
 1124c44:	2a0003f3 	mov	w19, w0
	if (res == TEE_SUCCESS)
 1124c48:	35000700 	cbnz	w0, 1124d28 <tee_fs_htree_write_block+0x128>
		*node = nd;
 1124c4c:	f94033f5 	ldr	x21, [sp, #96]

	res = get_block_node(ht, true, block_num, &node);
	if (res != TEE_SUCCESS)
		goto out;

	if (!node->block_updated)
 1124c50:	394026a0 	ldrb	w0, [x21, #9]
 1124c54:	35000080 	cbnz	w0, 1124c64 <tee_fs_htree_write_block+0x64>
		node->node.flags ^= HTREE_NODE_COMMITTED_BLOCK;
 1124c58:	794096a0 	ldrh	w0, [x21, #74]
 1124c5c:	52000000 	eor	w0, w0, #0x1
 1124c60:	790096a0 	strh	w0, [x21, #74]

	block_vers = !!(node->node.flags & HTREE_NODE_COMMITTED_BLOCK);
	res = ht->stor->rpc_write_init(ht->stor_aux, &op,
 1124c64:	f9407280 	ldr	x0, [x20, #224]
 1124c68:	910163e5 	add	x5, sp, #0x58
	block_vers = !!(node->node.flags & HTREE_NODE_COMMITTED_BLOCK);
 1124c6c:	794096a4 	ldrh	w4, [x21, #74]
	res = ht->stor->rpc_write_init(ht->stor_aux, &op,
 1124c70:	aa1703e3 	mov	x3, x23
 1124c74:	aa1803e1 	mov	x1, x24
 1124c78:	52800042 	mov	w2, #0x2                   	// #2
 1124c7c:	f9400c06 	ldr	x6, [x0, #24]
 1124c80:	12000084 	and	w4, w4, #0x1
 1124c84:	f9407680 	ldr	x0, [x20, #232]
 1124c88:	d63f00c0 	blr	x6
 1124c8c:	2a0003f3 	mov	w19, w0
				       TEE_FS_HTREE_TYPE_BLOCK, block_num,
				       block_vers, &enc_block);
	if (res != TEE_SUCCESS)
 1124c90:	350004c0 	cbnz	w0, 1124d28 <tee_fs_htree_write_block+0x128>
		goto out;

	res = authenc_init(&ctx, TEE_MODE_ENCRYPT, ht, &node->node,
 1124c94:	f9407280 	ldr	x0, [x20, #224]
 1124c98:	91002aa3 	add	x3, x21, #0xa
 1124c9c:	aa1403e2 	mov	x2, x20
 1124ca0:	52800001 	mov	w1, #0x0                   	// #0
 1124ca4:	f9400004 	ldr	x4, [x0]
 1124ca8:	910143e0 	add	x0, sp, #0x50
 1124cac:	97fffcc7 	bl	1123fc8 <authenc_init>
 1124cb0:	2a0003f3 	mov	w19, w0
			   ht->stor->block_size);
	if (res != TEE_SUCCESS)
 1124cb4:	350003a0 	cbnz	w0, 1124d28 <tee_fs_htree_write_block+0x128>
		goto out;
	res = authenc_encrypt_final(ctx, node->node.tag, block,
 1124cb8:	f9407280 	ldr	x0, [x20, #224]
 1124cbc:	aa1903e2 	mov	x2, x25
 1124cc0:	9100eaa1 	add	x1, x21, #0x3a
 1124cc4:	f9400003 	ldr	x3, [x0]
 1124cc8:	a94513e0 	ldp	x0, x4, [sp, #80]
 1124ccc:	97fffdb2 	bl	1124394 <authenc_encrypt_final>
 1124cd0:	2a0003f3 	mov	w19, w0
				    ht->stor->block_size, enc_block);
	if (res != TEE_SUCCESS)
 1124cd4:	350002a0 	cbnz	w0, 1124d28 <tee_fs_htree_write_block+0x128>
		goto out;

	res = ht->stor->rpc_write_final(&op);
 1124cd8:	f9407280 	ldr	x0, [x20, #224]
 1124cdc:	f9401001 	ldr	x1, [x0, #32]
 1124ce0:	aa1803e0 	mov	x0, x24
 1124ce4:	d63f0020 	blr	x1
 1124ce8:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 1124cec:	350001e0 	cbnz	w0, 1124d28 <tee_fs_htree_write_block+0x128>
		goto out;

	node->block_updated = true;
	node->dirty = true;
 1124cf0:	52802020 	mov	w0, #0x101                 	// #257
 1124cf4:	790012a0 	strh	w0, [x21, #8]
	ht->dirty = true;
 1124cf8:	52800020 	mov	w0, #0x1                   	// #1
 1124cfc:	39034280 	strb	w0, [x20, #208]
out:
	if (res != TEE_SUCCESS)
		tee_fs_htree_close(ht_arg);
	return res;
}
 1124d00:	2a1303e0 	mov	w0, w19
 1124d04:	a94153f3 	ldp	x19, x20, [sp, #16]
 1124d08:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1124d0c:	a94363f7 	ldp	x23, x24, [sp, #48]
 1124d10:	f94023f9 	ldr	x25, [sp, #64]
 1124d14:	a8cf7bfd 	ldp	x29, x30, [sp], #240
 1124d18:	d65f03c0 	ret
		return TEE_ERROR_CORRUPT_OBJECT;
 1124d1c:	52800033 	mov	w19, #0x1                   	// #1
 1124d20:	72be0213 	movk	w19, #0xf010, lsl #16
 1124d24:	17fffff7 	b	1124d00 <tee_fs_htree_write_block+0x100>
		tee_fs_htree_close(ht_arg);
 1124d28:	aa1603e0 	mov	x0, x22
 1124d2c:	97fffe50 	bl	112466c <tee_fs_htree_close>
 1124d30:	17fffff4 	b	1124d00 <tee_fs_htree_write_block+0x100>

0000000001124d34 <tee_fs_htree_read_block>:

TEE_Result tee_fs_htree_read_block(struct tee_fs_htree **ht_arg,
				   size_t block_num, void *block)
{
 1124d34:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
 1124d38:	910003fd 	mov	x29, sp
 1124d3c:	a90153f3 	stp	x19, x20, [sp, #16]
	struct tee_fs_htree *ht = *ht_arg;
 1124d40:	f9400014 	ldr	x20, [x0]
{
 1124d44:	a9025bf5 	stp	x21, x22, [sp, #32]
 1124d48:	a90363f7 	stp	x23, x24, [sp, #48]
 1124d4c:	f90023f9 	str	x25, [sp, #64]
	uint8_t block_vers;
	size_t len;
	void *ctx;
	void *enc_block;

	if (!ht)
 1124d50:	b4000814 	cbz	x20, 1124e50 <tee_fs_htree_read_block+0x11c>
	res = get_node(ht, create, BLOCK_NUM_TO_NODE_ID(block_num), &nd);
 1124d54:	9101c3f9 	add	x25, sp, #0x70
 1124d58:	aa0003f5 	mov	x21, x0
 1124d5c:	aa0103f6 	mov	x22, x1
 1124d60:	aa0203f8 	mov	x24, x2
 1124d64:	aa1903e3 	mov	x3, x25
 1124d68:	91000422 	add	x2, x1, #0x1
 1124d6c:	aa1403e0 	mov	x0, x20
 1124d70:	52800001 	mov	w1, #0x0                   	// #0
 1124d74:	97fffd32 	bl	112423c <get_node>
 1124d78:	2a0003f3 	mov	w19, w0
	if (res == TEE_SUCCESS)
 1124d7c:	35000520 	cbnz	w0, 1124e20 <tee_fs_htree_read_block+0xec>
	res = get_block_node(ht, false, block_num, &node);
	if (res != TEE_SUCCESS)
		goto out;

	block_vers = !!(node->node.flags & HTREE_NODE_COMMITTED_BLOCK);
	res = ht->stor->rpc_read_init(ht->stor_aux, &op,
 1124d80:	f9407280 	ldr	x0, [x20, #224]
 1124d84:	9101a3e5 	add	x5, sp, #0x68
		*node = nd;
 1124d88:	f9403bf7 	ldr	x23, [sp, #112]
	res = ht->stor->rpc_read_init(ht->stor_aux, &op,
 1124d8c:	aa1603e3 	mov	x3, x22
 1124d90:	f9400406 	ldr	x6, [x0, #8]
 1124d94:	aa1903e1 	mov	x1, x25
 1124d98:	f9407680 	ldr	x0, [x20, #232]
 1124d9c:	52800042 	mov	w2, #0x2                   	// #2
	block_vers = !!(node->node.flags & HTREE_NODE_COMMITTED_BLOCK);
 1124da0:	794096e4 	ldrh	w4, [x23, #74]
	res = ht->stor->rpc_read_init(ht->stor_aux, &op,
 1124da4:	12000084 	and	w4, w4, #0x1
 1124da8:	d63f00c0 	blr	x6
 1124dac:	2a0003f3 	mov	w19, w0
				      TEE_FS_HTREE_TYPE_BLOCK, block_num,
				      block_vers, &enc_block);
	if (res != TEE_SUCCESS)
 1124db0:	35000380 	cbnz	w0, 1124e20 <tee_fs_htree_read_block+0xec>
		goto out;

	res = ht->stor->rpc_read_final(&op, &len);
 1124db4:	f9407280 	ldr	x0, [x20, #224]
 1124db8:	910163e1 	add	x1, sp, #0x58
 1124dbc:	f9400802 	ldr	x2, [x0, #16]
 1124dc0:	aa1903e0 	mov	x0, x25
 1124dc4:	d63f0040 	blr	x2
 1124dc8:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 1124dcc:	350002a0 	cbnz	w0, 1124e20 <tee_fs_htree_read_block+0xec>
		goto out;
	if (len != ht->stor->block_size) {
 1124dd0:	f9407280 	ldr	x0, [x20, #224]
 1124dd4:	f9400004 	ldr	x4, [x0]
 1124dd8:	f9402fe0 	ldr	x0, [sp, #88]
 1124ddc:	eb00009f 	cmp	x4, x0
 1124de0:	54000321 	b.ne	1124e44 <tee_fs_htree_read_block+0x110>  // b.any
		res = TEE_ERROR_CORRUPT_OBJECT;
		goto out;
	}

	res = authenc_init(&ctx, TEE_MODE_DECRYPT, ht, &node->node,
 1124de4:	91002ae3 	add	x3, x23, #0xa
 1124de8:	aa1403e2 	mov	x2, x20
 1124dec:	910183e0 	add	x0, sp, #0x60
 1124df0:	52800021 	mov	w1, #0x1                   	// #1
 1124df4:	97fffc75 	bl	1123fc8 <authenc_init>
 1124df8:	2a0003f3 	mov	w19, w0
			   ht->stor->block_size);
	if (res != TEE_SUCCESS)
 1124dfc:	35000120 	cbnz	w0, 1124e20 <tee_fs_htree_read_block+0xec>
		goto out;

	res = authenc_decrypt_final(ctx, node->node.tag, enc_block,
 1124e00:	f9407280 	ldr	x0, [x20, #224]
 1124e04:	aa1803e4 	mov	x4, x24
 1124e08:	9100eae1 	add	x1, x23, #0x3a
 1124e0c:	f9400003 	ldr	x3, [x0]
 1124e10:	a9460be0 	ldp	x0, x2, [sp, #96]
 1124e14:	97fffcc4 	bl	1124124 <authenc_decrypt_final>
 1124e18:	2a0003f3 	mov	w19, w0
				    ht->stor->block_size, block);
out:
	if (res != TEE_SUCCESS)
 1124e1c:	34000060 	cbz	w0, 1124e28 <tee_fs_htree_read_block+0xf4>
		tee_fs_htree_close(ht_arg);
 1124e20:	aa1503e0 	mov	x0, x21
 1124e24:	97fffe12 	bl	112466c <tee_fs_htree_close>
	return res;
}
 1124e28:	2a1303e0 	mov	w0, w19
 1124e2c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1124e30:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1124e34:	a94363f7 	ldp	x23, x24, [sp, #48]
 1124e38:	f94023f9 	ldr	x25, [sp, #64]
 1124e3c:	a8d07bfd 	ldp	x29, x30, [sp], #256
 1124e40:	d65f03c0 	ret
		res = TEE_ERROR_CORRUPT_OBJECT;
 1124e44:	52800033 	mov	w19, #0x1                   	// #1
 1124e48:	72be0213 	movk	w19, #0xf010, lsl #16
 1124e4c:	17fffff5 	b	1124e20 <tee_fs_htree_read_block+0xec>
		return TEE_ERROR_CORRUPT_OBJECT;
 1124e50:	52800033 	mov	w19, #0x1                   	// #1
 1124e54:	72be0213 	movk	w19, #0xf010, lsl #16
 1124e58:	17fffff4 	b	1124e28 <tee_fs_htree_read_block+0xf4>

0000000001124e5c <tee_fs_htree_truncate>:

TEE_Result tee_fs_htree_truncate(struct tee_fs_htree **ht_arg, size_t block_num)
{
 1124e5c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1124e60:	910003fd 	mov	x29, sp
 1124e64:	a90153f3 	stp	x19, x20, [sp, #16]
	struct tee_fs_htree *ht = *ht_arg;
 1124e68:	f9400013 	ldr	x19, [x0]
{
 1124e6c:	f90013f5 	str	x21, [sp, #32]
	size_t node_id = BLOCK_NUM_TO_NODE_ID(block_num);
	struct htree_node *node;

	if (!ht)
 1124e70:	b40008b3 	cbz	x19, 1124f84 <tee_fs_htree_truncate+0x128>
 1124e74:	91000434 	add	x20, x1, #0x1
		assert(node->parent);
		assert(node->parent->child[node->id & 1] == node);
		node->parent->child[node->id & 1] = NULL;
		free(node);
		ht->imeta.max_node_id--;
		ht->dirty = true;
 1124e78:	52800035 	mov	w21, #0x1                   	// #1
	while (node_id < ht->imeta.max_node_id) {
 1124e7c:	b940ca61 	ldr	w1, [x19, #200]
 1124e80:	eb14003f 	cmp	x1, x20
 1124e84:	540000c8 	b.hi	1124e9c <tee_fs_htree_truncate+0x40>  // b.pmore
	}

	return TEE_SUCCESS;
 1124e88:	52800000 	mov	w0, #0x0                   	// #0
}
 1124e8c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1124e90:	f94013f5 	ldr	x21, [sp, #32]
 1124e94:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1124e98:	d65f03c0 	ret
		node = find_closest_node(ht, ht->imeta.max_node_id);
 1124e9c:	aa1303e0 	mov	x0, x19
 1124ea0:	97fffcc4 	bl	11241b0 <find_closest_node>
		assert(node && node->id == ht->imeta.max_node_id);
 1124ea4:	b40000a0 	cbz	x0, 1124eb8 <tee_fs_htree_truncate+0x5c>
 1124ea8:	f9400004 	ldr	x4, [x0]
 1124eac:	b940ca61 	ldr	w1, [x19, #200]
 1124eb0:	eb01009f 	cmp	x4, x1
 1124eb4:	54000140 	b.eq	1124edc <tee_fs_htree_truncate+0x80>  // b.none
 1124eb8:	b0000183 	adrp	x3, 1155000 <__func__.3826+0xa8>
 1124ebc:	b0000181 	adrp	x1, 1155000 <__func__.3826+0xa8>
 1124ec0:	b0000180 	adrp	x0, 1155000 <__func__.3826+0xa8>
 1124ec4:	91335863 	add	x3, x3, #0xcd6
 1124ec8:	912e7c21 	add	x1, x1, #0xb9f
 1124ecc:	91307400 	add	x0, x0, #0xc1d
 1124ed0:	528072c2 	mov	w2, #0x396                 	// #918
		assert(!node->child[0] && !node->child[1]);
 1124ed4:	97ffb4f6 	bl	11122ac <_assert_log>
 1124ed8:	97ffb506 	bl	11122f0 <_assert_break>
 1124edc:	f9402c01 	ldr	x1, [x0, #88]
 1124ee0:	b5000061 	cbnz	x1, 1124eec <tee_fs_htree_truncate+0x90>
 1124ee4:	f9403001 	ldr	x1, [x0, #96]
 1124ee8:	b4000121 	cbz	x1, 1124f0c <tee_fs_htree_truncate+0xb0>
 1124eec:	b0000183 	adrp	x3, 1155000 <__func__.3826+0xa8>
 1124ef0:	b0000181 	adrp	x1, 1155000 <__func__.3826+0xa8>
 1124ef4:	b0000180 	adrp	x0, 1155000 <__func__.3826+0xa8>
 1124ef8:	91335863 	add	x3, x3, #0xcd6
 1124efc:	912e7c21 	add	x1, x1, #0xb9f
 1124f00:	91311c00 	add	x0, x0, #0xc47
 1124f04:	528072e2 	mov	w2, #0x397                 	// #919
 1124f08:	17fffff3 	b	1124ed4 <tee_fs_htree_truncate+0x78>
		assert(node->parent);
 1124f0c:	f9402803 	ldr	x3, [x0, #80]
 1124f10:	b5000123 	cbnz	x3, 1124f34 <tee_fs_htree_truncate+0xd8>
 1124f14:	b0000183 	adrp	x3, 1155000 <__func__.3826+0xa8>
 1124f18:	b0000181 	adrp	x1, 1155000 <__func__.3826+0xa8>
 1124f1c:	b0000180 	adrp	x0, 1155000 <__func__.3826+0xa8>
 1124f20:	91335863 	add	x3, x3, #0xcd6
 1124f24:	912e7c21 	add	x1, x1, #0xb9f
 1124f28:	9131a800 	add	x0, x0, #0xc6a
 1124f2c:	52807302 	mov	w2, #0x398                 	// #920
 1124f30:	17ffffe9 	b	1124ed4 <tee_fs_htree_truncate+0x78>
		assert(node->parent->child[node->id & 1] == node);
 1124f34:	d37d0084 	ubfiz	x4, x4, #3, #1
 1124f38:	8b040063 	add	x3, x3, x4
 1124f3c:	f9402c61 	ldr	x1, [x3, #88]
 1124f40:	eb00003f 	cmp	x1, x0
 1124f44:	54000120 	b.eq	1124f68 <tee_fs_htree_truncate+0x10c>  // b.none
 1124f48:	b0000183 	adrp	x3, 1155000 <__func__.3826+0xa8>
 1124f4c:	b0000181 	adrp	x1, 1155000 <__func__.3826+0xa8>
 1124f50:	b0000180 	adrp	x0, 1155000 <__func__.3826+0xa8>
 1124f54:	91335863 	add	x3, x3, #0xcd6
 1124f58:	912e7c21 	add	x1, x1, #0xb9f
 1124f5c:	9131dc00 	add	x0, x0, #0xc77
 1124f60:	52807322 	mov	w2, #0x399                 	// #921
 1124f64:	17ffffdc 	b	1124ed4 <tee_fs_htree_truncate+0x78>
		node->parent->child[node->id & 1] = NULL;
 1124f68:	f9002c7f 	str	xzr, [x3, #88]
		free(node);
 1124f6c:	9400799d 	bl	11435e0 <free>
		ht->dirty = true;
 1124f70:	39034275 	strb	w21, [x19, #208]
		ht->imeta.max_node_id--;
 1124f74:	b940ca60 	ldr	w0, [x19, #200]
 1124f78:	51000400 	sub	w0, w0, #0x1
 1124f7c:	b900ca60 	str	w0, [x19, #200]
		ht->dirty = true;
 1124f80:	17ffffbf 	b	1124e7c <tee_fs_htree_truncate+0x20>
		return TEE_ERROR_CORRUPT_OBJECT;
 1124f84:	52800020 	mov	w0, #0x1                   	// #1
 1124f88:	72be0200 	movk	w0, #0xf010, lsl #16
 1124f8c:	17ffffc0 	b	1124e8c <tee_fs_htree_truncate+0x30>

0000000001124f90 <read_dent>:
	return false;
}

static TEE_Result read_dent(struct tee_fs_dirfile_dirh *dirh, int idx,
			    struct dirfile_entry *dent)
{
 1124f90:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	TEE_Result res;
	size_t l;

	l = sizeof(*dent);
	res = dirh->fops->read(dirh->fh, sizeof(struct dirfile_entry) * idx,
 1124f94:	93407c21 	sxtw	x1, w1
	l = sizeof(*dent);
 1124f98:	d2800f04 	mov	x4, #0x78                  	// #120
{
 1124f9c:	910003fd 	mov	x29, sp
	res = dirh->fops->read(dirh->fh, sizeof(struct dirfile_entry) * idx,
 1124fa0:	a9400003 	ldp	x3, x0, [x0]
 1124fa4:	9b047c21 	mul	x1, x1, x4
	l = sizeof(*dent);
 1124fa8:	f9000fe4 	str	x4, [sp, #24]
	res = dirh->fops->read(dirh->fh, sizeof(struct dirfile_entry) * idx,
 1124fac:	f9400865 	ldr	x5, [x3, #16]
 1124fb0:	910063e3 	add	x3, sp, #0x18
 1124fb4:	d63f00a0 	blr	x5
			       dent, &l);
	if (!res && l != sizeof(*dent))
 1124fb8:	350000a0 	cbnz	w0, 1124fcc <read_dent+0x3c>
		res = TEE_ERROR_ITEM_NOT_FOUND;
 1124fbc:	f9400fe0 	ldr	x0, [sp, #24]
 1124fc0:	f101e01f 	cmp	x0, #0x78
 1124fc4:	129ffee0 	mov	w0, #0xffff0008            	// #-65528
 1124fc8:	1a8003e0 	csel	w0, wzr, w0, eq  // eq = none

	return res;
}
 1124fcc:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1124fd0:	d65f03c0 	ret

0000000001124fd4 <test_file>:
	if (idx < dirh->nbits)
 1124fd4:	b9401002 	ldr	w2, [x0, #16]
 1124fd8:	6b01005f 	cmp	w2, w1
 1124fdc:	5400014d 	b.le	1125004 <test_file+0x30>
		return bit_test(dirh->files, idx);
 1124fe0:	f9400c00 	ldr	x0, [x0, #24]
 1124fe4:	13037c22 	asr	w2, w1, #3
 1124fe8:	12000821 	and	w1, w1, #0x7
 1124fec:	3862c802 	ldrb	w2, [x0, w2, sxtw]
 1124ff0:	52800020 	mov	w0, #0x1                   	// #1
 1124ff4:	1ac12001 	lsl	w1, w0, w1
 1124ff8:	6a01005f 	tst	w2, w1
 1124ffc:	1a9f07e0 	cset	w0, ne  // ne = any
}
 1125000:	d65f03c0 	ret
	return false;
 1125004:	52800000 	mov	w0, #0x0                   	// #0
 1125008:	17fffffe 	b	1125000 <test_file+0x2c>

000000000112500c <write_dent>:

static TEE_Result write_dent(struct tee_fs_dirfile_dirh *dirh, size_t n,
			     struct dirfile_entry *dent)
{
 112500c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	TEE_Result res;

	res = dirh->fops->write(dirh->fh, sizeof(*dent) * n,
 1125010:	d2800f03 	mov	x3, #0x78                  	// #120
{
 1125014:	910003fd 	mov	x29, sp
 1125018:	a90153f3 	stp	x19, x20, [sp, #16]
 112501c:	aa0003f4 	mov	x20, x0
 1125020:	aa0103f3 	mov	x19, x1
	res = dirh->fops->write(dirh->fh, sizeof(*dent) * n,
 1125024:	f9400000 	ldr	x0, [x0]
 1125028:	9b037c21 	mul	x1, x1, x3
 112502c:	f9400c04 	ldr	x4, [x0, #24]
 1125030:	f9400680 	ldr	x0, [x20, #8]
 1125034:	d63f0080 	blr	x4
				dent, sizeof(*dent));
	if (!res && n >= dirh->ndents)
 1125038:	350000c0 	cbnz	w0, 1125050 <write_dent+0x44>
 112503c:	f9401281 	ldr	x1, [x20, #32]
 1125040:	eb01027f 	cmp	x19, x1
 1125044:	54000063 	b.cc	1125050 <write_dent+0x44>  // b.lo, b.ul, b.last
		dirh->ndents = n + 1;
 1125048:	91000673 	add	x19, x19, #0x1
 112504c:	f9001293 	str	x19, [x20, #32]

	return res;
}
 1125050:	a94153f3 	ldp	x19, x20, [sp, #16]
 1125054:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1125058:	d65f03c0 	ret

000000000112505c <set_file>:
{
 112505c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1125060:	910003fd 	mov	x29, sp
 1125064:	a90153f3 	stp	x19, x20, [sp, #16]
 1125068:	aa0003f4 	mov	x20, x0
	if (idx < dirh->nbits)
 112506c:	b9401000 	ldr	w0, [x0, #16]
{
 1125070:	2a0103f3 	mov	w19, w1
	if (idx < dirh->nbits)
 1125074:	6b00003f 	cmp	w1, w0
 1125078:	540003cb 	b.lt	11250f0 <set_file+0x94>  // b.tstop
	p = realloc(dirh->files, bitstr_size(idx + 1));
 112507c:	11002021 	add	w1, w1, #0x8
 1125080:	f9400e80 	ldr	x0, [x20, #24]
 1125084:	13037c21 	asr	w1, w1, #3
 1125088:	93407c21 	sxtw	x1, w1
 112508c:	94007935 	bl	1143560 <realloc>
	if (!p)
 1125090:	b4000600 	cbz	x0, 1125150 <set_file+0xf4>
	bit_nclear(dirh->files, dirh->nbits, idx);
 1125094:	b9401282 	ldr	w2, [x20, #16]
 1125098:	12000a65 	and	w5, w19, #0x7
 112509c:	110004a5 	add	w5, w5, #0x1
	dirh->files = p;
 11250a0:	f9000e80 	str	x0, [x20, #24]
 11250a4:	12000841 	and	w1, w2, #0x7
	bit_nclear(dirh->files, dirh->nbits, idx);
 11250a8:	13037e64 	asr	w4, w19, #3
 11250ac:	13037c46 	asr	w6, w2, #3
 11250b0:	52800102 	mov	w2, #0x8                   	// #8
 11250b4:	4b010042 	sub	w2, w2, w1
 11250b8:	52801fe1 	mov	w1, #0xff                  	// #255
 11250bc:	93407cc3 	sxtw	x3, w6
 11250c0:	6b930cdf 	cmp	w6, w19, asr #3
 11250c4:	1ac22822 	asr	w2, w1, w2
 11250c8:	1ac52021 	lsl	w1, w1, w5
 11250cc:	13001c42 	sxtb	w2, w2
 11250d0:	38636805 	ldrb	w5, [x0, x3]
 11250d4:	13001c21 	sxtb	w1, w1
 11250d8:	54000261 	b.ne	1125124 <set_file+0xc8>  // b.any
 11250dc:	2a010042 	orr	w2, w2, w1
 11250e0:	0a050042 	and	w2, w2, w5
 11250e4:	38236802 	strb	w2, [x0, x3]
	dirh->nbits = idx + 1;
 11250e8:	11000660 	add	w0, w19, #0x1
 11250ec:	b9001280 	str	w0, [x20, #16]
		bit_set(dirh->files, idx);
 11250f0:	13037e60 	asr	w0, w19, #3
 11250f4:	12000a73 	and	w19, w19, #0x7
 11250f8:	f9400e82 	ldr	x2, [x20, #24]
 11250fc:	93407c00 	sxtw	x0, w0
 1125100:	52800021 	mov	w1, #0x1                   	// #1
 1125104:	1ad32033 	lsl	w19, w1, w19
 1125108:	38606841 	ldrb	w1, [x2, x0]
 112510c:	2a010273 	orr	w19, w19, w1
 1125110:	38206853 	strb	w19, [x2, x0]
 1125114:	52800000 	mov	w0, #0x0                   	// #0
}
 1125118:	a94153f3 	ldp	x19, x20, [sp, #16]
 112511c:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1125120:	d65f03c0 	ret
	bit_nclear(dirh->files, dirh->nbits, idx);
 1125124:	0a050042 	and	w2, w2, w5
 1125128:	38236802 	strb	w2, [x0, x3]
 112512c:	91000463 	add	x3, x3, #0x1
 1125130:	6b03009f 	cmp	w4, w3
 1125134:	540000ac 	b.gt	1125148 <set_file+0xec>
 1125138:	93407c83 	sxtw	x3, w4
 112513c:	38636802 	ldrb	w2, [x0, x3]
 1125140:	0a020022 	and	w2, w1, w2
 1125144:	17ffffe8 	b	11250e4 <set_file+0x88>
 1125148:	3823681f 	strb	wzr, [x0, x3]
 112514c:	17fffff8 	b	112512c <set_file+0xd0>
		return TEE_ERROR_OUT_OF_MEMORY;
 1125150:	129ffe60 	mov	w0, #0xffff000c            	// #-65524
	return res;
 1125154:	17fffff1 	b	1125118 <set_file+0xbc>

0000000001125158 <tee_fs_dirfile_close>:
	return res;
}

void tee_fs_dirfile_close(struct tee_fs_dirfile_dirh *dirh)
{
	if (dirh) {
 1125158:	b40001e0 	cbz	x0, 1125194 <tee_fs_dirfile_close+0x3c>
{
 112515c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1125160:	910003fd 	mov	x29, sp
 1125164:	f9000bf3 	str	x19, [sp, #16]
 1125168:	aa0003f3 	mov	x19, x0
		dirh->fops->close(dirh->fh);
 112516c:	f9400000 	ldr	x0, [x0]
 1125170:	f9400401 	ldr	x1, [x0, #8]
 1125174:	f9400660 	ldr	x0, [x19, #8]
 1125178:	d63f0020 	blr	x1
		free(dirh->files);
 112517c:	f9400e60 	ldr	x0, [x19, #24]
 1125180:	94007918 	bl	11435e0 <free>
		free(dirh);
 1125184:	aa1303e0 	mov	x0, x19
	}
}
 1125188:	f9400bf3 	ldr	x19, [sp, #16]
 112518c:	a8c27bfd 	ldp	x29, x30, [sp], #32
		free(dirh);
 1125190:	14007914 	b	11435e0 <free>
 1125194:	d65f03c0 	ret

0000000001125198 <tee_fs_dirfile_open>:
{
 1125198:	a9b37bfd 	stp	x29, x30, [sp, #-208]!
 112519c:	910003fd 	mov	x29, sp
 11251a0:	a90153f3 	stp	x19, x20, [sp, #16]
 11251a4:	aa0103f4 	mov	x20, x1
 11251a8:	aa0203f3 	mov	x19, x2
	struct tee_fs_dirfile_dirh *dirh = calloc(1, sizeof(*dirh));
 11251ac:	d2800501 	mov	x1, #0x28                  	// #40
{
 11251b0:	a9025bf5 	stp	x21, x22, [sp, #32]
 11251b4:	12001c16 	and	w22, w0, #0xff
 11251b8:	aa0303f5 	mov	x21, x3
	struct tee_fs_dirfile_dirh *dirh = calloc(1, sizeof(*dirh));
 11251bc:	d2800020 	mov	x0, #0x1                   	// #1
{
 11251c0:	a90363f7 	stp	x23, x24, [sp, #48]
 11251c4:	f90023f9 	str	x25, [sp, #64]
	struct tee_fs_dirfile_dirh *dirh = calloc(1, sizeof(*dirh));
 11251c8:	940078c2 	bl	11434d0 <calloc>
	if (!dirh)
 11251cc:	b4000880 	cbz	x0, 11252dc <tee_fs_dirfile_open+0x144>
	dirh->fops = fops;
 11251d0:	aa0003e4 	mov	x4, x0
 11251d4:	aa0003f9 	mov	x25, x0
	res = fops->open(create, hash, NULL, NULL, &dirh->fh);
 11251d8:	f9400265 	ldr	x5, [x19]
 11251dc:	aa1403e1 	mov	x1, x20
	dirh->fops = fops;
 11251e0:	f8008493 	str	x19, [x4], #8
	res = fops->open(create, hash, NULL, NULL, &dirh->fh);
 11251e4:	2a1603e0 	mov	w0, w22
 11251e8:	d2800003 	mov	x3, #0x0                   	// #0
 11251ec:	d2800002 	mov	x2, #0x0                   	// #0
 11251f0:	d63f00a0 	blr	x5
 11251f4:	2a0003f3 	mov	w19, w0
	if (res)
 11251f8:	350006c0 	cbnz	w0, 11252d0 <tee_fs_dirfile_open+0x138>
			DMSG("clearing duplicate file number %" PRIu32,
 11251fc:	90000197 	adrp	x23, 1155000 <__func__.3826+0xa8>
 1125200:	90000198 	adrp	x24, 1155000 <__func__.3826+0xa8>
		res = read_dent(dirh, n, &dent);
 1125204:	910163f6 	add	x22, sp, #0x58
			DMSG("clearing duplicate file number %" PRIu32,
 1125208:	9133b2f7 	add	x23, x23, #0xcec
 112520c:	91372f18 	add	x24, x24, #0xdcb
	for (n = 0;; n++) {
 1125210:	d2800014 	mov	x20, #0x0                   	// #0
		res = read_dent(dirh, n, &dent);
 1125214:	aa1603e2 	mov	x2, x22
 1125218:	2a1403e1 	mov	w1, w20
 112521c:	aa1903e0 	mov	x0, x25
 1125220:	97ffff5c 	bl	1124f90 <read_dent>
		if (res) {
 1125224:	340001a0 	cbz	w0, 1125258 <tee_fs_dirfile_open+0xc0>
			if (res == TEE_ERROR_ITEM_NOT_FOUND)
 1125228:	129ffee1 	mov	w1, #0xffff0008            	// #-65528
 112522c:	6b01001f 	cmp	w0, w1
 1125230:	540004e1 	b.ne	11252cc <tee_fs_dirfile_open+0x134>  // b.any
		*dirh_ret = dirh;
 1125234:	f90002b9 	str	x25, [x21]
		dirh->ndents = n;
 1125238:	f9001334 	str	x20, [x25, #32]
}
 112523c:	2a1303e0 	mov	w0, w19
 1125240:	a94153f3 	ldp	x19, x20, [sp, #16]
 1125244:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1125248:	a94363f7 	ldp	x23, x24, [sp, #48]
 112524c:	f94023f9 	ldr	x25, [sp, #64]
 1125250:	a8cd7bfd 	ldp	x29, x30, [sp], #208
 1125254:	d65f03c0 	ret
		if (!dent.oidlen)
 1125258:	b940abe0 	ldr	w0, [sp, #168]
 112525c:	340002c0 	cbz	w0, 11252b4 <tee_fs_dirfile_open+0x11c>
		if (test_file(dirh, dent.file_number)) {
 1125260:	b940cfe5 	ldr	w5, [sp, #204]
 1125264:	aa1903e0 	mov	x0, x25
 1125268:	2a0503e1 	mov	w1, w5
 112526c:	97ffff5a 	bl	1124fd4 <test_file>
 1125270:	72001c1f 	tst	w0, #0xff
 1125274:	54000240 	b.eq	11252bc <tee_fs_dirfile_open+0x124>  // b.none
			DMSG("clearing duplicate file number %" PRIu32,
 1125278:	aa1703e4 	mov	x4, x23
 112527c:	52800023 	mov	w3, #0x1                   	// #1
 1125280:	aa1803e0 	mov	x0, x24
 1125284:	52800062 	mov	w2, #0x3                   	// #3
 1125288:	52801181 	mov	w1, #0x8c                  	// #140
 112528c:	94007eae 	bl	1144d44 <trace_printf>
			memset(&dent, 0, sizeof(dent));
 1125290:	d2800f02 	mov	x2, #0x78                  	// #120
 1125294:	52800001 	mov	w1, #0x0                   	// #0
 1125298:	aa1603e0 	mov	x0, x22
 112529c:	94007a91 	bl	1143ce0 <memset>
			res = write_dent(dirh, n, &dent);
 11252a0:	aa1603e2 	mov	x2, x22
 11252a4:	aa1403e1 	mov	x1, x20
 11252a8:	aa1903e0 	mov	x0, x25
 11252ac:	97ffff58 	bl	112500c <write_dent>
		if (res != TEE_SUCCESS)
 11252b0:	350000e0 	cbnz	w0, 11252cc <tee_fs_dirfile_open+0x134>
	for (n = 0;; n++) {
 11252b4:	91000694 	add	x20, x20, #0x1
 11252b8:	17ffffd7 	b	1125214 <tee_fs_dirfile_open+0x7c>
		res = set_file(dirh, dent.file_number);
 11252bc:	2a0503e1 	mov	w1, w5
 11252c0:	aa1903e0 	mov	x0, x25
 11252c4:	97ffff66 	bl	112505c <set_file>
 11252c8:	17fffffa 	b	11252b0 <tee_fs_dirfile_open+0x118>
			goto out;
 11252cc:	2a0003f3 	mov	w19, w0
		tee_fs_dirfile_close(dirh);
 11252d0:	aa1903e0 	mov	x0, x25
 11252d4:	97ffffa1 	bl	1125158 <tee_fs_dirfile_close>
 11252d8:	17ffffd9 	b	112523c <tee_fs_dirfile_open+0xa4>
		return TEE_ERROR_OUT_OF_MEMORY;
 11252dc:	129ffe73 	mov	w19, #0xffff000c            	// #-65524
 11252e0:	17ffffd7 	b	112523c <tee_fs_dirfile_open+0xa4>

00000000011252e4 <tee_fs_dirfile_commit_writes>:

TEE_Result tee_fs_dirfile_commit_writes(struct tee_fs_dirfile_dirh *dirh,
					uint8_t *hash)
{
	return dirh->fops->commit_writes(dirh->fh, hash);
 11252e4:	a9400002 	ldp	x2, x0, [x0]
 11252e8:	f9401042 	ldr	x2, [x2, #32]
 11252ec:	aa0203f0 	mov	x16, x2
 11252f0:	d61f0200 	br	x16

00000000011252f4 <tee_fs_dirfile_get_tmp>:
}

TEE_Result tee_fs_dirfile_get_tmp(struct tee_fs_dirfile_dirh *dirh,
				  struct tee_fs_dirfile_fileh *dfh)
{
 11252f4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 11252f8:	910003fd 	mov	x29, sp
	TEE_Result res;
	int i = 0;

	if (dirh->files) {
 11252fc:	f9400c02 	ldr	x2, [x0, #24]
{
 1125300:	a90153f3 	stp	x19, x20, [sp, #16]
 1125304:	aa0103f4 	mov	x20, x1
	if (dirh->files) {
 1125308:	b40003c2 	cbz	x2, 1125380 <tee_fs_dirfile_get_tmp+0x8c>
		bit_ffc(dirh->files, dirh->nbits, &i);
 112530c:	b9401013 	ldr	w19, [x0, #16]
 1125310:	7100027f 	cmp	w19, #0x0
 1125314:	5400010d 	b.le	1125334 <tee_fs_dirfile_get_tmp+0x40>
 1125318:	51000661 	sub	w1, w19, #0x1
 112531c:	d1000444 	sub	x4, x2, #0x1
 1125320:	d2800003 	mov	x3, #0x0                   	// #0
 1125324:	13037c21 	asr	w1, w1, #3
 1125328:	2a0303e2 	mov	w2, w3
 112532c:	6b03003f 	cmp	w1, w3
 1125330:	5400010a 	b.ge	1125350 <tee_fs_dirfile_get_tmp+0x5c>  // b.tcont
		if (i == -1)
			i = dirh->nbits;
	}

	res = set_file(dirh, i);
 1125334:	2a1303e1 	mov	w1, w19
 1125338:	97ffff49 	bl	112505c <set_file>
	if (!res)
 112533c:	35000040 	cbnz	w0, 1125344 <tee_fs_dirfile_get_tmp+0x50>
		dfh->file_number = i;
 1125340:	b9000293 	str	w19, [x20]

	return res;
}
 1125344:	a94153f3 	ldp	x19, x20, [sp, #16]
 1125348:	a8c27bfd 	ldp	x29, x30, [sp], #32
 112534c:	d65f03c0 	ret
		bit_ffc(dirh->files, dirh->nbits, &i);
 1125350:	91000463 	add	x3, x3, #0x1
 1125354:	38636885 	ldrb	w5, [x4, x3]
 1125358:	7103fcbf 	cmp	w5, #0xff
 112535c:	54fffe60 	b.eq	1125328 <tee_fs_dirfile_get_tmp+0x34>  // b.none
 1125360:	531d7042 	lsl	w2, w2, #3
 1125364:	37000085 	tbnz	w5, #0, 1125374 <tee_fs_dirfile_get_tmp+0x80>
 1125368:	6b02027f 	cmp	w19, w2
 112536c:	1a82d273 	csel	w19, w19, w2, le
 1125370:	17fffff1 	b	1125334 <tee_fs_dirfile_get_tmp+0x40>
 1125374:	11000442 	add	w2, w2, #0x1
 1125378:	53017ca5 	lsr	w5, w5, #1
 112537c:	17fffffa 	b	1125364 <tee_fs_dirfile_get_tmp+0x70>
	int i = 0;
 1125380:	52800013 	mov	w19, #0x0                   	// #0
 1125384:	17ffffec 	b	1125334 <tee_fs_dirfile_get_tmp+0x40>

0000000001125388 <tee_fs_dirfile_find>:

TEE_Result tee_fs_dirfile_find(struct tee_fs_dirfile_dirh *dirh,
			       const TEE_UUID *uuid, const void *oid,
			       size_t oidlen, struct tee_fs_dirfile_fileh *dfh)
{
 1125388:	a9b27bfd 	stp	x29, x30, [sp, #-224]!
 112538c:	910003fd 	mov	x29, sp
 1125390:	a90363f7 	stp	x23, x24, [sp, #48]
	struct dirfile_entry dent;
	int n;
	int first_free = -1;

	for (n = 0;; n++) {
		res = read_dent(dirh, n, &dent);
 1125394:	9101a3f8 	add	x24, sp, #0x68
{
 1125398:	aa0003f7 	mov	x23, x0
 112539c:	a90153f3 	stp	x19, x20, [sp, #16]
 11253a0:	aa0403f3 	mov	x19, x4
	for (n = 0;; n++) {
 11253a4:	52800014 	mov	w20, #0x0                   	// #0
{
 11253a8:	a9025bf5 	stp	x21, x22, [sp, #32]
 11253ac:	aa0303f5 	mov	x21, x3
	int first_free = -1;
 11253b0:	12800016 	mov	w22, #0xffffffff            	// #-1
{
 11253b4:	a9046bf9 	stp	x25, x26, [sp, #64]
 11253b8:	aa0103f9 	mov	x25, x1
 11253bc:	aa0203fa 	mov	x26, x2
 11253c0:	a90573fb 	stp	x27, x28, [sp, #80]

		assert(!oidlen || !dent.oidlen ||
		       test_file(dirh, dent.file_number));

		if (!memcmp(&dent.uuid, uuid, sizeof(dent.uuid)) &&
		    !memcmp(&dent.oid, oid, oidlen))
 11253c4:	9100431c 	add	x28, x24, #0x10
		if (res == TEE_ERROR_ITEM_NOT_FOUND && !oidlen) {
 11253c8:	129ffefb 	mov	w27, #0xffff0008            	// #-65528
		res = read_dent(dirh, n, &dent);
 11253cc:	aa1803e2 	mov	x2, x24
 11253d0:	2a1403e1 	mov	w1, w20
 11253d4:	aa1703e0 	mov	x0, x23
 11253d8:	97fffeee 	bl	1124f90 <read_dent>
		if (res == TEE_ERROR_ITEM_NOT_FOUND && !oidlen) {
 11253dc:	f10002bf 	cmp	x21, #0x0
 11253e0:	7a5b0000 	ccmp	w0, w27, #0x0, eq  // eq = none
 11253e4:	540002e1 	b.ne	1125440 <tee_fs_dirfile_find+0xb8>  // b.any
			memset(&dent, 0, sizeof(dent));
 11253e8:	aa1803e0 	mov	x0, x24
 11253ec:	d2800f02 	mov	x2, #0x78                  	// #120
 11253f0:	52800001 	mov	w1, #0x0                   	// #0
 11253f4:	94007a3b 	bl	1143ce0 <memset>
			if (first_free != -1)
 11253f8:	310006df 	cmn	w22, #0x1
 11253fc:	1a960294 	csel	w20, w20, w22, eq  // eq = none
			break;
	}

	if (dfh) {
 1125400:	b4000113 	cbz	x19, 1125420 <tee_fs_dirfile_find+0x98>
		dfh->idx = n;
		dfh->file_number = dent.file_number;
 1125404:	aa1303e0 	mov	x0, x19
 1125408:	b940dfe1 	ldr	w1, [sp, #220]
		dfh->idx = n;
 112540c:	b9002674 	str	w20, [x19, #36]
		memcpy(dfh->hash, dent.hash, sizeof(dent.hash));
 1125410:	d2800402 	mov	x2, #0x20                  	// #32
		dfh->file_number = dent.file_number;
 1125414:	b8004401 	str	w1, [x0], #4
		memcpy(dfh->hash, dent.hash, sizeof(dent.hash));
 1125418:	9102f3e1 	add	x1, sp, #0xbc
 112541c:	97ff77dd 	bl	1103390 <memcpy>
	}

	return TEE_SUCCESS;
 1125420:	52800000 	mov	w0, #0x0                   	// #0
}
 1125424:	a94153f3 	ldp	x19, x20, [sp, #16]
 1125428:	a9425bf5 	ldp	x21, x22, [sp, #32]
 112542c:	a94363f7 	ldp	x23, x24, [sp, #48]
 1125430:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1125434:	a94573fb 	ldp	x27, x28, [sp, #80]
 1125438:	a8ce7bfd 	ldp	x29, x30, [sp], #224
 112543c:	d65f03c0 	ret
		if (res)
 1125440:	35ffff20 	cbnz	w0, 1125424 <tee_fs_dirfile_find+0x9c>
		if (!dent.oidlen && first_free == -1)
 1125444:	b940bbe0 	ldr	w0, [sp, #184]
 1125448:	35000060 	cbnz	w0, 1125454 <tee_fs_dirfile_find+0xcc>
 112544c:	310006df 	cmn	w22, #0x1
 1125450:	1a9412d6 	csel	w22, w22, w20, ne  // ne = any
		if (dent.oidlen != oidlen)
 1125454:	eb2042bf 	cmp	x21, w0, uxtw
 1125458:	54000361 	b.ne	11254c4 <tee_fs_dirfile_find+0x13c>  // b.any
		assert(!oidlen || !dent.oidlen ||
 112545c:	b4000215 	cbz	x21, 112549c <tee_fs_dirfile_find+0x114>
 1125460:	340001e0 	cbz	w0, 112549c <tee_fs_dirfile_find+0x114>
 1125464:	b940dfe1 	ldr	w1, [sp, #220]
 1125468:	aa1703e0 	mov	x0, x23
 112546c:	97fffeda 	bl	1124fd4 <test_file>
 1125470:	72001c1f 	tst	w0, #0xff
 1125474:	54000141 	b.ne	112549c <tee_fs_dirfile_find+0x114>  // b.any
 1125478:	90000183 	adrp	x3, 1155000 <__func__.3826+0xa8>
 112547c:	90000181 	adrp	x1, 1155000 <__func__.3826+0xa8>
 1125480:	91377c63 	add	x3, x3, #0xddf
 1125484:	91343821 	add	x1, x1, #0xd0e
 1125488:	90000180 	adrp	x0, 1155000 <__func__.3826+0xa8>
 112548c:	91349000 	add	x0, x0, #0xd24
 1125490:	52801c02 	mov	w2, #0xe0                  	// #224
 1125494:	97ffb386 	bl	11122ac <_assert_log>
 1125498:	97ffb396 	bl	11122f0 <_assert_break>
		if (!memcmp(&dent.uuid, uuid, sizeof(dent.uuid)) &&
 112549c:	aa1903e1 	mov	x1, x25
 11254a0:	aa1803e0 	mov	x0, x24
 11254a4:	d2800202 	mov	x2, #0x10                  	// #16
 11254a8:	940079ea 	bl	1143c50 <memcmp>
 11254ac:	350000c0 	cbnz	w0, 11254c4 <tee_fs_dirfile_find+0x13c>
		    !memcmp(&dent.oid, oid, oidlen))
 11254b0:	aa1503e2 	mov	x2, x21
 11254b4:	aa1a03e1 	mov	x1, x26
 11254b8:	aa1c03e0 	mov	x0, x28
 11254bc:	940079e5 	bl	1143c50 <memcmp>
		if (!memcmp(&dent.uuid, uuid, sizeof(dent.uuid)) &&
 11254c0:	34fffa00 	cbz	w0, 1125400 <tee_fs_dirfile_find+0x78>
	for (n = 0;; n++) {
 11254c4:	11000694 	add	w20, w20, #0x1
		res = read_dent(dirh, n, &dent);
 11254c8:	17ffffc1 	b	11253cc <tee_fs_dirfile_find+0x44>

00000000011254cc <tee_fs_dirfile_fileh_to_fname>:

TEE_Result tee_fs_dirfile_fileh_to_fname(const struct tee_fs_dirfile_fileh *dfh,
					 char *fname, size_t *fnlen)
{
 11254cc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 11254d0:	aa0003e3 	mov	x3, x0
 11254d4:	aa0103e0 	mov	x0, x1
 11254d8:	910003fd 	mov	x29, sp
 11254dc:	a90153f3 	stp	x19, x20, [sp, #16]
 11254e0:	aa0203f3 	mov	x19, x2
	int r;
	size_t l = *fnlen;
 11254e4:	f9400054 	ldr	x20, [x2]

	if (dfh)
 11254e8:	b4000203 	cbz	x3, 1125528 <tee_fs_dirfile_fileh_to_fname+0x5c>
		r = snprintf(fname, l, "%" PRIx32, dfh->file_number);
 11254ec:	b9400063 	ldr	w3, [x3]
 11254f0:	f0000162 	adrp	x2, 1154000 <__func__.1786+0x8>
 11254f4:	aa1403e1 	mov	x1, x20
 11254f8:	91074842 	add	x2, x2, #0x1d2
 11254fc:	940079c0 	bl	1143bfc <snprintf>
	else
		r = snprintf(fname, l, "dirf.db");

	if (r < 0)
 1125500:	37f801e0 	tbnz	w0, #31, 112553c <tee_fs_dirfile_fileh_to_fname+0x70>
		return TEE_ERROR_GENERIC;

	*fnlen = r + 1;
 1125504:	11000401 	add	w1, w0, #0x1
	if ((size_t)r >= l)
		return TEE_ERROR_SHORT_BUFFER;
 1125508:	eb20c29f 	cmp	x20, w0, sxtw
 112550c:	129ffde0 	mov	w0, #0xffff0010            	// #-65520
 1125510:	1a8083e0 	csel	w0, wzr, w0, hi  // hi = pmore
	*fnlen = r + 1;
 1125514:	93407c21 	sxtw	x1, w1
 1125518:	f9000261 	str	x1, [x19]

	return TEE_SUCCESS;
}
 112551c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1125520:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1125524:	d65f03c0 	ret
		r = snprintf(fname, l, "dirf.db");
 1125528:	aa1403e1 	mov	x1, x20
 112552c:	90000182 	adrp	x2, 1155000 <__func__.3826+0xa8>
 1125530:	91358442 	add	x2, x2, #0xd61
 1125534:	940079b2 	bl	1143bfc <snprintf>
 1125538:	17fffff2 	b	1125500 <tee_fs_dirfile_fileh_to_fname+0x34>
		return TEE_ERROR_GENERIC;
 112553c:	52bfffe0 	mov	w0, #0xffff0000            	// #-65536
 1125540:	17fffff7 	b	112551c <tee_fs_dirfile_fileh_to_fname+0x50>

0000000001125544 <tee_fs_dirfile_rename>:

TEE_Result tee_fs_dirfile_rename(struct tee_fs_dirfile_dirh *dirh,
				 const TEE_UUID *uuid,
				 struct tee_fs_dirfile_fileh *dfh,
				 const void *oid, size_t oidlen)
{
 1125544:	a9b17bfd 	stp	x29, x30, [sp, #-240]!
 1125548:	910003fd 	mov	x29, sp
 112554c:	a90153f3 	stp	x19, x20, [sp, #16]
 1125550:	a9025bf5 	stp	x21, x22, [sp, #32]
 1125554:	aa0003f5 	mov	x21, x0
	TEE_Result res;
	struct dirfile_entry dent;

	if (!oidlen || oidlen > sizeof(dent.oid))
 1125558:	d1000480 	sub	x0, x4, #0x1
{
 112555c:	a90363f7 	stp	x23, x24, [sp, #48]
	if (!oidlen || oidlen > sizeof(dent.oid))
 1125560:	f100fc1f 	cmp	x0, #0x3f
{
 1125564:	f90023f9 	str	x25, [sp, #64]
	if (!oidlen || oidlen > sizeof(dent.oid))
 1125568:	54000748 	b.hi	1125650 <tee_fs_dirfile_rename+0x10c>  // b.pmore
		return TEE_ERROR_BAD_PARAMETERS;
	memset(&dent, 0, sizeof(dent));
 112556c:	9101e3f8 	add	x24, sp, #0x78
 1125570:	aa0403f4 	mov	x20, x4
 1125574:	91004319 	add	x25, x24, #0x10
 1125578:	aa0303f7 	mov	x23, x3
 112557c:	aa0203f3 	mov	x19, x2
 1125580:	aa0103f6 	mov	x22, x1
 1125584:	d2800802 	mov	x2, #0x40                  	// #64
 1125588:	52800001 	mov	w1, #0x0                   	// #0
 112558c:	aa1903e0 	mov	x0, x25
 1125590:	940079d4 	bl	1143ce0 <memset>
	dent.uuid = *uuid;
 1125594:	aa1603e1 	mov	x1, x22
 1125598:	d2800202 	mov	x2, #0x10                  	// #16
 112559c:	aa1803e0 	mov	x0, x24
 11255a0:	97ff777c 	bl	1103390 <memcpy>
	memcpy(dent.oid, oid, oidlen);
 11255a4:	aa1403e2 	mov	x2, x20
 11255a8:	aa1703e1 	mov	x1, x23
 11255ac:	aa1903e0 	mov	x0, x25
 11255b0:	97ff7778 	bl	1103390 <memcpy>
	dent.oidlen = oidlen;
	memcpy(dent.hash, dfh->hash, sizeof(dent.hash));
 11255b4:	91001261 	add	x1, x19, #0x4
 11255b8:	910333e0 	add	x0, sp, #0xcc
 11255bc:	d2800402 	mov	x2, #0x20                  	// #32
	dent.oidlen = oidlen;
 11255c0:	b900cbf4 	str	w20, [sp, #200]
	memcpy(dent.hash, dfh->hash, sizeof(dent.hash));
 11255c4:	97ff7773 	bl	1103390 <memcpy>
	dent.file_number = dfh->file_number;
 11255c8:	b9400260 	ldr	w0, [x19]
 11255cc:	b900efe0 	str	w0, [sp, #236]

	if (dfh->idx < 0) {
 11255d0:	b9402660 	ldr	w0, [x19, #36]
 11255d4:	36f802a0 	tbz	w0, #31, 1125628 <tee_fs_dirfile_rename+0xe4>
		struct tee_fs_dirfile_fileh dfh2;

		res = tee_fs_dirfile_find(dirh, uuid, oid, oidlen, &dfh2);
 11255d8:	910143f9 	add	x25, sp, #0x50
 11255dc:	aa1403e3 	mov	x3, x20
 11255e0:	aa1903e4 	mov	x4, x25
 11255e4:	aa1703e2 	mov	x2, x23
 11255e8:	aa1603e1 	mov	x1, x22
 11255ec:	aa1503e0 	mov	x0, x21
 11255f0:	97ffff66 	bl	1125388 <tee_fs_dirfile_find>
		if (res) {
 11255f4:	34000160 	cbz	w0, 1125620 <tee_fs_dirfile_rename+0xdc>
			if (res == TEE_ERROR_ITEM_NOT_FOUND)
 11255f8:	129ffee1 	mov	w1, #0xffff0008            	// #-65528
 11255fc:	6b01001f 	cmp	w0, w1
 1125600:	540001c1 	b.ne	1125638 <tee_fs_dirfile_rename+0xf4>  // b.any
				res = tee_fs_dirfile_find(dirh, uuid, NULL, 0,
 1125604:	aa1903e4 	mov	x4, x25
 1125608:	aa1603e1 	mov	x1, x22
 112560c:	aa1503e0 	mov	x0, x21
 1125610:	d2800003 	mov	x3, #0x0                   	// #0
 1125614:	d2800002 	mov	x2, #0x0                   	// #0
 1125618:	97ffff5c 	bl	1125388 <tee_fs_dirfile_find>
							  &dfh2);
			if (res)
 112561c:	350000e0 	cbnz	w0, 1125638 <tee_fs_dirfile_rename+0xf4>
				return res;
		}
		dfh->idx = dfh2.idx;
 1125620:	b94077e0 	ldr	w0, [sp, #116]
 1125624:	b9002660 	str	w0, [x19, #36]
	}

	return write_dent(dirh, dfh->idx, &dent);
 1125628:	b9802661 	ldrsw	x1, [x19, #36]
 112562c:	aa1803e2 	mov	x2, x24
 1125630:	aa1503e0 	mov	x0, x21
 1125634:	97fffe76 	bl	112500c <write_dent>
}
 1125638:	a94153f3 	ldp	x19, x20, [sp, #16]
 112563c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1125640:	a94363f7 	ldp	x23, x24, [sp, #48]
 1125644:	f94023f9 	ldr	x25, [sp, #64]
 1125648:	a8cf7bfd 	ldp	x29, x30, [sp], #240
 112564c:	d65f03c0 	ret
		return TEE_ERROR_BAD_PARAMETERS;
 1125650:	129fff20 	mov	w0, #0xffff0006            	// #-65530
 1125654:	17fffff9 	b	1125638 <tee_fs_dirfile_rename+0xf4>

0000000001125658 <tee_fs_dirfile_remove>:

TEE_Result tee_fs_dirfile_remove(struct tee_fs_dirfile_dirh *dirh,
				 const struct tee_fs_dirfile_fileh *dfh)
{
 1125658:	a9b47bfd 	stp	x29, x30, [sp, #-192]!
 112565c:	910003fd 	mov	x29, sp
 1125660:	a9025bf5 	stp	x21, x22, [sp, #32]
 1125664:	aa0103f6 	mov	x22, x1
	TEE_Result res;
	struct dirfile_entry dent;
	uint32_t file_number;

	res = read_dent(dirh, dfh->idx, &dent);
 1125668:	b9402421 	ldr	w1, [x1, #36]
{
 112566c:	f9001bf7 	str	x23, [sp, #48]
	res = read_dent(dirh, dfh->idx, &dent);
 1125670:	910123f7 	add	x23, sp, #0x48
 1125674:	aa1703e2 	mov	x2, x23
{
 1125678:	a90153f3 	stp	x19, x20, [sp, #16]
 112567c:	aa0003f4 	mov	x20, x0
	res = read_dent(dirh, dfh->idx, &dent);
 1125680:	97fffe44 	bl	1124f90 <read_dent>
 1125684:	2a0003f5 	mov	w21, w0
	if (res)
 1125688:	35000640 	cbnz	w0, 1125750 <tee_fs_dirfile_remove+0xf8>
		return res;

	if (!dent.oidlen)
 112568c:	b9409be0 	ldr	w0, [sp, #152]
 1125690:	34000600 	cbz	w0, 1125750 <tee_fs_dirfile_remove+0xf8>
		return TEE_SUCCESS;

	file_number = dent.file_number;
	assert(dfh->file_number == file_number);
 1125694:	b94002d3 	ldr	w19, [x22]
 1125698:	b940bfe0 	ldr	w0, [sp, #188]
 112569c:	6b00027f 	cmp	w19, w0
 11256a0:	54000140 	b.eq	11256c8 <tee_fs_dirfile_remove+0x70>  // b.none
 11256a4:	90000183 	adrp	x3, 1155000 <__func__.3826+0xa8>
 11256a8:	90000181 	adrp	x1, 1155000 <__func__.3826+0xa8>
 11256ac:	90000180 	adrp	x0, 1155000 <__func__.3826+0xa8>
 11256b0:	9137cc63 	add	x3, x3, #0xdf3
 11256b4:	91343821 	add	x1, x1, #0xd0e
 11256b8:	9135a400 	add	x0, x0, #0xd69
 11256bc:	528026e2 	mov	w2, #0x137                 	// #311
	assert(test_file(dirh, file_number));
 11256c0:	97ffb2fb 	bl	11122ac <_assert_log>
 11256c4:	97ffb30b 	bl	11122f0 <_assert_break>
 11256c8:	2a1303e1 	mov	w1, w19
 11256cc:	aa1403e0 	mov	x0, x20
 11256d0:	97fffe41 	bl	1124fd4 <test_file>
 11256d4:	72001c1f 	tst	w0, #0xff
 11256d8:	54000121 	b.ne	11256fc <tee_fs_dirfile_remove+0xa4>  // b.any
 11256dc:	90000183 	adrp	x3, 1155000 <__func__.3826+0xa8>
 11256e0:	90000181 	adrp	x1, 1155000 <__func__.3826+0xa8>
 11256e4:	90000180 	adrp	x0, 1155000 <__func__.3826+0xa8>
 11256e8:	9137cc63 	add	x3, x3, #0xdf3
 11256ec:	91343821 	add	x1, x1, #0xd0e
 11256f0:	91362400 	add	x0, x0, #0xd89
 11256f4:	52802702 	mov	w2, #0x138                 	// #312
 11256f8:	17fffff2 	b	11256c0 <tee_fs_dirfile_remove+0x68>

	memset(&dent, 0, sizeof(dent));
 11256fc:	d2800f02 	mov	x2, #0x78                  	// #120
 1125700:	52800001 	mov	w1, #0x0                   	// #0
 1125704:	aa1703e0 	mov	x0, x23
 1125708:	94007976 	bl	1143ce0 <memset>
	res = write_dent(dirh, dfh->idx, &dent);
 112570c:	b98026c1 	ldrsw	x1, [x22, #36]
 1125710:	aa1703e2 	mov	x2, x23
 1125714:	aa1403e0 	mov	x0, x20
 1125718:	97fffe3d 	bl	112500c <write_dent>
	if (!res)
 112571c:	35000260 	cbnz	w0, 1125768 <tee_fs_dirfile_remove+0x110>
	if (idx < dirh->nbits)
 1125720:	b9401280 	ldr	w0, [x20, #16]
 1125724:	6b00027f 	cmp	w19, w0
 1125728:	5400014a 	b.ge	1125750 <tee_fs_dirfile_remove+0xf8>  // b.tcont
		bit_clear(dirh->files, idx);
 112572c:	13037e61 	asr	w1, w19, #3
 1125730:	12000a73 	and	w19, w19, #0x7
 1125734:	f9400e82 	ldr	x2, [x20, #24]
 1125738:	93407c21 	sxtw	x1, w1
 112573c:	52800020 	mov	w0, #0x1                   	// #1
 1125740:	1ad32013 	lsl	w19, w0, w19
 1125744:	38616840 	ldrb	w0, [x2, x1]
 1125748:	0a330013 	bic	w19, w0, w19
 112574c:	38216853 	strb	w19, [x2, x1]
		clear_file(dirh, file_number);

	return res;
}
 1125750:	2a1503e0 	mov	w0, w21
 1125754:	a94153f3 	ldp	x19, x20, [sp, #16]
 1125758:	a9425bf5 	ldp	x21, x22, [sp, #32]
 112575c:	f9401bf7 	ldr	x23, [sp, #48]
 1125760:	a8cc7bfd 	ldp	x29, x30, [sp], #192
 1125764:	d65f03c0 	ret
 1125768:	2a0003f5 	mov	w21, w0
 112576c:	17fffff9 	b	1125750 <tee_fs_dirfile_remove+0xf8>

0000000001125770 <tee_fs_dirfile_update_hash>:

TEE_Result tee_fs_dirfile_update_hash(struct tee_fs_dirfile_dirh *dirh,
				      const struct tee_fs_dirfile_fileh *dfh)
{
 1125770:	a9b57bfd 	stp	x29, x30, [sp, #-176]!
 1125774:	910003fd 	mov	x29, sp
 1125778:	a90153f3 	stp	x19, x20, [sp, #16]
 112577c:	aa0103f3 	mov	x19, x1
	TEE_Result res;
	struct dirfile_entry dent;

	res = read_dent(dirh, dfh->idx, &dent);
 1125780:	b9402421 	ldr	w1, [x1, #36]
{
 1125784:	f90013f5 	str	x21, [sp, #32]
	res = read_dent(dirh, dfh->idx, &dent);
 1125788:	9100e3f5 	add	x21, sp, #0x38
{
 112578c:	aa0003f4 	mov	x20, x0
	res = read_dent(dirh, dfh->idx, &dent);
 1125790:	aa1503e2 	mov	x2, x21
 1125794:	97fffdff 	bl	1124f90 <read_dent>
	if (res)
 1125798:	35000440 	cbnz	w0, 1125820 <tee_fs_dirfile_update_hash+0xb0>
		return res;
	assert(dent.file_number == dfh->file_number);
 112579c:	b9400260 	ldr	w0, [x19]
 11257a0:	b940afe1 	ldr	w1, [sp, #172]
 11257a4:	6b00003f 	cmp	w1, w0
 11257a8:	54000140 	b.eq	11257d0 <tee_fs_dirfile_update_hash+0x60>  // b.none
 11257ac:	90000183 	adrp	x3, 1155000 <__func__.3826+0xa8>
 11257b0:	90000181 	adrp	x1, 1155000 <__func__.3826+0xa8>
 11257b4:	90000180 	adrp	x0, 1155000 <__func__.3826+0xa8>
 11257b8:	91382463 	add	x3, x3, #0xe09
 11257bc:	91343821 	add	x1, x1, #0xd0e
 11257c0:	91369800 	add	x0, x0, #0xda6
 11257c4:	52802962 	mov	w2, #0x14b                 	// #331
	assert(test_file(dirh, dent.file_number));
 11257c8:	97ffb2b9 	bl	11122ac <_assert_log>
 11257cc:	97ffb2c9 	bl	11122f0 <_assert_break>
 11257d0:	aa1403e0 	mov	x0, x20
 11257d4:	97fffe00 	bl	1124fd4 <test_file>
 11257d8:	72001c1f 	tst	w0, #0xff
 11257dc:	54000121 	b.ne	1125800 <tee_fs_dirfile_update_hash+0x90>  // b.any
 11257e0:	90000183 	adrp	x3, 1155000 <__func__.3826+0xa8>
 11257e4:	90000181 	adrp	x1, 1155000 <__func__.3826+0xa8>
 11257e8:	90000180 	adrp	x0, 1155000 <__func__.3826+0xa8>
 11257ec:	91382463 	add	x3, x3, #0xe09
 11257f0:	91343821 	add	x1, x1, #0xd0e
 11257f4:	9134fc00 	add	x0, x0, #0xd3f
 11257f8:	52802982 	mov	w2, #0x14c                 	// #332
 11257fc:	17fffff3 	b	11257c8 <tee_fs_dirfile_update_hash+0x58>

	memcpy(&dent.hash, dfh->hash, sizeof(dent.hash));
 1125800:	91001261 	add	x1, x19, #0x4
 1125804:	d2800402 	mov	x2, #0x20                  	// #32
 1125808:	910233e0 	add	x0, sp, #0x8c
 112580c:	97ff76e1 	bl	1103390 <memcpy>

	return write_dent(dirh, dfh->idx, &dent);
 1125810:	b9802661 	ldrsw	x1, [x19, #36]
 1125814:	aa1503e2 	mov	x2, x21
 1125818:	aa1403e0 	mov	x0, x20
 112581c:	97fffdfc 	bl	112500c <write_dent>
}
 1125820:	a94153f3 	ldp	x19, x20, [sp, #16]
 1125824:	f94013f5 	ldr	x21, [sp, #32]
 1125828:	a8cb7bfd 	ldp	x29, x30, [sp], #176
 112582c:	d65f03c0 	ret

0000000001125830 <tee_fs_dirfile_get_next>:

TEE_Result tee_fs_dirfile_get_next(struct tee_fs_dirfile_dirh *dirh,
				   const TEE_UUID *uuid, int *idx, void *oid,
				   size_t *oidlen)
{
 1125830:	a9b37bfd 	stp	x29, x30, [sp, #-208]!
 1125834:	910003fd 	mov	x29, sp
 1125838:	a90153f3 	stp	x19, x20, [sp, #16]
	TEE_Result res;
	int i = *idx + 1;
 112583c:	b9400053 	ldr	w19, [x2]
{
 1125840:	a9025bf5 	stp	x21, x22, [sp, #32]
 1125844:	aa0203f5 	mov	x21, x2
 1125848:	31000673 	adds	w19, w19, #0x1
 112584c:	aa0403f6 	mov	x22, x4
 1125850:	1a9f5273 	csel	w19, w19, wzr, pl  // pl = nfrst
 1125854:	a90363f7 	stp	x23, x24, [sp, #48]
 1125858:	aa0003f8 	mov	x24, x0
 112585c:	aa0303f7 	mov	x23, x3
 1125860:	a9046bf9 	stp	x25, x26, [sp, #64]
 1125864:	aa0103f9 	mov	x25, x1

	if (i < 0)
		i = 0;

	for (;; i++) {
		res = read_dent(dirh, i, &dent);
 1125868:	910163fa 	add	x26, sp, #0x58
 112586c:	aa1a03e2 	mov	x2, x26
 1125870:	2a1303e1 	mov	w1, w19
 1125874:	aa1803e0 	mov	x0, x24
 1125878:	97fffdc6 	bl	1124f90 <read_dent>
 112587c:	2a0003f4 	mov	w20, w0
		if (res)
 1125880:	35000280 	cbnz	w0, 11258d0 <tee_fs_dirfile_get_next+0xa0>
			return res;
		if (!memcmp(&dent.uuid, uuid, sizeof(dent.uuid)) &&
 1125884:	aa1903e1 	mov	x1, x25
 1125888:	aa1a03e0 	mov	x0, x26
 112588c:	d2800202 	mov	x2, #0x10                  	// #16
 1125890:	940078f0 	bl	1143c50 <memcmp>
 1125894:	35000060 	cbnz	w0, 11258a0 <tee_fs_dirfile_get_next+0x70>
		    dent.oidlen)
 1125898:	b940abe0 	ldr	w0, [sp, #168]
		if (!memcmp(&dent.uuid, uuid, sizeof(dent.uuid)) &&
 112589c:	35000060 	cbnz	w0, 11258a8 <tee_fs_dirfile_get_next+0x78>
	for (;; i++) {
 11258a0:	11000673 	add	w19, w19, #0x1
		res = read_dent(dirh, i, &dent);
 11258a4:	17fffff2 	b	112586c <tee_fs_dirfile_get_next+0x3c>
			break;
	}

	if (*oidlen < dent.oidlen)
 11258a8:	f94002c1 	ldr	x1, [x22]
 11258ac:	2a0003f8 	mov	w24, w0
 11258b0:	eb20403f 	cmp	x1, w0, uxtw
 11258b4:	540001c3 	b.cc	11258ec <tee_fs_dirfile_get_next+0xbc>  // b.lo, b.ul, b.last
		return TEE_ERROR_SHORT_BUFFER;

	memcpy(oid, dent.oid, dent.oidlen);
 11258b8:	aa1803e2 	mov	x2, x24
 11258bc:	91004341 	add	x1, x26, #0x10
 11258c0:	aa1703e0 	mov	x0, x23
 11258c4:	97ff76b3 	bl	1103390 <memcpy>
	*oidlen = dent.oidlen;
 11258c8:	f90002d8 	str	x24, [x22]
	*idx = i;
 11258cc:	b90002b3 	str	w19, [x21]

	return TEE_SUCCESS;
}
 11258d0:	2a1403e0 	mov	w0, w20
 11258d4:	a94153f3 	ldp	x19, x20, [sp, #16]
 11258d8:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11258dc:	a94363f7 	ldp	x23, x24, [sp, #48]
 11258e0:	a9446bf9 	ldp	x25, x26, [sp, #64]
 11258e4:	a8cd7bfd 	ldp	x29, x30, [sp], #208
 11258e8:	d65f03c0 	ret
		return TEE_ERROR_SHORT_BUFFER;
 11258ec:	129ffdf4 	mov	w20, #0xffff0010            	// #-65520
 11258f0:	17fffff8 	b	11258d0 <tee_fs_dirfile_get_next+0xa0>

00000000011258f4 <operation_commit>:
	struct tee_fs_dirent d;
};

static TEE_Result operation_commit(struct tee_fs_rpc_operation *op)
{
	return thread_rpc_cmd(op->id, op->num_params, op->params);
 11258f4:	91002002 	add	x2, x0, #0x8
 11258f8:	f9404401 	ldr	x1, [x0, #136]
 11258fc:	b9400000 	ldr	w0, [x0]
 1125900:	17ff8597 	b	1106f5c <thread_rpc_cmd>

0000000001125904 <operation_open_dfh>:
}

static TEE_Result operation_open_dfh(uint32_t id, unsigned int cmd,
				 const struct tee_fs_dirfile_fileh *dfh,
				 int *fd)
{
 1125904:	a9b37bfd 	stp	x29, x30, [sp, #-208]!
 1125908:	910003fd 	mov	x29, sp
 112590c:	a90153f3 	stp	x19, x20, [sp, #16]
 1125910:	2a0103f3 	mov	w19, w1
 1125914:	aa0303f4 	mov	x20, x3
	struct mobj *mobj;
	TEE_Result res;
	void *va;

	va = thread_rpc_shm_cache_alloc(THREAD_SHM_CACHE_USER_FS,
 1125918:	52800001 	mov	w1, #0x0                   	// #0
 112591c:	9100e3e3 	add	x3, sp, #0x38
{
 1125920:	a9025bf5 	stp	x21, x22, [sp, #32]
 1125924:	2a0003f5 	mov	w21, w0
 1125928:	aa0203f6 	mov	x22, x2
	va = thread_rpc_shm_cache_alloc(THREAD_SHM_CACHE_USER_FS,
 112592c:	52800020 	mov	w0, #0x1                   	// #1
 1125930:	d2802bc2 	mov	x2, #0x15e                 	// #350
 1125934:	97ff82ab 	bl	11063e0 <thread_rpc_shm_cache_alloc>
					THREAD_SHM_TYPE_APPLICATION,
					TEE_FS_NAME_MAX, &mobj);
	if (!va)
 1125938:	b4000440 	cbz	x0, 11259c0 <operation_open_dfh+0xbc>
		return TEE_ERROR_OUT_OF_MEMORY;

	res = tee_svc_storage_create_filename_dfh(va, TEE_FS_NAME_MAX, dfh);
 112593c:	aa1603e2 	mov	x2, x22
 1125940:	d2802bc1 	mov	x1, #0x15e                 	// #350
 1125944:	97fff0ba 	bl	1121c2c <tee_svc_storage_create_filename_dfh>
	if (res != TEE_SUCCESS)
 1125948:	35000340 	cbnz	w0, 11259b0 <operation_open_dfh+0xac>
		return res;

	struct tee_fs_rpc_operation op = {
 112594c:	910103e4 	add	x4, sp, #0x40
 1125950:	d2801102 	mov	x2, #0x88                  	// #136
 1125954:	aa0403e0 	mov	x0, x4
 1125958:	52800001 	mov	w1, #0x0                   	// #0
 112595c:	940078e1 	bl	1143ce0 <memset>
 1125960:	aa0003e4 	mov	x4, x0
 1125964:	52800020 	mov	w0, #0x1                   	// #1
 1125968:	b9004be0 	str	w0, [sp, #72]
 112596c:	52800080 	mov	w0, #0x4                   	// #4
 1125970:	b9006be0 	str	w0, [sp, #104]
 1125974:	d2802bc0 	mov	x0, #0x15e                 	// #350
 1125978:	f9003fe0 	str	x0, [sp, #120]
 112597c:	f9401fe0 	ldr	x0, [sp, #56]
 1125980:	f90043e0 	str	x0, [sp, #128]
 1125984:	52800040 	mov	w0, #0x2                   	// #2
 1125988:	b9008be0 	str	w0, [sp, #136]
 112598c:	d2800060 	mov	x0, #0x3                   	// #3
 1125990:	b90043f5 	str	w21, [sp, #64]
 1125994:	f9002bf3 	str	x19, [sp, #80]
 1125998:	f90067e0 	str	x0, [sp, #200]
			[0] = THREAD_PARAM_VALUE(IN, cmd, 0, 0),
			[1] = THREAD_PARAM_MEMREF(IN, mobj, 0, TEE_FS_NAME_MAX),
			[2] = THREAD_PARAM_VALUE(OUT, 0, 0, 0),
	} };

	res = operation_commit(&op);
 112599c:	aa0403e0 	mov	x0, x4
 11259a0:	97ffffd5 	bl	11258f4 <operation_commit>
	if (res == TEE_SUCCESS)
 11259a4:	35000060 	cbnz	w0, 11259b0 <operation_open_dfh+0xac>
		*fd = op.params[2].u.value.a;
 11259a8:	f9404be1 	ldr	x1, [sp, #144]
 11259ac:	b9000281 	str	w1, [x20]

	return res;
}
 11259b0:	a94153f3 	ldp	x19, x20, [sp, #16]
 11259b4:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11259b8:	a8cd7bfd 	ldp	x29, x30, [sp], #208
 11259bc:	d65f03c0 	ret
		return TEE_ERROR_OUT_OF_MEMORY;
 11259c0:	129ffe60 	mov	w0, #0xffff000c            	// #-65524
 11259c4:	17fffffb 	b	11259b0 <operation_open_dfh+0xac>

00000000011259c8 <tee_fs_rpc_open_dfh>:


TEE_Result tee_fs_rpc_open_dfh(uint32_t id,
			       const struct tee_fs_dirfile_fileh *dfh, int *fd)
{
	return operation_open_dfh(id, OPTEE_RPC_FS_OPEN, dfh, fd);
 11259c8:	aa0203e3 	mov	x3, x2
 11259cc:	aa0103e2 	mov	x2, x1
 11259d0:	52800001 	mov	w1, #0x0                   	// #0
 11259d4:	17ffffcc 	b	1125904 <operation_open_dfh>

00000000011259d8 <tee_fs_rpc_create_dfh>:

TEE_Result tee_fs_rpc_create_dfh(uint32_t id,
				 const struct tee_fs_dirfile_fileh *dfh,
				 int *fd)
{
	return operation_open_dfh(id, OPTEE_RPC_FS_CREATE, dfh, fd);
 11259d8:	aa0203e3 	mov	x3, x2
 11259dc:	aa0103e2 	mov	x2, x1
 11259e0:	52800021 	mov	w1, #0x1                   	// #1
 11259e4:	17ffffc8 	b	1125904 <operation_open_dfh>

00000000011259e8 <tee_fs_rpc_close>:
}

TEE_Result tee_fs_rpc_close(uint32_t id, int fd)
{
 11259e8:	a9b57bfd 	stp	x29, x30, [sp, #-176]!
	struct tee_fs_rpc_operation op = {
 11259ec:	d2801102 	mov	x2, #0x88                  	// #136
 11259f0:	910083e3 	add	x3, sp, #0x20
{
 11259f4:	910003fd 	mov	x29, sp
 11259f8:	a90153f3 	stp	x19, x20, [sp, #16]
 11259fc:	2a0003f4 	mov	w20, w0
 1125a00:	93407c33 	sxtw	x19, w1
	struct tee_fs_rpc_operation op = {
 1125a04:	aa0303e0 	mov	x0, x3
 1125a08:	52800001 	mov	w1, #0x0                   	// #0
 1125a0c:	940078b5 	bl	1143ce0 <memset>
 1125a10:	aa0003e3 	mov	x3, x0
 1125a14:	52800020 	mov	w0, #0x1                   	// #1
 1125a18:	b9002be0 	str	w0, [sp, #40]
 1125a1c:	d2800040 	mov	x0, #0x2                   	// #2
 1125a20:	f9001be0 	str	x0, [sp, #48]
 1125a24:	d2800020 	mov	x0, #0x1                   	// #1
 1125a28:	b90023f4 	str	w20, [sp, #32]
 1125a2c:	f9001ff3 	str	x19, [sp, #56]
 1125a30:	f90057e0 	str	x0, [sp, #168]
		.id = id, .num_params = 1, .params = {
			[0] = THREAD_PARAM_VALUE(IN, OPTEE_RPC_FS_CLOSE, fd, 0),
		},
	};

	return operation_commit(&op);
 1125a34:	aa0303e0 	mov	x0, x3
 1125a38:	97ffffaf 	bl	11258f4 <operation_commit>
}
 1125a3c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1125a40:	a8cb7bfd 	ldp	x29, x30, [sp], #176
 1125a44:	d65f03c0 	ret

0000000001125a48 <tee_fs_rpc_read_init>:
				size_t data_len, void **out_data)
{
	struct mobj *mobj;
	uint8_t *va;

	if (offset < 0)
 1125a48:	b7f80583 	tbnz	x3, #63, 1125af8 <tee_fs_rpc_read_init+0xb0>
{
 1125a4c:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
 1125a50:	910003fd 	mov	x29, sp
 1125a54:	a90153f3 	stp	x19, x20, [sp, #16]
 1125a58:	aa0003f3 	mov	x19, x0
 1125a5c:	93407c54 	sxtw	x20, w2
		return TEE_ERROR_BAD_PARAMETERS;

	va = thread_rpc_shm_cache_alloc(THREAD_SHM_CACHE_USER_FS,
 1125a60:	52800020 	mov	w0, #0x1                   	// #1
 1125a64:	aa0403e2 	mov	x2, x4
{
 1125a68:	a9025bf5 	stp	x21, x22, [sp, #32]
 1125a6c:	aa0403f6 	mov	x22, x4
 1125a70:	a90363f7 	stp	x23, x24, [sp, #48]
 1125a74:	aa0303f7 	mov	x23, x3
 1125a78:	aa0503f8 	mov	x24, x5
	va = thread_rpc_shm_cache_alloc(THREAD_SHM_CACHE_USER_FS,
 1125a7c:	910163e3 	add	x3, sp, #0x58
{
 1125a80:	a9046bf9 	stp	x25, x26, [sp, #64]
 1125a84:	2a0103f9 	mov	w25, w1
	va = thread_rpc_shm_cache_alloc(THREAD_SHM_CACHE_USER_FS,
 1125a88:	52800001 	mov	w1, #0x0                   	// #0
 1125a8c:	97ff8255 	bl	11063e0 <thread_rpc_shm_cache_alloc>
 1125a90:	aa0003f5 	mov	x21, x0
					THREAD_SHM_TYPE_APPLICATION,
					data_len, &mobj);
	if (!va)
 1125a94:	b4000360 	cbz	x0, 1125b00 <tee_fs_rpc_read_init+0xb8>
		return TEE_ERROR_OUT_OF_MEMORY;

	*op = (struct tee_fs_rpc_operation){
 1125a98:	aa1303e0 	mov	x0, x19
 1125a9c:	d2801202 	mov	x2, #0x90                  	// #144
 1125aa0:	52800001 	mov	w1, #0x0                   	// #0
 1125aa4:	f9402ffa 	ldr	x26, [sp, #88]
 1125aa8:	9400788e 	bl	1143ce0 <memset>
 1125aac:	52800020 	mov	w0, #0x1                   	// #1
 1125ab0:	b9000a60 	str	w0, [x19, #8]
 1125ab4:	d2800060 	mov	x0, #0x3                   	// #3
 1125ab8:	f9000a60 	str	x0, [x19, #16]
 1125abc:	528000a0 	mov	w0, #0x5                   	// #5
 1125ac0:	b9000279 	str	w25, [x19]
 1125ac4:	a901de74 	stp	x20, x23, [x19, #24]
 1125ac8:	b9002a60 	str	w0, [x19, #40]
 1125acc:	d2800040 	mov	x0, #0x2                   	// #2
 1125ad0:	a903ea76 	stp	x22, x26, [x19, #56]
 1125ad4:	f9004660 	str	x0, [x19, #136]
		},
	};

	*out_data = va;

	return TEE_SUCCESS;
 1125ad8:	52800000 	mov	w0, #0x0                   	// #0
	*out_data = va;
 1125adc:	f9000315 	str	x21, [x24]
}
 1125ae0:	a94153f3 	ldp	x19, x20, [sp, #16]
 1125ae4:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1125ae8:	a94363f7 	ldp	x23, x24, [sp, #48]
 1125aec:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1125af0:	a8c67bfd 	ldp	x29, x30, [sp], #96
 1125af4:	d65f03c0 	ret
		return TEE_ERROR_BAD_PARAMETERS;
 1125af8:	129fff20 	mov	w0, #0xffff0006            	// #-65530
}
 1125afc:	d65f03c0 	ret
		return TEE_ERROR_OUT_OF_MEMORY;
 1125b00:	129ffe60 	mov	w0, #0xffff000c            	// #-65524
 1125b04:	17fffff7 	b	1125ae0 <tee_fs_rpc_read_init+0x98>

0000000001125b08 <tee_fs_rpc_read_final>:

TEE_Result tee_fs_rpc_read_final(struct tee_fs_rpc_operation *op,
				 size_t *data_len)
{
 1125b08:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1125b0c:	910003fd 	mov	x29, sp
 1125b10:	a90153f3 	stp	x19, x20, [sp, #16]
 1125b14:	aa0003f4 	mov	x20, x0
 1125b18:	aa0103f3 	mov	x19, x1
	TEE_Result res = operation_commit(op);
 1125b1c:	97ffff76 	bl	11258f4 <operation_commit>

	if (res == TEE_SUCCESS)
 1125b20:	35000060 	cbnz	w0, 1125b2c <tee_fs_rpc_read_final+0x24>
		*data_len = op->params[1].u.memref.size;
 1125b24:	f9401e81 	ldr	x1, [x20, #56]
 1125b28:	f9000261 	str	x1, [x19]
	return res;
}
 1125b2c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1125b30:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1125b34:	d65f03c0 	ret

0000000001125b38 <tee_fs_rpc_write_init>:
				 size_t data_len, void **data)
{
	struct mobj *mobj;
	uint8_t *va;

	if (offset < 0)
 1125b38:	b7f80563 	tbnz	x3, #63, 1125be4 <tee_fs_rpc_write_init+0xac>
{
 1125b3c:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
 1125b40:	910003fd 	mov	x29, sp
 1125b44:	a90153f3 	stp	x19, x20, [sp, #16]
 1125b48:	aa0003f3 	mov	x19, x0
 1125b4c:	93407c54 	sxtw	x20, w2
		return TEE_ERROR_BAD_PARAMETERS;

	va = thread_rpc_shm_cache_alloc(THREAD_SHM_CACHE_USER_FS,
 1125b50:	52800020 	mov	w0, #0x1                   	// #1
 1125b54:	aa0403e2 	mov	x2, x4
{
 1125b58:	a9025bf5 	stp	x21, x22, [sp, #32]
 1125b5c:	aa0403f6 	mov	x22, x4
 1125b60:	a90363f7 	stp	x23, x24, [sp, #48]
 1125b64:	aa0303f7 	mov	x23, x3
 1125b68:	aa0503f8 	mov	x24, x5
	va = thread_rpc_shm_cache_alloc(THREAD_SHM_CACHE_USER_FS,
 1125b6c:	910163e3 	add	x3, sp, #0x58
{
 1125b70:	a9046bf9 	stp	x25, x26, [sp, #64]
 1125b74:	2a0103f9 	mov	w25, w1
	va = thread_rpc_shm_cache_alloc(THREAD_SHM_CACHE_USER_FS,
 1125b78:	52800001 	mov	w1, #0x0                   	// #0
 1125b7c:	97ff8219 	bl	11063e0 <thread_rpc_shm_cache_alloc>
 1125b80:	aa0003f5 	mov	x21, x0
					THREAD_SHM_TYPE_APPLICATION,
					data_len, &mobj);
	if (!va)
 1125b84:	b4000340 	cbz	x0, 1125bec <tee_fs_rpc_write_init+0xb4>
		return TEE_ERROR_OUT_OF_MEMORY;

	*op = (struct tee_fs_rpc_operation){
 1125b88:	aa1303e0 	mov	x0, x19
 1125b8c:	d2801202 	mov	x2, #0x90                  	// #144
 1125b90:	52800001 	mov	w1, #0x0                   	// #0
 1125b94:	f9402ffa 	ldr	x26, [sp, #88]
 1125b98:	94007852 	bl	1143ce0 <memset>
 1125b9c:	52800020 	mov	w0, #0x1                   	// #1
 1125ba0:	b9000a60 	str	w0, [x19, #8]
 1125ba4:	d2800080 	mov	x0, #0x4                   	// #4
 1125ba8:	b9000279 	str	w25, [x19]
 1125bac:	f9000a60 	str	x0, [x19, #16]
 1125bb0:	a901de74 	stp	x20, x23, [x19, #24]
 1125bb4:	b9002a60 	str	w0, [x19, #40]
 1125bb8:	d2800040 	mov	x0, #0x2                   	// #2
 1125bbc:	a903ea76 	stp	x22, x26, [x19, #56]
 1125bc0:	f9004660 	str	x0, [x19, #136]
		},
	};

	*data = va;

	return TEE_SUCCESS;
 1125bc4:	52800000 	mov	w0, #0x0                   	// #0
	*data = va;
 1125bc8:	f9000315 	str	x21, [x24]
}
 1125bcc:	a94153f3 	ldp	x19, x20, [sp, #16]
 1125bd0:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1125bd4:	a94363f7 	ldp	x23, x24, [sp, #48]
 1125bd8:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1125bdc:	a8c67bfd 	ldp	x29, x30, [sp], #96
 1125be0:	d65f03c0 	ret
		return TEE_ERROR_BAD_PARAMETERS;
 1125be4:	129fff20 	mov	w0, #0xffff0006            	// #-65530
}
 1125be8:	d65f03c0 	ret
		return TEE_ERROR_OUT_OF_MEMORY;
 1125bec:	129ffe60 	mov	w0, #0xffff000c            	// #-65524
 1125bf0:	17fffff7 	b	1125bcc <tee_fs_rpc_write_init+0x94>

0000000001125bf4 <tee_fs_rpc_write_final>:

TEE_Result tee_fs_rpc_write_final(struct tee_fs_rpc_operation *op)
{
	return operation_commit(op);
 1125bf4:	17ffff40 	b	11258f4 <operation_commit>

0000000001125bf8 <tee_fs_rpc_truncate>:
}

TEE_Result tee_fs_rpc_truncate(uint32_t id, int fd, size_t len)
{
 1125bf8:	a9b47bfd 	stp	x29, x30, [sp, #-192]!
	struct tee_fs_rpc_operation op = {
 1125bfc:	9100c3e3 	add	x3, sp, #0x30
{
 1125c00:	910003fd 	mov	x29, sp
 1125c04:	a90153f3 	stp	x19, x20, [sp, #16]
 1125c08:	93407c33 	sxtw	x19, w1
 1125c0c:	aa0203f4 	mov	x20, x2
	struct tee_fs_rpc_operation op = {
 1125c10:	52800001 	mov	w1, #0x0                   	// #0
 1125c14:	d2801102 	mov	x2, #0x88                  	// #136
{
 1125c18:	f90013f5 	str	x21, [sp, #32]
 1125c1c:	2a0003f5 	mov	w21, w0
	struct tee_fs_rpc_operation op = {
 1125c20:	aa0303e0 	mov	x0, x3
 1125c24:	9400782f 	bl	1143ce0 <memset>
 1125c28:	aa0003e3 	mov	x3, x0
 1125c2c:	52800020 	mov	w0, #0x1                   	// #1
 1125c30:	b9003be0 	str	w0, [sp, #56]
 1125c34:	d28000a0 	mov	x0, #0x5                   	// #5
 1125c38:	f90023e0 	str	x0, [sp, #64]
 1125c3c:	d2800020 	mov	x0, #0x1                   	// #1
 1125c40:	b90033f5 	str	w21, [sp, #48]
 1125c44:	a904d3f3 	stp	x19, x20, [sp, #72]
 1125c48:	f9005fe0 	str	x0, [sp, #184]
			[0] = THREAD_PARAM_VALUE(IN, OPTEE_RPC_FS_TRUNCATE, fd,
						 len),
		}
	};

	return operation_commit(&op);
 1125c4c:	aa0303e0 	mov	x0, x3
 1125c50:	97ffff29 	bl	11258f4 <operation_commit>
}
 1125c54:	a94153f3 	ldp	x19, x20, [sp, #16]
 1125c58:	f94013f5 	ldr	x21, [sp, #32]
 1125c5c:	a8cc7bfd 	ldp	x29, x30, [sp], #192
 1125c60:	d65f03c0 	ret

0000000001125c64 <tee_fs_rpc_remove_dfh>:

TEE_Result tee_fs_rpc_remove_dfh(uint32_t id,
				 const struct tee_fs_dirfile_fileh *dfh)
{
 1125c64:	a9b47bfd 	stp	x29, x30, [sp, #-192]!
	TEE_Result res;
	struct mobj *mobj;
	void *va;

	va = thread_rpc_shm_cache_alloc(THREAD_SHM_CACHE_USER_FS,
 1125c68:	d2802bc2 	mov	x2, #0x15e                 	// #350
{
 1125c6c:	910003fd 	mov	x29, sp
	va = thread_rpc_shm_cache_alloc(THREAD_SHM_CACHE_USER_FS,
 1125c70:	9100a3e3 	add	x3, sp, #0x28
{
 1125c74:	a90153f3 	stp	x19, x20, [sp, #16]
 1125c78:	2a0003f3 	mov	w19, w0
 1125c7c:	aa0103f4 	mov	x20, x1
	va = thread_rpc_shm_cache_alloc(THREAD_SHM_CACHE_USER_FS,
 1125c80:	52800020 	mov	w0, #0x1                   	// #1
 1125c84:	52800001 	mov	w1, #0x0                   	// #0
 1125c88:	97ff81d6 	bl	11063e0 <thread_rpc_shm_cache_alloc>
					THREAD_SHM_TYPE_APPLICATION,
					TEE_FS_NAME_MAX, &mobj);
	if (!va)
 1125c8c:	b40003a0 	cbz	x0, 1125d00 <tee_fs_rpc_remove_dfh+0x9c>
		return TEE_ERROR_OUT_OF_MEMORY;


	res = tee_svc_storage_create_filename_dfh(va, TEE_FS_NAME_MAX, dfh);
 1125c90:	aa1403e2 	mov	x2, x20
 1125c94:	d2802bc1 	mov	x1, #0x15e                 	// #350
 1125c98:	97ffefe5 	bl	1121c2c <tee_svc_storage_create_filename_dfh>
	if (res != TEE_SUCCESS)
 1125c9c:	350002c0 	cbnz	w0, 1125cf4 <tee_fs_rpc_remove_dfh+0x90>
		return res;

	struct tee_fs_rpc_operation op = {
 1125ca0:	9100c3e3 	add	x3, sp, #0x30
 1125ca4:	d2801102 	mov	x2, #0x88                  	// #136
 1125ca8:	aa0303e0 	mov	x0, x3
 1125cac:	52800001 	mov	w1, #0x0                   	// #0
 1125cb0:	9400780c 	bl	1143ce0 <memset>
 1125cb4:	aa0003e3 	mov	x3, x0
 1125cb8:	52800020 	mov	w0, #0x1                   	// #1
 1125cbc:	b9003be0 	str	w0, [sp, #56]
 1125cc0:	d28000c0 	mov	x0, #0x6                   	// #6
 1125cc4:	f90023e0 	str	x0, [sp, #64]
 1125cc8:	52800080 	mov	w0, #0x4                   	// #4
 1125ccc:	b9005be0 	str	w0, [sp, #88]
 1125cd0:	d2802bc0 	mov	x0, #0x15e                 	// #350
 1125cd4:	f90037e0 	str	x0, [sp, #104]
 1125cd8:	f94017e0 	ldr	x0, [sp, #40]
 1125cdc:	f9003be0 	str	x0, [sp, #112]
 1125ce0:	d2800040 	mov	x0, #0x2                   	// #2
 1125ce4:	b90033f3 	str	w19, [sp, #48]
 1125ce8:	f9005fe0 	str	x0, [sp, #184]
			[0] = THREAD_PARAM_VALUE(IN, OPTEE_RPC_FS_REMOVE, 0, 0),
			[1] = THREAD_PARAM_MEMREF(IN, mobj, 0, TEE_FS_NAME_MAX),
		}
	};

	return operation_commit(&op);
 1125cec:	aa0303e0 	mov	x0, x3
 1125cf0:	97ffff01 	bl	11258f4 <operation_commit>
}
 1125cf4:	a94153f3 	ldp	x19, x20, [sp, #16]
 1125cf8:	a8cc7bfd 	ldp	x29, x30, [sp], #192
 1125cfc:	d65f03c0 	ret
		return TEE_ERROR_OUT_OF_MEMORY;
 1125d00:	129ffe60 	mov	w0, #0xffff000c            	// #-65524
 1125d04:	17fffffc 	b	1125cf4 <tee_fs_rpc_remove_dfh+0x90>

0000000001125d08 <tee_fs_init_key_manager>:
{
	return crypto_rng_read(key, len);
}

static TEE_Result tee_fs_init_key_manager(void)
{
 1125d08:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	TEE_Result res = TEE_SUCCESS;

	COMPILE_TIME_ASSERT(TEE_FS_KM_SSK_SIZE <= HUK_SUBKEY_MAX_LEN);

	res = huk_subkey_derive(HUK_SUBKEY_SSK, NULL, 0,
 1125d0c:	d2800404 	mov	x4, #0x20                  	// #32
 1125d10:	d2800002 	mov	x2, #0x0                   	// #0
{
 1125d14:	910003fd 	mov	x29, sp
 1125d18:	a90153f3 	stp	x19, x20, [sp, #16]
	res = huk_subkey_derive(HUK_SUBKEY_SSK, NULL, 0,
 1125d1c:	d2800001 	mov	x1, #0x0                   	// #0
 1125d20:	52800020 	mov	w0, #0x1                   	// #1
{
 1125d24:	f90013f5 	str	x21, [sp, #32]
	res = huk_subkey_derive(HUK_SUBKEY_SSK, NULL, 0,
 1125d28:	f0000215 	adrp	x21, 1168000 <data.5093+0x9e28>
 1125d2c:	912a66b4 	add	x20, x21, #0xa99
 1125d30:	91000683 	add	x3, x20, #0x1
 1125d34:	97ffbb40 	bl	1114a34 <huk_subkey_derive>
 1125d38:	2a0003f3 	mov	w19, w0
				tee_fs_ssk.key, sizeof(tee_fs_ssk.key));
	if (res == TEE_SUCCESS)
 1125d3c:	35000100 	cbnz	w0, 1125d5c <tee_fs_init_key_manager+0x54>
		tee_fs_ssk.is_init = 1;
 1125d40:	52800020 	mov	w0, #0x1                   	// #1
 1125d44:	392a66a0 	strb	w0, [x21, #2713]
	else
		memzero_explicit(&tee_fs_ssk, sizeof(tee_fs_ssk));

	return res;
}
 1125d48:	2a1303e0 	mov	w0, w19
 1125d4c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1125d50:	f94013f5 	ldr	x21, [sp, #32]
 1125d54:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1125d58:	d65f03c0 	ret
		memzero_explicit(&tee_fs_ssk, sizeof(tee_fs_ssk));
 1125d5c:	aa1403e0 	mov	x0, x20
 1125d60:	d2800421 	mov	x1, #0x21                  	// #33
 1125d64:	94007ca7 	bl	1145000 <memzero_explicit>
	return res;
 1125d68:	17fffff8 	b	1125d48 <tee_fs_init_key_manager+0x40>

0000000001125d6c <do_hmac.constprop.0>:
static TEE_Result do_hmac(void *out_key, size_t out_key_size,
 1125d6c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 1125d70:	910003fd 	mov	x29, sp
 1125d74:	a90153f3 	stp	x19, x20, [sp, #16]
 1125d78:	a9025bf5 	stp	x21, x22, [sp, #32]
	void *ctx = NULL;
 1125d7c:	f9001fff 	str	xzr, [sp, #56]
	if (!out_key || !in_key || !message)
 1125d80:	b4000481 	cbz	x1, 1125e10 <do_hmac.constprop.0+0xa4>
 1125d84:	aa0103f4 	mov	x20, x1
	res = crypto_mac_alloc_ctx(&ctx, TEE_FS_KM_HMAC_ALG);
 1125d88:	52800081 	mov	w1, #0x4                   	// #4
 1125d8c:	aa0003f5 	mov	x21, x0
 1125d90:	aa0203f6 	mov	x22, x2
 1125d94:	9100e3e0 	add	x0, sp, #0x38
 1125d98:	72a60001 	movk	w1, #0x3000, lsl #16
 1125d9c:	97ff9e6a 	bl	110d744 <crypto_mac_alloc_ctx>
 1125da0:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 1125da4:	350002c0 	cbnz	w0, 1125dfc <do_hmac.constprop.0+0x90>
	res = crypto_mac_init(ctx, in_key, in_key_size);
 1125da8:	f9401fe0 	ldr	x0, [sp, #56]
 1125dac:	f0000201 	adrp	x1, 1168000 <data.5093+0x9e28>
 1125db0:	912a6421 	add	x1, x1, #0xa99
 1125db4:	d2800402 	mov	x2, #0x20                  	// #32
 1125db8:	91000421 	add	x1, x1, #0x1
 1125dbc:	97ff9eda 	bl	110d924 <crypto_mac_init>
 1125dc0:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 1125dc4:	35000180 	cbnz	w0, 1125df4 <do_hmac.constprop.0+0x88>
	res = crypto_mac_update(ctx, message, message_size);
 1125dc8:	f9401fe0 	ldr	x0, [sp, #56]
 1125dcc:	aa1603e2 	mov	x2, x22
 1125dd0:	aa1403e1 	mov	x1, x20
 1125dd4:	97ff9ee5 	bl	110d968 <crypto_mac_update>
 1125dd8:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 1125ddc:	350000c0 	cbnz	w0, 1125df4 <do_hmac.constprop.0+0x88>
	res = crypto_mac_final(ctx, out_key, out_key_size);
 1125de0:	f9401fe0 	ldr	x0, [sp, #56]
 1125de4:	aa1503e1 	mov	x1, x21
 1125de8:	d2800402 	mov	x2, #0x20                  	// #32
 1125dec:	97ff9ef3 	bl	110d9b8 <crypto_mac_final>
 1125df0:	2a0003f3 	mov	w19, w0
	crypto_mac_free_ctx(ctx);
 1125df4:	f9401fe0 	ldr	x0, [sp, #56]
 1125df8:	97ff9eb1 	bl	110d8bc <crypto_mac_free_ctx>
}
 1125dfc:	2a1303e0 	mov	w0, w19
 1125e00:	a94153f3 	ldp	x19, x20, [sp, #16]
 1125e04:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1125e08:	a8c47bfd 	ldp	x29, x30, [sp], #64
 1125e0c:	d65f03c0 	ret
		return TEE_ERROR_BAD_PARAMETERS;
 1125e10:	129fff33 	mov	w19, #0xffff0006            	// #-65530
 1125e14:	17fffffa 	b	1125dfc <do_hmac.constprop.0+0x90>

0000000001125e18 <tee_fs_fek_crypt>:
{
 1125e18:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
	if (!in_key || !out_key)
 1125e1c:	f100005f 	cmp	x2, #0x0
 1125e20:	fa401884 	ccmp	x4, #0x0, #0x4, ne  // ne = any
{
 1125e24:	910003fd 	mov	x29, sp
 1125e28:	a90153f3 	stp	x19, x20, [sp, #16]
 1125e2c:	a9025bf5 	stp	x21, x22, [sp, #32]
 1125e30:	a90363f7 	stp	x23, x24, [sp, #48]
 1125e34:	2a0103f7 	mov	w23, w1
	uint8_t dst_key[size];
 1125e38:	91003c61 	add	x1, x3, #0xf
	void *ctx = NULL;
 1125e3c:	f90027bf 	str	xzr, [x29, #72]
	uint8_t dst_key[size];
 1125e40:	927cec21 	and	x1, x1, #0xfffffffffffffff0
{
 1125e44:	aa0203f8 	mov	x24, x2
	uint8_t dst_key[size];
 1125e48:	cb2163ff 	sub	sp, sp, x1
	if (!in_key || !out_key)
 1125e4c:	54000860 	b.eq	1125f58 <tee_fs_fek_crypt+0x140>  // b.none
 1125e50:	aa0303e2 	mov	x2, x3
	if (size != TEE_FS_KM_FEK_SIZE)
 1125e54:	f100407f 	cmp	x3, #0x10
 1125e58:	54000801 	b.ne	1125f58 <tee_fs_fek_crypt+0x140>  // b.any
	if (tee_fs_ssk.is_init == 0)
 1125e5c:	f0000201 	adrp	x1, 1168000 <data.5093+0x9e28>
 1125e60:	396a6421 	ldrb	w1, [x1, #2713]
 1125e64:	340007e1 	cbz	w1, 1125f60 <tee_fs_fek_crypt+0x148>
 1125e68:	aa0403f6 	mov	x22, x4
 1125e6c:	910003f4 	mov	x20, sp
	if (uuid) {
 1125e70:	910143b5 	add	x21, x29, #0x50
 1125e74:	b40006a0 	cbz	x0, 1125f48 <tee_fs_fek_crypt+0x130>
		res = do_hmac(tsk, sizeof(tsk), tee_fs_ssk.key,
 1125e78:	aa0003e1 	mov	x1, x0
		res = do_hmac(tsk, sizeof(tsk), tee_fs_ssk.key,
 1125e7c:	aa1503e0 	mov	x0, x21
 1125e80:	97ffffbb 	bl	1125d6c <do_hmac.constprop.0>
 1125e84:	2a0003f3 	mov	w19, w0
		if (res != TEE_SUCCESS)
 1125e88:	35000520 	cbnz	w0, 1125f2c <tee_fs_fek_crypt+0x114>
	res = crypto_cipher_alloc_ctx(&ctx, TEE_FS_KM_ENC_FEK_ALG);
 1125e8c:	52800201 	mov	w1, #0x10                  	// #16
 1125e90:	910123a0 	add	x0, x29, #0x48
 1125e94:	72a20001 	movk	w1, #0x1000, lsl #16
 1125e98:	97ff9d45 	bl	110d3ac <crypto_cipher_alloc_ctx>
 1125e9c:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 1125ea0:	35000460 	cbnz	w0, 1125f2c <tee_fs_fek_crypt+0x114>
	res = crypto_cipher_init(ctx, mode, tsk, sizeof(tsk), NULL, 0, NULL, 0);
 1125ea4:	f94027a0 	ldr	x0, [x29, #72]
 1125ea8:	aa1503e2 	mov	x2, x21
 1125eac:	2a1703e1 	mov	w1, w23
 1125eb0:	d2800007 	mov	x7, #0x0                   	// #0
 1125eb4:	d2800006 	mov	x6, #0x0                   	// #0
 1125eb8:	d2800005 	mov	x5, #0x0                   	// #0
 1125ebc:	d2800004 	mov	x4, #0x0                   	// #0
 1125ec0:	d2800403 	mov	x3, #0x20                  	// #32
 1125ec4:	97ff9db2 	bl	110d58c <crypto_cipher_init>
 1125ec8:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 1125ecc:	35000200 	cbnz	w0, 1125f0c <tee_fs_fek_crypt+0xf4>
	res = crypto_cipher_update(ctx, mode, true, in_key, size, dst_key);
 1125ed0:	f94027a0 	ldr	x0, [x29, #72]
 1125ed4:	aa1403e5 	mov	x5, x20
 1125ed8:	aa1803e3 	mov	x3, x24
 1125edc:	2a1703e1 	mov	w1, w23
 1125ee0:	d2800204 	mov	x4, #0x10                  	// #16
 1125ee4:	52800022 	mov	w2, #0x1                   	// #1
 1125ee8:	97ff9dcc 	bl	110d618 <crypto_cipher_update>
 1125eec:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 1125ef0:	350000e0 	cbnz	w0, 1125f0c <tee_fs_fek_crypt+0xf4>
	crypto_cipher_final(ctx);
 1125ef4:	f94027a0 	ldr	x0, [x29, #72]
 1125ef8:	97ff9ddf 	bl	110d674 <crypto_cipher_final>
	memcpy(out_key, dst_key, sizeof(dst_key));
 1125efc:	aa1403e1 	mov	x1, x20
 1125f00:	aa1603e0 	mov	x0, x22
 1125f04:	d2800202 	mov	x2, #0x10                  	// #16
 1125f08:	97ff7522 	bl	1103390 <memcpy>
	crypto_cipher_free_ctx(ctx);
 1125f0c:	f94027a0 	ldr	x0, [x29, #72]
 1125f10:	97ff9d85 	bl	110d524 <crypto_cipher_free_ctx>
	memzero_explicit(tsk, sizeof(tsk));
 1125f14:	aa1503e0 	mov	x0, x21
 1125f18:	d2800401 	mov	x1, #0x20                  	// #32
 1125f1c:	94007c39 	bl	1145000 <memzero_explicit>
	memzero_explicit(dst_key, sizeof(dst_key));
 1125f20:	aa1403e0 	mov	x0, x20
 1125f24:	d2800201 	mov	x1, #0x10                  	// #16
 1125f28:	94007c36 	bl	1145000 <memzero_explicit>
}
 1125f2c:	910003bf 	mov	sp, x29
 1125f30:	2a1303e0 	mov	w0, w19
 1125f34:	a94153f3 	ldp	x19, x20, [sp, #16]
 1125f38:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1125f3c:	a94363f7 	ldp	x23, x24, [sp, #48]
 1125f40:	a8c77bfd 	ldp	x29, x30, [sp], #112
 1125f44:	d65f03c0 	ret
		res = do_hmac(tsk, sizeof(tsk), tee_fs_ssk.key,
 1125f48:	910103a1 	add	x1, x29, #0x40
 1125f4c:	d2800022 	mov	x2, #0x1                   	// #1
		uint8_t dummy[1] = { 0 };
 1125f50:	390103bf 	strb	wzr, [x29, #64]
		res = do_hmac(tsk, sizeof(tsk), tee_fs_ssk.key,
 1125f54:	17ffffca 	b	1125e7c <tee_fs_fek_crypt+0x64>
		return TEE_ERROR_BAD_PARAMETERS;
 1125f58:	129fff33 	mov	w19, #0xffff0006            	// #-65530
 1125f5c:	17fffff4 	b	1125f2c <tee_fs_fek_crypt+0x114>
		return TEE_ERROR_GENERIC;
 1125f60:	52bffff3 	mov	w19, #0xffff0000            	// #-65536
 1125f64:	17fffff2 	b	1125f2c <tee_fs_fek_crypt+0x114>

0000000001125f68 <tee_obj_add>:
#include <tee/tee_svc_storage.h>
#include <trace.h>

void tee_obj_add(struct user_ta_ctx *utc, struct tee_obj *o)
{
	TAILQ_INSERT_TAIL(&utc->objects, o, link);
 1125f68:	f9401402 	ldr	x2, [x0, #40]
 1125f6c:	a900083f 	stp	xzr, x2, [x1]
 1125f70:	f9000041 	str	x1, [x2]
 1125f74:	f9001401 	str	x1, [x0, #40]
}
 1125f78:	d65f03c0 	ret

0000000001125f7c <tee_obj_get>:
TEE_Result tee_obj_get(struct user_ta_ctx *utc, vaddr_t obj_id,
		       struct tee_obj **obj)
{
	struct tee_obj *o;

	TAILQ_FOREACH(o, &utc->objects, link) {
 1125f7c:	f9401000 	ldr	x0, [x0, #32]
 1125f80:	b5000060 	cbnz	x0, 1125f8c <tee_obj_get+0x10>
		if (obj_id == (vaddr_t)o) {
			*obj = o;
			return TEE_SUCCESS;
		}
	}
	return TEE_ERROR_BAD_STATE;
 1125f84:	129fff00 	mov	w0, #0xffff0007            	// #-65529
 1125f88:	14000005 	b	1125f9c <tee_obj_get+0x20>
		if (obj_id == (vaddr_t)o) {
 1125f8c:	eb01001f 	cmp	x0, x1
 1125f90:	54000081 	b.ne	1125fa0 <tee_obj_get+0x24>  // b.any
			*obj = o;
 1125f94:	f9000040 	str	x0, [x2]
			return TEE_SUCCESS;
 1125f98:	52800000 	mov	w0, #0x0                   	// #0
}
 1125f9c:	d65f03c0 	ret
	TAILQ_FOREACH(o, &utc->objects, link) {
 1125fa0:	f9400000 	ldr	x0, [x0]
 1125fa4:	17fffff7 	b	1125f80 <tee_obj_get+0x4>

0000000001125fa8 <tee_obj_alloc>:
	return res;
}

struct tee_obj *tee_obj_alloc(void)
{
	return calloc(1, sizeof(struct tee_obj));
 1125fa8:	d2800b01 	mov	x1, #0x58                  	// #88
 1125fac:	d2800020 	mov	x0, #0x1                   	// #1
 1125fb0:	14007548 	b	11434d0 <calloc>

0000000001125fb4 <tee_obj_free>:
}

void tee_obj_free(struct tee_obj *o)
{
	if (o) {
 1125fb4:	b4000180 	cbz	x0, 1125fe4 <tee_obj_free+0x30>
{
 1125fb8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1125fbc:	910003fd 	mov	x29, sp
 1125fc0:	f9000bf3 	str	x19, [sp, #16]
 1125fc4:	aa0003f3 	mov	x19, x0
		tee_obj_attr_free(o);
 1125fc8:	97ffe215 	bl	111e81c <tee_obj_attr_free>
		free(o->attr);
 1125fcc:	f9401e60 	ldr	x0, [x19, #56]
 1125fd0:	94007584 	bl	11435e0 <free>
		free(o);
 1125fd4:	aa1303e0 	mov	x0, x19
	}
}
 1125fd8:	f9400bf3 	ldr	x19, [sp, #16]
 1125fdc:	a8c27bfd 	ldp	x29, x30, [sp], #32
		free(o);
 1125fe0:	14007580 	b	11435e0 <free>
 1125fe4:	d65f03c0 	ret

0000000001125fe8 <tee_obj_close>:
{
 1125fe8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1125fec:	910003fd 	mov	x29, sp
 1125ff0:	f9000bf3 	str	x19, [sp, #16]
 1125ff4:	aa0103f3 	mov	x19, x1
	TAILQ_REMOVE(&utc->objects, o, link);
 1125ff8:	f9400021 	ldr	x1, [x1]
 1125ffc:	f9400662 	ldr	x2, [x19, #8]
 1126000:	b4000221 	cbz	x1, 1126044 <tee_obj_close+0x5c>
 1126004:	f9000422 	str	x2, [x1, #8]
 1126008:	f9400660 	ldr	x0, [x19, #8]
 112600c:	f9000001 	str	x1, [x0]
	if ((o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT)) {
 1126010:	b9402a60 	ldr	w0, [x19, #40]
 1126014:	36800100 	tbz	w0, #16, 1126034 <tee_obj_close+0x4c>
		o->pobj->fops->close(&o->fh);
 1126018:	f9402660 	ldr	x0, [x19, #72]
 112601c:	f9402000 	ldr	x0, [x0, #64]
 1126020:	f9400801 	ldr	x1, [x0, #16]
 1126024:	91014260 	add	x0, x19, #0x50
 1126028:	d63f0020 	blr	x1
		tee_pobj_release(o->pobj);
 112602c:	f9402660 	ldr	x0, [x19, #72]
 1126030:	94000097 	bl	112628c <tee_pobj_release>
	tee_obj_free(o);
 1126034:	aa1303e0 	mov	x0, x19
}
 1126038:	f9400bf3 	ldr	x19, [sp, #16]
 112603c:	a8c27bfd 	ldp	x29, x30, [sp], #32
	tee_obj_free(o);
 1126040:	17ffffdd 	b	1125fb4 <tee_obj_free>
	TAILQ_REMOVE(&utc->objects, o, link);
 1126044:	f9001402 	str	x2, [x0, #40]
 1126048:	17fffff0 	b	1126008 <tee_obj_close+0x20>

000000000112604c <tee_obj_close_all>:
{
 112604c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1126050:	910003fd 	mov	x29, sp
 1126054:	f9000bf3 	str	x19, [sp, #16]
 1126058:	aa0003f3 	mov	x19, x0
	while (!TAILQ_EMPTY(objects))
 112605c:	f9401261 	ldr	x1, [x19, #32]
 1126060:	b5000081 	cbnz	x1, 1126070 <tee_obj_close_all+0x24>
}
 1126064:	f9400bf3 	ldr	x19, [sp, #16]
 1126068:	a8c27bfd 	ldp	x29, x30, [sp], #32
 112606c:	d65f03c0 	ret
		tee_obj_close(utc, TAILQ_FIRST(objects));
 1126070:	aa1303e0 	mov	x0, x19
 1126074:	97ffffdd 	bl	1125fe8 <tee_obj_close>
 1126078:	17fffff9 	b	112605c <tee_obj_close_all+0x10>

000000000112607c <tee_pobj_get>:

TEE_Result tee_pobj_get(TEE_UUID *uuid, void *obj_id, uint32_t obj_id_len,
			uint32_t flags, enum tee_pobj_usage usage,
			const struct tee_file_operations *fops,
			struct tee_pobj **obj)
{
 112607c:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
 1126080:	910003fd 	mov	x29, sp
	TEE_Result res = TEE_SUCCESS;
	struct tee_pobj *o = NULL;

	*obj = NULL;
 1126084:	f90000df 	str	xzr, [x6]
{
 1126088:	a9025bf5 	stp	x21, x22, [sp, #32]

	mutex_lock(&pobjs_mutex);
	/* Check if file is open */
	TAILQ_FOREACH(o, &tee_pobjs, link) {
 112608c:	b00001b6 	adrp	x22, 115b000 <__vcore_unpg_rw_start>
{
 1126090:	aa0603f5 	mov	x21, x6
 1126094:	a90153f3 	stp	x19, x20, [sp, #16]
 1126098:	2a0303f4 	mov	w20, w3
 112609c:	a90363f7 	stp	x23, x24, [sp, #48]
 11260a0:	2a0203f7 	mov	w23, w2
 11260a4:	2a0403f8 	mov	w24, w4
 11260a8:	a9046bf9 	stp	x25, x26, [sp, #64]
	mutex_lock(&pobjs_mutex);
 11260ac:	900001d9 	adrp	x25, 115e000 <state+0x80>
{
 11260b0:	aa0103fa 	mov	x26, x1
 11260b4:	a90573fb 	stp	x27, x28, [sp, #80]
 11260b8:	aa0003fc 	mov	x28, x0
 11260bc:	aa0503fb 	mov	x27, x5
	mutex_lock(&pobjs_mutex);
 11260c0:	91064320 	add	x0, x25, #0x190
 11260c4:	97ffbd24 	bl	1115554 <mutex_lock>
	TAILQ_FOREACH(o, &tee_pobjs, link) {
 11260c8:	f9476ed3 	ldr	x19, [x22, #3800]
 11260cc:	f90037f9 	str	x25, [sp, #104]
		if ((obj_id_len == o->obj_id_len) &&
		    (memcmp(obj_id, o->obj_id, obj_id_len) == 0) &&
 11260d0:	2a1703f9 	mov	w25, w23
	TAILQ_FOREACH(o, &tee_pobjs, link) {
 11260d4:	b5000273 	cbnz	x19, 1126120 <tee_pobj_get+0xa4>
		    (fops == o->fops)) {
			*obj = o;
		}
	}

	if (*obj) {
 11260d8:	f94002a0 	ldr	x0, [x21]
 11260dc:	b4000720 	cbz	x0, 11261c0 <tee_pobj_get+0x144>
		if (usage == TEE_POBJ_USAGE_ENUM) {
 11260e0:	71000f1f 	cmp	w24, #0x3
 11260e4:	54000441 	b.ne	112616c <tee_pobj_get+0xf0>  // b.any
			res = TEE_ERROR_ACCESS_CONFLICT;
			goto out;
		}
		res = tee_pobj_check_access((*obj)->flags, flags);
		if (res == TEE_SUCCESS)
			(*obj)->refcnt++;
 11260e8:	b9401001 	ldr	w1, [x0, #16]
 11260ec:	11000421 	add	w1, w1, #0x1
 11260f0:	b9001001 	str	w1, [x0, #16]

	res = TEE_SUCCESS;
out:
	if (res != TEE_SUCCESS)
		*obj = NULL;
	mutex_unlock(&pobjs_mutex);
 11260f4:	f94037e0 	ldr	x0, [sp, #104]
 11260f8:	91064000 	add	x0, x0, #0x190
 11260fc:	97ffbcf5 	bl	11154d0 <mutex_unlock>
	return res;
}
 1126100:	2a1303e0 	mov	w0, w19
 1126104:	a94153f3 	ldp	x19, x20, [sp, #16]
 1126108:	a9425bf5 	ldp	x21, x22, [sp, #32]
 112610c:	a94363f7 	ldp	x23, x24, [sp, #48]
 1126110:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1126114:	a94573fb 	ldp	x27, x28, [sp, #80]
 1126118:	a8c77bfd 	ldp	x29, x30, [sp], #112
 112611c:	d65f03c0 	ret
		if ((obj_id_len == o->obj_id_len) &&
 1126120:	b9403260 	ldr	w0, [x19, #48]
 1126124:	6b17001f 	cmp	w0, w23
 1126128:	540001e1 	b.ne	1126164 <tee_pobj_get+0xe8>  // b.any
		    (memcmp(obj_id, o->obj_id, obj_id_len) == 0) &&
 112612c:	f9401661 	ldr	x1, [x19, #40]
 1126130:	aa1903e2 	mov	x2, x25
 1126134:	aa1a03e0 	mov	x0, x26
 1126138:	940076c6 	bl	1143c50 <memcmp>
		if ((obj_id_len == o->obj_id_len) &&
 112613c:	35000140 	cbnz	w0, 1126164 <tee_pobj_get+0xe8>
		    (memcmp(uuid, &o->uuid, sizeof(TEE_UUID)) == 0) &&
 1126140:	91005261 	add	x1, x19, #0x14
 1126144:	aa1c03e0 	mov	x0, x28
 1126148:	d2800202 	mov	x2, #0x10                  	// #16
 112614c:	940076c1 	bl	1143c50 <memcmp>
		    (memcmp(obj_id, o->obj_id, obj_id_len) == 0) &&
 1126150:	350000a0 	cbnz	w0, 1126164 <tee_pobj_get+0xe8>
		    (memcmp(uuid, &o->uuid, sizeof(TEE_UUID)) == 0) &&
 1126154:	f9402260 	ldr	x0, [x19, #64]
 1126158:	eb1b001f 	cmp	x0, x27
 112615c:	54000041 	b.ne	1126164 <tee_pobj_get+0xe8>  // b.any
			*obj = o;
 1126160:	f90002b3 	str	x19, [x21]
	TAILQ_FOREACH(o, &tee_pobjs, link) {
 1126164:	f9400273 	ldr	x19, [x19]
 1126168:	17ffffdb 	b	11260d4 <tee_pobj_get+0x58>
		if ((*obj)->creating || (usage == TEE_POBJ_USAGE_CREATE &&
 112616c:	3940e401 	ldrb	w1, [x0, #57]
 1126170:	35000221 	cbnz	w1, 11261b4 <tee_pobj_get+0x138>
 1126174:	71000b1f 	cmp	w24, #0x2
 1126178:	54000041 	b.ne	1126180 <tee_pobj_get+0x104>  // b.any
 112617c:	365001d4 	tbz	w20, #10, 11261b4 <tee_pobj_get+0x138>
		res = tee_pobj_check_access((*obj)->flags, flags);
 1126180:	b9403401 	ldr	w1, [x0, #52]
	if ((oflags & TEE_DATA_FLAG_ACCESS_WRITE_META) ||
 1126184:	2a140023 	orr	w3, w1, w20
 1126188:	37100163 	tbnz	w3, #2, 11261b4 <tee_pobj_get+0x138>
	if (((oflags & TEE_DATA_FLAG_ACCESS_READ) ||
 112618c:	36000063 	tbz	w3, #0, 1126198 <tee_pobj_get+0x11c>
	     (nflags & TEE_DATA_FLAG_ACCESS_READ)) &&
 1126190:	36200134 	tbz	w20, #4, 11261b4 <tee_pobj_get+0x138>
	    !((nflags & TEE_DATA_FLAG_SHARE_READ) &&
 1126194:	36200101 	tbz	w1, #4, 11261b4 <tee_pobj_get+0x138>
	if ((nflags & TEE_DATA_FLAG_SHARE_READ) !=
 1126198:	4a140022 	eor	w2, w1, w20
 112619c:	372000c2 	tbnz	w2, #4, 11261b4 <tee_pobj_get+0x138>
	if (((oflags & TEE_DATA_FLAG_ACCESS_WRITE) ||
 11261a0:	36080063 	tbz	w3, #1, 11261ac <tee_pobj_get+0x130>
	     (nflags & TEE_DATA_FLAG_ACCESS_WRITE)) &&
 11261a4:	36280094 	tbz	w20, #5, 11261b4 <tee_pobj_get+0x138>
	    !((nflags & TEE_DATA_FLAG_SHARE_WRITE) &&
 11261a8:	36280061 	tbz	w1, #5, 11261b4 <tee_pobj_get+0x138>
	if ((nflags & TEE_DATA_FLAG_SHARE_WRITE) !=
 11261ac:	121b0053 	and	w19, w2, #0x20
 11261b0:	362ff9c2 	tbz	w2, #5, 11260e8 <tee_pobj_get+0x6c>
			res = TEE_ERROR_ACCESS_CONFLICT;
 11261b4:	129fff93 	mov	w19, #0xffff0003            	// #-65533
		*obj = NULL;
 11261b8:	f90002bf 	str	xzr, [x21]
 11261bc:	17ffffce 	b	11260f4 <tee_pobj_get+0x78>
	o = calloc(1, sizeof(struct tee_pobj));
 11261c0:	d2800901 	mov	x1, #0x48                  	// #72
 11261c4:	d2800020 	mov	x0, #0x1                   	// #1
 11261c8:	940074c2 	bl	11434d0 <calloc>
 11261cc:	aa0003f3 	mov	x19, x0
	if (!o) {
 11261d0:	b4000280 	cbz	x0, 1126220 <tee_pobj_get+0x1a4>
	o->refcnt = 1;
 11261d4:	52800020 	mov	w0, #0x1                   	// #1
 11261d8:	b9001260 	str	w0, [x19, #16]
	memcpy(&o->uuid, uuid, sizeof(TEE_UUID));
 11261dc:	aa1c03e1 	mov	x1, x28
 11261e0:	91005260 	add	x0, x19, #0x14
 11261e4:	d2800202 	mov	x2, #0x10                  	// #16
 11261e8:	97ff746a 	bl	1103390 <memcpy>
	o->flags = flags;
 11261ec:	b9003674 	str	w20, [x19, #52]
	if (usage == TEE_POBJ_USAGE_CREATE) {
 11261f0:	71000b1f 	cmp	w24, #0x2
	o->fops = fops;
 11261f4:	f900227b 	str	x27, [x19, #64]
	if (usage == TEE_POBJ_USAGE_CREATE) {
 11261f8:	54000061 	b.ne	1126204 <tee_pobj_get+0x188>  // b.any
		o->temporary = true;
 11261fc:	52802020 	mov	w0, #0x101                 	// #257
 1126200:	79007260 	strh	w0, [x19, #56]
	o->obj_id = malloc(obj_id_len);
 1126204:	2a1703f4 	mov	w20, w23
 1126208:	aa1403e0 	mov	x0, x20
 112620c:	94007493 	bl	1143458 <malloc>
 1126210:	f9001660 	str	x0, [x19, #40]
	if (o->obj_id == NULL) {
 1126214:	b50000a0 	cbnz	x0, 1126228 <tee_pobj_get+0x1ac>
		free(o);
 1126218:	aa1303e0 	mov	x0, x19
 112621c:	940074f1 	bl	11435e0 <free>
		res = TEE_ERROR_OUT_OF_MEMORY;
 1126220:	129ffe73 	mov	w19, #0xffff000c            	// #-65524
 1126224:	17ffffe5 	b	11261b8 <tee_pobj_get+0x13c>
	TAILQ_INSERT_TAIL(&tee_pobjs, o, link);
 1126228:	913b62d6 	add	x22, x22, #0xed8
	memcpy(o->obj_id, obj_id, obj_id_len);
 112622c:	aa1403e2 	mov	x2, x20
 1126230:	aa1a03e1 	mov	x1, x26
 1126234:	97ff7457 	bl	1103390 <memcpy>
	o->obj_id_len = obj_id_len;
 1126238:	b9003277 	str	w23, [x19, #48]
	TAILQ_INSERT_TAIL(&tee_pobjs, o, link);
 112623c:	f94006c0 	ldr	x0, [x22, #8]
 1126240:	a900027f 	stp	xzr, x0, [x19]
 1126244:	f9000013 	str	x19, [x0]
 1126248:	f90006d3 	str	x19, [x22, #8]
	*obj = o;
 112624c:	f90002b3 	str	x19, [x21]
	res = TEE_SUCCESS;
 1126250:	52800013 	mov	w19, #0x0                   	// #0
 1126254:	17ffffa8 	b	11260f4 <tee_pobj_get+0x78>

0000000001126258 <tee_pobj_create_final>:

void tee_pobj_create_final(struct tee_pobj *po)
{
 1126258:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 112625c:	910003fd 	mov	x29, sp
 1126260:	a90153f3 	stp	x19, x20, [sp, #16]
 1126264:	aa0003f4 	mov	x20, x0
	mutex_lock(&pobjs_mutex);
 1126268:	900001d3 	adrp	x19, 115e000 <state+0x80>
 112626c:	91064273 	add	x19, x19, #0x190
 1126270:	aa1303e0 	mov	x0, x19
 1126274:	97ffbcb8 	bl	1115554 <mutex_lock>
	po->temporary = false;
 1126278:	7900729f 	strh	wzr, [x20, #56]
	po->creating = false;
	mutex_unlock(&pobjs_mutex);
 112627c:	aa1303e0 	mov	x0, x19
}
 1126280:	a94153f3 	ldp	x19, x20, [sp, #16]
 1126284:	a8c27bfd 	ldp	x29, x30, [sp], #32
	mutex_unlock(&pobjs_mutex);
 1126288:	17ffbc92 	b	11154d0 <mutex_unlock>

000000000112628c <tee_pobj_release>:

TEE_Result tee_pobj_release(struct tee_pobj *obj)
{
	if (obj == NULL)
 112628c:	b40003c0 	cbz	x0, 1126304 <tee_pobj_release+0x78>
{
 1126290:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1126294:	910003fd 	mov	x29, sp
 1126298:	a90153f3 	stp	x19, x20, [sp, #16]
 112629c:	aa0003f3 	mov	x19, x0
		return TEE_ERROR_BAD_PARAMETERS;

	mutex_lock(&pobjs_mutex);
 11262a0:	900001d4 	adrp	x20, 115e000 <state+0x80>
 11262a4:	91064280 	add	x0, x20, #0x190
 11262a8:	97ffbcab 	bl	1115554 <mutex_lock>
	obj->refcnt--;
 11262ac:	b9401260 	ldr	w0, [x19, #16]
 11262b0:	51000400 	sub	w0, w0, #0x1
 11262b4:	b9001260 	str	w0, [x19, #16]
	if (obj->refcnt == 0) {
 11262b8:	35000140 	cbnz	w0, 11262e0 <tee_pobj_release+0x54>
		TAILQ_REMOVE(&tee_pobjs, obj, link);
 11262bc:	a9400660 	ldp	x0, x1, [x19]
 11262c0:	b40001c0 	cbz	x0, 11262f8 <tee_pobj_release+0x6c>
 11262c4:	f9000401 	str	x1, [x0, #8]
 11262c8:	f9400661 	ldr	x1, [x19, #8]
 11262cc:	f9000020 	str	x0, [x1]
		free(obj->obj_id);
 11262d0:	f9401660 	ldr	x0, [x19, #40]
 11262d4:	940074c3 	bl	11435e0 <free>
		free(obj);
 11262d8:	aa1303e0 	mov	x0, x19
 11262dc:	940074c1 	bl	11435e0 <free>
	}
	mutex_unlock(&pobjs_mutex);
 11262e0:	91064280 	add	x0, x20, #0x190
 11262e4:	97ffbc7b 	bl	11154d0 <mutex_unlock>

	return TEE_SUCCESS;
 11262e8:	52800000 	mov	w0, #0x0                   	// #0
}
 11262ec:	a94153f3 	ldp	x19, x20, [sp, #16]
 11262f0:	a8c27bfd 	ldp	x29, x30, [sp], #32
 11262f4:	d65f03c0 	ret
		TAILQ_REMOVE(&tee_pobjs, obj, link);
 11262f8:	b00001a2 	adrp	x2, 115b000 <__vcore_unpg_rw_start>
 11262fc:	f9077041 	str	x1, [x2, #3808]
 1126300:	17fffff2 	b	11262c8 <tee_pobj_release+0x3c>
		return TEE_ERROR_BAD_PARAMETERS;
 1126304:	129fff20 	mov	w0, #0xffff0006            	// #-65530
}
 1126308:	d65f03c0 	ret

000000000112630c <tee_pobj_rename>:

TEE_Result tee_pobj_rename(struct tee_pobj *obj, void *obj_id,
			   uint32_t obj_id_len)
{
 112630c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
	TEE_Result res = TEE_SUCCESS;
	void *new_obj_id = NULL;

	if (obj == NULL || obj_id == NULL)
 1126310:	f100001f 	cmp	x0, #0x0
 1126314:	fa401824 	ccmp	x1, #0x0, #0x4, ne  // ne = any
{
 1126318:	910003fd 	mov	x29, sp
 112631c:	a90153f3 	stp	x19, x20, [sp, #16]
 1126320:	a9025bf5 	stp	x21, x22, [sp, #32]
 1126324:	a90363f7 	stp	x23, x24, [sp, #48]
	if (obj == NULL || obj_id == NULL)
 1126328:	54000460 	b.eq	11263b4 <tee_pobj_rename+0xa8>  // b.none
 112632c:	aa0003f3 	mov	x19, x0
 1126330:	aa0103f7 	mov	x23, x1
 1126334:	2a0203f5 	mov	w21, w2
		return TEE_ERROR_BAD_PARAMETERS;

	mutex_lock(&pobjs_mutex);
 1126338:	900001d4 	adrp	x20, 115e000 <state+0x80>
 112633c:	91064280 	add	x0, x20, #0x190
 1126340:	97ffbc85 	bl	1115554 <mutex_lock>
	if (obj->refcnt != 1) {
 1126344:	b9401260 	ldr	w0, [x19, #16]
 1126348:	7100041f 	cmp	w0, #0x1
 112634c:	540002c1 	b.ne	11263a4 <tee_pobj_rename+0x98>  // b.any
		res = TEE_ERROR_BAD_STATE;
		goto exit;
	}

	new_obj_id = malloc(obj_id_len);
 1126350:	2a1503f8 	mov	w24, w21
 1126354:	aa1803e0 	mov	x0, x24
 1126358:	94007440 	bl	1143458 <malloc>
 112635c:	aa0003f6 	mov	x22, x0
	if (new_obj_id == NULL) {
 1126360:	b4000260 	cbz	x0, 11263ac <tee_pobj_rename+0xa0>
		res = TEE_ERROR_OUT_OF_MEMORY;
		goto exit;
	}
	memcpy(new_obj_id, obj_id, obj_id_len);
 1126364:	aa1803e2 	mov	x2, x24
 1126368:	aa1703e1 	mov	x1, x23
 112636c:	97ff7409 	bl	1103390 <memcpy>

	/* update internal data */
	free(obj->obj_id);
 1126370:	f9401660 	ldr	x0, [x19, #40]
 1126374:	9400749b 	bl	11435e0 <free>
	obj->obj_id = new_obj_id;
 1126378:	f9001676 	str	x22, [x19, #40]
	obj->obj_id_len = obj_id_len;
 112637c:	b9003275 	str	w21, [x19, #48]
	TEE_Result res = TEE_SUCCESS;
 1126380:	52800013 	mov	w19, #0x0                   	// #0
	new_obj_id = NULL;

exit:
	mutex_unlock(&pobjs_mutex);
 1126384:	91064280 	add	x0, x20, #0x190
 1126388:	97ffbc52 	bl	11154d0 <mutex_unlock>
	free(new_obj_id);
	return res;
}
 112638c:	2a1303e0 	mov	w0, w19
 1126390:	a94153f3 	ldp	x19, x20, [sp, #16]
 1126394:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1126398:	a94363f7 	ldp	x23, x24, [sp, #48]
 112639c:	a8c47bfd 	ldp	x29, x30, [sp], #64
 11263a0:	d65f03c0 	ret
		res = TEE_ERROR_BAD_STATE;
 11263a4:	129fff13 	mov	w19, #0xffff0007            	// #-65529
 11263a8:	17fffff7 	b	1126384 <tee_pobj_rename+0x78>
		res = TEE_ERROR_OUT_OF_MEMORY;
 11263ac:	129ffe73 	mov	w19, #0xffff000c            	// #-65524
 11263b0:	17fffff5 	b	1126384 <tee_pobj_rename+0x78>
		return TEE_ERROR_BAD_PARAMETERS;
 11263b4:	129fff33 	mov	w19, #0xffff0006            	// #-65530
 11263b8:	17fffff5 	b	112638c <tee_pobj_rename+0x80>

00000000011263bc <tee_time_ta_set_offs>:
	return TEE_ERROR_TIME_NOT_SET;
}

static TEE_Result tee_time_ta_set_offs(const TEE_UUID *uuid,
				       const TEE_Time *offs, bool positive)
{
 11263bc:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
 11263c0:	910003fd 	mov	x29, sp
 11263c4:	a9046bf9 	stp	x25, x26, [sp, #64]
	size_t n;
	struct tee_ta_time_offs *o;

	for (n = 0; n < tee_time_num_offs; n++) {
		if (memcmp(uuid, &tee_time_offs[n].uuid, sizeof(TEE_UUID))
 11263c8:	900001d9 	adrp	x25, 115e000 <state+0x80>
{
 11263cc:	a9025bf5 	stp	x21, x22, [sp, #32]
	for (n = 0; n < tee_time_num_offs; n++) {
 11263d0:	900001d5 	adrp	x21, 115e000 <state+0x80>
{
 11263d4:	12001c56 	and	w22, w2, #0xff
 11263d8:	a90573fb 	stp	x27, x28, [sp, #80]
		if (memcmp(uuid, &tee_time_offs[n].uuid, sizeof(TEE_UUID))
 11263dc:	f940db3c 	ldr	x28, [x25, #432]
{
 11263e0:	a90153f3 	stp	x19, x20, [sp, #16]
 11263e4:	aa0103f4 	mov	x20, x1
	for (n = 0; n < tee_time_num_offs; n++) {
 11263e8:	f940d6ba 	ldr	x26, [x21, #424]
{
 11263ec:	a90363f7 	stp	x23, x24, [sp, #48]
 11263f0:	aa0003f8 	mov	x24, x0
 11263f4:	aa1c03f7 	mov	x23, x28
	for (n = 0; n < tee_time_num_offs; n++) {
 11263f8:	d2800013 	mov	x19, #0x0                   	// #0
 11263fc:	eb13035f 	cmp	x26, x19
 1126400:	540002e1 	b.ne	112645c <tee_time_ta_set_offs+0xa0>  // b.any
			return TEE_SUCCESS;
		}
	}

	n = tee_time_num_offs + 1;
	o = realloc(tee_time_offs, n * sizeof(struct tee_ta_time_offs));
 1126404:	d2800393 	mov	x19, #0x1c                  	// #28
	n = tee_time_num_offs + 1;
 1126408:	91000757 	add	x23, x26, #0x1
	o = realloc(tee_time_offs, n * sizeof(struct tee_ta_time_offs));
 112640c:	aa1c03e0 	mov	x0, x28
 1126410:	9b134f53 	madd	x19, x26, x19, x19
 1126414:	aa1303e1 	mov	x1, x19
 1126418:	94007452 	bl	1143560 <realloc>
	if (!o)
 112641c:	b40004c0 	cbz	x0, 11264b4 <tee_time_ta_set_offs+0xf8>
		return TEE_ERROR_OUT_OF_MEMORY;
	tee_time_offs = o;
	tee_time_offs[tee_time_num_offs].uuid = *uuid;
 1126420:	d1007263 	sub	x3, x19, #0x1c
	tee_time_offs = o;
 1126424:	f900db20 	str	x0, [x25, #432]
	tee_time_offs[tee_time_num_offs].uuid = *uuid;
 1126428:	8b030003 	add	x3, x0, x3
 112642c:	aa1803e1 	mov	x1, x24
 1126430:	aa0303e0 	mov	x0, x3
 1126434:	d2800202 	mov	x2, #0x10                  	// #16
 1126438:	97ff73d6 	bl	1103390 <memcpy>
 112643c:	aa0003e3 	mov	x3, x0
	tee_time_offs[tee_time_num_offs].offs = *offs;
 1126440:	b9400280 	ldr	w0, [x20]
	tee_time_offs[tee_time_num_offs].positive = positive;
	tee_time_num_offs = n;
 1126444:	f900d6b7 	str	x23, [x21, #424]
	tee_time_offs[tee_time_num_offs].offs = *offs;
 1126448:	b9001060 	str	w0, [x3, #16]
 112644c:	b9400680 	ldr	w0, [x20, #4]
 1126450:	b9001460 	str	w0, [x3, #20]
	tee_time_offs[tee_time_num_offs].positive = positive;
 1126454:	39006076 	strb	w22, [x3, #24]
 1126458:	1400000d 	b	112648c <tee_time_ta_set_offs+0xd0>
		if (memcmp(uuid, &tee_time_offs[n].uuid, sizeof(TEE_UUID))
 112645c:	aa1703e1 	mov	x1, x23
 1126460:	aa1703fb 	mov	x27, x23
 1126464:	aa1803e0 	mov	x0, x24
 1126468:	d2800202 	mov	x2, #0x10                  	// #16
 112646c:	910072f7 	add	x23, x23, #0x1c
 1126470:	940075f8 	bl	1143c50 <memcmp>
 1126474:	350001c0 	cbnz	w0, 11264ac <tee_time_ta_set_offs+0xf0>
			tee_time_offs[n].offs = *offs;
 1126478:	b9400280 	ldr	w0, [x20]
 112647c:	b9001360 	str	w0, [x27, #16]
 1126480:	b9400680 	ldr	w0, [x20, #4]
 1126484:	b9001760 	str	w0, [x27, #20]
			tee_time_offs[n].positive = positive;
 1126488:	39006376 	strb	w22, [x27, #24]
	return TEE_SUCCESS;
 112648c:	52800000 	mov	w0, #0x0                   	// #0
}
 1126490:	a94153f3 	ldp	x19, x20, [sp, #16]
 1126494:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1126498:	a94363f7 	ldp	x23, x24, [sp, #48]
 112649c:	a9446bf9 	ldp	x25, x26, [sp, #64]
 11264a0:	a94573fb 	ldp	x27, x28, [sp, #80]
 11264a4:	a8c67bfd 	ldp	x29, x30, [sp], #96
 11264a8:	d65f03c0 	ret
	for (n = 0; n < tee_time_num_offs; n++) {
 11264ac:	91000673 	add	x19, x19, #0x1
 11264b0:	17ffffd3 	b	11263fc <tee_time_ta_set_offs+0x40>
		return TEE_ERROR_OUT_OF_MEMORY;
 11264b4:	129ffe60 	mov	w0, #0xffff000c            	// #-65524
 11264b8:	17fffff6 	b	1126490 <tee_time_ta_set_offs+0xd4>

00000000011264bc <tee_time_get_ta_time>:

TEE_Result tee_time_get_ta_time(const TEE_UUID *uuid, TEE_Time *time)
{
 11264bc:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 11264c0:	910003fd 	mov	x29, sp
 11264c4:	a90363f7 	stp	x23, x24, [sp, #48]
 11264c8:	aa0003f7 	mov	x23, x0
	for (n = 0; n < tee_time_num_offs; n++) {
 11264cc:	900001c0 	adrp	x0, 115e000 <state+0x80>
{
 11264d0:	a90153f3 	stp	x19, x20, [sp, #16]
 11264d4:	aa0103f3 	mov	x19, x1
	for (n = 0; n < tee_time_num_offs; n++) {
 11264d8:	f940d418 	ldr	x24, [x0, #424]
		if (memcmp(uuid, &tee_time_offs[n].uuid, sizeof(TEE_UUID))
 11264dc:	900001c0 	adrp	x0, 115e000 <state+0x80>
{
 11264e0:	a9025bf5 	stp	x21, x22, [sp, #32]
	for (n = 0; n < tee_time_num_offs; n++) {
 11264e4:	d2800016 	mov	x22, #0x0                   	// #0
 11264e8:	f940d814 	ldr	x20, [x0, #432]
 11264ec:	eb1802df 	cmp	x22, x24
 11264f0:	54000061 	b.ne	11264fc <tee_time_get_ta_time+0x40>  // b.any
	return TEE_ERROR_TIME_NOT_SET;
 11264f4:	1295ffe0 	mov	w0, #0xffff5000            	// #-45056
 11264f8:	1400000c 	b	1126528 <tee_time_get_ta_time+0x6c>
		if (memcmp(uuid, &tee_time_offs[n].uuid, sizeof(TEE_UUID))
 11264fc:	aa1403e1 	mov	x1, x20
 1126500:	aa1403f5 	mov	x21, x20
 1126504:	aa1703e0 	mov	x0, x23
 1126508:	d2800202 	mov	x2, #0x10                  	// #16
 112650c:	91007294 	add	x20, x20, #0x1c
 1126510:	940075d0 	bl	1143c50 <memcmp>
 1126514:	35000140 	cbnz	w0, 112653c <tee_time_get_ta_time+0x80>
			*positive = tee_time_offs[n].positive;
 1126518:	394062b4 	ldrb	w20, [x21, #24]

	res = tee_time_ta_get_offs(uuid, &offs, &positive);
	if (res != TEE_SUCCESS)
		return res;

	res = tee_time_get_sys_time(&t);
 112651c:	910123e0 	add	x0, sp, #0x48
 1126520:	97ff7724 	bl	11041b0 <tee_time_get_sys_time>
	if (res != TEE_SUCCESS)
 1126524:	34000100 	cbz	w0, 1126544 <tee_time_get_ta_time+0x88>
			res = TEE_ERROR_OVERFLOW;
	}
	*time = t2;

	return res;
}
 1126528:	a94153f3 	ldp	x19, x20, [sp, #16]
 112652c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1126530:	a94363f7 	ldp	x23, x24, [sp, #48]
 1126534:	a8c57bfd 	ldp	x29, x30, [sp], #80
 1126538:	d65f03c0 	ret
	for (n = 0; n < tee_time_num_offs; n++) {
 112653c:	910006d6 	add	x22, x22, #0x1
 1126540:	17ffffeb 	b	11264ec <tee_time_get_ta_time+0x30>
	if (positive) {
 1126544:	29420aa3 	ldp	w3, w2, [x21, #16]
 1126548:	294903e1 	ldp	w1, w0, [sp, #72]
 112654c:	34000254 	cbz	w20, 1126594 <tee_time_get_ta_time+0xd8>
		TEE_TIME_ADD(t, *offs, t2);
 1126550:	0b020002 	add	w2, w0, w2
 1126554:	0b030023 	add	w3, w1, w3
 1126558:	710f9c5f 	cmp	w2, #0x3e7
 112655c:	54000069 	b.ls	1126568 <tee_time_get_ta_time+0xac>  // b.plast
 1126560:	11000463 	add	w3, w3, #0x1
 1126564:	510fa042 	sub	w2, w2, #0x3e8
		if (TEE_TIME_LT(t2, t))
 1126568:	6b01007f 	cmp	w3, w1
 112656c:	54000101 	b.ne	112658c <tee_time_get_ta_time+0xd0>  // b.any
 1126570:	6b02001f 	cmp	w0, w2
 1126574:	1a9f97e0 	cset	w0, hi  // hi = pmore
			res = TEE_ERROR_OVERFLOW;
 1126578:	7100001f 	cmp	w0, #0x0
 112657c:	1299fe00 	mov	w0, #0xffff300f            	// #-53233
 1126580:	1a8003e0 	csel	w0, wzr, w0, eq  // eq = none
	*time = t2;
 1126584:	29000a63 	stp	w3, w2, [x19]
	return res;
 1126588:	17ffffe8 	b	1126528 <tee_time_get_ta_time+0x6c>
		if (TEE_TIME_LT(t2, t))
 112658c:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
 1126590:	17fffffa 	b	1126578 <tee_time_get_ta_time+0xbc>
		TEE_TIME_SUB(t, *offs, t2);
 1126594:	4b030023 	sub	w3, w1, w3
 1126598:	6b02001f 	cmp	w0, w2
 112659c:	54000122 	b.cs	11265c0 <tee_time_get_ta_time+0x104>  // b.hs, b.nlast
 11265a0:	110fa004 	add	w4, w0, #0x3e8
 11265a4:	51000463 	sub	w3, w3, #0x1
 11265a8:	4b020082 	sub	w2, w4, w2
		if (TEE_TIME_LE(t, t2))
 11265ac:	6b01007f 	cmp	w3, w1
 11265b0:	540000c1 	b.ne	11265c8 <tee_time_get_ta_time+0x10c>  // b.any
 11265b4:	6b02001f 	cmp	w0, w2
 11265b8:	1a9f87e0 	cset	w0, ls  // ls = plast
 11265bc:	17ffffef 	b	1126578 <tee_time_get_ta_time+0xbc>
		TEE_TIME_SUB(t, *offs, t2);
 11265c0:	4b020002 	sub	w2, w0, w2
 11265c4:	17fffffa 	b	11265ac <tee_time_get_ta_time+0xf0>
		if (TEE_TIME_LE(t, t2))
 11265c8:	1a9f37e0 	cset	w0, cs  // cs = hs, nlast
 11265cc:	17ffffeb 	b	1126578 <tee_time_get_ta_time+0xbc>

00000000011265d0 <tee_time_set_ta_time>:

TEE_Result tee_time_set_ta_time(const TEE_UUID *uuid, const TEE_Time *time)
{
 11265d0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 11265d4:	910003fd 	mov	x29, sp
 11265d8:	a90153f3 	stp	x19, x20, [sp, #16]
 11265dc:	aa0003f4 	mov	x20, x0
	TEE_Result res;
	TEE_Time offs;
	TEE_Time t;

	/* Check that time is normalized. */
	if (time->millis >= TEE_TIME_MILLIS_BASE)
 11265e0:	b9400420 	ldr	w0, [x1, #4]
 11265e4:	710f9c1f 	cmp	w0, #0x3e7
 11265e8:	54000568 	b.hi	1126694 <tee_time_set_ta_time+0xc4>  // b.pmore
 11265ec:	aa0103f3 	mov	x19, x1
		return TEE_ERROR_BAD_PARAMETERS;

	res = tee_time_get_sys_time(&t);
 11265f0:	9100a3e0 	add	x0, sp, #0x28
 11265f4:	97ff76ef 	bl	11041b0 <tee_time_get_sys_time>
	if (res != TEE_SUCCESS)
 11265f8:	350002a0 	cbnz	w0, 112664c <tee_time_set_ta_time+0x7c>
		return res;

	if (TEE_TIME_LT(t, *time)) {
 11265fc:	29400e65 	ldp	w5, w3, [x19]
 1126600:	29450be4 	ldp	w4, w2, [sp, #40]
 1126604:	6b05009f 	cmp	w4, w5
 1126608:	54000281 	b.ne	1126658 <tee_time_set_ta_time+0x88>  // b.any
 112660c:	6b02007f 	cmp	w3, w2
 1126610:	1a9f97e0 	cset	w0, hi  // hi = pmore
 1126614:	910083e1 	add	x1, sp, #0x20
 1126618:	34000280 	cbz	w0, 1126668 <tee_time_set_ta_time+0x98>
		TEE_TIME_SUB(*time, t, offs);
 112661c:	4b0400a4 	sub	w4, w5, w4
 1126620:	b90023e4 	str	w4, [sp, #32]
 1126624:	6b02007f 	cmp	w3, w2
 1126628:	540001c2 	b.cs	1126660 <tee_time_set_ta_time+0x90>  // b.hs, b.nlast
 112662c:	4b020062 	sub	w2, w3, w2
 1126630:	51000484 	sub	w4, w4, #0x1
 1126634:	110fa042 	add	w2, w2, #0x3e8
 1126638:	b90023e4 	str	w4, [sp, #32]
 112663c:	b90027e2 	str	w2, [sp, #36]
		return tee_time_ta_set_offs(uuid, &offs, true);
 1126640:	52800022 	mov	w2, #0x1                   	// #1
	} else {
		TEE_TIME_SUB(t, *time, offs);
		return tee_time_ta_set_offs(uuid, &offs, false);
 1126644:	aa1403e0 	mov	x0, x20
 1126648:	97ffff5d 	bl	11263bc <tee_time_ta_set_offs>
	}
}
 112664c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1126650:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1126654:	d65f03c0 	ret
	if (TEE_TIME_LT(t, *time)) {
 1126658:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
 112665c:	17ffffee 	b	1126614 <tee_time_set_ta_time+0x44>
		TEE_TIME_SUB(*time, t, offs);
 1126660:	4b020062 	sub	w2, w3, w2
 1126664:	17fffff6 	b	112663c <tee_time_set_ta_time+0x6c>
		TEE_TIME_SUB(t, *time, offs);
 1126668:	4b050084 	sub	w4, w4, w5
 112666c:	b90023e4 	str	w4, [sp, #32]
 1126670:	6b02007f 	cmp	w3, w2
 1126674:	54000089 	b.ls	1126684 <tee_time_set_ta_time+0xb4>  // b.plast
 1126678:	110fa042 	add	w2, w2, #0x3e8
 112667c:	51000484 	sub	w4, w4, #0x1
 1126680:	b90023e4 	str	w4, [sp, #32]
 1126684:	4b030042 	sub	w2, w2, w3
 1126688:	b90027e2 	str	w2, [sp, #36]
		return tee_time_ta_set_offs(uuid, &offs, false);
 112668c:	52800002 	mov	w2, #0x0                   	// #0
 1126690:	17ffffed 	b	1126644 <tee_time_set_ta_time+0x74>
		return TEE_ERROR_BAD_PARAMETERS;
 1126694:	129fff20 	mov	w0, #0xffff0006            	// #-65530
 1126698:	17ffffed 	b	112664c <tee_time_set_ta_time+0x7c>

000000000112669c <read_ent>:
	return false;
}

static TEE_Result read_ent(struct tee_tadb_dir *db, size_t idx,
			   struct tadb_entry *entry)
{
 112669c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	size_t l = sizeof(*entry);
 11266a0:	d2800c04 	mov	x4, #0x60                  	// #96
{
 11266a4:	910003fd 	mov	x29, sp
	TEE_Result res = db->ops->read(db->fh, idx * l, entry, &l);
 11266a8:	a9400003 	ldp	x3, x0, [x0]
 11266ac:	9b047c21 	mul	x1, x1, x4
	size_t l = sizeof(*entry);
 11266b0:	f9000fe4 	str	x4, [sp, #24]
	TEE_Result res = db->ops->read(db->fh, idx * l, entry, &l);
 11266b4:	f9400c65 	ldr	x5, [x3, #24]
 11266b8:	910063e3 	add	x3, sp, #0x18
 11266bc:	d63f00a0 	blr	x5

	if (!res && l != sizeof(*entry))
 11266c0:	350000a0 	cbnz	w0, 11266d4 <read_ent+0x38>
		return TEE_ERROR_ITEM_NOT_FOUND;
 11266c4:	f9400fe0 	ldr	x0, [sp, #24]
 11266c8:	f101801f 	cmp	x0, #0x60
 11266cc:	129ffee0 	mov	w0, #0xffff0008            	// #-65528
 11266d0:	1a8003e0 	csel	w0, wzr, w0, eq  // eq = none

	return res;
}
 11266d4:	a8c27bfd 	ldp	x29, x30, [sp], #32
 11266d8:	d65f03c0 	ret

00000000011266dc <write_ent>:
static TEE_Result write_ent(struct tee_tadb_dir *db, size_t idx,
			    const struct tadb_entry *entry)
{
	const size_t l = sizeof(*entry);

	return db->ops->write(db->fh, idx * l, entry, l);
 11266dc:	a9400003 	ldp	x3, x0, [x0]
 11266e0:	f9401064 	ldr	x4, [x3, #32]
 11266e4:	d2800c03 	mov	x3, #0x60                  	// #96
 11266e8:	9b037c21 	mul	x1, x1, x3
 11266ec:	aa0403f0 	mov	x16, x4
 11266f0:	d61f0200 	br	x16

00000000011266f4 <is_null_uuid>:
{
 11266f4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	return !memcmp(uuid, &null_uuid, sizeof(*uuid));
 11266f8:	d2800202 	mov	x2, #0x10                  	// #16
{
 11266fc:	910003fd 	mov	x29, sp
	return !memcmp(uuid, &null_uuid, sizeof(*uuid));
 1126700:	8b2263e1 	add	x1, sp, x2
	const TEE_UUID null_uuid = { 0 };
 1126704:	a9017fff 	stp	xzr, xzr, [sp, #16]
	return !memcmp(uuid, &null_uuid, sizeof(*uuid));
 1126708:	94007552 	bl	1143c50 <memcmp>
 112670c:	7100001f 	cmp	w0, #0x0
}
 1126710:	1a9f17e0 	cset	w0, eq  // eq = none
 1126714:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1126718:	d65f03c0 	ret

000000000112671c <find_ent>:
	free(ta);
}

static TEE_Result find_ent(struct tee_tadb_dir *db, const TEE_UUID *uuid,
			   size_t *idx_ret, struct tadb_entry *entry_ret)
{
 112671c:	a9b57bfd 	stp	x29, x30, [sp, #-176]!
 1126720:	910003fd 	mov	x29, sp
 1126724:	a9025bf5 	stp	x21, x22, [sp, #32]
 1126728:	aa0203f6 	mov	x22, x2
 112672c:	aa0303f5 	mov	x21, x3
 1126730:	a90363f7 	stp	x23, x24, [sp, #48]
 1126734:	aa0003f7 	mov	x23, x0
 1126738:	aa0103f8 	mov	x24, x1
 112673c:	f90023f9 	str	x25, [sp, #64]
	 * with TEE_ERROR_ITEM_NOT_FOUND.
	 */
	for (idx = 0;; idx++) {
		struct tadb_entry entry;

		res = read_ent(db, idx, &entry);
 1126740:	910143f9 	add	x25, sp, #0x50
{
 1126744:	a90153f3 	stp	x19, x20, [sp, #16]
	for (idx = 0;; idx++) {
 1126748:	d2800014 	mov	x20, #0x0                   	// #0
		res = read_ent(db, idx, &entry);
 112674c:	aa1903e2 	mov	x2, x25
 1126750:	aa1403e1 	mov	x1, x20
 1126754:	aa1703e0 	mov	x0, x23
 1126758:	97ffffd1 	bl	112669c <read_ent>
 112675c:	2a0003f3 	mov	w19, w0
		if (res) {
 1126760:	34000160 	cbz	w0, 112678c <find_ent+0x70>
			if (res == TEE_ERROR_ITEM_NOT_FOUND)
 1126764:	129ffee0 	mov	w0, #0xffff0008            	// #-65528
 1126768:	6b00027f 	cmp	w19, w0
 112676c:	54000240 	b.eq	11267b4 <find_ent+0x98>  // b.none
		}
	}

	*idx_ret = idx;
	return res;
}
 1126770:	2a1303e0 	mov	w0, w19
 1126774:	a94153f3 	ldp	x19, x20, [sp, #16]
 1126778:	a9425bf5 	ldp	x21, x22, [sp, #32]
 112677c:	a94363f7 	ldp	x23, x24, [sp, #48]
 1126780:	f94023f9 	ldr	x25, [sp, #64]
 1126784:	a8cb7bfd 	ldp	x29, x30, [sp], #176
 1126788:	d65f03c0 	ret
		if (!memcmp(&entry.prop.uuid, uuid, sizeof(*uuid))) {
 112678c:	aa1803e1 	mov	x1, x24
 1126790:	aa1903e0 	mov	x0, x25
 1126794:	d2800202 	mov	x2, #0x10                  	// #16
 1126798:	9400752e 	bl	1143c50 <memcmp>
 112679c:	35000100 	cbnz	w0, 11267bc <find_ent+0xa0>
			if (entry_ret)
 11267a0:	b40000b5 	cbz	x21, 11267b4 <find_ent+0x98>
				*entry_ret = entry;
 11267a4:	aa1903e1 	mov	x1, x25
 11267a8:	aa1503e0 	mov	x0, x21
 11267ac:	d2800c02 	mov	x2, #0x60                  	// #96
 11267b0:	97ff72f8 	bl	1103390 <memcpy>
	*idx_ret = idx;
 11267b4:	f90002d4 	str	x20, [x22]
	return res;
 11267b8:	17ffffee 	b	1126770 <find_ent+0x54>
	for (idx = 0;; idx++) {
 11267bc:	91000694 	add	x20, x20, #0x1
 11267c0:	17ffffe3 	b	112674c <find_ent+0x30>

00000000011267c4 <tadb_authenc_init>:
{
 11267c4:	d10183ff 	sub	sp, sp, #0x60
 11267c8:	a9017bfd 	stp	x29, x30, [sp, #16]
 11267cc:	910043fd 	add	x29, sp, #0x10
 11267d0:	a90253f3 	stp	x19, x20, [sp, #32]
 11267d4:	aa0103f4 	mov	x20, x1
 11267d8:	a90463f7 	stp	x23, x24, [sp, #64]
	const size_t enc_size = entry->prop.custom_size + entry->prop.bin_size;
 11267dc:	2942e037 	ldp	w23, w24, [x1, #20]
	res = crypto_authenc_alloc_ctx(&ctx, TADB_AUTH_ENC_ALG);
 11267e0:	52810201 	mov	w1, #0x810                 	// #2064
 11267e4:	72a80001 	movk	w1, #0x4000, lsl #16
{
 11267e8:	a9035bf5 	stp	x21, x22, [sp, #48]
 11267ec:	2a0003f6 	mov	w22, w0
 11267f0:	aa0203f5 	mov	x21, x2
	res = crypto_authenc_alloc_ctx(&ctx, TADB_AUTH_ENC_ALG);
 11267f4:	910163e0 	add	x0, sp, #0x58
 11267f8:	97ff9c81 	bl	110d9fc <crypto_authenc_alloc_ctx>
 11267fc:	2a0003f3 	mov	w19, w0
	if (res)
 1126800:	35000200 	cbnz	w0, 1126840 <tadb_authenc_init+0x7c>
	res = crypto_authenc_init(ctx, mode, entry->key, sizeof(entry->key),
 1126804:	f9402fe0 	ldr	x0, [sp, #88]
	const size_t enc_size = entry->prop.custom_size + entry->prop.bin_size;
 1126808:	0b1802f7 	add	w23, w23, w24
 112680c:	f90003f7 	str	x23, [sp]
	res = crypto_authenc_init(ctx, mode, entry->key, sizeof(entry->key),
 1126810:	d2800206 	mov	x6, #0x10                  	// #16
 1126814:	91008284 	add	x4, x20, #0x20
 1126818:	aa0603e5 	mov	x5, x6
 112681c:	91010282 	add	x2, x20, #0x40
 1126820:	2a1603e1 	mov	w1, w22
 1126824:	d2800007 	mov	x7, #0x0                   	// #0
 1126828:	d2800403 	mov	x3, #0x20                  	// #32
 112682c:	97ff9c8d 	bl	110da60 <crypto_authenc_init>
 1126830:	2a0003f3 	mov	w19, w0
		crypto_authenc_free_ctx(ctx);
 1126834:	f9402fe0 	ldr	x0, [sp, #88]
	if (res)
 1126838:	34000133 	cbz	w19, 112685c <tadb_authenc_init+0x98>
		crypto_authenc_free_ctx(ctx);
 112683c:	97ff9d2b 	bl	110dce8 <crypto_authenc_free_ctx>
}
 1126840:	2a1303e0 	mov	w0, w19
 1126844:	a9417bfd 	ldp	x29, x30, [sp, #16]
 1126848:	a94253f3 	ldp	x19, x20, [sp, #32]
 112684c:	a9435bf5 	ldp	x21, x22, [sp, #48]
 1126850:	a94463f7 	ldp	x23, x24, [sp, #64]
 1126854:	910183ff 	add	sp, sp, #0x60
 1126858:	d65f03c0 	ret
		*ctx_ret = ctx;
 112685c:	f90002a0 	str	x0, [x21]
 1126860:	17fffff8 	b	1126840 <tadb_authenc_init+0x7c>

0000000001126864 <tadb_put>:
{
 1126864:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1126868:	910003fd 	mov	x29, sp
 112686c:	f90013f5 	str	x21, [sp, #32]
	assert(db == tadb_db);
 1126870:	900001d5 	adrp	x21, 115e000 <state+0x80>
{
 1126874:	a90153f3 	stp	x19, x20, [sp, #16]
	assert(db == tadb_db);
 1126878:	f940deb4 	ldr	x20, [x21, #440]
 112687c:	eb00029f 	cmp	x20, x0
 1126880:	54000140 	b.eq	11268a8 <tadb_put+0x44>  // b.none
 1126884:	f0000163 	adrp	x3, 1155000 <__func__.3826+0xa8>
 1126888:	f0000161 	adrp	x1, 1155000 <__func__.3826+0xa8>
 112688c:	f0000160 	adrp	x0, 1155000 <__func__.3826+0xa8>
 1126890:	913b0863 	add	x3, x3, #0xec2
 1126894:	9138f021 	add	x1, x1, #0xe3c
 1126898:	91393000 	add	x0, x0, #0xe4c
 112689c:	52801fc2 	mov	w2, #0xfe                  	// #254
	assert(tadb_db_refc);
 11268a0:	97ffae83 	bl	11122ac <_assert_log>
 11268a4:	97ffae93 	bl	11122f0 <_assert_break>
	mutex_lock(&tadb_mutex);
 11268a8:	900001d3 	adrp	x19, 115e000 <state+0x80>
 11268ac:	91070260 	add	x0, x19, #0x1c0
 11268b0:	97ffbb29 	bl	1115554 <mutex_lock>
	assert(tadb_db_refc);
 11268b4:	d0000201 	adrp	x1, 1168000 <data.5093+0x9e28>
 11268b8:	b94a8820 	ldr	w0, [x1, #2696]
 11268bc:	35000120 	cbnz	w0, 11268e0 <tadb_put+0x7c>
 11268c0:	f0000163 	adrp	x3, 1155000 <__func__.3826+0xa8>
 11268c4:	f0000161 	adrp	x1, 1155000 <__func__.3826+0xa8>
 11268c8:	f0000160 	adrp	x0, 1155000 <__func__.3826+0xa8>
 11268cc:	913b0863 	add	x3, x3, #0xec2
 11268d0:	9138f021 	add	x1, x1, #0xe3c
 11268d4:	91396800 	add	x0, x0, #0xe5a
 11268d8:	52802002 	mov	w2, #0x100                 	// #256
 11268dc:	17fffff1 	b	11268a0 <tadb_put+0x3c>
	tadb_db_refc--;
 11268e0:	51000400 	sub	w0, w0, #0x1
 11268e4:	b90a8820 	str	w0, [x1, #2696]
	if (!tadb_db_refc) {
 11268e8:	35000140 	cbnz	w0, 1126910 <tadb_put+0xac>
		db->ops->close(&db->fh);
 11268ec:	aa1403e0 	mov	x0, x20
 11268f0:	f8408401 	ldr	x1, [x0], #8
 11268f4:	f9400821 	ldr	x1, [x1, #16]
 11268f8:	d63f0020 	blr	x1
		free(db->files);
 11268fc:	f9400e80 	ldr	x0, [x20, #24]
 1126900:	94007338 	bl	11435e0 <free>
		free(db);
 1126904:	aa1403e0 	mov	x0, x20
 1126908:	94007336 	bl	11435e0 <free>
		tadb_db = NULL;
 112690c:	f900debf 	str	xzr, [x21, #440]
	mutex_unlock(&tadb_mutex);
 1126910:	91070260 	add	x0, x19, #0x1c0
}
 1126914:	a94153f3 	ldp	x19, x20, [sp, #16]
 1126918:	f94013f5 	ldr	x21, [sp, #32]
 112691c:	a8c37bfd 	ldp	x29, x30, [sp], #48
	mutex_unlock(&tadb_mutex);
 1126920:	17ffbaec 	b	11154d0 <mutex_unlock>

0000000001126924 <set_file>:
{
 1126924:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1126928:	910003fd 	mov	x29, sp
 112692c:	a90153f3 	stp	x19, x20, [sp, #16]
 1126930:	aa0003f4 	mov	x20, x0
	if (idx < db->nbits)
 1126934:	b9401000 	ldr	w0, [x0, #16]
{
 1126938:	2a0103f3 	mov	w19, w1
	if (idx < db->nbits)
 112693c:	6b00003f 	cmp	w1, w0
 1126940:	540003cb 	b.lt	11269b8 <set_file+0x94>  // b.tstop
	p = realloc(db->files, bitstr_size(idx + 1));
 1126944:	11002021 	add	w1, w1, #0x8
 1126948:	f9400e80 	ldr	x0, [x20, #24]
 112694c:	13037c21 	asr	w1, w1, #3
 1126950:	93407c21 	sxtw	x1, w1
 1126954:	94007303 	bl	1143560 <realloc>
	if (!p)
 1126958:	b4000600 	cbz	x0, 1126a18 <set_file+0xf4>
	bit_nclear(db->files, db->nbits, idx);
 112695c:	b9401282 	ldr	w2, [x20, #16]
 1126960:	12000a65 	and	w5, w19, #0x7
 1126964:	110004a5 	add	w5, w5, #0x1
	db->files = p;
 1126968:	f9000e80 	str	x0, [x20, #24]
 112696c:	12000841 	and	w1, w2, #0x7
	bit_nclear(db->files, db->nbits, idx);
 1126970:	13037e64 	asr	w4, w19, #3
 1126974:	13037c46 	asr	w6, w2, #3
 1126978:	52800102 	mov	w2, #0x8                   	// #8
 112697c:	4b010042 	sub	w2, w2, w1
 1126980:	52801fe1 	mov	w1, #0xff                  	// #255
 1126984:	93407cc3 	sxtw	x3, w6
 1126988:	6b930cdf 	cmp	w6, w19, asr #3
 112698c:	1ac22822 	asr	w2, w1, w2
 1126990:	1ac52021 	lsl	w1, w1, w5
 1126994:	13001c42 	sxtb	w2, w2
 1126998:	38636805 	ldrb	w5, [x0, x3]
 112699c:	13001c21 	sxtb	w1, w1
 11269a0:	54000261 	b.ne	11269ec <set_file+0xc8>  // b.any
 11269a4:	2a010042 	orr	w2, w2, w1
 11269a8:	0a050042 	and	w2, w2, w5
 11269ac:	38236802 	strb	w2, [x0, x3]
	db->nbits = idx + 1;
 11269b0:	11000660 	add	w0, w19, #0x1
 11269b4:	b9001280 	str	w0, [x20, #16]
		bit_set(db->files, idx);
 11269b8:	13037e60 	asr	w0, w19, #3
 11269bc:	12000a73 	and	w19, w19, #0x7
 11269c0:	f9400e82 	ldr	x2, [x20, #24]
 11269c4:	93407c00 	sxtw	x0, w0
 11269c8:	52800021 	mov	w1, #0x1                   	// #1
 11269cc:	1ad32033 	lsl	w19, w1, w19
 11269d0:	38606841 	ldrb	w1, [x2, x0]
 11269d4:	2a010273 	orr	w19, w19, w1
 11269d8:	38206853 	strb	w19, [x2, x0]
 11269dc:	52800000 	mov	w0, #0x0                   	// #0
}
 11269e0:	a94153f3 	ldp	x19, x20, [sp, #16]
 11269e4:	a8c27bfd 	ldp	x29, x30, [sp], #32
 11269e8:	d65f03c0 	ret
	bit_nclear(db->files, db->nbits, idx);
 11269ec:	0a050042 	and	w2, w2, w5
 11269f0:	38236802 	strb	w2, [x0, x3]
 11269f4:	91000463 	add	x3, x3, #0x1
 11269f8:	6b03009f 	cmp	w4, w3
 11269fc:	540000ac 	b.gt	1126a10 <set_file+0xec>
 1126a00:	93407c83 	sxtw	x3, w4
 1126a04:	38636802 	ldrb	w2, [x0, x3]
 1126a08:	0a020022 	and	w2, w1, w2
 1126a0c:	17ffffe8 	b	11269ac <set_file+0x88>
 1126a10:	3823681f 	strb	wzr, [x0, x3]
 1126a14:	17fffff8 	b	11269f4 <set_file+0xd0>
		return TEE_ERROR_OUT_OF_MEMORY;
 1126a18:	129ffe60 	mov	w0, #0xffff000c            	// #-65524
	return res;
 1126a1c:	17fffff1 	b	11269e0 <set_file+0xbc>

0000000001126a20 <tadb_update_payload>:
{
 1126a20:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1126a24:	910003fd 	mov	x29, sp
	res = crypto_authenc_update_payload(ctx, mode, (const uint8_t *)src,
 1126a28:	9100a3e5 	add	x5, sp, #0x28
{
 1126a2c:	f9000bf3 	str	x19, [sp, #16]
 1126a30:	aa0303f3 	mov	x19, x3
	size_t sz = len;
 1126a34:	f90017e3 	str	x3, [sp, #40]
	res = crypto_authenc_update_payload(ctx, mode, (const uint8_t *)src,
 1126a38:	97ff9c3a 	bl	110db20 <crypto_authenc_update_payload>
	assert(res || sz == len);
 1126a3c:	350001a0 	cbnz	w0, 1126a70 <tadb_update_payload+0x50>
 1126a40:	f94017e1 	ldr	x1, [sp, #40]
 1126a44:	eb13003f 	cmp	x1, x19
 1126a48:	54000140 	b.eq	1126a70 <tadb_update_payload+0x50>  // b.none
 1126a4c:	f0000163 	adrp	x3, 1155000 <__func__.3826+0xa8>
 1126a50:	f0000161 	adrp	x1, 1155000 <__func__.3826+0xa8>
 1126a54:	913b2c63 	add	x3, x3, #0xecb
 1126a58:	9138f021 	add	x1, x1, #0xe3c
 1126a5c:	f0000160 	adrp	x0, 1155000 <__func__.3826+0xa8>
 1126a60:	91399c00 	add	x0, x0, #0xe67
 1126a64:	528025e2 	mov	w2, #0x12f                 	// #303
 1126a68:	97ffae11 	bl	11122ac <_assert_log>
 1126a6c:	97ffae21 	bl	11122f0 <_assert_break>
}
 1126a70:	f9400bf3 	ldr	x19, [sp, #16]
 1126a74:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1126a78:	d65f03c0 	ret

0000000001126a7c <tee_tadb_open>:
{
 1126a7c:	d102c3ff 	sub	sp, sp, #0xb0
 1126a80:	a9017bfd 	stp	x29, x30, [sp, #16]
 1126a84:	910043fd 	add	x29, sp, #0x10
 1126a88:	a9035bf5 	stp	x21, x22, [sp, #48]
	if (!tadb_db_refc) {
 1126a8c:	d0000215 	adrp	x21, 1168000 <data.5093+0x9e28>
	mutex_lock(&tadb_mutex);
 1126a90:	900001d6 	adrp	x22, 115e000 <state+0x80>
{
 1126a94:	a90253f3 	stp	x19, x20, [sp, #32]
 1126a98:	a90463f7 	stp	x23, x24, [sp, #64]
 1126a9c:	aa0003f8 	mov	x24, x0
	mutex_lock(&tadb_mutex);
 1126aa0:	910702c0 	add	x0, x22, #0x1c0
{
 1126aa4:	a9056bf9 	stp	x25, x26, [sp, #80]
	mutex_lock(&tadb_mutex);
 1126aa8:	97ffbaab 	bl	1115554 <mutex_lock>
	if (!tadb_db_refc) {
 1126aac:	b94a8aa0 	ldr	w0, [x21, #2696]
 1126ab0:	900001d9 	adrp	x25, 115e000 <state+0x80>
 1126ab4:	350008a0 	cbnz	w0, 1126bc8 <tee_tadb_open+0x14c>
		assert(!tadb_db);
 1126ab8:	f940df20 	ldr	x0, [x25, #440]
 1126abc:	b4000140 	cbz	x0, 1126ae4 <tee_tadb_open+0x68>
 1126ac0:	f0000163 	adrp	x3, 1155000 <__func__.3826+0xa8>
 1126ac4:	f0000161 	adrp	x1, 1155000 <__func__.3826+0xa8>
 1126ac8:	913ad063 	add	x3, x3, #0xeb4
 1126acc:	9138f021 	add	x1, x1, #0xe3c
 1126ad0:	f0000160 	adrp	x0, 1155000 <__func__.3826+0xa8>
 1126ad4:	9139e000 	add	x0, x0, #0xe78
 1126ad8:	52801e02 	mov	w2, #0xf0                  	// #240
 1126adc:	97ffadf4 	bl	11122ac <_assert_log>
 1126ae0:	97ffae04 	bl	11122f0 <_assert_break>
	struct tee_tadb_dir *db = calloc(1, sizeof(*db));
 1126ae4:	d2800401 	mov	x1, #0x20                  	// #32
	struct tee_pobj po = {
 1126ae8:	9101a3fa 	add	x26, sp, #0x68
	struct tee_tadb_dir *db = calloc(1, sizeof(*db));
 1126aec:	d2800020 	mov	x0, #0x1                   	// #1
 1126af0:	94007278 	bl	11434d0 <calloc>
	struct tee_pobj po = {
 1126af4:	d2800902 	mov	x2, #0x48                  	// #72
	struct tee_tadb_dir *db = calloc(1, sizeof(*db));
 1126af8:	aa0003f4 	mov	x20, x0
	struct tee_pobj po = {
 1126afc:	52800001 	mov	w1, #0x0                   	// #0
 1126b00:	aa1a03e0 	mov	x0, x26
 1126b04:	94007477 	bl	1143ce0 <memset>
 1126b08:	f0000160 	adrp	x0, 1155000 <__func__.3826+0xa8>
 1126b0c:	913bd800 	add	x0, x0, #0xef6
 1126b10:	f9004be0 	str	x0, [sp, #144]
 1126b14:	528000c0 	mov	w0, #0x6                   	// #6
 1126b18:	b9009be0 	str	w0, [sp, #152]
	if (!db)
 1126b1c:	b5000194 	cbnz	x20, 1126b4c <tee_tadb_open+0xd0>
		return TEE_ERROR_OUT_OF_MEMORY;
 1126b20:	129ffe73 	mov	w19, #0xffff000c            	// #-65524
	mutex_unlock(&tadb_mutex);
 1126b24:	910702c0 	add	x0, x22, #0x1c0
 1126b28:	97ffba6a 	bl	11154d0 <mutex_unlock>
}
 1126b2c:	2a1303e0 	mov	w0, w19
 1126b30:	a9417bfd 	ldp	x29, x30, [sp, #16]
 1126b34:	a94253f3 	ldp	x19, x20, [sp, #32]
 1126b38:	a9435bf5 	ldp	x21, x22, [sp, #48]
 1126b3c:	a94463f7 	ldp	x23, x24, [sp, #64]
 1126b40:	a9456bf9 	ldp	x25, x26, [sp, #80]
 1126b44:	9102c3ff 	add	sp, sp, #0xb0
 1126b48:	d65f03c0 	ret
	db->ops = tee_svc_storage_file_ops(TEE_STORAGE_PRIVATE);
 1126b4c:	aa1403f7 	mov	x23, x20
 1126b50:	52800020 	mov	w0, #0x1                   	// #1
 1126b54:	97ffec2c 	bl	1121c04 <tee_svc_storage_file_ops>
	res = db->ops->open(&po, NULL, &db->fh);
 1126b58:	f9400003 	ldr	x3, [x0]
	db->ops = tee_svc_storage_file_ops(TEE_STORAGE_PRIVATE);
 1126b5c:	f80086e0 	str	x0, [x23], #8
	res = db->ops->open(&po, NULL, &db->fh);
 1126b60:	d2800001 	mov	x1, #0x0                   	// #0
 1126b64:	aa1a03e0 	mov	x0, x26
 1126b68:	aa1703e2 	mov	x2, x23
 1126b6c:	d63f0060 	blr	x3
 1126b70:	2a0003f3 	mov	w19, w0
	if (res == TEE_ERROR_ITEM_NOT_FOUND)
 1126b74:	129ffee0 	mov	w0, #0xffff0008            	// #-65528
 1126b78:	6b00027f 	cmp	w19, w0
 1126b7c:	540001c1 	b.ne	1126bb4 <tee_tadb_open+0x138>  // b.any
		res = db->ops->create(&po, false, NULL, 0, NULL, 0, NULL, 0,
 1126b80:	f9400280 	ldr	x0, [x20]
 1126b84:	f90003f7 	str	x23, [sp]
 1126b88:	d2800007 	mov	x7, #0x0                   	// #0
 1126b8c:	d2800006 	mov	x6, #0x0                   	// #0
 1126b90:	d2800005 	mov	x5, #0x0                   	// #0
 1126b94:	d2800004 	mov	x4, #0x0                   	// #0
 1126b98:	f9400408 	ldr	x8, [x0, #8]
 1126b9c:	d2800003 	mov	x3, #0x0                   	// #0
 1126ba0:	aa1a03e0 	mov	x0, x26
 1126ba4:	d2800002 	mov	x2, #0x0                   	// #0
 1126ba8:	52800001 	mov	w1, #0x0                   	// #0
 1126bac:	d63f0100 	blr	x8
 1126bb0:	2a0003f3 	mov	w19, w0
	if (res)
 1126bb4:	34000093 	cbz	w19, 1126bc4 <tee_tadb_open+0x148>
		free(db);
 1126bb8:	aa1403e0 	mov	x0, x20
 1126bbc:	94007289 	bl	11435e0 <free>
		if (res)
 1126bc0:	17ffffd9 	b	1126b24 <tee_tadb_open+0xa8>
		*db_ret = db;
 1126bc4:	f900df34 	str	x20, [x25, #440]
	tadb_db_refc++;
 1126bc8:	b94a8aa0 	ldr	w0, [x21, #2696]
	*db = tadb_db;
 1126bcc:	52800013 	mov	w19, #0x0                   	// #0
	tadb_db_refc++;
 1126bd0:	11000400 	add	w0, w0, #0x1
 1126bd4:	b90a8aa0 	str	w0, [x21, #2696]
	*db = tadb_db;
 1126bd8:	f940df20 	ldr	x0, [x25, #440]
 1126bdc:	f9000300 	str	x0, [x24]
 1126be0:	17ffffd1 	b	1126b24 <tee_tadb_open+0xa8>

0000000001126be4 <ta_operation_open>:
{
 1126be4:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
 1126be8:	910003fd 	mov	x29, sp
	va = thread_rpc_shm_cache_alloc(THREAD_SHM_CACHE_USER_FS,
 1126bec:	9100e3e3 	add	x3, sp, #0x38
{
 1126bf0:	a90153f3 	stp	x19, x20, [sp, #16]
 1126bf4:	2a0003f3 	mov	w19, w0
 1126bf8:	aa0203f4 	mov	x20, x2
	va = thread_rpc_shm_cache_alloc(THREAD_SHM_CACHE_USER_FS,
 1126bfc:	52800020 	mov	w0, #0x1                   	// #1
 1126c00:	d2802bc2 	mov	x2, #0x15e                 	// #350
{
 1126c04:	f90013f5 	str	x21, [sp, #32]
 1126c08:	2a0103f5 	mov	w21, w1
	va = thread_rpc_shm_cache_alloc(THREAD_SHM_CACHE_USER_FS,
 1126c0c:	52800001 	mov	w1, #0x0                   	// #0
 1126c10:	97ff7df4 	bl	11063e0 <thread_rpc_shm_cache_alloc>
	if (!va)
 1126c14:	b40003e0 	cbz	x0, 1126c90 <ta_operation_open+0xac>
	rc = snprintf(buf, blen, "%" PRIu32 ".ta", file_number);
 1126c18:	d2802bc1 	mov	x1, #0x15e                 	// #350
 1126c1c:	2a1503e3 	mov	w3, w21
 1126c20:	f0000162 	adrp	x2, 1155000 <__func__.3826+0xa8>
 1126c24:	913a0442 	add	x2, x2, #0xe81
 1126c28:	940073f5 	bl	1143bfc <snprintf>
	struct thread_param params[] = {
 1126c2c:	a904fff3 	stp	x19, xzr, [sp, #72]
 1126c30:	52800020 	mov	w0, #0x1                   	// #1
 1126c34:	b90043e0 	str	w0, [sp, #64]
 1126c38:	52800080 	mov	w0, #0x4                   	// #4
 1126c3c:	b90063e0 	str	w0, [sp, #96]
 1126c40:	d2802bc0 	mov	x0, #0x15e                 	// #350
 1126c44:	f9003be0 	str	x0, [sp, #112]
	res = thread_rpc_cmd(OPTEE_RPC_CMD_FS, ARRAY_SIZE(params), params);
 1126c48:	910103e2 	add	x2, sp, #0x40
	struct thread_param params[] = {
 1126c4c:	f9401fe0 	ldr	x0, [sp, #56]
	res = thread_rpc_cmd(OPTEE_RPC_CMD_FS, ARRAY_SIZE(params), params);
 1126c50:	d2800061 	mov	x1, #0x3                   	// #3
	struct thread_param params[] = {
 1126c54:	f9002fff 	str	xzr, [sp, #88]
 1126c58:	f90037ff 	str	xzr, [sp, #104]
 1126c5c:	f9003fe0 	str	x0, [sp, #120]
 1126c60:	52800040 	mov	w0, #0x2                   	// #2
 1126c64:	b90083e0 	str	w0, [sp, #128]
 1126c68:	a908ffff 	stp	xzr, xzr, [sp, #136]
 1126c6c:	f9004fff 	str	xzr, [sp, #152]
	res = thread_rpc_cmd(OPTEE_RPC_CMD_FS, ARRAY_SIZE(params), params);
 1126c70:	97ff80bb 	bl	1106f5c <thread_rpc_cmd>
	if (!res)
 1126c74:	35000060 	cbnz	w0, 1126c80 <ta_operation_open+0x9c>
		*fd = params[2].u.value.a;
 1126c78:	f94047e1 	ldr	x1, [sp, #136]
 1126c7c:	b9000281 	str	w1, [x20]
}
 1126c80:	a94153f3 	ldp	x19, x20, [sp, #16]
 1126c84:	f94013f5 	ldr	x21, [sp, #32]
 1126c88:	a8ca7bfd 	ldp	x29, x30, [sp], #160
 1126c8c:	d65f03c0 	ret
		return TEE_ERROR_OUT_OF_MEMORY;
 1126c90:	129ffe60 	mov	w0, #0xffff000c            	// #-65524
 1126c94:	17fffffb 	b	1126c80 <ta_operation_open+0x9c>

0000000001126c98 <clear_file>:
	if (idx < db->nbits)
 1126c98:	b9401002 	ldr	w2, [x0, #16]
 1126c9c:	6b01005f 	cmp	w2, w1
 1126ca0:	5400014d 	b.le	1126cc8 <clear_file+0x30>
		bit_clear(db->files, idx);
 1126ca4:	13037c22 	asr	w2, w1, #3
 1126ca8:	12000821 	and	w1, w1, #0x7
 1126cac:	f9400c03 	ldr	x3, [x0, #24]
 1126cb0:	93407c42 	sxtw	x2, w2
 1126cb4:	52800020 	mov	w0, #0x1                   	// #1
 1126cb8:	1ac12001 	lsl	w1, w0, w1
 1126cbc:	38626860 	ldrb	w0, [x3, x2]
 1126cc0:	0a210001 	bic	w1, w0, w1
 1126cc4:	38226861 	strb	w1, [x3, x2]
}
 1126cc8:	d65f03c0 	ret

0000000001126ccc <ta_operation_remove>:
{
 1126ccc:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
	va = thread_rpc_shm_cache_alloc(THREAD_SHM_CACHE_USER_FS,
 1126cd0:	d2802bc2 	mov	x2, #0x15e                 	// #350
 1126cd4:	52800001 	mov	w1, #0x0                   	// #0
{
 1126cd8:	910003fd 	mov	x29, sp
	va = thread_rpc_shm_cache_alloc(THREAD_SHM_CACHE_USER_FS,
 1126cdc:	9100a3e3 	add	x3, sp, #0x28
{
 1126ce0:	f9000bf3 	str	x19, [sp, #16]
 1126ce4:	2a0003f3 	mov	w19, w0
	va = thread_rpc_shm_cache_alloc(THREAD_SHM_CACHE_USER_FS,
 1126ce8:	52800020 	mov	w0, #0x1                   	// #1
 1126cec:	97ff7dbd 	bl	11063e0 <thread_rpc_shm_cache_alloc>
	if (!va)
 1126cf0:	b4000320 	cbz	x0, 1126d54 <ta_operation_remove+0x88>
	rc = snprintf(buf, blen, "%" PRIu32 ".ta", file_number);
 1126cf4:	d2802bc1 	mov	x1, #0x15e                 	// #350
 1126cf8:	2a1303e3 	mov	w3, w19
 1126cfc:	f0000162 	adrp	x2, 1155000 <__func__.3826+0xa8>
 1126d00:	913a0442 	add	x2, x2, #0xe81
 1126d04:	940073be 	bl	1143bfc <snprintf>
	struct thread_param params[] = {
 1126d08:	a9047fff 	stp	xzr, xzr, [sp, #64]
 1126d0c:	52800020 	mov	w0, #0x1                   	// #1
 1126d10:	b90033e0 	str	w0, [sp, #48]
 1126d14:	d28000c0 	mov	x0, #0x6                   	// #6
 1126d18:	f9001fe0 	str	x0, [sp, #56]
 1126d1c:	52800080 	mov	w0, #0x4                   	// #4
 1126d20:	b90053e0 	str	w0, [sp, #80]
 1126d24:	d2802bc0 	mov	x0, #0x15e                 	// #350
 1126d28:	f90033e0 	str	x0, [sp, #96]
	return thread_rpc_cmd(OPTEE_RPC_CMD_FS, ARRAY_SIZE(params), params);
 1126d2c:	d2800041 	mov	x1, #0x2                   	// #2
	struct thread_param params[] = {
 1126d30:	f94017e0 	ldr	x0, [sp, #40]
	return thread_rpc_cmd(OPTEE_RPC_CMD_FS, ARRAY_SIZE(params), params);
 1126d34:	9100c3e2 	add	x2, sp, #0x30
	struct thread_param params[] = {
 1126d38:	f9002fff 	str	xzr, [sp, #88]
 1126d3c:	f90037e0 	str	x0, [sp, #104]
	return thread_rpc_cmd(OPTEE_RPC_CMD_FS, ARRAY_SIZE(params), params);
 1126d40:	2a0103e0 	mov	w0, w1
 1126d44:	97ff8086 	bl	1106f5c <thread_rpc_cmd>
}
 1126d48:	f9400bf3 	ldr	x19, [sp, #16]
 1126d4c:	a8c77bfd 	ldp	x29, x30, [sp], #112
 1126d50:	d65f03c0 	ret
		return TEE_ERROR_OUT_OF_MEMORY;
 1126d54:	129ffe60 	mov	w0, #0xffff000c            	// #-65524
 1126d58:	17fffffc 	b	1126d48 <ta_operation_remove+0x7c>

0000000001126d5c <tee_tadb_ta_create>:
{
 1126d5c:	a9b47bfd 	stp	x29, x30, [sp, #-192]!
 1126d60:	910003fd 	mov	x29, sp
 1126d64:	a90153f3 	stp	x19, x20, [sp, #16]
 1126d68:	a9025bf5 	stp	x21, x22, [sp, #32]
 1126d6c:	aa0103f5 	mov	x21, x1
 1126d70:	a90363f7 	stp	x23, x24, [sp, #48]
 1126d74:	aa0003f8 	mov	x24, x0
 1126d78:	a9046bf9 	stp	x25, x26, [sp, #64]
 1126d7c:	a90573fb 	stp	x27, x28, [sp, #80]
	if (is_null_uuid(&property->uuid))
 1126d80:	97fffe5d 	bl	11266f4 <is_null_uuid>
 1126d84:	72001c1f 	tst	w0, #0xff
 1126d88:	540012a1 	b.ne	1126fdc <tee_tadb_ta_create+0x280>  // b.any
	ta = calloc(1, sizeof(*ta));
 1126d8c:	d2801001 	mov	x1, #0x80                  	// #128
 1126d90:	d2800020 	mov	x0, #0x1                   	// #1
 1126d94:	940071cf 	bl	11434d0 <calloc>
 1126d98:	aa0003f4 	mov	x20, x0
	if (!ta)
 1126d9c:	b4001240 	cbz	x0, 1126fe4 <tee_tadb_ta_create+0x288>
	res = tee_tadb_open(&ta->db);
 1126da0:	97ffff37 	bl	1126a7c <tee_tadb_open>
 1126da4:	2a0003f3 	mov	w19, w0
	if (res)
 1126da8:	35000f80 	cbnz	w0, 1126f98 <tee_tadb_ta_create+0x23c>
	mutex_lock(&tadb_mutex);
 1126dac:	900001d6 	adrp	x22, 115e000 <state+0x80>
 1126db0:	910702c0 	add	x0, x22, #0x1c0
 1126db4:	97ffb9e8 	bl	1115554 <mutex_lock>
	res = populate_files(ta->db);
 1126db8:	f940029b 	ldr	x27, [x20]
	if (db->files)
 1126dbc:	f9400f60 	ldr	x0, [x27, #24]
 1126dc0:	b5000200 	cbnz	x0, 1126e00 <tee_tadb_ta_create+0xa4>
			IMSG("Clearing duplicate file number %" PRIu32,
 1126dc4:	f0000179 	adrp	x25, 1155000 <__func__.3826+0xa8>
 1126dc8:	f000017a 	adrp	x26, 1155000 <__func__.3826+0xa8>
		res = read_ent(db, idx, &entry);
 1126dcc:	910183fc 	add	x28, sp, #0x60
			IMSG("Clearing duplicate file number %" PRIu32,
 1126dd0:	913a1f39 	add	x25, x25, #0xe87
 1126dd4:	913b7f5a 	add	x26, x26, #0xedf
	for (idx = 0;; idx++) {
 1126dd8:	d2800017 	mov	x23, #0x0                   	// #0
		res = read_ent(db, idx, &entry);
 1126ddc:	aa1c03e2 	mov	x2, x28
 1126de0:	aa1703e1 	mov	x1, x23
 1126de4:	aa1b03e0 	mov	x0, x27
 1126de8:	97fffe2d 	bl	112669c <read_ent>
 1126dec:	2a0003f3 	mov	w19, w0
		if (res) {
 1126df0:	34000760 	cbz	w0, 1126edc <tee_tadb_ta_create+0x180>
			if (res == TEE_ERROR_ITEM_NOT_FOUND)
 1126df4:	129ffee0 	mov	w0, #0xffff0008            	// #-65528
 1126df8:	6b00027f 	cmp	w19, w0
 1126dfc:	54000be1 	b.ne	1126f78 <tee_tadb_ta_create+0x21c>  // b.any
	if (ta->db->files) {
 1126e00:	f9400280 	ldr	x0, [x20]
 1126e04:	f9400c01 	ldr	x1, [x0, #24]
 1126e08:	b4000e61 	cbz	x1, 1126fd4 <tee_tadb_ta_create+0x278>
		bit_ffc(ta->db->files, ta->db->nbits, &i);
 1126e0c:	b9401017 	ldr	w23, [x0, #16]
 1126e10:	710002ff 	cmp	w23, #0x0
 1126e14:	5400010d 	b.le	1126e34 <tee_tadb_ta_create+0xd8>
 1126e18:	510006e5 	sub	w5, w23, #0x1
 1126e1c:	d1000423 	sub	x3, x1, #0x1
 1126e20:	d2800002 	mov	x2, #0x0                   	// #0
 1126e24:	13037ca5 	asr	w5, w5, #3
 1126e28:	2a0203e1 	mov	w1, w2
 1126e2c:	6b0200bf 	cmp	w5, w2
 1126e30:	54000baa 	b.ge	1126fa4 <tee_tadb_ta_create+0x248>  // b.tcont
	res = set_file(ta->db, i);
 1126e34:	2a1703e1 	mov	w1, w23
 1126e38:	97fffebb 	bl	1126924 <set_file>
 1126e3c:	2a0003f3 	mov	w19, w0
	if (res)
 1126e40:	35000a40 	cbnz	w0, 1126f88 <tee_tadb_ta_create+0x22c>
	mutex_unlock(&tadb_mutex);
 1126e44:	910702c0 	add	x0, x22, #0x1c0
 1126e48:	97ffb9a2 	bl	11154d0 <mutex_unlock>
	ta->entry.prop = *property;
 1126e4c:	d2800382 	mov	x2, #0x1c                  	// #28
 1126e50:	91003296 	add	x22, x20, #0xc
 1126e54:	aa1803e1 	mov	x1, x24
 1126e58:	aa1603e0 	mov	x0, x22
	ta->entry.file_number = i;
 1126e5c:	b9002a97 	str	w23, [x20, #40]
	ta->entry.prop = *property;
 1126e60:	97ff714c 	bl	1103390 <memcpy>
	res = crypto_rng_read(ta->entry.iv, sizeof(ta->entry.iv));
 1126e64:	9100b280 	add	x0, x20, #0x2c
 1126e68:	d2800201 	mov	x1, #0x10                  	// #16
 1126e6c:	97ffa1d0 	bl	110f5ac <crypto_rng_read>
 1126e70:	2a0003f3 	mov	w19, w0
	if (res)
 1126e74:	350008e0 	cbnz	w0, 1126f90 <tee_tadb_ta_create+0x234>
	res = crypto_rng_read(ta->entry.key, sizeof(ta->entry.key));
 1126e78:	91013280 	add	x0, x20, #0x4c
 1126e7c:	d2800401 	mov	x1, #0x20                  	// #32
 1126e80:	97ffa1cb 	bl	110f5ac <crypto_rng_read>
 1126e84:	2a0003f3 	mov	w19, w0
	if (res)
 1126e88:	35000840 	cbnz	w0, 1126f90 <tee_tadb_ta_create+0x234>
	res = ta_operation_open(OPTEE_RPC_FS_CREATE, ta->entry.file_number,
 1126e8c:	b9402a81 	ldr	w1, [x20, #40]
 1126e90:	91002282 	add	x2, x20, #0x8
 1126e94:	52800020 	mov	w0, #0x1                   	// #1
 1126e98:	97ffff53 	bl	1126be4 <ta_operation_open>
 1126e9c:	2a0003f3 	mov	w19, w0
	if (res)
 1126ea0:	35000780 	cbnz	w0, 1126f90 <tee_tadb_ta_create+0x234>
	res = tadb_authenc_init(TEE_MODE_ENCRYPT, &ta->entry, &ta->ctx);
 1126ea4:	9101e282 	add	x2, x20, #0x78
 1126ea8:	aa1603e1 	mov	x1, x22
 1126eac:	97fffe46 	bl	11267c4 <tadb_authenc_init>
 1126eb0:	2a0003f3 	mov	w19, w0
	if (res)
 1126eb4:	350006e0 	cbnz	w0, 1126f90 <tee_tadb_ta_create+0x234>
	*ta_ret = ta;
 1126eb8:	f90002b4 	str	x20, [x21]
}
 1126ebc:	2a1303e0 	mov	w0, w19
 1126ec0:	a94153f3 	ldp	x19, x20, [sp, #16]
 1126ec4:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1126ec8:	a94363f7 	ldp	x23, x24, [sp, #48]
 1126ecc:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1126ed0:	a94573fb 	ldp	x27, x28, [sp, #80]
 1126ed4:	a8cc7bfd 	ldp	x29, x30, [sp], #192
 1126ed8:	d65f03c0 	ret
		if (is_null_uuid(&entry.prop.uuid))
 1126edc:	aa1c03e0 	mov	x0, x28
 1126ee0:	97fffe05 	bl	11266f4 <is_null_uuid>
 1126ee4:	72001c1f 	tst	w0, #0xff
 1126ee8:	540003e1 	b.ne	1126f64 <tee_tadb_ta_create+0x208>  // b.any
	if (idx < db->nbits)
 1126eec:	b9401360 	ldr	w0, [x27, #16]
		if (test_file(db, entry.file_number)) {
 1126ef0:	b9407fe1 	ldr	w1, [sp, #124]
	if (idx < db->nbits)
 1126ef4:	6b00003f 	cmp	w1, w0
 1126ef8:	540003aa 	b.ge	1126f6c <tee_tadb_ta_create+0x210>  // b.tcont
		return bit_test(db->files, idx);
 1126efc:	f9400f62 	ldr	x2, [x27, #24]
 1126f00:	13037c20 	asr	w0, w1, #3
 1126f04:	52800023 	mov	w3, #0x1                   	// #1
 1126f08:	3860c842 	ldrb	w2, [x2, w0, sxtw]
 1126f0c:	12000820 	and	w0, w1, #0x7
 1126f10:	1ac02060 	lsl	w0, w3, w0
		if (test_file(db, entry.file_number)) {
 1126f14:	6a00005f 	tst	w2, w0
 1126f18:	540002a0 	b.eq	1126f6c <tee_tadb_ta_create+0x210>  // b.none
			IMSG("Clearing duplicate file number %" PRIu32,
 1126f1c:	2a0103e5 	mov	w5, w1
 1126f20:	aa1903e4 	mov	x4, x25
 1126f24:	aa1a03e0 	mov	x0, x26
 1126f28:	52800042 	mov	w2, #0x2                   	// #2
 1126f2c:	52802b01 	mov	w1, #0x158                 	// #344
 1126f30:	94007785 	bl	1144d44 <trace_printf>
			res = write_ent(db, idx, &entry);
 1126f34:	aa1c03e2 	mov	x2, x28
 1126f38:	aa1703e1 	mov	x1, x23
 1126f3c:	aa1b03e0 	mov	x0, x27
			memset(&entry, 0, sizeof(entry));
 1126f40:	a9007f9f 	stp	xzr, xzr, [x28]
 1126f44:	a9017f9f 	stp	xzr, xzr, [x28, #16]
 1126f48:	a9027f9f 	stp	xzr, xzr, [x28, #32]
 1126f4c:	a9037f9f 	stp	xzr, xzr, [x28, #48]
 1126f50:	a9047f9f 	stp	xzr, xzr, [x28, #64]
 1126f54:	a9057f9f 	stp	xzr, xzr, [x28, #80]
			res = write_ent(db, idx, &entry);
 1126f58:	97fffde1 	bl	11266dc <write_ent>
		res = set_file(db, entry.file_number);
 1126f5c:	2a0003f3 	mov	w19, w0
		if (res)
 1126f60:	350000c0 	cbnz	w0, 1126f78 <tee_tadb_ta_create+0x21c>
	for (idx = 0;; idx++) {
 1126f64:	910006f7 	add	x23, x23, #0x1
 1126f68:	17ffff9d 	b	1126ddc <tee_tadb_ta_create+0x80>
		res = set_file(db, entry.file_number);
 1126f6c:	aa1b03e0 	mov	x0, x27
 1126f70:	97fffe6d 	bl	1126924 <set_file>
 1126f74:	17fffffa 	b	1126f5c <tee_tadb_ta_create+0x200>
	free(db->files);
 1126f78:	f9400f60 	ldr	x0, [x27, #24]
 1126f7c:	94007199 	bl	11435e0 <free>
	db->nbits = 0;
 1126f80:	b900137f 	str	wzr, [x27, #16]
	db->files = NULL;
 1126f84:	f9000f7f 	str	xzr, [x27, #24]
	mutex_unlock(&tadb_mutex);
 1126f88:	910702c0 	add	x0, x22, #0x1c0
 1126f8c:	97ffb951 	bl	11154d0 <mutex_unlock>
	tadb_put(ta->db);
 1126f90:	f9400280 	ldr	x0, [x20]
 1126f94:	97fffe34 	bl	1126864 <tadb_put>
	free(ta);
 1126f98:	aa1403e0 	mov	x0, x20
 1126f9c:	94007191 	bl	11435e0 <free>
	return res;
 1126fa0:	17ffffc7 	b	1126ebc <tee_tadb_ta_create+0x160>
		bit_ffc(ta->db->files, ta->db->nbits, &i);
 1126fa4:	91000442 	add	x2, x2, #0x1
 1126fa8:	38626864 	ldrb	w4, [x3, x2]
 1126fac:	7103fc9f 	cmp	w4, #0xff
 1126fb0:	54fff3c0 	b.eq	1126e28 <tee_tadb_ta_create+0xcc>  // b.none
 1126fb4:	531d7021 	lsl	w1, w1, #3
 1126fb8:	37000084 	tbnz	w4, #0, 1126fc8 <tee_tadb_ta_create+0x26c>
 1126fbc:	6b0102ff 	cmp	w23, w1
 1126fc0:	1a81d2f7 	csel	w23, w23, w1, le
 1126fc4:	17ffff9c 	b	1126e34 <tee_tadb_ta_create+0xd8>
 1126fc8:	11000421 	add	w1, w1, #0x1
 1126fcc:	53017c84 	lsr	w4, w4, #1
 1126fd0:	17fffffa 	b	1126fb8 <tee_tadb_ta_create+0x25c>
	int i = 0;
 1126fd4:	52800017 	mov	w23, #0x0                   	// #0
 1126fd8:	17ffff97 	b	1126e34 <tee_tadb_ta_create+0xd8>
		return TEE_ERROR_GENERIC;
 1126fdc:	52bffff3 	mov	w19, #0xffff0000            	// #-65536
 1126fe0:	17ffffb7 	b	1126ebc <tee_tadb_ta_create+0x160>
		return TEE_ERROR_OUT_OF_MEMORY;
 1126fe4:	129ffe73 	mov	w19, #0xffff000c            	// #-65524
 1126fe8:	17ffffb5 	b	1126ebc <tee_tadb_ta_create+0x160>

0000000001126fec <tee_tadb_ta_write>:
{
 1126fec:	a9b17bfd 	stp	x29, x30, [sp, #-240]!
 1126ff0:	910003fd 	mov	x29, sp
 1126ff4:	a90153f3 	stp	x19, x20, [sp, #16]
 1126ff8:	aa0003f4 	mov	x20, x0
 1126ffc:	aa0203f3 	mov	x19, x2
 1127000:	a9025bf5 	stp	x21, x22, [sp, #32]
 1127004:	aa0103f5 	mov	x21, x1
		res = tee_fs_rpc_write_init(&op, OPTEE_RPC_CMD_FS, ta->fd,
 1127008:	910183f6 	add	x22, sp, #0x60
{
 112700c:	a90363f7 	stp	x23, x24, [sp, #48]
		res = tee_fs_rpc_write_init(&op, OPTEE_RPC_CMD_FS, ta->fd,
 1127010:	910163f8 	add	x24, sp, #0x58
		size_t wl = MIN(rl, TADB_MAX_BUFFER_SIZE);
 1127014:	d2a00037 	mov	x23, #0x10000               	// #65536
{
 1127018:	f90023f9 	str	x25, [sp, #64]
	while (rl) {
 112701c:	b5000113 	cbnz	x19, 112703c <tee_tadb_ta_write+0x50>
	return TEE_SUCCESS;
 1127020:	52800000 	mov	w0, #0x0                   	// #0
}
 1127024:	a94153f3 	ldp	x19, x20, [sp, #16]
 1127028:	a9425bf5 	ldp	x21, x22, [sp, #32]
 112702c:	a94363f7 	ldp	x23, x24, [sp, #48]
 1127030:	f94023f9 	ldr	x25, [sp, #64]
 1127034:	a8cf7bfd 	ldp	x29, x30, [sp], #240
 1127038:	d65f03c0 	ret
		res = tee_fs_rpc_write_init(&op, OPTEE_RPC_CMD_FS, ta->fd,
 112703c:	b9400a82 	ldr	w2, [x20, #8]
		size_t wl = MIN(rl, TADB_MAX_BUFFER_SIZE);
 1127040:	f140427f 	cmp	x19, #0x10, lsl #12
		res = tee_fs_rpc_write_init(&op, OPTEE_RPC_CMD_FS, ta->fd,
 1127044:	f9403a83 	ldr	x3, [x20, #112]
		size_t wl = MIN(rl, TADB_MAX_BUFFER_SIZE);
 1127048:	9a979279 	csel	x25, x19, x23, ls  // ls = plast
		res = tee_fs_rpc_write_init(&op, OPTEE_RPC_CMD_FS, ta->fd,
 112704c:	aa1803e5 	mov	x5, x24
 1127050:	aa1903e4 	mov	x4, x25
 1127054:	aa1603e0 	mov	x0, x22
 1127058:	52800041 	mov	w1, #0x2                   	// #2
 112705c:	97fffab7 	bl	1125b38 <tee_fs_rpc_write_init>
		if (res)
 1127060:	35fffe20 	cbnz	w0, 1127024 <tee_tadb_ta_write+0x38>
		res = tadb_update_payload(ta->ctx, TEE_MODE_ENCRYPT,
 1127064:	f9402fe4 	ldr	x4, [sp, #88]
 1127068:	aa1903e3 	mov	x3, x25
 112706c:	f9403e80 	ldr	x0, [x20, #120]
 1127070:	aa1503e2 	mov	x2, x21
 1127074:	52800001 	mov	w1, #0x0                   	// #0
 1127078:	97fffe6a 	bl	1126a20 <tadb_update_payload>
		if (res)
 112707c:	35fffd40 	cbnz	w0, 1127024 <tee_tadb_ta_write+0x38>
		res = tee_fs_rpc_write_final(&op);
 1127080:	aa1603e0 	mov	x0, x22
 1127084:	97fffadc 	bl	1125bf4 <tee_fs_rpc_write_final>
		if (res)
 1127088:	35fffce0 	cbnz	w0, 1127024 <tee_tadb_ta_write+0x38>
		ta->pos += wl;
 112708c:	f9403a80 	ldr	x0, [x20, #112]
		rl -= wl;
 1127090:	cb190273 	sub	x19, x19, x25
		rb += wl;
 1127094:	8b1902b5 	add	x21, x21, x25
		ta->pos += wl;
 1127098:	8b190019 	add	x25, x0, x25
 112709c:	f9003a99 	str	x25, [x20, #112]
 11270a0:	17ffffdf 	b	112701c <tee_tadb_ta_write+0x30>

00000000011270a4 <tee_tadb_ta_close_and_delete>:
{
 11270a4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 11270a8:	910003fd 	mov	x29, sp
 11270ac:	a90153f3 	stp	x19, x20, [sp, #16]
 11270b0:	aa0003f3 	mov	x19, x0
	mutex_lock(&tadb_mutex);
 11270b4:	f00001b4 	adrp	x20, 115e000 <state+0x80>
	crypto_authenc_final(ta->ctx);
 11270b8:	f9403c00 	ldr	x0, [x0, #120]
 11270bc:	97ff9b00 	bl	110dcbc <crypto_authenc_final>
	crypto_authenc_free_ctx(ta->ctx);
 11270c0:	f9403e60 	ldr	x0, [x19, #120]
 11270c4:	97ff9b09 	bl	110dce8 <crypto_authenc_free_ctx>
	tee_fs_rpc_close(OPTEE_RPC_CMD_FS, ta->fd);
 11270c8:	b9400a61 	ldr	w1, [x19, #8]
 11270cc:	52800040 	mov	w0, #0x2                   	// #2
 11270d0:	97fffa46 	bl	11259e8 <tee_fs_rpc_close>
	ta_operation_remove(ta->entry.file_number);
 11270d4:	b9402a60 	ldr	w0, [x19, #40]
 11270d8:	97fffefd 	bl	1126ccc <ta_operation_remove>
	mutex_lock(&tadb_mutex);
 11270dc:	91070280 	add	x0, x20, #0x1c0
 11270e0:	97ffb91d 	bl	1115554 <mutex_lock>
	clear_file(ta->db, ta->entry.file_number);
 11270e4:	f9400262 	ldr	x2, [x19]
 11270e8:	b9402a61 	ldr	w1, [x19, #40]
	if (idx < db->nbits)
 11270ec:	b9401040 	ldr	w0, [x2, #16]
 11270f0:	6b00003f 	cmp	w1, w0
 11270f4:	5400014a 	b.ge	112711c <tee_tadb_ta_close_and_delete+0x78>  // b.tcont
		bit_clear(db->files, idx);
 11270f8:	13037c20 	asr	w0, w1, #3
 11270fc:	f9400c43 	ldr	x3, [x2, #24]
 1127100:	93407c00 	sxtw	x0, w0
 1127104:	12000822 	and	w2, w1, #0x7
 1127108:	52800021 	mov	w1, #0x1                   	// #1
 112710c:	1ac22021 	lsl	w1, w1, w2
 1127110:	38606862 	ldrb	w2, [x3, x0]
 1127114:	0a210041 	bic	w1, w2, w1
 1127118:	38206861 	strb	w1, [x3, x0]
	mutex_unlock(&tadb_mutex);
 112711c:	91070280 	add	x0, x20, #0x1c0
 1127120:	97ffb8ec 	bl	11154d0 <mutex_unlock>
	tadb_put(ta->db);
 1127124:	f9400260 	ldr	x0, [x19]
 1127128:	97fffdcf 	bl	1126864 <tadb_put>
	free(ta);
 112712c:	aa1303e0 	mov	x0, x19
}
 1127130:	a94153f3 	ldp	x19, x20, [sp, #16]
 1127134:	a8c27bfd 	ldp	x29, x30, [sp], #32
	free(ta);
 1127138:	1400712a 	b	11435e0 <free>

000000000112713c <tee_tadb_ta_close_and_commit>:
		return TEE_SUCCESS;
	return res;
}

TEE_Result tee_tadb_ta_close_and_commit(struct tee_tadb_ta_write *ta)
{
 112713c:	a9b37bfd 	stp	x29, x30, [sp, #-208]!
	size_t sz = sizeof(ta->entry.tag);
	size_t idx;
	struct tadb_entry old_ent;
	bool have_old_ent = false;

	res = crypto_authenc_enc_final(ta->ctx, NULL, 0, NULL, &dsz,
 1127140:	d2800003 	mov	x3, #0x0                   	// #0
 1127144:	d2800002 	mov	x2, #0x0                   	// #0
{
 1127148:	910003fd 	mov	x29, sp
 112714c:	a90153f3 	stp	x19, x20, [sp, #16]
 1127150:	aa0003f3 	mov	x19, x0
	size_t sz = sizeof(ta->entry.tag);
 1127154:	d2800200 	mov	x0, #0x10                  	// #16
 1127158:	a90483ff 	stp	xzr, x0, [sp, #72]
	res = crypto_authenc_enc_final(ta->ctx, NULL, 0, NULL, &dsz,
 112715c:	910143e6 	add	x6, sp, #0x50
 1127160:	9100f265 	add	x5, x19, #0x3c
 1127164:	f9403e60 	ldr	x0, [x19, #120]
 1127168:	910123e4 	add	x4, sp, #0x48
 112716c:	d2800001 	mov	x1, #0x0                   	// #0
{
 1127170:	a9025bf5 	stp	x21, x22, [sp, #32]
 1127174:	f9001bf7 	str	x23, [sp, #48]
	res = crypto_authenc_enc_final(ta->ctx, NULL, 0, NULL, &dsz,
 1127178:	97ff9a8b 	bl	110dba4 <crypto_authenc_enc_final>
				       ta->entry.tag, &sz);
	if (res)
 112717c:	350007e0 	cbnz	w0, 1127278 <tee_tadb_ta_close_and_commit+0x13c>
		goto err;

	tee_fs_rpc_close(OPTEE_RPC_CMD_FS, ta->fd);
 1127180:	b9400a61 	ldr	w1, [x19, #8]
 1127184:	52800040 	mov	w0, #0x2                   	// #2

	mutex_lock(&tadb_mutex);
 1127188:	f00001b5 	adrp	x21, 115e000 <state+0x80>
	 * we'll use the entry, but we should also remove the old encrypted
	 * file.
	 *
	 * If there isn't an existing TA to replace, grab a new entry.
	 */
	res = find_ent(ta->db, &ta->entry.prop.uuid, &idx, &old_ent);
 112718c:	91003277 	add	x23, x19, #0xc
 1127190:	910163f4 	add	x20, sp, #0x58
	tee_fs_rpc_close(OPTEE_RPC_CMD_FS, ta->fd);
 1127194:	97fffa15 	bl	11259e8 <tee_fs_rpc_close>
	mutex_lock(&tadb_mutex);
 1127198:	910702a0 	add	x0, x21, #0x1c0
 112719c:	97ffb8ee 	bl	1115554 <mutex_lock>
	res = find_ent(ta->db, &ta->entry.prop.uuid, &idx, &old_ent);
 11271a0:	f9400260 	ldr	x0, [x19]
 11271a4:	9101c3e3 	add	x3, sp, #0x70
 11271a8:	aa1403e2 	mov	x2, x20
 11271ac:	aa1703e1 	mov	x1, x23
 11271b0:	97fffd5b 	bl	112671c <find_ent>
	if (!res) {
 11271b4:	340005e0 	cbz	w0, 1127270 <tee_tadb_ta_close_and_commit+0x134>
	TEE_Result res = find_ent(db, &null_uuid, idx, NULL);
 11271b8:	f9400260 	ldr	x0, [x19]
 11271bc:	aa1403e2 	mov	x2, x20
 11271c0:	910183e1 	add	x1, sp, #0x60
 11271c4:	d2800003 	mov	x3, #0x0                   	// #0
	const TEE_UUID null_uuid = { 0 };
 11271c8:	a9067fff 	stp	xzr, xzr, [sp, #96]
	TEE_Result res = find_ent(db, &null_uuid, idx, NULL);
 11271cc:	97fffd54 	bl	112671c <find_ent>
 11271d0:	2a0003f4 	mov	w20, w0
	if (res == TEE_ERROR_ITEM_NOT_FOUND)
 11271d4:	129ffee0 	mov	w0, #0xffff0008            	// #-65528
 11271d8:	6b00029f 	cmp	w20, w0
 11271dc:	540003e1 	b.ne	1127258 <tee_tadb_ta_close_and_commit+0x11c>  // b.any
	bool have_old_ent = false;
 11271e0:	52800016 	mov	w22, #0x0                   	// #0
	} else {
		res = find_free_ent_idx(ta->db, &idx);
		if (res)
			goto err_mutex;
	}
	res = write_ent(ta->db, idx, &ta->entry);
 11271e4:	f9400260 	ldr	x0, [x19]
 11271e8:	aa1703e2 	mov	x2, x23
 11271ec:	f9402fe1 	ldr	x1, [sp, #88]
 11271f0:	97fffd3b 	bl	11266dc <write_ent>
 11271f4:	2a0003f4 	mov	w20, w0
	if (res)
 11271f8:	35000320 	cbnz	w0, 112725c <tee_tadb_ta_close_and_commit+0x120>
		goto err_mutex;
	if (have_old_ent)
 11271fc:	34000096 	cbz	w22, 112720c <tee_tadb_ta_close_and_commit+0xd0>
		clear_file(ta->db, old_ent.file_number);
 1127200:	b9408fe1 	ldr	w1, [sp, #140]
 1127204:	f9400260 	ldr	x0, [x19]
 1127208:	97fffea4 	bl	1126c98 <clear_file>
	mutex_unlock(&tadb_mutex);
 112720c:	910702a0 	add	x0, x21, #0x1c0
 1127210:	97ffb8b0 	bl	11154d0 <mutex_unlock>

	crypto_authenc_final(ta->ctx);
 1127214:	f9403e60 	ldr	x0, [x19, #120]
 1127218:	97ff9aa9 	bl	110dcbc <crypto_authenc_final>
	crypto_authenc_free_ctx(ta->ctx);
 112721c:	f9403e60 	ldr	x0, [x19, #120]
 1127220:	97ff9ab2 	bl	110dce8 <crypto_authenc_free_ctx>
	tadb_put(ta->db);
 1127224:	f9400260 	ldr	x0, [x19]
 1127228:	97fffd8f 	bl	1126864 <tadb_put>
	free(ta);
 112722c:	aa1303e0 	mov	x0, x19
 1127230:	940070ec 	bl	11435e0 <free>
	if (have_old_ent)
 1127234:	34000076 	cbz	w22, 1127240 <tee_tadb_ta_close_and_commit+0x104>
		ta_operation_remove(old_ent.file_number);
 1127238:	b9408fe0 	ldr	w0, [sp, #140]
 112723c:	97fffea4 	bl	1126ccc <ta_operation_remove>
err_mutex:
	mutex_unlock(&tadb_mutex);
err:
	tee_tadb_ta_close_and_delete(ta);
	return res;
}
 1127240:	2a1403e0 	mov	w0, w20
 1127244:	a94153f3 	ldp	x19, x20, [sp, #16]
 1127248:	a9425bf5 	ldp	x21, x22, [sp, #32]
 112724c:	f9401bf7 	ldr	x23, [sp, #48]
 1127250:	a8cd7bfd 	ldp	x29, x30, [sp], #208
 1127254:	d65f03c0 	ret
		if (res)
 1127258:	34fffc54 	cbz	w20, 11271e0 <tee_tadb_ta_close_and_commit+0xa4>
	mutex_unlock(&tadb_mutex);
 112725c:	910702a0 	add	x0, x21, #0x1c0
 1127260:	97ffb89c 	bl	11154d0 <mutex_unlock>
	tee_tadb_ta_close_and_delete(ta);
 1127264:	aa1303e0 	mov	x0, x19
 1127268:	97ffff8f 	bl	11270a4 <tee_tadb_ta_close_and_delete>
	return res;
 112726c:	17fffff5 	b	1127240 <tee_tadb_ta_close_and_commit+0x104>
		have_old_ent = true;
 1127270:	52800036 	mov	w22, #0x1                   	// #1
 1127274:	17ffffdc 	b	11271e4 <tee_tadb_ta_close_and_commit+0xa8>
 1127278:	2a0003f4 	mov	w20, w0
 112727c:	17fffffa 	b	1127264 <tee_tadb_ta_close_and_commit+0x128>

0000000001127280 <tee_tadb_ta_open>:
	return TEE_SUCCESS;
}

TEE_Result tee_tadb_ta_open(const TEE_UUID *uuid,
			    struct tee_tadb_ta_read **ta_ret)
{
 1127280:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 1127284:	910003fd 	mov	x29, sp
 1127288:	a90153f3 	stp	x19, x20, [sp, #16]
 112728c:	a9025bf5 	stp	x21, x22, [sp, #32]
 1127290:	aa0103f6 	mov	x22, x1
 1127294:	a90363f7 	stp	x23, x24, [sp, #48]
 1127298:	aa0003f7 	mov	x23, x0
	TEE_Result res = TEE_SUCCESS;
	size_t idx = 0;
 112729c:	f90027ff 	str	xzr, [sp, #72]
	struct tee_tadb_ta_read *ta = NULL;

	if (is_null_uuid(uuid))
 11272a0:	97fffd15 	bl	11266f4 <is_null_uuid>
 11272a4:	72001c1f 	tst	w0, #0xff
 11272a8:	540005e1 	b.ne	1127364 <tee_tadb_ta_open+0xe4>  // b.any
		return TEE_ERROR_GENERIC;

	ta = calloc(1, sizeof(*ta));
 11272ac:	d2801201 	mov	x1, #0x90                  	// #144
 11272b0:	d2800020 	mov	x0, #0x1                   	// #1
 11272b4:	94007087 	bl	11434d0 <calloc>
 11272b8:	aa0003f4 	mov	x20, x0
	if (!ta)
 11272bc:	b4000580 	cbz	x0, 112736c <tee_tadb_ta_open+0xec>
		return TEE_ERROR_OUT_OF_MEMORY;

	res = tee_tadb_open(&ta->db);
 11272c0:	97fffdef 	bl	1126a7c <tee_tadb_open>
 11272c4:	2a0003f3 	mov	w19, w0
	if (res)
 11272c8:	35000480 	cbnz	w0, 1127358 <tee_tadb_ta_open+0xd8>
		goto err_free; /* Mustn't call tadb_put() */

	mutex_read_lock(&tadb_mutex);
 11272cc:	f00001b5 	adrp	x21, 115e000 <state+0x80>
 11272d0:	910702b5 	add	x21, x21, #0x1c0
 11272d4:	aa1503e0 	mov	x0, x21
 11272d8:	97ffb930 	bl	1115798 <mutex_read_lock>
	res = find_ent(ta->db, uuid, &idx, &ta->entry);
 11272dc:	f9400280 	ldr	x0, [x20]
 11272e0:	91003298 	add	x24, x20, #0xc
 11272e4:	aa1803e3 	mov	x3, x24
 11272e8:	910123e2 	add	x2, sp, #0x48
 11272ec:	aa1703e1 	mov	x1, x23
 11272f0:	97fffd0b 	bl	112671c <find_ent>
 11272f4:	2a0003f3 	mov	w19, w0
	mutex_read_unlock(&tadb_mutex);
 11272f8:	aa1503e0 	mov	x0, x21
 11272fc:	97ffb8f3 	bl	11156c8 <mutex_read_unlock>
	if (res)
 1127300:	35000293 	cbnz	w19, 1127350 <tee_tadb_ta_open+0xd0>
		goto err;

	res = ta_operation_open(OPTEE_RPC_FS_OPEN, ta->entry.file_number,
 1127304:	b9402a81 	ldr	w1, [x20, #40]
 1127308:	91002282 	add	x2, x20, #0x8
 112730c:	52800000 	mov	w0, #0x0                   	// #0
 1127310:	97fffe35 	bl	1126be4 <ta_operation_open>
 1127314:	2a0003f3 	mov	w19, w0
				&ta->fd);
	if (res)
 1127318:	350001c0 	cbnz	w0, 1127350 <tee_tadb_ta_open+0xd0>
		goto err;

	res = tadb_authenc_init(TEE_MODE_DECRYPT, &ta->entry, &ta->ctx);
 112731c:	9101e282 	add	x2, x20, #0x78
 1127320:	aa1803e1 	mov	x1, x24
 1127324:	52800020 	mov	w0, #0x1                   	// #1
 1127328:	97fffd27 	bl	11267c4 <tadb_authenc_init>
 112732c:	2a0003f3 	mov	w19, w0
	if (res)
 1127330:	35000100 	cbnz	w0, 1127350 <tee_tadb_ta_open+0xd0>
		goto err;

	*ta_ret = ta;
 1127334:	f90002d4 	str	x20, [x22]
err:
	tadb_put(ta->db);
err_free:
	free(ta);
	return res;
}
 1127338:	2a1303e0 	mov	w0, w19
 112733c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1127340:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1127344:	a94363f7 	ldp	x23, x24, [sp, #48]
 1127348:	a8c57bfd 	ldp	x29, x30, [sp], #80
 112734c:	d65f03c0 	ret
	tadb_put(ta->db);
 1127350:	f9400280 	ldr	x0, [x20]
 1127354:	97fffd44 	bl	1126864 <tadb_put>
	free(ta);
 1127358:	aa1403e0 	mov	x0, x20
 112735c:	940070a1 	bl	11435e0 <free>
	return res;
 1127360:	17fffff6 	b	1127338 <tee_tadb_ta_open+0xb8>
		return TEE_ERROR_GENERIC;
 1127364:	52bffff3 	mov	w19, #0xffff0000            	// #-65536
 1127368:	17fffff4 	b	1127338 <tee_tadb_ta_open+0xb8>
		return TEE_ERROR_OUT_OF_MEMORY;
 112736c:	129ffe73 	mov	w19, #0xffff000c            	// #-65524
 1127370:	17fffff2 	b	1127338 <tee_tadb_ta_open+0xb8>

0000000001127374 <tee_tadb_ta_get_property>:

const struct tee_tadb_property *
tee_tadb_ta_get_property(struct tee_tadb_ta_read *ta)
{
	return &ta->entry.prop;
}
 1127374:	91003000 	add	x0, x0, #0xc
 1127378:	d65f03c0 	ret

000000000112737c <tee_tadb_get_tag>:

TEE_Result tee_tadb_get_tag(struct tee_tadb_ta_read *ta, uint8_t *tag,
			    unsigned int *tag_len)
{
 112737c:	aa0003e3 	mov	x3, x0
 1127380:	aa0103e0 	mov	x0, x1
 1127384:	52800201 	mov	w1, #0x10                  	// #16
	if (!tag || *tag_len < sizeof(ta->entry.tag)) {
 1127388:	b4000080 	cbz	x0, 1127398 <tee_tadb_get_tag+0x1c>
 112738c:	b9400044 	ldr	w4, [x2]
 1127390:	71003c9f 	cmp	w4, #0xf
 1127394:	54000088 	b.hi	11273a4 <tee_tadb_get_tag+0x28>  // b.pmore
		*tag_len = sizeof(ta->entry.tag);
		return TEE_ERROR_SHORT_BUFFER;
 1127398:	129ffde0 	mov	w0, #0xffff0010            	// #-65520
		*tag_len = sizeof(ta->entry.tag);
 112739c:	b9000041 	str	w1, [x2]
	*tag_len = sizeof(ta->entry.tag);

	memcpy(tag, ta->entry.tag, sizeof(ta->entry.tag));

	return TEE_SUCCESS;
}
 11273a0:	d65f03c0 	ret
{
 11273a4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 11273a8:	910003fd 	mov	x29, sp
	*tag_len = sizeof(ta->entry.tag);
 11273ac:	b9000041 	str	w1, [x2]
	memcpy(tag, ta->entry.tag, sizeof(ta->entry.tag));
 11273b0:	9100f061 	add	x1, x3, #0x3c
 11273b4:	d2800202 	mov	x2, #0x10                  	// #16
 11273b8:	97ff6ff6 	bl	1103390 <memcpy>
	return TEE_SUCCESS;
 11273bc:	52800000 	mov	w0, #0x0                   	// #0
}
 11273c0:	a8c17bfd 	ldp	x29, x30, [sp], #16
 11273c4:	d65f03c0 	ret

00000000011273c8 <tee_tadb_ta_read>:
	}
	return res;
}

TEE_Result tee_tadb_ta_read(struct tee_tadb_ta_read *ta, void *buf, size_t *len)
{
 11273c8:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
 11273cc:	910003fd 	mov	x29, sp
 11273d0:	a90153f3 	stp	x19, x20, [sp, #16]
 11273d4:	aa0003f3 	mov	x19, x0
 11273d8:	a9025bf5 	stp	x21, x22, [sp, #32]
	TEE_Result res;
	const size_t sz = ta->entry.prop.custom_size + ta->entry.prop.bin_size;
 11273dc:	29440016 	ldp	w22, w0, [x0, #32]
{
 11273e0:	a90363f7 	stp	x23, x24, [sp, #48]
 11273e4:	aa0103f7 	mov	x23, x1
	const size_t sz = ta->entry.prop.custom_size + ta->entry.prop.bin_size;
 11273e8:	0b0002d6 	add	w22, w22, w0
{
 11273ec:	a9046bf9 	stp	x25, x26, [sp, #64]
 11273f0:	aa0203f8 	mov	x24, x2
	if (ta->ta_mobj)
 11273f4:	f9404260 	ldr	x0, [x19, #128]
	size_t l = MIN(*len, sz - ta->pos);
 11273f8:	f9400059 	ldr	x25, [x2]
 11273fc:	f9403a75 	ldr	x21, [x19, #112]
{
 1127400:	f9002bfb 	str	x27, [sp, #80]
	if (ta->ta_mobj)
 1127404:	b4000260 	cbz	x0, 1127450 <tee_tadb_ta_read+0x88>
	size_t l = MIN(*len, sz - ta->pos);
 1127408:	cb1502d5 	sub	x21, x22, x21
 112740c:	eb1902bf 	cmp	x21, x25
 1127410:	9a9992b5 	csel	x21, x21, x25, ls  // ls = plast

	res = ta_load(ta);
	if (res)
		return res;

	if (buf) {
 1127414:	b5000897 	cbnz	x23, 1127524 <tee_tadb_ta_read+0x15c>
					  ta->ta_buf + ta->pos, l, buf);
		if (res)
			return res;
	} else {
		size_t num_bytes = 0;
		size_t b_size = MIN(256U, l);
 1127418:	f10402bf 	cmp	x21, #0x100
 112741c:	d280201a 	mov	x26, #0x100                 	// #256
 1127420:	9a9a92ba 	csel	x26, x21, x26, ls  // ls = plast
		uint8_t *b = malloc(b_size);
 1127424:	aa1a03e0 	mov	x0, x26
 1127428:	9400700c 	bl	1143458 <malloc>
 112742c:	aa0003f7 	mov	x23, x0

		if (!b)
 1127430:	b4000180 	cbz	x0, 1127460 <tee_tadb_ta_read+0x98>
		size_t num_bytes = 0;
 1127434:	d2800019 	mov	x25, #0x0                   	// #0
			return TEE_ERROR_OUT_OF_MEMORY;

		while (num_bytes < l) {
 1127438:	eb15033f 	cmp	x25, x21
 112743c:	54000ae3 	b.cc	1127598 <tee_tadb_ta_read+0x1d0>  // b.lo, b.ul, b.last
 1127440:	52800014 	mov	w20, #0x0                   	// #0
			if (res)
				break;
			num_bytes += n;
		}

		free(b);
 1127444:	aa1703e0 	mov	x0, x23
 1127448:	94007066 	bl	11435e0 <free>
		if (res)
 112744c:	1400003f 	b	1127548 <tee_tadb_ta_read+0x180>
	ta->ta_mobj = thread_rpc_alloc_payload(sz);
 1127450:	aa1603e0 	mov	x0, x22
 1127454:	97ff7efe 	bl	110704c <thread_rpc_alloc_payload>
 1127458:	f9004260 	str	x0, [x19, #128]
	if (!ta->ta_mobj)
 112745c:	b5000060 	cbnz	x0, 1127468 <tee_tadb_ta_read+0xa0>
			return TEE_ERROR_OUT_OF_MEMORY;
 1127460:	129ffe74 	mov	w20, #0xffff000c            	// #-65524
 1127464:	14000028 	b	1127504 <tee_tadb_ta_read+0x13c>
	if (mobj && mobj->ops && mobj->ops->get_va)
 1127468:	f9400001 	ldr	x1, [x0]
 112746c:	b5000161 	cbnz	x1, 1127498 <tee_tadb_ta_read+0xd0>
	ta->ta_buf = mobj_get_va(ta->ta_mobj, 0);
 1127470:	f900467f 	str	xzr, [x19, #136]
	assert(ta->ta_buf);
 1127474:	d0000163 	adrp	x3, 1155000 <__func__.3826+0xa8>
 1127478:	d0000161 	adrp	x1, 1155000 <__func__.3826+0xa8>
 112747c:	913bb863 	add	x3, x3, #0xeee
 1127480:	9138f021 	add	x1, x1, #0xe3c
 1127484:	d0000160 	adrp	x0, 1155000 <__func__.3826+0xa8>
 1127488:	913aa400 	add	x0, x0, #0xea9
 112748c:	528057c2 	mov	w2, #0x2be                 	// #702
 1127490:	97ffab87 	bl	11122ac <_assert_log>
 1127494:	97ffab97 	bl	11122f0 <_assert_break>
 1127498:	f9400022 	ldr	x2, [x1]
 112749c:	b4fffea2 	cbz	x2, 1127470 <tee_tadb_ta_read+0xa8>
		return mobj->ops->get_va(mobj, offset);
 11274a0:	d2800001 	mov	x1, #0x0                   	// #0
 11274a4:	d63f0040 	blr	x2
	ta->ta_buf = mobj_get_va(ta->ta_mobj, 0);
 11274a8:	f9004660 	str	x0, [x19, #136]
	assert(ta->ta_buf);
 11274ac:	b4fffe40 	cbz	x0, 1127474 <tee_tadb_ta_read+0xac>
	struct thread_param params[] = {
 11274b0:	52800020 	mov	w0, #0x1                   	// #1
 11274b4:	b90063e0 	str	w0, [sp, #96]
 11274b8:	d2800060 	mov	x0, #0x3                   	// #3
 11274bc:	f90037e0 	str	x0, [sp, #104]
		[0] = THREAD_PARAM_VALUE(IN, OPTEE_RPC_FS_READ, ta->fd, 0),
 11274c0:	b9800a60 	ldrsw	x0, [x19, #8]
	res = thread_rpc_cmd(OPTEE_RPC_CMD_FS, ARRAY_SIZE(params), params);
 11274c4:	d2800041 	mov	x1, #0x2                   	// #2
		[0] = THREAD_PARAM_VALUE(IN, OPTEE_RPC_FS_READ, ta->fd, 0),
 11274c8:	f9003be0 	str	x0, [sp, #112]
	res = thread_rpc_cmd(OPTEE_RPC_CMD_FS, ARRAY_SIZE(params), params);
 11274cc:	910183e2 	add	x2, sp, #0x60
	struct thread_param params[] = {
 11274d0:	528000a0 	mov	w0, #0x5                   	// #5
 11274d4:	b90083e0 	str	w0, [sp, #128]
 11274d8:	f9404260 	ldr	x0, [x19, #128]
 11274dc:	f9003fff 	str	xzr, [sp, #120]
 11274e0:	a908dbff 	stp	xzr, x22, [sp, #136]
 11274e4:	f9004fe0 	str	x0, [sp, #152]
	res = thread_rpc_cmd(OPTEE_RPC_CMD_FS, ARRAY_SIZE(params), params);
 11274e8:	2a0103e0 	mov	w0, w1
 11274ec:	97ff7e9c 	bl	1106f5c <thread_rpc_cmd>
 11274f0:	2a0003f4 	mov	w20, w0
	if (res) {
 11274f4:	34fff8a0 	cbz	w0, 1127408 <tee_tadb_ta_read+0x40>
		thread_rpc_free_payload(ta->ta_mobj);
 11274f8:	f9404260 	ldr	x0, [x19, #128]
 11274fc:	97ff7ee7 	bl	1107098 <thread_rpc_free_payload>
		ta->ta_mobj = NULL;
 1127500:	f900427f 	str	xzr, [x19, #128]
		if (res)
			return res;
	}
	*len = l;
	return TEE_SUCCESS;
}
 1127504:	2a1403e0 	mov	w0, w20
 1127508:	a94153f3 	ldp	x19, x20, [sp, #16]
 112750c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1127510:	a94363f7 	ldp	x23, x24, [sp, #48]
 1127514:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1127518:	f9402bfb 	ldr	x27, [sp, #80]
 112751c:	a8ca7bfd 	ldp	x29, x30, [sp], #160
 1127520:	d65f03c0 	ret
					  ta->ta_buf + ta->pos, l, buf);
 1127524:	f9403a60 	ldr	x0, [x19, #112]
		res = tadb_update_payload(ta->ctx, TEE_MODE_DECRYPT,
 1127528:	aa1703e4 	mov	x4, x23
					  ta->ta_buf + ta->pos, l, buf);
 112752c:	f9404662 	ldr	x2, [x19, #136]
		res = tadb_update_payload(ta->ctx, TEE_MODE_DECRYPT,
 1127530:	aa1503e3 	mov	x3, x21
 1127534:	52800021 	mov	w1, #0x1                   	// #1
 1127538:	8b000042 	add	x2, x2, x0
 112753c:	f9403e60 	ldr	x0, [x19, #120]
 1127540:	97fffd38 	bl	1126a20 <tadb_update_payload>
 1127544:	2a0003f4 	mov	w20, w0
		if (res)
 1127548:	35fffdf4 	cbnz	w20, 1127504 <tee_tadb_ta_read+0x13c>
	ta->pos += l;
 112754c:	f9403a60 	ldr	x0, [x19, #112]
 1127550:	8b0002a0 	add	x0, x21, x0
 1127554:	f9003a60 	str	x0, [x19, #112]
	if (ta->pos == sz) {
 1127558:	eb16001f 	cmp	x0, x22
 112755c:	54000181 	b.ne	112758c <tee_tadb_ta_read+0x1c4>  // b.any
		res = crypto_authenc_dec_final(ta->ctx, NULL, 0, NULL, &dl,
 1127560:	f9403e60 	ldr	x0, [x19, #120]
 1127564:	9100f265 	add	x5, x19, #0x3c
 1127568:	910183e4 	add	x4, sp, #0x60
 112756c:	d2800206 	mov	x6, #0x10                  	// #16
 1127570:	d2800003 	mov	x3, #0x0                   	// #0
 1127574:	d2800002 	mov	x2, #0x0                   	// #0
 1127578:	d2800001 	mov	x1, #0x0                   	// #0
		size_t dl = 0;
 112757c:	f90033ff 	str	xzr, [sp, #96]
		res = crypto_authenc_dec_final(ta->ctx, NULL, 0, NULL, &dl,
 1127580:	97ff99ac 	bl	110dc30 <crypto_authenc_dec_final>
 1127584:	2a0003f4 	mov	w20, w0
		if (res)
 1127588:	35fffbe0 	cbnz	w0, 1127504 <tee_tadb_ta_read+0x13c>
	return TEE_SUCCESS;
 112758c:	52800014 	mov	w20, #0x0                   	// #0
	*len = l;
 1127590:	f9000315 	str	x21, [x24]
	return TEE_SUCCESS;
 1127594:	17ffffdc 	b	1127504 <tee_tadb_ta_read+0x13c>
						  ta->ta_buf + ta->pos +
 1127598:	f9403a60 	ldr	x0, [x19, #112]
			size_t n = MIN(b_size, l - num_bytes);
 112759c:	cb1902bb 	sub	x27, x21, x25
						  ta->ta_buf + ta->pos +
 11275a0:	f9404662 	ldr	x2, [x19, #136]
 11275a4:	8b000320 	add	x0, x25, x0
			size_t n = MIN(b_size, l - num_bytes);
 11275a8:	eb1a037f 	cmp	x27, x26
			res = tadb_update_payload(ta->ctx, TEE_MODE_DECRYPT,
 11275ac:	aa1703e4 	mov	x4, x23
 11275b0:	8b000042 	add	x2, x2, x0
			size_t n = MIN(b_size, l - num_bytes);
 11275b4:	9a9a937b 	csel	x27, x27, x26, ls  // ls = plast
			res = tadb_update_payload(ta->ctx, TEE_MODE_DECRYPT,
 11275b8:	f9403e60 	ldr	x0, [x19, #120]
 11275bc:	aa1b03e3 	mov	x3, x27
 11275c0:	52800021 	mov	w1, #0x1                   	// #1
 11275c4:	97fffd17 	bl	1126a20 <tadb_update_payload>
 11275c8:	2a0003f4 	mov	w20, w0
			if (res)
 11275cc:	35fff3c0 	cbnz	w0, 1127444 <tee_tadb_ta_read+0x7c>
			num_bytes += n;
 11275d0:	8b1b0339 	add	x25, x25, x27
 11275d4:	17ffff99 	b	1127438 <tee_tadb_ta_read+0x70>

00000000011275d8 <tee_tadb_ta_close>:

void tee_tadb_ta_close(struct tee_tadb_ta_read *ta)
{
 11275d8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 11275dc:	910003fd 	mov	x29, sp
 11275e0:	f9000bf3 	str	x19, [sp, #16]
 11275e4:	aa0003f3 	mov	x19, x0
	crypto_authenc_final(ta->ctx);
 11275e8:	f9403c00 	ldr	x0, [x0, #120]
 11275ec:	97ff99b4 	bl	110dcbc <crypto_authenc_final>
	crypto_authenc_free_ctx(ta->ctx);
 11275f0:	f9403e60 	ldr	x0, [x19, #120]
 11275f4:	97ff99bd 	bl	110dce8 <crypto_authenc_free_ctx>
	if (ta->ta_mobj)
 11275f8:	f9404260 	ldr	x0, [x19, #128]
 11275fc:	b4000040 	cbz	x0, 1127604 <tee_tadb_ta_close+0x2c>
		thread_rpc_free_payload(ta->ta_mobj);
 1127600:	97ff7ea6 	bl	1107098 <thread_rpc_free_payload>
	tee_fs_rpc_close(OPTEE_RPC_CMD_FS, ta->fd);
 1127604:	b9400a61 	ldr	w1, [x19, #8]
 1127608:	52800040 	mov	w0, #0x2                   	// #2
 112760c:	97fff8f7 	bl	11259e8 <tee_fs_rpc_close>
	tadb_put(ta->db);
 1127610:	f9400260 	ldr	x0, [x19]
 1127614:	97fffc94 	bl	1126864 <tadb_put>
	free(ta);
 1127618:	aa1303e0 	mov	x0, x19
}
 112761c:	f9400bf3 	ldr	x19, [sp, #16]
 1127620:	a8c27bfd 	ldp	x29, x30, [sp], #32
	free(ta);
 1127624:	14006fef 	b	11435e0 <free>

0000000001127628 <pta_socket_close_session>:

	return TEE_SUCCESS;
}

static void pta_socket_close_session(void *sess_ctx)
{
 1127628:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
	TEE_Result res;
	struct thread_param tpm = {
 112762c:	d2800041 	mov	x1, #0x2                   	// #2
{
 1127630:	910003fd 	mov	x29, sp
	struct thread_param tpm = {
 1127634:	a9027fff 	stp	xzr, xzr, [sp, #32]
		.attr = THREAD_PARAM_ATTR_VALUE_IN, .u.value = {
			.a = OPTEE_RPC_SOCKET_CLOSE_ALL, .b = (vaddr_t)sess_ctx,
		},
	};

	res = thread_rpc_cmd(OPTEE_RPC_CMD_SOCKET, 1, &tpm);
 1127638:	910083e2 	add	x2, sp, #0x20
	struct thread_param tpm = {
 112763c:	a9037fff 	stp	xzr, xzr, [sp, #48]
{
 1127640:	f9000bf3 	str	x19, [sp, #16]
	struct thread_param tpm = {
 1127644:	52800033 	mov	w19, #0x1                   	// #1
 1127648:	b90023f3 	str	w19, [sp, #32]
 112764c:	a90283e1 	stp	x1, x0, [sp, #40]
	res = thread_rpc_cmd(OPTEE_RPC_CMD_SOCKET, 1, &tpm);
 1127650:	d2800021 	mov	x1, #0x1                   	// #1
 1127654:	52800140 	mov	w0, #0xa                   	// #10
 1127658:	97ff7e41 	bl	1106f5c <thread_rpc_cmd>
	if (res != TEE_SUCCESS)
 112765c:	34000140 	cbz	w0, 1127684 <pta_socket_close_session+0x5c>
 1127660:	2a0003e5 	mov	w5, w0
		DMSG("OPTEE_RPC_SOCKET_CLOSE_ALL failed: %#" PRIx32, res);
 1127664:	d0000164 	adrp	x4, 1155000 <__func__.3826+0xa8>
 1127668:	d0000160 	adrp	x0, 1155000 <__func__.3826+0xa8>
 112766c:	913bf084 	add	x4, x4, #0xefc
 1127670:	2a1303e3 	mov	w3, w19
 1127674:	913e3000 	add	x0, x0, #0xf8c
 1127678:	52800062 	mov	w2, #0x3                   	// #3
 112767c:	52801f41 	mov	w1, #0xfa                  	// #250
 1127680:	940075b1 	bl	1144d44 <trace_printf>
}
 1127684:	f9400bf3 	ldr	x19, [sp, #16]
 1127688:	a8c47bfd 	ldp	x29, x30, [sp], #64
 112768c:	d65f03c0 	ret

0000000001127690 <pta_socket_open_session>:
{
 1127690:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1127694:	910003fd 	mov	x29, sp
 1127698:	a90153f3 	stp	x19, x20, [sp, #16]
 112769c:	aa0203f4 	mov	x20, x2
	struct ts_session *s = ts_get_calling_session();
 11276a0:	97ffb4dd 	bl	1114a14 <ts_get_calling_session>
	if (!s || !is_user_ta_ctx(s->ctx))
 11276a4:	b50000a0 	cbnz	x0, 11276b8 <pta_socket_open_session+0x28>
		return TEE_ERROR_ACCESS_DENIED;
 11276a8:	129fffc0 	mov	w0, #0xffff0001            	// #-65535
}
 11276ac:	a94153f3 	ldp	x19, x20, [sp, #16]
 11276b0:	a8c27bfd 	ldp	x29, x30, [sp], #32
 11276b4:	d65f03c0 	ret
 11276b8:	aa0003f3 	mov	x19, x0
	if (!s || !is_user_ta_ctx(s->ctx))
 11276bc:	f9400800 	ldr	x0, [x0, #16]
 11276c0:	97ffbacb 	bl	11161ec <is_user_ta_ctx>
 11276c4:	72001c1f 	tst	w0, #0xff
 11276c8:	54ffff00 	b.eq	11276a8 <pta_socket_open_session+0x18>  // b.none
	*sess_ctx = (void *)(vaddr_t)get_instance_id(s);
 11276cc:	f9400a60 	ldr	x0, [x19, #16]
	return sess->ctx->ops->get_instance_id(sess->ctx);
 11276d0:	f9400801 	ldr	x1, [x0, #16]
 11276d4:	f9401821 	ldr	x1, [x1, #48]
 11276d8:	d63f0020 	blr	x1
	*sess_ctx = (void *)(vaddr_t)get_instance_id(s);
 11276dc:	2a0003e0 	mov	w0, w0
 11276e0:	f9000280 	str	x0, [x20]
	return TEE_SUCCESS;
 11276e4:	52800000 	mov	w0, #0x0                   	// #0
 11276e8:	17fffff1 	b	11276ac <pta_socket_open_session+0x1c>

00000000011276ec <pta_socket_invoke_command>:

static TEE_Result pta_socket_invoke_command(void *sess_ctx, uint32_t cmd_id,
			uint32_t param_types, TEE_Param params[TEE_NUM_PARAMS])
{
 11276ec:	2a0103e4 	mov	w4, w1
 11276f0:	2a0203e1 	mov	w1, w2
	if (cmd_id < ARRAY_SIZE(ta_funcs) && ta_funcs[cmd_id])
 11276f4:	7100149f 	cmp	w4, #0x5
{
 11276f8:	aa0303e2 	mov	x2, x3
	if (cmd_id < ARRAY_SIZE(ta_funcs) && ta_funcs[cmd_id])
 11276fc:	540000e8 	b.hi	1127718 <pta_socket_invoke_command+0x2c>  // b.pmore
 1127700:	900001a3 	adrp	x3, 115b000 <__vcore_unpg_rw_start>
 1127704:	913ba063 	add	x3, x3, #0xee8
 1127708:	f8645863 	ldr	x3, [x3, w4, uxtw #3]
 112770c:	b4000063 	cbz	x3, 1127718 <pta_socket_invoke_command+0x2c>
		return ta_funcs[cmd_id]((vaddr_t)sess_ctx, param_types, params);
 1127710:	aa0303f0 	mov	x16, x3
 1127714:	d61f0200 	br	x16

	return TEE_ERROR_NOT_IMPLEMENTED;
}
 1127718:	129ffec0 	mov	w0, #0xffff0009            	// #-65527
 112771c:	d65f03c0 	ret

0000000001127720 <socket_ioctl>:
{
 1127720:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
	if (exp_pt != param_types) {
 1127724:	7101c43f 	cmp	w1, #0x71
{
 1127728:	910003fd 	mov	x29, sp
 112772c:	a90153f3 	stp	x19, x20, [sp, #16]
 1127730:	a9025bf5 	stp	x21, x22, [sp, #32]
	if (exp_pt != param_types) {
 1127734:	54000220 	b.eq	1127778 <socket_ioctl+0x58>  // b.none
		return TEE_ERROR_BAD_PARAMETERS;
 1127738:	129fff34 	mov	w20, #0xffff0006            	// #-65530
 112773c:	2a0103e5 	mov	w5, w1
		DMSG("got param_types 0x%x, expected 0x%x",
 1127740:	52800e26 	mov	w6, #0x71                  	// #113
 1127744:	d0000164 	adrp	x4, 1155000 <__func__.3826+0xa8>
 1127748:	52800023 	mov	w3, #0x1                   	// #1
 112774c:	913c8c84 	add	x4, x4, #0xf23
 1127750:	52800062 	mov	w2, #0x3                   	// #3
 1127754:	52801601 	mov	w1, #0xb0                  	// #176
 1127758:	d0000160 	adrp	x0, 1155000 <__func__.3826+0xa8>
 112775c:	913dfc00 	add	x0, x0, #0xf7f
 1127760:	94007579 	bl	1144d44 <trace_printf>
}
 1127764:	2a1403e0 	mov	w0, w20
 1127768:	a94153f3 	ldp	x19, x20, [sp, #16]
 112776c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1127770:	a8ca7bfd 	ldp	x29, x30, [sp], #160
 1127774:	d65f03c0 	ret
 1127778:	aa0203f3 	mov	x19, x2
					params[1].memref.size, &mobj);
 112777c:	91004055 	add	x21, x2, #0x10
	va = thread_rpc_shm_cache_alloc(THREAD_SHM_CACHE_USER_SOCKET,
 1127780:	b9401842 	ldr	w2, [x2, #24]
 1127784:	2a0003f4 	mov	w20, w0
 1127788:	9100e3e3 	add	x3, sp, #0x38
 112778c:	52800001 	mov	w1, #0x0                   	// #0
 1127790:	52800000 	mov	w0, #0x0                   	// #0
 1127794:	97ff7b13 	bl	11063e0 <thread_rpc_shm_cache_alloc>
 1127798:	aa0003f6 	mov	x22, x0
	if (!va)
 112779c:	b4000460 	cbz	x0, 1127828 <socket_ioctl+0x108>
	memcpy(va, params[1].memref.buffer, params[1].memref.size);
 11277a0:	b9400aa2 	ldr	w2, [x21, #8]
 11277a4:	f9400a61 	ldr	x1, [x19, #16]
 11277a8:	97ff6efa 	bl	1103390 <memcpy>
	struct thread_param tpm[3] = {
 11277ac:	f90037ff 	str	xzr, [sp, #104]
 11277b0:	52800020 	mov	w0, #0x1                   	// #1
 11277b4:	d28000a1 	mov	x1, #0x5                   	// #5
 11277b8:	b90043e0 	str	w0, [sp, #64]
	res = thread_rpc_cmd(OPTEE_RPC_CMD_SOCKET, 3, tpm);
 11277bc:	910103e2 	add	x2, sp, #0x40
	struct thread_param tpm[3] = {
 11277c0:	a904d3e1 	stp	x1, x20, [sp, #72]
 11277c4:	b90083e0 	str	w0, [sp, #128]
		[2] = THREAD_PARAM_VALUE(IN,
 11277c8:	29400261 	ldp	w1, w0, [x19]
		[0] = THREAD_PARAM_VALUE(IN, OPTEE_RPC_SOCKET_IOCTL,
 11277cc:	f9002fe1 	str	x1, [sp, #88]
	struct thread_param tpm[3] = {
 11277d0:	528000c1 	mov	w1, #0x6                   	// #6
 11277d4:	b90063e1 	str	w1, [sp, #96]
		[1] = THREAD_PARAM_MEMREF(INOUT, mobj, 0,
 11277d8:	b9400aa1 	ldr	w1, [x21, #8]
 11277dc:	f9003be1 	str	x1, [sp, #112]
	struct thread_param tpm[3] = {
 11277e0:	f9401fe1 	ldr	x1, [sp, #56]
 11277e4:	f9003fe1 	str	x1, [sp, #120]
	res = thread_rpc_cmd(OPTEE_RPC_CMD_SOCKET, 3, tpm);
 11277e8:	d2800061 	mov	x1, #0x3                   	// #3
		[2] = THREAD_PARAM_VALUE(IN,
 11277ec:	f90047e0 	str	x0, [sp, #136]
	res = thread_rpc_cmd(OPTEE_RPC_CMD_SOCKET, 3, tpm);
 11277f0:	52800140 	mov	w0, #0xa                   	// #10
	struct thread_param tpm[3] = {
 11277f4:	a9097fff 	stp	xzr, xzr, [sp, #144]
	res = thread_rpc_cmd(OPTEE_RPC_CMD_SOCKET, 3, tpm);
 11277f8:	97ff7dd9 	bl	1106f5c <thread_rpc_cmd>
	if (tpm[1].u.memref.size <= params[1].memref.size)
 11277fc:	f9403be2 	ldr	x2, [sp, #112]
	res = thread_rpc_cmd(OPTEE_RPC_CMD_SOCKET, 3, tpm);
 1127800:	2a0003f4 	mov	w20, w0
	if (tpm[1].u.memref.size <= params[1].memref.size)
 1127804:	b9400aa0 	ldr	w0, [x21, #8]
 1127808:	eb00005f 	cmp	x2, x0
 112780c:	54000088 	b.hi	112781c <socket_ioctl+0xfc>  // b.pmore
		memcpy(params[1].memref.buffer, va, tpm[1].u.memref.size);
 1127810:	f9400a60 	ldr	x0, [x19, #16]
 1127814:	aa1603e1 	mov	x1, x22
 1127818:	97ff6ede 	bl	1103390 <memcpy>
	params[1].memref.size = tpm[1].u.memref.size;
 112781c:	f9403be0 	ldr	x0, [sp, #112]
 1127820:	b9000aa0 	str	w0, [x21, #8]
	return res;
 1127824:	17ffffd0 	b	1127764 <socket_ioctl+0x44>
		return TEE_ERROR_OUT_OF_MEMORY;
 1127828:	129ffe74 	mov	w20, #0xffff000c            	// #-65524
 112782c:	17ffffce 	b	1127764 <socket_ioctl+0x44>

0000000001127830 <socket_recv>:
{
 1127830:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
	if (exp_pt != param_types) {
 1127834:	7101843f 	cmp	w1, #0x61
{
 1127838:	910003fd 	mov	x29, sp
 112783c:	a90153f3 	stp	x19, x20, [sp, #16]
 1127840:	a9025bf5 	stp	x21, x22, [sp, #32]
	if (exp_pt != param_types) {
 1127844:	54000220 	b.eq	1127888 <socket_recv+0x58>  // b.none
		return TEE_ERROR_BAD_PARAMETERS;
 1127848:	129fff34 	mov	w20, #0xffff0006            	// #-65530
 112784c:	2a0103e5 	mov	w5, w1
		DMSG("got param_types 0x%x, expected 0x%x",
 1127850:	52800c26 	mov	w6, #0x61                  	// #97
 1127854:	d0000164 	adrp	x4, 1155000 <__func__.3826+0xa8>
 1127858:	52800023 	mov	w3, #0x1                   	// #1
 112785c:	913c8c84 	add	x4, x4, #0xf23
 1127860:	52800062 	mov	w2, #0x3                   	// #3
 1127864:	528010c1 	mov	w1, #0x86                  	// #134
 1127868:	d0000160 	adrp	x0, 1155000 <__func__.3826+0xa8>
 112786c:	913dcc00 	add	x0, x0, #0xf73
 1127870:	94007535 	bl	1144d44 <trace_printf>
}
 1127874:	2a1403e0 	mov	w0, w20
 1127878:	a94153f3 	ldp	x19, x20, [sp, #16]
 112787c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1127880:	a8ca7bfd 	ldp	x29, x30, [sp], #160
 1127884:	d65f03c0 	ret
 1127888:	aa0203f3 	mov	x19, x2
	va = thread_rpc_shm_cache_alloc(THREAD_SHM_CACHE_USER_SOCKET,
 112788c:	b9401842 	ldr	w2, [x2, #24]
 1127890:	2a0003f4 	mov	w20, w0
 1127894:	9100e3e3 	add	x3, sp, #0x38
 1127898:	52800001 	mov	w1, #0x0                   	// #0
 112789c:	52800000 	mov	w0, #0x0                   	// #0
 11278a0:	97ff7ad0 	bl	11063e0 <thread_rpc_shm_cache_alloc>
 11278a4:	aa0003f5 	mov	x21, x0
	if (!va)
 11278a8:	b4000400 	cbz	x0, 1127928 <socket_recv+0xf8>
	struct thread_param tpm[3] = {
 11278ac:	52800020 	mov	w0, #0x1                   	// #1
 11278b0:	d2800081 	mov	x1, #0x4                   	// #4
 11278b4:	b90043e0 	str	w0, [sp, #64]
	res = thread_rpc_cmd(OPTEE_RPC_CMD_SOCKET, 3, tpm);
 11278b8:	910103e2 	add	x2, sp, #0x40
	struct thread_param tpm[3] = {
 11278bc:	a904d3e1 	stp	x1, x20, [sp, #72]
 11278c0:	b90083e0 	str	w0, [sp, #128]
		[2] = THREAD_PARAM_VALUE(IN, params[0].value.b /* timeout */,
 11278c4:	29400261 	ldp	w1, w0, [x19]
		[0] = THREAD_PARAM_VALUE(IN, OPTEE_RPC_SOCKET_RECV, instance_id,
 11278c8:	f9002fe1 	str	x1, [sp, #88]
	struct thread_param tpm[3] = {
 11278cc:	528000a1 	mov	w1, #0x5                   	// #5
 11278d0:	b90063e1 	str	w1, [sp, #96]
		[1] = THREAD_PARAM_MEMREF(OUT, mobj, 0, params[1].memref.size),
 11278d4:	b9401a61 	ldr	w1, [x19, #24]
 11278d8:	f9003be1 	str	x1, [sp, #112]
	struct thread_param tpm[3] = {
 11278dc:	f9401fe1 	ldr	x1, [sp, #56]
 11278e0:	f90037ff 	str	xzr, [sp, #104]
 11278e4:	f9003fe1 	str	x1, [sp, #120]
	res = thread_rpc_cmd(OPTEE_RPC_CMD_SOCKET, 3, tpm);
 11278e8:	d2800061 	mov	x1, #0x3                   	// #3
		[2] = THREAD_PARAM_VALUE(IN, params[0].value.b /* timeout */,
 11278ec:	f90047e0 	str	x0, [sp, #136]
	res = thread_rpc_cmd(OPTEE_RPC_CMD_SOCKET, 3, tpm);
 11278f0:	52800140 	mov	w0, #0xa                   	// #10
	struct thread_param tpm[3] = {
 11278f4:	a9097fff 	stp	xzr, xzr, [sp, #144]
	res = thread_rpc_cmd(OPTEE_RPC_CMD_SOCKET, 3, tpm);
 11278f8:	97ff7d99 	bl	1106f5c <thread_rpc_cmd>
 11278fc:	2a0003f4 	mov	w20, w0
	if (tpm[1].u.memref.size > params[1].memref.size)
 1127900:	f9403be2 	ldr	x2, [sp, #112]
 1127904:	b9401a60 	ldr	w0, [x19, #24]
 1127908:	eb00005f 	cmp	x2, x0
 112790c:	54000128 	b.hi	1127930 <socket_recv+0x100>  // b.pmore
	params[1].memref.size = tpm[1].u.memref.size;
 1127910:	b9001a62 	str	w2, [x19, #24]
	if (params[1].memref.size)
 1127914:	b4fffb02 	cbz	x2, 1127874 <socket_recv+0x44>
		memcpy(params[1].memref.buffer, va, params[1].memref.size);
 1127918:	f9400a60 	ldr	x0, [x19, #16]
 112791c:	aa1503e1 	mov	x1, x21
 1127920:	97ff6e9c 	bl	1103390 <memcpy>
 1127924:	17ffffd4 	b	1127874 <socket_recv+0x44>
		return TEE_ERROR_OUT_OF_MEMORY;
 1127928:	129ffe74 	mov	w20, #0xffff000c            	// #-65524
 112792c:	17ffffd2 	b	1127874 <socket_recv+0x44>
		return TEE_ERROR_GENERIC;
 1127930:	52bffff4 	mov	w20, #0xffff0000            	// #-65536
 1127934:	17ffffd0 	b	1127874 <socket_recv+0x44>

0000000001127938 <socket_send>:
{
 1127938:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
	if (exp_pt != param_types) {
 112793c:	7109443f 	cmp	w1, #0x251
{
 1127940:	910003fd 	mov	x29, sp
 1127944:	a90153f3 	stp	x19, x20, [sp, #16]
 1127948:	f90013f5 	str	x21, [sp, #32]
	if (exp_pt != param_types) {
 112794c:	54000200 	b.eq	112798c <socket_send+0x54>  // b.none
 1127950:	2a0103e5 	mov	w5, w1
		DMSG("got param_types 0x%x, expected 0x%x",
 1127954:	52804a26 	mov	w6, #0x251                 	// #593
 1127958:	d0000164 	adrp	x4, 1155000 <__func__.3826+0xa8>
 112795c:	52800023 	mov	w3, #0x1                   	// #1
 1127960:	913c8c84 	add	x4, x4, #0xf23
 1127964:	52800062 	mov	w2, #0x3                   	// #3
 1127968:	52800be1 	mov	w1, #0x5f                  	// #95
 112796c:	d0000160 	adrp	x0, 1155000 <__func__.3826+0xa8>
 1127970:	913d9c00 	add	x0, x0, #0xf67
 1127974:	940074f4 	bl	1144d44 <trace_printf>
		return TEE_ERROR_BAD_PARAMETERS;
 1127978:	129fff20 	mov	w0, #0xffff0006            	// #-65530
}
 112797c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1127980:	f94013f5 	ldr	x21, [sp, #32]
 1127984:	a8ca7bfd 	ldp	x29, x30, [sp], #160
 1127988:	d65f03c0 	ret
 112798c:	aa0203f3 	mov	x19, x2
	va = thread_rpc_shm_cache_alloc(THREAD_SHM_CACHE_USER_SOCKET,
 1127990:	b9401842 	ldr	w2, [x2, #24]
 1127994:	2a0003f4 	mov	w20, w0
 1127998:	9100e3e3 	add	x3, sp, #0x38
 112799c:	52800001 	mov	w1, #0x0                   	// #0
 11279a0:	52800000 	mov	w0, #0x0                   	// #0
 11279a4:	97ff7a8f 	bl	11063e0 <thread_rpc_shm_cache_alloc>
	if (!va)
 11279a8:	b4000360 	cbz	x0, 1127a14 <socket_send+0xdc>
	memcpy(va, params[1].memref.buffer, params[1].memref.size);
 11279ac:	b9401a62 	ldr	w2, [x19, #24]
 11279b0:	f9400a61 	ldr	x1, [x19, #16]
 11279b4:	97ff6e77 	bl	1103390 <memcpy>
	struct thread_param tpm[3] = {
 11279b8:	f90037ff 	str	xzr, [sp, #104]
 11279bc:	52800020 	mov	w0, #0x1                   	// #1
 11279c0:	b90043e0 	str	w0, [sp, #64]
		[0] = THREAD_PARAM_VALUE(IN, OPTEE_RPC_SOCKET_SEND, instance_id,
 11279c4:	b9400260 	ldr	w0, [x19]
	struct thread_param tpm[3] = {
 11279c8:	d2800061 	mov	x1, #0x3                   	// #3
		[0] = THREAD_PARAM_VALUE(IN, OPTEE_RPC_SOCKET_SEND, instance_id,
 11279cc:	f9002fe0 	str	x0, [sp, #88]
	res = thread_rpc_cmd(OPTEE_RPC_CMD_SOCKET, 3, tpm);
 11279d0:	910103e2 	add	x2, sp, #0x40
	struct thread_param tpm[3] = {
 11279d4:	52800080 	mov	w0, #0x4                   	// #4
 11279d8:	b90063e0 	str	w0, [sp, #96]
		[1] = THREAD_PARAM_MEMREF(IN, mobj, 0, params[1].memref.size),
 11279dc:	b9401a60 	ldr	w0, [x19, #24]
 11279e0:	f9003be0 	str	x0, [sp, #112]
	struct thread_param tpm[3] = {
 11279e4:	f9401fe0 	ldr	x0, [sp, #56]
 11279e8:	f9003fe0 	str	x0, [sp, #120]
		[2] = THREAD_PARAM_VALUE(INOUT, params[0].value.b, /* timeout */
 11279ec:	b9400660 	ldr	w0, [x19, #4]
	struct thread_param tpm[3] = {
 11279f0:	a904d3e1 	stp	x1, x20, [sp, #72]
 11279f4:	b90083e1 	str	w1, [sp, #128]
		[2] = THREAD_PARAM_VALUE(INOUT, params[0].value.b, /* timeout */
 11279f8:	f90047e0 	str	x0, [sp, #136]
	res = thread_rpc_cmd(OPTEE_RPC_CMD_SOCKET, 3, tpm);
 11279fc:	52800140 	mov	w0, #0xa                   	// #10
	struct thread_param tpm[3] = {
 1127a00:	a9097fff 	stp	xzr, xzr, [sp, #144]
	res = thread_rpc_cmd(OPTEE_RPC_CMD_SOCKET, 3, tpm);
 1127a04:	97ff7d56 	bl	1106f5c <thread_rpc_cmd>
	params[2].value.a = tpm[2].u.value.b; /* transmitted bytes */
 1127a08:	f9404be1 	ldr	x1, [sp, #144]
 1127a0c:	b9002261 	str	w1, [x19, #32]
	return res;
 1127a10:	17ffffdb 	b	112797c <socket_send+0x44>
		return TEE_ERROR_OUT_OF_MEMORY;
 1127a14:	129ffe60 	mov	w0, #0xffff000c            	// #-65524
 1127a18:	17ffffd9 	b	112797c <socket_send+0x44>

0000000001127a1c <socket_close>:
{
 1127a1c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1127a20:	2a0103e5 	mov	w5, w1
	if (exp_pt != param_types) {
 1127a24:	7100043f 	cmp	w1, #0x1
{
 1127a28:	910003fd 	mov	x29, sp
	if (exp_pt != param_types) {
 1127a2c:	540001a0 	b.eq	1127a60 <socket_close+0x44>  // b.none
		DMSG("got param_types 0x%x, expected 0x%x",
 1127a30:	52800026 	mov	w6, #0x1                   	// #1
 1127a34:	d0000164 	adrp	x4, 1155000 <__func__.3826+0xa8>
 1127a38:	2a0603e3 	mov	w3, w6
 1127a3c:	913c8c84 	add	x4, x4, #0xf23
 1127a40:	52800062 	mov	w2, #0x3                   	// #3
 1127a44:	528008e1 	mov	w1, #0x47                  	// #71
 1127a48:	d0000160 	adrp	x0, 1155000 <__func__.3826+0xa8>
 1127a4c:	913d6800 	add	x0, x0, #0xf5a
 1127a50:	940074bd 	bl	1144d44 <trace_printf>
 1127a54:	129fff20 	mov	w0, #0xffff0006            	// #-65530
}
 1127a58:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1127a5c:	d65f03c0 	ret
	struct thread_param tpm = THREAD_PARAM_VALUE(IN, OPTEE_RPC_SOCKET_CLOSE,
 1127a60:	2a0003e0 	mov	w0, w0
 1127a64:	d2800021 	mov	x1, #0x1                   	// #1
 1127a68:	a90183e1 	stp	x1, x0, [sp, #24]
 1127a6c:	b9400040 	ldr	w0, [x2]
	return thread_rpc_cmd(OPTEE_RPC_CMD_SOCKET, 1, &tpm);
 1127a70:	910043e2 	add	x2, sp, #0x10
	struct thread_param tpm = THREAD_PARAM_VALUE(IN, OPTEE_RPC_SOCKET_CLOSE,
 1127a74:	b90013e5 	str	w5, [sp, #16]
 1127a78:	f90017e0 	str	x0, [sp, #40]
	return thread_rpc_cmd(OPTEE_RPC_CMD_SOCKET, 1, &tpm);
 1127a7c:	52800140 	mov	w0, #0xa                   	// #10
 1127a80:	97ff7d37 	bl	1106f5c <thread_rpc_cmd>
 1127a84:	17fffff5 	b	1127a58 <socket_close+0x3c>

0000000001127a88 <socket_open>:
{
 1127a88:	a9b47bfd 	stp	x29, x30, [sp, #-192]!
	if (exp_pt != param_types) {
 1127a8c:	52842a26 	mov	w6, #0x2151                	// #8529
 1127a90:	6b06003f 	cmp	w1, w6
{
 1127a94:	910003fd 	mov	x29, sp
 1127a98:	a90153f3 	stp	x19, x20, [sp, #16]
 1127a9c:	f90013f5 	str	x21, [sp, #32]
	if (exp_pt != param_types) {
 1127aa0:	540001e0 	b.eq	1127adc <socket_open+0x54>  // b.none
 1127aa4:	2a0103e5 	mov	w5, w1
		DMSG("got param_types 0x%x, expected 0x%x",
 1127aa8:	d0000164 	adrp	x4, 1155000 <__func__.3826+0xa8>
 1127aac:	52800023 	mov	w3, #0x1                   	// #1
 1127ab0:	913c8c84 	add	x4, x4, #0xf23
 1127ab4:	52800062 	mov	w2, #0x3                   	// #3
 1127ab8:	528003e1 	mov	w1, #0x1f                  	// #31
 1127abc:	d0000160 	adrp	x0, 1155000 <__func__.3826+0xa8>
 1127ac0:	913d3800 	add	x0, x0, #0xf4e
 1127ac4:	940074a0 	bl	1144d44 <trace_printf>
		return TEE_ERROR_BAD_PARAMETERS;
 1127ac8:	129fff20 	mov	w0, #0xffff0006            	// #-65530
}
 1127acc:	a94153f3 	ldp	x19, x20, [sp, #16]
 1127ad0:	f94013f5 	ldr	x21, [sp, #32]
 1127ad4:	a8cc7bfd 	ldp	x29, x30, [sp], #192
 1127ad8:	d65f03c0 	ret
 1127adc:	aa0203f3 	mov	x19, x2
	va = thread_rpc_shm_cache_alloc(THREAD_SHM_CACHE_USER_SOCKET,
 1127ae0:	b9401842 	ldr	w2, [x2, #24]
 1127ae4:	2a0003f4 	mov	w20, w0
 1127ae8:	9100e3e3 	add	x3, sp, #0x38
 1127aec:	52800001 	mov	w1, #0x0                   	// #0
 1127af0:	52800000 	mov	w0, #0x0                   	// #0
 1127af4:	97ff7a3b 	bl	11063e0 <thread_rpc_shm_cache_alloc>
	if (!va)
 1127af8:	b4000440 	cbz	x0, 1127b80 <socket_open+0xf8>
	memcpy(va, params[1].memref.buffer, params[1].memref.size);
 1127afc:	b9401a62 	ldr	w2, [x19, #24]
 1127b00:	f9400a61 	ldr	x1, [x19, #16]
 1127b04:	97ff6e23 	bl	1103390 <memcpy>
	struct thread_param tpm[4] = {
 1127b08:	a904d3ff 	stp	xzr, x20, [sp, #72]
 1127b0c:	52800020 	mov	w0, #0x1                   	// #1
 1127b10:	b90043e0 	str	w0, [sp, #64]
	res = thread_rpc_cmd(OPTEE_RPC_CMD_SOCKET, 4, tpm);
 1127b14:	910103e2 	add	x2, sp, #0x40
	struct thread_param tpm[4] = {
 1127b18:	b90063e0 	str	w0, [sp, #96]
	res = thread_rpc_cmd(OPTEE_RPC_CMD_SOCKET, 4, tpm);
 1127b1c:	d2800081 	mov	x1, #0x4                   	// #4
		[1] = THREAD_PARAM_VALUE(IN,
 1127b20:	b9400660 	ldr	w0, [x19, #4]
 1127b24:	f90037e0 	str	x0, [sp, #104]
 1127b28:	b9402260 	ldr	w0, [x19, #32]
 1127b2c:	f9003be0 	str	x0, [sp, #112]
 1127b30:	b9400260 	ldr	w0, [x19]
 1127b34:	f9003fe0 	str	x0, [sp, #120]
	struct thread_param tpm[4] = {
 1127b38:	52800080 	mov	w0, #0x4                   	// #4
 1127b3c:	b90083e0 	str	w0, [sp, #128]
		[2] = THREAD_PARAM_MEMREF(IN, mobj, 0, params[1].memref.size),
 1127b40:	b9401a60 	ldr	w0, [x19, #24]
 1127b44:	f9004be0 	str	x0, [sp, #144]
	struct thread_param tpm[4] = {
 1127b48:	f9401fe0 	ldr	x0, [sp, #56]
 1127b4c:	f9004fe0 	str	x0, [sp, #152]
 1127b50:	52800040 	mov	w0, #0x2                   	// #2
 1127b54:	f9002fff 	str	xzr, [sp, #88]
 1127b58:	f90047ff 	str	xzr, [sp, #136]
 1127b5c:	b900a3e0 	str	w0, [sp, #160]
	res = thread_rpc_cmd(OPTEE_RPC_CMD_SOCKET, 4, tpm);
 1127b60:	52800140 	mov	w0, #0xa                   	// #10
	struct thread_param tpm[4] = {
 1127b64:	a90affff 	stp	xzr, xzr, [sp, #168]
 1127b68:	f9005fff 	str	xzr, [sp, #184]
	res = thread_rpc_cmd(OPTEE_RPC_CMD_SOCKET, 4, tpm);
 1127b6c:	97ff7cfc 	bl	1106f5c <thread_rpc_cmd>
	if (res == TEE_SUCCESS)
 1127b70:	35fffae0 	cbnz	w0, 1127acc <socket_open+0x44>
		params[3].value.a = tpm[3].u.value.a;
 1127b74:	f94057e1 	ldr	x1, [sp, #168]
 1127b78:	b9003261 	str	w1, [x19, #48]
 1127b7c:	17ffffd4 	b	1127acc <socket_open+0x44>
		return TEE_ERROR_OUT_OF_MEMORY;
 1127b80:	129ffe60 	mov	w0, #0xffff000c            	// #-65524
 1127b84:	17ffffd2 	b	1127acc <socket_open+0x44>

0000000001127b88 <tee_ta_decrypt_init>:
#include <tee/tee_ta_enc_manager.h>
#include <trace.h>

TEE_Result tee_ta_decrypt_init(void **enc_ctx, struct shdr_encrypted_ta *ehdr,
			       size_t len)
{
 1127b88:	d101c3ff 	sub	sp, sp, #0x70
 1127b8c:	a9017bfd 	stp	x29, x30, [sp, #16]
 1127b90:	910043fd 	add	x29, sp, #0x10
 1127b94:	a90253f3 	stp	x19, x20, [sp, #32]
 1127b98:	aa0103f4 	mov	x20, x1
	TEE_Result res = TEE_SUCCESS;
	uint8_t key[TEE_TA_ENC_KEY_SIZE] = {0};

	res = crypto_authenc_alloc_ctx(enc_ctx, ehdr->enc_algo);
 1127b9c:	b9400021 	ldr	w1, [x1]
{
 1127ba0:	a9035bf5 	stp	x21, x22, [sp, #48]
 1127ba4:	aa0003f5 	mov	x21, x0
 1127ba8:	f90023f7 	str	x23, [sp, #64]
 1127bac:	aa0203f7 	mov	x23, x2
	uint8_t key[TEE_TA_ENC_KEY_SIZE] = {0};
 1127bb0:	a9057fff 	stp	xzr, xzr, [sp, #80]
 1127bb4:	a9067fff 	stp	xzr, xzr, [sp, #96]
	res = crypto_authenc_alloc_ctx(enc_ctx, ehdr->enc_algo);
 1127bb8:	97ff9791 	bl	110d9fc <crypto_authenc_alloc_ctx>
	if (res != TEE_SUCCESS)
 1127bbc:	35000420 	cbnz	w0, 1127c40 <tee_ta_decrypt_init+0xb8>
		return res;

	res = tee_otp_get_ta_enc_key(ehdr->flags & SHDR_ENC_KEY_TYPE_MASK,
 1127bc0:	b9400680 	ldr	w0, [x20, #4]
 1127bc4:	910143f6 	add	x22, sp, #0x50
 1127bc8:	aa1603e1 	mov	x1, x22
 1127bcc:	d2800402 	mov	x2, #0x20                  	// #32
 1127bd0:	12000000 	and	w0, w0, #0x1
 1127bd4:	97ff71bb 	bl	11042c0 <tee_otp_get_ta_enc_key>
 1127bd8:	2a0003f3 	mov	w19, w0
				     key, sizeof(key));
	if (res != TEE_SUCCESS)
 1127bdc:	350001a0 	cbnz	w0, 1127c10 <tee_ta_decrypt_init+0x88>
		goto out_init;

	res = crypto_authenc_init(*enc_ctx, TEE_MODE_DECRYPT, key, sizeof(key),
 1127be0:	79401686 	ldrh	w6, [x20, #10]
 1127be4:	91003284 	add	x4, x20, #0xc
 1127be8:	79401285 	ldrh	w5, [x20, #8]
 1127bec:	aa1603e2 	mov	x2, x22
 1127bf0:	f94002a0 	ldr	x0, [x21]
 1127bf4:	f90003f7 	str	x23, [sp]
 1127bf8:	d2800007 	mov	x7, #0x0                   	// #0
 1127bfc:	d2800403 	mov	x3, #0x20                  	// #32
 1127c00:	52800021 	mov	w1, #0x1                   	// #1
 1127c04:	97ff9797 	bl	110da60 <crypto_authenc_init>
 1127c08:	2a0003f3 	mov	w19, w0
				  SHDR_ENC_GET_IV(ehdr), ehdr->iv_size,
				  ehdr->tag_size, 0, len);

out_init:
	if (res != TEE_SUCCESS)
 1127c0c:	34000060 	cbz	w0, 1127c18 <tee_ta_decrypt_init+0x90>
		crypto_authenc_free_ctx(*enc_ctx);
 1127c10:	f94002a0 	ldr	x0, [x21]
 1127c14:	97ff9835 	bl	110dce8 <crypto_authenc_free_ctx>

	memzero_explicit(key, sizeof(key));
 1127c18:	aa1603e0 	mov	x0, x22
 1127c1c:	d2800401 	mov	x1, #0x20                  	// #32
 1127c20:	940074f8 	bl	1145000 <memzero_explicit>
	return res;
}
 1127c24:	2a1303e0 	mov	w0, w19
 1127c28:	a9417bfd 	ldp	x29, x30, [sp, #16]
 1127c2c:	a94253f3 	ldp	x19, x20, [sp, #32]
 1127c30:	a9435bf5 	ldp	x21, x22, [sp, #48]
 1127c34:	f94023f7 	ldr	x23, [sp, #64]
 1127c38:	9101c3ff 	add	sp, sp, #0x70
 1127c3c:	d65f03c0 	ret
 1127c40:	2a0003f3 	mov	w19, w0
 1127c44:	17fffff8 	b	1127c24 <tee_ta_decrypt_init+0x9c>

0000000001127c48 <tee_ta_decrypt_update>:

TEE_Result tee_ta_decrypt_update(void *enc_ctx, uint8_t *dst, uint8_t *src,
				 size_t len)
{
 1127c48:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	TEE_Result res = TEE_SUCCESS;
	size_t dlen = len;

	res = crypto_authenc_update_payload(enc_ctx, TEE_MODE_DECRYPT, src, len,
 1127c4c:	aa0103e4 	mov	x4, x1
 1127c50:	52800021 	mov	w1, #0x1                   	// #1
{
 1127c54:	910003fd 	mov	x29, sp
	res = crypto_authenc_update_payload(enc_ctx, TEE_MODE_DECRYPT, src, len,
 1127c58:	9100a3e5 	add	x5, sp, #0x28
{
 1127c5c:	a90153f3 	stp	x19, x20, [sp, #16]
 1127c60:	aa0003f4 	mov	x20, x0
	size_t dlen = len;
 1127c64:	f90017e3 	str	x3, [sp, #40]
	res = crypto_authenc_update_payload(enc_ctx, TEE_MODE_DECRYPT, src, len,
 1127c68:	97ff97ae 	bl	110db20 <crypto_authenc_update_payload>
 1127c6c:	2a0003f3 	mov	w19, w0
					    dst, &dlen);
	if (res != TEE_SUCCESS)
 1127c70:	34000060 	cbz	w0, 1127c7c <tee_ta_decrypt_update+0x34>
		crypto_authenc_free_ctx(enc_ctx);
 1127c74:	aa1403e0 	mov	x0, x20
 1127c78:	97ff981c 	bl	110dce8 <crypto_authenc_free_ctx>

	return res;
}
 1127c7c:	2a1303e0 	mov	w0, w19
 1127c80:	a94153f3 	ldp	x19, x20, [sp, #16]
 1127c84:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1127c88:	d65f03c0 	ret

0000000001127c8c <tee_ta_decrypt_final>:

TEE_Result tee_ta_decrypt_final(void *enc_ctx, struct shdr_encrypted_ta *ehdr,
				uint8_t *dst, uint8_t *src, size_t len)
{
 1127c8c:	aa0103e7 	mov	x7, x1
 1127c90:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1127c94:	aa0203e8 	mov	x8, x2
 1127c98:	910003fd 	mov	x29, sp
	TEE_Result res = TEE_SUCCESS;
	size_t dlen = len;

	res = crypto_authenc_dec_final(enc_ctx, src, len, dst, &dlen,
				       SHDR_ENC_GET_TAG(ehdr), ehdr->tag_size);
 1127c9c:	794010e5 	ldrh	w5, [x7, #8]
{
 1127ca0:	aa0403e2 	mov	x2, x4
	res = crypto_authenc_dec_final(enc_ctx, src, len, dst, &dlen,
 1127ca4:	794014e6 	ldrh	w6, [x7, #10]
{
 1127ca8:	aa0303e1 	mov	x1, x3
				       SHDR_ENC_GET_TAG(ehdr), ehdr->tag_size);
 1127cac:	910030a5 	add	x5, x5, #0xc
	res = crypto_authenc_dec_final(enc_ctx, src, len, dst, &dlen,
 1127cb0:	9100a3e4 	add	x4, sp, #0x28
 1127cb4:	8b0500e5 	add	x5, x7, x5
 1127cb8:	aa0803e3 	mov	x3, x8
{
 1127cbc:	a90153f3 	stp	x19, x20, [sp, #16]
 1127cc0:	aa0003f4 	mov	x20, x0
	size_t dlen = len;
 1127cc4:	f90017e2 	str	x2, [sp, #40]
	res = crypto_authenc_dec_final(enc_ctx, src, len, dst, &dlen,
 1127cc8:	97ff97da 	bl	110dc30 <crypto_authenc_dec_final>
 1127ccc:	2a0003f3 	mov	w19, w0

	crypto_authenc_free_ctx(enc_ctx);
 1127cd0:	aa1403e0 	mov	x0, x20
 1127cd4:	97ff9805 	bl	110dce8 <crypto_authenc_free_ctx>

	return res;
}
 1127cd8:	2a1303e0 	mov	w0, w19
 1127cdc:	a94153f3 	ldp	x19, x20, [sp, #16]
 1127ce0:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1127ce4:	d65f03c0 	ret

0000000001127ce8 <tee_uuid_to_octets>:
#include <tee/uuid.h>
#include <util.h>

void tee_uuid_to_octets(uint8_t *d, const TEE_UUID *s)
{
	d[0] = s->timeLow >> 24;
 1127ce8:	39400c22 	ldrb	w2, [x1, #3]
 1127cec:	39000002 	strb	w2, [x0]
	d[1] = s->timeLow >> 16;
 1127cf0:	79400422 	ldrh	w2, [x1, #2]
 1127cf4:	39000402 	strb	w2, [x0, #1]
	d[2] = s->timeLow >> 8;
 1127cf8:	b9400022 	ldr	w2, [x1]
 1127cfc:	53087c42 	lsr	w2, w2, #8
 1127d00:	39000802 	strb	w2, [x0, #2]
	d[3] = s->timeLow;
 1127d04:	b9400022 	ldr	w2, [x1]
 1127d08:	39000c02 	strb	w2, [x0, #3]
	d[4] = s->timeMid >> 8;
 1127d0c:	39401422 	ldrb	w2, [x1, #5]
 1127d10:	39001002 	strb	w2, [x0, #4]
	d[5] = s->timeMid;
 1127d14:	79400822 	ldrh	w2, [x1, #4]
 1127d18:	39001402 	strb	w2, [x0, #5]
	d[6] = s->timeHiAndVersion >> 8;
 1127d1c:	39401c22 	ldrb	w2, [x1, #7]
 1127d20:	39001802 	strb	w2, [x0, #6]
	d[7] = s->timeHiAndVersion;
 1127d24:	79400c22 	ldrh	w2, [x1, #6]
 1127d28:	39001c02 	strb	w2, [x0, #7]
	memcpy(d + 8, s->clockSeqAndNode, sizeof(s->clockSeqAndNode));
 1127d2c:	d2800102 	mov	x2, #0x8                   	// #8
 1127d30:	8b020021 	add	x1, x1, x2
 1127d34:	8b020000 	add	x0, x0, x2
 1127d38:	17ff6d96 	b	1103390 <memcpy>

0000000001127d3c <tee_uuid_from_octets>:
}

void tee_uuid_from_octets(TEE_UUID *d, const uint8_t *s)
{
	d->timeLow = SHIFT_U32(s[0], 24) | SHIFT_U32(s[1], 16) |
 1127d3c:	39400022 	ldrb	w2, [x1]
 1127d40:	39400423 	ldrb	w3, [x1, #1]
 1127d44:	aa032043 	orr	x3, x2, x3, lsl #8
 1127d48:	39400822 	ldrb	w2, [x1, #2]
 1127d4c:	aa024063 	orr	x3, x3, x2, lsl #16
 1127d50:	39400c22 	ldrb	w2, [x1, #3]
 1127d54:	aa026062 	orr	x2, x3, x2, lsl #24
 1127d58:	5ac00842 	rev	w2, w2
 1127d5c:	b9000002 	str	w2, [x0]
		     SHIFT_U32(s[2], 8) | s[3];
	d->timeMid = SHIFT_U32(s[4], 8) | s[5];
 1127d60:	39401023 	ldrb	w3, [x1, #4]
 1127d64:	39401422 	ldrb	w2, [x1, #5]
 1127d68:	aa022062 	orr	x2, x3, x2, lsl #8
 1127d6c:	5ac00442 	rev16	w2, w2
 1127d70:	79000802 	strh	w2, [x0, #4]
	d->timeHiAndVersion = SHIFT_U32(s[6], 8) | s[7];
 1127d74:	39401823 	ldrb	w3, [x1, #6]
 1127d78:	39401c22 	ldrb	w2, [x1, #7]
 1127d7c:	aa022062 	orr	x2, x3, x2, lsl #8
 1127d80:	5ac00442 	rev16	w2, w2
 1127d84:	79000c02 	strh	w2, [x0, #6]
	memcpy(d->clockSeqAndNode, s + 8, sizeof(d->clockSeqAndNode));
 1127d88:	d2800102 	mov	x2, #0x8                   	// #8
 1127d8c:	8b020021 	add	x1, x1, x2
 1127d90:	8b020000 	add	x0, x0, x2
 1127d94:	17ff6d7f 	b	1103390 <memcpy>

0000000001127d98 <tee_invoke_supp_plugin_rpc>:
#include <trace.h>

TEE_Result tee_invoke_supp_plugin_rpc(const TEE_UUID *uuid, uint32_t cmd,
				      uint32_t sub_cmd, void *buf, size_t len,
				      size_t *outlen)
{
 1127d98:	a9b27bfd 	stp	x29, x30, [sp, #-224]!
 1127d9c:	910003fd 	mov	x29, sp
 1127da0:	a90153f3 	stp	x19, x20, [sp, #16]
 1127da4:	a9025bf5 	stp	x21, x22, [sp, #32]
 1127da8:	a90363f7 	stp	x23, x24, [sp, #48]
 1127dac:	a9046bf9 	stp	x25, x26, [sp, #64]
	TEE_Result res = TEE_ERROR_GENERIC;
	struct thread_param params[THREAD_RPC_MAX_NUM_PARAMS];
	uint32_t uuid_words[4] = { };
 1127db0:	a9057fff 	stp	xzr, xzr, [sp, #80]
	 * Array 'uuid_words' is used just for convenient work with
	 * 'TEE_UUID' as with uint32_t values.
	 */
	COMPILE_TIME_ASSERT(sizeof(TEE_UUID) == sizeof(uuid_words));

	if (!uuid || (len && !buf) || (!len && buf))
 1127db4:	b4000c40 	cbz	x0, 1127f3c <tee_invoke_supp_plugin_rpc+0x1a4>
 1127db8:	f100009f 	cmp	x4, #0x0
 1127dbc:	aa0303f6 	mov	x22, x3
 1127dc0:	aa0403f3 	mov	x19, x4
 1127dc4:	fa401860 	ccmp	x3, #0x0, #0x0, ne  // ne = any
 1127dc8:	54000ba0 	b.eq	1127f3c <tee_invoke_supp_plugin_rpc+0x1a4>  // b.none
 1127dcc:	f100009f 	cmp	x4, #0x0
 1127dd0:	fa400864 	ccmp	x3, #0x0, #0x4, eq  // eq = none
 1127dd4:	54000b41 	b.ne	1127f3c <tee_invoke_supp_plugin_rpc+0x1a4>  // b.any
 1127dd8:	aa0003fa 	mov	x26, x0
 1127ddc:	2a0103f8 	mov	w24, w1
 1127de0:	2a0203f4 	mov	w20, w2
 1127de4:	aa0503f9 	mov	x25, x5
		return TEE_ERROR_BAD_PARAMETERS;

	if (len) {
 1127de8:	b4000a04 	cbz	x4, 1127f28 <tee_invoke_supp_plugin_rpc+0x190>
		mobj = thread_rpc_alloc_payload(len);
 1127dec:	aa0403e0 	mov	x0, x4
 1127df0:	97ff7c97 	bl	110704c <thread_rpc_alloc_payload>
 1127df4:	aa0003f5 	mov	x21, x0
		if (!mobj) {
 1127df8:	b5000220 	cbnz	x0, 1127e3c <tee_invoke_supp_plugin_rpc+0xa4>
			EMSG("can't create mobj for plugin data");
			return TEE_ERROR_OUT_OF_MEMORY;
 1127dfc:	129ffe74 	mov	w20, #0xffff000c            	// #-65524
			EMSG("can't create mobj for plugin data");
 1127e00:	d0000164 	adrp	x4, 1155000 <__func__.3826+0xa8>
 1127e04:	52800023 	mov	w3, #0x1                   	// #1
 1127e08:	913e9484 	add	x4, x4, #0xfa5
 1127e0c:	52800022 	mov	w2, #0x1                   	// #1
 1127e10:	52800581 	mov	w1, #0x2c                  	// #44
 1127e14:	d0000160 	adrp	x0, 1155000 <__func__.3826+0xa8>
 1127e18:	913f7800 	add	x0, x0, #0xfde
 1127e1c:	940073ca 	bl	1144d44 <trace_printf>
out:
	if (len)
		thread_rpc_free_payload(mobj);

	return res;
}
 1127e20:	2a1403e0 	mov	w0, w20
 1127e24:	a94153f3 	ldp	x19, x20, [sp, #16]
 1127e28:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1127e2c:	a94363f7 	ldp	x23, x24, [sp, #48]
 1127e30:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1127e34:	a8ce7bfd 	ldp	x29, x30, [sp], #224
 1127e38:	d65f03c0 	ret
	if (mobj && mobj->ops && mobj->ops->get_va)
 1127e3c:	f9400001 	ldr	x1, [x0]
 1127e40:	b50001a1 	cbnz	x1, 1127e74 <tee_invoke_supp_plugin_rpc+0xdc>
	TEE_Result res = TEE_ERROR_GENERIC;
 1127e44:	52bffff4 	mov	w20, #0xffff0000            	// #-65536
			EMSG("can't get va from mobj");
 1127e48:	d0000164 	adrp	x4, 1155000 <__func__.3826+0xa8>
 1127e4c:	52800023 	mov	w3, #0x1                   	// #1
 1127e50:	913f1c84 	add	x4, x4, #0xfc7
 1127e54:	52800022 	mov	w2, #0x1                   	// #1
 1127e58:	52800641 	mov	w1, #0x32                  	// #50
 1127e5c:	d0000160 	adrp	x0, 1155000 <__func__.3826+0xa8>
 1127e60:	913f7800 	add	x0, x0, #0xfde
 1127e64:	940073b8 	bl	1144d44 <trace_printf>
		thread_rpc_free_payload(mobj);
 1127e68:	aa1503e0 	mov	x0, x21
 1127e6c:	97ff7c8b 	bl	1107098 <thread_rpc_free_payload>
 1127e70:	17ffffec 	b	1127e20 <tee_invoke_supp_plugin_rpc+0x88>
 1127e74:	f9400022 	ldr	x2, [x1]
 1127e78:	b4fffe62 	cbz	x2, 1127e44 <tee_invoke_supp_plugin_rpc+0xac>
		return mobj->ops->get_va(mobj, offset);
 1127e7c:	d2800001 	mov	x1, #0x0                   	// #0
 1127e80:	d63f0040 	blr	x2
 1127e84:	aa0003f7 	mov	x23, x0
		if (!va) {
 1127e88:	b4fffde0 	cbz	x0, 1127e44 <tee_invoke_supp_plugin_rpc+0xac>
		memcpy(va, buf, len);
 1127e8c:	aa1303e2 	mov	x2, x19
 1127e90:	aa1603e1 	mov	x1, x22
 1127e94:	97ff6d3f 	bl	1103390 <memcpy>
	tee_uuid_to_octets((uint8_t *)uuid_words, uuid);
 1127e98:	aa1a03e1 	mov	x1, x26
 1127e9c:	910143e0 	add	x0, sp, #0x50
 1127ea0:	97ffff92 	bl	1127ce8 <tee_uuid_to_octets>
	params[1] = THREAD_PARAM_VALUE(IN, uuid_words[2], uuid_words[3], cmd);
 1127ea4:	f9004ff8 	str	x24, [sp, #152]
	params[0] = THREAD_PARAM_VALUE(IN, OPTEE_RPC_SUPP_PLUGIN_INVOKE,
 1127ea8:	294a07e2 	ldp	w2, w1, [sp, #80]
 1127eac:	52800020 	mov	w0, #0x1                   	// #1
 1127eb0:	b90063e0 	str	w0, [sp, #96]
 1127eb4:	a9068bff 	stp	xzr, x2, [sp, #104]
 1127eb8:	f9003fe1 	str	x1, [sp, #120]
	params[1] = THREAD_PARAM_VALUE(IN, uuid_words[2], uuid_words[3], cmd);
 1127ebc:	294b07e2 	ldp	w2, w1, [sp, #88]
 1127ec0:	b90083e0 	str	w0, [sp, #128]
	params[2] = THREAD_PARAM_VALUE(INOUT, sub_cmd, 0, 0);
 1127ec4:	52800060 	mov	w0, #0x3                   	// #3
 1127ec8:	b900a3e0 	str	w0, [sp, #160]
	params[3] = THREAD_PARAM_MEMREF(INOUT, mobj, 0, len);
 1127ecc:	528000c0 	mov	w0, #0x6                   	// #6
	params[1] = THREAD_PARAM_VALUE(IN, uuid_words[2], uuid_words[3], cmd);
 1127ed0:	a90887e2 	stp	x2, x1, [sp, #136]
	res = thread_rpc_cmd(OPTEE_RPC_CMD_SUPP_PLUGIN, 4, params);
 1127ed4:	910183e2 	add	x2, sp, #0x60
 1127ed8:	d2800081 	mov	x1, #0x4                   	// #4
	params[2] = THREAD_PARAM_VALUE(INOUT, sub_cmd, 0, 0);
 1127edc:	a90afff4 	stp	x20, xzr, [sp, #168]
 1127ee0:	f9005fff 	str	xzr, [sp, #184]
	params[3] = THREAD_PARAM_MEMREF(INOUT, mobj, 0, len);
 1127ee4:	b900c3e0 	str	w0, [sp, #192]
	res = thread_rpc_cmd(OPTEE_RPC_CMD_SUPP_PLUGIN, 4, params);
 1127ee8:	52800180 	mov	w0, #0xc                   	// #12
	params[3] = THREAD_PARAM_MEMREF(INOUT, mobj, 0, len);
 1127eec:	a90ccfff 	stp	xzr, x19, [sp, #200]
 1127ef0:	f9006ff5 	str	x21, [sp, #216]
	res = thread_rpc_cmd(OPTEE_RPC_CMD_SUPP_PLUGIN, 4, params);
 1127ef4:	97ff7c1a 	bl	1106f5c <thread_rpc_cmd>
 1127ef8:	2a0003f4 	mov	w20, w0
	if (outlen)
 1127efc:	b40001d9 	cbz	x25, 1127f34 <tee_invoke_supp_plugin_rpc+0x19c>
		*outlen = params[2].u.value.b;
 1127f00:	f9405be2 	ldr	x2, [sp, #176]
 1127f04:	f9000322 	str	x2, [x25]
	if (len && outlen && *outlen)
 1127f08:	b4fff8d3 	cbz	x19, 1127e20 <tee_invoke_supp_plugin_rpc+0x88>
 1127f0c:	b4fffae2 	cbz	x2, 1127e68 <tee_invoke_supp_plugin_rpc+0xd0>
		memcpy(buf, va, *outlen <= len ? *outlen : len);
 1127f10:	eb13005f 	cmp	x2, x19
 1127f14:	aa1703e1 	mov	x1, x23
 1127f18:	9a939042 	csel	x2, x2, x19, ls  // ls = plast
 1127f1c:	aa1603e0 	mov	x0, x22
 1127f20:	97ff6d1c 	bl	1103390 <memcpy>
 1127f24:	17ffffd1 	b	1127e68 <tee_invoke_supp_plugin_rpc+0xd0>
	struct mobj *mobj = NULL;
 1127f28:	d2800015 	mov	x21, #0x0                   	// #0
	void *va = NULL;
 1127f2c:	d2800017 	mov	x23, #0x0                   	// #0
 1127f30:	17ffffda 	b	1127e98 <tee_invoke_supp_plugin_rpc+0x100>
	if (len)
 1127f34:	b4fff773 	cbz	x19, 1127e20 <tee_invoke_supp_plugin_rpc+0x88>
 1127f38:	17ffffcc 	b	1127e68 <tee_invoke_supp_plugin_rpc+0xd0>
		return TEE_ERROR_BAD_PARAMETERS;
 1127f3c:	129fff34 	mov	w20, #0xffff0006            	// #-65530
 1127f40:	17ffffb8 	b	1127e20 <tee_invoke_supp_plugin_rpc+0x88>

0000000001127f44 <ftrace_map_lr>:
#include <trace.h>
#include <types_ext.h>
#include <unw/unwind.h>

void __weak ftrace_map_lr(uint64_t *lr __unused)
{}
 1127f44:	d65f03c0 	ret

0000000001127f48 <unwind_stack_arm64>:
	return true;
}

bool unwind_stack_arm64(struct unwind_state_arm64 *frame,
			vaddr_t stack, size_t stack_size)
{
 1127f48:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1127f4c:	910003fd 	mov	x29, sp
 1127f50:	a90153f3 	stp	x19, x20, [sp, #16]
	vaddr_t fp = frame->fp;
 1127f54:	f9400014 	ldr	x20, [x0]

	if (fp < stack)
 1127f58:	eb01029f 	cmp	x20, x1
 1127f5c:	540000a2 	b.cs	1127f70 <unwind_stack_arm64+0x28>  // b.hs, b.nlast
		return false;
 1127f60:	52800000 	mov	w0, #0x0                   	// #0
	ftrace_map_lr(&frame->pc);

	frame->pc -= 4;

	return true;
}
 1127f64:	a94153f3 	ldp	x19, x20, [sp, #16]
 1127f68:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1127f6c:	d65f03c0 	ret
 1127f70:	aa0103e3 	mov	x3, x1
	if (fp + sizeof(uint64_t) * 3 > stack + stack_size)
 1127f74:	91006281 	add	x1, x20, #0x18
 1127f78:	8b020063 	add	x3, x3, x2
 1127f7c:	eb03003f 	cmp	x1, x3
 1127f80:	54ffff08 	b.hi	1127f60 <unwind_stack_arm64+0x18>  // b.pmore
 1127f84:	aa0003f3 	mov	x19, x0
	frame->sp = fp + 0x10;
 1127f88:	91004281 	add	x1, x20, #0x10
 1127f8c:	f9000401 	str	x1, [x0, #8]
	memcpy(reg, (void *)addr, sizeof(*reg));
 1127f90:	d2800102 	mov	x2, #0x8                   	// #8
 1127f94:	aa1403e1 	mov	x1, x20
 1127f98:	97ff6cfe 	bl	1103390 <memcpy>
	if (!frame->fp)
 1127f9c:	f9400260 	ldr	x0, [x19]
 1127fa0:	b4fffe00 	cbz	x0, 1127f60 <unwind_stack_arm64+0x18>
	if (!copy_in_reg(&frame->pc, fp + 8))
 1127fa4:	91004263 	add	x3, x19, #0x10
	memcpy(reg, (void *)addr, sizeof(*reg));
 1127fa8:	d2800102 	mov	x2, #0x8                   	// #8
 1127fac:	8b020281 	add	x1, x20, x2
 1127fb0:	aa0303e0 	mov	x0, x3
 1127fb4:	97ff6cf7 	bl	1103390 <memcpy>
	ftrace_map_lr(&frame->pc);
 1127fb8:	97ffffe3 	bl	1127f44 <ftrace_map_lr>
	frame->pc -= 4;
 1127fbc:	f9400a60 	ldr	x0, [x19, #16]
 1127fc0:	d1001000 	sub	x0, x0, #0x4
 1127fc4:	f9000a60 	str	x0, [x19, #16]
	return true;
 1127fc8:	52800020 	mov	w0, #0x1                   	// #1
 1127fcc:	17ffffe6 	b	1127f64 <unwind_stack_arm64+0x1c>

0000000001127fd0 <print_stack_arm64>:

void print_stack_arm64(struct unwind_state_arm64 *state,
		       vaddr_t stack, size_t stack_size)
{
 1127fd0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	trace_printf_helper_raw(TRACE_ERROR, true, "Call stack:");
 1127fd4:	f0000164 	adrp	x4, 1156000 <ta_pub_key_modulus+0x7>
 1127fd8:	91063084 	add	x4, x4, #0x18c
{
 1127fdc:	910003fd 	mov	x29, sp
 1127fe0:	a9025bf5 	stp	x21, x22, [sp, #32]

	ftrace_map_lr(&state->pc);
	do {
		trace_printf_helper_raw(TRACE_ERROR, true, " 0x%016" PRIx64,
 1127fe4:	f0000176 	adrp	x22, 1156000 <ta_pub_key_modulus+0x7>
 1127fe8:	910662d6 	add	x22, x22, #0x198
	trace_printf_helper_raw(TRACE_ERROR, true, "Call stack:");
 1127fec:	52800023 	mov	w3, #0x1                   	// #1
{
 1127ff0:	aa0203f5 	mov	x21, x2
	trace_printf_helper_raw(TRACE_ERROR, true, "Call stack:");
 1127ff4:	52800022 	mov	w2, #0x1                   	// #1
{
 1127ff8:	a90153f3 	stp	x19, x20, [sp, #16]
 1127ffc:	aa0103f4 	mov	x20, x1
	trace_printf_helper_raw(TRACE_ERROR, true, "Call stack:");
 1128000:	52800001 	mov	w1, #0x0                   	// #0
{
 1128004:	aa0003f3 	mov	x19, x0
	trace_printf_helper_raw(TRACE_ERROR, true, "Call stack:");
 1128008:	d2800000 	mov	x0, #0x0                   	// #0
 112800c:	9400734e 	bl	1144d44 <trace_printf>
	ftrace_map_lr(&state->pc);
 1128010:	91004260 	add	x0, x19, #0x10
 1128014:	97ffffcc 	bl	1127f44 <ftrace_map_lr>
		trace_printf_helper_raw(TRACE_ERROR, true, " 0x%016" PRIx64,
 1128018:	f9400a65 	ldr	x5, [x19, #16]
 112801c:	aa1603e4 	mov	x4, x22
 1128020:	52800023 	mov	w3, #0x1                   	// #1
 1128024:	52800022 	mov	w2, #0x1                   	// #1
 1128028:	52800001 	mov	w1, #0x0                   	// #0
 112802c:	d2800000 	mov	x0, #0x0                   	// #0
 1128030:	94007345 	bl	1144d44 <trace_printf>
					state->pc);
	} while (unwind_stack_arm64(state, stack, stack_size));
 1128034:	aa1503e2 	mov	x2, x21
 1128038:	aa1403e1 	mov	x1, x20
 112803c:	aa1303e0 	mov	x0, x19
 1128040:	97ffffc2 	bl	1127f48 <unwind_stack_arm64>
 1128044:	72001c1f 	tst	w0, #0xff
 1128048:	54fffe81 	b.ne	1128018 <print_stack_arm64+0x48>  // b.any
}
 112804c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1128050:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1128054:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1128058:	d65f03c0 	ret

000000000112805c <ltc_hash_alloc_ctx>:
static TEE_Result ltc_hash_alloc_ctx(struct crypto_hash_ctx **ctx_ret,
				     int ltc_hash_idx)
{
	struct ltc_hash_ctx *ctx = NULL;

	if (ltc_hash_idx < 0)
 112805c:	37f802c1 	tbnz	w1, #31, 11280b4 <ltc_hash_alloc_ctx+0x58>
{
 1128060:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1128064:	910003fd 	mov	x29, sp
 1128068:	a90153f3 	stp	x19, x20, [sp, #16]
 112806c:	aa0003f4 	mov	x20, x0
 1128070:	2a0103f3 	mov	w19, w1
		return TEE_ERROR_NOT_SUPPORTED;

	ctx = calloc(1, sizeof(*ctx));
 1128074:	d2800020 	mov	x0, #0x1                   	// #1
 1128078:	d2801c01 	mov	x1, #0xe0                  	// #224
 112807c:	94006d15 	bl	11434d0 <calloc>
	if (!ctx)
 1128080:	b40001e0 	cbz	x0, 11280bc <ltc_hash_alloc_ctx+0x60>
		return TEE_ERROR_OUT_OF_MEMORY;

	ctx->ctx.ops = &ltc_hash_ops;
 1128084:	f0000181 	adrp	x1, 115b000 <__vcore_unpg_rw_start>
 1128088:	913c6021 	add	x1, x1, #0xf18
 112808c:	f9000001 	str	x1, [x0]
	ctx->descr = hash_descriptor[ltc_hash_idx];
 1128090:	d0000181 	adrp	x1, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1128094:	f941a021 	ldr	x1, [x1, #832]
 1128098:	f873d821 	ldr	x1, [x1, w19, sxtw #3]

	*ctx_ret = &ctx->ctx;
 112809c:	f9000280 	str	x0, [x20]
	ctx->descr = hash_descriptor[ltc_hash_idx];
 11280a0:	f9000401 	str	x1, [x0, #8]

	return TEE_SUCCESS;
 11280a4:	52800000 	mov	w0, #0x0                   	// #0
}
 11280a8:	a94153f3 	ldp	x19, x20, [sp, #16]
 11280ac:	a8c27bfd 	ldp	x29, x30, [sp], #32
 11280b0:	d65f03c0 	ret
		return TEE_ERROR_NOT_SUPPORTED;
 11280b4:	129ffea0 	mov	w0, #0xffff000a            	// #-65526
}
 11280b8:	d65f03c0 	ret
		return TEE_ERROR_OUT_OF_MEMORY;
 11280bc:	129ffe60 	mov	w0, #0xffff000c            	// #-65524
 11280c0:	17fffffa 	b	11280a8 <ltc_hash_alloc_ctx+0x4c>

00000000011280c4 <to_hash_ctx>:
	assert(ctx && ctx->ops == &ltc_hash_ops);
 11280c4:	b40000c0 	cbz	x0, 11280dc <to_hash_ctx+0x18>
 11280c8:	f9400002 	ldr	x2, [x0]
 11280cc:	f0000181 	adrp	x1, 115b000 <__vcore_unpg_rw_start>
 11280d0:	913c6021 	add	x1, x1, #0xf18
 11280d4:	eb01005f 	cmp	x2, x1
 11280d8:	54000180 	b.eq	1128108 <to_hash_ctx+0x44>  // b.none
 11280dc:	d0000163 	adrp	x3, 1156000 <ta_pub_key_modulus+0x7>
 11280e0:	d0000161 	adrp	x1, 1156000 <ta_pub_key_modulus+0x7>
 11280e4:	91087463 	add	x3, x3, #0x21d
 11280e8:	91068821 	add	x1, x1, #0x1a2
 11280ec:	d0000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 11280f0:	9106f800 	add	x0, x0, #0x1be
{
 11280f4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	assert(ctx && ctx->ops == &ltc_hash_ops);
 11280f8:	528003c2 	mov	w2, #0x1e                  	// #30
{
 11280fc:	910003fd 	mov	x29, sp
	assert(ctx && ctx->ops == &ltc_hash_ops);
 1128100:	97ffa86b 	bl	11122ac <_assert_log>
 1128104:	97ffa87b 	bl	11122f0 <_assert_break>
}
 1128108:	d65f03c0 	ret

000000000112810c <ltc_hash_update>:
{
 112810c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1128110:	910003fd 	mov	x29, sp
 1128114:	a90153f3 	stp	x19, x20, [sp, #16]
 1128118:	aa0103f3 	mov	x19, x1
 112811c:	aa0203f4 	mov	x20, x2
	struct ltc_hash_ctx *hc = to_hash_ctx(ctx);
 1128120:	97ffffe9 	bl	11280c4 <to_hash_ctx>
	if (hc->descr->process(&hc->state, data, len) == CRYPT_OK)
 1128124:	91004000 	add	x0, x0, #0x10
 1128128:	f85f8001 	ldur	x1, [x0, #-8]
 112812c:	aa1403e2 	mov	x2, x20
 1128130:	f9405823 	ldr	x3, [x1, #176]
 1128134:	aa1303e1 	mov	x1, x19
 1128138:	d63f0060 	blr	x3
		return TEE_ERROR_BAD_STATE;
 112813c:	7100001f 	cmp	w0, #0x0
}
 1128140:	129fff00 	mov	w0, #0xffff0007            	// #-65529
 1128144:	1a9f1000 	csel	w0, w0, wzr, ne  // ne = any
 1128148:	a94153f3 	ldp	x19, x20, [sp, #16]
 112814c:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1128150:	d65f03c0 	ret

0000000001128154 <ltc_hash_init>:
{
 1128154:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 1128158:	910003fd 	mov	x29, sp
	struct ltc_hash_ctx *hc = to_hash_ctx(ctx);
 112815c:	97ffffda 	bl	11280c4 <to_hash_ctx>
	if (hc->descr->init(&hc->state) == CRYPT_OK)
 1128160:	91004000 	add	x0, x0, #0x10
 1128164:	f85f8001 	ldur	x1, [x0, #-8]
 1128168:	f9405421 	ldr	x1, [x1, #168]
 112816c:	d63f0020 	blr	x1
		return TEE_ERROR_BAD_STATE;
 1128170:	7100001f 	cmp	w0, #0x0
}
 1128174:	a8c17bfd 	ldp	x29, x30, [sp], #16
 1128178:	129fff00 	mov	w0, #0xffff0007            	// #-65529
 112817c:	1a9f1000 	csel	w0, w0, wzr, ne  // ne = any
 1128180:	d65f03c0 	ret

0000000001128184 <ltc_hash_free_ctx>:
{
 1128184:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 1128188:	910003fd 	mov	x29, sp
	free(to_hash_ctx(ctx));
 112818c:	97ffffce 	bl	11280c4 <to_hash_ctx>
}
 1128190:	a8c17bfd 	ldp	x29, x30, [sp], #16
	free(to_hash_ctx(ctx));
 1128194:	14006d13 	b	11435e0 <free>

0000000001128198 <ltc_hash_final>:
{
 1128198:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
 112819c:	910003fd 	mov	x29, sp
 11281a0:	a90153f3 	stp	x19, x20, [sp, #16]
 11281a4:	aa0103f4 	mov	x20, x1
 11281a8:	aa0203f3 	mov	x19, x2
 11281ac:	a9025bf5 	stp	x21, x22, [sp, #32]
	struct ltc_hash_ctx *hc = to_hash_ctx(ctx);
 11281b0:	97ffffc5 	bl	11280c4 <to_hash_ctx>
	size_t hash_size = hc->descr->hashsize;
 11281b4:	f9400401 	ldr	x1, [x0, #8]
 11281b8:	f9400836 	ldr	x22, [x1, #16]
	uint8_t block_digest[TEE_MAX_HASH_SIZE] = { 0 };
 11281bc:	a9037fff 	stp	xzr, xzr, [sp, #48]
 11281c0:	a9047fff 	stp	xzr, xzr, [sp, #64]
 11281c4:	a9057fff 	stp	xzr, xzr, [sp, #80]
 11281c8:	a9067fff 	stp	xzr, xzr, [sp, #96]
	if (len == 0)
 11281cc:	b4000353 	cbz	x19, 1128234 <ltc_hash_final+0x9c>
	if (hash_size > len) {
 11281d0:	eb1302df 	cmp	x22, x19
 11281d4:	54000109 	b.ls	11281f4 <ltc_hash_final+0x5c>  // b.plast
		if (hash_size > sizeof(block_digest))
 11281d8:	f10102df 	cmp	x22, #0x40
 11281dc:	54000289 	b.ls	112822c <ltc_hash_final+0x94>  // b.plast
			return TEE_ERROR_BAD_STATE;
 11281e0:	129fff00 	mov	w0, #0xffff0007            	// #-65529
}
 11281e4:	a94153f3 	ldp	x19, x20, [sp, #16]
 11281e8:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11281ec:	a8c77bfd 	ldp	x29, x30, [sp], #112
 11281f0:	d65f03c0 	ret
		tmp_digest = digest;
 11281f4:	aa1403f5 	mov	x21, x20
	if (hc->descr->done(&hc->state, tmp_digest) == CRYPT_OK) {
 11281f8:	f9405c22 	ldr	x2, [x1, #184]
 11281fc:	91004000 	add	x0, x0, #0x10
 1128200:	aa1503e1 	mov	x1, x21
 1128204:	d63f0040 	blr	x2
 1128208:	35fffec0 	cbnz	w0, 11281e0 <ltc_hash_final+0x48>
		if (hash_size > len)
 112820c:	eb1302df 	cmp	x22, x19
 1128210:	540000a9 	b.ls	1128224 <ltc_hash_final+0x8c>  // b.plast
			memcpy(digest, tmp_digest, len);
 1128214:	aa1303e2 	mov	x2, x19
 1128218:	aa1503e1 	mov	x1, x21
 112821c:	aa1403e0 	mov	x0, x20
 1128220:	97ff6c5c 	bl	1103390 <memcpy>
	return TEE_SUCCESS;
 1128224:	52800000 	mov	w0, #0x0                   	// #0
 1128228:	17ffffef 	b	11281e4 <ltc_hash_final+0x4c>
		tmp_digest = block_digest; /* use a tempory buffer */
 112822c:	9100c3f5 	add	x21, sp, #0x30
 1128230:	17fffff2 	b	11281f8 <ltc_hash_final+0x60>
		return TEE_ERROR_BAD_PARAMETERS;
 1128234:	129fff20 	mov	w0, #0xffff0006            	// #-65530
 1128238:	17ffffeb 	b	11281e4 <ltc_hash_final+0x4c>

000000000112823c <ltc_hash_copy_state>:
{
 112823c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1128240:	910003fd 	mov	x29, sp
 1128244:	a90153f3 	stp	x19, x20, [sp, #16]
 1128248:	aa0003f4 	mov	x20, x0
 112824c:	aa0103e0 	mov	x0, x1
	struct ltc_hash_ctx *src = to_hash_ctx(src_ctx);
 1128250:	97ffff9d 	bl	11280c4 <to_hash_ctx>
 1128254:	aa0003f3 	mov	x19, x0
	struct ltc_hash_ctx *dst = to_hash_ctx(dst_ctx);
 1128258:	aa1403e0 	mov	x0, x20
 112825c:	97ffff9a 	bl	11280c4 <to_hash_ctx>
	assert(src->descr == dst->descr);
 1128260:	f9400401 	ldr	x1, [x0, #8]
 1128264:	f9400662 	ldr	x2, [x19, #8]
 1128268:	eb01005f 	cmp	x2, x1
 112826c:	54000140 	b.eq	1128294 <ltc_hash_copy_state+0x58>  // b.none
 1128270:	d0000163 	adrp	x3, 1156000 <ta_pub_key_modulus+0x7>
 1128274:	d0000161 	adrp	x1, 1156000 <ta_pub_key_modulus+0x7>
 1128278:	9108a463 	add	x3, x3, #0x229
 112827c:	91068821 	add	x1, x1, #0x1a2
 1128280:	d0000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 1128284:	91077c00 	add	x0, x0, #0x1df
 1128288:	52800c02 	mov	w2, #0x60                  	// #96
 112828c:	97ffa808 	bl	11122ac <_assert_log>
 1128290:	97ffa818 	bl	11122f0 <_assert_break>
	dst->state = src->state;
 1128294:	91004261 	add	x1, x19, #0x10
 1128298:	d2801a02 	mov	x2, #0xd0                  	// #208
 112829c:	91004000 	add	x0, x0, #0x10
 11282a0:	97ff6c3c 	bl	1103390 <memcpy>
}
 11282a4:	a94153f3 	ldp	x19, x20, [sp, #16]
 11282a8:	a8c27bfd 	ldp	x29, x30, [sp], #32
 11282ac:	d65f03c0 	ret

00000000011282b0 <crypto_md5_alloc_ctx>:

#if defined(_CFG_CORE_LTC_MD5)
TEE_Result crypto_md5_alloc_ctx(struct crypto_hash_ctx **ctx)
{
 11282b0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 11282b4:	910003fd 	mov	x29, sp
 11282b8:	f9000bf3 	str	x19, [sp, #16]
 11282bc:	aa0003f3 	mov	x19, x0
	return ltc_hash_alloc_ctx(ctx, find_hash("md5"));
 11282c0:	d0000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 11282c4:	9107e000 	add	x0, x0, #0x1f8
 11282c8:	940028a1 	bl	113254c <find_hash>
 11282cc:	2a0003e1 	mov	w1, w0
 11282d0:	aa1303e0 	mov	x0, x19
}
 11282d4:	f9400bf3 	ldr	x19, [sp, #16]
 11282d8:	a8c27bfd 	ldp	x29, x30, [sp], #32
	return ltc_hash_alloc_ctx(ctx, find_hash("md5"));
 11282dc:	17ffff60 	b	112805c <ltc_hash_alloc_ctx>

00000000011282e0 <crypto_sha1_alloc_ctx>:
#endif

#if defined(_CFG_CORE_LTC_SHA1)
TEE_Result crypto_sha1_alloc_ctx(struct crypto_hash_ctx **ctx)
{
 11282e0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 11282e4:	910003fd 	mov	x29, sp
 11282e8:	f9000bf3 	str	x19, [sp, #16]
 11282ec:	aa0003f3 	mov	x19, x0
	return ltc_hash_alloc_ctx(ctx, find_hash("sha1"));
 11282f0:	d0000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 11282f4:	9107f000 	add	x0, x0, #0x1fc
 11282f8:	94002895 	bl	113254c <find_hash>
 11282fc:	2a0003e1 	mov	w1, w0
 1128300:	aa1303e0 	mov	x0, x19
}
 1128304:	f9400bf3 	ldr	x19, [sp, #16]
 1128308:	a8c27bfd 	ldp	x29, x30, [sp], #32
	return ltc_hash_alloc_ctx(ctx, find_hash("sha1"));
 112830c:	17ffff54 	b	112805c <ltc_hash_alloc_ctx>

0000000001128310 <crypto_sha224_alloc_ctx>:
#endif

#if defined(_CFG_CORE_LTC_SHA224)
TEE_Result crypto_sha224_alloc_ctx(struct crypto_hash_ctx **ctx)
{
 1128310:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1128314:	910003fd 	mov	x29, sp
 1128318:	f9000bf3 	str	x19, [sp, #16]
 112831c:	aa0003f3 	mov	x19, x0
	return ltc_hash_alloc_ctx(ctx, find_hash("sha224"));
 1128320:	d0000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 1128324:	91080400 	add	x0, x0, #0x201
 1128328:	94002889 	bl	113254c <find_hash>
 112832c:	2a0003e1 	mov	w1, w0
 1128330:	aa1303e0 	mov	x0, x19
}
 1128334:	f9400bf3 	ldr	x19, [sp, #16]
 1128338:	a8c27bfd 	ldp	x29, x30, [sp], #32
	return ltc_hash_alloc_ctx(ctx, find_hash("sha224"));
 112833c:	17ffff48 	b	112805c <ltc_hash_alloc_ctx>

0000000001128340 <crypto_sha256_alloc_ctx>:
#endif

#if defined(_CFG_CORE_LTC_SHA256)
TEE_Result crypto_sha256_alloc_ctx(struct crypto_hash_ctx **ctx)
{
 1128340:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1128344:	910003fd 	mov	x29, sp
 1128348:	f9000bf3 	str	x19, [sp, #16]
 112834c:	aa0003f3 	mov	x19, x0
	return ltc_hash_alloc_ctx(ctx, find_hash("sha256"));
 1128350:	d0000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 1128354:	91082000 	add	x0, x0, #0x208
 1128358:	9400287d 	bl	113254c <find_hash>
 112835c:	2a0003e1 	mov	w1, w0
 1128360:	aa1303e0 	mov	x0, x19
}
 1128364:	f9400bf3 	ldr	x19, [sp, #16]
 1128368:	a8c27bfd 	ldp	x29, x30, [sp], #32
	return ltc_hash_alloc_ctx(ctx, find_hash("sha256"));
 112836c:	17ffff3c 	b	112805c <ltc_hash_alloc_ctx>

0000000001128370 <crypto_sha384_alloc_ctx>:
#endif

#if defined(_CFG_CORE_LTC_SHA384)
TEE_Result crypto_sha384_alloc_ctx(struct crypto_hash_ctx **ctx)
{
 1128370:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1128374:	910003fd 	mov	x29, sp
 1128378:	f9000bf3 	str	x19, [sp, #16]
 112837c:	aa0003f3 	mov	x19, x0
	return ltc_hash_alloc_ctx(ctx, find_hash("sha384"));
 1128380:	d0000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 1128384:	91083c00 	add	x0, x0, #0x20f
 1128388:	94002871 	bl	113254c <find_hash>
 112838c:	2a0003e1 	mov	w1, w0
 1128390:	aa1303e0 	mov	x0, x19
}
 1128394:	f9400bf3 	ldr	x19, [sp, #16]
 1128398:	a8c27bfd 	ldp	x29, x30, [sp], #32
	return ltc_hash_alloc_ctx(ctx, find_hash("sha384"));
 112839c:	17ffff30 	b	112805c <ltc_hash_alloc_ctx>

00000000011283a0 <crypto_sha512_alloc_ctx>:
#endif

#if defined(_CFG_CORE_LTC_SHA512)
TEE_Result crypto_sha512_alloc_ctx(struct crypto_hash_ctx **ctx)
{
 11283a0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 11283a4:	910003fd 	mov	x29, sp
 11283a8:	f9000bf3 	str	x19, [sp, #16]
 11283ac:	aa0003f3 	mov	x19, x0
	return ltc_hash_alloc_ctx(ctx, find_hash("sha512"));
 11283b0:	d0000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 11283b4:	91085800 	add	x0, x0, #0x216
 11283b8:	94002865 	bl	113254c <find_hash>
 11283bc:	2a0003e1 	mov	w1, w0
 11283c0:	aa1303e0 	mov	x0, x19
}
 11283c4:	f9400bf3 	ldr	x19, [sp, #16]
 11283c8:	a8c27bfd 	ldp	x29, x30, [sp], #32
	return ltc_hash_alloc_ctx(ctx, find_hash("sha512"));
 11283cc:	17ffff24 	b	112805c <ltc_hash_alloc_ctx>

00000000011283d0 <ltc_hmac_alloc_ctx>:
static TEE_Result ltc_hmac_alloc_ctx(struct crypto_mac_ctx **ctx_ret,
				     int hash_idx)
{
	struct ltc_hmac_ctx *ctx = NULL;

	if (hash_idx < 0)
 11283d0:	37f80261 	tbnz	w1, #31, 112841c <ltc_hmac_alloc_ctx+0x4c>
{
 11283d4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 11283d8:	910003fd 	mov	x29, sp
 11283dc:	a90153f3 	stp	x19, x20, [sp, #16]
 11283e0:	aa0003f4 	mov	x20, x0
 11283e4:	2a0103f3 	mov	w19, w1
		return TEE_ERROR_NOT_SUPPORTED;

	ctx = calloc(1, sizeof(*ctx));
 11283e8:	d2800020 	mov	x0, #0x1                   	// #1
 11283ec:	d2804901 	mov	x1, #0x248                 	// #584
 11283f0:	94006c38 	bl	11434d0 <calloc>
	if (!ctx)
 11283f4:	b4000180 	cbz	x0, 1128424 <ltc_hmac_alloc_ctx+0x54>
		return TEE_ERROR_OUT_OF_MEMORY;

	ctx->ctx.ops = &ltc_hmac_ops;
 11283f8:	f0000181 	adrp	x1, 115b000 <__vcore_unpg_rw_start>
 11283fc:	913d0021 	add	x1, x1, #0xf40
	ctx->hash_idx = hash_idx;
	*ctx_ret = &ctx->ctx;
 1128400:	f9000280 	str	x0, [x20]
	ctx->ctx.ops = &ltc_hmac_ops;
 1128404:	f9000001 	str	x1, [x0]
	ctx->hash_idx = hash_idx;
 1128408:	b9000813 	str	w19, [x0, #8]

	return TEE_SUCCESS;
 112840c:	52800000 	mov	w0, #0x0                   	// #0
}
 1128410:	a94153f3 	ldp	x19, x20, [sp, #16]
 1128414:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1128418:	d65f03c0 	ret
		return TEE_ERROR_NOT_SUPPORTED;
 112841c:	129ffea0 	mov	w0, #0xffff000a            	// #-65526
}
 1128420:	d65f03c0 	ret
		return TEE_ERROR_OUT_OF_MEMORY;
 1128424:	129ffe60 	mov	w0, #0xffff000c            	// #-65524
 1128428:	17fffffa 	b	1128410 <ltc_hmac_alloc_ctx+0x40>

000000000112842c <to_hmac_ctx>:
	assert(ctx && ctx->ops == &ltc_hmac_ops);
 112842c:	b40000c0 	cbz	x0, 1128444 <to_hmac_ctx+0x18>
 1128430:	f9400002 	ldr	x2, [x0]
 1128434:	f0000181 	adrp	x1, 115b000 <__vcore_unpg_rw_start>
 1128438:	913d0021 	add	x1, x1, #0xf40
 112843c:	eb01005f 	cmp	x2, x1
 1128440:	54000180 	b.eq	1128470 <to_hmac_ctx+0x44>  // b.none
 1128444:	d0000163 	adrp	x3, 1156000 <ta_pub_key_modulus+0x7>
 1128448:	d0000161 	adrp	x1, 1156000 <ta_pub_key_modulus+0x7>
 112844c:	910a6463 	add	x3, x3, #0x299
 1128450:	9108f421 	add	x1, x1, #0x23d
 1128454:	d0000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 1128458:	91096400 	add	x0, x0, #0x259
{
 112845c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	assert(ctx && ctx->ops == &ltc_hmac_ops);
 1128460:	52800342 	mov	w2, #0x1a                  	// #26
{
 1128464:	910003fd 	mov	x29, sp
	assert(ctx && ctx->ops == &ltc_hmac_ops);
 1128468:	97ffa791 	bl	11122ac <_assert_log>
 112846c:	97ffa7a1 	bl	11122f0 <_assert_break>
}
 1128470:	d65f03c0 	ret

0000000001128474 <ltc_hmac_free_ctx>:
{
 1128474:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 1128478:	910003fd 	mov	x29, sp
	free(to_hmac_ctx(ctx));
 112847c:	97ffffec 	bl	112842c <to_hmac_ctx>
}
 1128480:	a8c17bfd 	ldp	x29, x30, [sp], #16
	free(to_hmac_ctx(ctx));
 1128484:	14006c57 	b	11435e0 <free>

0000000001128488 <ltc_hmac_final>:
{
 1128488:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 112848c:	910003fd 	mov	x29, sp
 1128490:	f9000bf3 	str	x19, [sp, #16]
 1128494:	aa0103f3 	mov	x19, x1
	unsigned long l = len;
 1128498:	f90017e2 	str	x2, [sp, #40]
	if (hmac_done(&to_hmac_ctx(ctx)->state, digest, &l) == CRYPT_OK)
 112849c:	97ffffe4 	bl	112842c <to_hmac_ctx>
 11284a0:	9100a3e2 	add	x2, sp, #0x28
 11284a4:	aa1303e1 	mov	x1, x19
 11284a8:	91004000 	add	x0, x0, #0x10
 11284ac:	94002467 	bl	1131648 <hmac_done>
		return TEE_ERROR_BAD_STATE;
 11284b0:	7100001f 	cmp	w0, #0x0
}
 11284b4:	129fff00 	mov	w0, #0xffff0007            	// #-65529
 11284b8:	1a9f1000 	csel	w0, w0, wzr, ne  // ne = any
 11284bc:	f9400bf3 	ldr	x19, [sp, #16]
 11284c0:	a8c37bfd 	ldp	x29, x30, [sp], #48
 11284c4:	d65f03c0 	ret

00000000011284c8 <ltc_hmac_update>:
{
 11284c8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 11284cc:	910003fd 	mov	x29, sp
 11284d0:	a90153f3 	stp	x19, x20, [sp, #16]
 11284d4:	aa0103f3 	mov	x19, x1
 11284d8:	aa0203f4 	mov	x20, x2
	if (hmac_process(&to_hmac_ctx(ctx)->state, data, len) == CRYPT_OK)
 11284dc:	97ffffd4 	bl	112842c <to_hmac_ctx>
 11284e0:	91004000 	add	x0, x0, #0x10
 11284e4:	aa1403e2 	mov	x2, x20
 11284e8:	aa1303e1 	mov	x1, x19
 11284ec:	9400253a 	bl	11319d4 <hmac_process>
		return TEE_ERROR_BAD_STATE;
 11284f0:	7100001f 	cmp	w0, #0x0
}
 11284f4:	129fff00 	mov	w0, #0xffff0007            	// #-65529
 11284f8:	1a9f1000 	csel	w0, w0, wzr, ne  // ne = any
 11284fc:	a94153f3 	ldp	x19, x20, [sp, #16]
 1128500:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1128504:	d65f03c0 	ret

0000000001128508 <ltc_hmac_init>:
{
 1128508:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 112850c:	910003fd 	mov	x29, sp
 1128510:	a90153f3 	stp	x19, x20, [sp, #16]
 1128514:	aa0103f3 	mov	x19, x1
 1128518:	aa0203f4 	mov	x20, x2
	struct ltc_hmac_ctx *hc = to_hmac_ctx(ctx);
 112851c:	97ffffc4 	bl	112842c <to_hmac_ctx>
	if (hmac_init(&hc->state, hc->hash_idx, key, len) == CRYPT_OK)
 1128520:	b9400801 	ldr	w1, [x0, #8]
 1128524:	aa1403e3 	mov	x3, x20
 1128528:	aa1303e2 	mov	x2, x19
 112852c:	91004000 	add	x0, x0, #0x10
 1128530:	940024be 	bl	1131828 <hmac_init>
		return TEE_ERROR_BAD_STATE;
 1128534:	7100001f 	cmp	w0, #0x0
}
 1128538:	129fff00 	mov	w0, #0xffff0007            	// #-65529
 112853c:	1a9f1000 	csel	w0, w0, wzr, ne  // ne = any
 1128540:	a94153f3 	ldp	x19, x20, [sp, #16]
 1128544:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1128548:	d65f03c0 	ret

000000000112854c <ltc_hmac_copy_state>:
{
 112854c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1128550:	910003fd 	mov	x29, sp
 1128554:	a90153f3 	stp	x19, x20, [sp, #16]
 1128558:	aa0003f4 	mov	x20, x0
 112855c:	aa0103e0 	mov	x0, x1
	struct ltc_hmac_ctx *src = to_hmac_ctx(src_ctx);
 1128560:	97ffffb3 	bl	112842c <to_hmac_ctx>
 1128564:	aa0003f3 	mov	x19, x0
	struct ltc_hmac_ctx *dst = to_hmac_ctx(dst_ctx);
 1128568:	aa1403e0 	mov	x0, x20
 112856c:	97ffffb0 	bl	112842c <to_hmac_ctx>
	assert(src->hash_idx == dst->hash_idx);
 1128570:	b9400801 	ldr	w1, [x0, #8]
 1128574:	b9400a62 	ldr	w2, [x19, #8]
 1128578:	6b01005f 	cmp	w2, w1
 112857c:	54000140 	b.eq	11285a4 <ltc_hmac_copy_state+0x58>  // b.none
 1128580:	d0000163 	adrp	x3, 1156000 <ta_pub_key_modulus+0x7>
 1128584:	d0000161 	adrp	x1, 1156000 <ta_pub_key_modulus+0x7>
 1128588:	910a9463 	add	x3, x3, #0x2a5
 112858c:	9108f421 	add	x1, x1, #0x23d
 1128590:	d0000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 1128594:	9109e800 	add	x0, x0, #0x27a
 1128598:	52800922 	mov	w2, #0x49                  	// #73
 112859c:	97ffa744 	bl	11122ac <_assert_log>
 11285a0:	97ffa754 	bl	11122f0 <_assert_break>
	dst->state = src->state;
 11285a4:	91004261 	add	x1, x19, #0x10
 11285a8:	d2804702 	mov	x2, #0x238                 	// #568
 11285ac:	91004000 	add	x0, x0, #0x10
 11285b0:	97ff6b78 	bl	1103390 <memcpy>
}
 11285b4:	a94153f3 	ldp	x19, x20, [sp, #16]
 11285b8:	a8c27bfd 	ldp	x29, x30, [sp], #32
 11285bc:	d65f03c0 	ret

00000000011285c0 <crypto_hmac_md5_alloc_ctx>:

TEE_Result crypto_hmac_md5_alloc_ctx(struct crypto_mac_ctx **ctx)
{
 11285c0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 11285c4:	910003fd 	mov	x29, sp
 11285c8:	f9000bf3 	str	x19, [sp, #16]
 11285cc:	aa0003f3 	mov	x19, x0
	return ltc_hmac_alloc_ctx(ctx, find_hash("md5"));
 11285d0:	d0000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 11285d4:	9107e000 	add	x0, x0, #0x1f8
 11285d8:	940027dd 	bl	113254c <find_hash>
 11285dc:	2a0003e1 	mov	w1, w0
 11285e0:	aa1303e0 	mov	x0, x19
}
 11285e4:	f9400bf3 	ldr	x19, [sp, #16]
 11285e8:	a8c27bfd 	ldp	x29, x30, [sp], #32
	return ltc_hmac_alloc_ctx(ctx, find_hash("md5"));
 11285ec:	17ffff79 	b	11283d0 <ltc_hmac_alloc_ctx>

00000000011285f0 <crypto_hmac_sha1_alloc_ctx>:

TEE_Result crypto_hmac_sha1_alloc_ctx(struct crypto_mac_ctx **ctx)
{
 11285f0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 11285f4:	910003fd 	mov	x29, sp
 11285f8:	f9000bf3 	str	x19, [sp, #16]
 11285fc:	aa0003f3 	mov	x19, x0
	return ltc_hmac_alloc_ctx(ctx, find_hash("sha1"));
 1128600:	d0000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 1128604:	9107f000 	add	x0, x0, #0x1fc
 1128608:	940027d1 	bl	113254c <find_hash>
 112860c:	2a0003e1 	mov	w1, w0
 1128610:	aa1303e0 	mov	x0, x19
}
 1128614:	f9400bf3 	ldr	x19, [sp, #16]
 1128618:	a8c27bfd 	ldp	x29, x30, [sp], #32
	return ltc_hmac_alloc_ctx(ctx, find_hash("sha1"));
 112861c:	17ffff6d 	b	11283d0 <ltc_hmac_alloc_ctx>

0000000001128620 <crypto_hmac_sha224_alloc_ctx>:

TEE_Result crypto_hmac_sha224_alloc_ctx(struct crypto_mac_ctx **ctx)
{
 1128620:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1128624:	910003fd 	mov	x29, sp
 1128628:	f9000bf3 	str	x19, [sp, #16]
 112862c:	aa0003f3 	mov	x19, x0
	return ltc_hmac_alloc_ctx(ctx, find_hash("sha224"));
 1128630:	d0000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 1128634:	91080400 	add	x0, x0, #0x201
 1128638:	940027c5 	bl	113254c <find_hash>
 112863c:	2a0003e1 	mov	w1, w0
 1128640:	aa1303e0 	mov	x0, x19
}
 1128644:	f9400bf3 	ldr	x19, [sp, #16]
 1128648:	a8c27bfd 	ldp	x29, x30, [sp], #32
	return ltc_hmac_alloc_ctx(ctx, find_hash("sha224"));
 112864c:	17ffff61 	b	11283d0 <ltc_hmac_alloc_ctx>

0000000001128650 <crypto_hmac_sha256_alloc_ctx>:

TEE_Result crypto_hmac_sha256_alloc_ctx(struct crypto_mac_ctx **ctx)
{
 1128650:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1128654:	910003fd 	mov	x29, sp
 1128658:	f9000bf3 	str	x19, [sp, #16]
 112865c:	aa0003f3 	mov	x19, x0
	return ltc_hmac_alloc_ctx(ctx, find_hash("sha256"));
 1128660:	d0000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 1128664:	91082000 	add	x0, x0, #0x208
 1128668:	940027b9 	bl	113254c <find_hash>
 112866c:	2a0003e1 	mov	w1, w0
 1128670:	aa1303e0 	mov	x0, x19
}
 1128674:	f9400bf3 	ldr	x19, [sp, #16]
 1128678:	a8c27bfd 	ldp	x29, x30, [sp], #32
	return ltc_hmac_alloc_ctx(ctx, find_hash("sha256"));
 112867c:	17ffff55 	b	11283d0 <ltc_hmac_alloc_ctx>

0000000001128680 <crypto_hmac_sha384_alloc_ctx>:

TEE_Result crypto_hmac_sha384_alloc_ctx(struct crypto_mac_ctx **ctx)
{
 1128680:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1128684:	910003fd 	mov	x29, sp
 1128688:	f9000bf3 	str	x19, [sp, #16]
 112868c:	aa0003f3 	mov	x19, x0
	return ltc_hmac_alloc_ctx(ctx, find_hash("sha384"));
 1128690:	d0000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 1128694:	91083c00 	add	x0, x0, #0x20f
 1128698:	940027ad 	bl	113254c <find_hash>
 112869c:	2a0003e1 	mov	w1, w0
 11286a0:	aa1303e0 	mov	x0, x19
}
 11286a4:	f9400bf3 	ldr	x19, [sp, #16]
 11286a8:	a8c27bfd 	ldp	x29, x30, [sp], #32
	return ltc_hmac_alloc_ctx(ctx, find_hash("sha384"));
 11286ac:	17ffff49 	b	11283d0 <ltc_hmac_alloc_ctx>

00000000011286b0 <crypto_hmac_sha512_alloc_ctx>:

TEE_Result crypto_hmac_sha512_alloc_ctx(struct crypto_mac_ctx **ctx)
{
 11286b0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 11286b4:	910003fd 	mov	x29, sp
 11286b8:	f9000bf3 	str	x19, [sp, #16]
 11286bc:	aa0003f3 	mov	x19, x0
	return ltc_hmac_alloc_ctx(ctx, find_hash("sha512"));
 11286c0:	d0000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 11286c4:	91085800 	add	x0, x0, #0x216
 11286c8:	940027a1 	bl	113254c <find_hash>
 11286cc:	2a0003e1 	mov	w1, w0
 11286d0:	aa1303e0 	mov	x0, x19
}
 11286d4:	f9400bf3 	ldr	x19, [sp, #16]
 11286d8:	a8c27bfd 	ldp	x29, x30, [sp], #32
	return ltc_hmac_alloc_ctx(ctx, find_hash("sha512"));
 11286dc:	17ffff3d 	b	11283d0 <ltc_hmac_alloc_ctx>

00000000011286e0 <crypto_common_cmac_alloc_ctx>:
	.copy_state = ltc_omac_copy_state,
};

static TEE_Result crypto_common_cmac_alloc_ctx(struct crypto_mac_ctx **ctx_ret,
		const char *cipher)
{
 11286e0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 11286e4:	910003fd 	mov	x29, sp
 11286e8:	a90153f3 	stp	x19, x20, [sp, #16]
 11286ec:	aa0003f3 	mov	x19, x0
 11286f0:	aa0103e0 	mov	x0, x1
	struct ltc_omac_ctx *ctx = NULL;
	int cipher_idx = find_cipher(cipher);
 11286f4:	94002771 	bl	11324b8 <find_cipher>

	if (!ctx_ret)
 11286f8:	b4000213 	cbz	x19, 1128738 <crypto_common_cmac_alloc_ctx+0x58>
 11286fc:	2a0003f4 	mov	w20, w0
		return TEE_ERROR_BAD_PARAMETERS;

	if (cipher_idx < 0)
 1128700:	37f80200 	tbnz	w0, #31, 1128740 <crypto_common_cmac_alloc_ctx+0x60>
		return TEE_ERROR_NOT_SUPPORTED;

	ctx = calloc(1, sizeof(*ctx));
 1128704:	d280ac01 	mov	x1, #0x560                 	// #1376
 1128708:	d2800020 	mov	x0, #0x1                   	// #1
 112870c:	94006b71 	bl	11434d0 <calloc>
	if (!ctx)
 1128710:	b40001c0 	cbz	x0, 1128748 <crypto_common_cmac_alloc_ctx+0x68>
		return TEE_ERROR_OUT_OF_MEMORY;

	ctx->ctx.ops = &ltc_omac_ops;
 1128714:	f0000181 	adrp	x1, 115b000 <__vcore_unpg_rw_start>
 1128718:	913da021 	add	x1, x1, #0xf68
	ctx->cipher_idx = cipher_idx;
	*ctx_ret = &ctx->ctx;
 112871c:	f9000260 	str	x0, [x19]
	ctx->ctx.ops = &ltc_omac_ops;
 1128720:	f9000001 	str	x1, [x0]
	ctx->cipher_idx = cipher_idx;
 1128724:	b9000814 	str	w20, [x0, #8]

	return TEE_SUCCESS;
 1128728:	52800000 	mov	w0, #0x0                   	// #0
}
 112872c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1128730:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1128734:	d65f03c0 	ret
		return TEE_ERROR_BAD_PARAMETERS;
 1128738:	129fff20 	mov	w0, #0xffff0006            	// #-65530
 112873c:	17fffffc 	b	112872c <crypto_common_cmac_alloc_ctx+0x4c>
		return TEE_ERROR_NOT_SUPPORTED;
 1128740:	129ffea0 	mov	w0, #0xffff000a            	// #-65526
 1128744:	17fffffa 	b	112872c <crypto_common_cmac_alloc_ctx+0x4c>
		return TEE_ERROR_OUT_OF_MEMORY;
 1128748:	129ffe60 	mov	w0, #0xffff000c            	// #-65524
 112874c:	17fffff8 	b	112872c <crypto_common_cmac_alloc_ctx+0x4c>

0000000001128750 <to_omac_ctx>:
	assert(ctx && ctx->ops == &ltc_omac_ops);
 1128750:	b40000c0 	cbz	x0, 1128768 <to_omac_ctx+0x18>
 1128754:	f9400002 	ldr	x2, [x0]
 1128758:	f0000181 	adrp	x1, 115b000 <__vcore_unpg_rw_start>
 112875c:	913da021 	add	x1, x1, #0xf68
 1128760:	eb01005f 	cmp	x2, x1
 1128764:	54000180 	b.eq	1128794 <to_omac_ctx+0x44>  // b.none
 1128768:	d0000163 	adrp	x3, 1156000 <ta_pub_key_modulus+0x7>
 112876c:	d0000161 	adrp	x1, 1156000 <ta_pub_key_modulus+0x7>
 1128770:	910c8863 	add	x3, x3, #0x322
 1128774:	910ae421 	add	x1, x1, #0x2b9
 1128778:	d0000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 112877c:	910b5400 	add	x0, x0, #0x2d5
{
 1128780:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	assert(ctx && ctx->ops == &ltc_omac_ops);
 1128784:	52800362 	mov	w2, #0x1b                  	// #27
{
 1128788:	910003fd 	mov	x29, sp
	assert(ctx && ctx->ops == &ltc_omac_ops);
 112878c:	97ffa6c8 	bl	11122ac <_assert_log>
 1128790:	97ffa6d8 	bl	11122f0 <_assert_break>
}
 1128794:	d65f03c0 	ret

0000000001128798 <ltc_omac_free_ctx>:
{
 1128798:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 112879c:	910003fd 	mov	x29, sp
	free(to_omac_ctx(ctx));
 11287a0:	97ffffec 	bl	1128750 <to_omac_ctx>
}
 11287a4:	a8c17bfd 	ldp	x29, x30, [sp], #16
	free(to_omac_ctx(ctx));
 11287a8:	14006b8e 	b	11435e0 <free>

00000000011287ac <ltc_omac_final>:
{
 11287ac:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 11287b0:	910003fd 	mov	x29, sp
 11287b4:	f9000bf3 	str	x19, [sp, #16]
 11287b8:	aa0103f3 	mov	x19, x1
	unsigned long l = len;
 11287bc:	f90017e2 	str	x2, [sp, #40]
	if (omac_done(&to_omac_ctx(ctx)->state, digest, &l) == CRYPT_OK)
 11287c0:	97ffffe4 	bl	1128750 <to_omac_ctx>
 11287c4:	9100a3e2 	add	x2, sp, #0x28
 11287c8:	aa1303e1 	mov	x1, x19
 11287cc:	91004000 	add	x0, x0, #0x10
 11287d0:	940024a1 	bl	1131a54 <omac_done>
		return TEE_ERROR_BAD_STATE;
 11287d4:	7100001f 	cmp	w0, #0x0
}
 11287d8:	129fff00 	mov	w0, #0xffff0007            	// #-65529
 11287dc:	1a9f1000 	csel	w0, w0, wzr, ne  // ne = any
 11287e0:	f9400bf3 	ldr	x19, [sp, #16]
 11287e4:	a8c37bfd 	ldp	x29, x30, [sp], #48
 11287e8:	d65f03c0 	ret

00000000011287ec <ltc_omac_update>:
{
 11287ec:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 11287f0:	910003fd 	mov	x29, sp
 11287f4:	a90153f3 	stp	x19, x20, [sp, #16]
 11287f8:	aa0103f3 	mov	x19, x1
 11287fc:	aa0203f4 	mov	x20, x2
	if (omac_process(&to_omac_ctx(ctx)->state, data, len) == CRYPT_OK)
 1128800:	97ffffd4 	bl	1128750 <to_omac_ctx>
 1128804:	91004000 	add	x0, x0, #0x10
 1128808:	aa1403e2 	mov	x2, x20
 112880c:	aa1303e1 	mov	x1, x19
 1128810:	9400255d 	bl	1131d84 <omac_process>
		return TEE_ERROR_BAD_STATE;
 1128814:	7100001f 	cmp	w0, #0x0
}
 1128818:	129fff00 	mov	w0, #0xffff0007            	// #-65529
 112881c:	1a9f1000 	csel	w0, w0, wzr, ne  // ne = any
 1128820:	a94153f3 	ldp	x19, x20, [sp, #16]
 1128824:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1128828:	d65f03c0 	ret

000000000112882c <ltc_omac_init>:
{
 112882c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1128830:	910003fd 	mov	x29, sp
 1128834:	a90153f3 	stp	x19, x20, [sp, #16]
 1128838:	aa0103f3 	mov	x19, x1
 112883c:	aa0203f4 	mov	x20, x2
	struct ltc_omac_ctx *hc = to_omac_ctx(ctx);
 1128840:	97ffffc4 	bl	1128750 <to_omac_ctx>
	if (omac_init(&hc->state, hc->cipher_idx, key, len) == CRYPT_OK)
 1128844:	b9400801 	ldr	w1, [x0, #8]
 1128848:	aa1403e3 	mov	x3, x20
 112884c:	aa1303e2 	mov	x2, x19
 1128850:	91004000 	add	x0, x0, #0x10
 1128854:	940024e1 	bl	1131bd8 <omac_init>
		return TEE_ERROR_BAD_STATE;
 1128858:	7100001f 	cmp	w0, #0x0
}
 112885c:	129fff00 	mov	w0, #0xffff0007            	// #-65529
 1128860:	1a9f1000 	csel	w0, w0, wzr, ne  // ne = any
 1128864:	a94153f3 	ldp	x19, x20, [sp, #16]
 1128868:	a8c27bfd 	ldp	x29, x30, [sp], #32
 112886c:	d65f03c0 	ret

0000000001128870 <ltc_omac_copy_state>:
{
 1128870:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1128874:	910003fd 	mov	x29, sp
 1128878:	a90153f3 	stp	x19, x20, [sp, #16]
 112887c:	aa0003f4 	mov	x20, x0
 1128880:	aa0103e0 	mov	x0, x1
	struct ltc_omac_ctx *src = to_omac_ctx(src_ctx);
 1128884:	97ffffb3 	bl	1128750 <to_omac_ctx>
 1128888:	aa0003f3 	mov	x19, x0
	struct ltc_omac_ctx *dst = to_omac_ctx(dst_ctx);
 112888c:	aa1403e0 	mov	x0, x20
 1128890:	97ffffb0 	bl	1128750 <to_omac_ctx>
	assert(src->cipher_idx == dst->cipher_idx);
 1128894:	b9400801 	ldr	w1, [x0, #8]
 1128898:	b9400a62 	ldr	w2, [x19, #8]
 112889c:	6b01005f 	cmp	w2, w1
 11288a0:	54000140 	b.eq	11288c8 <ltc_omac_copy_state+0x58>  // b.none
 11288a4:	d0000163 	adrp	x3, 1156000 <ta_pub_key_modulus+0x7>
 11288a8:	d0000161 	adrp	x1, 1156000 <ta_pub_key_modulus+0x7>
 11288ac:	910cb863 	add	x3, x3, #0x32e
 11288b0:	910ae421 	add	x1, x1, #0x2b9
 11288b4:	d0000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 11288b8:	910bd800 	add	x0, x0, #0x2f6
 11288bc:	52800942 	mov	w2, #0x4a                  	// #74
 11288c0:	97ffa67b 	bl	11122ac <_assert_log>
 11288c4:	97ffa68b 	bl	11122f0 <_assert_break>
	dst->state = src->state;
 11288c8:	91004261 	add	x1, x19, #0x10
 11288cc:	d280aa02 	mov	x2, #0x550                 	// #1360
 11288d0:	91004000 	add	x0, x0, #0x10
 11288d4:	97ff6aaf 	bl	1103390 <memcpy>
}
 11288d8:	a94153f3 	ldp	x19, x20, [sp, #16]
 11288dc:	a8c27bfd 	ldp	x29, x30, [sp], #32
 11288e0:	d65f03c0 	ret

00000000011288e4 <crypto_aes_cmac_alloc_ctx>:

TEE_Result crypto_aes_cmac_alloc_ctx(struct crypto_mac_ctx **ctx_ret)
{
	return crypto_common_cmac_alloc_ctx(ctx_ret, "aes");
 11288e4:	d0000161 	adrp	x1, 1156000 <ta_pub_key_modulus+0x7>
 11288e8:	910c6421 	add	x1, x1, #0x319
 11288ec:	17ffff7d 	b	11286e0 <crypto_common_cmac_alloc_ctx>

00000000011288f0 <crypto_des3_cmac_alloc_ctx>:
}

TEE_Result crypto_des3_cmac_alloc_ctx(struct crypto_mac_ctx **ctx_ret)
{
	return crypto_common_cmac_alloc_ctx(ctx_ret, "3des");
 11288f0:	d0000161 	adrp	x1, 1156000 <ta_pub_key_modulus+0x7>
 11288f4:	910c7421 	add	x1, x1, #0x31d
 11288f8:	17ffff7a 	b	11286e0 <crypto_common_cmac_alloc_ctx>

00000000011288fc <ltc_ecb_alloc_ctx>:
static TEE_Result ltc_ecb_alloc_ctx(struct crypto_cipher_ctx **ctx_ret,
				    int cipher_idx, bool des3)
{
	struct ltc_ecb_ctx *c = NULL;

	if (cipher_idx < 0)
 11288fc:	37f802e1 	tbnz	w1, #31, 1128958 <ltc_ecb_alloc_ctx+0x5c>
{
 1128900:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1128904:	910003fd 	mov	x29, sp
 1128908:	a90153f3 	stp	x19, x20, [sp, #16]
 112890c:	aa0003f4 	mov	x20, x0
 1128910:	2a0103f3 	mov	w19, w1
		return TEE_ERROR_NOT_SUPPORTED;

	c = calloc(1, sizeof(*c));
 1128914:	d2800020 	mov	x0, #0x1                   	// #1
 1128918:	d2806401 	mov	x1, #0x320                 	// #800
{
 112891c:	f90013f5 	str	x21, [sp, #32]
 1128920:	12001c55 	and	w21, w2, #0xff
	c = calloc(1, sizeof(*c));
 1128924:	94006aeb 	bl	11434d0 <calloc>
	if (!c)
 1128928:	b40001c0 	cbz	x0, 1128960 <ltc_ecb_alloc_ctx+0x64>
		return TEE_ERROR_OUT_OF_MEMORY;

	c->ctx.ops = &ltc_ecb_ops;
 112892c:	f0000181 	adrp	x1, 115b000 <__vcore_unpg_rw_start>
 1128930:	913e4021 	add	x1, x1, #0xf90
	c->cipher_idx = cipher_idx;
	c->des3 = des3;
	*ctx_ret = &c->ctx;
 1128934:	f9000280 	str	x0, [x20]
	c->ctx.ops = &ltc_ecb_ops;
 1128938:	f9000001 	str	x1, [x0]
	c->cipher_idx = cipher_idx;
 112893c:	b9000813 	str	w19, [x0, #8]
	c->des3 = des3;
 1128940:	39003015 	strb	w21, [x0, #12]

	return TEE_SUCCESS;
 1128944:	52800000 	mov	w0, #0x0                   	// #0
}
 1128948:	a94153f3 	ldp	x19, x20, [sp, #16]
 112894c:	f94013f5 	ldr	x21, [sp, #32]
 1128950:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1128954:	d65f03c0 	ret
		return TEE_ERROR_NOT_SUPPORTED;
 1128958:	129ffea0 	mov	w0, #0xffff000a            	// #-65526
}
 112895c:	d65f03c0 	ret
		return TEE_ERROR_OUT_OF_MEMORY;
 1128960:	129ffe60 	mov	w0, #0xffff000c            	// #-65524
 1128964:	17fffff9 	b	1128948 <ltc_ecb_alloc_ctx+0x4c>

0000000001128968 <to_ecb_ctx>:
	assert(ctx && ctx->ops == &ltc_ecb_ops);
 1128968:	b40000c0 	cbz	x0, 1128980 <to_ecb_ctx+0x18>
 112896c:	f9400002 	ldr	x2, [x0]
 1128970:	f0000181 	adrp	x1, 115b000 <__vcore_unpg_rw_start>
 1128974:	913e4021 	add	x1, x1, #0xf90
 1128978:	eb01005f 	cmp	x2, x1
 112897c:	54000180 	b.eq	11289ac <to_ecb_ctx+0x44>  // b.none
 1128980:	d0000163 	adrp	x3, 1156000 <ta_pub_key_modulus+0x7>
 1128984:	d0000161 	adrp	x1, 1156000 <ta_pub_key_modulus+0x7>
 1128988:	910df463 	add	x3, x3, #0x37d
 112898c:	910d0821 	add	x1, x1, #0x342
 1128990:	d0000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 1128994:	910d7400 	add	x0, x0, #0x35d
{
 1128998:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	assert(ctx && ctx->ops == &ltc_ecb_ops);
 112899c:	528003a2 	mov	w2, #0x1d                  	// #29
{
 11289a0:	910003fd 	mov	x29, sp
	assert(ctx && ctx->ops == &ltc_ecb_ops);
 11289a4:	97ffa642 	bl	11122ac <_assert_log>
 11289a8:	97ffa652 	bl	11122f0 <_assert_break>
}
 11289ac:	d65f03c0 	ret

00000000011289b0 <ltc_ecb_update>:
{
 11289b0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 11289b4:	910003fd 	mov	x29, sp
 11289b8:	a90153f3 	stp	x19, x20, [sp, #16]
 11289bc:	aa0403f4 	mov	x20, x4
 11289c0:	aa0203f3 	mov	x19, x2
 11289c4:	f90013f5 	str	x21, [sp, #32]
 11289c8:	aa0303f5 	mov	x21, x3
	struct ltc_ecb_ctx *c = to_ecb_ctx(ctx);
 11289cc:	97ffffe7 	bl	1128968 <to_ecb_ctx>
	if (c->update && c->update(data, dst, len, &c->state) == CRYPT_OK)
 11289d0:	f9400804 	ldr	x4, [x0, #16]
 11289d4:	b40000e4 	cbz	x4, 11289f0 <ltc_ecb_update+0x40>
 11289d8:	91006003 	add	x3, x0, #0x18
 11289dc:	aa1503e2 	mov	x2, x21
 11289e0:	aa1403e1 	mov	x1, x20
 11289e4:	aa1303e0 	mov	x0, x19
 11289e8:	d63f0080 	blr	x4
 11289ec:	340000c0 	cbz	w0, 1128a04 <ltc_ecb_update+0x54>
		return TEE_ERROR_BAD_STATE;
 11289f0:	129fff00 	mov	w0, #0xffff0007            	// #-65529
}
 11289f4:	a94153f3 	ldp	x19, x20, [sp, #16]
 11289f8:	f94013f5 	ldr	x21, [sp, #32]
 11289fc:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1128a00:	d65f03c0 	ret
		return TEE_SUCCESS;
 1128a04:	52800000 	mov	w0, #0x0                   	// #0
 1128a08:	17fffffb 	b	11289f4 <ltc_ecb_update+0x44>

0000000001128a0c <ltc_ecb_free_ctx>:
{
 1128a0c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 1128a10:	910003fd 	mov	x29, sp
	free(to_ecb_ctx(ctx));
 1128a14:	97ffffd5 	bl	1128968 <to_ecb_ctx>
}
 1128a18:	a8c17bfd 	ldp	x29, x30, [sp], #16
	free(to_ecb_ctx(ctx));
 1128a1c:	14006af1 	b	11435e0 <free>

0000000001128a20 <ltc_ecb_final>:
{
 1128a20:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 1128a24:	910003fd 	mov	x29, sp
	ecb_done(&to_ecb_ctx(ctx)->state);
 1128a28:	97ffffd0 	bl	1128968 <to_ecb_ctx>
 1128a2c:	91006000 	add	x0, x0, #0x18
}
 1128a30:	a8c17bfd 	ldp	x29, x30, [sp], #16
	ecb_done(&to_ecb_ctx(ctx)->state);
 1128a34:	14002a1a 	b	113329c <ecb_done>

0000000001128a38 <ltc_ecb_init>:
{
 1128a38:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 1128a3c:	910003fd 	mov	x29, sp
 1128a40:	a90153f3 	stp	x19, x20, [sp, #16]
 1128a44:	aa0203f4 	mov	x20, x2
 1128a48:	a9025bf5 	stp	x21, x22, [sp, #32]
 1128a4c:	2a0103f6 	mov	w22, w1
 1128a50:	aa0303f5 	mov	x21, x3
	struct ltc_ecb_ctx *c = to_ecb_ctx(ctx);
 1128a54:	97ffffc5 	bl	1128968 <to_ecb_ctx>
 1128a58:	aa0003f3 	mov	x19, x0
	uint8_t tmp[24] = { 0 };
 1128a5c:	d0000181 	adrp	x1, 115a000 <__scattered_array_1phys_mem_map+0x8>
		c->update = ecb_decrypt;
 1128a60:	710002df 	cmp	w22, #0x0
	uint8_t tmp[24] = { 0 };
 1128a64:	a903ffff 	stp	xzr, xzr, [sp, #56]
		c->update = ecb_decrypt;
 1128a68:	f9415c22 	ldr	x2, [x1, #696]
	uint8_t tmp[24] = { 0 };
 1128a6c:	f90027ff 	str	xzr, [sp, #72]
		c->update = ecb_decrypt;
 1128a70:	f941e020 	ldr	x0, [x1, #960]
 1128a74:	9a820000 	csel	x0, x0, x2, eq  // eq = none
 1128a78:	f9000a60 	str	x0, [x19, #16]
	if (c->des3)
 1128a7c:	39403260 	ldrb	w0, [x19, #12]
 1128a80:	340001c0 	cbz	w0, 1128ab8 <ltc_ecb_init+0x80>
 */

static inline void get_des2_key(const uint8_t **key, size_t *key_len,
				uint8_t *tmp)
{
	if (*key_len == 16) {
 1128a84:	f10042bf 	cmp	x21, #0x10
 1128a88:	54000181 	b.ne	1128ab8 <ltc_ecb_init+0x80>  // b.any
		 * algorithm is similar to 3DES. Both perform and
		 * encryption step, then a decryption step, followed
		 * by another encryption step (EDE). However 2DES uses
		 * the same key for both of the encryption (E) steps.
		 */
		memcpy(tmp, *key, 16);
 1128a8c:	9100e3f6 	add	x22, sp, #0x38
 1128a90:	aa1503e2 	mov	x2, x21
 1128a94:	aa1403e1 	mov	x1, x20
 1128a98:	aa1603e0 	mov	x0, x22
 1128a9c:	97ff6a3d 	bl	1103390 <memcpy>
		memcpy(tmp + 16, *key, 8);
		*key = tmp;
		*key_len = 24;
 1128aa0:	d2800315 	mov	x21, #0x18                  	// #24
		memcpy(tmp + 16, *key, 8);
 1128aa4:	aa1403e1 	mov	x1, x20
		*key = tmp;
 1128aa8:	aa1603f4 	mov	x20, x22
		memcpy(tmp + 16, *key, 8);
 1128aac:	910042c0 	add	x0, x22, #0x10
 1128ab0:	d2800102 	mov	x2, #0x8                   	// #8
 1128ab4:	97ff6a37 	bl	1103390 <memcpy>
	if (ecb_start(c->cipher_idx, k, kl, 0, &c->state) == CRYPT_OK)
 1128ab8:	b9400a60 	ldr	w0, [x19, #8]
 1128abc:	91006264 	add	x4, x19, #0x18
 1128ac0:	2a1503e2 	mov	w2, w21
 1128ac4:	aa1403e1 	mov	x1, x20
 1128ac8:	52800003 	mov	w3, #0x0                   	// #0
 1128acc:	94002a4a 	bl	11333f4 <ecb_start>
		return TEE_ERROR_BAD_STATE;
 1128ad0:	7100001f 	cmp	w0, #0x0
}
 1128ad4:	129fff00 	mov	w0, #0xffff0007            	// #-65529
 1128ad8:	1a9f1000 	csel	w0, w0, wzr, ne  // ne = any
 1128adc:	a94153f3 	ldp	x19, x20, [sp, #16]
 1128ae0:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1128ae4:	a8c57bfd 	ldp	x29, x30, [sp], #80
 1128ae8:	d65f03c0 	ret

0000000001128aec <ltc_ecb_copy_state>:
{
 1128aec:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1128af0:	910003fd 	mov	x29, sp
 1128af4:	a90153f3 	stp	x19, x20, [sp, #16]
 1128af8:	aa0003f4 	mov	x20, x0
 1128afc:	aa0103e0 	mov	x0, x1
	struct ltc_ecb_ctx *src = to_ecb_ctx(src_ctx);
 1128b00:	97ffff9a 	bl	1128968 <to_ecb_ctx>
 1128b04:	aa0003f3 	mov	x19, x0
	struct ltc_ecb_ctx *dst = to_ecb_ctx(dst_ctx);
 1128b08:	aa1403e0 	mov	x0, x20
 1128b0c:	97ffff97 	bl	1128968 <to_ecb_ctx>
	assert(src->cipher_idx == dst->cipher_idx);
 1128b10:	b9400801 	ldr	w1, [x0, #8]
 1128b14:	b9400a62 	ldr	w2, [x19, #8]
 1128b18:	6b01005f 	cmp	w2, w1
 1128b1c:	54000140 	b.eq	1128b44 <ltc_ecb_copy_state+0x58>  // b.none
 1128b20:	d0000163 	adrp	x3, 1156000 <ta_pub_key_modulus+0x7>
 1128b24:	d0000161 	adrp	x1, 1156000 <ta_pub_key_modulus+0x7>
 1128b28:	910e2063 	add	x3, x3, #0x388
 1128b2c:	910d0821 	add	x1, x1, #0x342
 1128b30:	d0000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 1128b34:	910bd800 	add	x0, x0, #0x2f6
 1128b38:	52800b02 	mov	w2, #0x58                  	// #88
 1128b3c:	97ffa5dc 	bl	11122ac <_assert_log>
 1128b40:	97ffa5ec 	bl	11122f0 <_assert_break>
	dst->update = src->update;
 1128b44:	f9400a61 	ldr	x1, [x19, #16]
 1128b48:	f9000801 	str	x1, [x0, #16]
	dst->state = src->state;
 1128b4c:	d2806102 	mov	x2, #0x308                 	// #776
 1128b50:	91006261 	add	x1, x19, #0x18
 1128b54:	91006000 	add	x0, x0, #0x18
 1128b58:	97ff6a0e 	bl	1103390 <memcpy>
}
 1128b5c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1128b60:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1128b64:	d65f03c0 	ret

0000000001128b68 <crypto_aes_ecb_alloc_ctx>:

#if defined(_CFG_CORE_LTC_AES)
TEE_Result crypto_aes_ecb_alloc_ctx(struct crypto_cipher_ctx **ctx)
{
 1128b68:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1128b6c:	910003fd 	mov	x29, sp
 1128b70:	f9000bf3 	str	x19, [sp, #16]
 1128b74:	aa0003f3 	mov	x19, x0
	return ltc_ecb_alloc_ctx(ctx, find_cipher("aes"), false);
 1128b78:	d0000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 1128b7c:	910c6400 	add	x0, x0, #0x319
 1128b80:	9400264e 	bl	11324b8 <find_cipher>
 1128b84:	2a0003e1 	mov	w1, w0
 1128b88:	aa1303e0 	mov	x0, x19
 1128b8c:	52800002 	mov	w2, #0x0                   	// #0
}
 1128b90:	f9400bf3 	ldr	x19, [sp, #16]
 1128b94:	a8c27bfd 	ldp	x29, x30, [sp], #32
	return ltc_ecb_alloc_ctx(ctx, find_cipher("aes"), false);
 1128b98:	17ffff59 	b	11288fc <ltc_ecb_alloc_ctx>

0000000001128b9c <crypto_des_ecb_alloc_ctx>:
#endif

#if defined(_CFG_CORE_LTC_DES)
TEE_Result crypto_des_ecb_alloc_ctx(struct crypto_cipher_ctx **ctx)
{
 1128b9c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1128ba0:	910003fd 	mov	x29, sp
 1128ba4:	f9000bf3 	str	x19, [sp, #16]
 1128ba8:	aa0003f3 	mov	x19, x0
	return ltc_ecb_alloc_ctx(ctx, find_cipher("des"), false);
 1128bac:	d0000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 1128bb0:	910c7800 	add	x0, x0, #0x31e
 1128bb4:	94002641 	bl	11324b8 <find_cipher>
 1128bb8:	2a0003e1 	mov	w1, w0
 1128bbc:	aa1303e0 	mov	x0, x19
 1128bc0:	52800002 	mov	w2, #0x0                   	// #0
}
 1128bc4:	f9400bf3 	ldr	x19, [sp, #16]
 1128bc8:	a8c27bfd 	ldp	x29, x30, [sp], #32
	return ltc_ecb_alloc_ctx(ctx, find_cipher("des"), false);
 1128bcc:	17ffff4c 	b	11288fc <ltc_ecb_alloc_ctx>

0000000001128bd0 <crypto_des3_ecb_alloc_ctx>:

TEE_Result crypto_des3_ecb_alloc_ctx(struct crypto_cipher_ctx **ctx)
{
 1128bd0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1128bd4:	910003fd 	mov	x29, sp
 1128bd8:	f9000bf3 	str	x19, [sp, #16]
 1128bdc:	aa0003f3 	mov	x19, x0
	return ltc_ecb_alloc_ctx(ctx, find_cipher("3des"), true);
 1128be0:	d0000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 1128be4:	910c7400 	add	x0, x0, #0x31d
 1128be8:	94002634 	bl	11324b8 <find_cipher>
 1128bec:	2a0003e1 	mov	w1, w0
 1128bf0:	aa1303e0 	mov	x0, x19
 1128bf4:	52800022 	mov	w2, #0x1                   	// #1
}
 1128bf8:	f9400bf3 	ldr	x19, [sp, #16]
 1128bfc:	a8c27bfd 	ldp	x29, x30, [sp], #32
	return ltc_ecb_alloc_ctx(ctx, find_cipher("3des"), true);
 1128c00:	17ffff3f 	b	11288fc <ltc_ecb_alloc_ctx>

0000000001128c04 <ltc_cbc_alloc_ctx>:
static TEE_Result ltc_cbc_alloc_ctx(struct crypto_cipher_ctx **ctx_ret,
				    int cipher_idx, bool des3)
{
	struct ltc_cbc_ctx *c = NULL;

	if (cipher_idx < 0)
 1128c04:	37f802e1 	tbnz	w1, #31, 1128c60 <ltc_cbc_alloc_ctx+0x5c>
{
 1128c08:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1128c0c:	910003fd 	mov	x29, sp
 1128c10:	a90153f3 	stp	x19, x20, [sp, #16]
 1128c14:	aa0003f4 	mov	x20, x0
 1128c18:	2a0103f3 	mov	w19, w1
		return TEE_ERROR_NOT_SUPPORTED;

	c = calloc(1, sizeof(*c));
 1128c1c:	d2800020 	mov	x0, #0x1                   	// #1
 1128c20:	d2807601 	mov	x1, #0x3b0                 	// #944
{
 1128c24:	f90013f5 	str	x21, [sp, #32]
 1128c28:	12001c55 	and	w21, w2, #0xff
	c = calloc(1, sizeof(*c));
 1128c2c:	94006a29 	bl	11434d0 <calloc>
	if (!c)
 1128c30:	b40001c0 	cbz	x0, 1128c68 <ltc_cbc_alloc_ctx+0x64>
		return TEE_ERROR_OUT_OF_MEMORY;

	c->ctx.ops = &ltc_cbc_ops;
 1128c34:	f0000181 	adrp	x1, 115b000 <__vcore_unpg_rw_start>
 1128c38:	913ee021 	add	x1, x1, #0xfb8
	c->cipher_idx = cipher_idx;
	c->des3 = des3;
	*ctx_ret = &c->ctx;
 1128c3c:	f9000280 	str	x0, [x20]
	c->ctx.ops = &ltc_cbc_ops;
 1128c40:	f9000001 	str	x1, [x0]
	c->cipher_idx = cipher_idx;
 1128c44:	b9000813 	str	w19, [x0, #8]
	c->des3 = des3;
 1128c48:	39003015 	strb	w21, [x0, #12]

	return TEE_SUCCESS;
 1128c4c:	52800000 	mov	w0, #0x0                   	// #0
}
 1128c50:	a94153f3 	ldp	x19, x20, [sp, #16]
 1128c54:	f94013f5 	ldr	x21, [sp, #32]
 1128c58:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1128c5c:	d65f03c0 	ret
		return TEE_ERROR_NOT_SUPPORTED;
 1128c60:	129ffea0 	mov	w0, #0xffff000a            	// #-65526
}
 1128c64:	d65f03c0 	ret
		return TEE_ERROR_OUT_OF_MEMORY;
 1128c68:	129ffe60 	mov	w0, #0xffff000c            	// #-65524
 1128c6c:	17fffff9 	b	1128c50 <ltc_cbc_alloc_ctx+0x4c>

0000000001128c70 <to_cbc_ctx>:
	assert(ctx && ctx->ops == &ltc_cbc_ops);
 1128c70:	b40000c0 	cbz	x0, 1128c88 <to_cbc_ctx+0x18>
 1128c74:	f9400002 	ldr	x2, [x0]
 1128c78:	f0000181 	adrp	x1, 115b000 <__vcore_unpg_rw_start>
 1128c7c:	913ee021 	add	x1, x1, #0xfb8
 1128c80:	eb01005f 	cmp	x2, x1
 1128c84:	54000180 	b.eq	1128cb4 <to_cbc_ctx+0x44>  // b.none
 1128c88:	d0000163 	adrp	x3, 1156000 <ta_pub_key_modulus+0x7>
 1128c8c:	d0000161 	adrp	x1, 1156000 <ta_pub_key_modulus+0x7>
 1128c90:	910f5863 	add	x3, x3, #0x3d6
 1128c94:	910e6c21 	add	x1, x1, #0x39b
 1128c98:	d0000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 1128c9c:	910ed800 	add	x0, x0, #0x3b6
{
 1128ca0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	assert(ctx && ctx->ops == &ltc_cbc_ops);
 1128ca4:	528003a2 	mov	w2, #0x1d                  	// #29
{
 1128ca8:	910003fd 	mov	x29, sp
	assert(ctx && ctx->ops == &ltc_cbc_ops);
 1128cac:	97ffa580 	bl	11122ac <_assert_log>
 1128cb0:	97ffa590 	bl	11122f0 <_assert_break>
}
 1128cb4:	d65f03c0 	ret

0000000001128cb8 <ltc_cbc_update>:
{
 1128cb8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1128cbc:	910003fd 	mov	x29, sp
 1128cc0:	a90153f3 	stp	x19, x20, [sp, #16]
 1128cc4:	aa0403f4 	mov	x20, x4
 1128cc8:	aa0203f3 	mov	x19, x2
 1128ccc:	f90013f5 	str	x21, [sp, #32]
 1128cd0:	aa0303f5 	mov	x21, x3
	struct ltc_cbc_ctx *c = to_cbc_ctx(ctx);
 1128cd4:	97ffffe7 	bl	1128c70 <to_cbc_ctx>
	if (c->update && c->update(data, dst, len, &c->state) == CRYPT_OK)
 1128cd8:	f9400804 	ldr	x4, [x0, #16]
 1128cdc:	b40000e4 	cbz	x4, 1128cf8 <ltc_cbc_update+0x40>
 1128ce0:	91006003 	add	x3, x0, #0x18
 1128ce4:	aa1503e2 	mov	x2, x21
 1128ce8:	aa1403e1 	mov	x1, x20
 1128cec:	aa1303e0 	mov	x0, x19
 1128cf0:	d63f0080 	blr	x4
 1128cf4:	340000c0 	cbz	w0, 1128d0c <ltc_cbc_update+0x54>
		return TEE_ERROR_BAD_STATE;
 1128cf8:	129fff00 	mov	w0, #0xffff0007            	// #-65529
}
 1128cfc:	a94153f3 	ldp	x19, x20, [sp, #16]
 1128d00:	f94013f5 	ldr	x21, [sp, #32]
 1128d04:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1128d08:	d65f03c0 	ret
		return TEE_SUCCESS;
 1128d0c:	52800000 	mov	w0, #0x0                   	// #0
 1128d10:	17fffffb 	b	1128cfc <ltc_cbc_update+0x44>

0000000001128d14 <ltc_cbc_free_ctx>:
{
 1128d14:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 1128d18:	910003fd 	mov	x29, sp
	free(to_cbc_ctx(ctx));
 1128d1c:	97ffffd5 	bl	1128c70 <to_cbc_ctx>
}
 1128d20:	a8c17bfd 	ldp	x29, x30, [sp], #16
	free(to_cbc_ctx(ctx));
 1128d24:	14006a2f 	b	11435e0 <free>

0000000001128d28 <ltc_cbc_final>:
{
 1128d28:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 1128d2c:	910003fd 	mov	x29, sp
	cbc_done(&to_cbc_ctx(ctx)->state);
 1128d30:	97ffffd0 	bl	1128c70 <to_cbc_ctx>
 1128d34:	91006000 	add	x0, x0, #0x18
}
 1128d38:	a8c17bfd 	ldp	x29, x30, [sp], #16
	cbc_done(&to_cbc_ctx(ctx)->state);
 1128d3c:	14002751 	b	1132a80 <cbc_done>

0000000001128d40 <ltc_cbc_init>:
{
 1128d40:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
 1128d44:	910003fd 	mov	x29, sp
 1128d48:	a90153f3 	stp	x19, x20, [sp, #16]
 1128d4c:	aa0203f4 	mov	x20, x2
 1128d50:	a9025bf5 	stp	x21, x22, [sp, #32]
 1128d54:	2a0103f6 	mov	w22, w1
 1128d58:	aa0303f5 	mov	x21, x3
 1128d5c:	a90363f7 	stp	x23, x24, [sp, #48]
 1128d60:	aa0703f8 	mov	x24, x7
 1128d64:	aa0603f7 	mov	x23, x6
	struct ltc_cbc_ctx *c = to_cbc_ctx(ctx);
 1128d68:	97ffffc2 	bl	1128c70 <to_cbc_ctx>
 1128d6c:	aa0003f3 	mov	x19, x0
	if ((int)iv_len != cipher_descriptor[c->cipher_idx]->block_length)
 1128d70:	d0000180 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
	uint8_t tmp[24] = { 0 };
 1128d74:	a904ffff 	stp	xzr, xzr, [sp, #72]
 1128d78:	f9002fff 	str	xzr, [sp, #88]
	if ((int)iv_len != cipher_descriptor[c->cipher_idx]->block_length)
 1128d7c:	f941c001 	ldr	x1, [x0, #896]
 1128d80:	b9800a62 	ldrsw	x2, [x19, #8]
 1128d84:	f8627821 	ldr	x1, [x1, x2, lsl #3]
 1128d88:	b9401421 	ldr	w1, [x1, #20]
 1128d8c:	6b18003f 	cmp	w1, w24
 1128d90:	54000481 	b.ne	1128e20 <ltc_cbc_init+0xe0>  // b.any
		c->update = cbc_decrypt;
 1128d94:	f9414c01 	ldr	x1, [x0, #664]
 1128d98:	710002df 	cmp	w22, #0x0
 1128d9c:	f9420400 	ldr	x0, [x0, #1032]
 1128da0:	9a800020 	csel	x0, x1, x0, eq  // eq = none
 1128da4:	f9000a60 	str	x0, [x19, #16]
	if (c->des3)
 1128da8:	39403260 	ldrb	w0, [x19, #12]
 1128dac:	340001c0 	cbz	w0, 1128de4 <ltc_cbc_init+0xa4>
	if (*key_len == 16) {
 1128db0:	f10042bf 	cmp	x21, #0x10
 1128db4:	54000181 	b.ne	1128de4 <ltc_cbc_init+0xa4>  // b.any
		memcpy(tmp, *key, 16);
 1128db8:	910123f6 	add	x22, sp, #0x48
 1128dbc:	aa1503e2 	mov	x2, x21
 1128dc0:	aa1403e1 	mov	x1, x20
 1128dc4:	aa1603e0 	mov	x0, x22
 1128dc8:	97ff6972 	bl	1103390 <memcpy>
		*key_len = 24;
 1128dcc:	d2800315 	mov	x21, #0x18                  	// #24
		memcpy(tmp + 16, *key, 8);
 1128dd0:	aa1403e1 	mov	x1, x20
		*key = tmp;
 1128dd4:	aa1603f4 	mov	x20, x22
		memcpy(tmp + 16, *key, 8);
 1128dd8:	910042c0 	add	x0, x22, #0x10
 1128ddc:	d2800102 	mov	x2, #0x8                   	// #8
 1128de0:	97ff696c 	bl	1103390 <memcpy>
	if (cbc_start(c->cipher_idx, iv, k, kl, 0, &c->state) == CRYPT_OK)
 1128de4:	b9400a60 	ldr	w0, [x19, #8]
 1128de8:	91006265 	add	x5, x19, #0x18
 1128dec:	2a1503e3 	mov	w3, w21
 1128df0:	aa1403e2 	mov	x2, x20
 1128df4:	aa1703e1 	mov	x1, x23
 1128df8:	52800004 	mov	w4, #0x0                   	// #0
 1128dfc:	9400278d 	bl	1132c30 <cbc_start>
		return TEE_ERROR_BAD_STATE;
 1128e00:	7100001f 	cmp	w0, #0x0
 1128e04:	129fff00 	mov	w0, #0xffff0007            	// #-65529
 1128e08:	1a8003e0 	csel	w0, wzr, w0, eq  // eq = none
}
 1128e0c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1128e10:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1128e14:	a94363f7 	ldp	x23, x24, [sp, #48]
 1128e18:	a8c67bfd 	ldp	x29, x30, [sp], #96
 1128e1c:	d65f03c0 	ret
		return TEE_ERROR_BAD_PARAMETERS;
 1128e20:	129fff20 	mov	w0, #0xffff0006            	// #-65530
 1128e24:	17fffffa 	b	1128e0c <ltc_cbc_init+0xcc>

0000000001128e28 <ltc_cbc_copy_state>:
{
 1128e28:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1128e2c:	910003fd 	mov	x29, sp
 1128e30:	a90153f3 	stp	x19, x20, [sp, #16]
 1128e34:	aa0003f4 	mov	x20, x0
 1128e38:	aa0103e0 	mov	x0, x1
	struct ltc_cbc_ctx *src = to_cbc_ctx(src_ctx);
 1128e3c:	97ffff8d 	bl	1128c70 <to_cbc_ctx>
 1128e40:	aa0003f3 	mov	x19, x0
	struct ltc_cbc_ctx *dst = to_cbc_ctx(dst_ctx);
 1128e44:	aa1403e0 	mov	x0, x20
 1128e48:	97ffff8a 	bl	1128c70 <to_cbc_ctx>
	assert(src->cipher_idx == dst->cipher_idx);
 1128e4c:	b9400801 	ldr	w1, [x0, #8]
 1128e50:	b9400a62 	ldr	w2, [x19, #8]
 1128e54:	6b01005f 	cmp	w2, w1
 1128e58:	54000140 	b.eq	1128e80 <ltc_cbc_copy_state+0x58>  // b.none
 1128e5c:	d0000163 	adrp	x3, 1156000 <ta_pub_key_modulus+0x7>
 1128e60:	d0000161 	adrp	x1, 1156000 <ta_pub_key_modulus+0x7>
 1128e64:	910f8463 	add	x3, x3, #0x3e1
 1128e68:	910e6c21 	add	x1, x1, #0x39b
 1128e6c:	d0000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 1128e70:	910bd800 	add	x0, x0, #0x2f6
 1128e74:	52800b42 	mov	w2, #0x5a                  	// #90
 1128e78:	97ffa50d 	bl	11122ac <_assert_log>
 1128e7c:	97ffa51d 	bl	11122f0 <_assert_break>
	dst->update = src->update;
 1128e80:	f9400a61 	ldr	x1, [x19, #16]
 1128e84:	f9000801 	str	x1, [x0, #16]
	dst->state = src->state;
 1128e88:	d2807302 	mov	x2, #0x398                 	// #920
 1128e8c:	91006261 	add	x1, x19, #0x18
 1128e90:	91006000 	add	x0, x0, #0x18
 1128e94:	97ff693f 	bl	1103390 <memcpy>
}
 1128e98:	a94153f3 	ldp	x19, x20, [sp, #16]
 1128e9c:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1128ea0:	d65f03c0 	ret

0000000001128ea4 <crypto_aes_cbc_alloc_ctx>:

#if defined(_CFG_CORE_LTC_AES)
TEE_Result crypto_aes_cbc_alloc_ctx(struct crypto_cipher_ctx **ctx)
{
 1128ea4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1128ea8:	910003fd 	mov	x29, sp
 1128eac:	f9000bf3 	str	x19, [sp, #16]
 1128eb0:	aa0003f3 	mov	x19, x0
	return ltc_cbc_alloc_ctx(ctx, find_cipher("aes"), false);
 1128eb4:	d0000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 1128eb8:	910c6400 	add	x0, x0, #0x319
 1128ebc:	9400257f 	bl	11324b8 <find_cipher>
 1128ec0:	2a0003e1 	mov	w1, w0
 1128ec4:	aa1303e0 	mov	x0, x19
 1128ec8:	52800002 	mov	w2, #0x0                   	// #0
}
 1128ecc:	f9400bf3 	ldr	x19, [sp, #16]
 1128ed0:	a8c27bfd 	ldp	x29, x30, [sp], #32
	return ltc_cbc_alloc_ctx(ctx, find_cipher("aes"), false);
 1128ed4:	17ffff4c 	b	1128c04 <ltc_cbc_alloc_ctx>

0000000001128ed8 <crypto_des_cbc_alloc_ctx>:
#endif

#if defined(_CFG_CORE_LTC_DES)
TEE_Result crypto_des_cbc_alloc_ctx(struct crypto_cipher_ctx **ctx)
{
 1128ed8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1128edc:	910003fd 	mov	x29, sp
 1128ee0:	f9000bf3 	str	x19, [sp, #16]
 1128ee4:	aa0003f3 	mov	x19, x0
	return ltc_cbc_alloc_ctx(ctx, find_cipher("des"), false);
 1128ee8:	d0000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 1128eec:	910c7800 	add	x0, x0, #0x31e
 1128ef0:	94002572 	bl	11324b8 <find_cipher>
 1128ef4:	2a0003e1 	mov	w1, w0
 1128ef8:	aa1303e0 	mov	x0, x19
 1128efc:	52800002 	mov	w2, #0x0                   	// #0
}
 1128f00:	f9400bf3 	ldr	x19, [sp, #16]
 1128f04:	a8c27bfd 	ldp	x29, x30, [sp], #32
	return ltc_cbc_alloc_ctx(ctx, find_cipher("des"), false);
 1128f08:	17ffff3f 	b	1128c04 <ltc_cbc_alloc_ctx>

0000000001128f0c <crypto_des3_cbc_alloc_ctx>:

TEE_Result crypto_des3_cbc_alloc_ctx(struct crypto_cipher_ctx **ctx)
{
 1128f0c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1128f10:	910003fd 	mov	x29, sp
 1128f14:	f9000bf3 	str	x19, [sp, #16]
 1128f18:	aa0003f3 	mov	x19, x0
	return ltc_cbc_alloc_ctx(ctx, find_cipher("3des"), true);
 1128f1c:	d0000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 1128f20:	910c7400 	add	x0, x0, #0x31d
 1128f24:	94002565 	bl	11324b8 <find_cipher>
 1128f28:	2a0003e1 	mov	w1, w0
 1128f2c:	aa1303e0 	mov	x0, x19
 1128f30:	52800022 	mov	w2, #0x1                   	// #1
}
 1128f34:	f9400bf3 	ldr	x19, [sp, #16]
 1128f38:	a8c27bfd 	ldp	x29, x30, [sp], #32
	return ltc_cbc_alloc_ctx(ctx, find_cipher("3des"), true);
 1128f3c:	17ffff32 	b	1128c04 <ltc_cbc_alloc_ctx>

0000000001128f40 <to_ctr_ctx>:

static const struct crypto_cipher_ops ltc_ctr_ops;

static struct ltc_ctr_ctx *to_ctr_ctx(struct crypto_cipher_ctx *ctx)
{
	assert(ctx && ctx->ops == &ltc_ctr_ops);
 1128f40:	b40000c0 	cbz	x0, 1128f58 <to_ctr_ctx+0x18>
 1128f44:	f9400002 	ldr	x2, [x0]
 1128f48:	f0000181 	adrp	x1, 115b000 <__vcore_unpg_rw_start>
 1128f4c:	913f8021 	add	x1, x1, #0xfe0
 1128f50:	eb01005f 	cmp	x2, x1
 1128f54:	54000180 	b.eq	1128f84 <to_ctr_ctx+0x44>  // b.none
 1128f58:	d0000163 	adrp	x3, 1156000 <ta_pub_key_modulus+0x7>
 1128f5c:	d0000161 	adrp	x1, 1156000 <ta_pub_key_modulus+0x7>
 1128f60:	9110bc63 	add	x3, x3, #0x42f
 1128f64:	910fd021 	add	x1, x1, #0x3f4
 1128f68:	d0000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 1128f6c:	91103c00 	add	x0, x0, #0x40f
{
 1128f70:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	assert(ctx && ctx->ops == &ltc_ctr_ops);
 1128f74:	52800342 	mov	w2, #0x1a                  	// #26
{
 1128f78:	910003fd 	mov	x29, sp
	assert(ctx && ctx->ops == &ltc_ctr_ops);
 1128f7c:	97ffa4cc 	bl	11122ac <_assert_log>
 1128f80:	97ffa4dc 	bl	11122f0 <_assert_break>

	return container_of(ctx, struct ltc_ctr_ctx, ctx);
}
 1128f84:	d65f03c0 	ret

0000000001128f88 <ltc_ctr_update>:
}

static TEE_Result ltc_ctr_update(struct crypto_cipher_ctx *ctx,
				 bool last_block __unused,
				 const uint8_t *data, size_t len, uint8_t *dst)
{
 1128f88:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1128f8c:	910003fd 	mov	x29, sp
 1128f90:	a90153f3 	stp	x19, x20, [sp, #16]
 1128f94:	aa0403f4 	mov	x20, x4
 1128f98:	aa0203f3 	mov	x19, x2
 1128f9c:	f90013f5 	str	x21, [sp, #32]
 1128fa0:	aa0303f5 	mov	x21, x3
	struct ltc_ctr_ctx *c = to_ctr_ctx(ctx);
 1128fa4:	97ffffe7 	bl	1128f40 <to_ctr_ctx>

	if (c->update && c->update(data, dst, len, &c->state) == CRYPT_OK)
 1128fa8:	f9400804 	ldr	x4, [x0, #16]
 1128fac:	b40000e4 	cbz	x4, 1128fc8 <ltc_ctr_update+0x40>
 1128fb0:	91006003 	add	x3, x0, #0x18
 1128fb4:	aa1503e2 	mov	x2, x21
 1128fb8:	aa1403e1 	mov	x1, x20
 1128fbc:	aa1303e0 	mov	x0, x19
 1128fc0:	d63f0080 	blr	x4
 1128fc4:	340000c0 	cbz	w0, 1128fdc <ltc_ctr_update+0x54>
		return TEE_SUCCESS;
	else
		return TEE_ERROR_BAD_STATE;
 1128fc8:	129fff00 	mov	w0, #0xffff0007            	// #-65529
}
 1128fcc:	a94153f3 	ldp	x19, x20, [sp, #16]
 1128fd0:	f94013f5 	ldr	x21, [sp, #32]
 1128fd4:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1128fd8:	d65f03c0 	ret
		return TEE_SUCCESS;
 1128fdc:	52800000 	mov	w0, #0x0                   	// #0
 1128fe0:	17fffffb 	b	1128fcc <ltc_ctr_update+0x44>

0000000001128fe4 <ltc_ctr_free_ctx>:
{
	ctr_done(&to_ctr_ctx(ctx)->state);
}

static void ltc_ctr_free_ctx(struct crypto_cipher_ctx *ctx)
{
 1128fe4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 1128fe8:	910003fd 	mov	x29, sp
	free(to_ctr_ctx(ctx));
 1128fec:	97ffffd5 	bl	1128f40 <to_ctr_ctx>
}
 1128ff0:	a8c17bfd 	ldp	x29, x30, [sp], #16
	free(to_ctr_ctx(ctx));
 1128ff4:	1400697b 	b	11435e0 <free>

0000000001128ff8 <ltc_ctr_final>:
{
 1128ff8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 1128ffc:	910003fd 	mov	x29, sp
	ctr_done(&to_ctr_ctx(ctx)->state);
 1129000:	97ffffd0 	bl	1128f40 <to_ctr_ctx>
 1129004:	91006000 	add	x0, x0, #0x18
}
 1129008:	a8c17bfd 	ldp	x29, x30, [sp], #16
	ctr_done(&to_ctr_ctx(ctx)->state);
 112900c:	14002740 	b	1132d0c <ctr_done>

0000000001129010 <ltc_ctr_init>:
{
 1129010:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 1129014:	910003fd 	mov	x29, sp
 1129018:	a90153f3 	stp	x19, x20, [sp, #16]
 112901c:	aa0603f3 	mov	x19, x6
 1129020:	aa0203f4 	mov	x20, x2
 1129024:	a9025bf5 	stp	x21, x22, [sp, #32]
 1129028:	2a0103f6 	mov	w22, w1
 112902c:	aa0303f5 	mov	x21, x3
 1129030:	f9001bf7 	str	x23, [sp, #48]
 1129034:	aa0703f7 	mov	x23, x7
	struct ltc_ctr_ctx *c = to_ctr_ctx(ctx);
 1129038:	97ffffc2 	bl	1128f40 <to_ctr_ctx>
 112903c:	aa0003e6 	mov	x6, x0
	if ((int)iv_len != cipher_descriptor[c->cipher_idx]->block_length)
 1129040:	b0000185 	adrp	x5, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1129044:	b9400800 	ldr	w0, [x0, #8]
 1129048:	f941c0a1 	ldr	x1, [x5, #896]
 112904c:	f860d821 	ldr	x1, [x1, w0, sxtw #3]
 1129050:	b9401421 	ldr	w1, [x1, #20]
 1129054:	6b17003f 	cmp	w1, w23
 1129058:	540002a1 	b.ne	11290ac <ltc_ctr_init+0x9c>  // b.any
		c->update = ctr_decrypt;
 112905c:	f941fca1 	ldr	x1, [x5, #1016]
 1129060:	710002df 	cmp	w22, #0x0
 1129064:	f941b4a5 	ldr	x5, [x5, #872]
	if (ctr_start(c->cipher_idx, iv, key1, key1_len, 0,
 1129068:	2a1503e3 	mov	w3, w21
 112906c:	aa1403e2 	mov	x2, x20
 1129070:	910060c6 	add	x6, x6, #0x18
		c->update = ctr_decrypt;
 1129074:	9a850025 	csel	x5, x1, x5, eq  // eq = none
 1129078:	f81f80c5 	stur	x5, [x6, #-8]
	if (ctr_start(c->cipher_idx, iv, key1, key1_len, 0,
 112907c:	aa1303e1 	mov	x1, x19
 1129080:	52800004 	mov	w4, #0x0                   	// #0
 1129084:	52820005 	mov	w5, #0x1000                	// #4096
 1129088:	940027da 	bl	1132ff0 <ctr_start>
		return TEE_ERROR_BAD_STATE;
 112908c:	7100001f 	cmp	w0, #0x0
 1129090:	129fff00 	mov	w0, #0xffff0007            	// #-65529
 1129094:	1a8003e0 	csel	w0, wzr, w0, eq  // eq = none
}
 1129098:	a94153f3 	ldp	x19, x20, [sp, #16]
 112909c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11290a0:	f9401bf7 	ldr	x23, [sp, #48]
 11290a4:	a8c47bfd 	ldp	x29, x30, [sp], #64
 11290a8:	d65f03c0 	ret
		return TEE_ERROR_BAD_PARAMETERS;
 11290ac:	129fff20 	mov	w0, #0xffff0006            	// #-65530
 11290b0:	17fffffa 	b	1129098 <ltc_ctr_init+0x88>

00000000011290b4 <ltc_ctr_copy_state>:

static void ltc_ctr_copy_state(struct crypto_cipher_ctx *dst_ctx,
			       struct crypto_cipher_ctx *src_ctx)
{
 11290b4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 11290b8:	910003fd 	mov	x29, sp
 11290bc:	a90153f3 	stp	x19, x20, [sp, #16]
 11290c0:	aa0003f4 	mov	x20, x0
 11290c4:	aa0103e0 	mov	x0, x1
	struct ltc_ctr_ctx *src = to_ctr_ctx(src_ctx);
 11290c8:	97ffff9e 	bl	1128f40 <to_ctr_ctx>
 11290cc:	aa0003f3 	mov	x19, x0
	struct ltc_ctr_ctx *dst = to_ctr_ctx(dst_ctx);
 11290d0:	aa1403e0 	mov	x0, x20
 11290d4:	97ffff9b 	bl	1128f40 <to_ctr_ctx>

	assert(src->cipher_idx == dst->cipher_idx);
 11290d8:	b9400801 	ldr	w1, [x0, #8]
 11290dc:	b9400a62 	ldr	w2, [x19, #8]
 11290e0:	6b01005f 	cmp	w2, w1
 11290e4:	54000140 	b.eq	112910c <ltc_ctr_copy_state+0x58>  // b.none
 11290e8:	b0000163 	adrp	x3, 1156000 <ta_pub_key_modulus+0x7>
 11290ec:	b0000161 	adrp	x1, 1156000 <ta_pub_key_modulus+0x7>
 11290f0:	9110e863 	add	x3, x3, #0x43a
 11290f4:	910fd021 	add	x1, x1, #0x3f4
 11290f8:	b0000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 11290fc:	910bd800 	add	x0, x0, #0x2f6
 1129100:	52800a62 	mov	w2, #0x53                  	// #83
 1129104:	97ffa46a 	bl	11122ac <_assert_log>
 1129108:	97ffa47a 	bl	11122f0 <_assert_break>
	dst->update = src->update;
 112910c:	f9400a61 	ldr	x1, [x19, #16]
 1129110:	f9000801 	str	x1, [x0, #16]
	dst->state = src->state;
 1129114:	d2808702 	mov	x2, #0x438                 	// #1080
 1129118:	91006261 	add	x1, x19, #0x18
 112911c:	91006000 	add	x0, x0, #0x18
 1129120:	97ff689c 	bl	1103390 <memcpy>
}
 1129124:	a94153f3 	ldp	x19, x20, [sp, #16]
 1129128:	a8c27bfd 	ldp	x29, x30, [sp], #32
 112912c:	d65f03c0 	ret

0000000001129130 <crypto_aes_ctr_alloc_ctx>:
	.free_ctx = ltc_ctr_free_ctx,
	.copy_state = ltc_ctr_copy_state,
};

TEE_Result crypto_aes_ctr_alloc_ctx(struct crypto_cipher_ctx **ctx_ret)
{
 1129130:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1129134:	910003fd 	mov	x29, sp
 1129138:	a90153f3 	stp	x19, x20, [sp, #16]
 112913c:	aa0003f4 	mov	x20, x0
	struct ltc_ctr_ctx *c = NULL;
	int cipher_idx = find_cipher("aes");
 1129140:	b0000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 1129144:	910c6400 	add	x0, x0, #0x319
 1129148:	940024dc 	bl	11324b8 <find_cipher>

	if (cipher_idx < 0)
 112914c:	37f801e0 	tbnz	w0, #31, 1129188 <crypto_aes_ctr_alloc_ctx+0x58>
 1129150:	2a0003f3 	mov	w19, w0
		return TEE_ERROR_NOT_SUPPORTED;

	c = calloc(1, sizeof(*c));
 1129154:	d2808a01 	mov	x1, #0x450                 	// #1104
 1129158:	d2800020 	mov	x0, #0x1                   	// #1
 112915c:	940068dd 	bl	11434d0 <calloc>
	if (!c)
 1129160:	b4000180 	cbz	x0, 1129190 <crypto_aes_ctr_alloc_ctx+0x60>
		return TEE_ERROR_OUT_OF_MEMORY;

	c->ctx.ops = &ltc_ctr_ops;
 1129164:	d0000181 	adrp	x1, 115b000 <__vcore_unpg_rw_start>
 1129168:	913f8021 	add	x1, x1, #0xfe0
	c->cipher_idx = cipher_idx;
	*ctx_ret = &c->ctx;
 112916c:	f9000280 	str	x0, [x20]
	c->ctx.ops = &ltc_ctr_ops;
 1129170:	f9000001 	str	x1, [x0]
	c->cipher_idx = cipher_idx;
 1129174:	b9000813 	str	w19, [x0, #8]

	return TEE_SUCCESS;
 1129178:	52800000 	mov	w0, #0x0                   	// #0
}
 112917c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1129180:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1129184:	d65f03c0 	ret
		return TEE_ERROR_NOT_SUPPORTED;
 1129188:	129ffea0 	mov	w0, #0xffff000a            	// #-65526
 112918c:	17fffffc 	b	112917c <crypto_aes_ctr_alloc_ctx+0x4c>
		return TEE_ERROR_OUT_OF_MEMORY;
 1129190:	129ffe60 	mov	w0, #0xffff000c            	// #-65524
 1129194:	17fffffa 	b	112917c <crypto_aes_ctr_alloc_ctx+0x4c>

0000000001129198 <to_xts_ctx>:

static const struct crypto_cipher_ops ltc_xts_ops;

static struct ltc_xts_ctx *to_xts_ctx(struct crypto_cipher_ctx *ctx)
{
	assert(ctx && ctx->ops == &ltc_xts_ops);
 1129198:	b40000c0 	cbz	x0, 11291b0 <to_xts_ctx+0x18>
 112919c:	f9400002 	ldr	x2, [x0]
 11291a0:	f0000181 	adrp	x1, 115c000 <ltc_ctr_ops+0x20>
 11291a4:	91002021 	add	x1, x1, #0x8
 11291a8:	eb01005f 	cmp	x2, x1
 11291ac:	54000180 	b.eq	11291dc <to_xts_ctx+0x44>  // b.none
 11291b0:	b0000163 	adrp	x3, 1156000 <ta_pub_key_modulus+0x7>
 11291b4:	b0000161 	adrp	x1, 1156000 <ta_pub_key_modulus+0x7>
 11291b8:	91122063 	add	x3, x3, #0x488
 11291bc:	91113421 	add	x1, x1, #0x44d
 11291c0:	b0000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 11291c4:	9111a000 	add	x0, x0, #0x468
{
 11291c8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	assert(ctx && ctx->ops == &ltc_xts_ops);
 11291cc:	528003c2 	mov	w2, #0x1e                  	// #30
{
 11291d0:	910003fd 	mov	x29, sp
	assert(ctx && ctx->ops == &ltc_xts_ops);
 11291d4:	97ffa436 	bl	11122ac <_assert_log>
 11291d8:	97ffa446 	bl	11122f0 <_assert_break>

	return container_of(ctx, struct ltc_xts_ctx, ctx);
}
 11291dc:	d65f03c0 	ret

00000000011291e0 <ltc_xts_update>:
}

static TEE_Result ltc_xts_update(struct crypto_cipher_ctx *ctx,
				 bool last_block __unused,
				 const uint8_t *data, size_t len, uint8_t *dst)
{
 11291e0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 11291e4:	910003fd 	mov	x29, sp
 11291e8:	a90153f3 	stp	x19, x20, [sp, #16]
 11291ec:	aa0203f3 	mov	x19, x2
 11291f0:	aa0303f4 	mov	x20, x3
 11291f4:	f90013f5 	str	x21, [sp, #32]
 11291f8:	aa0403f5 	mov	x21, x4
	struct ltc_xts_ctx *c = to_xts_ctx(ctx);
 11291fc:	97ffffe7 	bl	1129198 <to_xts_ctx>

	if (c->update && c->update(data, len, dst, c->tweak,
 1129200:	f9400805 	ldr	x5, [x0, #16]
 1129204:	b4000105 	cbz	x5, 1129224 <ltc_xts_update+0x44>
 1129208:	91006004 	add	x4, x0, #0x18
 112920c:	91188003 	add	x3, x0, #0x620
 1129210:	aa1503e2 	mov	x2, x21
 1129214:	aa1403e1 	mov	x1, x20
 1129218:	aa1303e0 	mov	x0, x19
 112921c:	d63f00a0 	blr	x5
 1129220:	340000c0 	cbz	w0, 1129238 <ltc_xts_update+0x58>
				   &c->state) == CRYPT_OK)
		return TEE_SUCCESS;
	else
		return TEE_ERROR_BAD_STATE;
 1129224:	129fff00 	mov	w0, #0xffff0007            	// #-65529
}
 1129228:	a94153f3 	ldp	x19, x20, [sp, #16]
 112922c:	f94013f5 	ldr	x21, [sp, #32]
 1129230:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1129234:	d65f03c0 	ret
		return TEE_SUCCESS;
 1129238:	52800000 	mov	w0, #0x0                   	// #0
 112923c:	17fffffb 	b	1129228 <ltc_xts_update+0x48>

0000000001129240 <ltc_xts_free_ctx>:
{
	xts_done(&to_xts_ctx(ctx)->state);
}

static void ltc_xts_free_ctx(struct crypto_cipher_ctx *ctx)
{
 1129240:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 1129244:	910003fd 	mov	x29, sp
	free(to_xts_ctx(ctx));
 1129248:	97ffffd4 	bl	1129198 <to_xts_ctx>
}
 112924c:	a8c17bfd 	ldp	x29, x30, [sp], #16
	free(to_xts_ctx(ctx));
 1129250:	140068e4 	b	11435e0 <free>

0000000001129254 <ltc_xts_final>:
{
 1129254:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 1129258:	910003fd 	mov	x29, sp
	xts_done(&to_xts_ctx(ctx)->state);
 112925c:	97ffffcf 	bl	1129198 <to_xts_ctx>
 1129260:	91006000 	add	x0, x0, #0x18
}
 1129264:	a8c17bfd 	ldp	x29, x30, [sp], #16
	xts_done(&to_xts_ctx(ctx)->state);
 1129268:	1400292a 	b	1133710 <xts_done>

000000000112926c <ltc_xts_init>:
{
 112926c:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 1129270:	910003fd 	mov	x29, sp
 1129274:	a90153f3 	stp	x19, x20, [sp, #16]
 1129278:	aa0703f4 	mov	x20, x7
 112927c:	a9025bf5 	stp	x21, x22, [sp, #32]
 1129280:	aa0303f5 	mov	x21, x3
 1129284:	aa0603f6 	mov	x22, x6
 1129288:	a90363f7 	stp	x23, x24, [sp, #48]
 112928c:	aa0203f7 	mov	x23, x2
 1129290:	aa0403f8 	mov	x24, x4
 1129294:	a9046bf9 	stp	x25, x26, [sp, #64]
 1129298:	aa0503fa 	mov	x26, x5
 112929c:	2a0103f9 	mov	w25, w1
	struct ltc_xts_ctx *c = to_xts_ctx(ctx);
 11292a0:	97ffffbe 	bl	1129198 <to_xts_ctx>
	if (key1_len != key2_len)
 11292a4:	eb1a02bf 	cmp	x21, x26
 11292a8:	54000100 	b.eq	11292c8 <ltc_xts_init+0x5c>  // b.none
		return TEE_ERROR_BAD_PARAMETERS;
 11292ac:	129fff20 	mov	w0, #0xffff0006            	// #-65530
}
 11292b0:	a94153f3 	ldp	x19, x20, [sp, #16]
 11292b4:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11292b8:	a94363f7 	ldp	x23, x24, [sp, #48]
 11292bc:	a9446bf9 	ldp	x25, x26, [sp, #64]
 11292c0:	a8c57bfd 	ldp	x29, x30, [sp], #80
 11292c4:	d65f03c0 	ret
 11292c8:	aa0003f3 	mov	x19, x0
	if (iv) {
 11292cc:	b40003b6 	cbz	x22, 1129340 <ltc_xts_init+0xd4>
		if (iv_len != sizeof(c->tweak))
 11292d0:	f100429f 	cmp	x20, #0x10
 11292d4:	54fffec1 	b.ne	11292ac <ltc_xts_init+0x40>  // b.any
		memcpy(c->tweak, iv, sizeof(c->tweak));
 11292d8:	aa1403e2 	mov	x2, x20
 11292dc:	aa1603e1 	mov	x1, x22
 11292e0:	91188000 	add	x0, x0, #0x620
 11292e4:	97ff682b 	bl	1103390 <memcpy>
	if ((int)iv_len != cipher_descriptor[c->cipher_idx]->block_length)
 11292e8:	b0000185 	adrp	x5, 115a000 <__scattered_array_1phys_mem_map+0x8>
 11292ec:	b9400a60 	ldr	w0, [x19, #8]
 11292f0:	f941c0a1 	ldr	x1, [x5, #896]
 11292f4:	f860d821 	ldr	x1, [x1, w0, sxtw #3]
 11292f8:	b9401421 	ldr	w1, [x1, #20]
 11292fc:	6b14003f 	cmp	w1, w20
 1129300:	54fffd61 	b.ne	11292ac <ltc_xts_init+0x40>  // b.any
		c->update = xts_decrypt;
 1129304:	f94124a1 	ldr	x1, [x5, #584]
 1129308:	7100033f 	cmp	w25, #0x0
 112930c:	f941c8a5 	ldr	x5, [x5, #912]
	if (xts_start(c->cipher_idx, key1, key2, key1_len, 0,
 1129310:	aa1503e3 	mov	x3, x21
 1129314:	aa1803e2 	mov	x2, x24
 1129318:	52800004 	mov	w4, #0x0                   	// #0
		c->update = xts_decrypt;
 112931c:	9a850025 	csel	x5, x1, x5, eq  // eq = none
 1129320:	f9000a65 	str	x5, [x19, #16]
	if (xts_start(c->cipher_idx, key1, key2, key1_len, 0,
 1129324:	aa1703e1 	mov	x1, x23
 1129328:	91006265 	add	x5, x19, #0x18
 112932c:	940029a9 	bl	11339d0 <xts_start>
		return TEE_ERROR_BAD_STATE;
 1129330:	7100001f 	cmp	w0, #0x0
 1129334:	129fff00 	mov	w0, #0xffff0007            	// #-65529
 1129338:	1a8003e0 	csel	w0, wzr, w0, eq  // eq = none
 112933c:	17ffffdd 	b	11292b0 <ltc_xts_init+0x44>
		memset(c->tweak, 0, sizeof(c->tweak));
 1129340:	d2800202 	mov	x2, #0x10                  	// #16
 1129344:	52800001 	mov	w1, #0x0                   	// #0
 1129348:	91188000 	add	x0, x0, #0x620
 112934c:	94006a65 	bl	1143ce0 <memset>
 1129350:	17ffffe6 	b	11292e8 <ltc_xts_init+0x7c>

0000000001129354 <ltc_xts_copy_state>:

static void ltc_xts_copy_state(struct crypto_cipher_ctx *dst_ctx,
			       struct crypto_cipher_ctx *src_ctx)
{
 1129354:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1129358:	910003fd 	mov	x29, sp
 112935c:	a90153f3 	stp	x19, x20, [sp, #16]
 1129360:	aa0003f3 	mov	x19, x0
 1129364:	aa0103e0 	mov	x0, x1
	struct ltc_xts_ctx *src = to_xts_ctx(src_ctx);
 1129368:	97ffff8c 	bl	1129198 <to_xts_ctx>
 112936c:	aa0003f4 	mov	x20, x0
	struct ltc_xts_ctx *dst = to_xts_ctx(dst_ctx);
 1129370:	aa1303e0 	mov	x0, x19
 1129374:	97ffff89 	bl	1129198 <to_xts_ctx>
 1129378:	aa0003f3 	mov	x19, x0

	assert(src->cipher_idx == dst->cipher_idx);
 112937c:	b9400800 	ldr	w0, [x0, #8]
 1129380:	b9400a81 	ldr	w1, [x20, #8]
 1129384:	6b00003f 	cmp	w1, w0
 1129388:	54000140 	b.eq	11293b0 <ltc_xts_copy_state+0x5c>  // b.none
 112938c:	b0000163 	adrp	x3, 1156000 <ta_pub_key_modulus+0x7>
 1129390:	b0000161 	adrp	x1, 1156000 <ta_pub_key_modulus+0x7>
 1129394:	91124c63 	add	x3, x3, #0x493
 1129398:	91113421 	add	x1, x1, #0x44d
 112939c:	b0000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 11293a0:	910bd800 	add	x0, x0, #0x2f6
 11293a4:	52800c62 	mov	w2, #0x63                  	// #99
 11293a8:	97ffa3c1 	bl	11122ac <_assert_log>
 11293ac:	97ffa3d1 	bl	11122f0 <_assert_break>
	dst->update = src->update;
 11293b0:	f9400a80 	ldr	x0, [x20, #16]
 11293b4:	f9000a60 	str	x0, [x19, #16]
	memcpy(dst->tweak, src->tweak, sizeof(src->tweak));
 11293b8:	91188281 	add	x1, x20, #0x620
 11293bc:	91188260 	add	x0, x19, #0x620
 11293c0:	d2800202 	mov	x2, #0x10                  	// #16
 11293c4:	97ff67f3 	bl	1103390 <memcpy>
	dst->state = src->state;
 11293c8:	91006281 	add	x1, x20, #0x18
 11293cc:	91006260 	add	x0, x19, #0x18
 11293d0:	d280c102 	mov	x2, #0x608                 	// #1544
 11293d4:	97ff67ef 	bl	1103390 <memcpy>
}
 11293d8:	a94153f3 	ldp	x19, x20, [sp, #16]
 11293dc:	a8c27bfd 	ldp	x29, x30, [sp], #32
 11293e0:	d65f03c0 	ret

00000000011293e4 <crypto_aes_xts_alloc_ctx>:
	.free_ctx = ltc_xts_free_ctx,
	.copy_state = ltc_xts_copy_state,
};

TEE_Result crypto_aes_xts_alloc_ctx(struct crypto_cipher_ctx **ctx_ret)
{
 11293e4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 11293e8:	910003fd 	mov	x29, sp
 11293ec:	a90153f3 	stp	x19, x20, [sp, #16]
 11293f0:	aa0003f4 	mov	x20, x0
	struct ltc_xts_ctx *c = NULL;
	int cipher_idx = find_cipher("aes");
 11293f4:	b0000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 11293f8:	910c6400 	add	x0, x0, #0x319
 11293fc:	9400242f 	bl	11324b8 <find_cipher>

	if (cipher_idx < 0)
 1129400:	37f801e0 	tbnz	w0, #31, 112943c <crypto_aes_xts_alloc_ctx+0x58>
 1129404:	2a0003f3 	mov	w19, w0
		return TEE_ERROR_NOT_SUPPORTED;

	c = calloc(1, sizeof(*c));
 1129408:	d280c601 	mov	x1, #0x630                 	// #1584
 112940c:	d2800020 	mov	x0, #0x1                   	// #1
 1129410:	94006830 	bl	11434d0 <calloc>
	if (!c)
 1129414:	b4000180 	cbz	x0, 1129444 <crypto_aes_xts_alloc_ctx+0x60>
		return TEE_ERROR_OUT_OF_MEMORY;

	c->ctx.ops = &ltc_xts_ops;
 1129418:	f0000181 	adrp	x1, 115c000 <ltc_ctr_ops+0x20>
 112941c:	91002021 	add	x1, x1, #0x8
	c->cipher_idx = cipher_idx;
	*ctx_ret = &c->ctx;
 1129420:	f9000280 	str	x0, [x20]
	c->ctx.ops = &ltc_xts_ops;
 1129424:	f9000001 	str	x1, [x0]
	c->cipher_idx = cipher_idx;
 1129428:	b9000813 	str	w19, [x0, #8]

	return TEE_SUCCESS;
 112942c:	52800000 	mov	w0, #0x0                   	// #0
}
 1129430:	a94153f3 	ldp	x19, x20, [sp, #16]
 1129434:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1129438:	d65f03c0 	ret
		return TEE_ERROR_NOT_SUPPORTED;
 112943c:	129ffea0 	mov	w0, #0xffff000a            	// #-65526
 1129440:	17fffffc 	b	1129430 <crypto_aes_xts_alloc_ctx+0x4c>
		return TEE_ERROR_OUT_OF_MEMORY;
 1129444:	129ffe60 	mov	w0, #0xffff000c            	// #-65524
 1129448:	17fffffa 	b	1129430 <crypto_aes_xts_alloc_ctx+0x4c>

000000000112944c <to_tee_ccm_state>:
	return TEE_SUCCESS;
}

static struct tee_ccm_state *to_tee_ccm_state(struct crypto_authenc_ctx *aectx)
{
	assert(aectx && aectx->ops == &aes_ccm_ops);
 112944c:	b40000c0 	cbz	x0, 1129464 <to_tee_ccm_state+0x18>
 1129450:	f9400002 	ldr	x2, [x0]
 1129454:	f0000181 	adrp	x1, 115c000 <ltc_ctr_ops+0x20>
 1129458:	9100c021 	add	x1, x1, #0x30
 112945c:	eb01005f 	cmp	x2, x1
 1129460:	54000180 	b.eq	1129490 <to_tee_ccm_state+0x44>  // b.none
 1129464:	b0000163 	adrp	x3, 1156000 <ta_pub_key_modulus+0x7>
 1129468:	b0000161 	adrp	x1, 1156000 <ta_pub_key_modulus+0x7>
 112946c:	91139463 	add	x3, x3, #0x4e5
 1129470:	91129821 	add	x1, x1, #0x4a6
 1129474:	b0000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 1129478:	91130400 	add	x0, x0, #0x4c1
{
 112947c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	assert(aectx && aectx->ops == &aes_ccm_ops);
 1129480:	52800522 	mov	w2, #0x29                  	// #41
{
 1129484:	910003fd 	mov	x29, sp
	assert(aectx && aectx->ops == &aes_ccm_ops);
 1129488:	97ffa389 	bl	11122ac <_assert_log>
 112948c:	97ffa399 	bl	11122f0 <_assert_break>

	return container_of(aectx, struct tee_ccm_state, aectx);
}
 1129490:	d65f03c0 	ret

0000000001129494 <crypto_aes_ccm_copy_state>:
	free(to_tee_ccm_state(aectx));
}

static void crypto_aes_ccm_copy_state(struct crypto_authenc_ctx *dst_aectx,
				      struct crypto_authenc_ctx *src_aectx)
{
 1129494:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1129498:	910003fd 	mov	x29, sp
 112949c:	a90153f3 	stp	x19, x20, [sp, #16]
 11294a0:	aa0103f4 	mov	x20, x1
	struct tee_ccm_state *dst_ctx = to_tee_ccm_state(dst_aectx);
 11294a4:	97ffffea 	bl	112944c <to_tee_ccm_state>
 11294a8:	aa0003f3 	mov	x19, x0
	struct tee_ccm_state *src_ctx = to_tee_ccm_state(src_aectx);
 11294ac:	aa1403e0 	mov	x0, x20
 11294b0:	97ffffe7 	bl	112944c <to_tee_ccm_state>
 11294b4:	aa0003f4 	mov	x20, x0

	dst_ctx->ctx = src_ctx->ctx;
 11294b8:	91002001 	add	x1, x0, #0x8
 11294bc:	d2806f02 	mov	x2, #0x378                 	// #888
 11294c0:	91002260 	add	x0, x19, #0x8
 11294c4:	97ff67b3 	bl	1103390 <memcpy>
	dst_ctx->tag_len = src_ctx->tag_len;
 11294c8:	f941c280 	ldr	x0, [x20, #896]
 11294cc:	f901c260 	str	x0, [x19, #896]
}
 11294d0:	a94153f3 	ldp	x19, x20, [sp, #16]
 11294d4:	a8c27bfd 	ldp	x29, x30, [sp], #32
 11294d8:	d65f03c0 	ret

00000000011294dc <crypto_aes_ccm_free_ctx>:
{
 11294dc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 11294e0:	910003fd 	mov	x29, sp
	free(to_tee_ccm_state(aectx));
 11294e4:	97ffffda 	bl	112944c <to_tee_ccm_state>
}
 11294e8:	a8c17bfd 	ldp	x29, x30, [sp], #16
	free(to_tee_ccm_state(aectx));
 11294ec:	1400683d 	b	11435e0 <free>

00000000011294f0 <crypto_aes_ccm_final>:
		res = TEE_SUCCESS;
	return res;
}

static void crypto_aes_ccm_final(struct crypto_authenc_ctx *aectx)
{
 11294f0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 11294f4:	910003fd 	mov	x29, sp
	ccm_reset(&to_tee_ccm_state(aectx)->ctx);
 11294f8:	97ffffd5 	bl	112944c <to_tee_ccm_state>
 11294fc:	91002000 	add	x0, x0, #0x8
}
 1129500:	a8c17bfd 	ldp	x29, x30, [sp], #16
	ccm_reset(&to_tee_ccm_state(aectx)->ctx);
 1129504:	14001ad9 	b	1130068 <ccm_reset>

0000000001129508 <crypto_aes_ccm_update_payload>:
{
 1129508:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 112950c:	910003fd 	mov	x29, sp
 1129510:	a90153f3 	stp	x19, x20, [sp, #16]
 1129514:	aa0203f3 	mov	x19, x2
 1129518:	aa0403f4 	mov	x20, x4
 112951c:	a9025bf5 	stp	x21, x22, [sp, #32]
 1129520:	2a0103f6 	mov	w22, w1
 1129524:	aa0303f5 	mov	x21, x3
	struct tee_ccm_state *ccm = to_tee_ccm_state(aectx);
 1129528:	97ffffc9 	bl	112944c <to_tee_ccm_state>
	if (mode == TEE_MODE_ENCRYPT) {
 112952c:	34000236 	cbz	w22, 1129570 <crypto_aes_ccm_update_payload+0x68>
 1129530:	aa1303e1 	mov	x1, x19
		pt = dst_data;
 1129534:	aa1403f3 	mov	x19, x20
		ct = (unsigned char *)src_data;
 1129538:	aa0103f4 	mov	x20, x1
		dir = CCM_DECRYPT;
 112953c:	52800024 	mov	w4, #0x1                   	// #1
	ltc_res = ccm_process(&ccm->ctx, pt, len, ct, dir);
 1129540:	aa1403e3 	mov	x3, x20
 1129544:	aa1503e2 	mov	x2, x21
 1129548:	aa1303e1 	mov	x1, x19
 112954c:	91002000 	add	x0, x0, #0x8
 1129550:	94001a0a 	bl	112fd78 <ccm_process>
		return TEE_ERROR_BAD_STATE;
 1129554:	7100001f 	cmp	w0, #0x0
}
 1129558:	129fff00 	mov	w0, #0xffff0007            	// #-65529
 112955c:	1a9f1000 	csel	w0, w0, wzr, ne  // ne = any
 1129560:	a94153f3 	ldp	x19, x20, [sp, #16]
 1129564:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1129568:	a8c37bfd 	ldp	x29, x30, [sp], #48
 112956c:	d65f03c0 	ret
		dir = CCM_ENCRYPT;
 1129570:	52800004 	mov	w4, #0x0                   	// #0
 1129574:	17fffff3 	b	1129540 <crypto_aes_ccm_update_payload+0x38>

0000000001129578 <crypto_aes_ccm_dec_final>:
{
 1129578:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
 112957c:	910003fd 	mov	x29, sp
 1129580:	a90153f3 	stp	x19, x20, [sp, #16]
 1129584:	aa0503f3 	mov	x19, x5
 1129588:	aa0403f4 	mov	x20, x4
 112958c:	a9025bf5 	stp	x21, x22, [sp, #32]
 1129590:	aa0003f6 	mov	x22, x0
 1129594:	a90363f7 	stp	x23, x24, [sp, #48]
 1129598:	aa0103f7 	mov	x23, x1
 112959c:	aa0203f8 	mov	x24, x2
 11295a0:	f90023f9 	str	x25, [sp, #64]
 11295a4:	aa0303f9 	mov	x25, x3
	struct tee_ccm_state *ccm = to_tee_ccm_state(aectx);
 11295a8:	97ffffa9 	bl	112944c <to_tee_ccm_state>
	unsigned long ltc_tag_len = tag_len;
 11295ac:	f9002ff3 	str	x19, [sp, #88]
	uint8_t dst_tag[TEE_CCM_TAG_MAX_LENGTH] = { 0 };
 11295b0:	a9067fff 	stp	xzr, xzr, [sp, #96]
	if (tag_len == 0)
 11295b4:	b4000413 	cbz	x19, 1129634 <crypto_aes_ccm_dec_final+0xbc>
	if (tag_len > TEE_CCM_TAG_MAX_LENGTH)
 11295b8:	f100427f 	cmp	x19, #0x10
 11295bc:	54000109 	b.ls	11295dc <crypto_aes_ccm_dec_final+0x64>  // b.plast
		return TEE_ERROR_BAD_STATE;
 11295c0:	129fff00 	mov	w0, #0xffff0007            	// #-65529
}
 11295c4:	a94153f3 	ldp	x19, x20, [sp, #16]
 11295c8:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11295cc:	a94363f7 	ldp	x23, x24, [sp, #48]
 11295d0:	f94023f9 	ldr	x25, [sp, #64]
 11295d4:	a8c77bfd 	ldp	x29, x30, [sp], #112
 11295d8:	d65f03c0 	ret
 11295dc:	aa0003f5 	mov	x21, x0
	res = crypto_aes_ccm_update_payload(aectx, TEE_MODE_DECRYPT, src_data,
 11295e0:	aa1903e4 	mov	x4, x25
 11295e4:	aa1803e3 	mov	x3, x24
 11295e8:	aa1703e2 	mov	x2, x23
 11295ec:	aa1603e0 	mov	x0, x22
 11295f0:	52800021 	mov	w1, #0x1                   	// #1
 11295f4:	97ffffc5 	bl	1129508 <crypto_aes_ccm_update_payload>
	if (res != TEE_SUCCESS)
 11295f8:	35fffe60 	cbnz	w0, 11295c4 <crypto_aes_ccm_dec_final+0x4c>
	ltc_res = ccm_done(&ccm->ctx, dst_tag, &ltc_tag_len);
 11295fc:	910183f6 	add	x22, sp, #0x60
 1129600:	910163e2 	add	x2, sp, #0x58
 1129604:	aa1603e1 	mov	x1, x22
 1129608:	910022a0 	add	x0, x21, #0x8
 112960c:	94001a4a 	bl	112ff34 <ccm_done>
	if (ltc_res != CRYPT_OK)
 1129610:	35fffd80 	cbnz	w0, 11295c0 <crypto_aes_ccm_dec_final+0x48>
	if (consttime_memcmp(dst_tag, tag, tag_len) != 0)
 1129614:	aa1303e2 	mov	x2, x19
 1129618:	aa1403e1 	mov	x1, x20
 112961c:	aa1603e0 	mov	x0, x22
 1129620:	94006e5c 	bl	1144f90 <consttime_memcmp>
		res = TEE_ERROR_MAC_INVALID;
 1129624:	7100001f 	cmp	w0, #0x0
 1129628:	1299f1c0 	mov	w0, #0xffff3071            	// #-53135
 112962c:	1a8003e0 	csel	w0, wzr, w0, eq  // eq = none
 1129630:	17ffffe5 	b	11295c4 <crypto_aes_ccm_dec_final+0x4c>
		return TEE_ERROR_SHORT_BUFFER;
 1129634:	129ffde0 	mov	w0, #0xffff0010            	// #-65520
 1129638:	17ffffe3 	b	11295c4 <crypto_aes_ccm_dec_final+0x4c>

000000000112963c <crypto_aes_ccm_enc_final>:
{
 112963c:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 1129640:	910003fd 	mov	x29, sp
 1129644:	a90153f3 	stp	x19, x20, [sp, #16]
 1129648:	aa0503f3 	mov	x19, x5
 112964c:	a9025bf5 	stp	x21, x22, [sp, #32]
 1129650:	aa0003f6 	mov	x22, x0
 1129654:	aa0403f5 	mov	x21, x4
 1129658:	a90363f7 	stp	x23, x24, [sp, #48]
 112965c:	aa0103f7 	mov	x23, x1
 1129660:	aa0203f8 	mov	x24, x2
 1129664:	f90023f9 	str	x25, [sp, #64]
 1129668:	aa0303f9 	mov	x25, x3
	struct tee_ccm_state *ccm = to_tee_ccm_state(aectx);
 112966c:	97ffff78 	bl	112944c <to_tee_ccm_state>
 1129670:	aa0003f4 	mov	x20, x0
	res = crypto_aes_ccm_update_payload(aectx, TEE_MODE_ENCRYPT, src_data,
 1129674:	aa1903e4 	mov	x4, x25
 1129678:	aa1803e3 	mov	x3, x24
 112967c:	aa1703e2 	mov	x2, x23
 1129680:	aa1603e0 	mov	x0, x22
 1129684:	52800001 	mov	w1, #0x0                   	// #0
 1129688:	97ffffa0 	bl	1129508 <crypto_aes_ccm_update_payload>
	if (res != TEE_SUCCESS)
 112968c:	350000e0 	cbnz	w0, 11296a8 <crypto_aes_ccm_enc_final+0x6c>
	if (*dst_tag_len < ccm->tag_len) {
 1129690:	f9400261 	ldr	x1, [x19]
 1129694:	f941c280 	ldr	x0, [x20, #896]
		*dst_tag_len = ccm->tag_len;
 1129698:	f9000260 	str	x0, [x19]
	if (*dst_tag_len < ccm->tag_len) {
 112969c:	eb00003f 	cmp	x1, x0
 11296a0:	54000102 	b.cs	11296c0 <crypto_aes_ccm_enc_final+0x84>  // b.hs, b.nlast
		return TEE_ERROR_SHORT_BUFFER;
 11296a4:	129ffde0 	mov	w0, #0xffff0010            	// #-65520
}
 11296a8:	a94153f3 	ldp	x19, x20, [sp, #16]
 11296ac:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11296b0:	a94363f7 	ldp	x23, x24, [sp, #48]
 11296b4:	f94023f9 	ldr	x25, [sp, #64]
 11296b8:	a8c57bfd 	ldp	x29, x30, [sp], #80
 11296bc:	d65f03c0 	ret
	ltc_res = ccm_done(&ccm->ctx, dst_tag,
 11296c0:	aa1303e2 	mov	x2, x19
 11296c4:	aa1503e1 	mov	x1, x21
 11296c8:	91002280 	add	x0, x20, #0x8
 11296cc:	94001a1a 	bl	112ff34 <ccm_done>
		return TEE_ERROR_BAD_STATE;
 11296d0:	7100001f 	cmp	w0, #0x0
 11296d4:	129fff00 	mov	w0, #0xffff0007            	// #-65529
 11296d8:	1a8003e0 	csel	w0, wzr, w0, eq  // eq = none
 11296dc:	17fffff3 	b	11296a8 <crypto_aes_ccm_enc_final+0x6c>

00000000011296e0 <crypto_aes_ccm_update_aad>:
{
 11296e0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 11296e4:	910003fd 	mov	x29, sp
 11296e8:	a90153f3 	stp	x19, x20, [sp, #16]
 11296ec:	aa0103f3 	mov	x19, x1
 11296f0:	aa0203f4 	mov	x20, x2
	struct tee_ccm_state *ccm = to_tee_ccm_state(aectx);
 11296f4:	97ffff56 	bl	112944c <to_tee_ccm_state>
	ltc_res = ccm_add_aad(&ccm->ctx, data, len);
 11296f8:	91002000 	add	x0, x0, #0x8
 11296fc:	aa1403e2 	mov	x2, x20
 1129700:	aa1303e1 	mov	x1, x19
 1129704:	94001957 	bl	112fc60 <ccm_add_aad>
		return TEE_ERROR_BAD_STATE;
 1129708:	7100001f 	cmp	w0, #0x0
}
 112970c:	129fff00 	mov	w0, #0xffff0007            	// #-65529
 1129710:	1a9f1000 	csel	w0, w0, wzr, ne  // ne = any
 1129714:	a94153f3 	ldp	x19, x20, [sp, #16]
 1129718:	a8c27bfd 	ldp	x29, x30, [sp], #32
 112971c:	d65f03c0 	ret

0000000001129720 <crypto_aes_ccm_init>:
{
 1129720:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
 1129724:	910003fd 	mov	x29, sp
 1129728:	a90153f3 	stp	x19, x20, [sp, #16]
 112972c:	aa0503f4 	mov	x20, x5
 1129730:	aa0603f3 	mov	x19, x6
 1129734:	a9025bf5 	stp	x21, x22, [sp, #32]
 1129738:	aa0203f6 	mov	x22, x2
 112973c:	a90363f7 	stp	x23, x24, [sp, #48]
 1129740:	aa0003f8 	mov	x24, x0
 1129744:	aa0303f7 	mov	x23, x3
	int ltc_cipherindex = find_cipher("aes");
 1129748:	b0000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 112974c:	910c6400 	add	x0, x0, #0x319
{
 1129750:	a9046bf9 	stp	x25, x26, [sp, #64]
 1129754:	aa0403fa 	mov	x26, x4
 1129758:	f9002bfb 	str	x27, [sp, #80]
 112975c:	aa0703fb 	mov	x27, x7
	int ltc_cipherindex = find_cipher("aes");
 1129760:	94002356 	bl	11324b8 <find_cipher>
 1129764:	2a0003f5 	mov	w21, w0
	struct tee_ccm_state *ccm = to_tee_ccm_state(aectx);
 1129768:	aa1803e0 	mov	x0, x24
 112976c:	97ffff38 	bl	112944c <to_tee_ccm_state>
	if (ltc_cipherindex < 0)
 1129770:	36f80135 	tbz	w21, #31, 1129794 <crypto_aes_ccm_init+0x74>
		return TEE_ERROR_NOT_SUPPORTED;
 1129774:	129ffea0 	mov	w0, #0xffff000a            	// #-65526
}
 1129778:	a94153f3 	ldp	x19, x20, [sp, #16]
 112977c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1129780:	a94363f7 	ldp	x23, x24, [sp, #48]
 1129784:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1129788:	f9402bfb 	ldr	x27, [sp, #80]
 112978c:	a8c67bfd 	ldp	x29, x30, [sp], #96
 1129790:	d65f03c0 	ret
 1129794:	aa0003f8 	mov	x24, x0
	memset(&ccm->ctx, 0, sizeof(ccm->ctx));
 1129798:	91002019 	add	x25, x0, #0x8
 112979c:	aa1903e0 	mov	x0, x25
 11297a0:	d2806f02 	mov	x2, #0x378                 	// #888
 11297a4:	52800001 	mov	w1, #0x0                   	// #0
 11297a8:	9400694e 	bl	1143ce0 <memset>
	ccm->tag_len = tag_len;
 11297ac:	f901c313 	str	x19, [x24, #896]
	if ((!key) || (key_len > TEE_CCM_KEY_MAX_LENGTH))
 11297b0:	f10082ff 	cmp	x23, #0x20
 11297b4:	fa409ac4 	ccmp	x22, #0x0, #0x4, ls  // ls = plast
 11297b8:	540002e0 	b.eq	1129814 <crypto_aes_ccm_init+0xf4>  // b.none
	if (nonce_len > TEE_CCM_NONCE_MAX_LENGTH)
 11297bc:	f100369f 	cmp	x20, #0xd
 11297c0:	540002a8 	b.hi	1129814 <crypto_aes_ccm_init+0xf4>  // b.pmore
	if ((tag_len < 4) || (tag_len > TEE_CCM_TAG_MAX_LENGTH) ||
 11297c4:	d1001260 	sub	x0, x19, #0x4
 11297c8:	f100301f 	cmp	x0, #0xc
 11297cc:	54fffd48 	b.hi	1129774 <crypto_aes_ccm_init+0x54>  // b.pmore
 11297d0:	3707fd33 	tbnz	w19, #0, 1129774 <crypto_aes_ccm_init+0x54>
	ltc_res = ccm_init(&ccm->ctx, ltc_cipherindex, key, key_len,
 11297d4:	b94063e4 	ldr	w4, [sp, #96]
 11297d8:	2a1b03e6 	mov	w6, w27
 11297dc:	2a1303e5 	mov	w5, w19
 11297e0:	2a1703e3 	mov	w3, w23
 11297e4:	aa1603e2 	mov	x2, x22
 11297e8:	2a1503e1 	mov	w1, w21
 11297ec:	aa1903e0 	mov	x0, x25
 11297f0:	94001846 	bl	112f908 <ccm_init>
	if (ltc_res != CRYPT_OK)
 11297f4:	350000c0 	cbnz	w0, 112980c <crypto_aes_ccm_init+0xec>
	ltc_res = ccm_add_nonce(&ccm->ctx, nonce, nonce_len);
 11297f8:	aa1403e2 	mov	x2, x20
 11297fc:	aa1a03e1 	mov	x1, x26
 1129800:	aa1903e0 	mov	x0, x25
 1129804:	94001884 	bl	112fa14 <ccm_add_nonce>
	if (ltc_res != CRYPT_OK)
 1129808:	340000a0 	cbz	w0, 112981c <crypto_aes_ccm_init+0xfc>
		return TEE_ERROR_BAD_STATE;
 112980c:	129fff00 	mov	w0, #0xffff0007            	// #-65529
 1129810:	17ffffda 	b	1129778 <crypto_aes_ccm_init+0x58>
		return TEE_ERROR_BAD_PARAMETERS;
 1129814:	129fff20 	mov	w0, #0xffff0006            	// #-65530
 1129818:	17ffffd8 	b	1129778 <crypto_aes_ccm_init+0x58>
	return TEE_SUCCESS;
 112981c:	52800000 	mov	w0, #0x0                   	// #0
 1129820:	17ffffd6 	b	1129778 <crypto_aes_ccm_init+0x58>

0000000001129824 <crypto_aes_ccm_alloc_ctx>:
{
 1129824:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	struct tee_ccm_state *ctx = calloc(1, sizeof(*ctx));
 1129828:	d2807101 	mov	x1, #0x388                 	// #904
{
 112982c:	910003fd 	mov	x29, sp
 1129830:	f9000bf3 	str	x19, [sp, #16]
 1129834:	aa0003f3 	mov	x19, x0
	struct tee_ccm_state *ctx = calloc(1, sizeof(*ctx));
 1129838:	d2800020 	mov	x0, #0x1                   	// #1
 112983c:	94006725 	bl	11434d0 <calloc>
	if (!ctx)
 1129840:	b4000120 	cbz	x0, 1129864 <crypto_aes_ccm_alloc_ctx+0x40>
	ctx->aectx.ops = &aes_ccm_ops;
 1129844:	f0000181 	adrp	x1, 115c000 <ltc_ctr_ops+0x20>
 1129848:	9100c021 	add	x1, x1, #0x30
	*ctx_ret = &ctx->aectx;
 112984c:	f9000260 	str	x0, [x19]
	ctx->aectx.ops = &aes_ccm_ops;
 1129850:	f9000001 	str	x1, [x0]
	return TEE_SUCCESS;
 1129854:	52800000 	mov	w0, #0x0                   	// #0
}
 1129858:	f9400bf3 	ldr	x19, [sp, #16]
 112985c:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1129860:	d65f03c0 	ret
		return TEE_ERROR_OUT_OF_MEMORY;
 1129864:	129ffe60 	mov	w0, #0xffff000c            	// #-65524
 1129868:	17fffffc 	b	1129858 <crypto_aes_ccm_alloc_ctx+0x34>

000000000112986c <bn_alloc_max>:
#include <tee_api_types.h>
#include <tomcrypt_private.h>
#include <types_ext.h>

static inline bool bn_alloc_max(struct bignum **s)
{
 112986c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1129870:	910003fd 	mov	x29, sp
 1129874:	f9000bf3 	str	x19, [sp, #16]
 1129878:	aa0003f3 	mov	x19, x0
	*s = crypto_bignum_allocate(_CFG_CORE_LTC_BIGNUM_MAX_BITS);
 112987c:	d2820000 	mov	x0, #0x1000                	// #4096
 1129880:	9400126a 	bl	112e228 <crypto_bignum_allocate>

	return *s;
 1129884:	f100001f 	cmp	x0, #0x0
	*s = crypto_bignum_allocate(_CFG_CORE_LTC_BIGNUM_MAX_BITS);
 1129888:	f9000260 	str	x0, [x19]
}
 112988c:	1a9f07e0 	cset	w0, ne  // ne = any
 1129890:	f9400bf3 	ldr	x19, [sp, #16]
 1129894:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1129898:	d65f03c0 	ret

000000000112989c <crypto_acipher_alloc_dsa_keypair>:

#include "acipher_helpers.h"

TEE_Result crypto_acipher_alloc_dsa_keypair(struct dsa_keypair *s,
					    size_t key_size_bits __unused)
{
 112989c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	memset(s, 0, sizeof(*s));
 11298a0:	d2800502 	mov	x2, #0x28                  	// #40
 11298a4:	52800001 	mov	w1, #0x0                   	// #0
{
 11298a8:	910003fd 	mov	x29, sp
 11298ac:	f9000bf3 	str	x19, [sp, #16]
 11298b0:	aa0003f3 	mov	x19, x0
	memset(s, 0, sizeof(*s));
 11298b4:	9400690b 	bl	1143ce0 <memset>
	if (!bn_alloc_max(&s->g))
 11298b8:	aa1303e0 	mov	x0, x19
 11298bc:	97ffffec 	bl	112986c <bn_alloc_max>
 11298c0:	72001c1f 	tst	w0, #0xff
 11298c4:	540001a0 	b.eq	11298f8 <crypto_acipher_alloc_dsa_keypair+0x5c>  // b.none
		return TEE_ERROR_OUT_OF_MEMORY;

	if (!bn_alloc_max(&s->p))
 11298c8:	91002260 	add	x0, x19, #0x8
 11298cc:	97ffffe8 	bl	112986c <bn_alloc_max>
 11298d0:	72001c1f 	tst	w0, #0xff
 11298d4:	54000161 	b.ne	1129900 <crypto_acipher_alloc_dsa_keypair+0x64>  // b.any
		goto err;
	if (!bn_alloc_max(&s->x))
		goto err;
	return TEE_SUCCESS;
err:
	crypto_bignum_free(s->g);
 11298d8:	f9400260 	ldr	x0, [x19]
 11298dc:	94001269 	bl	112e280 <crypto_bignum_free>
	crypto_bignum_free(s->p);
 11298e0:	f9400660 	ldr	x0, [x19, #8]
 11298e4:	94001267 	bl	112e280 <crypto_bignum_free>
	crypto_bignum_free(s->q);
 11298e8:	f9400a60 	ldr	x0, [x19, #16]
 11298ec:	94001265 	bl	112e280 <crypto_bignum_free>
	crypto_bignum_free(s->y);
 11298f0:	f9400e60 	ldr	x0, [x19, #24]
 11298f4:	94001263 	bl	112e280 <crypto_bignum_free>
		return TEE_ERROR_OUT_OF_MEMORY;
 11298f8:	129ffe60 	mov	w0, #0xffff000c            	// #-65524
 11298fc:	1400000e 	b	1129934 <crypto_acipher_alloc_dsa_keypair+0x98>
	if (!bn_alloc_max(&s->q))
 1129900:	91004260 	add	x0, x19, #0x10
 1129904:	97ffffda 	bl	112986c <bn_alloc_max>
 1129908:	72001c1f 	tst	w0, #0xff
 112990c:	54fffe60 	b.eq	11298d8 <crypto_acipher_alloc_dsa_keypair+0x3c>  // b.none
	if (!bn_alloc_max(&s->y))
 1129910:	91006260 	add	x0, x19, #0x18
 1129914:	97ffffd6 	bl	112986c <bn_alloc_max>
 1129918:	72001c1f 	tst	w0, #0xff
 112991c:	54fffde0 	b.eq	11298d8 <crypto_acipher_alloc_dsa_keypair+0x3c>  // b.none
	if (!bn_alloc_max(&s->x))
 1129920:	91008260 	add	x0, x19, #0x20
 1129924:	97ffffd2 	bl	112986c <bn_alloc_max>
 1129928:	72001c1f 	tst	w0, #0xff
 112992c:	54fffd60 	b.eq	11298d8 <crypto_acipher_alloc_dsa_keypair+0x3c>  // b.none
	return TEE_SUCCESS;
 1129930:	52800000 	mov	w0, #0x0                   	// #0
	return TEE_ERROR_OUT_OF_MEMORY;
}
 1129934:	f9400bf3 	ldr	x19, [sp, #16]
 1129938:	a8c27bfd 	ldp	x29, x30, [sp], #32
 112993c:	d65f03c0 	ret

0000000001129940 <crypto_acipher_alloc_dsa_public_key>:

TEE_Result crypto_acipher_alloc_dsa_public_key(struct dsa_public_key *s,
					       size_t key_size_bits __unused)
{
 1129940:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	memset(s, 0, sizeof(*s));
 1129944:	d2800402 	mov	x2, #0x20                  	// #32
 1129948:	52800001 	mov	w1, #0x0                   	// #0
{
 112994c:	910003fd 	mov	x29, sp
 1129950:	f9000bf3 	str	x19, [sp, #16]
 1129954:	aa0003f3 	mov	x19, x0
	memset(s, 0, sizeof(*s));
 1129958:	940068e2 	bl	1143ce0 <memset>
	if (!bn_alloc_max(&s->g))
 112995c:	aa1303e0 	mov	x0, x19
 1129960:	97ffffc3 	bl	112986c <bn_alloc_max>
 1129964:	72001c1f 	tst	w0, #0xff
 1129968:	54000160 	b.eq	1129994 <crypto_acipher_alloc_dsa_public_key+0x54>  // b.none
		return TEE_ERROR_OUT_OF_MEMORY;

	if (!bn_alloc_max(&s->p))
 112996c:	91002260 	add	x0, x19, #0x8
 1129970:	97ffffbf 	bl	112986c <bn_alloc_max>
 1129974:	72001c1f 	tst	w0, #0xff
 1129978:	54000121 	b.ne	112999c <crypto_acipher_alloc_dsa_public_key+0x5c>  // b.any
		goto err;
	if (!bn_alloc_max(&s->y))
		goto err;
	return TEE_SUCCESS;
err:
	crypto_bignum_free(s->g);
 112997c:	f9400260 	ldr	x0, [x19]
 1129980:	94001240 	bl	112e280 <crypto_bignum_free>
	crypto_bignum_free(s->p);
 1129984:	f9400660 	ldr	x0, [x19, #8]
 1129988:	9400123e 	bl	112e280 <crypto_bignum_free>
	crypto_bignum_free(s->q);
 112998c:	f9400a60 	ldr	x0, [x19, #16]
 1129990:	9400123c 	bl	112e280 <crypto_bignum_free>
		return TEE_ERROR_OUT_OF_MEMORY;
 1129994:	129ffe60 	mov	w0, #0xffff000c            	// #-65524
 1129998:	1400000a 	b	11299c0 <crypto_acipher_alloc_dsa_public_key+0x80>
	if (!bn_alloc_max(&s->q))
 112999c:	91004260 	add	x0, x19, #0x10
 11299a0:	97ffffb3 	bl	112986c <bn_alloc_max>
 11299a4:	72001c1f 	tst	w0, #0xff
 11299a8:	54fffea0 	b.eq	112997c <crypto_acipher_alloc_dsa_public_key+0x3c>  // b.none
	if (!bn_alloc_max(&s->y))
 11299ac:	91006260 	add	x0, x19, #0x18
 11299b0:	97ffffaf 	bl	112986c <bn_alloc_max>
 11299b4:	72001c1f 	tst	w0, #0xff
 11299b8:	54fffe20 	b.eq	112997c <crypto_acipher_alloc_dsa_public_key+0x3c>  // b.none
	return TEE_SUCCESS;
 11299bc:	52800000 	mov	w0, #0x0                   	// #0
	return TEE_ERROR_OUT_OF_MEMORY;
}
 11299c0:	f9400bf3 	ldr	x19, [sp, #16]
 11299c4:	a8c27bfd 	ldp	x29, x30, [sp], #32
 11299c8:	d65f03c0 	ret

00000000011299cc <crypto_acipher_gen_dsa_key>:

TEE_Result crypto_acipher_gen_dsa_key(struct dsa_keypair *key, size_t key_size)
{
 11299cc:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
 11299d0:	910003fd 	mov	x29, sp
 11299d4:	a90153f3 	stp	x19, x20, [sp, #16]
	dsa_key ltc_tmp_key = { };
	int ltc_res = 0;

	if (key_size != 8 * mp_unsigned_bin_size(key->p))
 11299d8:	b0000194 	adrp	x20, 115a000 <__scattered_array_1phys_mem_map+0x8>
{
 11299dc:	aa0003f3 	mov	x19, x0
	if (key_size != 8 * mp_unsigned_bin_size(key->p))
 11299e0:	f941d694 	ldr	x20, [x20, #936]
	dsa_key ltc_tmp_key = { };
 11299e4:	a9037fff 	stp	xzr, xzr, [sp, #48]
	if (key_size != 8 * mp_unsigned_bin_size(key->p))
 11299e8:	f9400400 	ldr	x0, [x0, #8]
{
 11299ec:	f90013f5 	str	x21, [sp, #32]
 11299f0:	aa0103f5 	mov	x21, x1
	dsa_key ltc_tmp_key = { };
 11299f4:	a9047fff 	stp	xzr, xzr, [sp, #64]
	if (key_size != 8 * mp_unsigned_bin_size(key->p))
 11299f8:	f9404e81 	ldr	x1, [x20, #152]
	dsa_key ltc_tmp_key = { };
 11299fc:	a9057fff 	stp	xzr, xzr, [sp, #80]
	if (key_size != 8 * mp_unsigned_bin_size(key->p))
 1129a00:	d63f0020 	blr	x1
 1129a04:	eb000ebf 	cmp	x21, x0, lsl #3
 1129a08:	540000c0 	b.eq	1129a20 <crypto_acipher_gen_dsa_key+0x54>  // b.none
		return TEE_ERROR_BAD_PARAMETERS;
 1129a0c:	129fff20 	mov	w0, #0xffff0006            	// #-65530

	/* Free the temporary key */
	dsa_free(&ltc_tmp_key);

	return TEE_SUCCESS;
}
 1129a10:	a94153f3 	ldp	x19, x20, [sp, #16]
 1129a14:	f94013f5 	ldr	x21, [sp, #32]
 1129a18:	a8c67bfd 	ldp	x29, x30, [sp], #96
 1129a1c:	d65f03c0 	ret
	ltc_res = mp_init_multi(&ltc_tmp_key.g, &ltc_tmp_key.p, &ltc_tmp_key.q,
 1129a20:	9100c3f5 	add	x21, sp, #0x30
 1129a24:	910163e4 	add	x4, sp, #0x58
 1129a28:	910143e3 	add	x3, sp, #0x50
 1129a2c:	910103e2 	add	x2, sp, #0x40
 1129a30:	910123e1 	add	x1, sp, #0x48
 1129a34:	9100e3e0 	add	x0, sp, #0x38
 1129a38:	d2800005 	mov	x5, #0x0                   	// #0
 1129a3c:	9400211e 	bl	1131eb4 <ltc_init_multi>
	if (ltc_res)
 1129a40:	35000420 	cbnz	w0, 1129ac4 <crypto_acipher_gen_dsa_key+0xf8>
	mp_copy(key->g, ltc_tmp_key.g);
 1129a44:	f9400260 	ldr	x0, [x19]
 1129a48:	f9401e82 	ldr	x2, [x20, #56]
 1129a4c:	f9401fe1 	ldr	x1, [sp, #56]
 1129a50:	d63f0040 	blr	x2
	mp_copy(key->p, ltc_tmp_key.p);
 1129a54:	f9400660 	ldr	x0, [x19, #8]
 1129a58:	f9401e82 	ldr	x2, [x20, #56]
 1129a5c:	f94027e1 	ldr	x1, [sp, #72]
 1129a60:	d63f0040 	blr	x2
	mp_copy(key->q, ltc_tmp_key.q);
 1129a64:	f9400a60 	ldr	x0, [x19, #16]
 1129a68:	f9401e82 	ldr	x2, [x20, #56]
 1129a6c:	f94023e1 	ldr	x1, [sp, #64]
 1129a70:	d63f0040 	blr	x2
	ltc_res = dsa_generate_key(NULL, find_prng("prng_crypto"),
 1129a74:	b0000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 1129a78:	9113d800 	add	x0, x0, #0x4f6
 1129a7c:	940022d9 	bl	11325e0 <find_prng>
 1129a80:	2a0003e1 	mov	w1, w0
 1129a84:	aa1503e2 	mov	x2, x21
 1129a88:	d2800000 	mov	x0, #0x0                   	// #0
 1129a8c:	94002823 	bl	1133b18 <dsa_generate_key>
	if (ltc_res)
 1129a90:	35fffbe0 	cbnz	w0, 1129a0c <crypto_acipher_gen_dsa_key+0x40>
	mp_copy(ltc_tmp_key.y, key->y);
 1129a94:	f9400e61 	ldr	x1, [x19, #24]
 1129a98:	f9401e82 	ldr	x2, [x20, #56]
 1129a9c:	f9402fe0 	ldr	x0, [sp, #88]
 1129aa0:	d63f0040 	blr	x2
	mp_copy(ltc_tmp_key.x, key->x);
 1129aa4:	f9401261 	ldr	x1, [x19, #32]
 1129aa8:	f9401e82 	ldr	x2, [x20, #56]
 1129aac:	f9402be0 	ldr	x0, [sp, #80]
 1129ab0:	d63f0040 	blr	x2
	dsa_free(&ltc_tmp_key);
 1129ab4:	aa1503e0 	mov	x0, x21
 1129ab8:	94002807 	bl	1133ad4 <dsa_free>
	return TEE_SUCCESS;
 1129abc:	52800000 	mov	w0, #0x0                   	// #0
 1129ac0:	17ffffd4 	b	1129a10 <crypto_acipher_gen_dsa_key+0x44>
		return TEE_ERROR_OUT_OF_MEMORY;
 1129ac4:	129ffe60 	mov	w0, #0xffff000c            	// #-65524
 1129ac8:	17ffffd2 	b	1129a10 <crypto_acipher_gen_dsa_key+0x44>

0000000001129acc <crypto_acipher_dsa_sign>:

TEE_Result crypto_acipher_dsa_sign(uint32_t algo, struct dsa_keypair *key,
				   const uint8_t *msg, size_t msg_len,
				   uint8_t *sig, size_t *sig_len)
{
 1129acc:	a9b57bfd 	stp	x29, x30, [sp, #-176]!
 1129ad0:	910003fd 	mov	x29, sp
 1129ad4:	a9046bf9 	stp	x25, x26, [sp, #64]
	size_t hash_size;
	int ltc_res;
	void *r, *s;
	dsa_key ltc_key = {
		.type = PK_PRIVATE,
		.qord = mp_unsigned_bin_size(key->g),
 1129ad8:	b000019a 	adrp	x26, 115a000 <__scattered_array_1phys_mem_map+0x8>
{
 1129adc:	aa0203f9 	mov	x25, x2
 1129ae0:	a90153f3 	stp	x19, x20, [sp, #16]
 1129ae4:	2a0003f3 	mov	w19, w0
	dsa_key ltc_key = {
 1129ae8:	52800020 	mov	w0, #0x1                   	// #1
 1129aec:	b90083e0 	str	w0, [sp, #128]
{
 1129af0:	aa0103f4 	mov	x20, x1
		.qord = mp_unsigned_bin_size(key->g),
 1129af4:	f941d740 	ldr	x0, [x26, #936]
{
 1129af8:	a9025bf5 	stp	x21, x22, [sp, #32]
 1129afc:	aa0503f6 	mov	x22, x5
 1129b00:	a90363f7 	stp	x23, x24, [sp, #48]
 1129b04:	aa0303f8 	mov	x24, x3
 1129b08:	aa0403f7 	mov	x23, x4
		.qord = mp_unsigned_bin_size(key->g),
 1129b0c:	f9404c01 	ldr	x1, [x0, #152]
{
 1129b10:	f9002bfb 	str	x27, [sp, #80]
		.qord = mp_unsigned_bin_size(key->g),
 1129b14:	f9400280 	ldr	x0, [x20]
 1129b18:	d63f0020 	blr	x1
	dsa_key ltc_key = {
 1129b1c:	b90087e0 	str	w0, [sp, #132]
 1129b20:	f9400280 	ldr	x0, [x20]
 1129b24:	f90047e0 	str	x0, [sp, #136]
 1129b28:	f9400a80 	ldr	x0, [x20, #16]
 1129b2c:	f9004be0 	str	x0, [sp, #144]
 1129b30:	f9400680 	ldr	x0, [x20, #8]
 1129b34:	f9004fe0 	str	x0, [sp, #152]
 1129b38:	f9401280 	ldr	x0, [x20, #32]
 1129b3c:	f90053e0 	str	x0, [sp, #160]
 1129b40:	f9400e80 	ldr	x0, [x20, #24]
 1129b44:	f90057e0 	str	x0, [sp, #168]
		.q = key->q,
		.y = key->y,
		.x = key->x,
	};

	if (algo != TEE_ALG_DSA_SHA1 &&
 1129b48:	12137a61 	and	w1, w19, #0xffffefff
 1129b4c:	52842620 	mov	w0, #0x2131                	// #8497
 1129b50:	72ae0000 	movk	w0, #0x7000, lsl #16
 1129b54:	aa1a03f4 	mov	x20, x26
 1129b58:	6b00003f 	cmp	w1, w0
 1129b5c:	54000080 	b.eq	1129b6c <crypto_acipher_dsa_sign+0xa0>  // b.none
	    algo != TEE_ALG_DSA_SHA224 &&
 1129b60:	11400800 	add	w0, w0, #0x2, lsl #12
 1129b64:	6b00027f 	cmp	w19, w0
 1129b68:	54000c41 	b.ne	1129cf0 <crypto_acipher_dsa_sign+0x224>  // b.any
	return (algo >> 12) & 0xF;
 1129b6c:	d34c3e73 	ubfx	x19, x19, #12, #4
	    algo != TEE_ALG_DSA_SHA256) {
		res = TEE_ERROR_NOT_IMPLEMENTED;
		goto err;
	}

	res = tee_alg_get_digest_size(TEE_DIGEST_HASH_TO_ALGO(algo),
 1129b70:	528000e2 	mov	w2, #0x7                   	// #7
	return (TEE_OPERATION_DIGEST << 28) | main_hash;
 1129b74:	71001e7f 	cmp	w19, #0x7
 1129b78:	72aa0002 	movk	w2, #0x5000, lsl #16
 1129b7c:	52aa0000 	mov	w0, #0x50000000            	// #1342177280
 1129b80:	2a000260 	orr	w0, w19, w0
 1129b84:	9101a3e1 	add	x1, sp, #0x68
 1129b88:	1a821000 	csel	w0, w0, w2, ne  // ne = any
 1129b8c:	97ffc6eb 	bl	111b738 <tee_alg_get_digest_size>
 1129b90:	2a0003f5 	mov	w21, w0
				      &hash_size);
	if (res != TEE_SUCCESS)
 1129b94:	35000380 	cbnz	w0, 1129c04 <crypto_acipher_dsa_sign+0x138>
		goto err;
	if (mp_unsigned_bin_size(ltc_key.q) < hash_size)
 1129b98:	f941d693 	ldr	x19, [x20, #936]
 1129b9c:	f9404be0 	ldr	x0, [sp, #144]
 1129ba0:	f9404e61 	ldr	x1, [x19, #152]
 1129ba4:	d63f0020 	blr	x1
 1129ba8:	f94037e1 	ldr	x1, [sp, #104]
 1129bac:	eb01001f 	cmp	x0, x1
 1129bb0:	540000a2 	b.cs	1129bc4 <crypto_acipher_dsa_sign+0xf8>  // b.hs, b.nlast
		hash_size = mp_unsigned_bin_size(ltc_key.q);
 1129bb4:	f9404be0 	ldr	x0, [sp, #144]
 1129bb8:	f9404e61 	ldr	x1, [x19, #152]
 1129bbc:	d63f0020 	blr	x1
 1129bc0:	f90037e0 	str	x0, [sp, #104]
	if (msg_len != hash_size) {
 1129bc4:	f94037e0 	ldr	x0, [sp, #104]
 1129bc8:	eb18001f 	cmp	x0, x24
 1129bcc:	54000961 	b.ne	1129cf8 <crypto_acipher_dsa_sign+0x22c>  // b.any
		res = TEE_ERROR_SECURITY;
		goto err;
	}

	if (*sig_len < 2 * mp_unsigned_bin_size(ltc_key.q)) {
 1129bd0:	f941d693 	ldr	x19, [x20, #936]
 1129bd4:	f94002db 	ldr	x27, [x22]
 1129bd8:	f9404be0 	ldr	x0, [sp, #144]
 1129bdc:	f9404e61 	ldr	x1, [x19, #152]
 1129be0:	d63f0020 	blr	x1
 1129be4:	eb00077f 	cmp	x27, x0, lsl #1
 1129be8:	540001e2 	b.cs	1129c24 <crypto_acipher_dsa_sign+0x158>  // b.hs, b.nlast
		*sig_len = 2 * mp_unsigned_bin_size(ltc_key.q);
 1129bec:	f9404be0 	ldr	x0, [sp, #144]
		res = TEE_ERROR_SHORT_BUFFER;
 1129bf0:	129ffdf5 	mov	w21, #0xffff0010            	// #-65520
		*sig_len = 2 * mp_unsigned_bin_size(ltc_key.q);
 1129bf4:	f9404e61 	ldr	x1, [x19, #152]
 1129bf8:	d63f0020 	blr	x1
 1129bfc:	d37ff800 	lsl	x0, x0, #1
 1129c00:	f90002c0 	str	x0, [x22]

	mp_clear_multi(r, s, NULL);

err:
	return res;
}
 1129c04:	2a1503e0 	mov	w0, w21
 1129c08:	a94153f3 	ldp	x19, x20, [sp, #16]
 1129c0c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1129c10:	a94363f7 	ldp	x23, x24, [sp, #48]
 1129c14:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1129c18:	f9402bfb 	ldr	x27, [sp, #80]
 1129c1c:	a8cb7bfd 	ldp	x29, x30, [sp], #176
 1129c20:	d65f03c0 	ret
	ltc_res = mp_init_multi(&r, &s, NULL);
 1129c24:	9101e3e1 	add	x1, sp, #0x78
 1129c28:	9101c3e0 	add	x0, sp, #0x70
 1129c2c:	d2800002 	mov	x2, #0x0                   	// #0
 1129c30:	940020a1 	bl	1131eb4 <ltc_init_multi>
	if (ltc_res != CRYPT_OK) {
 1129c34:	35000660 	cbnz	w0, 1129d00 <crypto_acipher_dsa_sign+0x234>
	ltc_res = dsa_sign_hash_raw(msg, msg_len, r, s, NULL,
 1129c38:	a9476bf4 	ldp	x20, x26, [sp, #112]
 1129c3c:	b0000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 1129c40:	9113d800 	add	x0, x0, #0x4f6
 1129c44:	94002267 	bl	11325e0 <find_prng>
 1129c48:	910203e6 	add	x6, sp, #0x80
 1129c4c:	2a0003e5 	mov	w5, w0
 1129c50:	aa1803e1 	mov	x1, x24
 1129c54:	aa1903e0 	mov	x0, x25
 1129c58:	d2800004 	mov	x4, #0x0                   	// #0
 1129c5c:	aa1a03e3 	mov	x3, x26
 1129c60:	aa1403e2 	mov	x2, x20
 1129c64:	940027cb 	bl	1133b90 <dsa_sign_hash_raw>
	if (ltc_res == CRYPT_OK) {
 1129c68:	35000400 	cbnz	w0, 1129ce8 <crypto_acipher_dsa_sign+0x21c>
		*sig_len = 2 * mp_unsigned_bin_size(ltc_key.q);
 1129c6c:	f9404be0 	ldr	x0, [sp, #144]
 1129c70:	f9404e61 	ldr	x1, [x19, #152]
 1129c74:	d63f0020 	blr	x1
 1129c78:	d37ff802 	lsl	x2, x0, #1
 1129c7c:	f90002c2 	str	x2, [x22]
		memset(sig, 0, *sig_len);
 1129c80:	52800001 	mov	w1, #0x0                   	// #0
 1129c84:	aa1703e0 	mov	x0, x23
 1129c88:	94006816 	bl	1143ce0 <memset>
		mp_to_unsigned_bin(r, (uint8_t *)sig + *sig_len/2 -
 1129c8c:	a949e661 	ldp	x1, x25, [x19, #152]
 1129c90:	f94002d4 	ldr	x20, [x22]
 1129c94:	f9403bf8 	ldr	x24, [sp, #112]
 1129c98:	d341fe94 	lsr	x20, x20, #1
 1129c9c:	aa1803e0 	mov	x0, x24
 1129ca0:	d63f0020 	blr	x1
 1129ca4:	cb000281 	sub	x1, x20, x0
 1129ca8:	aa1803e0 	mov	x0, x24
 1129cac:	8b0102e1 	add	x1, x23, x1
 1129cb0:	d63f0320 	blr	x25
		mp_to_unsigned_bin(s, (uint8_t *)sig + *sig_len -
 1129cb4:	a949e661 	ldp	x1, x25, [x19, #152]
 1129cb8:	f94002d4 	ldr	x20, [x22]
 1129cbc:	f9403ff8 	ldr	x24, [sp, #120]
 1129cc0:	aa1803e0 	mov	x0, x24
 1129cc4:	d63f0020 	blr	x1
 1129cc8:	cb000281 	sub	x1, x20, x0
 1129ccc:	aa1803e0 	mov	x0, x24
 1129cd0:	8b0102e1 	add	x1, x23, x1
 1129cd4:	d63f0320 	blr	x25
	mp_clear_multi(r, s, NULL);
 1129cd8:	a94707e0 	ldp	x0, x1, [sp, #112]
 1129cdc:	d2800002 	mov	x2, #0x0                   	// #0
 1129ce0:	9400210f 	bl	113211c <ltc_deinit_multi>
 1129ce4:	17ffffc8 	b	1129c04 <crypto_acipher_dsa_sign+0x138>
		res = TEE_ERROR_GENERIC;
 1129ce8:	52bffff5 	mov	w21, #0xffff0000            	// #-65536
 1129cec:	17fffffb 	b	1129cd8 <crypto_acipher_dsa_sign+0x20c>
		res = TEE_ERROR_NOT_IMPLEMENTED;
 1129cf0:	129ffed5 	mov	w21, #0xffff0009            	// #-65527
 1129cf4:	17ffffc4 	b	1129c04 <crypto_acipher_dsa_sign+0x138>
		res = TEE_ERROR_SECURITY;
 1129cf8:	129ffe15 	mov	w21, #0xffff000f            	// #-65521
 1129cfc:	17ffffc2 	b	1129c04 <crypto_acipher_dsa_sign+0x138>
		res = TEE_ERROR_OUT_OF_MEMORY;
 1129d00:	129ffe75 	mov	w21, #0xffff000c            	// #-65524
	return res;
 1129d04:	17ffffc0 	b	1129c04 <crypto_acipher_dsa_sign+0x138>

0000000001129d08 <crypto_acipher_dsa_verify>:

TEE_Result crypto_acipher_dsa_verify(uint32_t algo, struct dsa_public_key *key,
				     const uint8_t *msg, size_t msg_len,
				     const uint8_t *sig, size_t sig_len)
{
 1129d08:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
	TEE_Result res;
	int ltc_stat, ltc_res;
	void *r, *s;
	dsa_key ltc_key = {
		.type = PK_PUBLIC,
		.qord = mp_unsigned_bin_size(key->g),
 1129d0c:	b0000186 	adrp	x6, 115a000 <__scattered_array_1phys_mem_map+0x8>
{
 1129d10:	910003fd 	mov	x29, sp
		.qord = mp_unsigned_bin_size(key->g),
 1129d14:	f941d4c6 	ldr	x6, [x6, #936]
{
 1129d18:	a90153f3 	stp	x19, x20, [sp, #16]
 1129d1c:	aa0103f3 	mov	x19, x1
 1129d20:	a9025bf5 	stp	x21, x22, [sp, #32]
 1129d24:	2a0003f6 	mov	w22, w0
 1129d28:	aa0403f5 	mov	x21, x4
		.qord = mp_unsigned_bin_size(key->g),
 1129d2c:	f9400260 	ldr	x0, [x19]
{
 1129d30:	a90363f7 	stp	x23, x24, [sp, #48]
 1129d34:	aa0503f4 	mov	x20, x5
		.qord = mp_unsigned_bin_size(key->g),
 1129d38:	f9404cc1 	ldr	x1, [x6, #152]
	dsa_key ltc_key = {
 1129d3c:	a9067fff 	stp	xzr, xzr, [sp, #96]
{
 1129d40:	aa0203f7 	mov	x23, x2
	dsa_key ltc_key = {
 1129d44:	a9077fff 	stp	xzr, xzr, [sp, #112]
{
 1129d48:	aa0303f8 	mov	x24, x3
	dsa_key ltc_key = {
 1129d4c:	a9087fff 	stp	xzr, xzr, [sp, #128]
		.qord = mp_unsigned_bin_size(key->g),
 1129d50:	d63f0020 	blr	x1
	dsa_key ltc_key = {
 1129d54:	b90067e0 	str	w0, [sp, #100]
 1129d58:	f9400260 	ldr	x0, [x19]
 1129d5c:	f90037e0 	str	x0, [sp, #104]
 1129d60:	f9400a60 	ldr	x0, [x19, #16]
 1129d64:	f9003be0 	str	x0, [sp, #112]
 1129d68:	f9400660 	ldr	x0, [x19, #8]
 1129d6c:	f9003fe0 	str	x0, [sp, #120]
 1129d70:	f9400e60 	ldr	x0, [x19, #24]
 1129d74:	f90047e0 	str	x0, [sp, #136]
		.p = key->p,
		.q = key->q,
		.y = key->y
	};

	if (algo != TEE_ALG_DSA_SHA1 &&
 1129d78:	12137ac1 	and	w1, w22, #0xffffefff
 1129d7c:	52842620 	mov	w0, #0x2131                	// #8497
 1129d80:	72ae0000 	movk	w0, #0x7000, lsl #16
 1129d84:	6b00003f 	cmp	w1, w0
 1129d88:	54000080 	b.eq	1129d98 <crypto_acipher_dsa_verify+0x90>  // b.none
	    algo != TEE_ALG_DSA_SHA224 &&
 1129d8c:	11400800 	add	w0, w0, #0x2, lsl #12
 1129d90:	6b0002df 	cmp	w22, w0
 1129d94:	54000561 	b.ne	1129e40 <crypto_acipher_dsa_verify+0x138>  // b.any
	    algo != TEE_ALG_DSA_SHA256) {
		res = TEE_ERROR_NOT_IMPLEMENTED;
		goto err;
	}

	ltc_res = mp_init_multi(&r, &s, NULL);
 1129d98:	910163e1 	add	x1, sp, #0x58
 1129d9c:	910143e0 	add	x0, sp, #0x50
 1129da0:	d2800002 	mov	x2, #0x0                   	// #0
 1129da4:	94002044 	bl	1131eb4 <ltc_init_multi>
	if (ltc_res != CRYPT_OK) {
 1129da8:	35000500 	cbnz	w0, 1129e48 <crypto_acipher_dsa_verify+0x140>
		res = TEE_ERROR_OUT_OF_MEMORY;
		goto err;
	}
	mp_read_unsigned_bin(r, (uint8_t *)sig, sig_len/2);
 1129dac:	b0000186 	adrp	x6, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1129db0:	d341fe94 	lsr	x20, x20, #1
 1129db4:	f9402be0 	ldr	x0, [sp, #80]
 1129db8:	aa1403e2 	mov	x2, x20
 1129dbc:	f941d4d3 	ldr	x19, [x6, #936]
 1129dc0:	aa1503e1 	mov	x1, x21
 1129dc4:	f9405663 	ldr	x3, [x19, #168]
 1129dc8:	d63f0060 	blr	x3
	mp_read_unsigned_bin(s, (uint8_t *)sig + sig_len/2, sig_len/2);
 1129dcc:	f9402fe0 	ldr	x0, [sp, #88]
 1129dd0:	aa1403e2 	mov	x2, x20
 1129dd4:	f9405663 	ldr	x3, [x19, #168]
 1129dd8:	8b1402a1 	add	x1, x21, x20
 1129ddc:	d63f0060 	blr	x3
	ltc_res = dsa_verify_hash_raw(r, s, msg, msg_len, &ltc_stat, &ltc_key);
 1129de0:	a94507e0 	ldp	x0, x1, [sp, #80]
 1129de4:	910183e5 	add	x5, sp, #0x60
 1129de8:	910133e4 	add	x4, sp, #0x4c
 1129dec:	aa1803e3 	mov	x3, x24
 1129df0:	aa1703e2 	mov	x2, x23
 1129df4:	9400280b 	bl	1133e20 <dsa_verify_hash_raw>
 1129df8:	2a0003f3 	mov	w19, w0
	mp_clear_multi(r, s, NULL);
 1129dfc:	a94507e0 	ldp	x0, x1, [sp, #80]
 1129e00:	d2800002 	mov	x2, #0x0                   	// #0
 1129e04:	940020c6 	bl	113211c <ltc_deinit_multi>

static inline TEE_Result convert_ltc_verify_status(int ltc_res, int ltc_stat)
{
	switch (ltc_res) {
 1129e08:	71001e7f 	cmp	w19, #0x7
 1129e0c:	54000220 	b.eq	1129e50 <crypto_acipher_dsa_verify+0x148>  // b.none
 1129e10:	71005a7f 	cmp	w19, #0x16
 1129e14:	540001e0 	b.eq	1129e50 <crypto_acipher_dsa_verify+0x148>  // b.none
 1129e18:	35000213 	cbnz	w19, 1129e58 <crypto_acipher_dsa_verify+0x150>
	case CRYPT_OK:
		if (ltc_stat == 1)
			return TEE_SUCCESS;
		else
			return TEE_ERROR_SIGNATURE_INVALID;
 1129e1c:	b9404fe0 	ldr	w0, [sp, #76]
 1129e20:	7100041f 	cmp	w0, #0x1
 1129e24:	1299f1a0 	mov	w0, #0xffff3072            	// #-53134
 1129e28:	1a8003e0 	csel	w0, wzr, w0, eq  // eq = none
	res = convert_ltc_verify_status(ltc_res, ltc_stat);
err:
	return res;
}
 1129e2c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1129e30:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1129e34:	a94363f7 	ldp	x23, x24, [sp, #48]
 1129e38:	a8c97bfd 	ldp	x29, x30, [sp], #144
 1129e3c:	d65f03c0 	ret
		res = TEE_ERROR_NOT_IMPLEMENTED;
 1129e40:	129ffec0 	mov	w0, #0xffff0009            	// #-65527
 1129e44:	17fffffa 	b	1129e2c <crypto_acipher_dsa_verify+0x124>
		res = TEE_ERROR_OUT_OF_MEMORY;
 1129e48:	129ffe60 	mov	w0, #0xffff000c            	// #-65524
 1129e4c:	17fffff8 	b	1129e2c <crypto_acipher_dsa_verify+0x124>
	case CRYPT_INVALID_PACKET:
	case CRYPT_PK_INVALID_SIZE:
		return TEE_ERROR_SIGNATURE_INVALID;
 1129e50:	1299f1a0 	mov	w0, #0xffff3072            	// #-53134
 1129e54:	17fffff6 	b	1129e2c <crypto_acipher_dsa_verify+0x124>
	switch (ltc_res) {
 1129e58:	52bfffe0 	mov	w0, #0xffff0000            	// #-65536
 1129e5c:	17fffff4 	b	1129e2c <crypto_acipher_dsa_verify+0x124>

0000000001129e60 <ecc_get_curve_info>:
	/*
	 * Note GPv1.1 indicates TEE_ALG_ECDH_NIST_P192_DERIVE_SHARED_SECRET
	 * but defines TEE_ALG_ECDH_P192
	 */

	switch (curve) {
 1129e60:	7100141f 	cmp	w0, #0x5
 1129e64:	54000168 	b.hi	1129e90 <ecc_get_curve_info+0x30>  // b.pmore
 1129e68:	34000180 	cbz	w0, 1129e98 <ecc_get_curve_info+0x38>
 1129e6c:	51000800 	sub	w0, w0, #0x2
 1129e70:	71000c1f 	cmp	w0, #0x3
 1129e74:	54000168 	b.hi	1129ea0 <ecc_get_curve_info+0x40>  // b.pmore
 1129e78:	b0000125 	adrp	x5, 114e000 <ldelf_data+0x8000>
 1129e7c:	912450a5 	add	x5, x5, #0x914
 1129e80:	386048a0 	ldrb	w0, [x5, w0, uxtw]
 1129e84:	10000065 	adr	x5, 1129e90 <ecc_get_curve_info+0x30>
 1129e88:	8b2088a0 	add	x0, x5, w0, sxtb #2
 1129e8c:	d61f0000 	br	x0
 1129e90:	710c001f 	cmp	w0, #0x300
 1129e94:	54000a00 	b.eq	1129fd4 <ecc_get_curve_info+0x174>  // b.none
 1129e98:	129ffea0 	mov	w0, #0xffff000a            	// #-65526
	if (key_size_bits)
		*key_size_bits = size_bits;
	if (curve_name)
		*curve_name = name;
	return TEE_SUCCESS;
}
 1129e9c:	d65f03c0 	ret
		if ((algo != 0) && (algo != TEE_ALG_ECDSA_P192) &&
 1129ea0:	7100003f 	cmp	w1, #0x0
 1129ea4:	52820820 	mov	w0, #0x1041                	// #4161
 1129ea8:	72ae0000 	movk	w0, #0x7000, lsl #16
 1129eac:	7a401024 	ccmp	w1, w0, #0x4, ne  // ne = any
 1129eb0:	540000a0 	b.eq	1129ec4 <ecc_get_curve_info+0x64>  // b.none
 1129eb4:	52820840 	mov	w0, #0x1042                	// #4162
 1129eb8:	72b00000 	movk	w0, #0x8000, lsl #16
 1129ebc:	6b00003f 	cmp	w1, w0
 1129ec0:	54000a81 	b.ne	112a010 <ecc_get_curve_info+0x1b0>  // b.any
		name = "NISTP192";
 1129ec4:	b0000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 1129ec8:	91140800 	add	x0, x0, #0x502
		size_bits = 192;
 1129ecc:	d2801801 	mov	x1, #0xc0                  	// #192
		size_bytes = 24;
 1129ed0:	d2800305 	mov	x5, #0x18                  	// #24
	if (key_size_bytes)
 1129ed4:	b4000042 	cbz	x2, 1129edc <ecc_get_curve_info+0x7c>
		*key_size_bytes = size_bytes;
 1129ed8:	f9000045 	str	x5, [x2]
	if (key_size_bits)
 1129edc:	b4000043 	cbz	x3, 1129ee4 <ecc_get_curve_info+0x84>
		*key_size_bits = size_bits;
 1129ee0:	f9000061 	str	x1, [x3]
	if (curve_name)
 1129ee4:	b4000044 	cbz	x4, 1129eec <ecc_get_curve_info+0x8c>
		*curve_name = name;
 1129ee8:	f9000080 	str	x0, [x4]
	return TEE_SUCCESS;
 1129eec:	52800000 	mov	w0, #0x0                   	// #0
 1129ef0:	17ffffeb 	b	1129e9c <ecc_get_curve_info+0x3c>
		if ((algo != 0) && (algo != TEE_ALG_ECDSA_P224) &&
 1129ef4:	7100003f 	cmp	w1, #0x0
 1129ef8:	52840820 	mov	w0, #0x2041                	// #8257
 1129efc:	72ae0000 	movk	w0, #0x7000, lsl #16
 1129f00:	7a401024 	ccmp	w1, w0, #0x4, ne  // ne = any
 1129f04:	540000a0 	b.eq	1129f18 <ecc_get_curve_info+0xb8>  // b.none
 1129f08:	52840840 	mov	w0, #0x2042                	// #8258
 1129f0c:	72b00000 	movk	w0, #0x8000, lsl #16
 1129f10:	6b00003f 	cmp	w1, w0
 1129f14:	540007e1 	b.ne	112a010 <ecc_get_curve_info+0x1b0>  // b.any
		name = "NISTP224";
 1129f18:	b0000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
		size_bits = 224;
 1129f1c:	d2801c01 	mov	x1, #0xe0                  	// #224
		name = "NISTP224";
 1129f20:	91142c00 	add	x0, x0, #0x50b
		size_bytes = 28;
 1129f24:	d2800385 	mov	x5, #0x1c                  	// #28
 1129f28:	17ffffeb 	b	1129ed4 <ecc_get_curve_info+0x74>
		if ((algo != 0) && (algo != TEE_ALG_ECDSA_P256) &&
 1129f2c:	7100003f 	cmp	w1, #0x0
 1129f30:	52860820 	mov	w0, #0x3041                	// #12353
 1129f34:	72ae0000 	movk	w0, #0x7000, lsl #16
 1129f38:	7a401024 	ccmp	w1, w0, #0x4, ne  // ne = any
 1129f3c:	540000a0 	b.eq	1129f50 <ecc_get_curve_info+0xf0>  // b.none
 1129f40:	52860840 	mov	w0, #0x3042                	// #12354
 1129f44:	72b00000 	movk	w0, #0x8000, lsl #16
 1129f48:	6b00003f 	cmp	w1, w0
 1129f4c:	54000621 	b.ne	112a010 <ecc_get_curve_info+0x1b0>  // b.any
		name = "NISTP256";
 1129f50:	b0000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 1129f54:	91145000 	add	x0, x0, #0x514
		size_bits = 256;
 1129f58:	d2802001 	mov	x1, #0x100                 	// #256
		size_bytes = 32;
 1129f5c:	d2800405 	mov	x5, #0x20                  	// #32
 1129f60:	17ffffdd 	b	1129ed4 <ecc_get_curve_info+0x74>
		if ((algo != 0) && (algo != TEE_ALG_ECDSA_P384) &&
 1129f64:	7100003f 	cmp	w1, #0x0
 1129f68:	52880820 	mov	w0, #0x4041                	// #16449
 1129f6c:	72ae0000 	movk	w0, #0x7000, lsl #16
 1129f70:	7a401024 	ccmp	w1, w0, #0x4, ne  // ne = any
 1129f74:	540000a0 	b.eq	1129f88 <ecc_get_curve_info+0x128>  // b.none
 1129f78:	52880840 	mov	w0, #0x4042                	// #16450
 1129f7c:	72b00000 	movk	w0, #0x8000, lsl #16
 1129f80:	6b00003f 	cmp	w1, w0
 1129f84:	54000461 	b.ne	112a010 <ecc_get_curve_info+0x1b0>  // b.any
		name = "NISTP384";
 1129f88:	b0000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
		size_bits = 384;
 1129f8c:	d2803001 	mov	x1, #0x180                 	// #384
		name = "NISTP384";
 1129f90:	91147400 	add	x0, x0, #0x51d
		size_bytes = 48;
 1129f94:	d2800605 	mov	x5, #0x30                  	// #48
 1129f98:	17ffffcf 	b	1129ed4 <ecc_get_curve_info+0x74>
		if ((algo != 0) && (algo != TEE_ALG_ECDSA_P521) &&
 1129f9c:	7100003f 	cmp	w1, #0x0
 1129fa0:	528a0820 	mov	w0, #0x5041                	// #20545
 1129fa4:	72ae0000 	movk	w0, #0x7000, lsl #16
 1129fa8:	7a401024 	ccmp	w1, w0, #0x4, ne  // ne = any
 1129fac:	540000a0 	b.eq	1129fc0 <ecc_get_curve_info+0x160>  // b.none
 1129fb0:	528a0840 	mov	w0, #0x5042                	// #20546
 1129fb4:	72b00000 	movk	w0, #0x8000, lsl #16
 1129fb8:	6b00003f 	cmp	w1, w0
 1129fbc:	540002a1 	b.ne	112a010 <ecc_get_curve_info+0x1b0>  // b.any
		name = "NISTP521";
 1129fc0:	b0000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
		size_bits = 521;
 1129fc4:	d2804121 	mov	x1, #0x209                 	// #521
		name = "NISTP521";
 1129fc8:	91149800 	add	x0, x0, #0x526
		size_bytes = 66;
 1129fcc:	d2800845 	mov	x5, #0x42                  	// #66
 1129fd0:	17ffffc1 	b	1129ed4 <ecc_get_curve_info+0x74>
		if ((algo != 0) && (algo != TEE_ALG_SM2_PKE) &&
 1129fd4:	7100003f 	cmp	w1, #0x0
 1129fd8:	528008a0 	mov	w0, #0x45                  	// #69
 1129fdc:	72b00000 	movk	w0, #0x8000, lsl #16
 1129fe0:	7a401024 	ccmp	w1, w0, #0x4, ne  // ne = any
 1129fe4:	54000100 	b.eq	112a004 <ecc_get_curve_info+0x1a4>  // b.none
		    (algo != TEE_ALG_SM2_DSA_SM3) &&
 1129fe8:	528c08a0 	mov	w0, #0x6045                	// #24645
 1129fec:	72ae0000 	movk	w0, #0x7000, lsl #16
 1129ff0:	6b00003f 	cmp	w1, w0
 1129ff4:	528008a0 	mov	w0, #0x45                  	// #69
 1129ff8:	72ac0000 	movk	w0, #0x6000, lsl #16
 1129ffc:	7a401024 	ccmp	w1, w0, #0x4, ne  // ne = any
 112a000:	54000081 	b.ne	112a010 <ecc_get_curve_info+0x1b0>  // b.any
		name = "SM2";
 112a004:	90000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 112a008:	9114bc00 	add	x0, x0, #0x52f
 112a00c:	17ffffd3 	b	1129f58 <ecc_get_curve_info+0xf8>
			return TEE_ERROR_BAD_PARAMETERS;
 112a010:	129fff20 	mov	w0, #0xffff0006            	// #-65530
 112a014:	17ffffa2 	b	1129e9c <ecc_get_curve_info+0x3c>

000000000112a018 <ecc_set_curve_from_name>:
}

/* Note: this function clears the key before setting the curve */
static TEE_Result ecc_set_curve_from_name(ecc_key *ltc_key,
					  const char *curve_name)
{
 112a018:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 112a01c:	910003fd 	mov	x29, sp
 112a020:	f9000bf3 	str	x19, [sp, #16]
 112a024:	aa0003f3 	mov	x19, x0
 112a028:	aa0103e0 	mov	x0, x1
	const ltc_ecc_curve *curve = NULL;
	int ltc_res = 0;

	ltc_res = ecc_find_curve(curve_name, &curve);
 112a02c:	9100a3e1 	add	x1, sp, #0x28
	const ltc_ecc_curve *curve = NULL;
 112a030:	f90017ff 	str	xzr, [sp, #40]
	ltc_res = ecc_find_curve(curve_name, &curve);
 112a034:	94002cb7 	bl	1135310 <ecc_find_curve>
	if (ltc_res != CRYPT_OK)
 112a038:	35000140 	cbnz	w0, 112a060 <ecc_set_curve_from_name+0x48>
		return TEE_ERROR_NOT_SUPPORTED;

	ltc_res = ecc_set_curve(curve, ltc_key);
 112a03c:	f94017e0 	ldr	x0, [sp, #40]
 112a040:	aa1303e1 	mov	x1, x19
 112a044:	94002d74 	bl	1135614 <ecc_set_curve>
	if (ltc_res != CRYPT_OK)
		return TEE_ERROR_GENERIC;
 112a048:	7100001f 	cmp	w0, #0x0
 112a04c:	52bfffe0 	mov	w0, #0xffff0000            	// #-65536
 112a050:	1a8003e0 	csel	w0, wzr, w0, eq  // eq = none

	return TEE_SUCCESS;
}
 112a054:	f9400bf3 	ldr	x19, [sp, #16]
 112a058:	a8c37bfd 	ldp	x29, x30, [sp], #48
 112a05c:	d65f03c0 	ret
		return TEE_ERROR_NOT_SUPPORTED;
 112a060:	129ffea0 	mov	w0, #0xffff000a            	// #-65526
 112a064:	17fffffc 	b	112a054 <ecc_set_curve_from_name+0x3c>

000000000112a068 <_ltc_ecc_generate_keypair>:
{
 112a068:	a9ac7bfd 	stp	x29, x30, [sp, #-320]!
 112a06c:	aa0103e6 	mov	x6, x1
	res = ecc_get_curve_info(key->curve, 0, &key_size_bytes, &key_size_bits,
 112a070:	d2800004 	mov	x4, #0x0                   	// #0
{
 112a074:	910003fd 	mov	x29, sp
 112a078:	a9025bf5 	stp	x21, x22, [sp, #32]
 112a07c:	aa0003f5 	mov	x21, x0
	res = ecc_get_curve_info(key->curve, 0, &key_size_bytes, &key_size_bits,
 112a080:	b9401800 	ldr	w0, [x0, #24]
 112a084:	910103e3 	add	x3, sp, #0x40
 112a088:	9100e3e2 	add	x2, sp, #0x38
 112a08c:	52800001 	mov	w1, #0x0                   	// #0
{
 112a090:	a90153f3 	stp	x19, x20, [sp, #16]
	size_t key_size_bits = 0;
 112a094:	a903ffff 	stp	xzr, xzr, [sp, #56]
	res = ecc_get_curve_info(key->curve, 0, &key_size_bytes, &key_size_bits,
 112a098:	97ffff72 	bl	1129e60 <ecc_get_curve_info>
 112a09c:	2a0003f4 	mov	w20, w0
	if (res != TEE_SUCCESS)
 112a0a0:	350000a0 	cbnz	w0, 112a0b4 <_ltc_ecc_generate_keypair+0x4c>
	if (key_size != key_size_bits)
 112a0a4:	f94023e0 	ldr	x0, [sp, #64]
 112a0a8:	eb06001f 	cmp	x0, x6
 112a0ac:	540000e0 	b.eq	112a0c8 <_ltc_ecc_generate_keypair+0x60>  // b.none
		return TEE_ERROR_BAD_PARAMETERS;
 112a0b0:	129fff34 	mov	w20, #0xffff0006            	// #-65530
}
 112a0b4:	2a1403e0 	mov	w0, w20
 112a0b8:	a94153f3 	ldp	x19, x20, [sp, #16]
 112a0bc:	a9425bf5 	ldp	x21, x22, [sp, #32]
 112a0c0:	a8d47bfd 	ldp	x29, x30, [sp], #320
 112a0c4:	d65f03c0 	ret
	ltc_res = ecc_make_key(NULL, find_prng("prng_crypto"),
 112a0c8:	90000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 112a0cc:	9113d800 	add	x0, x0, #0x4f6
 112a0d0:	94002144 	bl	11325e0 <find_prng>
 112a0d4:	910123f6 	add	x22, sp, #0x48
 112a0d8:	b9403be2 	ldr	w2, [sp, #56]
 112a0dc:	2a0003e1 	mov	w1, w0
 112a0e0:	aa1603e3 	mov	x3, x22
 112a0e4:	d2800000 	mov	x0, #0x0                   	// #0
 112a0e8:	94002d35 	bl	11355bc <ecc_make_key>
	if (ltc_res != CRYPT_OK)
 112a0ec:	35fffe20 	cbnz	w0, 112a0b0 <_ltc_ecc_generate_keypair+0x48>
	if (((size_t)mp_count_bits(ltc_tmp_key.pubkey.x) > key_size_bits) ||
 112a0f0:	90000193 	adrp	x19, 115a000 <__scattered_array_1phys_mem_map+0x8>
 112a0f4:	f94093e0 	ldr	x0, [sp, #288]
 112a0f8:	f941d673 	ldr	x19, [x19, #936]
 112a0fc:	f9403a61 	ldr	x1, [x19, #112]
 112a100:	d63f0020 	blr	x1
 112a104:	f94023e1 	ldr	x1, [sp, #64]
 112a108:	eb20c03f 	cmp	x1, w0, sxtw
 112a10c:	540000a2 	b.cs	112a120 <_ltc_ecc_generate_keypair+0xb8>  // b.hs, b.nlast
		res = TEE_ERROR_BAD_PARAMETERS;
 112a110:	129fff34 	mov	w20, #0xffff0006            	// #-65530
	ecc_free(&ltc_tmp_key);		/* Free the temporary key */
 112a114:	aa1603e0 	mov	x0, x22
 112a118:	94002ce9 	bl	11354bc <ecc_free>
	return res;
 112a11c:	17ffffe6 	b	112a0b4 <_ltc_ecc_generate_keypair+0x4c>
	    ((size_t)mp_count_bits(ltc_tmp_key.pubkey.y) > key_size_bits) ||
 112a120:	f9403a61 	ldr	x1, [x19, #112]
 112a124:	f94097e0 	ldr	x0, [sp, #296]
 112a128:	d63f0020 	blr	x1
	if (((size_t)mp_count_bits(ltc_tmp_key.pubkey.x) > key_size_bits) ||
 112a12c:	f94023e1 	ldr	x1, [sp, #64]
 112a130:	eb20c03f 	cmp	x1, w0, sxtw
 112a134:	54fffee3 	b.cc	112a110 <_ltc_ecc_generate_keypair+0xa8>  // b.lo, b.ul, b.last
	    ((size_t)mp_count_bits(ltc_tmp_key.k) > key_size_bits)) {
 112a138:	f9403a61 	ldr	x1, [x19, #112]
 112a13c:	f9409fe0 	ldr	x0, [sp, #312]
 112a140:	d63f0020 	blr	x1
	    ((size_t)mp_count_bits(ltc_tmp_key.pubkey.y) > key_size_bits) ||
 112a144:	f94023e1 	ldr	x1, [sp, #64]
 112a148:	eb20c03f 	cmp	x1, w0, sxtw
 112a14c:	54fffe23 	b.cc	112a110 <_ltc_ecc_generate_keypair+0xa8>  // b.lo, b.ul, b.last
	if (mp_count_bits(ltc_tmp_key.pubkey.z) != 1) {
 112a150:	f9403a61 	ldr	x1, [x19, #112]
 112a154:	f9409be0 	ldr	x0, [sp, #304]
 112a158:	d63f0020 	blr	x1
 112a15c:	7100041f 	cmp	w0, #0x1
 112a160:	54fffd81 	b.ne	112a110 <_ltc_ecc_generate_keypair+0xa8>  // b.any
	ltc_mp.copy(ltc_tmp_key.k, key->d);
 112a164:	f94002a1 	ldr	x1, [x21]
 112a168:	f9401e62 	ldr	x2, [x19, #56]
 112a16c:	f9409fe0 	ldr	x0, [sp, #312]
 112a170:	d63f0040 	blr	x2
	ltc_mp.copy(ltc_tmp_key.pubkey.x, key->x);
 112a174:	f94006a1 	ldr	x1, [x21, #8]
 112a178:	f9401e62 	ldr	x2, [x19, #56]
 112a17c:	f94093e0 	ldr	x0, [sp, #288]
 112a180:	d63f0040 	blr	x2
	ltc_mp.copy(ltc_tmp_key.pubkey.y, key->y);
 112a184:	f9400aa1 	ldr	x1, [x21, #16]
 112a188:	f9401e62 	ldr	x2, [x19, #56]
 112a18c:	f94097e0 	ldr	x0, [sp, #296]
 112a190:	d63f0040 	blr	x2
	res = TEE_SUCCESS;
 112a194:	17ffffe0 	b	112a114 <_ltc_ecc_generate_keypair+0xac>

000000000112a198 <bn_alloc_max>:
{
 112a198:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 112a19c:	910003fd 	mov	x29, sp
 112a1a0:	f9000bf3 	str	x19, [sp, #16]
 112a1a4:	aa0003f3 	mov	x19, x0
	*s = crypto_bignum_allocate(_CFG_CORE_LTC_BIGNUM_MAX_BITS);
 112a1a8:	d2820000 	mov	x0, #0x1000                	// #4096
 112a1ac:	9400101f 	bl	112e228 <crypto_bignum_allocate>
	return *s;
 112a1b0:	f100001f 	cmp	x0, #0x0
	*s = crypto_bignum_allocate(_CFG_CORE_LTC_BIGNUM_MAX_BITS);
 112a1b4:	f9000260 	str	x0, [x19]
}
 112a1b8:	1a9f07e0 	cset	w0, ne  // ne = any
 112a1bc:	f9400bf3 	ldr	x19, [sp, #16]
 112a1c0:	a8c27bfd 	ldp	x29, x30, [sp], #32
 112a1c4:	d65f03c0 	ret

000000000112a1c8 <_ltc_ecc_free_public_key>:
	if (!s)
 112a1c8:	b4000160 	cbz	x0, 112a1f4 <_ltc_ecc_free_public_key+0x2c>
{
 112a1cc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 112a1d0:	910003fd 	mov	x29, sp
 112a1d4:	f9000bf3 	str	x19, [sp, #16]
 112a1d8:	aa0003f3 	mov	x19, x0
	crypto_bignum_free(s->x);
 112a1dc:	f9400000 	ldr	x0, [x0]
 112a1e0:	94001028 	bl	112e280 <crypto_bignum_free>
	crypto_bignum_free(s->y);
 112a1e4:	f9400660 	ldr	x0, [x19, #8]
}
 112a1e8:	f9400bf3 	ldr	x19, [sp, #16]
 112a1ec:	a8c27bfd 	ldp	x29, x30, [sp], #32
	crypto_bignum_free(s->y);
 112a1f0:	14001024 	b	112e280 <crypto_bignum_free>
 112a1f4:	d65f03c0 	ret

000000000112a1f8 <ecc_populate_ltc_private_key>:
 * It also returns the key size, in bytes
 */
TEE_Result ecc_populate_ltc_private_key(ecc_key *ltc_key,
					struct ecc_keypair *key,
					uint32_t algo, size_t *key_size_bytes)
{
 112a1f8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 112a1fc:	910003fd 	mov	x29, sp
 112a200:	a9025bf5 	stp	x21, x22, [sp, #32]
 112a204:	aa0103f6 	mov	x22, x1
	TEE_Result res = TEE_ERROR_GENERIC;
	const char *name = NULL;

	res = ecc_get_curve_info(key->curve, algo, key_size_bytes, NULL, &name);
 112a208:	9100e3e4 	add	x4, sp, #0x38
{
 112a20c:	a90153f3 	stp	x19, x20, [sp, #16]
 112a210:	aa0003f3 	mov	x19, x0
	res = ecc_get_curve_info(key->curve, algo, key_size_bytes, NULL, &name);
 112a214:	b9401ac0 	ldr	w0, [x22, #24]
{
 112a218:	2a0203e1 	mov	w1, w2
 112a21c:	aa0303e2 	mov	x2, x3
	res = ecc_get_curve_info(key->curve, algo, key_size_bytes, NULL, &name);
 112a220:	d2800003 	mov	x3, #0x0                   	// #0
	const char *name = NULL;
 112a224:	f9001fff 	str	xzr, [sp, #56]
	res = ecc_get_curve_info(key->curve, algo, key_size_bytes, NULL, &name);
 112a228:	97ffff0e 	bl	1129e60 <ecc_get_curve_info>
 112a22c:	2a0003f4 	mov	w20, w0
	if (res)
 112a230:	350003c0 	cbnz	w0, 112a2a8 <ecc_populate_ltc_private_key+0xb0>
		return res;

	memset(ltc_key, 0, sizeof(*ltc_key));
 112a234:	d2801f02 	mov	x2, #0xf8                  	// #248
 112a238:	52800001 	mov	w1, #0x0                   	// #0
 112a23c:	aa1303e0 	mov	x0, x19
 112a240:	940066a8 	bl	1143ce0 <memset>

	res = ecc_set_curve_from_name(ltc_key, name);
 112a244:	f9401fe1 	ldr	x1, [sp, #56]
 112a248:	aa1303e0 	mov	x0, x19
 112a24c:	97ffff73 	bl	112a018 <ecc_set_curve_from_name>
 112a250:	2a0003f4 	mov	w20, w0
	if (res)
 112a254:	350002a0 	cbnz	w0, 112a2a8 <ecc_populate_ltc_private_key+0xb0>
		return res;

	ltc_key->type = PK_PRIVATE;
	mp_copy(key->d, ltc_key->k);
 112a258:	90000195 	adrp	x21, 115a000 <__scattered_array_1phys_mem_map+0x8>
	ltc_key->type = PK_PRIVATE;
 112a25c:	52800020 	mov	w0, #0x1                   	// #1
	mp_copy(key->d, ltc_key->k);
 112a260:	f9407a61 	ldr	x1, [x19, #240]
 112a264:	f941d6b5 	ldr	x21, [x21, #936]
 112a268:	f9401ea2 	ldr	x2, [x21, #56]
	ltc_key->type = PK_PRIVATE;
 112a26c:	b9000260 	str	w0, [x19]
	mp_copy(key->d, ltc_key->k);
 112a270:	f94002c0 	ldr	x0, [x22]
 112a274:	d63f0040 	blr	x2
	mp_copy(key->x, ltc_key->pubkey.x);
 112a278:	f94006c0 	ldr	x0, [x22, #8]
 112a27c:	f9401ea2 	ldr	x2, [x21, #56]
 112a280:	f9406e61 	ldr	x1, [x19, #216]
 112a284:	d63f0040 	blr	x2
	mp_copy(key->y, ltc_key->pubkey.y);
 112a288:	f9400ac0 	ldr	x0, [x22, #16]
 112a28c:	f9401ea2 	ldr	x2, [x21, #56]
 112a290:	f9407261 	ldr	x1, [x19, #224]
 112a294:	d63f0040 	blr	x2
	mp_set_int(ltc_key->pubkey.z, 1);
 112a298:	f94022a2 	ldr	x2, [x21, #64]
 112a29c:	d2800021 	mov	x1, #0x1                   	// #1
 112a2a0:	f9407660 	ldr	x0, [x19, #232]
 112a2a4:	d63f0040 	blr	x2

	return TEE_SUCCESS;
}
 112a2a8:	2a1403e0 	mov	w0, w20
 112a2ac:	a94153f3 	ldp	x19, x20, [sp, #16]
 112a2b0:	a9425bf5 	ldp	x21, x22, [sp, #32]
 112a2b4:	a8c47bfd 	ldp	x29, x30, [sp], #64
 112a2b8:	d65f03c0 	ret

000000000112a2bc <_ltc_ecc_sign>:
}

static TEE_Result _ltc_ecc_sign(uint32_t algo, struct ecc_keypair *key,
				const uint8_t *msg, size_t msg_len,
				uint8_t *sig, size_t *sig_len)
{
 112a2bc:	d105c3ff 	sub	sp, sp, #0x170
 112a2c0:	a9017bfd 	stp	x29, x30, [sp, #16]
 112a2c4:	910043fd 	add	x29, sp, #0x10
 112a2c8:	a9035bf5 	stp	x21, x22, [sp, #48]
	TEE_Result res = TEE_ERROR_GENERIC;
	int ltc_res = 0;
	size_t key_size_bytes = 0;
	ecc_key ltc_key = { };
 112a2cc:	9101e3f5 	add	x21, sp, #0x78
{
 112a2d0:	aa0203f6 	mov	x22, x2
	ecc_key ltc_key = { };
 112a2d4:	d2801f02 	mov	x2, #0xf8                  	// #248
{
 112a2d8:	a90253f3 	stp	x19, x20, [sp, #32]
 112a2dc:	2a0003f3 	mov	w19, w0
 112a2e0:	aa0503f4 	mov	x20, x5
	ecc_key ltc_key = { };
 112a2e4:	aa1503e0 	mov	x0, x21
{
 112a2e8:	a90463f7 	stp	x23, x24, [sp, #64]
 112a2ec:	aa0303f7 	mov	x23, x3
 112a2f0:	aa0403f8 	mov	x24, x4
 112a2f4:	f9002bf9 	str	x25, [sp, #80]
 112a2f8:	aa0103f9 	mov	x25, x1
	ecc_key ltc_key = { };
 112a2fc:	52800001 	mov	w1, #0x0                   	// #0
	size_t key_size_bytes = 0;
 112a300:	f90037ff 	str	xzr, [sp, #104]
	ecc_key ltc_key = { };
 112a304:	94006677 	bl	1143ce0 <memset>
	unsigned long ltc_sig_len = 0;
 112a308:	f9003bff 	str	xzr, [sp, #112]

	if (algo == 0)
 112a30c:	340005b3 	cbz	w19, 112a3c0 <_ltc_ecc_sign+0x104>
		return TEE_ERROR_BAD_PARAMETERS;

	res = ecc_populate_ltc_private_key(&ltc_key, key, algo,
 112a310:	2a1303e2 	mov	w2, w19
 112a314:	9101a3e3 	add	x3, sp, #0x68
 112a318:	aa1903e1 	mov	x1, x25
 112a31c:	aa1503e0 	mov	x0, x21
 112a320:	97ffffb6 	bl	112a1f8 <ecc_populate_ltc_private_key>
 112a324:	2a0003f3 	mov	w19, w0
					   &key_size_bytes);
	if (res != TEE_SUCCESS)
 112a328:	35000140 	cbnz	w0, 112a350 <_ltc_ecc_sign+0x94>
		return res;

	if (*sig_len < 2 * key_size_bytes) {
 112a32c:	f9400280 	ldr	x0, [x20]
 112a330:	f94037e1 	ldr	x1, [sp, #104]
 112a334:	d37ff822 	lsl	x2, x1, #1
 112a338:	eb01041f 	cmp	x0, x1, lsl #1
 112a33c:	540001a2 	b.cs	112a370 <_ltc_ecc_sign+0xb4>  // b.hs, b.nlast
		*sig_len = 2 * key_size_bytes;
		res = TEE_ERROR_SHORT_BUFFER;
 112a340:	129ffdf3 	mov	w19, #0xffff0010            	// #-65520
		*sig_len = 2 * key_size_bytes;
 112a344:	f9000282 	str	x2, [x20]
		res = TEE_ERROR_GENERIC;
	}
	*sig_len = ltc_sig_len;

out:
	ecc_free(&ltc_key);
 112a348:	aa1503e0 	mov	x0, x21
 112a34c:	94002c5c 	bl	11354bc <ecc_free>
	return res;
}
 112a350:	2a1303e0 	mov	w0, w19
 112a354:	a9417bfd 	ldp	x29, x30, [sp, #16]
 112a358:	a94253f3 	ldp	x19, x20, [sp, #32]
 112a35c:	a9435bf5 	ldp	x21, x22, [sp, #48]
 112a360:	a94463f7 	ldp	x23, x24, [sp, #64]
 112a364:	f9402bf9 	ldr	x25, [sp, #80]
 112a368:	9105c3ff 	add	sp, sp, #0x170
 112a36c:	d65f03c0 	ret
	ltc_sig_len = *sig_len;
 112a370:	f9003be0 	str	x0, [sp, #112]
	ltc_res = ecc_sign_hash_rfc7518(msg, msg_len, sig, &ltc_sig_len,
 112a374:	90000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 112a378:	9113d800 	add	x0, x0, #0x4f6
 112a37c:	94002099 	bl	11325e0 <find_prng>
 112a380:	f90003f5 	str	x21, [sp]
 112a384:	2a0003e5 	mov	w5, w0
 112a388:	9101c3e3 	add	x3, sp, #0x70
 112a38c:	aa1803e2 	mov	x2, x24
 112a390:	aa1703e1 	mov	x1, x23
 112a394:	aa1603e0 	mov	x0, x22
 112a398:	d2800007 	mov	x7, #0x0                   	// #0
 112a39c:	52800026 	mov	w6, #0x1                   	// #1
 112a3a0:	d2800004 	mov	x4, #0x0                   	// #0
 112a3a4:	94002d88 	bl	11359c4 <ecc_sign_hash_ex>
		res = TEE_ERROR_GENERIC;
 112a3a8:	7100001f 	cmp	w0, #0x0
 112a3ac:	52bffff3 	mov	w19, #0xffff0000            	// #-65536
	*sig_len = ltc_sig_len;
 112a3b0:	f9403be0 	ldr	x0, [sp, #112]
		res = TEE_ERROR_GENERIC;
 112a3b4:	1a9303f3 	csel	w19, wzr, w19, eq  // eq = none
	*sig_len = ltc_sig_len;
 112a3b8:	f9000280 	str	x0, [x20]
 112a3bc:	17ffffe3 	b	112a348 <_ltc_ecc_sign+0x8c>
		return TEE_ERROR_BAD_PARAMETERS;
 112a3c0:	129fff33 	mov	w19, #0xffff0006            	// #-65530
 112a3c4:	17ffffe3 	b	112a350 <_ltc_ecc_sign+0x94>

000000000112a3c8 <ecc_populate_ltc_public_key>:
{
 112a3c8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 112a3cc:	910003fd 	mov	x29, sp
 112a3d0:	a9025bf5 	stp	x21, x22, [sp, #32]
 112a3d4:	aa0103f6 	mov	x22, x1
	res = ecc_get_curve_info(key->curve, algo, key_size_bytes, NULL, &name);
 112a3d8:	9100e3e4 	add	x4, sp, #0x38
{
 112a3dc:	a90153f3 	stp	x19, x20, [sp, #16]
 112a3e0:	aa0003f4 	mov	x20, x0
	uint8_t one[1] = { 1 };
 112a3e4:	52800020 	mov	w0, #0x1                   	// #1
 112a3e8:	3900c3e0 	strb	w0, [sp, #48]
{
 112a3ec:	2a0203e1 	mov	w1, w2
	res = ecc_get_curve_info(key->curve, algo, key_size_bytes, NULL, &name);
 112a3f0:	b94012c0 	ldr	w0, [x22, #16]
{
 112a3f4:	aa0303e2 	mov	x2, x3
	res = ecc_get_curve_info(key->curve, algo, key_size_bytes, NULL, &name);
 112a3f8:	d2800003 	mov	x3, #0x0                   	// #0
	const char *name = NULL;
 112a3fc:	f9001fff 	str	xzr, [sp, #56]
	res = ecc_get_curve_info(key->curve, algo, key_size_bytes, NULL, &name);
 112a400:	97fffe98 	bl	1129e60 <ecc_get_curve_info>
 112a404:	2a0003f3 	mov	w19, w0
	if (res)
 112a408:	35000340 	cbnz	w0, 112a470 <ecc_populate_ltc_public_key+0xa8>
	memset(ltc_key, 0, sizeof(*ltc_key));
 112a40c:	d2801f02 	mov	x2, #0xf8                  	// #248
 112a410:	52800001 	mov	w1, #0x0                   	// #0
 112a414:	aa1403e0 	mov	x0, x20
 112a418:	94006632 	bl	1143ce0 <memset>
	res = ecc_set_curve_from_name(ltc_key, name);
 112a41c:	f9401fe1 	ldr	x1, [sp, #56]
 112a420:	aa1403e0 	mov	x0, x20
 112a424:	97fffefd 	bl	112a018 <ecc_set_curve_from_name>
 112a428:	2a0003f3 	mov	w19, w0
	if (res)
 112a42c:	35000220 	cbnz	w0, 112a470 <ecc_populate_ltc_public_key+0xa8>
	mp_copy(key->x, ltc_key->pubkey.x);
 112a430:	90000195 	adrp	x21, 115a000 <__scattered_array_1phys_mem_map+0x8>
 112a434:	f94002c0 	ldr	x0, [x22]
 112a438:	f941d6b5 	ldr	x21, [x21, #936]
 112a43c:	f9406e81 	ldr	x1, [x20, #216]
 112a440:	f9401ea2 	ldr	x2, [x21, #56]
	ltc_key->type = PK_PUBLIC;
 112a444:	b900029f 	str	wzr, [x20]
	mp_copy(key->x, ltc_key->pubkey.x);
 112a448:	d63f0040 	blr	x2
	mp_copy(key->y, ltc_key->pubkey.y);
 112a44c:	f94006c0 	ldr	x0, [x22, #8]
 112a450:	f9401ea2 	ldr	x2, [x21, #56]
 112a454:	f9407281 	ldr	x1, [x20, #224]
 112a458:	d63f0040 	blr	x2
	mp_read_unsigned_bin(ltc_key->pubkey.z, one, sizeof(one));
 112a45c:	f94056a3 	ldr	x3, [x21, #168]
 112a460:	9100c3e1 	add	x1, sp, #0x30
 112a464:	f9407680 	ldr	x0, [x20, #232]
 112a468:	d2800022 	mov	x2, #0x1                   	// #1
 112a46c:	d63f0060 	blr	x3
}
 112a470:	2a1303e0 	mov	w0, w19
 112a474:	a94153f3 	ldp	x19, x20, [sp, #16]
 112a478:	a9425bf5 	ldp	x21, x22, [sp, #32]
 112a47c:	a8c47bfd 	ldp	x29, x30, [sp], #64
 112a480:	d65f03c0 	ret

000000000112a484 <_ltc_ecc_shared_secret>:

static TEE_Result _ltc_ecc_shared_secret(struct ecc_keypair *private_key,
					 struct ecc_public_key *public_key,
					 void *secret,
					 unsigned long *secret_len)
{
 112a484:	d10943ff 	sub	sp, sp, #0x250
 112a488:	a9007bfd 	stp	x29, x30, [sp]
 112a48c:	910003fd 	mov	x29, sp
 112a490:	a90153f3 	stp	x19, x20, [sp, #16]
 112a494:	aa0003f3 	mov	x19, x0
	TEE_Result res = TEE_ERROR_GENERIC;
	int ltc_res = 0;
	ecc_key ltc_private_key = { };
	ecc_key ltc_public_key = { };
 112a498:	910563f4 	add	x20, sp, #0x158
{
 112a49c:	a9025bf5 	stp	x21, x22, [sp, #32]
 112a4a0:	aa0103f6 	mov	x22, x1
	ecc_key ltc_private_key = { };
 112a4a4:	910183f5 	add	x21, sp, #0x60
 112a4a8:	52800001 	mov	w1, #0x0                   	// #0
 112a4ac:	aa1503e0 	mov	x0, x21
{
 112a4b0:	a90363f7 	stp	x23, x24, [sp, #48]
 112a4b4:	aa0303f8 	mov	x24, x3
 112a4b8:	aa0203f7 	mov	x23, x2
	ecc_key ltc_private_key = { };
 112a4bc:	d2801f02 	mov	x2, #0xf8                  	// #248
{
 112a4c0:	f90023f9 	str	x25, [sp, #64]
	ecc_key ltc_private_key = { };
 112a4c4:	94006607 	bl	1143ce0 <memset>
	ecc_key ltc_public_key = { };
 112a4c8:	52800001 	mov	w1, #0x0                   	// #0
 112a4cc:	aa1403e0 	mov	x0, x20
 112a4d0:	d2801f02 	mov	x2, #0xf8                  	// #248
 112a4d4:	94006603 	bl	1143ce0 <memset>
	size_t key_size_bytes = 0;

	/* Check the curves are the same */
	if (private_key->curve != public_key->curve)
 112a4d8:	b9401a61 	ldr	w1, [x19, #24]
 112a4dc:	b94012c0 	ldr	w0, [x22, #16]
	size_t key_size_bytes = 0;
 112a4e0:	f9002fff 	str	xzr, [sp, #88]
	if (private_key->curve != public_key->curve)
 112a4e4:	6b00003f 	cmp	w1, w0
 112a4e8:	54000481 	b.ne	112a578 <_ltc_ecc_shared_secret+0xf4>  // b.any
		return TEE_ERROR_BAD_PARAMETERS;

	res = ecc_populate_ltc_private_key(&ltc_private_key, private_key,
 112a4ec:	910163f9 	add	x25, sp, #0x58
 112a4f0:	aa1303e1 	mov	x1, x19
 112a4f4:	aa1903e3 	mov	x3, x25
 112a4f8:	aa1503e0 	mov	x0, x21
 112a4fc:	52800002 	mov	w2, #0x0                   	// #0
 112a500:	97ffff3e 	bl	112a1f8 <ecc_populate_ltc_private_key>
 112a504:	2a0003f3 	mov	w19, w0
					   0, &key_size_bytes);
	if (res != TEE_SUCCESS)
 112a508:	35000200 	cbnz	w0, 112a548 <_ltc_ecc_shared_secret+0xc4>
		goto out;
	res = ecc_populate_ltc_public_key(&ltc_public_key, public_key,
 112a50c:	aa1903e3 	mov	x3, x25
 112a510:	aa1603e1 	mov	x1, x22
 112a514:	aa1403e0 	mov	x0, x20
 112a518:	52800002 	mov	w2, #0x0                   	// #0
 112a51c:	97ffffab 	bl	112a3c8 <ecc_populate_ltc_public_key>
 112a520:	2a0003f3 	mov	w19, w0
					  0, &key_size_bytes);
	if (res != TEE_SUCCESS)
 112a524:	35000120 	cbnz	w0, 112a548 <_ltc_ecc_shared_secret+0xc4>
		goto out;

	ltc_res = ecc_shared_secret(&ltc_private_key, &ltc_public_key,
 112a528:	aa1803e3 	mov	x3, x24
 112a52c:	aa1703e2 	mov	x2, x23
 112a530:	aa1403e1 	mov	x1, x20
 112a534:	aa1503e0 	mov	x0, x21
 112a538:	94002cdc 	bl	11358a8 <ecc_shared_secret>
				    secret, secret_len);
	if (ltc_res == CRYPT_OK)
		res = TEE_SUCCESS;
	else
		res = TEE_ERROR_BAD_PARAMETERS;
 112a53c:	7100001f 	cmp	w0, #0x0
 112a540:	129fff33 	mov	w19, #0xffff0006            	// #-65530
 112a544:	1a9303f3 	csel	w19, wzr, w19, eq  // eq = none

out:
	ecc_free(&ltc_private_key);
 112a548:	aa1503e0 	mov	x0, x21
 112a54c:	94002bdc 	bl	11354bc <ecc_free>
	ecc_free(&ltc_public_key);
 112a550:	aa1403e0 	mov	x0, x20
 112a554:	94002bda 	bl	11354bc <ecc_free>
	return res;
}
 112a558:	2a1303e0 	mov	w0, w19
 112a55c:	a9407bfd 	ldp	x29, x30, [sp]
 112a560:	a94153f3 	ldp	x19, x20, [sp, #16]
 112a564:	a9425bf5 	ldp	x21, x22, [sp, #32]
 112a568:	a94363f7 	ldp	x23, x24, [sp, #48]
 112a56c:	f94023f9 	ldr	x25, [sp, #64]
 112a570:	910943ff 	add	sp, sp, #0x250
 112a574:	d65f03c0 	ret
		return TEE_ERROR_BAD_PARAMETERS;
 112a578:	129fff33 	mov	w19, #0xffff0006            	// #-65530
 112a57c:	17fffff7 	b	112a558 <_ltc_ecc_shared_secret+0xd4>

000000000112a580 <_ltc_ecc_verify>:
{
 112a580:	a9aa7bfd 	stp	x29, x30, [sp, #-352]!
 112a584:	910003fd 	mov	x29, sp
 112a588:	a90153f3 	stp	x19, x20, [sp, #16]
	ecc_key ltc_key = { };
 112a58c:	9101a3f4 	add	x20, sp, #0x68
{
 112a590:	2a0003f3 	mov	w19, w0
	ecc_key ltc_key = { };
 112a594:	aa1403e0 	mov	x0, x20
{
 112a598:	a9025bf5 	stp	x21, x22, [sp, #32]
 112a59c:	aa0203f6 	mov	x22, x2
 112a5a0:	aa0403f5 	mov	x21, x4
	ecc_key ltc_key = { };
 112a5a4:	d2801f02 	mov	x2, #0xf8                  	// #248
{
 112a5a8:	a90363f7 	stp	x23, x24, [sp, #48]
 112a5ac:	aa0303f7 	mov	x23, x3
 112a5b0:	aa0503f8 	mov	x24, x5
 112a5b4:	f90023f9 	str	x25, [sp, #64]
 112a5b8:	aa0103f9 	mov	x25, x1
	ecc_key ltc_key = { };
 112a5bc:	52800001 	mov	w1, #0x0                   	// #0
	int ltc_stat = 0;
 112a5c0:	b9005fff 	str	wzr, [sp, #92]
	size_t key_size_bytes = 0;
 112a5c4:	f90033ff 	str	xzr, [sp, #96]
	ecc_key ltc_key = { };
 112a5c8:	940065c6 	bl	1143ce0 <memset>
	if (algo == 0)
 112a5cc:	34000573 	cbz	w19, 112a678 <_ltc_ecc_verify+0xf8>
	res = ecc_populate_ltc_public_key(&ltc_key, key, algo, &key_size_bytes);
 112a5d0:	2a1303e2 	mov	w2, w19
 112a5d4:	910183e3 	add	x3, sp, #0x60
 112a5d8:	aa1903e1 	mov	x1, x25
 112a5dc:	aa1403e0 	mov	x0, x20
 112a5e0:	97ffff7a 	bl	112a3c8 <ecc_populate_ltc_public_key>
 112a5e4:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS)
 112a5e8:	350002a0 	cbnz	w0, 112a63c <_ltc_ecc_verify+0xbc>
	if ((key_size_bytes * 2) != sig_len) {
 112a5ec:	f94033e0 	ldr	x0, [sp, #96]
 112a5f0:	d37ff801 	lsl	x1, x0, #1
 112a5f4:	eb00071f 	cmp	x24, x0, lsl #1
 112a5f8:	54000341 	b.ne	112a660 <_ltc_ecc_verify+0xe0>  // b.any
	ltc_res = ecc_verify_hash_rfc7518(sig, sig_len, msg, msg_len, &ltc_stat,
 112a5fc:	aa1403e6 	mov	x6, x20
 112a600:	910173e5 	add	x5, sp, #0x5c
 112a604:	aa1703e3 	mov	x3, x23
 112a608:	aa1603e2 	mov	x2, x22
 112a60c:	aa1503e0 	mov	x0, x21
 112a610:	52800024 	mov	w4, #0x1                   	// #1
 112a614:	94002e99 	bl	1136078 <ecc_verify_hash_ex>
	switch (ltc_res) {
 112a618:	71001c1f 	cmp	w0, #0x7
 112a61c:	54000260 	b.eq	112a668 <_ltc_ecc_verify+0xe8>  // b.none
 112a620:	7100581f 	cmp	w0, #0x16
 112a624:	54000220 	b.eq	112a668 <_ltc_ecc_verify+0xe8>  // b.none
 112a628:	35000240 	cbnz	w0, 112a670 <_ltc_ecc_verify+0xf0>
			return TEE_ERROR_SIGNATURE_INVALID;
 112a62c:	b9405fe0 	ldr	w0, [sp, #92]
 112a630:	1299f1b3 	mov	w19, #0xffff3072            	// #-53134
 112a634:	7100041f 	cmp	w0, #0x1
 112a638:	1a9303f3 	csel	w19, wzr, w19, eq  // eq = none
	ecc_free(&ltc_key);
 112a63c:	aa1403e0 	mov	x0, x20
 112a640:	94002b9f 	bl	11354bc <ecc_free>
}
 112a644:	2a1303e0 	mov	w0, w19
 112a648:	a94153f3 	ldp	x19, x20, [sp, #16]
 112a64c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 112a650:	a94363f7 	ldp	x23, x24, [sp, #48]
 112a654:	f94023f9 	ldr	x25, [sp, #64]
 112a658:	a8d67bfd 	ldp	x29, x30, [sp], #352
 112a65c:	d65f03c0 	ret
		res = TEE_ERROR_BAD_PARAMETERS;
 112a660:	129fff33 	mov	w19, #0xffff0006            	// #-65530
 112a664:	17fffff6 	b	112a63c <_ltc_ecc_verify+0xbc>
		return TEE_ERROR_SIGNATURE_INVALID;
 112a668:	1299f1b3 	mov	w19, #0xffff3072            	// #-53134
 112a66c:	17fffff4 	b	112a63c <_ltc_ecc_verify+0xbc>
	switch (ltc_res) {
 112a670:	52bffff3 	mov	w19, #0xffff0000            	// #-65536
 112a674:	17fffff2 	b	112a63c <_ltc_ecc_verify+0xbc>
		return TEE_ERROR_BAD_PARAMETERS;
 112a678:	129fff33 	mov	w19, #0xffff0006            	// #-65530
 112a67c:	17fffff2 	b	112a644 <_ltc_ecc_verify+0xc4>

000000000112a680 <crypto_asym_alloc_ecc_keypair>:
};

TEE_Result crypto_asym_alloc_ecc_keypair(struct ecc_keypair *s,
					 uint32_t key_type,
					 size_t key_size_bits __unused)
{
 112a680:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	memset(s, 0, sizeof(*s));
 112a684:	d2800502 	mov	x2, #0x28                  	// #40
{
 112a688:	910003fd 	mov	x29, sp
 112a68c:	a90153f3 	stp	x19, x20, [sp, #16]
 112a690:	2a0103f4 	mov	w20, w1
 112a694:	aa0003f3 	mov	x19, x0
	memset(s, 0, sizeof(*s));
 112a698:	52800001 	mov	w1, #0x0                   	// #0
 112a69c:	94006591 	bl	1143ce0 <memset>

	switch (key_type) {
 112a6a0:	529ff7e1 	mov	w1, #0xffbf                	// #65471
 112a6a4:	72abdfe1 	movk	w1, #0x5eff, lsl #16
 112a6a8:	0b010281 	add	w1, w20, w1
 112a6ac:	7100183f 	cmp	w1, #0x6
 112a6b0:	54000548 	b.hi	112a758 <crypto_asym_alloc_ecc_keypair+0xd8>  // b.pmore
 112a6b4:	90000120 	adrp	x0, 114e000 <ldelf_data+0x8000>
 112a6b8:	91246000 	add	x0, x0, #0x918
 112a6bc:	38614800 	ldrb	w0, [x0, w1, uxtw]
 112a6c0:	10000061 	adr	x1, 112a6cc <crypto_asym_alloc_ecc_keypair+0x4c>
 112a6c4:	8b208820 	add	x0, x1, w0, sxtb #2
 112a6c8:	d61f0000 	br	x0
	case TEE_TYPE_ECDSA_KEYPAIR:
	case TEE_TYPE_ECDH_KEYPAIR:
		s->ops = &ecc_keypair_ops;
 112a6cc:	d0000180 	adrp	x0, 115c000 <ltc_ctr_ops+0x20>
 112a6d0:	9101c000 	add	x0, x0, #0x70
		break;
	case TEE_TYPE_SM2_KEP_KEYPAIR:
		if (!IS_ENABLED(_CFG_CORE_LTC_SM2_KEP))
			return TEE_ERROR_NOT_IMPLEMENTED;

		s->ops = &sm2_kep_keypair_ops;
 112a6d4:	f9001260 	str	x0, [x19, #32]
		break;
	default:
		return TEE_ERROR_NOT_IMPLEMENTED;
	}

	if (!bn_alloc_max(&s->d))
 112a6d8:	aa1303e0 	mov	x0, x19
 112a6dc:	97fffeaf 	bl	112a198 <bn_alloc_max>
 112a6e0:	72001c1f 	tst	w0, #0xff
 112a6e4:	54000261 	b.ne	112a730 <crypto_asym_alloc_ecc_keypair+0xb0>  // b.any
	return TEE_SUCCESS;

err:
	s->ops = NULL;

	crypto_bignum_free(s->d);
 112a6e8:	f9400260 	ldr	x0, [x19]
	s->ops = NULL;
 112a6ec:	f900127f 	str	xzr, [x19, #32]
	crypto_bignum_free(s->d);
 112a6f0:	94000ee4 	bl	112e280 <crypto_bignum_free>
	crypto_bignum_free(s->x);
 112a6f4:	f9400660 	ldr	x0, [x19, #8]
 112a6f8:	94000ee2 	bl	112e280 <crypto_bignum_free>

	return TEE_ERROR_OUT_OF_MEMORY;
 112a6fc:	129ffe60 	mov	w0, #0xffff000c            	// #-65524
}
 112a700:	a94153f3 	ldp	x19, x20, [sp, #16]
 112a704:	a8c27bfd 	ldp	x29, x30, [sp], #32
 112a708:	d65f03c0 	ret
		s->ops = &sm2_dsa_keypair_ops;
 112a70c:	d0000180 	adrp	x0, 115c000 <ltc_ctr_ops+0x20>
 112a710:	91038000 	add	x0, x0, #0xe0
 112a714:	17fffff0 	b	112a6d4 <crypto_asym_alloc_ecc_keypair+0x54>
		s->ops = &sm2_pke_keypair_ops;
 112a718:	d0000180 	adrp	x0, 115c000 <ltc_ctr_ops+0x20>
 112a71c:	91046000 	add	x0, x0, #0x118
 112a720:	17ffffed 	b	112a6d4 <crypto_asym_alloc_ecc_keypair+0x54>
		s->ops = &sm2_kep_keypair_ops;
 112a724:	d0000180 	adrp	x0, 115c000 <ltc_ctr_ops+0x20>
 112a728:	9102a000 	add	x0, x0, #0xa8
 112a72c:	17ffffea 	b	112a6d4 <crypto_asym_alloc_ecc_keypair+0x54>
	if (!bn_alloc_max(&s->x))
 112a730:	91002260 	add	x0, x19, #0x8
 112a734:	97fffe99 	bl	112a198 <bn_alloc_max>
 112a738:	72001c1f 	tst	w0, #0xff
 112a73c:	54fffd60 	b.eq	112a6e8 <crypto_asym_alloc_ecc_keypair+0x68>  // b.none
	if (!bn_alloc_max(&s->y))
 112a740:	91004260 	add	x0, x19, #0x10
 112a744:	97fffe95 	bl	112a198 <bn_alloc_max>
 112a748:	72001c1f 	tst	w0, #0xff
 112a74c:	54fffce0 	b.eq	112a6e8 <crypto_asym_alloc_ecc_keypair+0x68>  // b.none
	return TEE_SUCCESS;
 112a750:	52800000 	mov	w0, #0x0                   	// #0
 112a754:	17ffffeb 	b	112a700 <crypto_asym_alloc_ecc_keypair+0x80>
	memset(s, 0, sizeof(*s));
 112a758:	129ffec0 	mov	w0, #0xffff0009            	// #-65527
 112a75c:	17ffffe9 	b	112a700 <crypto_asym_alloc_ecc_keypair+0x80>

000000000112a760 <crypto_asym_alloc_ecc_public_key>:

TEE_Result crypto_asym_alloc_ecc_public_key(struct ecc_public_key *s,
					    uint32_t key_type,
					    size_t key_size_bits __unused)
{
 112a760:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	memset(s, 0, sizeof(*s));
 112a764:	d2800402 	mov	x2, #0x20                  	// #32
{
 112a768:	910003fd 	mov	x29, sp
 112a76c:	a90153f3 	stp	x19, x20, [sp, #16]
 112a770:	2a0103f4 	mov	w20, w1
 112a774:	aa0003f3 	mov	x19, x0
	memset(s, 0, sizeof(*s));
 112a778:	52800001 	mov	w1, #0x0                   	// #0
 112a77c:	94006559 	bl	1143ce0 <memset>

	switch (key_type) {
 112a780:	529ff7e1 	mov	w1, #0xffbf                	// #65471
 112a784:	72abffe1 	movk	w1, #0x5fff, lsl #16
 112a788:	0b010281 	add	w1, w20, w1
 112a78c:	7100183f 	cmp	w1, #0x6
 112a790:	54000488 	b.hi	112a820 <crypto_asym_alloc_ecc_public_key+0xc0>  // b.pmore
 112a794:	90000120 	adrp	x0, 114e000 <ldelf_data+0x8000>
 112a798:	91248000 	add	x0, x0, #0x920
 112a79c:	38614800 	ldrb	w0, [x0, w1, uxtw]
 112a7a0:	10000061 	adr	x1, 112a7ac <crypto_asym_alloc_ecc_public_key+0x4c>
 112a7a4:	8b208820 	add	x0, x1, w0, sxtb #2
 112a7a8:	d61f0000 	br	x0
	case TEE_TYPE_ECDSA_PUBLIC_KEY:
	case TEE_TYPE_ECDH_PUBLIC_KEY:
		s->ops = &ecc_public_key_ops;
 112a7ac:	d0000180 	adrp	x0, 115c000 <ltc_ctr_ops+0x20>
 112a7b0:	91024000 	add	x0, x0, #0x90
		break;
	case TEE_TYPE_SM2_KEP_PUBLIC_KEY:
		if (!IS_ENABLED(_CFG_CORE_LTC_SM2_KEP))
			return TEE_ERROR_NOT_IMPLEMENTED;

		s->ops = &sm2_kep_public_key_ops;
 112a7b4:	f9000e60 	str	x0, [x19, #24]
		break;
	default:
		return TEE_ERROR_NOT_IMPLEMENTED;
	}

	if (!bn_alloc_max(&s->x))
 112a7b8:	aa1303e0 	mov	x0, x19
 112a7bc:	97fffe77 	bl	112a198 <bn_alloc_max>
 112a7c0:	72001c1f 	tst	w0, #0xff
 112a7c4:	54000221 	b.ne	112a808 <crypto_asym_alloc_ecc_public_key+0xa8>  // b.any
	return TEE_SUCCESS;

err:
	s->ops = NULL;

	crypto_bignum_free(s->x);
 112a7c8:	f9400260 	ldr	x0, [x19]
	s->ops = NULL;
 112a7cc:	f9000e7f 	str	xzr, [x19, #24]
	crypto_bignum_free(s->x);
 112a7d0:	94000eac 	bl	112e280 <crypto_bignum_free>

	return TEE_ERROR_OUT_OF_MEMORY;
 112a7d4:	129ffe60 	mov	w0, #0xffff000c            	// #-65524
}
 112a7d8:	a94153f3 	ldp	x19, x20, [sp, #16]
 112a7dc:	a8c27bfd 	ldp	x29, x30, [sp], #32
 112a7e0:	d65f03c0 	ret
		s->ops = &sm2_dsa_public_key_ops;
 112a7e4:	d0000180 	adrp	x0, 115c000 <ltc_ctr_ops+0x20>
 112a7e8:	91040000 	add	x0, x0, #0x100
 112a7ec:	17fffff2 	b	112a7b4 <crypto_asym_alloc_ecc_public_key+0x54>
		s->ops = &sm2_pke_public_key_ops;
 112a7f0:	d0000180 	adrp	x0, 115c000 <ltc_ctr_ops+0x20>
 112a7f4:	9104e000 	add	x0, x0, #0x138
 112a7f8:	17ffffef 	b	112a7b4 <crypto_asym_alloc_ecc_public_key+0x54>
		s->ops = &sm2_kep_public_key_ops;
 112a7fc:	d0000180 	adrp	x0, 115c000 <ltc_ctr_ops+0x20>
 112a800:	91032000 	add	x0, x0, #0xc8
 112a804:	17ffffec 	b	112a7b4 <crypto_asym_alloc_ecc_public_key+0x54>
	if (!bn_alloc_max(&s->y))
 112a808:	91002260 	add	x0, x19, #0x8
 112a80c:	97fffe63 	bl	112a198 <bn_alloc_max>
 112a810:	72001c1f 	tst	w0, #0xff
 112a814:	54fffda0 	b.eq	112a7c8 <crypto_asym_alloc_ecc_public_key+0x68>  // b.none
	return TEE_SUCCESS;
 112a818:	52800000 	mov	w0, #0x0                   	// #0
 112a81c:	17ffffef 	b	112a7d8 <crypto_asym_alloc_ecc_public_key+0x78>
	memset(s, 0, sizeof(*s));
 112a820:	129ffec0 	mov	w0, #0xffff0009            	// #-65527
 112a824:	17ffffed 	b	112a7d8 <crypto_asym_alloc_ecc_public_key+0x78>

000000000112a828 <bn_alloc_max>:
{
 112a828:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 112a82c:	910003fd 	mov	x29, sp
 112a830:	f9000bf3 	str	x19, [sp, #16]
 112a834:	aa0003f3 	mov	x19, x0
	*s = crypto_bignum_allocate(_CFG_CORE_LTC_BIGNUM_MAX_BITS);
 112a838:	d2820000 	mov	x0, #0x1000                	// #4096
 112a83c:	94000e7b 	bl	112e228 <crypto_bignum_allocate>
	return *s;
 112a840:	f100001f 	cmp	x0, #0x0
	*s = crypto_bignum_allocate(_CFG_CORE_LTC_BIGNUM_MAX_BITS);
 112a844:	f9000260 	str	x0, [x19]
}
 112a848:	1a9f07e0 	cset	w0, ne  // ne = any
 112a84c:	f9400bf3 	ldr	x19, [sp, #16]
 112a850:	a8c27bfd 	ldp	x29, x30, [sp], #32
 112a854:	d65f03c0 	ret

000000000112a858 <rsadorep>:
	return res;
}

static TEE_Result rsadorep(rsa_key *ltc_key, const uint8_t *src,
			   size_t src_len, uint8_t *dst, size_t *dst_len)
{
 112a858:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 112a85c:	910003fd 	mov	x29, sp
 112a860:	a90153f3 	stp	x19, x20, [sp, #16]
 112a864:	aa0403f4 	mov	x20, x4
 112a868:	a9025bf5 	stp	x21, x22, [sp, #32]
 112a86c:	aa0103f6 	mov	x22, x1
 112a870:	aa0303f5 	mov	x21, x3
 112a874:	a90363f7 	stp	x23, x24, [sp, #48]
 112a878:	aa0003f8 	mov	x24, x0
 112a87c:	aa0203f7 	mov	x23, x2
	/*
	 * Use a temporary buffer since we don't know exactly how large the
	 * required size of the out buffer without doing a partial decrypt.
	 * We know the upper bound though.
	 */
	blen = _CFG_CORE_LTC_BIGNUM_MAX_BITS / sizeof(uint8_t);
 112a880:	d2820000 	mov	x0, #0x1000                	// #4096
 112a884:	f90027e0 	str	x0, [sp, #72]
	buf = malloc(blen);
 112a888:	940062f4 	bl	1143458 <malloc>
	if (!buf) {
 112a88c:	b40007a0 	cbz	x0, 112a980 <rsadorep+0x128>
		res = TEE_ERROR_OUT_OF_MEMORY;
		goto out;
	}

	ltc_res = rsa_exptmod(src, src_len, buf, &blen, ltc_key->type,
 112a890:	b9400304 	ldr	w4, [x24]
 112a894:	aa1803e5 	mov	x5, x24
 112a898:	aa0003e2 	mov	x2, x0
 112a89c:	aa0003f3 	mov	x19, x0
 112a8a0:	910123e3 	add	x3, sp, #0x48
 112a8a4:	aa1703e1 	mov	x1, x23
 112a8a8:	aa1603e0 	mov	x0, x22
 112a8ac:	940026af 	bl	1134368 <rsa_exptmod>
 112a8b0:	2a0003e5 	mov	w5, w0
			      ltc_key);
	switch (ltc_res) {
 112a8b4:	7100581f 	cmp	w0, #0x16
 112a8b8:	540003c8 	b.hi	112a930 <rsadorep+0xd8>  // b.pmore
 112a8bc:	d2800022 	mov	x2, #0x1                   	// #1
 112a8c0:	d2901001 	mov	x1, #0x8080                	// #32896
 112a8c4:	9ac02040 	lsl	x0, x2, x0
 112a8c8:	f2a00881 	movk	x1, #0x44, lsl #16
 112a8cc:	ea010001 	ands	x1, x0, x1
 112a8d0:	540001a1 	b.ne	112a904 <rsadorep+0xac>  // b.any
 112a8d4:	360002e0 	tbz	w0, #0, 112a930 <rsadorep+0xd8>
		goto out;
	}

	/* Remove the zero-padding (leave one zero if buff is all zeroes) */
	offset = 0;
	while ((offset < blen - 1) && (buf[offset] == 0))
 112a8d8:	f94027e2 	ldr	x2, [sp, #72]
 112a8dc:	d1000443 	sub	x3, x2, #0x1
 112a8e0:	eb01007f 	cmp	x3, x1
 112a8e4:	540003a8 	b.hi	112a958 <rsadorep+0x100>  // b.pmore
		offset++;

	if (*dst_len < blen - offset) {
 112a8e8:	f9400280 	ldr	x0, [x20]
 112a8ec:	cb010042 	sub	x2, x2, x1
 112a8f0:	eb02001f 	cmp	x0, x2
 112a8f4:	540003a2 	b.cs	112a968 <rsadorep+0x110>  // b.hs, b.nlast
		*dst_len = blen - offset;
 112a8f8:	f9000282 	str	x2, [x20]
		res = TEE_ERROR_SHORT_BUFFER;
 112a8fc:	129ffdf4 	mov	w20, #0xffff0010            	// #-65520
		goto out;
 112a900:	14000009 	b	112a924 <rsadorep+0xcc>
		res = TEE_ERROR_BAD_PARAMETERS;
 112a904:	129fff34 	mov	w20, #0xffff0006            	// #-65530
		EMSG("rsa_exptmod() returned %d", ltc_res);
 112a908:	2a0203e3 	mov	w3, w2
 112a90c:	90000164 	adrp	x4, 1156000 <ta_pub_key_modulus+0x7>
 112a910:	52801a81 	mov	w1, #0xd4                  	// #212
 112a914:	9114cc84 	add	x4, x4, #0x533
 112a918:	90000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 112a91c:	91177c00 	add	x0, x0, #0x5df
 112a920:	94006909 	bl	1144d44 <trace_printf>
	*dst_len = blen - offset;
	memcpy(dst, (char *)buf + offset, *dst_len);

out:
	if (buf)
		free(buf);
 112a924:	aa1303e0 	mov	x0, x19
 112a928:	9400632e 	bl	11435e0 <free>
 112a92c:	14000016 	b	112a984 <rsadorep+0x12c>
		EMSG("rsa_exptmod() returned %d", ltc_res);
 112a930:	90000164 	adrp	x4, 1156000 <ta_pub_key_modulus+0x7>
 112a934:	52800023 	mov	w3, #0x1                   	// #1
 112a938:	9114cc84 	add	x4, x4, #0x533
 112a93c:	52800022 	mov	w2, #0x1                   	// #1
 112a940:	52801b61 	mov	w1, #0xdb                  	// #219
 112a944:	90000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
		res = TEE_ERROR_GENERIC;
 112a948:	52bffff4 	mov	w20, #0xffff0000            	// #-65536
		EMSG("rsa_exptmod() returned %d", ltc_res);
 112a94c:	91177c00 	add	x0, x0, #0x5df
 112a950:	940068fd 	bl	1144d44 <trace_printf>
		goto out;
 112a954:	17fffff4 	b	112a924 <rsadorep+0xcc>
	while ((offset < blen - 1) && (buf[offset] == 0))
 112a958:	38616a60 	ldrb	w0, [x19, x1]
 112a95c:	35fffc60 	cbnz	w0, 112a8e8 <rsadorep+0x90>
		offset++;
 112a960:	91000421 	add	x1, x1, #0x1
 112a964:	17ffffdf 	b	112a8e0 <rsadorep+0x88>
	*dst_len = blen - offset;
 112a968:	f9000282 	str	x2, [x20]
	memcpy(dst, (char *)buf + offset, *dst_len);
 112a96c:	8b010261 	add	x1, x19, x1
 112a970:	aa1503e0 	mov	x0, x21
	res = TEE_SUCCESS;
 112a974:	52800014 	mov	w20, #0x0                   	// #0
	memcpy(dst, (char *)buf + offset, *dst_len);
 112a978:	97ff6286 	bl	1103390 <memcpy>
 112a97c:	17ffffea 	b	112a924 <rsadorep+0xcc>
		res = TEE_ERROR_OUT_OF_MEMORY;
 112a980:	129ffe74 	mov	w20, #0xffff000c            	// #-65524

	return res;
}
 112a984:	2a1403e0 	mov	w0, w20
 112a988:	a94153f3 	ldp	x19, x20, [sp, #16]
 112a98c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 112a990:	a94363f7 	ldp	x23, x24, [sp, #48]
 112a994:	a8c57bfd 	ldp	x29, x30, [sp], #80
 112a998:	d65f03c0 	ret

000000000112a99c <tee_algo_to_ltc_hashindex>:
{
 112a99c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 112a9a0:	910003fd 	mov	x29, sp
 112a9a4:	f9000bf3 	str	x19, [sp, #16]
 112a9a8:	aa0103f3 	mov	x19, x1
	switch (algo) {
 112a9ac:	52850601 	mov	w1, #0x2830                	// #10288
 112a9b0:	72ae0001 	movk	w1, #0x7000, lsl #16
 112a9b4:	6b01001f 	cmp	w0, w1
 112a9b8:	54000820 	b.eq	112aabc <tee_algo_to_ltc_hashindex+0x120>  // b.none
 112a9bc:	54000508 	b.hi	112aa5c <tee_algo_to_ltc_hashindex+0xc0>  // b.pmore
 112a9c0:	52804601 	mov	w1, #0x230                 	// #560
 112a9c4:	72ac0a21 	movk	w1, #0x6051, lsl #16
 112a9c8:	6b01001f 	cmp	w0, w1
 112a9cc:	54000a20 	b.eq	112ab10 <tee_algo_to_ltc_hashindex+0x174>  // b.none
 112a9d0:	52804601 	mov	w1, #0x230                 	// #560
 112a9d4:	540002e8 	b.hi	112aa30 <tee_algo_to_ltc_hashindex+0x94>  // b.pmore
 112a9d8:	72ac0421 	movk	w1, #0x6021, lsl #16
 112a9dc:	6b01001f 	cmp	w0, w1
 112a9e0:	540006e0 	b.eq	112aabc <tee_algo_to_ltc_hashindex+0x120>  // b.none
 112a9e4:	54000128 	b.hi	112aa08 <tee_algo_to_ltc_hashindex+0x6c>  // b.pmore
 112a9e8:	52802601 	mov	w1, #0x130                 	// #304
 112a9ec:	72ac0001 	movk	w1, #0x6000, lsl #16
 112a9f0:	6b01001f 	cmp	w0, w1
 112a9f4:	540002c1 	b.ne	112aa4c <tee_algo_to_ltc_hashindex+0xb0>  // b.any
		*ltc_hashindex = -1;
 112a9f8:	12800000 	mov	w0, #0xffffffff            	// #-1
 112a9fc:	b9000260 	str	w0, [x19]
		return TEE_SUCCESS;
 112aa00:	52800000 	mov	w0, #0x0                   	// #0
 112aa04:	14000013 	b	112aa50 <tee_algo_to_ltc_hashindex+0xb4>
	switch (algo) {
 112aa08:	52804601 	mov	w1, #0x230                 	// #560
 112aa0c:	72ac0621 	movk	w1, #0x6031, lsl #16
 112aa10:	6b01001f 	cmp	w0, w1
 112aa14:	54000900 	b.eq	112ab34 <tee_algo_to_ltc_hashindex+0x198>  // b.none
 112aa18:	11440021 	add	w1, w1, #0x100, lsl #12
 112aa1c:	6b01001f 	cmp	w0, w1
 112aa20:	54000161 	b.ne	112aa4c <tee_algo_to_ltc_hashindex+0xb0>  // b.any
		*ltc_hashindex = find_hash("sha256");
 112aa24:	90000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 112aa28:	91082000 	add	x0, x0, #0x208
 112aa2c:	14000026 	b	112aac4 <tee_algo_to_ltc_hashindex+0x128>
	switch (algo) {
 112aa30:	72ac0c21 	movk	w1, #0x6061, lsl #16
 112aa34:	6b01001f 	cmp	w0, w1
 112aa38:	54000840 	b.eq	112ab40 <tee_algo_to_ltc_hashindex+0x1a4>  // b.none
 112aa3c:	52830601 	mov	w1, #0x1830                	// #6192
 112aa40:	72ae0001 	movk	w1, #0x7000, lsl #16
 112aa44:	6b01001f 	cmp	w0, w1
 112aa48:	54000700 	b.eq	112ab28 <tee_algo_to_ltc_hashindex+0x18c>  // b.none
 112aa4c:	129fff20 	mov	w0, #0xffff0006            	// #-65530
}
 112aa50:	f9400bf3 	ldr	x19, [sp, #16]
 112aa54:	a8c27bfd 	ldp	x29, x30, [sp], #32
 112aa58:	d65f03c0 	ret
	switch (algo) {
 112aa5c:	52872601 	mov	w1, #0x3930                	// #14640
 112aa60:	72ae0621 	movk	w1, #0x7031, lsl #16
 112aa64:	6b01001f 	cmp	w0, w1
 112aa68:	54000660 	b.eq	112ab34 <tee_algo_to_ltc_hashindex+0x198>  // b.none
 112aa6c:	540003a8 	b.hi	112aae0 <tee_algo_to_ltc_hashindex+0x144>  // b.pmore
 112aa70:	528b0601 	mov	w1, #0x5830                	// #22576
 112aa74:	72ae0001 	movk	w1, #0x7000, lsl #16
 112aa78:	6b01001f 	cmp	w0, w1
 112aa7c:	540004a0 	b.eq	112ab10 <tee_algo_to_ltc_hashindex+0x174>  // b.none
 112aa80:	540000e8 	b.hi	112aa9c <tee_algo_to_ltc_hashindex+0x100>  // b.pmore
 112aa84:	52870601 	mov	w1, #0x3830                	// #14384
 112aa88:	72ae0001 	movk	w1, #0x7000, lsl #16
 112aa8c:	6b01001f 	cmp	w0, w1
 112aa90:	54000520 	b.eq	112ab34 <tee_algo_to_ltc_hashindex+0x198>  // b.none
 112aa94:	11400421 	add	w1, w1, #0x1, lsl #12
 112aa98:	17ffffe1 	b	112aa1c <tee_algo_to_ltc_hashindex+0x80>
 112aa9c:	528d0601 	mov	w1, #0x6830                	// #26672
 112aaa0:	72ae0001 	movk	w1, #0x7000, lsl #16
 112aaa4:	6b01001f 	cmp	w0, w1
 112aaa8:	540004c0 	b.eq	112ab40 <tee_algo_to_ltc_hashindex+0x1a4>  // b.none
 112aaac:	52852601 	mov	w1, #0x2930                	// #10544
 112aab0:	72ae0421 	movk	w1, #0x7021, lsl #16
 112aab4:	6b01001f 	cmp	w0, w1
 112aab8:	54fffca1 	b.ne	112aa4c <tee_algo_to_ltc_hashindex+0xb0>  // b.any
		*ltc_hashindex = find_hash("sha1");
 112aabc:	90000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 112aac0:	9107f000 	add	x0, x0, #0x1fc
		*ltc_hashindex = find_hash("sha512");
 112aac4:	94001ea2 	bl	113254c <find_hash>
 112aac8:	b9000260 	str	w0, [x19]
	if (*ltc_hashindex < 0)
 112aacc:	b9400260 	ldr	w0, [x19]
		return TEE_SUCCESS;
 112aad0:	7100001f 	cmp	w0, #0x0
 112aad4:	129ffea0 	mov	w0, #0xffff000a            	// #-65526
 112aad8:	1a9fb000 	csel	w0, w0, wzr, lt  // lt = tstop
 112aadc:	17ffffdd 	b	112aa50 <tee_algo_to_ltc_hashindex+0xb4>
	switch (algo) {
 112aae0:	528d2601 	mov	w1, #0x6930                	// #26928
 112aae4:	72ae0c21 	movk	w1, #0x7061, lsl #16
 112aae8:	6b01001f 	cmp	w0, w1
 112aaec:	540002a0 	b.eq	112ab40 <tee_algo_to_ltc_hashindex+0x1a4>  // b.none
 112aaf0:	54000168 	b.hi	112ab1c <tee_algo_to_ltc_hashindex+0x180>  // b.pmore
 112aaf4:	52892601 	mov	w1, #0x4930                	// #18736
 112aaf8:	72ae0821 	movk	w1, #0x7041, lsl #16
 112aafc:	6b01001f 	cmp	w0, w1
 112ab00:	54fff920 	b.eq	112aa24 <tee_algo_to_ltc_hashindex+0x88>  // b.none
 112ab04:	11440421 	add	w1, w1, #0x101, lsl #12
 112ab08:	6b01001f 	cmp	w0, w1
 112ab0c:	54fffa01 	b.ne	112aa4c <tee_algo_to_ltc_hashindex+0xb0>  // b.any
		*ltc_hashindex = find_hash("sha384");
 112ab10:	90000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 112ab14:	91083c00 	add	x0, x0, #0x20f
 112ab18:	17ffffeb 	b	112aac4 <tee_algo_to_ltc_hashindex+0x128>
	switch (algo) {
 112ab1c:	52810601 	mov	w1, #0x830                 	// #2096
 112ab20:	72be0001 	movk	w1, #0xf000, lsl #16
 112ab24:	17ffffb3 	b	112a9f0 <tee_algo_to_ltc_hashindex+0x54>
		*ltc_hashindex = find_hash("md5");
 112ab28:	90000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 112ab2c:	9107e000 	add	x0, x0, #0x1f8
 112ab30:	17ffffe5 	b	112aac4 <tee_algo_to_ltc_hashindex+0x128>
		*ltc_hashindex = find_hash("sha224");
 112ab34:	90000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 112ab38:	91080400 	add	x0, x0, #0x201
 112ab3c:	17ffffe2 	b	112aac4 <tee_algo_to_ltc_hashindex+0x128>
		*ltc_hashindex = find_hash("sha512");
 112ab40:	90000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 112ab44:	91085800 	add	x0, x0, #0x216
 112ab48:	17ffffdf 	b	112aac4 <tee_algo_to_ltc_hashindex+0x128>

000000000112ab4c <crypto_acipher_alloc_rsa_public_key>:
{
 112ab4c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	memset(s, 0, sizeof(*s));
 112ab50:	d2800202 	mov	x2, #0x10                  	// #16
 112ab54:	52800001 	mov	w1, #0x0                   	// #0
{
 112ab58:	910003fd 	mov	x29, sp
 112ab5c:	f9000bf3 	str	x19, [sp, #16]
 112ab60:	aa0003f3 	mov	x19, x0
	memset(s, 0, sizeof(*s));
 112ab64:	9400645f 	bl	1143ce0 <memset>
	if (!bn_alloc_max(&s->e))
 112ab68:	aa1303e0 	mov	x0, x19
 112ab6c:	97ffff2f 	bl	112a828 <bn_alloc_max>
 112ab70:	72001c1f 	tst	w0, #0xff
 112ab74:	54000120 	b.eq	112ab98 <crypto_acipher_alloc_rsa_public_key+0x4c>  // b.none
	if (!bn_alloc_max(&s->n))
 112ab78:	91002260 	add	x0, x19, #0x8
 112ab7c:	97ffff2b 	bl	112a828 <bn_alloc_max>
 112ab80:	2a0003e1 	mov	w1, w0
	return TEE_SUCCESS;
 112ab84:	52800000 	mov	w0, #0x0                   	// #0
	if (!bn_alloc_max(&s->n))
 112ab88:	72001c3f 	tst	w1, #0xff
 112ab8c:	54000081 	b.ne	112ab9c <crypto_acipher_alloc_rsa_public_key+0x50>  // b.any
	crypto_bignum_free(s->e);
 112ab90:	f9400260 	ldr	x0, [x19]
 112ab94:	94000dbb 	bl	112e280 <crypto_bignum_free>
		return TEE_ERROR_OUT_OF_MEMORY;
 112ab98:	129ffe60 	mov	w0, #0xffff000c            	// #-65524
}
 112ab9c:	f9400bf3 	ldr	x19, [sp, #16]
 112aba0:	a8c27bfd 	ldp	x29, x30, [sp], #32
 112aba4:	d65f03c0 	ret

000000000112aba8 <crypto_acipher_free_rsa_public_key>:
	if (!s)
 112aba8:	b4000160 	cbz	x0, 112abd4 <crypto_acipher_free_rsa_public_key+0x2c>
{
 112abac:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 112abb0:	910003fd 	mov	x29, sp
 112abb4:	f9000bf3 	str	x19, [sp, #16]
 112abb8:	aa0003f3 	mov	x19, x0
	crypto_bignum_free(s->n);
 112abbc:	f9400400 	ldr	x0, [x0, #8]
 112abc0:	94000db0 	bl	112e280 <crypto_bignum_free>
	crypto_bignum_free(s->e);
 112abc4:	f9400260 	ldr	x0, [x19]
}
 112abc8:	f9400bf3 	ldr	x19, [sp, #16]
 112abcc:	a8c27bfd 	ldp	x29, x30, [sp], #32
	crypto_bignum_free(s->e);
 112abd0:	14000dac 	b	112e280 <crypto_bignum_free>
 112abd4:	d65f03c0 	ret

000000000112abd8 <crypto_acipher_free_rsa_keypair>:
	if (!s)
 112abd8:	b40002e0 	cbz	x0, 112ac34 <crypto_acipher_free_rsa_keypair+0x5c>
{
 112abdc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 112abe0:	910003fd 	mov	x29, sp
 112abe4:	f9000bf3 	str	x19, [sp, #16]
 112abe8:	aa0003f3 	mov	x19, x0
	crypto_bignum_free(s->e);
 112abec:	f9400000 	ldr	x0, [x0]
 112abf0:	94000da4 	bl	112e280 <crypto_bignum_free>
	crypto_bignum_free(s->d);
 112abf4:	f9400660 	ldr	x0, [x19, #8]
 112abf8:	94000da2 	bl	112e280 <crypto_bignum_free>
	crypto_bignum_free(s->n);
 112abfc:	f9400a60 	ldr	x0, [x19, #16]
 112ac00:	94000da0 	bl	112e280 <crypto_bignum_free>
	crypto_bignum_free(s->p);
 112ac04:	f9400e60 	ldr	x0, [x19, #24]
 112ac08:	94000d9e 	bl	112e280 <crypto_bignum_free>
	crypto_bignum_free(s->q);
 112ac0c:	f9401260 	ldr	x0, [x19, #32]
 112ac10:	94000d9c 	bl	112e280 <crypto_bignum_free>
	crypto_bignum_free(s->qp);
 112ac14:	f9401660 	ldr	x0, [x19, #40]
 112ac18:	94000d9a 	bl	112e280 <crypto_bignum_free>
	crypto_bignum_free(s->dp);
 112ac1c:	f9401a60 	ldr	x0, [x19, #48]
 112ac20:	94000d98 	bl	112e280 <crypto_bignum_free>
	crypto_bignum_free(s->dq);
 112ac24:	f9401e60 	ldr	x0, [x19, #56]
}
 112ac28:	f9400bf3 	ldr	x19, [sp, #16]
 112ac2c:	a8c27bfd 	ldp	x29, x30, [sp], #32
	crypto_bignum_free(s->dq);
 112ac30:	14000d94 	b	112e280 <crypto_bignum_free>
 112ac34:	d65f03c0 	ret

000000000112ac38 <crypto_acipher_alloc_rsa_keypair>:
{
 112ac38:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	memset(s, 0, sizeof(*s));
 112ac3c:	d2800802 	mov	x2, #0x40                  	// #64
 112ac40:	52800001 	mov	w1, #0x0                   	// #0
{
 112ac44:	910003fd 	mov	x29, sp
 112ac48:	f9000bf3 	str	x19, [sp, #16]
 112ac4c:	aa0003f3 	mov	x19, x0
	memset(s, 0, sizeof(*s));
 112ac50:	94006424 	bl	1143ce0 <memset>
	if (!bn_alloc_max(&s->e))
 112ac54:	aa1303e0 	mov	x0, x19
 112ac58:	97fffef4 	bl	112a828 <bn_alloc_max>
 112ac5c:	72001c1f 	tst	w0, #0xff
 112ac60:	540000e0 	b.eq	112ac7c <crypto_acipher_alloc_rsa_keypair+0x44>  // b.none
	if (!bn_alloc_max(&s->d))
 112ac64:	91002260 	add	x0, x19, #0x8
 112ac68:	97fffef0 	bl	112a828 <bn_alloc_max>
 112ac6c:	72001c1f 	tst	w0, #0xff
 112ac70:	540000a1 	b.ne	112ac84 <crypto_acipher_alloc_rsa_keypair+0x4c>  // b.any
	crypto_acipher_free_rsa_keypair(s);
 112ac74:	aa1303e0 	mov	x0, x19
 112ac78:	97ffffd8 	bl	112abd8 <crypto_acipher_free_rsa_keypair>
		return TEE_ERROR_OUT_OF_MEMORY;
 112ac7c:	129ffe60 	mov	w0, #0xffff000c            	// #-65524
 112ac80:	1400001a 	b	112ace8 <crypto_acipher_alloc_rsa_keypair+0xb0>
	if (!bn_alloc_max(&s->n))
 112ac84:	91004260 	add	x0, x19, #0x10
 112ac88:	97fffee8 	bl	112a828 <bn_alloc_max>
 112ac8c:	72001c1f 	tst	w0, #0xff
 112ac90:	54ffff20 	b.eq	112ac74 <crypto_acipher_alloc_rsa_keypair+0x3c>  // b.none
	if (!bn_alloc_max(&s->p))
 112ac94:	91006260 	add	x0, x19, #0x18
 112ac98:	97fffee4 	bl	112a828 <bn_alloc_max>
 112ac9c:	72001c1f 	tst	w0, #0xff
 112aca0:	54fffea0 	b.eq	112ac74 <crypto_acipher_alloc_rsa_keypair+0x3c>  // b.none
	if (!bn_alloc_max(&s->q))
 112aca4:	91008260 	add	x0, x19, #0x20
 112aca8:	97fffee0 	bl	112a828 <bn_alloc_max>
 112acac:	72001c1f 	tst	w0, #0xff
 112acb0:	54fffe20 	b.eq	112ac74 <crypto_acipher_alloc_rsa_keypair+0x3c>  // b.none
	if (!bn_alloc_max(&s->qp))
 112acb4:	9100a260 	add	x0, x19, #0x28
 112acb8:	97fffedc 	bl	112a828 <bn_alloc_max>
 112acbc:	72001c1f 	tst	w0, #0xff
 112acc0:	54fffda0 	b.eq	112ac74 <crypto_acipher_alloc_rsa_keypair+0x3c>  // b.none
	if (!bn_alloc_max(&s->dp))
 112acc4:	9100c260 	add	x0, x19, #0x30
 112acc8:	97fffed8 	bl	112a828 <bn_alloc_max>
 112accc:	72001c1f 	tst	w0, #0xff
 112acd0:	54fffd20 	b.eq	112ac74 <crypto_acipher_alloc_rsa_keypair+0x3c>  // b.none
	if (!bn_alloc_max(&s->dq))
 112acd4:	9100e260 	add	x0, x19, #0x38
 112acd8:	97fffed4 	bl	112a828 <bn_alloc_max>
 112acdc:	72001c1f 	tst	w0, #0xff
 112ace0:	54fffca0 	b.eq	112ac74 <crypto_acipher_alloc_rsa_keypair+0x3c>  // b.none
	return TEE_SUCCESS;
 112ace4:	52800000 	mov	w0, #0x0                   	// #0
}
 112ace8:	f9400bf3 	ldr	x19, [sp, #16]
 112acec:	a8c27bfd 	ldp	x29, x30, [sp], #32
 112acf0:	d65f03c0 	ret

000000000112acf4 <crypto_acipher_gen_rsa_key>:
{
 112acf4:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
 112acf8:	910003fd 	mov	x29, sp
 112acfc:	a90153f3 	stp	x19, x20, [sp, #16]
	e = mp_get_int(key->e);
 112ad00:	90000193 	adrp	x19, 115a000 <__scattered_array_1phys_mem_map+0x8>
{
 112ad04:	aa0003f4 	mov	x20, x0
	e = mp_get_int(key->e);
 112ad08:	f941d673 	ldr	x19, [x19, #936]
{
 112ad0c:	a9025bf5 	stp	x21, x22, [sp, #32]
 112ad10:	aa0103f5 	mov	x21, x1
	e = mp_get_int(key->e);
 112ad14:	f9400000 	ldr	x0, [x0]
	ltc_res = rsa_make_key(NULL, find_prng("prng_crypto"), key_size / 8, e,
 112ad18:	910123f6 	add	x22, sp, #0x48
	e = mp_get_int(key->e);
 112ad1c:	f9402661 	ldr	x1, [x19, #72]
{
 112ad20:	f9001bf7 	str	x23, [sp, #48]
	e = mp_get_int(key->e);
 112ad24:	d63f0020 	blr	x1
 112ad28:	aa0003f7 	mov	x23, x0
	ltc_res = rsa_make_key(NULL, find_prng("prng_crypto"), key_size / 8, e,
 112ad2c:	90000160 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 112ad30:	9113d800 	add	x0, x0, #0x4f6
 112ad34:	94001e2b 	bl	11325e0 <find_prng>
 112ad38:	2a0003e1 	mov	w1, w0
 112ad3c:	aa1603e4 	mov	x4, x22
 112ad40:	aa1703e3 	mov	x3, x23
 112ad44:	d3438aa2 	ubfx	x2, x21, #3, #32
 112ad48:	d2800000 	mov	x0, #0x0                   	// #0
 112ad4c:	94002699 	bl	11347b0 <rsa_make_key>
	if (ltc_res != CRYPT_OK) {
 112ad50:	35000100 	cbnz	w0, 112ad70 <crypto_acipher_gen_rsa_key+0x7c>
	} else if ((size_t)mp_count_bits(ltc_tmp_key.N) != key_size) {
 112ad54:	f94033e0 	ldr	x0, [sp, #96]
 112ad58:	f9403a61 	ldr	x1, [x19, #112]
 112ad5c:	d63f0020 	blr	x1
 112ad60:	eb20c2bf 	cmp	x21, w0, sxtw
 112ad64:	540000a0 	b.eq	112ad78 <crypto_acipher_gen_rsa_key+0x84>  // b.none
		rsa_free(&ltc_tmp_key);
 112ad68:	aa1603e0 	mov	x0, x22
 112ad6c:	9400267f 	bl	1134768 <rsa_free>
		res = TEE_ERROR_BAD_PARAMETERS;
 112ad70:	129fff20 	mov	w0, #0xffff0006            	// #-65530
	return res;
 112ad74:	14000024 	b	112ae04 <crypto_acipher_gen_rsa_key+0x110>
		ltc_mp.copy(ltc_tmp_key.e,  key->e);
 112ad78:	f9400281 	ldr	x1, [x20]
 112ad7c:	f9401e62 	ldr	x2, [x19, #56]
 112ad80:	f9402be0 	ldr	x0, [sp, #80]
 112ad84:	d63f0040 	blr	x2
		ltc_mp.copy(ltc_tmp_key.d,  key->d);
 112ad88:	f9400681 	ldr	x1, [x20, #8]
 112ad8c:	f9401e62 	ldr	x2, [x19, #56]
 112ad90:	f9402fe0 	ldr	x0, [sp, #88]
 112ad94:	d63f0040 	blr	x2
		ltc_mp.copy(ltc_tmp_key.N,  key->n);
 112ad98:	f9400a81 	ldr	x1, [x20, #16]
 112ad9c:	f9401e62 	ldr	x2, [x19, #56]
 112ada0:	f94033e0 	ldr	x0, [sp, #96]
 112ada4:	d63f0040 	blr	x2
		ltc_mp.copy(ltc_tmp_key.p,  key->p);
 112ada8:	f9400e81 	ldr	x1, [x20, #24]
 112adac:	f9401e62 	ldr	x2, [x19, #56]
 112adb0:	f94037e0 	ldr	x0, [sp, #104]
 112adb4:	d63f0040 	blr	x2
		ltc_mp.copy(ltc_tmp_key.q,  key->q);
 112adb8:	f9401281 	ldr	x1, [x20, #32]
 112adbc:	f9401e62 	ldr	x2, [x19, #56]
 112adc0:	f9403be0 	ldr	x0, [sp, #112]
 112adc4:	d63f0040 	blr	x2
		ltc_mp.copy(ltc_tmp_key.qP, key->qp);
 112adc8:	f9401681 	ldr	x1, [x20, #40]
 112adcc:	f9401e62 	ldr	x2, [x19, #56]
 112add0:	f9403fe0 	ldr	x0, [sp, #120]
 112add4:	d63f0040 	blr	x2
		ltc_mp.copy(ltc_tmp_key.dP, key->dp);
 112add8:	f9401a81 	ldr	x1, [x20, #48]
 112addc:	f9401e62 	ldr	x2, [x19, #56]
 112ade0:	f94043e0 	ldr	x0, [sp, #128]
 112ade4:	d63f0040 	blr	x2
		ltc_mp.copy(ltc_tmp_key.dQ, key->dq);
 112ade8:	f9401e62 	ldr	x2, [x19, #56]
 112adec:	f9401e81 	ldr	x1, [x20, #56]
 112adf0:	f94047e0 	ldr	x0, [sp, #136]
 112adf4:	d63f0040 	blr	x2
		rsa_free(&ltc_tmp_key);
 112adf8:	aa1603e0 	mov	x0, x22
 112adfc:	9400265b 	bl	1134768 <rsa_free>
		res = TEE_SUCCESS;
 112ae00:	52800000 	mov	w0, #0x0                   	// #0
}
 112ae04:	a94153f3 	ldp	x19, x20, [sp, #16]
 112ae08:	a9425bf5 	ldp	x21, x22, [sp, #32]
 112ae0c:	f9401bf7 	ldr	x23, [sp, #48]
 112ae10:	a8c97bfd 	ldp	x29, x30, [sp], #144
 112ae14:	d65f03c0 	ret

000000000112ae18 <crypto_acipher_rsanopad_encrypt>:

TEE_Result crypto_acipher_rsanopad_encrypt(struct rsa_public_key *key,
					   const uint8_t *src, size_t src_len,
					   uint8_t *dst, size_t *dst_len)
{
 112ae18:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
 112ae1c:	910003fd 	mov	x29, sp
	TEE_Result res;
	rsa_key ltc_key = { 0, };
 112ae20:	910123e5 	add	x5, sp, #0x48
{
 112ae24:	a90153f3 	stp	x19, x20, [sp, #16]
 112ae28:	aa0003f3 	mov	x19, x0
 112ae2c:	aa0103f4 	mov	x20, x1
	rsa_key ltc_key = { 0, };
 112ae30:	aa0503e0 	mov	x0, x5
 112ae34:	52800001 	mov	w1, #0x0                   	// #0
{
 112ae38:	a9025bf5 	stp	x21, x22, [sp, #32]
 112ae3c:	aa0203f5 	mov	x21, x2
 112ae40:	aa0303f6 	mov	x22, x3
	rsa_key ltc_key = { 0, };
 112ae44:	d2800902 	mov	x2, #0x48                  	// #72
{
 112ae48:	f9001bf7 	str	x23, [sp, #48]
 112ae4c:	aa0403f7 	mov	x23, x4
	rsa_key ltc_key = { 0, };
 112ae50:	940063a4 	bl	1143ce0 <memset>
 112ae54:	aa0003e5 	mov	x5, x0

	ltc_key.type = PK_PUBLIC;
	ltc_key.e = key->e;
	ltc_key.N = key->n;

	res = rsadorep(&ltc_key, src, src_len, dst, dst_len);
 112ae58:	aa1703e4 	mov	x4, x23
	ltc_key.e = key->e;
 112ae5c:	f9400260 	ldr	x0, [x19]
 112ae60:	f9002be0 	str	x0, [sp, #80]
	ltc_key.N = key->n;
 112ae64:	f9400660 	ldr	x0, [x19, #8]
	res = rsadorep(&ltc_key, src, src_len, dst, dst_len);
 112ae68:	aa1603e3 	mov	x3, x22
 112ae6c:	aa1503e2 	mov	x2, x21
 112ae70:	aa1403e1 	mov	x1, x20
	ltc_key.N = key->n;
 112ae74:	f90033e0 	str	x0, [sp, #96]
	res = rsadorep(&ltc_key, src, src_len, dst, dst_len);
 112ae78:	aa0503e0 	mov	x0, x5
 112ae7c:	97fffe77 	bl	112a858 <rsadorep>
	return res;
}
 112ae80:	a94153f3 	ldp	x19, x20, [sp, #16]
 112ae84:	a9425bf5 	ldp	x21, x22, [sp, #32]
 112ae88:	f9401bf7 	ldr	x23, [sp, #48]
 112ae8c:	a8c97bfd 	ldp	x29, x30, [sp], #144
 112ae90:	d65f03c0 	ret

000000000112ae94 <crypto_acipher_rsanopad_decrypt>:

TEE_Result crypto_acipher_rsanopad_decrypt(struct rsa_keypair *key,
					   const uint8_t *src, size_t src_len,
					   uint8_t *dst, size_t *dst_len)
{
 112ae94:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
 112ae98:	910003fd 	mov	x29, sp
 112ae9c:	a90153f3 	stp	x19, x20, [sp, #16]
 112aea0:	aa0003f3 	mov	x19, x0
 112aea4:	aa0103f4 	mov	x20, x1
 112aea8:	a90363f7 	stp	x23, x24, [sp, #48]
	TEE_Result res;
	rsa_key ltc_key = { 0, };
 112aeac:	910123f8 	add	x24, sp, #0x48
{
 112aeb0:	aa0403f7 	mov	x23, x4
	rsa_key ltc_key = { 0, };
 112aeb4:	aa1803e0 	mov	x0, x24
 112aeb8:	52800001 	mov	w1, #0x0                   	// #0
{
 112aebc:	a9025bf5 	stp	x21, x22, [sp, #32]
 112aec0:	aa0203f5 	mov	x21, x2
 112aec4:	aa0303f6 	mov	x22, x3
	rsa_key ltc_key = { 0, };
 112aec8:	d2800902 	mov	x2, #0x48                  	// #72
 112aecc:	94006385 	bl	1143ce0 <memset>

	ltc_key.type = PK_PRIVATE;
 112aed0:	52800020 	mov	w0, #0x1                   	// #1
 112aed4:	b9004be0 	str	w0, [sp, #72]
	ltc_key.e = key->e;
 112aed8:	f9400260 	ldr	x0, [x19]
 112aedc:	f9002be0 	str	x0, [sp, #80]
	ltc_key.N = key->n;
 112aee0:	f9400a60 	ldr	x0, [x19, #16]
 112aee4:	f90033e0 	str	x0, [sp, #96]
	ltc_key.d = key->d;
 112aee8:	f9400660 	ldr	x0, [x19, #8]
 112aeec:	f9002fe0 	str	x0, [sp, #88]
	if (key->p && crypto_bignum_num_bytes(key->p)) {
 112aef0:	f9400e60 	ldr	x0, [x19, #24]
 112aef4:	b40001a0 	cbz	x0, 112af28 <crypto_acipher_rsanopad_decrypt+0x94>
 112aef8:	94000c99 	bl	112e15c <crypto_bignum_num_bytes>
 112aefc:	b4000160 	cbz	x0, 112af28 <crypto_acipher_rsanopad_decrypt+0x94>
		ltc_key.p = key->p;
 112af00:	f9400e60 	ldr	x0, [x19, #24]
 112af04:	f90037e0 	str	x0, [sp, #104]
		ltc_key.q = key->q;
 112af08:	f9401260 	ldr	x0, [x19, #32]
 112af0c:	f9003be0 	str	x0, [sp, #112]
		ltc_key.qP = key->qp;
 112af10:	f9401660 	ldr	x0, [x19, #40]
 112af14:	f9003fe0 	str	x0, [sp, #120]
		ltc_key.dP = key->dp;
 112af18:	f9401a60 	ldr	x0, [x19, #48]
 112af1c:	f90043e0 	str	x0, [sp, #128]
		ltc_key.dQ = key->dq;
 112af20:	f9401e60 	ldr	x0, [x19, #56]
 112af24:	f90047e0 	str	x0, [sp, #136]
	}

	res = rsadorep(&ltc_key, src, src_len, dst, dst_len);
 112af28:	aa1703e4 	mov	x4, x23
 112af2c:	aa1603e3 	mov	x3, x22
 112af30:	aa1503e2 	mov	x2, x21
 112af34:	aa1403e1 	mov	x1, x20
 112af38:	aa1803e0 	mov	x0, x24
 112af3c:	97fffe47 	bl	112a858 <rsadorep>
	return res;
}
 112af40:	a94153f3 	ldp	x19, x20, [sp, #16]
 112af44:	a9425bf5 	ldp	x21, x22, [sp, #32]
 112af48:	a94363f7 	ldp	x23, x24, [sp, #48]
 112af4c:	a8c97bfd 	ldp	x29, x30, [sp], #144
 112af50:	d65f03c0 	ret

000000000112af54 <crypto_acipher_rsaes_decrypt>:

TEE_Result crypto_acipher_rsaes_decrypt(uint32_t algo, struct rsa_keypair *key,
					const uint8_t *label, size_t label_len,
					const uint8_t *src, size_t src_len,
					uint8_t *dst, size_t *dst_len)
{
 112af54:	d10343ff 	sub	sp, sp, #0xd0
 112af58:	a9017bfd 	stp	x29, x30, [sp, #16]
 112af5c:	910043fd 	add	x29, sp, #0x10
 112af60:	a90253f3 	stp	x19, x20, [sp, #32]
 112af64:	aa0103f3 	mov	x19, x1
 112af68:	2a0003f4 	mov	w20, w0
 112af6c:	a90673fb 	stp	x27, x28, [sp, #96]
	TEE_Result res = TEE_SUCCESS;
	void *buf = NULL;
	unsigned long blen;
	int ltc_hashindex, ltc_res, ltc_stat, ltc_rsa_algo;
	size_t mod_size;
	rsa_key ltc_key = { 0, };
 112af70:	910223fb 	add	x27, sp, #0x88
 112af74:	aa1b03e0 	mov	x0, x27
 112af78:	52800001 	mov	w1, #0x0                   	// #0
{
 112af7c:	a9035bf5 	stp	x21, x22, [sp, #48]
 112af80:	aa0503f6 	mov	x22, x5
 112af84:	aa0703f5 	mov	x21, x7
 112af88:	a90463f7 	stp	x23, x24, [sp, #64]
 112af8c:	aa0303f7 	mov	x23, x3
 112af90:	aa0603f8 	mov	x24, x6
 112af94:	a9056bf9 	stp	x25, x26, [sp, #80]
 112af98:	aa0203fa 	mov	x26, x2
 112af9c:	aa0403f9 	mov	x25, x4
	rsa_key ltc_key = { 0, };
 112afa0:	d2800902 	mov	x2, #0x48                  	// #72
 112afa4:	9400634f 	bl	1143ce0 <memset>

	ltc_key.type = PK_PRIVATE;
 112afa8:	52800020 	mov	w0, #0x1                   	// #1
 112afac:	b9008be0 	str	w0, [sp, #136]
	ltc_key.e = key->e;
 112afb0:	f9400260 	ldr	x0, [x19]
 112afb4:	f9004be0 	str	x0, [sp, #144]
	ltc_key.d = key->d;
 112afb8:	f9400660 	ldr	x0, [x19, #8]
 112afbc:	f9004fe0 	str	x0, [sp, #152]
	ltc_key.N = key->n;
 112afc0:	f9400a60 	ldr	x0, [x19, #16]
 112afc4:	f90053e0 	str	x0, [sp, #160]
	if (key->p && crypto_bignum_num_bytes(key->p)) {
 112afc8:	f9400e60 	ldr	x0, [x19, #24]
 112afcc:	b40001a0 	cbz	x0, 112b000 <crypto_acipher_rsaes_decrypt+0xac>
 112afd0:	94000c63 	bl	112e15c <crypto_bignum_num_bytes>
 112afd4:	b4000160 	cbz	x0, 112b000 <crypto_acipher_rsaes_decrypt+0xac>
		ltc_key.p = key->p;
 112afd8:	f9400e60 	ldr	x0, [x19, #24]
 112afdc:	f90057e0 	str	x0, [sp, #168]
		ltc_key.q = key->q;
 112afe0:	f9401260 	ldr	x0, [x19, #32]
 112afe4:	f9005be0 	str	x0, [sp, #176]
		ltc_key.qP = key->qp;
 112afe8:	f9401660 	ldr	x0, [x19, #40]
 112afec:	f9005fe0 	str	x0, [sp, #184]
		ltc_key.dP = key->dp;
 112aff0:	f9401a60 	ldr	x0, [x19, #48]
 112aff4:	f90063e0 	str	x0, [sp, #192]
		ltc_key.dQ = key->dq;
 112aff8:	f9401e60 	ldr	x0, [x19, #56]
 112affc:	f90067e0 	str	x0, [sp, #200]
	}

	/* Get the algorithm */
	res = tee_algo_to_ltc_hashindex(algo, &ltc_hashindex);
 112b000:	9101e3e1 	add	x1, sp, #0x78
 112b004:	2a1403e0 	mov	w0, w20
 112b008:	97fffe65 	bl	112a99c <tee_algo_to_ltc_hashindex>
 112b00c:	2a0003f3 	mov	w19, w0
	if (res != TEE_SUCCESS) {
 112b010:	34000260 	cbz	w0, 112b05c <crypto_acipher_rsaes_decrypt+0x108>
		EMSG("tee_algo_to_ltc_hashindex() returned %d", (int)res);
 112b014:	2a0003e5 	mov	w5, w0
 112b018:	f0000144 	adrp	x4, 1156000 <ta_pub_key_modulus+0x7>
 112b01c:	f0000140 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 112b020:	91153484 	add	x4, x4, #0x54d
 112b024:	9117a000 	add	x0, x0, #0x5e8
 112b028:	52800023 	mov	w3, #0x1                   	// #1
 112b02c:	52800022 	mov	w2, #0x1                   	// #1
 112b030:	528026e1 	mov	w1, #0x137                 	// #311
 112b034:	94006744 	bl	1144d44 <trace_printf>
out:
	if (buf)
		free(buf);

	return res;
}
 112b038:	2a1303e0 	mov	w0, w19
 112b03c:	a9417bfd 	ldp	x29, x30, [sp, #16]
 112b040:	a94253f3 	ldp	x19, x20, [sp, #32]
 112b044:	a9435bf5 	ldp	x21, x22, [sp, #48]
 112b048:	a94463f7 	ldp	x23, x24, [sp, #64]
 112b04c:	a9456bf9 	ldp	x25, x26, [sp, #80]
 112b050:	a94673fb 	ldp	x27, x28, [sp, #96]
 112b054:	910343ff 	add	sp, sp, #0xd0
 112b058:	d65f03c0 	ret
	if (algo == TEE_ALG_RSAES_PKCS1_V1_5) {
 112b05c:	52802600 	mov	w0, #0x130                 	// #304
 112b060:	72ac0000 	movk	w0, #0x6000, lsl #16
 112b064:	6b00029f 	cmp	w20, w0
 112b068:	54000501 	b.ne	112b108 <crypto_acipher_rsaes_decrypt+0x1b4>  // b.any
		mod_size = ltc_mp.unsigned_size((void *)(ltc_key.N));
 112b06c:	f0000160 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
		ltc_rsa_algo = LTC_PKCS_1_V1_5;
 112b070:	5280003c 	mov	w28, #0x1                   	// #1
		mod_size = ltc_mp.unsigned_size((void *)(ltc_key.N));
 112b074:	f941d400 	ldr	x0, [x0, #936]
 112b078:	f9404c01 	ldr	x1, [x0, #152]
 112b07c:	f94053e0 	ldr	x0, [sp, #160]
 112b080:	d63f0020 	blr	x1
		blen = mod_size - 11;
 112b084:	d1002c00 	sub	x0, x0, #0xb
 112b088:	f90043e0 	str	x0, [sp, #128]
	buf = malloc(blen);
 112b08c:	f94043e0 	ldr	x0, [sp, #128]
 112b090:	940060f2 	bl	1143458 <malloc>
 112b094:	aa0003f4 	mov	x20, x0
	if (!buf) {
 112b098:	b40008e0 	cbz	x0, 112b1b4 <crypto_acipher_rsaes_decrypt+0x260>
	ltc_res = rsa_decrypt_key_ex(src, src_len, buf, &blen,
 112b09c:	b9407be6 	ldr	w6, [sp, #120]
 112b0a0:	f10002ff 	cmp	x23, #0x0
 112b0a4:	9101f3e0 	add	x0, sp, #0x7c
 112b0a8:	a9006fe0 	stp	x0, x27, [sp]
 112b0ac:	aa1703e5 	mov	x5, x23
 112b0b0:	9a9f1344 	csel	x4, x26, xzr, ne  // ne = any
 112b0b4:	2a1c03e7 	mov	w7, w28
 112b0b8:	910203e3 	add	x3, sp, #0x80
 112b0bc:	aa1403e2 	mov	x2, x20
 112b0c0:	aa1603e1 	mov	x1, x22
 112b0c4:	aa1903e0 	mov	x0, x25
 112b0c8:	940023e3 	bl	1134054 <rsa_decrypt_key_ex>
 112b0cc:	2a0003e5 	mov	w5, w0
	switch (ltc_res) {
 112b0d0:	71001c1f 	cmp	w0, #0x7
 112b0d4:	54000280 	b.eq	112b124 <crypto_acipher_rsaes_decrypt+0x1d0>  // b.none
 112b0d8:	540001ec 	b.gt	112b114 <crypto_acipher_rsaes_decrypt+0x1c0>
 112b0dc:	340003c0 	cbz	w0, 112b154 <crypto_acipher_rsaes_decrypt+0x200>
		EMSG("rsa_decrypt_key_ex() returned %d", ltc_res);
 112b0e0:	f0000144 	adrp	x4, 1156000 <ta_pub_key_modulus+0x7>
 112b0e4:	f0000140 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 112b0e8:	9115d484 	add	x4, x4, #0x575
 112b0ec:	9117a000 	add	x0, x0, #0x5e8
 112b0f0:	52800023 	mov	w3, #0x1                   	// #1
 112b0f4:	52800022 	mov	w2, #0x1                   	// #1
 112b0f8:	52802be1 	mov	w1, #0x15f                 	// #351
 112b0fc:	94006712 	bl	1144d44 <trace_printf>
		res = TEE_ERROR_GENERIC;
 112b100:	52bffff3 	mov	w19, #0xffff0000            	// #-65536
		goto out;
 112b104:	14000011 	b	112b148 <crypto_acipher_rsaes_decrypt+0x1f4>
		ltc_rsa_algo = LTC_PKCS_1_OAEP;
 112b108:	5280005c 	mov	w28, #0x2                   	// #2
		blen = src_len;
 112b10c:	f90043f6 	str	x22, [sp, #128]
		ltc_rsa_algo = LTC_PKCS_1_OAEP;
 112b110:	17ffffdf 	b	112b08c <crypto_acipher_rsaes_decrypt+0x138>
	switch (ltc_res) {
 112b114:	7100581f 	cmp	w0, #0x16
 112b118:	54000060 	b.eq	112b124 <crypto_acipher_rsaes_decrypt+0x1d0>  // b.none
 112b11c:	7100601f 	cmp	w0, #0x18
 112b120:	54fffe01 	b.ne	112b0e0 <crypto_acipher_rsaes_decrypt+0x18c>  // b.any
		res = TEE_ERROR_BAD_PARAMETERS;
 112b124:	129fff33 	mov	w19, #0xffff0006            	// #-65530
		EMSG("rsa_decrypt_key_ex() returned %d", ltc_res);
 112b128:	f0000144 	adrp	x4, 1156000 <ta_pub_key_modulus+0x7>
 112b12c:	52800023 	mov	w3, #0x1                   	// #1
 112b130:	9115d484 	add	x4, x4, #0x575
 112b134:	52800022 	mov	w2, #0x1                   	// #1
 112b138:	52802b01 	mov	w1, #0x158                 	// #344
 112b13c:	f0000140 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 112b140:	9117a000 	add	x0, x0, #0x5e8
 112b144:	94006700 	bl	1144d44 <trace_printf>
		free(buf);
 112b148:	aa1403e0 	mov	x0, x20
 112b14c:	94006125 	bl	11435e0 <free>
 112b150:	17ffffba 	b	112b038 <crypto_acipher_rsaes_decrypt+0xe4>
	if (ltc_stat != 1) {
 112b154:	b9407fe6 	ldr	w6, [sp, #124]
 112b158:	710004df 	cmp	w6, #0x1
 112b15c:	54000160 	b.eq	112b188 <crypto_acipher_rsaes_decrypt+0x234>  // b.none
		EMSG("rsa_decrypt_key_ex() returned %d and %d",
 112b160:	52800005 	mov	w5, #0x0                   	// #0
 112b164:	f0000144 	adrp	x4, 1156000 <ta_pub_key_modulus+0x7>
 112b168:	52800023 	mov	w3, #0x1                   	// #1
 112b16c:	91165884 	add	x4, x4, #0x596
 112b170:	52800022 	mov	w2, #0x1                   	// #1
 112b174:	52802ca1 	mov	w1, #0x165                 	// #357
 112b178:	f0000140 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 112b17c:	9117a000 	add	x0, x0, #0x5e8
 112b180:	940066f1 	bl	1144d44 <trace_printf>
 112b184:	17ffffdf 	b	112b100 <crypto_acipher_rsaes_decrypt+0x1ac>
	if (*dst_len < blen) {
 112b188:	f94002a0 	ldr	x0, [x21]
 112b18c:	f94043e2 	ldr	x2, [sp, #128]
		*dst_len = blen;
 112b190:	f90002a2 	str	x2, [x21]
	if (*dst_len < blen) {
 112b194:	eb02001f 	cmp	x0, x2
 112b198:	54000062 	b.cs	112b1a4 <crypto_acipher_rsaes_decrypt+0x250>  // b.hs, b.nlast
		res = TEE_ERROR_SHORT_BUFFER;
 112b19c:	129ffdf3 	mov	w19, #0xffff0010            	// #-65520
		goto out;
 112b1a0:	17ffffea 	b	112b148 <crypto_acipher_rsaes_decrypt+0x1f4>
	memcpy(dst, buf, blen);
 112b1a4:	aa1403e1 	mov	x1, x20
 112b1a8:	aa1803e0 	mov	x0, x24
 112b1ac:	97ff6079 	bl	1103390 <memcpy>
 112b1b0:	17ffffe6 	b	112b148 <crypto_acipher_rsaes_decrypt+0x1f4>
		res = TEE_ERROR_OUT_OF_MEMORY;
 112b1b4:	129ffe73 	mov	w19, #0xffff000c            	// #-65524
	return res;
 112b1b8:	17ffffa0 	b	112b038 <crypto_acipher_rsaes_decrypt+0xe4>

000000000112b1bc <crypto_acipher_rsaes_encrypt>:
TEE_Result crypto_acipher_rsaes_encrypt(uint32_t algo,
					struct rsa_public_key *key,
					const uint8_t *label, size_t label_len,
					const uint8_t *src, size_t src_len,
					uint8_t *dst, size_t *dst_len)
{
 112b1bc:	d10343ff 	sub	sp, sp, #0xd0
 112b1c0:	a9027bfd 	stp	x29, x30, [sp, #32]
 112b1c4:	910083fd 	add	x29, sp, #0x20
 112b1c8:	a9066bf9 	stp	x25, x26, [sp, #96]
	TEE_Result res;
	uint32_t mod_size;
	int ltc_hashindex, ltc_res, ltc_rsa_algo;
	rsa_key ltc_key = {
 112b1cc:	910223fa 	add	x26, sp, #0x88
{
 112b1d0:	aa0303f9 	mov	x25, x3
 112b1d4:	a90353f3 	stp	x19, x20, [sp, #48]
 112b1d8:	aa0703f3 	mov	x19, x7
 112b1dc:	2a0003f4 	mov	w20, w0
	rsa_key ltc_key = {
 112b1e0:	aa1a03e0 	mov	x0, x26
{
 112b1e4:	a9045bf5 	stp	x21, x22, [sp, #64]
 112b1e8:	aa0403f5 	mov	x21, x4
 112b1ec:	aa0503f6 	mov	x22, x5
 112b1f0:	a90563f7 	stp	x23, x24, [sp, #80]
 112b1f4:	aa0603f7 	mov	x23, x6
 112b1f8:	aa0203f8 	mov	x24, x2
	rsa_key ltc_key = {
 112b1fc:	d2800902 	mov	x2, #0x48                  	// #72
{
 112b200:	f9003bfb 	str	x27, [sp, #112]
 112b204:	aa0103fb 	mov	x27, x1
	rsa_key ltc_key = {
 112b208:	52800001 	mov	w1, #0x0                   	// #0
 112b20c:	940062b5 	bl	1143ce0 <memset>
		.type = PK_PUBLIC,
		.e = key->e,
		.N = key->n
	};

	mod_size =  ltc_mp.unsigned_size((void *)(ltc_key.N));
 112b210:	f0000161 	adrp	x1, 115a000 <__scattered_array_1phys_mem_map+0x8>
	rsa_key ltc_key = {
 112b214:	f9400360 	ldr	x0, [x27]
 112b218:	f9004be0 	str	x0, [sp, #144]
	mod_size =  ltc_mp.unsigned_size((void *)(ltc_key.N));
 112b21c:	f941d421 	ldr	x1, [x1, #936]
		.N = key->n
 112b220:	f9400760 	ldr	x0, [x27, #8]
	rsa_key ltc_key = {
 112b224:	f90053e0 	str	x0, [sp, #160]
	mod_size =  ltc_mp.unsigned_size((void *)(ltc_key.N));
 112b228:	f9404c21 	ldr	x1, [x1, #152]
 112b22c:	d63f0020 	blr	x1
	if (*dst_len < mod_size) {
 112b230:	2a0003e1 	mov	w1, w0
 112b234:	f9400262 	ldr	x2, [x19]
		*dst_len = mod_size;
 112b238:	f9000261 	str	x1, [x19]
	if (*dst_len < mod_size) {
 112b23c:	eb20405f 	cmp	x2, w0, uxtw
 112b240:	54000142 	b.cs	112b268 <crypto_acipher_rsaes_encrypt+0xac>  // b.hs, b.nlast
		res = TEE_ERROR_SHORT_BUFFER;
 112b244:	129ffde0 	mov	w0, #0xffff0010            	// #-65520
	}
	res = TEE_SUCCESS;

out:
	return res;
}
 112b248:	a9427bfd 	ldp	x29, x30, [sp, #32]
 112b24c:	a94353f3 	ldp	x19, x20, [sp, #48]
 112b250:	a9445bf5 	ldp	x21, x22, [sp, #64]
 112b254:	a94563f7 	ldp	x23, x24, [sp, #80]
 112b258:	a9466bf9 	ldp	x25, x26, [sp, #96]
 112b25c:	f9403bfb 	ldr	x27, [sp, #112]
 112b260:	910343ff 	add	sp, sp, #0xd0
 112b264:	d65f03c0 	ret
	res = tee_algo_to_ltc_hashindex(algo, &ltc_hashindex);
 112b268:	910213e1 	add	x1, sp, #0x84
 112b26c:	2a1403e0 	mov	w0, w20
 112b270:	97fffdcb 	bl	112a99c <tee_algo_to_ltc_hashindex>
	if (res != TEE_SUCCESS)
 112b274:	35fffea0 	cbnz	w0, 112b248 <crypto_acipher_rsaes_encrypt+0x8c>
	if (algo == TEE_ALG_RSAES_PKCS1_V1_5)
 112b278:	52802600 	mov	w0, #0x130                 	// #304
 112b27c:	72ac0000 	movk	w0, #0x6000, lsl #16
		ltc_rsa_algo = LTC_PKCS_1_OAEP;
 112b280:	6b00029f 	cmp	w20, w0
 112b284:	1a9f07f4 	cset	w20, ne  // ne = any
	ltc_res = rsa_encrypt_key_ex(src, src_len, dst,
 112b288:	f0000140 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 112b28c:	9113d800 	add	x0, x0, #0x4f6
		ltc_rsa_algo = LTC_PKCS_1_OAEP;
 112b290:	11000694 	add	w20, w20, #0x1
	ltc_res = rsa_encrypt_key_ex(src, src_len, dst,
 112b294:	94001cd3 	bl	11325e0 <find_prng>
 112b298:	b9000bf4 	str	w20, [sp, #8]
 112b29c:	b94087e1 	ldr	w1, [sp, #132]
 112b2a0:	aa1903e5 	mov	x5, x25
 112b2a4:	b90003e1 	str	w1, [sp]
 112b2a8:	2a0003e7 	mov	w7, w0
 112b2ac:	f9000bfa 	str	x26, [sp, #16]
 112b2b0:	aa1803e4 	mov	x4, x24
 112b2b4:	aa1303e3 	mov	x3, x19
 112b2b8:	aa1703e2 	mov	x2, x23
 112b2bc:	aa1503e0 	mov	x0, x21
 112b2c0:	aa1603e1 	mov	x1, x22
 112b2c4:	d2800006 	mov	x6, #0x0                   	// #0
 112b2c8:	940023c3 	bl	11341d4 <rsa_encrypt_key_ex>
 112b2cc:	2a0003e5 	mov	w5, w0
	switch (ltc_res) {
 112b2d0:	71001c1f 	cmp	w0, #0x7
 112b2d4:	54000140 	b.eq	112b2fc <crypto_acipher_rsaes_encrypt+0x140>  // b.none
 112b2d8:	540000ac 	b.gt	112b2ec <crypto_acipher_rsaes_encrypt+0x130>
 112b2dc:	7100001f 	cmp	w0, #0x0
 112b2e0:	52bfffe0 	mov	w0, #0xffff0000            	// #-65536
 112b2e4:	1a8003e0 	csel	w0, wzr, w0, eq  // eq = none
 112b2e8:	17ffffd8 	b	112b248 <crypto_acipher_rsaes_encrypt+0x8c>
 112b2ec:	7100581f 	cmp	w0, #0x16
 112b2f0:	54000060 	b.eq	112b2fc <crypto_acipher_rsaes_encrypt+0x140>  // b.none
 112b2f4:	7100601f 	cmp	w0, #0x18
 112b2f8:	54000161 	b.ne	112b324 <crypto_acipher_rsaes_encrypt+0x168>  // b.any
		EMSG("rsa_encrypt_key_ex() returned %d", ltc_res);
 112b2fc:	f0000144 	adrp	x4, 1156000 <ta_pub_key_modulus+0x7>
 112b300:	52800023 	mov	w3, #0x1                   	// #1
 112b304:	9116f884 	add	x4, x4, #0x5be
 112b308:	52800022 	mov	w2, #0x1                   	// #1
 112b30c:	528034a1 	mov	w1, #0x1a5                 	// #421
 112b310:	f0000140 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 112b314:	91181400 	add	x0, x0, #0x605
 112b318:	9400668b 	bl	1144d44 <trace_printf>
		res = TEE_ERROR_BAD_PARAMETERS;
 112b31c:	129fff20 	mov	w0, #0xffff0006            	// #-65530
		goto out;
 112b320:	17ffffca 	b	112b248 <crypto_acipher_rsaes_encrypt+0x8c>
	switch (ltc_res) {
 112b324:	52bfffe0 	mov	w0, #0xffff0000            	// #-65536
	return res;
 112b328:	17ffffc8 	b	112b248 <crypto_acipher_rsaes_encrypt+0x8c>

000000000112b32c <crypto_acipher_rsassa_sign>:

TEE_Result crypto_acipher_rsassa_sign(uint32_t algo, struct rsa_keypair *key,
				      int salt_len, const uint8_t *msg,
				      size_t msg_len, uint8_t *sig,
				      size_t *sig_len)
{
 112b32c:	d10303ff 	sub	sp, sp, #0xc0
 112b330:	a9017bfd 	stp	x29, x30, [sp, #16]
 112b334:	910043fd 	add	x29, sp, #0x10
 112b338:	a9056bf9 	stp	x25, x26, [sp, #80]
 112b33c:	aa0103fa 	mov	x26, x1
	TEE_Result res;
	size_t hash_size, mod_size;
	int ltc_res, ltc_rsa_algo, ltc_hashindex;
	unsigned long ltc_sig_len;
	rsa_key ltc_key = { 0, };
 112b340:	9101e3f9 	add	x25, sp, #0x78
 112b344:	52800001 	mov	w1, #0x0                   	// #0
{
 112b348:	a90253f3 	stp	x19, x20, [sp, #32]
 112b34c:	2a0003f3 	mov	w19, w0
 112b350:	aa0603f4 	mov	x20, x6
	rsa_key ltc_key = { 0, };
 112b354:	aa1903e0 	mov	x0, x25
{
 112b358:	a9035bf5 	stp	x21, x22, [sp, #48]
 112b35c:	93407c55 	sxtw	x21, w2
 112b360:	aa0403f6 	mov	x22, x4
	rsa_key ltc_key = { 0, };
 112b364:	d2800902 	mov	x2, #0x48                  	// #72
{
 112b368:	a90463f7 	stp	x23, x24, [sp, #64]
 112b36c:	aa0303f7 	mov	x23, x3
 112b370:	aa0503f8 	mov	x24, x5
	rsa_key ltc_key = { 0, };
 112b374:	9400625b 	bl	1143ce0 <memset>

	ltc_key.type = PK_PRIVATE;
 112b378:	52800020 	mov	w0, #0x1                   	// #1
 112b37c:	b9007be0 	str	w0, [sp, #120]
	ltc_key.e = key->e;
 112b380:	f9400340 	ldr	x0, [x26]
 112b384:	f90043e0 	str	x0, [sp, #128]
	ltc_key.N = key->n;
 112b388:	f9400b40 	ldr	x0, [x26, #16]
 112b38c:	f9004be0 	str	x0, [sp, #144]
	ltc_key.d = key->d;
 112b390:	f9400740 	ldr	x0, [x26, #8]
 112b394:	f90047e0 	str	x0, [sp, #136]
	if (key->p && crypto_bignum_num_bytes(key->p)) {
 112b398:	f9400f40 	ldr	x0, [x26, #24]
 112b39c:	b40001a0 	cbz	x0, 112b3d0 <crypto_acipher_rsassa_sign+0xa4>
 112b3a0:	94000b6f 	bl	112e15c <crypto_bignum_num_bytes>
 112b3a4:	b4000160 	cbz	x0, 112b3d0 <crypto_acipher_rsassa_sign+0xa4>
		ltc_key.p = key->p;
 112b3a8:	f9400f40 	ldr	x0, [x26, #24]
 112b3ac:	f9004fe0 	str	x0, [sp, #152]
		ltc_key.q = key->q;
 112b3b0:	f9401340 	ldr	x0, [x26, #32]
 112b3b4:	f90053e0 	str	x0, [sp, #160]
		ltc_key.qP = key->qp;
 112b3b8:	f9401740 	ldr	x0, [x26, #40]
 112b3bc:	f90057e0 	str	x0, [sp, #168]
		ltc_key.dP = key->dp;
 112b3c0:	f9401b40 	ldr	x0, [x26, #48]
 112b3c4:	f9005be0 	str	x0, [sp, #176]
		ltc_key.dQ = key->dq;
 112b3c8:	f9401f40 	ldr	x0, [x26, #56]
 112b3cc:	f9005fe0 	str	x0, [sp, #184]
	}

	switch (algo) {
 112b3d0:	52892600 	mov	w0, #0x4930                	// #18736
 112b3d4:	72ae0820 	movk	w0, #0x7041, lsl #16
 112b3d8:	6b00027f 	cmp	w19, w0
 112b3dc:	54000ac0 	b.eq	112b534 <crypto_acipher_rsassa_sign+0x208>  // b.none
 112b3e0:	54000928 	b.hi	112b504 <crypto_acipher_rsassa_sign+0x1d8>  // b.pmore
 112b3e4:	528b0600 	mov	w0, #0x5830                	// #22576
 112b3e8:	72ae0000 	movk	w0, #0x7000, lsl #16
 112b3ec:	6b00027f 	cmp	w19, w0
 112b3f0:	540002a0 	b.eq	112b444 <crypto_acipher_rsassa_sign+0x118>  // b.none
 112b3f4:	54000768 	b.hi	112b4e0 <crypto_acipher_rsassa_sign+0x1b4>  // b.pmore
 112b3f8:	52870600 	mov	w0, #0x3830                	// #14384
 112b3fc:	72ae0000 	movk	w0, #0x7000, lsl #16
 112b400:	6b00027f 	cmp	w19, w0
 112b404:	54000200 	b.eq	112b444 <crypto_acipher_rsassa_sign+0x118>  // b.none
 112b408:	54000168 	b.hi	112b434 <crypto_acipher_rsassa_sign+0x108>  // b.pmore
 112b40c:	52830600 	mov	w0, #0x1830                	// #6192
	case TEE_ALG_RSASSA_PKCS1_V1_5_SHA1:
	case TEE_ALG_RSASSA_PKCS1_V1_5_SHA224:
	case TEE_ALG_RSASSA_PKCS1_V1_5_SHA256:
	case TEE_ALG_RSASSA_PKCS1_V1_5_SHA384:
	case TEE_ALG_RSASSA_PKCS1_V1_5_SHA512:
		ltc_rsa_algo = LTC_PKCS_1_V1_5;
 112b410:	5280003a 	mov	w26, #0x1                   	// #1
	switch (algo) {
 112b414:	72ae0000 	movk	w0, #0x7000, lsl #16
 112b418:	6b00027f 	cmp	w19, w0
 112b41c:	54000160 	b.eq	112b448 <crypto_acipher_rsassa_sign+0x11c>  // b.none
 112b420:	11400400 	add	w0, w0, #0x1, lsl #12
 112b424:	6b00027f 	cmp	w19, w0
 112b428:	54000100 	b.eq	112b448 <crypto_acipher_rsassa_sign+0x11c>  // b.none
 112b42c:	129fff20 	mov	w0, #0xffff0006            	// #-65530
 112b430:	14000025 	b	112b4c4 <crypto_acipher_rsassa_sign+0x198>
 112b434:	52890600 	mov	w0, #0x4830                	// #18480
 112b438:	72ae0000 	movk	w0, #0x7000, lsl #16
 112b43c:	6b00027f 	cmp	w19, w0
 112b440:	54ffff61 	b.ne	112b42c <crypto_acipher_rsassa_sign+0x100>  // b.any
		ltc_rsa_algo = LTC_PKCS_1_V1_5;
 112b444:	5280003a 	mov	w26, #0x1                   	// #1
		res = TEE_ERROR_BAD_PARAMETERS;
		goto err;
	}

	if (ltc_rsa_algo != LTC_PKCS_1_V1_5_NA1) {
		ltc_res = tee_algo_to_ltc_hashindex(algo, &ltc_hashindex);
 112b448:	910193e1 	add	x1, sp, #0x64
 112b44c:	2a1303e0 	mov	w0, w19
 112b450:	97fffd53 	bl	112a99c <tee_algo_to_ltc_hashindex>
		if (ltc_res != CRYPT_OK) {
 112b454:	35fffec0 	cbnz	w0, 112b42c <crypto_acipher_rsassa_sign+0x100>
	if (algo == TEE_ALG_SM2_DSA_SM3)
 112b458:	528c08a0 	mov	w0, #0x6045                	// #24645
 112b45c:	72ae0000 	movk	w0, #0x7000, lsl #16
 112b460:	6b00027f 	cmp	w19, w0
 112b464:	540006c0 	b.eq	112b53c <crypto_acipher_rsassa_sign+0x210>  // b.none
	return (algo >> 12) & 0xF;
 112b468:	d34c3e73 	ubfx	x19, x19, #12, #4
	return (TEE_OPERATION_DIGEST << 28) | main_hash;
 112b46c:	52aa0000 	mov	w0, #0x50000000            	// #1342177280
 112b470:	71001e7f 	cmp	w19, #0x7
 112b474:	2a000260 	orr	w0, w19, w0
 112b478:	528000e1 	mov	w1, #0x7                   	// #7
 112b47c:	72aa0001 	movk	w1, #0x5000, lsl #16
 112b480:	1a811000 	csel	w0, w0, w1, ne  // ne = any
			res = TEE_ERROR_BAD_PARAMETERS;
			goto err;
		}

		res = tee_alg_get_digest_size(TEE_DIGEST_HASH_TO_ALGO(algo),
 112b484:	9101a3e1 	add	x1, sp, #0x68
 112b488:	97ffc0ac 	bl	111b738 <tee_alg_get_digest_size>
					      &hash_size);
		if (res != TEE_SUCCESS)
 112b48c:	350001c0 	cbnz	w0, 112b4c4 <crypto_acipher_rsassa_sign+0x198>
			goto err;

		if (msg_len != hash_size) {
 112b490:	f94037e0 	ldr	x0, [sp, #104]
 112b494:	eb16001f 	cmp	x0, x22
 112b498:	54fffca1 	b.ne	112b42c <crypto_acipher_rsassa_sign+0x100>  // b.any
			res = TEE_ERROR_BAD_PARAMETERS;
			goto err;
		}
	}

	mod_size = ltc_mp.unsigned_size((void *)(ltc_key.N));
 112b49c:	f0000160 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 112b4a0:	f941d400 	ldr	x0, [x0, #936]
 112b4a4:	f9404c01 	ldr	x1, [x0, #152]
 112b4a8:	f9404be0 	ldr	x0, [sp, #144]
 112b4ac:	d63f0020 	blr	x1

	if (*sig_len < mod_size) {
 112b4b0:	f9400281 	ldr	x1, [x20]
 112b4b4:	eb00003f 	cmp	x1, x0
 112b4b8:	540004c2 	b.cs	112b550 <crypto_acipher_rsassa_sign+0x224>  // b.hs, b.nlast
		*sig_len = mod_size;
 112b4bc:	f9000280 	str	x0, [x20]
		res = TEE_ERROR_SHORT_BUFFER;
 112b4c0:	129ffde0 	mov	w0, #0xffff0010            	// #-65520
	}
	res = TEE_SUCCESS;

err:
	return res;
}
 112b4c4:	a9417bfd 	ldp	x29, x30, [sp, #16]
 112b4c8:	a94253f3 	ldp	x19, x20, [sp, #32]
 112b4cc:	a9435bf5 	ldp	x21, x22, [sp, #48]
 112b4d0:	a94463f7 	ldp	x23, x24, [sp, #64]
 112b4d4:	a9456bf9 	ldp	x25, x26, [sp, #80]
 112b4d8:	910303ff 	add	sp, sp, #0xc0
 112b4dc:	d65f03c0 	ret
	switch (algo) {
 112b4e0:	52852600 	mov	w0, #0x2930                	// #10544
 112b4e4:	72ae0420 	movk	w0, #0x7021, lsl #16
 112b4e8:	6b00027f 	cmp	w19, w0
 112b4ec:	54000240 	b.eq	112b534 <crypto_acipher_rsassa_sign+0x208>  // b.none
 112b4f0:	11440400 	add	w0, w0, #0x101, lsl #12
 112b4f4:	6b00027f 	cmp	w19, w0
 112b4f8:	540001e0 	b.eq	112b534 <crypto_acipher_rsassa_sign+0x208>  // b.none
 112b4fc:	528d0600 	mov	w0, #0x6830                	// #26672
 112b500:	17ffffce 	b	112b438 <crypto_acipher_rsassa_sign+0x10c>
 112b504:	52810600 	mov	w0, #0x830                 	// #2096
 112b508:	72be0000 	movk	w0, #0xf000, lsl #16
 112b50c:	6b00027f 	cmp	w19, w0
 112b510:	540001c0 	b.eq	112b548 <crypto_acipher_rsassa_sign+0x21c>  // b.none
 112b514:	54fff8c8 	b.hi	112b42c <crypto_acipher_rsassa_sign+0x100>  // b.pmore
 112b518:	528b2600 	mov	w0, #0x5930                	// #22832
 112b51c:	72ae0a20 	movk	w0, #0x7051, lsl #16
 112b520:	6b00027f 	cmp	w19, w0
 112b524:	54000080 	b.eq	112b534 <crypto_acipher_rsassa_sign+0x208>  // b.none
 112b528:	11440400 	add	w0, w0, #0x101, lsl #12
 112b52c:	6b00027f 	cmp	w19, w0
 112b530:	54fff7e1 	b.ne	112b42c <crypto_acipher_rsassa_sign+0x100>  // b.any
 112b534:	5280007a 	mov	w26, #0x3                   	// #3
 112b538:	17ffffc4 	b	112b448 <crypto_acipher_rsassa_sign+0x11c>
		return TEE_ALG_SM3;
 112b53c:	528000e0 	mov	w0, #0x7                   	// #7
 112b540:	72aa0000 	movk	w0, #0x5000, lsl #16
 112b544:	17ffffd0 	b	112b484 <crypto_acipher_rsassa_sign+0x158>
 112b548:	5280009a 	mov	w26, #0x4                   	// #4
 112b54c:	17ffffd4 	b	112b49c <crypto_acipher_rsassa_sign+0x170>
	ltc_sig_len = mod_size;
 112b550:	f9003be0 	str	x0, [sp, #112]
	ltc_res = rsa_sign_hash_ex(msg, msg_len, sig, &ltc_sig_len,
 112b554:	f0000140 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 112b558:	9113d800 	add	x0, x0, #0x4f6
 112b55c:	94001c21 	bl	11325e0 <find_prng>
 112b560:	b94067e7 	ldr	w7, [sp, #100]
 112b564:	2a0003e6 	mov	w6, w0
 112b568:	a90067f5 	stp	x21, x25, [sp]
 112b56c:	aa1603e1 	mov	x1, x22
 112b570:	2a1a03e4 	mov	w4, w26
 112b574:	9101c3e3 	add	x3, sp, #0x70
 112b578:	aa1803e2 	mov	x2, x24
 112b57c:	aa1703e0 	mov	x0, x23
 112b580:	d2800005 	mov	x5, #0x0                   	// #0
 112b584:	94002559 	bl	1134ae8 <rsa_sign_hash_ex>
	*sig_len = ltc_sig_len;
 112b588:	f9403be1 	ldr	x1, [sp, #112]
 112b58c:	f9000281 	str	x1, [x20]
	if (ltc_res != CRYPT_OK) {
 112b590:	35fff4e0 	cbnz	w0, 112b42c <crypto_acipher_rsassa_sign+0x100>
	res = TEE_SUCCESS;
 112b594:	52800000 	mov	w0, #0x0                   	// #0
	return res;
 112b598:	17ffffcb 	b	112b4c4 <crypto_acipher_rsassa_sign+0x198>

000000000112b59c <crypto_acipher_rsassa_verify>:
TEE_Result crypto_acipher_rsassa_verify(uint32_t algo,
					struct rsa_public_key *key,
					int salt_len, const uint8_t *msg,
					size_t msg_len, const uint8_t *sig,
					size_t sig_len)
{
 112b59c:	d10303ff 	sub	sp, sp, #0xc0
 112b5a0:	a9017bfd 	stp	x29, x30, [sp, #16]
 112b5a4:	910043fd 	add	x29, sp, #0x10
 112b5a8:	a9056bf9 	stp	x25, x26, [sp, #80]
 112b5ac:	aa0103fa 	mov	x26, x1
	TEE_Result res;
	uint32_t bigint_size;
	size_t hash_size;
	int stat, ltc_hashindex, ltc_res, ltc_rsa_algo;
	rsa_key ltc_key = {
 112b5b0:	9101e3f9 	add	x25, sp, #0x78
 112b5b4:	52800001 	mov	w1, #0x0                   	// #0
{
 112b5b8:	a90253f3 	stp	x19, x20, [sp, #32]
 112b5bc:	2a0003f3 	mov	w19, w0
 112b5c0:	aa0603f4 	mov	x20, x6
	rsa_key ltc_key = {
 112b5c4:	aa1903e0 	mov	x0, x25
{
 112b5c8:	a9035bf5 	stp	x21, x22, [sp, #48]
 112b5cc:	aa0403f5 	mov	x21, x4
 112b5d0:	aa0503f6 	mov	x22, x5
 112b5d4:	a90463f7 	stp	x23, x24, [sp, #64]
 112b5d8:	2a0203f8 	mov	w24, w2
 112b5dc:	aa0303f7 	mov	x23, x3
	rsa_key ltc_key = {
 112b5e0:	d2800902 	mov	x2, #0x48                  	// #72
 112b5e4:	940061bf 	bl	1143ce0 <memset>
 112b5e8:	f9400340 	ldr	x0, [x26]
 112b5ec:	f90043e0 	str	x0, [sp, #128]
 112b5f0:	f9400740 	ldr	x0, [x26, #8]
 112b5f4:	f9004be0 	str	x0, [sp, #144]
		.type = PK_PUBLIC,
		.e = key->e,
		.N = key->n
	};

	if (algo != TEE_ALG_RSASSA_PKCS1_V1_5) {
 112b5f8:	52810600 	mov	w0, #0x830                 	// #2096
 112b5fc:	72be0000 	movk	w0, #0xf000, lsl #16
 112b600:	6b00027f 	cmp	w19, w0
 112b604:	54000141 	b.ne	112b62c <crypto_acipher_rsassa_verify+0x90>  // b.any
			res = TEE_ERROR_BAD_PARAMETERS;
			goto err;
		}
	}

	bigint_size = ltc_mp.unsigned_size(ltc_key.N);
 112b608:	f0000160 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 112b60c:	f941d400 	ldr	x0, [x0, #936]
 112b610:	f9404c01 	ldr	x1, [x0, #152]
 112b614:	f9404be0 	ldr	x0, [sp, #144]
 112b618:	d63f0020 	blr	x1
	if (sig_len < bigint_size) {
 112b61c:	eb20429f 	cmp	x20, w0, uxtw
 112b620:	540003e2 	b.cs	112b69c <crypto_acipher_rsassa_verify+0x100>  // b.hs, b.nlast
		return TEE_ERROR_SIGNATURE_INVALID;
 112b624:	1299f1a0 	mov	w0, #0xffff3072            	// #-53134
 112b628:	14000013 	b	112b674 <crypto_acipher_rsassa_verify+0xd8>
	if (algo == TEE_ALG_SM2_DSA_SM3)
 112b62c:	528c08a0 	mov	w0, #0x6045                	// #24645
 112b630:	72ae0000 	movk	w0, #0x7000, lsl #16
 112b634:	6b00027f 	cmp	w19, w0
 112b638:	540002c0 	b.eq	112b690 <crypto_acipher_rsassa_verify+0xf4>  // b.none
	return (algo >> 12) & 0xF;
 112b63c:	d34c3e61 	ubfx	x1, x19, #12, #4
	return (TEE_OPERATION_DIGEST << 28) | main_hash;
 112b640:	52aa0000 	mov	w0, #0x50000000            	// #1342177280
 112b644:	71001c3f 	cmp	w1, #0x7
 112b648:	2a000020 	orr	w0, w1, w0
 112b64c:	528000e1 	mov	w1, #0x7                   	// #7
 112b650:	72aa0001 	movk	w1, #0x5000, lsl #16
 112b654:	1a811000 	csel	w0, w0, w1, ne  // ne = any
		res = tee_alg_get_digest_size(TEE_DIGEST_HASH_TO_ALGO(algo),
 112b658:	9101c3e1 	add	x1, sp, #0x70
 112b65c:	97ffc037 	bl	111b738 <tee_alg_get_digest_size>
		if (res != TEE_SUCCESS)
 112b660:	350000a0 	cbnz	w0, 112b674 <crypto_acipher_rsassa_verify+0xd8>
		if (msg_len != hash_size) {
 112b664:	f9403be0 	ldr	x0, [sp, #112]
 112b668:	eb15001f 	cmp	x0, x21
 112b66c:	54fffce0 	b.eq	112b608 <crypto_acipher_rsassa_verify+0x6c>  // b.none
		res = tee_algo_to_ltc_hashindex(algo, &ltc_hashindex);
		if (res != TEE_SUCCESS)
			goto err;
	}

	switch (algo) {
 112b670:	129fff20 	mov	w0, #0xffff0006            	// #-65530
	ltc_res = rsa_verify_hash_ex(sig, sig_len, msg, msg_len, ltc_rsa_algo,
				     ltc_hashindex, salt_len, &stat, &ltc_key);
	res = convert_ltc_verify_status(ltc_res, stat);
err:
	return res;
}
 112b674:	a9417bfd 	ldp	x29, x30, [sp, #16]
 112b678:	a94253f3 	ldp	x19, x20, [sp, #32]
 112b67c:	a9435bf5 	ldp	x21, x22, [sp, #48]
 112b680:	a94463f7 	ldp	x23, x24, [sp, #64]
 112b684:	a9456bf9 	ldp	x25, x26, [sp, #80]
 112b688:	910303ff 	add	sp, sp, #0xc0
 112b68c:	d65f03c0 	ret
		return TEE_ALG_SM3;
 112b690:	528000e0 	mov	w0, #0x7                   	// #7
 112b694:	72aa0000 	movk	w0, #0x5000, lsl #16
 112b698:	17fffff0 	b	112b658 <crypto_acipher_rsassa_verify+0xbc>
	if (algo != TEE_ALG_RSASSA_PKCS1_V1_5) {
 112b69c:	52810600 	mov	w0, #0x830                 	// #2096
 112b6a0:	72be0000 	movk	w0, #0xf000, lsl #16
 112b6a4:	6b00027f 	cmp	w19, w0
 112b6a8:	54000640 	b.eq	112b770 <crypto_acipher_rsassa_verify+0x1d4>  // b.none
		res = tee_algo_to_ltc_hashindex(algo, &ltc_hashindex);
 112b6ac:	9101b3e1 	add	x1, sp, #0x6c
 112b6b0:	2a1303e0 	mov	w0, w19
 112b6b4:	97fffcba 	bl	112a99c <tee_algo_to_ltc_hashindex>
		if (res != TEE_SUCCESS)
 112b6b8:	35fffde0 	cbnz	w0, 112b674 <crypto_acipher_rsassa_verify+0xd8>
	switch (algo) {
 112b6bc:	528d0600 	mov	w0, #0x6830                	// #26672
 112b6c0:	72ae0000 	movk	w0, #0x7000, lsl #16
 112b6c4:	6b00027f 	cmp	w19, w0
 112b6c8:	540001c0 	b.eq	112b700 <crypto_acipher_rsassa_verify+0x164>  // b.none
 112b6cc:	54000288 	b.hi	112b71c <crypto_acipher_rsassa_verify+0x180>  // b.pmore
 112b6d0:	52870600 	mov	w0, #0x3830                	// #14384
 112b6d4:	72ae0000 	movk	w0, #0x7000, lsl #16
 112b6d8:	6b00027f 	cmp	w19, w0
 112b6dc:	54000120 	b.eq	112b700 <crypto_acipher_rsassa_verify+0x164>  // b.none
 112b6e0:	54000148 	b.hi	112b708 <crypto_acipher_rsassa_verify+0x16c>  // b.pmore
 112b6e4:	52830600 	mov	w0, #0x1830                	// #6192
 112b6e8:	72ae0000 	movk	w0, #0x7000, lsl #16
 112b6ec:	6b00027f 	cmp	w19, w0
 112b6f0:	54000080 	b.eq	112b700 <crypto_acipher_rsassa_verify+0x164>  // b.none
 112b6f4:	11400400 	add	w0, w0, #0x1, lsl #12
 112b6f8:	6b00027f 	cmp	w19, w0
 112b6fc:	54fffba1 	b.ne	112b670 <crypto_acipher_rsassa_verify+0xd4>  // b.any
 112b700:	52800024 	mov	w4, #0x1                   	// #1
 112b704:	1400001c 	b	112b774 <crypto_acipher_rsassa_verify+0x1d8>
 112b708:	12137a73 	and	w19, w19, #0xffffefff
 112b70c:	52890601 	mov	w1, #0x4830                	// #18480
 112b710:	72ae0001 	movk	w1, #0x7000, lsl #16
 112b714:	6b01027f 	cmp	w19, w1
 112b718:	17fffff9 	b	112b6fc <crypto_acipher_rsassa_verify+0x160>
 112b71c:	52892600 	mov	w0, #0x4930                	// #18736
 112b720:	72ae0820 	movk	w0, #0x7041, lsl #16
 112b724:	6b00027f 	cmp	w19, w0
 112b728:	54000120 	b.eq	112b74c <crypto_acipher_rsassa_verify+0x1b0>  // b.none
 112b72c:	54000148 	b.hi	112b754 <crypto_acipher_rsassa_verify+0x1b8>  // b.pmore
 112b730:	52852600 	mov	w0, #0x2930                	// #10544
 112b734:	72ae0420 	movk	w0, #0x7021, lsl #16
 112b738:	6b00027f 	cmp	w19, w0
 112b73c:	54000080 	b.eq	112b74c <crypto_acipher_rsassa_verify+0x1b0>  // b.none
 112b740:	11440400 	add	w0, w0, #0x101, lsl #12
 112b744:	6b00027f 	cmp	w19, w0
 112b748:	54fff941 	b.ne	112b670 <crypto_acipher_rsassa_verify+0xd4>  // b.any
		ltc_rsa_algo = LTC_PKCS_1_PSS;
 112b74c:	52800064 	mov	w4, #0x3                   	// #3
 112b750:	14000009 	b	112b774 <crypto_acipher_rsassa_verify+0x1d8>
	switch (algo) {
 112b754:	528d2600 	mov	w0, #0x6930                	// #26928
 112b758:	72ae0c20 	movk	w0, #0x7061, lsl #16
 112b75c:	6b00027f 	cmp	w19, w0
 112b760:	54ffff60 	b.eq	112b74c <crypto_acipher_rsassa_verify+0x1b0>  // b.none
 112b764:	528b2600 	mov	w0, #0x5930                	// #22832
 112b768:	72ae0a20 	movk	w0, #0x7051, lsl #16
 112b76c:	17fffff6 	b	112b744 <crypto_acipher_rsassa_verify+0x1a8>
		ltc_rsa_algo = LTC_PKCS_1_V1_5_NA1;
 112b770:	52800084 	mov	w4, #0x4                   	// #4
	ltc_res = rsa_verify_hash_ex(sig, sig_len, msg, msg_len, ltc_rsa_algo,
 112b774:	b9406fe5 	ldr	w5, [sp, #108]
 112b778:	9101a3e7 	add	x7, sp, #0x68
 112b77c:	f90003f9 	str	x25, [sp]
 112b780:	93407f06 	sxtw	x6, w24
 112b784:	aa1503e3 	mov	x3, x21
 112b788:	aa1703e2 	mov	x2, x23
 112b78c:	aa1403e1 	mov	x1, x20
 112b790:	aa1603e0 	mov	x0, x22
 112b794:	94002575 	bl	1134d68 <rsa_verify_hash_ex>
	switch (ltc_res) {
 112b798:	71001c1f 	cmp	w0, #0x7
 112b79c:	54fff440 	b.eq	112b624 <crypto_acipher_rsassa_verify+0x88>  // b.none
 112b7a0:	7100581f 	cmp	w0, #0x16
 112b7a4:	54fff400 	b.eq	112b624 <crypto_acipher_rsassa_verify+0x88>  // b.none
 112b7a8:	350000c0 	cbnz	w0, 112b7c0 <crypto_acipher_rsassa_verify+0x224>
		if (ltc_stat == 1)
 112b7ac:	b9406be0 	ldr	w0, [sp, #104]
 112b7b0:	7100041f 	cmp	w0, #0x1
 112b7b4:	54fff381 	b.ne	112b624 <crypto_acipher_rsassa_verify+0x88>  // b.any
			return TEE_SUCCESS;
 112b7b8:	52800000 	mov	w0, #0x0                   	// #0
	return res;
 112b7bc:	17ffffae 	b	112b674 <crypto_acipher_rsassa_verify+0xd8>
	switch (ltc_res) {
 112b7c0:	52bfffe0 	mov	w0, #0xffff0000            	// #-65536
 112b7c4:	17ffffac 	b	112b674 <crypto_acipher_rsassa_verify+0xd8>

000000000112b7c8 <bn_alloc_max>:
{
 112b7c8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 112b7cc:	910003fd 	mov	x29, sp
 112b7d0:	f9000bf3 	str	x19, [sp, #16]
 112b7d4:	aa0003f3 	mov	x19, x0
	*s = crypto_bignum_allocate(_CFG_CORE_LTC_BIGNUM_MAX_BITS);
 112b7d8:	d2820000 	mov	x0, #0x1000                	// #4096
 112b7dc:	94000a93 	bl	112e228 <crypto_bignum_allocate>
	return *s;
 112b7e0:	f100001f 	cmp	x0, #0x0
	*s = crypto_bignum_allocate(_CFG_CORE_LTC_BIGNUM_MAX_BITS);
 112b7e4:	f9000260 	str	x0, [x19]
}
 112b7e8:	1a9f07e0 	cset	w0, ne  // ne = any
 112b7ec:	f9400bf3 	ldr	x19, [sp, #16]
 112b7f0:	a8c27bfd 	ldp	x29, x30, [sp], #32
 112b7f4:	d65f03c0 	ret

000000000112b7f8 <crypto_acipher_alloc_dh_keypair>:

#include "acipher_helpers.h"

TEE_Result crypto_acipher_alloc_dh_keypair(struct dh_keypair *s,
					   size_t key_size_bits __unused)
{
 112b7f8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	memset(s, 0, sizeof(*s));
 112b7fc:	d2800602 	mov	x2, #0x30                  	// #48
 112b800:	52800001 	mov	w1, #0x0                   	// #0
{
 112b804:	910003fd 	mov	x29, sp
 112b808:	f9000bf3 	str	x19, [sp, #16]
 112b80c:	aa0003f3 	mov	x19, x0
	memset(s, 0, sizeof(*s));
 112b810:	94006134 	bl	1143ce0 <memset>
	if (!bn_alloc_max(&s->g))
 112b814:	aa1303e0 	mov	x0, x19
 112b818:	97ffffec 	bl	112b7c8 <bn_alloc_max>
 112b81c:	72001c1f 	tst	w0, #0xff
 112b820:	540001a0 	b.eq	112b854 <crypto_acipher_alloc_dh_keypair+0x5c>  // b.none
		return TEE_ERROR_OUT_OF_MEMORY;
	if (!bn_alloc_max(&s->p))
 112b824:	91002260 	add	x0, x19, #0x8
 112b828:	97ffffe8 	bl	112b7c8 <bn_alloc_max>
 112b82c:	72001c1f 	tst	w0, #0xff
 112b830:	54000161 	b.ne	112b85c <crypto_acipher_alloc_dh_keypair+0x64>  // b.any
		goto err;
	if (!bn_alloc_max(&s->q))
		goto err;
	return TEE_SUCCESS;
err:
	crypto_bignum_free(s->g);
 112b834:	f9400260 	ldr	x0, [x19]
 112b838:	94000a92 	bl	112e280 <crypto_bignum_free>
	crypto_bignum_free(s->p);
 112b83c:	f9400660 	ldr	x0, [x19, #8]
 112b840:	94000a90 	bl	112e280 <crypto_bignum_free>
	crypto_bignum_free(s->y);
 112b844:	f9400e60 	ldr	x0, [x19, #24]
 112b848:	94000a8e 	bl	112e280 <crypto_bignum_free>
	crypto_bignum_free(s->x);
 112b84c:	f9400a60 	ldr	x0, [x19, #16]
 112b850:	94000a8c 	bl	112e280 <crypto_bignum_free>
		return TEE_ERROR_OUT_OF_MEMORY;
 112b854:	129ffe60 	mov	w0, #0xffff000c            	// #-65524
 112b858:	1400000e 	b	112b890 <crypto_acipher_alloc_dh_keypair+0x98>
	if (!bn_alloc_max(&s->y))
 112b85c:	91006260 	add	x0, x19, #0x18
 112b860:	97ffffda 	bl	112b7c8 <bn_alloc_max>
 112b864:	72001c1f 	tst	w0, #0xff
 112b868:	54fffe60 	b.eq	112b834 <crypto_acipher_alloc_dh_keypair+0x3c>  // b.none
	if (!bn_alloc_max(&s->x))
 112b86c:	91004260 	add	x0, x19, #0x10
 112b870:	97ffffd6 	bl	112b7c8 <bn_alloc_max>
 112b874:	72001c1f 	tst	w0, #0xff
 112b878:	54fffde0 	b.eq	112b834 <crypto_acipher_alloc_dh_keypair+0x3c>  // b.none
	if (!bn_alloc_max(&s->q))
 112b87c:	91008260 	add	x0, x19, #0x20
 112b880:	97ffffd2 	bl	112b7c8 <bn_alloc_max>
 112b884:	72001c1f 	tst	w0, #0xff
 112b888:	54fffd60 	b.eq	112b834 <crypto_acipher_alloc_dh_keypair+0x3c>  // b.none
	return TEE_SUCCESS;
 112b88c:	52800000 	mov	w0, #0x0                   	// #0
	return TEE_ERROR_OUT_OF_MEMORY;
}
 112b890:	f9400bf3 	ldr	x19, [sp, #16]
 112b894:	a8c27bfd 	ldp	x29, x30, [sp], #32
 112b898:	d65f03c0 	ret

000000000112b89c <crypto_acipher_gen_dh_key>:

TEE_Result crypto_acipher_gen_dh_key(struct dh_keypair *key, struct bignum *q,
				     size_t xbits, size_t key_size)
{
 112b89c:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
 112b8a0:	910003fd 	mov	x29, sp
 112b8a4:	a90153f3 	stp	x19, x20, [sp, #16]
	TEE_Result res = TEE_ERROR_GENERIC;
	dh_key ltc_tmp_key = { };
	int ltc_res = 0;

	if (key_size != 8 * mp_unsigned_bin_size(key->p))
 112b8a8:	f0000174 	adrp	x20, 115a000 <__scattered_array_1phys_mem_map+0x8>
{
 112b8ac:	aa0003f3 	mov	x19, x0
	if (key_size != 8 * mp_unsigned_bin_size(key->p))
 112b8b0:	f941d694 	ldr	x20, [x20, #936]
{
 112b8b4:	a9025bf5 	stp	x21, x22, [sp, #32]
 112b8b8:	aa0103f6 	mov	x22, x1
	if (key_size != 8 * mp_unsigned_bin_size(key->p))
 112b8bc:	f9400400 	ldr	x0, [x0, #8]
	dh_key ltc_tmp_key = { };
 112b8c0:	a904ffff 	stp	xzr, xzr, [sp, #72]
{
 112b8c4:	aa0303f5 	mov	x21, x3
	if (key_size != 8 * mp_unsigned_bin_size(key->p))
 112b8c8:	f9404e81 	ldr	x1, [x20, #152]
{
 112b8cc:	f9001bf7 	str	x23, [sp, #48]
	dh_key ltc_tmp_key = { };
 112b8d0:	a905ffff 	stp	xzr, xzr, [sp, #88]
{
 112b8d4:	aa0203f7 	mov	x23, x2
	dh_key ltc_tmp_key = { };
 112b8d8:	f90037ff 	str	xzr, [sp, #104]
	if (key_size != 8 * mp_unsigned_bin_size(key->p))
 112b8dc:	d63f0020 	blr	x1
 112b8e0:	eb000ebf 	cmp	x21, x0, lsl #3
 112b8e4:	54000581 	b.ne	112b994 <crypto_acipher_gen_dh_key+0xf8>  // b.any
		return TEE_ERROR_BAD_PARAMETERS;

	ltc_res = mp_init_multi(&ltc_tmp_key.base, &ltc_tmp_key.prime, NULL);
 112b8e8:	910123f5 	add	x21, sp, #0x48
 112b8ec:	d2800002 	mov	x2, #0x0                   	// #0
 112b8f0:	910082a1 	add	x1, x21, #0x20
 112b8f4:	910062a0 	add	x0, x21, #0x18
 112b8f8:	9400196f 	bl	1131eb4 <ltc_init_multi>
	if (ltc_res != CRYPT_OK)
 112b8fc:	35000500 	cbnz	w0, 112b99c <crypto_acipher_gen_dh_key+0x100>
		return TEE_ERROR_OUT_OF_MEMORY;

	/* Generate the DH key */
	mp_copy(key->g, ltc_tmp_key.base);
 112b900:	f9400260 	ldr	x0, [x19]
 112b904:	f9401e82 	ldr	x2, [x20, #56]
 112b908:	f94033e1 	ldr	x1, [sp, #96]
 112b90c:	d63f0040 	blr	x2
	mp_copy(key->p, ltc_tmp_key.prime);
 112b910:	f9400660 	ldr	x0, [x19, #8]
 112b914:	f9401e82 	ldr	x2, [x20, #56]
 112b918:	f94037e1 	ldr	x1, [sp, #104]
 112b91c:	d63f0040 	blr	x2
	ltc_res = dh_make_key(NULL, find_prng("prng_crypto"), q, xbits,
 112b920:	f0000140 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 112b924:	9113d800 	add	x0, x0, #0x4f6
 112b928:	94001b2e 	bl	11325e0 <find_prng>
 112b92c:	2a0003e1 	mov	w1, w0
 112b930:	aa1503e4 	mov	x4, x21
 112b934:	2a1703e3 	mov	w3, w23
 112b938:	aa1603e2 	mov	x2, x22
 112b93c:	d2800000 	mov	x0, #0x0                   	// #0
 112b940:	940025fc 	bl	1135130 <dh_make_key>
			      &ltc_tmp_key);
	if (ltc_res != CRYPT_OK) {
 112b944:	35000240 	cbnz	w0, 112b98c <crypto_acipher_gen_dh_key+0xf0>
		res = TEE_ERROR_BAD_PARAMETERS;
	} else {
		ltc_mp.copy(ltc_tmp_key.y,  key->y);
 112b948:	f9400e61 	ldr	x1, [x19, #24]
 112b94c:	f9401e82 	ldr	x2, [x20, #56]
 112b950:	f9402fe0 	ldr	x0, [sp, #88]
 112b954:	d63f0040 	blr	x2
		ltc_mp.copy(ltc_tmp_key.x,  key->x);
 112b958:	f9400a61 	ldr	x1, [x19, #16]
		res = TEE_SUCCESS;
 112b95c:	52800013 	mov	w19, #0x0                   	// #0
		ltc_mp.copy(ltc_tmp_key.x,  key->x);
 112b960:	f9401e82 	ldr	x2, [x20, #56]
 112b964:	f9402be0 	ldr	x0, [sp, #80]
 112b968:	d63f0040 	blr	x2
	}

	dh_free(&ltc_tmp_key);
 112b96c:	aa1503e0 	mov	x0, x21
 112b970:	940025e8 	bl	1135110 <dh_free>
	return res;
}
 112b974:	2a1303e0 	mov	w0, w19
 112b978:	a94153f3 	ldp	x19, x20, [sp, #16]
 112b97c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 112b980:	f9401bf7 	ldr	x23, [sp, #48]
 112b984:	a8c77bfd 	ldp	x29, x30, [sp], #112
 112b988:	d65f03c0 	ret
		res = TEE_ERROR_BAD_PARAMETERS;
 112b98c:	129fff33 	mov	w19, #0xffff0006            	// #-65530
 112b990:	17fffff7 	b	112b96c <crypto_acipher_gen_dh_key+0xd0>
		return TEE_ERROR_BAD_PARAMETERS;
 112b994:	129fff33 	mov	w19, #0xffff0006            	// #-65530
 112b998:	17fffff7 	b	112b974 <crypto_acipher_gen_dh_key+0xd8>
		return TEE_ERROR_OUT_OF_MEMORY;
 112b99c:	129ffe73 	mov	w19, #0xffff000c            	// #-65524
 112b9a0:	17fffff5 	b	112b974 <crypto_acipher_gen_dh_key+0xd8>

000000000112b9a4 <crypto_acipher_dh_shared_secret>:
					   struct bignum *public_key,
					   struct bignum *secret)
{
	int err;

	if (!private_key || !public_key || !secret)
 112b9a4:	f100001f 	cmp	x0, #0x0
{
 112b9a8:	aa0003e4 	mov	x4, x0
	if (!private_key || !public_key || !secret)
 112b9ac:	fa401824 	ccmp	x1, #0x0, #0x4, ne  // ne = any
 112b9b0:	54000220 	b.eq	112b9f4 <crypto_acipher_dh_shared_secret+0x50>  // b.none
 112b9b4:	aa0203e3 	mov	x3, x2
 112b9b8:	b40001e2 	cbz	x2, 112b9f4 <crypto_acipher_dh_shared_secret+0x50>
{
 112b9bc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 112b9c0:	aa0103e0 	mov	x0, x1
		return TEE_ERROR_BAD_PARAMETERS;

	err = mp_exptmod(public_key, private_key->x, private_key->p, secret);
 112b9c4:	f0000161 	adrp	x1, 115a000 <__scattered_array_1phys_mem_map+0x8>
{
 112b9c8:	910003fd 	mov	x29, sp
	err = mp_exptmod(public_key, private_key->x, private_key->p, secret);
 112b9cc:	f941d421 	ldr	x1, [x1, #936]
 112b9d0:	f940a825 	ldr	x5, [x1, #336]
 112b9d4:	a9408482 	ldp	x2, x1, [x4, #8]
 112b9d8:	d63f00a0 	blr	x5
	return ((err == CRYPT_OK) ? TEE_SUCCESS : TEE_ERROR_BAD_PARAMETERS);
 112b9dc:	34000080 	cbz	w0, 112b9ec <crypto_acipher_dh_shared_secret+0x48>
 112b9e0:	129fff20 	mov	w0, #0xffff0006            	// #-65530

}
 112b9e4:	a8c17bfd 	ldp	x29, x30, [sp], #16
 112b9e8:	d65f03c0 	ret
	return ((err == CRYPT_OK) ? TEE_SUCCESS : TEE_ERROR_BAD_PARAMETERS);
 112b9ec:	52800000 	mov	w0, #0x0                   	// #0
 112b9f0:	17fffffd 	b	112b9e4 <crypto_acipher_dh_shared_secret+0x40>
 112b9f4:	129fff20 	mov	w0, #0xffff0006            	// #-65530
}
 112b9f8:	d65f03c0 	ret

000000000112b9fc <crypto_aes_expand_enc_key>:
	return crypto_accel_aes_expand_keys(key, key_len, enc_key, NULL,
					    enc_keylen, rounds);
#else
	symmetric_key skey;

	if (enc_keylen < sizeof(skey.rijndael.eK))
 112b9fc:	f103bc7f 	cmp	x3, #0xef
 112ba00:	54000128 	b.hi	112ba24 <crypto_aes_expand_enc_key+0x28>  // b.pmore
		return TEE_ERROR_BAD_PARAMETERS;
 112ba04:	129fff20 	mov	w0, #0xffff0006            	// #-65530

	memcpy(enc_key, skey.rijndael.eK, sizeof(skey.rijndael.eK));
	*rounds = skey.rijndael.Nr;
#endif
	return TEE_SUCCESS;
}
 112ba08:	d65f03c0 	ret
		return TEE_ERROR_BAD_PARAMETERS;
 112ba0c:	129fff20 	mov	w0, #0xffff0006            	// #-65530
}
 112ba10:	a9407bfd 	ldp	x29, x30, [sp]
 112ba14:	a94153f3 	ldp	x19, x20, [sp, #16]
 112ba18:	f94013f5 	ldr	x21, [sp, #32]
 112ba1c:	910cc3ff 	add	sp, sp, #0x330
 112ba20:	d65f03c0 	ret
{
 112ba24:	d10cc3ff 	sub	sp, sp, #0x330
 112ba28:	a9007bfd 	stp	x29, x30, [sp]
 112ba2c:	910003fd 	mov	x29, sp
 112ba30:	f90013f5 	str	x21, [sp, #32]
	if (aes_setup(key, key_len, 0, &skey))
 112ba34:	9100c3f5 	add	x21, sp, #0x30
 112ba38:	aa1503e3 	mov	x3, x21
{
 112ba3c:	a90153f3 	stp	x19, x20, [sp, #16]
 112ba40:	aa0203f4 	mov	x20, x2
 112ba44:	aa0403f3 	mov	x19, x4
	if (aes_setup(key, key_len, 0, &skey))
 112ba48:	52800002 	mov	w2, #0x0                   	// #0
 112ba4c:	94000ebb 	bl	112f538 <rijndael_setup>
 112ba50:	35fffde0 	cbnz	w0, 112ba0c <crypto_aes_expand_enc_key+0x10>
	memcpy(enc_key, skey.rijndael.eK, sizeof(skey.rijndael.eK));
 112ba54:	aa1503e1 	mov	x1, x21
 112ba58:	aa1403e0 	mov	x0, x20
 112ba5c:	d2801e02 	mov	x2, #0xf0                  	// #240
 112ba60:	97ff5e4c 	bl	1103390 <memcpy>
	*rounds = skey.rijndael.Nr;
 112ba64:	b94213e0 	ldr	w0, [sp, #528]
 112ba68:	b9000260 	str	w0, [x19]
	return TEE_SUCCESS;
 112ba6c:	52800000 	mov	w0, #0x0                   	// #0
 112ba70:	17ffffe8 	b	112ba10 <crypto_aes_expand_enc_key+0x14>

000000000112ba74 <crypto_aes_enc_block>:

void crypto_aes_enc_block(const void *enc_key, size_t enc_keylen __maybe_unused,
			  unsigned int rounds, const void *src, void *dst)
{
 112ba74:	d10cc3ff 	sub	sp, sp, #0x330
#ifdef _CFG_CORE_LTC_AES_ACCEL
	crypto_accel_aes_ecb_enc(dst, src, enc_key, rounds, 1);
#else
	symmetric_key skey;

	assert(enc_keylen >= sizeof(skey.rijndael.eK));
 112ba78:	f103bc3f 	cmp	x1, #0xef
{
 112ba7c:	a9007bfd 	stp	x29, x30, [sp]
 112ba80:	910003fd 	mov	x29, sp
 112ba84:	a90153f3 	stp	x19, x20, [sp, #16]
 112ba88:	f90013f5 	str	x21, [sp, #32]
	assert(enc_keylen >= sizeof(skey.rijndael.eK));
 112ba8c:	54000148 	b.hi	112bab4 <crypto_aes_enc_block+0x40>  // b.pmore
 112ba90:	f0000143 	adrp	x3, 1156000 <ta_pub_key_modulus+0x7>
 112ba94:	f0000141 	adrp	x1, 1156000 <ta_pub_key_modulus+0x7>
 112ba98:	91199063 	add	x3, x3, #0x664
 112ba9c:	91188821 	add	x1, x1, #0x622
 112baa0:	f0000140 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 112baa4:	9118f400 	add	x0, x0, #0x63d
 112baa8:	52800562 	mov	w2, #0x2b                  	// #43
 112baac:	97ff9a00 	bl	11122ac <_assert_log>
 112bab0:	97ff9a10 	bl	11122f0 <_assert_break>
	memcpy(skey.rijndael.eK, enc_key, sizeof(skey.rijndael.eK));
 112bab4:	9100c3e5 	add	x5, sp, #0x30
 112bab8:	aa0003e1 	mov	x1, x0
 112babc:	2a0203f5 	mov	w21, w2
 112bac0:	aa0303f3 	mov	x19, x3
 112bac4:	aa0403f4 	mov	x20, x4
 112bac8:	d2801e02 	mov	x2, #0xf0                  	// #240
 112bacc:	aa0503e0 	mov	x0, x5
 112bad0:	97ff5e30 	bl	1103390 <memcpy>
	skey.rijndael.Nr = rounds;
	if (aes_ecb_encrypt(src, dst, &skey))
 112bad4:	aa1403e1 	mov	x1, x20
 112bad8:	aa0003e2 	mov	x2, x0
 112badc:	aa1303e0 	mov	x0, x19
	skey.rijndael.Nr = rounds;
 112bae0:	b90213f5 	str	w21, [sp, #528]
	if (aes_ecb_encrypt(src, dst, &skey))
 112bae4:	94000cc8 	bl	112ee04 <rijndael_ecb_encrypt>
 112bae8:	34000100 	cbz	w0, 112bb08 <crypto_aes_enc_block+0x94>
		panic();
 112baec:	f0000142 	adrp	x2, 1156000 <ta_pub_key_modulus+0x7>
 112baf0:	f0000140 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 112baf4:	91199042 	add	x2, x2, #0x664
 112baf8:	91188800 	add	x0, x0, #0x622
 112bafc:	d2800003 	mov	x3, #0x0                   	// #0
 112bb00:	528005e1 	mov	w1, #0x2f                  	// #47
 112bb04:	97ff9e59 	bl	1113468 <__do_panic>
#endif
}
 112bb08:	a9407bfd 	ldp	x29, x30, [sp]
 112bb0c:	a94153f3 	ldp	x19, x20, [sp, #16]
 112bb10:	f94013f5 	ldr	x21, [sp, #32]
 112bb14:	910cc3ff 	add	sp, sp, #0x330
 112bb18:	d65f03c0 	ret

000000000112bb1c <sm2_ltc_dsa_sign>:
 * GM/T 0003.12012 Part1 2 Section 6.1
 */
TEE_Result sm2_ltc_dsa_sign(uint32_t algo, struct ecc_keypair *key,
			    const uint8_t *msg, size_t msg_len, uint8_t *sig,
			    size_t *sig_len)
{
 112bb1c:	a9a67bfd 	stp	x29, x30, [sp, #-416]!
 112bb20:	910003fd 	mov	x29, sp
 112bb24:	a90363f7 	stp	x23, x24, [sp, #48]
 112bb28:	aa0503f8 	mov	x24, x5
 112bb2c:	aa0403f7 	mov	x23, x4
 112bb30:	a9046bf9 	stp	x25, x26, [sp, #64]
	TEE_Result res = TEE_SUCCESS;
	ecc_point *x1y1p = NULL;
	ecc_key ltc_key = { };
 112bb34:	9102a3f9 	add	x25, sp, #0xa8
{
 112bb38:	aa0303fa 	mov	x26, x3
 112bb3c:	a90153f3 	stp	x19, x20, [sp, #16]
 112bb40:	2a0003f4 	mov	w20, w0
 112bb44:	aa0103f3 	mov	x19, x1
	ecc_key ltc_key = { };
 112bb48:	aa1903e0 	mov	x0, x25
 112bb4c:	52800001 	mov	w1, #0x0                   	// #0
{
 112bb50:	a9025bf5 	stp	x21, x22, [sp, #32]
 112bb54:	a90573fb 	stp	x27, x28, [sp, #80]
 112bb58:	f90037e2 	str	x2, [sp, #104]
	ecc_key ltc_key = { };
 112bb5c:	d2801f02 	mov	x2, #0xf8                  	// #248
 112bb60:	94006060 	bl	1143ce0 <memset>
	int ltc_res = 0;
	void *k = NULL;
	void *e = NULL;
 112bb64:	a9087fff 	stp	xzr, xzr, [sp, #128]
	void *r = NULL;
	void *s = NULL;
	void *tmp = NULL;

	if (*sig_len < 2 * SM2_INT_SIZE_BYTES) {
 112bb68:	f9400300 	ldr	x0, [x24]
	void *s = NULL;
 112bb6c:	a9097fff 	stp	xzr, xzr, [sp, #144]
	void *tmp = NULL;
 112bb70:	f90053ff 	str	xzr, [sp, #160]
	if (*sig_len < 2 * SM2_INT_SIZE_BYTES) {
 112bb74:	f100fc1f 	cmp	x0, #0x3f
 112bb78:	54000188 	b.hi	112bba8 <sm2_ltc_dsa_sign+0x8c>  // b.pmore
		*sig_len = 64;
 112bb7c:	d2800800 	mov	x0, #0x40                  	// #64
		return TEE_ERROR_SHORT_BUFFER;
 112bb80:	129ffdf4 	mov	w20, #0xffff0010            	// #-65520
		*sig_len = 64;
 112bb84:	f9000300 	str	x0, [x24]
out:
	ecc_free(&ltc_key);
	ltc_ecc_del_point(x1y1p);
	mp_clear_multi(k, e, r, s, tmp, NULL);
	return res;
}
 112bb88:	2a1403e0 	mov	w0, w20
 112bb8c:	a94153f3 	ldp	x19, x20, [sp, #16]
 112bb90:	a9425bf5 	ldp	x21, x22, [sp, #32]
 112bb94:	a94363f7 	ldp	x23, x24, [sp, #48]
 112bb98:	a9446bf9 	ldp	x25, x26, [sp, #64]
 112bb9c:	a94573fb 	ldp	x27, x28, [sp, #80]
 112bba0:	a8da7bfd 	ldp	x29, x30, [sp], #416
 112bba4:	d65f03c0 	ret
	ltc_res = mp_init_multi(&k, &e, &r, &s, &tmp, NULL);
 112bba8:	910283e4 	add	x4, sp, #0xa0
 112bbac:	910263e3 	add	x3, sp, #0x98
 112bbb0:	910243e2 	add	x2, sp, #0x90
 112bbb4:	910223e1 	add	x1, sp, #0x88
 112bbb8:	910203e0 	add	x0, sp, #0x80
 112bbbc:	d2800005 	mov	x5, #0x0                   	// #0
 112bbc0:	940018bd 	bl	1131eb4 <ltc_init_multi>
	if (ltc_res != CRYPT_OK)
 112bbc4:	35001000 	cbnz	w0, 112bdc4 <sm2_ltc_dsa_sign+0x2a8>
	x1y1p = ltc_ecc_new_point();
 112bbc8:	94002e9b 	bl	1137634 <ltc_ecc_new_point>
 112bbcc:	aa0003f6 	mov	x22, x0
	if (!x1y1p) {
 112bbd0:	b4000f60 	cbz	x0, 112bdbc <sm2_ltc_dsa_sign+0x2a0>
	res = ecc_populate_ltc_private_key(&ltc_key, key, algo, NULL);
 112bbd4:	2a1403e2 	mov	w2, w20
 112bbd8:	aa1303e1 	mov	x1, x19
 112bbdc:	aa1903e0 	mov	x0, x25
 112bbe0:	d2800003 	mov	x3, #0x0                   	// #0
 112bbe4:	97fff985 	bl	112a1f8 <ecc_populate_ltc_private_key>
 112bbe8:	2a0003f4 	mov	w20, w0
	if (res)
 112bbec:	35000240 	cbnz	w0, 112bc34 <sm2_ltc_dsa_sign+0x118>
	mp_read_unsigned_bin(e, (unsigned char *)msg, msg_len);
 112bbf0:	f0000175 	adrp	x21, 115a000 <__scattered_array_1phys_mem_map+0x8>
	ltc_res = rand_bn_upto(k, ltc_key.dp.order, NULL,
 112bbf4:	f000015b 	adrp	x27, 1156000 <ta_pub_key_modulus+0x7>
	ltc_res = ltc_ecc_mulmod(k, &ltc_key.dp.base, x1y1p, ltc_key.dp.A,
 112bbf8:	9100c33c 	add	x28, x25, #0x30
	ltc_res = rand_bn_upto(k, ltc_key.dp.order, NULL,
 112bbfc:	9113db7b 	add	x27, x27, #0x4f6
	mp_read_unsigned_bin(e, (unsigned char *)msg, msg_len);
 112bc00:	f941d6b3 	ldr	x19, [x21, #936]
	ltc_res = rand_bn_upto(k, ltc_key.dp.order, NULL,
 112bc04:	aa1b03e0 	mov	x0, x27
 112bc08:	f94043e4 	ldr	x4, [sp, #128]
 112bc0c:	f9406be1 	ldr	x1, [sp, #208]
 112bc10:	a90713e1 	stp	x1, x4, [sp, #112]
 112bc14:	94001a73 	bl	11325e0 <find_prng>
 112bc18:	2a0003e3 	mov	w3, w0
 112bc1c:	a94713e1 	ldp	x1, x4, [sp, #112]
 112bc20:	d2800002 	mov	x2, #0x0                   	// #0
 112bc24:	aa0403e0 	mov	x0, x4
 112bc28:	940019ce 	bl	1132360 <rand_bn_upto>
	if (ltc_res != CRYPT_OK) {
 112bc2c:	34000180 	cbz	w0, 112bc5c <sm2_ltc_dsa_sign+0x140>
		res = TEE_ERROR_BAD_STATE;
 112bc30:	129fff14 	mov	w20, #0xffff0007            	// #-65529
	ecc_free(&ltc_key);
 112bc34:	aa1903e0 	mov	x0, x25
 112bc38:	94002621 	bl	11354bc <ecc_free>
	ltc_ecc_del_point(x1y1p);
 112bc3c:	aa1603e0 	mov	x0, x22
 112bc40:	94002e93 	bl	113768c <ltc_ecc_del_point>
	mp_clear_multi(k, e, r, s, tmp, NULL);
 112bc44:	a94807e0 	ldp	x0, x1, [sp, #128]
 112bc48:	d2800005 	mov	x5, #0x0                   	// #0
 112bc4c:	a9490fe2 	ldp	x2, x3, [sp, #144]
 112bc50:	f94053e4 	ldr	x4, [sp, #160]
 112bc54:	94001932 	bl	113211c <ltc_deinit_multi>
	return res;
 112bc58:	17ffffcc 	b	112bb88 <sm2_ltc_dsa_sign+0x6c>
	ltc_res = ltc_ecc_mulmod(k, &ltc_key.dp.base, x1y1p, ltc_key.dp.A,
 112bc5c:	a94b8fe4 	ldp	x4, x3, [sp, #184]
 112bc60:	aa1603e2 	mov	x2, x22
 112bc64:	f94043e0 	ldr	x0, [sp, #128]
 112bc68:	aa1c03e1 	mov	x1, x28
 112bc6c:	52800025 	mov	w5, #0x1                   	// #1
 112bc70:	94002bcb 	bl	1136b9c <ltc_ecc_mulmod>
	if (ltc_res != CRYPT_OK) {
 112bc74:	35fffde0 	cbnz	w0, 112bc30 <sm2_ltc_dsa_sign+0x114>
	mp_read_unsigned_bin(e, (unsigned char *)msg, msg_len);
 112bc78:	f94037e1 	ldr	x1, [sp, #104]
 112bc7c:	aa1a03e2 	mov	x2, x26
 112bc80:	f94047e0 	ldr	x0, [sp, #136]
 112bc84:	f9405663 	ldr	x3, [x19, #168]
 112bc88:	d63f0060 	blr	x3
	ltc_res = mp_addmod(e, x1y1p->x, ltc_key.dp.order, r);
 112bc8c:	a9488fe0 	ldp	x0, x3, [sp, #136]
 112bc90:	f94002c1 	ldr	x1, [x22]
 112bc94:	f9406be2 	ldr	x2, [sp, #208]
 112bc98:	f940ce64 	ldr	x4, [x19, #408]
 112bc9c:	d63f0080 	blr	x4
	if (ltc_res != CRYPT_OK) {
 112bca0:	35fffc80 	cbnz	w0, 112bc30 <sm2_ltc_dsa_sign+0x114>
	ltc_res = mp_add(r, k, tmp);
 112bca4:	f94043e1 	ldr	x1, [sp, #128]
 112bca8:	f9404be0 	ldr	x0, [sp, #144]
 112bcac:	f94053e2 	ldr	x2, [sp, #160]
 112bcb0:	f9405a63 	ldr	x3, [x19, #176]
 112bcb4:	d63f0060 	blr	x3
	if (ltc_res != CRYPT_OK) {
 112bcb8:	35fffbc0 	cbnz	w0, 112bc30 <sm2_ltc_dsa_sign+0x114>
	if (mp_cmp_d(r, 0) == LTC_MP_EQ ||
 112bcbc:	f9403662 	ldr	x2, [x19, #104]
 112bcc0:	d2800001 	mov	x1, #0x0                   	// #0
 112bcc4:	f9404be0 	ldr	x0, [sp, #144]
 112bcc8:	d63f0040 	blr	x2
 112bccc:	34fff9c0 	cbz	w0, 112bc04 <sm2_ltc_dsa_sign+0xe8>
	    mp_cmp(tmp, ltc_key.dp.order) == LTC_MP_EQ)
 112bcd0:	f9403262 	ldr	x2, [x19, #96]
 112bcd4:	f94053e0 	ldr	x0, [sp, #160]
 112bcd8:	f9406be1 	ldr	x1, [sp, #208]
 112bcdc:	d63f0040 	blr	x2
	if (mp_cmp_d(r, 0) == LTC_MP_EQ ||
 112bce0:	34fff920 	cbz	w0, 112bc04 <sm2_ltc_dsa_sign+0xe8>
	ltc_res = mp_add_d(ltc_key.k, 1, s);
 112bce4:	f9404fe2 	ldr	x2, [sp, #152]
 112bce8:	d2800021 	mov	x1, #0x1                   	// #1
 112bcec:	f9405e63 	ldr	x3, [x19, #184]
 112bcf0:	f940cfe0 	ldr	x0, [sp, #408]
 112bcf4:	d63f0060 	blr	x3
	if (ltc_res != CRYPT_OK) {
 112bcf8:	35fff9c0 	cbnz	w0, 112bc30 <sm2_ltc_dsa_sign+0x114>
	ltc_res = mp_invmod(s, ltc_key.dp.order, s);
 112bcfc:	f9404fe2 	ldr	x2, [sp, #152]
 112bd00:	f9406be1 	ldr	x1, [sp, #208]
 112bd04:	aa0203e0 	mov	x0, x2
 112bd08:	f9409663 	ldr	x3, [x19, #296]
 112bd0c:	d63f0060 	blr	x3
	if (ltc_res != CRYPT_OK) {
 112bd10:	35fff900 	cbnz	w0, 112bc30 <sm2_ltc_dsa_sign+0x114>
	ltc_res = mp_mul(r, ltc_key.k, tmp);
 112bd14:	f9404be0 	ldr	x0, [sp, #144]
 112bd18:	f94053e2 	ldr	x2, [sp, #160]
 112bd1c:	f9406a63 	ldr	x3, [x19, #208]
 112bd20:	f940cfe1 	ldr	x1, [sp, #408]
 112bd24:	d63f0060 	blr	x3
	if (ltc_res != CRYPT_OK) {
 112bd28:	35fff840 	cbnz	w0, 112bc30 <sm2_ltc_dsa_sign+0x114>
	ltc_res = mp_sub(k, tmp, tmp);
 112bd2c:	f94043e0 	ldr	x0, [sp, #128]
 112bd30:	f94053e2 	ldr	x2, [sp, #160]
 112bd34:	f9406263 	ldr	x3, [x19, #192]
 112bd38:	aa0203e1 	mov	x1, x2
 112bd3c:	d63f0060 	blr	x3
	if (ltc_res != CRYPT_OK) {
 112bd40:	35fff780 	cbnz	w0, 112bc30 <sm2_ltc_dsa_sign+0x114>
	ltc_res = mp_mulmod(s, tmp, ltc_key.dp.order, s);
 112bd44:	f941d6b5 	ldr	x21, [x21, #936]
 112bd48:	a94987e3 	ldp	x3, x1, [sp, #152]
 112bd4c:	f9406be2 	ldr	x2, [sp, #208]
 112bd50:	f9408ea4 	ldr	x4, [x21, #280]
 112bd54:	aa0303e0 	mov	x0, x3
 112bd58:	d63f0080 	blr	x4
	if (ltc_res != CRYPT_OK) {
 112bd5c:	35fff6a0 	cbnz	w0, 112bc30 <sm2_ltc_dsa_sign+0x114>
	*sig_len = 2 * SM2_INT_SIZE_BYTES;
 112bd60:	d2800813 	mov	x19, #0x40                  	// #64
 112bd64:	f9000313 	str	x19, [x24]
	memset(sig, 0, *sig_len);
 112bd68:	aa1303e2 	mov	x2, x19
 112bd6c:	aa1703e0 	mov	x0, x23
 112bd70:	52800001 	mov	w1, #0x0                   	// #0
 112bd74:	94005fdb 	bl	1143ce0 <memset>
	mp_to_unsigned_bin2(r, sig, SM2_INT_SIZE_BYTES);
 112bd78:	a949eaa1 	ldp	x1, x26, [x21, #152]
 112bd7c:	f9404bf8 	ldr	x24, [sp, #144]
 112bd80:	aa1803e0 	mov	x0, x24
 112bd84:	d63f0020 	blr	x1
 112bd88:	cb0002e1 	sub	x1, x23, x0
 112bd8c:	91008021 	add	x1, x1, #0x20
 112bd90:	aa1803e0 	mov	x0, x24
 112bd94:	d63f0340 	blr	x26
	mp_to_unsigned_bin2(s, sig + SM2_INT_SIZE_BYTES, SM2_INT_SIZE_BYTES);
 112bd98:	a949eaa1 	ldp	x1, x26, [x21, #152]
 112bd9c:	f9404ff8 	ldr	x24, [sp, #152]
 112bda0:	aa1803e0 	mov	x0, x24
 112bda4:	d63f0020 	blr	x1
 112bda8:	cb000261 	sub	x1, x19, x0
 112bdac:	8b0102e1 	add	x1, x23, x1
 112bdb0:	aa1803e0 	mov	x0, x24
 112bdb4:	d63f0340 	blr	x26
 112bdb8:	17ffff9f 	b	112bc34 <sm2_ltc_dsa_sign+0x118>
		res = TEE_ERROR_OUT_OF_MEMORY;
 112bdbc:	129ffe74 	mov	w20, #0xffff000c            	// #-65524
 112bdc0:	17ffff9d 	b	112bc34 <sm2_ltc_dsa_sign+0x118>
		return TEE_ERROR_OUT_OF_MEMORY;
 112bdc4:	129ffe74 	mov	w20, #0xffff000c            	// #-65524
 112bdc8:	17ffff70 	b	112bb88 <sm2_ltc_dsa_sign+0x6c>

000000000112bdcc <sm2_ltc_dsa_verify>:
 * GM/T 0003.12012 Part1 2 Section 7.1
 */
TEE_Result sm2_ltc_dsa_verify(uint32_t algo, struct ecc_public_key *key,
			      const uint8_t *msg, size_t msg_len,
			      const uint8_t *sig, size_t sig_len)
{
 112bdcc:	a9a77bfd 	stp	x29, x30, [sp, #-400]!
 112bdd0:	910003fd 	mov	x29, sp
 112bdd4:	a9025bf5 	stp	x21, x22, [sp, #32]
	TEE_Result res = TEE_SUCCESS;
	ecc_key ltc_key = { };
 112bdd8:	910263f5 	add	x21, sp, #0x98
{
 112bddc:	aa0103f6 	mov	x22, x1
	ecc_key ltc_key = { };
 112bde0:	52800001 	mov	w1, #0x0                   	// #0
{
 112bde4:	a90153f3 	stp	x19, x20, [sp, #16]
 112bde8:	aa0503f4 	mov	x20, x5
 112bdec:	aa0403f3 	mov	x19, x4
 112bdf0:	a90363f7 	stp	x23, x24, [sp, #48]
 112bdf4:	aa0203f8 	mov	x24, x2
	ecc_key ltc_key = { };
 112bdf8:	d2801f02 	mov	x2, #0xf8                  	// #248
{
 112bdfc:	a9046bf9 	stp	x25, x26, [sp, #64]
 112be00:	2a0003fa 	mov	w26, w0
 112be04:	aa0303f9 	mov	x25, x3
	ecc_key ltc_key = { };
 112be08:	aa1503e0 	mov	x0, x21
 112be0c:	94005fb5 	bl	1143ce0 <memset>
	int ltc_res = 0;
	void *rprime = NULL;
	void *sprime = NULL;
 112be10:	a905ffff 	stp	xzr, xzr, [sp, #88]
	void *ma = NULL;
	void *eprime = NULL;
	void *R = NULL;
	ecc_point *x1y1p = NULL;

	if (sig_len != 64)
 112be14:	f101029f 	cmp	x20, #0x40
	void *mp = NULL;
 112be18:	a906ffff 	stp	xzr, xzr, [sp, #104]
	void *ma = NULL;
 112be1c:	a907ffff 	stp	xzr, xzr, [sp, #120]
	void *R = NULL;
 112be20:	a908ffff 	stp	xzr, xzr, [sp, #136]
	if (sig_len != 64)
 112be24:	540011c1 	b.ne	112c05c <sm2_ltc_dsa_verify+0x290>  // b.any
		return TEE_ERROR_BAD_PARAMETERS;

	ltc_res = mp_init_multi(&rprime, &sprime, &t, &mu, &ma, &eprime, &R,
 112be28:	910243e6 	add	x6, sp, #0x90
 112be2c:	910223e5 	add	x5, sp, #0x88
 112be30:	910203e4 	add	x4, sp, #0x80
 112be34:	9101e3e3 	add	x3, sp, #0x78
 112be38:	9101a3e2 	add	x2, sp, #0x68
 112be3c:	910183e1 	add	x1, sp, #0x60
 112be40:	910163e0 	add	x0, sp, #0x58
 112be44:	d2800007 	mov	x7, #0x0                   	// #0
 112be48:	9400181b 	bl	1131eb4 <ltc_init_multi>
				NULL);
	if (ltc_res != CRYPT_OK)
 112be4c:	350010c0 	cbnz	w0, 112c064 <sm2_ltc_dsa_verify+0x298>
		return TEE_ERROR_OUT_OF_MEMORY;

	mp_read_unsigned_bin(rprime, (unsigned char *)sig, 32);
 112be50:	f0000177 	adrp	x23, 115a000 <__scattered_array_1phys_mem_map+0x8>
 112be54:	aa1303e1 	mov	x1, x19
 112be58:	f9402fe0 	ldr	x0, [sp, #88]
 112be5c:	d2800402 	mov	x2, #0x20                  	// #32
 112be60:	f941d6f4 	ldr	x20, [x23, #936]
 112be64:	f9405683 	ldr	x3, [x20, #168]
 112be68:	d63f0060 	blr	x3
	mp_read_unsigned_bin(sprime, (unsigned char *)sig + 32, 32);
 112be6c:	f94033e0 	ldr	x0, [sp, #96]
 112be70:	d2800402 	mov	x2, #0x20                  	// #32
 112be74:	f9405683 	ldr	x3, [x20, #168]
 112be78:	8b020261 	add	x1, x19, x2
 112be7c:	d63f0060 	blr	x3

	res = ecc_populate_ltc_public_key(&ltc_key, key, algo, NULL);
 112be80:	aa1603e1 	mov	x1, x22
 112be84:	2a1a03e2 	mov	w2, w26
 112be88:	aa1503e0 	mov	x0, x21
 112be8c:	d2800003 	mov	x3, #0x0                   	// #0
 112be90:	aa1703f6 	mov	x22, x23
 112be94:	97fff94d 	bl	112a3c8 <ecc_populate_ltc_public_key>
 112be98:	2a0003f3 	mov	w19, w0
	if (res)
 112be9c:	35000d20 	cbnz	w0, 112c040 <sm2_ltc_dsa_verify+0x274>
		goto out;

	/* Step B1: verify r' in [1, n - 1] */

	if (mp_cmp_d(rprime, 1) == LTC_MP_LT ||
 112bea0:	f9402fe0 	ldr	x0, [sp, #88]
 112bea4:	d2800021 	mov	x1, #0x1                   	// #1
 112bea8:	f9403682 	ldr	x2, [x20, #104]
 112beac:	d63f0040 	blr	x2
 112beb0:	3100041f 	cmn	w0, #0x1
 112beb4:	54000301 	b.ne	112bf14 <sm2_ltc_dsa_verify+0x148>  // b.any
	ecc_point *x1y1p = NULL;
 112beb8:	d2800014 	mov	x20, #0x0                   	// #0
	    mp_cmp(rprime, ltc_key.dp.order) != LTC_MP_LT) {
		res = TEE_ERROR_SIGNATURE_INVALID;
 112bebc:	1299f1b3 	mov	w19, #0xffff3072            	// #-53134
		goto out;
	}
	if (mp_cmp(R, rprime) != LTC_MP_EQ)
		res = TEE_ERROR_SIGNATURE_INVALID;
out:
	mp_montgomery_free(mp);
 112bec0:	f941d6d6 	ldr	x22, [x22, #936]
 112bec4:	f9403be0 	ldr	x0, [sp, #112]
 112bec8:	f940a6c1 	ldr	x1, [x22, #328]
 112becc:	d63f0020 	blr	x1
	ltc_ecc_del_point(x1y1p);
 112bed0:	aa1403e0 	mov	x0, x20
 112bed4:	94002dee 	bl	113768c <ltc_ecc_del_point>
	ecc_free(&ltc_key);
 112bed8:	aa1503e0 	mov	x0, x21
 112bedc:	94002578 	bl	11354bc <ecc_free>
	mp_clear_multi(rprime, sprime, t, mu, ma, eprime, R, NULL);
 112bee0:	a94587e0 	ldp	x0, x1, [sp, #88]
 112bee4:	d2800007 	mov	x7, #0x0                   	// #0
 112bee8:	a94793e3 	ldp	x3, x4, [sp, #120]
 112beec:	a9489be5 	ldp	x5, x6, [sp, #136]
 112bef0:	f94037e2 	ldr	x2, [sp, #104]
 112bef4:	9400188a 	bl	113211c <ltc_deinit_multi>
	return res;
}
 112bef8:	2a1303e0 	mov	w0, w19
 112befc:	a94153f3 	ldp	x19, x20, [sp, #16]
 112bf00:	a9425bf5 	ldp	x21, x22, [sp, #32]
 112bf04:	a94363f7 	ldp	x23, x24, [sp, #48]
 112bf08:	a9446bf9 	ldp	x25, x26, [sp, #64]
 112bf0c:	a8d97bfd 	ldp	x29, x30, [sp], #400
 112bf10:	d65f03c0 	ret
	    mp_cmp(rprime, ltc_key.dp.order) != LTC_MP_LT) {
 112bf14:	f9402fe0 	ldr	x0, [sp, #88]
 112bf18:	f9403282 	ldr	x2, [x20, #96]
 112bf1c:	f94063e1 	ldr	x1, [sp, #192]
 112bf20:	d63f0040 	blr	x2
	if (mp_cmp_d(rprime, 1) == LTC_MP_LT ||
 112bf24:	3100041f 	cmn	w0, #0x1
 112bf28:	54fffc81 	b.ne	112beb8 <sm2_ltc_dsa_verify+0xec>  // b.any
	if (mp_cmp_d(sprime, 1) == LTC_MP_LT ||
 112bf2c:	f94033e0 	ldr	x0, [sp, #96]
 112bf30:	d2800021 	mov	x1, #0x1                   	// #1
 112bf34:	f9403682 	ldr	x2, [x20, #104]
 112bf38:	d63f0040 	blr	x2
 112bf3c:	3100041f 	cmn	w0, #0x1
 112bf40:	54fffbc0 	b.eq	112beb8 <sm2_ltc_dsa_verify+0xec>  // b.none
	    mp_cmp(sprime, ltc_key.dp.order) != LTC_MP_LT) {
 112bf44:	f9403282 	ldr	x2, [x20, #96]
 112bf48:	f94033e0 	ldr	x0, [sp, #96]
 112bf4c:	f94063e1 	ldr	x1, [sp, #192]
 112bf50:	d63f0040 	blr	x2
	if (mp_cmp_d(sprime, 1) == LTC_MP_LT ||
 112bf54:	3100041f 	cmn	w0, #0x1
 112bf58:	54fffb01 	b.ne	112beb8 <sm2_ltc_dsa_verify+0xec>  // b.any
	ltc_res = mp_addmod(rprime, sprime, ltc_key.dp.order, t);
 112bf5c:	a94587e0 	ldp	x0, x1, [sp, #88]
 112bf60:	f94037e3 	ldr	x3, [sp, #104]
 112bf64:	f94063e2 	ldr	x2, [sp, #192]
 112bf68:	f940ce84 	ldr	x4, [x20, #408]
 112bf6c:	d63f0080 	blr	x4
	if (ltc_res != CRYPT_OK) {
 112bf70:	350006c0 	cbnz	w0, 112c048 <sm2_ltc_dsa_verify+0x27c>
	if (mp_cmp_d(t, 0) == LTC_MP_EQ) {
 112bf74:	f9403682 	ldr	x2, [x20, #104]
 112bf78:	d2800001 	mov	x1, #0x0                   	// #0
 112bf7c:	f94037e0 	ldr	x0, [sp, #104]
 112bf80:	d63f0040 	blr	x2
 112bf84:	34fff9a0 	cbz	w0, 112beb8 <sm2_ltc_dsa_verify+0xec>
	x1y1p = ltc_ecc_new_point();
 112bf88:	94002dab 	bl	1137634 <ltc_ecc_new_point>
 112bf8c:	aa0003f4 	mov	x20, x0
	if (!x1y1p) {
 112bf90:	b4000620 	cbz	x0, 112c054 <sm2_ltc_dsa_verify+0x288>
	ltc_res = mp_montgomery_setup(ltc_key.dp.prime, &mp);
 112bf94:	f941d6f3 	ldr	x19, [x23, #936]
 112bf98:	9101c3e1 	add	x1, sp, #0x70
 112bf9c:	f94057e0 	ldr	x0, [sp, #168]
 112bfa0:	f9409a62 	ldr	x2, [x19, #304]
 112bfa4:	d63f0040 	blr	x2
	if (ltc_res != CRYPT_OK) {
 112bfa8:	35000520 	cbnz	w0, 112c04c <sm2_ltc_dsa_verify+0x280>
	ltc_res = mp_montgomery_normalization(mu, ltc_key.dp.prime);
 112bfac:	f9403fe0 	ldr	x0, [sp, #120]
 112bfb0:	f94057e1 	ldr	x1, [sp, #168]
 112bfb4:	f9409e62 	ldr	x2, [x19, #312]
 112bfb8:	d63f0040 	blr	x2
	if (ltc_res != CRYPT_OK) {
 112bfbc:	35000480 	cbnz	w0, 112c04c <sm2_ltc_dsa_verify+0x280>
	ltc_res = mp_mulmod(ltc_key.dp.A, mu, ltc_key.dp.prime, ma);
 112bfc0:	a9478fe1 	ldp	x1, x3, [sp, #120]
 112bfc4:	a94a83e2 	ldp	x2, x0, [sp, #168]
 112bfc8:	f9408e64 	ldr	x4, [x19, #280]
 112bfcc:	d63f0080 	blr	x4
	if (ltc_res != CRYPT_OK) {
 112bfd0:	350003e0 	cbnz	w0, 112c04c <sm2_ltc_dsa_verify+0x280>
	ltc_res = ltc_ecc_mul2add(&ltc_key.dp.base, sprime, &ltc_key.pubkey, t,
 112bfd4:	a9460fe1 	ldp	x1, x3, [sp, #96]
 112bfd8:	aa1403e4 	mov	x4, x20
 112bfdc:	f94043e5 	ldr	x5, [sp, #128]
 112bfe0:	910362a2 	add	x2, x21, #0xd8
 112bfe4:	f94057e6 	ldr	x6, [sp, #168]
 112bfe8:	9100c2a0 	add	x0, x21, #0x30
 112bfec:	94002c2e 	bl	11370a4 <ltc_ecc_mul2add>
	if (ltc_res != CRYPT_OK) {
 112bff0:	350002e0 	cbnz	w0, 112c04c <sm2_ltc_dsa_verify+0x280>
	mp_read_unsigned_bin(eprime, (unsigned char *)msg, msg_len);
 112bff4:	f94047e0 	ldr	x0, [sp, #136]
 112bff8:	aa1903e2 	mov	x2, x25
 112bffc:	f9405663 	ldr	x3, [x19, #168]
 112c000:	aa1803e1 	mov	x1, x24
 112c004:	d63f0060 	blr	x3
	ltc_res = mp_addmod(eprime, x1y1p->x, ltc_key.dp.order, R);
 112c008:	a9488fe0 	ldp	x0, x3, [sp, #136]
 112c00c:	f9400281 	ldr	x1, [x20]
 112c010:	f94063e2 	ldr	x2, [sp, #192]
 112c014:	f940ce64 	ldr	x4, [x19, #408]
 112c018:	d63f0080 	blr	x4
	if (ltc_res != CRYPT_OK) {
 112c01c:	35000180 	cbnz	w0, 112c04c <sm2_ltc_dsa_verify+0x280>
	if (mp_cmp(R, rprime) != LTC_MP_EQ)
 112c020:	f9402fe1 	ldr	x1, [sp, #88]
 112c024:	f9403262 	ldr	x2, [x19, #96]
		res = TEE_ERROR_SIGNATURE_INVALID;
 112c028:	1299f1b3 	mov	w19, #0xffff3072            	// #-53134
	if (mp_cmp(R, rprime) != LTC_MP_EQ)
 112c02c:	f9404be0 	ldr	x0, [sp, #144]
 112c030:	d63f0040 	blr	x2
		res = TEE_ERROR_SIGNATURE_INVALID;
 112c034:	7100001f 	cmp	w0, #0x0
 112c038:	1a9303f3 	csel	w19, wzr, w19, eq  // eq = none
 112c03c:	17ffffa1 	b	112bec0 <sm2_ltc_dsa_verify+0xf4>
	ecc_point *x1y1p = NULL;
 112c040:	d2800014 	mov	x20, #0x0                   	// #0
 112c044:	17ffff9f 	b	112bec0 <sm2_ltc_dsa_verify+0xf4>
 112c048:	d2800014 	mov	x20, #0x0                   	// #0
		res = TEE_ERROR_BAD_STATE;
 112c04c:	129fff13 	mov	w19, #0xffff0007            	// #-65529
 112c050:	17ffff9c 	b	112bec0 <sm2_ltc_dsa_verify+0xf4>
		res = TEE_ERROR_OUT_OF_MEMORY;
 112c054:	129ffe73 	mov	w19, #0xffff000c            	// #-65524
 112c058:	17ffff9a 	b	112bec0 <sm2_ltc_dsa_verify+0xf4>
		return TEE_ERROR_BAD_PARAMETERS;
 112c05c:	129fff33 	mov	w19, #0xffff0006            	// #-65530
 112c060:	17ffffa6 	b	112bef8 <sm2_ltc_dsa_verify+0x12c>
		return TEE_ERROR_OUT_OF_MEMORY;
 112c064:	129ffe73 	mov	w19, #0xffff000c            	// #-65524
 112c068:	17ffffa4 	b	112bef8 <sm2_ltc_dsa_verify+0x12c>

000000000112c06c <sm2_ltc_pke_decrypt>:
 * GM/T 0003.12012 Part 4 Section 7.1
 * Decryption algorithm
 */
TEE_Result sm2_ltc_pke_decrypt(struct ecc_keypair *key, const uint8_t *src,
			       size_t src_len, uint8_t *dst, size_t *dst_len)
{
 112c06c:	a9a17bfd 	stp	x29, x30, [sp, #-496]!
 112c070:	910003fd 	mov	x29, sp
 112c074:	a9046bf9 	stp	x25, x26, [sp, #64]
	TEE_Result res = TEE_SUCCESS;
	uint8_t x2y2[64] = { };
	ecc_key ltc_key = { };
 112c078:	9103e3fa 	add	x26, sp, #0xf8
{
 112c07c:	a90153f3 	stp	x19, x20, [sp, #16]
 112c080:	aa0003f3 	mov	x19, x0
	ecc_key ltc_key = { };
 112c084:	aa1a03e0 	mov	x0, x26
{
 112c088:	a9025bf5 	stp	x21, x22, [sp, #32]
 112c08c:	a90363f7 	stp	x23, x24, [sp, #48]
 112c090:	aa0403f7 	mov	x23, x4
 112c094:	a90573fb 	stp	x27, x28, [sp, #80]
 112c098:	a9068be1 	stp	x1, x2, [sp, #104]
	ecc_key ltc_key = { };
 112c09c:	d2801f02 	mov	x2, #0xf8                  	// #248
 112c0a0:	52800001 	mov	w1, #0x0                   	// #0
{
 112c0a4:	f9003fe3 	str	x3, [sp, #120]
	uint8_t x2y2[64] = { };
 112c0a8:	a90bffff 	stp	xzr, xzr, [sp, #184]
 112c0ac:	a90cffff 	stp	xzr, xzr, [sp, #200]
 112c0b0:	a90dffff 	stp	xzr, xzr, [sp, #216]
 112c0b4:	a90effff 	stp	xzr, xzr, [sp, #232]
	ecc_key ltc_key = { };
 112c0b8:	94005f0a 	bl	1143ce0 <memset>
	 * - C1 represents a point (should be on the curve)
	 * - C2 is the encrypted message
	 * - C3 is a SM3 hash
	 */

	res = ecc_populate_ltc_private_key(&ltc_key, key, TEE_ALG_SM2_PKE,
 112c0bc:	528008a2 	mov	w2, #0x45                  	// #69
 112c0c0:	aa1303e1 	mov	x1, x19
 112c0c4:	aa1a03e0 	mov	x0, x26
 112c0c8:	d2800003 	mov	x3, #0x0                   	// #0
 112c0cc:	72b00002 	movk	w2, #0x8000, lsl #16
	int inf = 0;
 112c0d0:	b90087ff 	str	wzr, [sp, #132]
	void *h = NULL;
 112c0d4:	a908ffff 	stp	xzr, xzr, [sp, #136]
	uint8_t u[TEE_SM3_HASH_SIZE] = { };
 112c0d8:	a909ffff 	stp	xzr, xzr, [sp, #152]
 112c0dc:	a90affff 	stp	xzr, xzr, [sp, #168]
	res = ecc_populate_ltc_private_key(&ltc_key, key, TEE_ALG_SM2_PKE,
 112c0e0:	97fff846 	bl	112a1f8 <ecc_populate_ltc_private_key>
					   NULL);
	if (res)
 112c0e4:	350021e0 	cbnz	w0, 112c520 <sm2_ltc_pke_decrypt+0x4b4>
		goto out;

	/* Step B1: read and validate point C1 from encrypted message */

	C1 = ltc_ecc_new_point();
 112c0e8:	94002d53 	bl	1137634 <ltc_ecc_new_point>
 112c0ec:	aa0003f5 	mov	x21, x0
	if (!C1) {
 112c0f0:	b4002260 	cbz	x0, 112c53c <sm2_ltc_pke_decrypt+0x4d0>
	if (!max_size)
 112c0f4:	f9403be0 	ldr	x0, [sp, #112]
 112c0f8:	b4002640 	cbz	x0, 112c5c0 <sm2_ltc_pke_decrypt+0x554>
	PC = buf[0];
 112c0fc:	f94037e0 	ldr	x0, [sp, #104]
 112c100:	39400000 	ldrb	w0, [x0]
	switch (PC) {
 112c104:	7100101f 	cmp	w0, #0x4
 112c108:	540004e0 	b.eq	112c1a4 <sm2_ltc_pke_decrypt+0x138>  // b.none
 112c10c:	54000488 	b.hi	112c19c <sm2_ltc_pke_decrypt+0x130>  // b.pmore
 112c110:	51000800 	sub	w0, w0, #0x2
 112c114:	12001c00 	and	w0, w0, #0xff
	uint8_t *eom = NULL;
 112c118:	129ffebc 	mov	w28, #0xffff000a            	// #-65526
 112c11c:	7100081f 	cmp	w0, #0x2
 112c120:	129fff20 	mov	w0, #0xffff0006            	// #-65530
 112c124:	1a80339c 	csel	w28, w28, w0, cc  // cc = lo, ul, last
 112c128:	d2800017 	mov	x23, #0x0                   	// #0
 112c12c:	d280001b 	mov	x27, #0x0                   	// #0
 112c130:	d2800013 	mov	x19, #0x0                   	// #0
 112c134:	d2800014 	mov	x20, #0x0                   	// #0
	if (consttime_memcmp(u, src + C1_len + C2_len, TEE_SM3_HASH_SIZE)) {
		res = TEE_ERROR_CIPHERTEXT_INVALID;
		goto out;
	}
out:
	free(eom);
 112c138:	aa1703e0 	mov	x0, x23
 112c13c:	94005d29 	bl	11435e0 <free>
	free(t);
 112c140:	aa1b03e0 	mov	x0, x27
 112c144:	94005d27 	bl	11435e0 <free>
	crypto_hash_free_ctx(ctx);
 112c148:	f94047e0 	ldr	x0, [sp, #136]
 112c14c:	97ff8451 	bl	110d290 <crypto_hash_free_ctx>
	ltc_ecc_del_point(x2y2p);
 112c150:	aa1303e0 	mov	x0, x19
 112c154:	94002d4e 	bl	113768c <ltc_ecc_del_point>
	ltc_ecc_del_point(S);
 112c158:	aa1403e0 	mov	x0, x20
 112c15c:	94002d4c 	bl	113768c <ltc_ecc_del_point>
	ltc_ecc_del_point(C1);
 112c160:	aa1503e0 	mov	x0, x21
 112c164:	94002d4a 	bl	113768c <ltc_ecc_del_point>
	mp_clear_multi(h, NULL);
 112c168:	f9404be0 	ldr	x0, [sp, #144]
 112c16c:	d2800001 	mov	x1, #0x0                   	// #0
 112c170:	940017eb 	bl	113211c <ltc_deinit_multi>
	ecc_free(&ltc_key);
 112c174:	aa1a03e0 	mov	x0, x26
 112c178:	940024d1 	bl	11354bc <ecc_free>
	return res;
}
 112c17c:	2a1c03e0 	mov	w0, w28
 112c180:	a94153f3 	ldp	x19, x20, [sp, #16]
 112c184:	a9425bf5 	ldp	x21, x22, [sp, #32]
 112c188:	a94363f7 	ldp	x23, x24, [sp, #48]
 112c18c:	a9446bf9 	ldp	x25, x26, [sp, #64]
 112c190:	a94573fb 	ldp	x27, x28, [sp, #80]
 112c194:	a8df7bfd 	ldp	x29, x30, [sp], #496
 112c198:	d65f03c0 	ret
	switch (PC) {
 112c19c:	51001800 	sub	w0, w0, #0x6
 112c1a0:	17ffffdd 	b	112c114 <sm2_ltc_pke_decrypt+0xa8>
		return sm2_uncompressed_bytes_to_point(p, dp, buf + 1,
 112c1a4:	f94037e0 	ldr	x0, [sp, #104]
 112c1a8:	91000401 	add	x1, x0, #0x1
	uint8_t one[] = { 1 };
 112c1ac:	52800020 	mov	w0, #0x1                   	// #1
 112c1b0:	390203e0 	strb	w0, [sp, #128]
		return sm2_uncompressed_bytes_to_point(p, dp, buf + 1,
 112c1b4:	f9403be0 	ldr	x0, [sp, #112]
 112c1b8:	d1000400 	sub	x0, x0, #0x1
	if (max_size < (size_t)(2 * SM2_INT_SIZE_BYTES))
 112c1bc:	f100fc1f 	cmp	x0, #0x3f
 112c1c0:	54002009 	b.ls	112c5c0 <sm2_ltc_pke_decrypt+0x554>  // b.plast
	ltc_res = mp_read_unsigned_bin(p->x, ptr, SM2_INT_SIZE_BYTES);
 112c1c4:	d0000179 	adrp	x25, 115a000 <__scattered_array_1phys_mem_map+0x8>
 112c1c8:	d2800402 	mov	x2, #0x20                  	// #32
 112c1cc:	f94002a0 	ldr	x0, [x21]
 112c1d0:	aa1903f6 	mov	x22, x25
 112c1d4:	f941d733 	ldr	x19, [x25, #936]
 112c1d8:	f9405663 	ldr	x3, [x19, #168]
 112c1dc:	d63f0060 	blr	x3
	if (ltc_res != CRYPT_OK)
 112c1e0:	35001f00 	cbnz	w0, 112c5c0 <sm2_ltc_pke_decrypt+0x554>
	ltc_res = mp_read_unsigned_bin(p->y, ptr, SM2_INT_SIZE_BYTES);
 112c1e4:	f94037e0 	ldr	x0, [sp, #104]
 112c1e8:	d2800402 	mov	x2, #0x20                  	// #32
 112c1ec:	f9405663 	ldr	x3, [x19, #168]
 112c1f0:	91008401 	add	x1, x0, #0x21
 112c1f4:	f94006a0 	ldr	x0, [x21, #8]
 112c1f8:	d63f0060 	blr	x3
	if (ltc_res != CRYPT_OK)
 112c1fc:	35001e20 	cbnz	w0, 112c5c0 <sm2_ltc_pke_decrypt+0x554>
	ltc_res = ltc_ecc_is_point(dp, p->x, p->y);
 112c200:	a9400aa1 	ldp	x1, x2, [x21]
 112c204:	91002340 	add	x0, x26, #0x8
 112c208:	94002924 	bl	1136698 <ltc_ecc_is_point>
	if (ltc_res != CRYPT_OK)
 112c20c:	35001da0 	cbnz	w0, 112c5c0 <sm2_ltc_pke_decrypt+0x554>
	mp_read_unsigned_bin(p->z, one, sizeof(one));
 112c210:	f9400aa0 	ldr	x0, [x21, #16]
 112c214:	910203e1 	add	x1, sp, #0x80
 112c218:	f9405663 	ldr	x3, [x19, #168]
 112c21c:	d2800022 	mov	x2, #0x1                   	// #1
 112c220:	d63f0060 	blr	x3
	if (ltc_key.dp.cofactor != 1) {
 112c224:	f940a3e0 	ldr	x0, [sp, #320]
 112c228:	f100041f 	cmp	x0, #0x1
 112c22c:	540014e0 	b.eq	112c4c8 <sm2_ltc_pke_decrypt+0x45c>  // b.none
		S = ltc_ecc_new_point();
 112c230:	94002d01 	bl	1137634 <ltc_ecc_new_point>
 112c234:	aa0003f4 	mov	x20, x0
		if (!S) {
 112c238:	b40018e0 	cbz	x0, 112c554 <sm2_ltc_pke_decrypt+0x4e8>
		ltc_res = mp_init_multi(&h, NULL);
 112c23c:	910243e0 	add	x0, sp, #0x90
 112c240:	d2800001 	mov	x1, #0x0                   	// #0
 112c244:	9400171c 	bl	1131eb4 <ltc_init_multi>
		if (ltc_res != CRYPT_OK) {
 112c248:	35001860 	cbnz	w0, 112c554 <sm2_ltc_pke_decrypt+0x4e8>
		ltc_res = mp_set_int(h, ltc_key.dp.cofactor);
 112c24c:	f941d720 	ldr	x0, [x25, #936]
 112c250:	f940a3e1 	ldr	x1, [sp, #320]
 112c254:	f9402002 	ldr	x2, [x0, #64]
 112c258:	f9404be0 	ldr	x0, [sp, #144]
 112c25c:	d63f0040 	blr	x2
		if (ltc_res != CRYPT_OK) {
 112c260:	35001820 	cbnz	w0, 112c564 <sm2_ltc_pke_decrypt+0x4f8>
		ltc_res = ltc_ecc_mulmod(h, C1, S, ltc_key.dp.A,
 112c264:	a9508fe4 	ldp	x4, x3, [sp, #264]
 112c268:	aa1403e2 	mov	x2, x20
 112c26c:	f9404be0 	ldr	x0, [sp, #144]
 112c270:	aa1503e1 	mov	x1, x21
 112c274:	52800025 	mov	w5, #0x1                   	// #1
 112c278:	94002a49 	bl	1136b9c <ltc_ecc_mulmod>
		if (ltc_res != CRYPT_OK) {
 112c27c:	35001740 	cbnz	w0, 112c564 <sm2_ltc_pke_decrypt+0x4f8>
		ltc_res = ltc_ecc_is_point_at_infinity(S, ltc_key.dp.prime,
 112c280:	f94087e1 	ldr	x1, [sp, #264]
 112c284:	910213e2 	add	x2, sp, #0x84
 112c288:	aa1403e0 	mov	x0, x20
 112c28c:	9400297c 	bl	113687c <ltc_ecc_is_point_at_infinity>
	if (ltc_res != CRYPT_OK || inf) {
 112c290:	b94087e1 	ldr	w1, [sp, #132]
 112c294:	2a010000 	orr	w0, w0, w1
 112c298:	35001660 	cbnz	w0, 112c564 <sm2_ltc_pke_decrypt+0x4f8>
	x2y2p = ltc_ecc_new_point();
 112c29c:	94002ce6 	bl	1137634 <ltc_ecc_new_point>
 112c2a0:	aa0003f3 	mov	x19, x0
	if (!x2y2p) {
 112c2a4:	b40016a0 	cbz	x0, 112c578 <sm2_ltc_pke_decrypt+0x50c>
	ltc_res = ltc_ecc_mulmod(ltc_key.k, C1, x2y2p, ltc_key.dp.A,
 112c2a8:	a9508fe4 	ldp	x4, x3, [sp, #264]
 112c2ac:	aa0003e2 	mov	x2, x0
 112c2b0:	f940f7e0 	ldr	x0, [sp, #488]
 112c2b4:	aa1503e1 	mov	x1, x21
 112c2b8:	52800025 	mov	w5, #0x1                   	// #1
 112c2bc:	94002a38 	bl	1136b9c <ltc_ecc_mulmod>
	if (ltc_res != CRYPT_OK) {
 112c2c0:	35001620 	cbnz	w0, 112c584 <sm2_ltc_pke_decrypt+0x518>
	if (mp_unsigned_bin_size(x2y2p->x) > SM2_INT_SIZE_BYTES ||
 112c2c4:	f941d6d6 	ldr	x22, [x22, #936]
 112c2c8:	f9400260 	ldr	x0, [x19]
 112c2cc:	f9404ec1 	ldr	x1, [x22, #152]
 112c2d0:	d63f0020 	blr	x1
 112c2d4:	f100801f 	cmp	x0, #0x20
 112c2d8:	54001568 	b.hi	112c584 <sm2_ltc_pke_decrypt+0x518>  // b.pmore
	    mp_unsigned_bin_size(x2y2p->y) > SM2_INT_SIZE_BYTES) {
 112c2dc:	f9400660 	ldr	x0, [x19, #8]
 112c2e0:	f9404ec1 	ldr	x1, [x22, #152]
 112c2e4:	d63f0020 	blr	x1
	if (mp_unsigned_bin_size(x2y2p->x) > SM2_INT_SIZE_BYTES ||
 112c2e8:	f100801f 	cmp	x0, #0x20
 112c2ec:	540014c8 	b.hi	112c584 <sm2_ltc_pke_decrypt+0x518>  // b.pmore
	mp_to_unsigned_bin2(x2y2p->x, x2y2, SM2_INT_SIZE_BYTES);
 112c2f0:	a949e2c1 	ldp	x1, x24, [x22, #152]
 112c2f4:	9102e3f9 	add	x25, sp, #0xb8
 112c2f8:	f940027c 	ldr	x28, [x19]
 112c2fc:	aa1c03e0 	mov	x0, x28
 112c300:	d63f0020 	blr	x1
 112c304:	cb000321 	sub	x1, x25, x0
 112c308:	91008021 	add	x1, x1, #0x20
 112c30c:	aa1c03e0 	mov	x0, x28
 112c310:	d63f0300 	blr	x24
	mp_to_unsigned_bin2(x2y2p->y, x2y2 + SM2_INT_SIZE_BYTES,
 112c314:	d280081c 	mov	x28, #0x40                  	// #64
 112c318:	a949e2c1 	ldp	x1, x24, [x22, #152]
 112c31c:	f940067b 	ldr	x27, [x19, #8]
 112c320:	aa1b03e0 	mov	x0, x27
 112c324:	d63f0020 	blr	x1
 112c328:	cb000381 	sub	x1, x28, x0
 112c32c:	8b010321 	add	x1, x25, x1
 112c330:	aa1b03e0 	mov	x0, x27
 112c334:	d63f0300 	blr	x24
	if (src_len <= C1_len + TEE_SM3_HASH_SIZE) {
 112c338:	f9403be0 	ldr	x0, [sp, #112]
 112c33c:	f101841f 	cmp	x0, #0x61
 112c340:	54001289 	b.ls	112c590 <sm2_ltc_pke_decrypt+0x524>  // b.plast
	C2_len = src_len - C1_len - TEE_SM3_HASH_SIZE;
 112c344:	d1018416 	sub	x22, x0, #0x61
	t = calloc(1, C2_len);
 112c348:	d2800020 	mov	x0, #0x1                   	// #1
 112c34c:	aa1603e1 	mov	x1, x22
 112c350:	94005c60 	bl	11434d0 <calloc>
 112c354:	aa0003fb 	mov	x27, x0
	if (!t) {
 112c358:	b4001240 	cbz	x0, 112c5a0 <sm2_ltc_pke_decrypt+0x534>
	res = sm2_kdf(x2y2, sizeof(x2y2), t, C2_len);
 112c35c:	aa0003e2 	mov	x2, x0
 112c360:	aa1c03e1 	mov	x1, x28
 112c364:	aa1603e3 	mov	x3, x22
 112c368:	aa1903e0 	mov	x0, x25
 112c36c:	97ff8fab 	bl	1110218 <sm2_kdf>
 112c370:	2a0003fc 	mov	w28, w0
	if (res)
 112c374:	350011a0 	cbnz	w0, 112c5a8 <sm2_ltc_pke_decrypt+0x53c>
	uint8_t v = 0;
 112c378:	52800001 	mov	w1, #0x0                   	// #0
	for (i = 0; i < size; i++)
 112c37c:	d2800000 	mov	x0, #0x0                   	// #0
		v |= buf[i];
 112c380:	38606b62 	ldrb	w2, [x27, x0]
	for (i = 0; i < size; i++)
 112c384:	91000400 	add	x0, x0, #0x1
 112c388:	eb0002df 	cmp	x22, x0
		v |= buf[i];
 112c38c:	2a010041 	orr	w1, w2, w1
	for (i = 0; i < size; i++)
 112c390:	54ffff88 	b.hi	112c380 <sm2_ltc_pke_decrypt+0x314>  // b.pmore
	if (is_zero(t, C2_len)) {
 112c394:	340010e1 	cbz	w1, 112c5b0 <sm2_ltc_pke_decrypt+0x544>
	out_len = MIN(*dst_len, C2_len);
 112c398:	f94002e5 	ldr	x5, [x23]
	for (i = 0; i < out_len; i++)
 112c39c:	d2800000 	mov	x0, #0x0                   	// #0
		dst[i] = src[C1_len + i] ^ t[i];
 112c3a0:	f94037e1 	ldr	x1, [sp, #104]
	out_len = MIN(*dst_len, C2_len);
 112c3a4:	eb1600bf 	cmp	x5, x22
 112c3a8:	9a9690b8 	csel	x24, x5, x22, ls  // ls = plast
		dst[i] = src[C1_len + i] ^ t[i];
 112c3ac:	91010422 	add	x2, x1, #0x41
	for (i = 0; i < out_len; i++)
 112c3b0:	eb18001f 	cmp	x0, x24
 112c3b4:	54000961 	b.ne	112c4e0 <sm2_ltc_pke_decrypt+0x474>  // b.any
	*dst_len = out_len;
 112c3b8:	f90002f8 	str	x24, [x23]
	if (out_len < C2_len) {
 112c3bc:	eb1802df 	cmp	x22, x24
 112c3c0:	540009e9 	b.ls	112c4fc <sm2_ltc_pke_decrypt+0x490>  // b.plast
		eom = calloc(1, C2_len - out_len);
 112c3c4:	cb1802c1 	sub	x1, x22, x24
 112c3c8:	d2800020 	mov	x0, #0x1                   	// #1
 112c3cc:	94005c41 	bl	11434d0 <calloc>
 112c3d0:	aa0003f7 	mov	x23, x0
		if (!eom) {
 112c3d4:	b4000bc0 	cbz	x0, 112c54c <sm2_ltc_pke_decrypt+0x4e0>
		       eom[i - out_len] = src[C1_len + i] ^ t[i];
 112c3d8:	f94037e1 	ldr	x1, [sp, #104]
 112c3dc:	aa1803e0 	mov	x0, x24
 112c3e0:	cb1802e2 	sub	x2, x23, x24
 112c3e4:	91010427 	add	x7, x1, #0x41
 112c3e8:	386068e1 	ldrb	w1, [x7, x0]
 112c3ec:	38606b66 	ldrb	w6, [x27, x0]
 112c3f0:	4a060021 	eor	w1, w1, w6
 112c3f4:	38206841 	strb	w1, [x2, x0]
		for (i = out_len; i < C2_len; i++)
 112c3f8:	91000400 	add	x0, x0, #0x1
 112c3fc:	eb0002df 	cmp	x22, x0
 112c400:	54ffff48 	b.hi	112c3e8 <sm2_ltc_pke_decrypt+0x37c>  // b.pmore
	res = crypto_hash_alloc_ctx(&ctx, TEE_ALG_SM3);
 112c404:	528000e1 	mov	w1, #0x7                   	// #7
 112c408:	910223e0 	add	x0, sp, #0x88
 112c40c:	72aa0001 	movk	w1, #0x5000, lsl #16
 112c410:	97ff837b 	bl	110d1fc <crypto_hash_alloc_ctx>
 112c414:	2a0003fc 	mov	w28, w0
	if (res)
 112c418:	35ffe900 	cbnz	w0, 112c138 <sm2_ltc_pke_decrypt+0xcc>
	res = crypto_hash_init(ctx);
 112c41c:	f94047e0 	ldr	x0, [sp, #136]
 112c420:	97ff83b6 	bl	110d2f8 <crypto_hash_init>
 112c424:	2a0003fc 	mov	w28, w0
	if (res)
 112c428:	35ffe880 	cbnz	w0, 112c138 <sm2_ltc_pke_decrypt+0xcc>
	res = crypto_hash_update(ctx, x2y2, SM2_INT_SIZE_BYTES);
 112c42c:	f94047e0 	ldr	x0, [sp, #136]
 112c430:	aa1903e1 	mov	x1, x25
 112c434:	d2800402 	mov	x2, #0x20                  	// #32
 112c438:	97ff83bb 	bl	110d324 <crypto_hash_update>
 112c43c:	2a0003fc 	mov	w28, w0
	if (res)
 112c440:	35ffe7c0 	cbnz	w0, 112c138 <sm2_ltc_pke_decrypt+0xcc>
	res = crypto_hash_update(ctx, dst, out_len);
 112c444:	f9403fe1 	ldr	x1, [sp, #120]
 112c448:	aa1803e2 	mov	x2, x24
 112c44c:	f94047e0 	ldr	x0, [sp, #136]
 112c450:	97ff83b5 	bl	110d324 <crypto_hash_update>
 112c454:	2a0003fc 	mov	w28, w0
	if (res)
 112c458:	35ffe700 	cbnz	w0, 112c138 <sm2_ltc_pke_decrypt+0xcc>
	if (out_len < C2_len) {
 112c45c:	eb1802df 	cmp	x22, x24
 112c460:	54000528 	b.hi	112c504 <sm2_ltc_pke_decrypt+0x498>  // b.pmore
	res = crypto_hash_update(ctx, x2y2 + SM2_INT_SIZE_BYTES,
 112c464:	f94047e0 	ldr	x0, [sp, #136]
 112c468:	d2800402 	mov	x2, #0x20                  	// #32
 112c46c:	8b020321 	add	x1, x25, x2
 112c470:	97ff83ad 	bl	110d324 <crypto_hash_update>
 112c474:	2a0003fc 	mov	w28, w0
	if (res)
 112c478:	35ffe600 	cbnz	w0, 112c138 <sm2_ltc_pke_decrypt+0xcc>
	res = crypto_hash_final(ctx, u, sizeof(u));
 112c47c:	f94047e0 	ldr	x0, [sp, #136]
 112c480:	910263f6 	add	x22, sp, #0x98
 112c484:	aa1603e1 	mov	x1, x22
 112c488:	d2800402 	mov	x2, #0x20                  	// #32
 112c48c:	97ff83b7 	bl	110d368 <crypto_hash_final>
 112c490:	2a0003fc 	mov	w28, w0
	if (res)
 112c494:	35ffe520 	cbnz	w0, 112c138 <sm2_ltc_pke_decrypt+0xcc>
	if (consttime_memcmp(u, src + C1_len + C2_len, TEE_SM3_HASH_SIZE)) {
 112c498:	f9403be0 	ldr	x0, [sp, #112]
 112c49c:	d2800402 	mov	x2, #0x20                  	// #32
		res = TEE_ERROR_CIPHERTEXT_INVALID;
 112c4a0:	528000dc 	mov	w28, #0x6                   	// #6
	if (consttime_memcmp(u, src + C1_len + C2_len, TEE_SM3_HASH_SIZE)) {
 112c4a4:	d1008001 	sub	x1, x0, #0x20
		res = TEE_ERROR_CIPHERTEXT_INVALID;
 112c4a8:	72be021c 	movk	w28, #0xf010, lsl #16
	if (consttime_memcmp(u, src + C1_len + C2_len, TEE_SM3_HASH_SIZE)) {
 112c4ac:	f94037e0 	ldr	x0, [sp, #104]
 112c4b0:	8b010001 	add	x1, x0, x1
 112c4b4:	aa1603e0 	mov	x0, x22
 112c4b8:	940062b6 	bl	1144f90 <consttime_memcmp>
		res = TEE_ERROR_CIPHERTEXT_INVALID;
 112c4bc:	7100001f 	cmp	w0, #0x0
 112c4c0:	1a9c03fc 	csel	w28, wzr, w28, eq  // eq = none
 112c4c4:	17ffff1d 	b	112c138 <sm2_ltc_pke_decrypt+0xcc>
		ltc_res = ltc_ecc_is_point_at_infinity(C1, ltc_key.dp.prime,
 112c4c8:	f94087e1 	ldr	x1, [sp, #264]
 112c4cc:	910213e2 	add	x2, sp, #0x84
 112c4d0:	aa1503e0 	mov	x0, x21
	ecc_point *S = NULL;
 112c4d4:	d2800014 	mov	x20, #0x0                   	// #0
		ltc_res = ltc_ecc_is_point_at_infinity(C1, ltc_key.dp.prime,
 112c4d8:	940028e9 	bl	113687c <ltc_ecc_is_point_at_infinity>
 112c4dc:	17ffff6d 	b	112c290 <sm2_ltc_pke_decrypt+0x224>
		dst[i] = src[C1_len + i] ^ t[i];
 112c4e0:	38606841 	ldrb	w1, [x2, x0]
 112c4e4:	38606b63 	ldrb	w3, [x27, x0]
 112c4e8:	4a030021 	eor	w1, w1, w3
 112c4ec:	f9403fe3 	ldr	x3, [sp, #120]
 112c4f0:	38206861 	strb	w1, [x3, x0]
	for (i = 0; i < out_len; i++)
 112c4f4:	91000400 	add	x0, x0, #0x1
 112c4f8:	17ffffae 	b	112c3b0 <sm2_ltc_pke_decrypt+0x344>
	uint8_t *eom = NULL;
 112c4fc:	d2800017 	mov	x23, #0x0                   	// #0
 112c500:	17ffffc1 	b	112c404 <sm2_ltc_pke_decrypt+0x398>
		res = crypto_hash_update(ctx, eom, C2_len - out_len);
 112c504:	f94047e0 	ldr	x0, [sp, #136]
 112c508:	cb1802c2 	sub	x2, x22, x24
 112c50c:	aa1703e1 	mov	x1, x23
 112c510:	97ff8385 	bl	110d324 <crypto_hash_update>
 112c514:	2a0003fc 	mov	w28, w0
		if (res)
 112c518:	34fffa60 	cbz	w0, 112c464 <sm2_ltc_pke_decrypt+0x3f8>
 112c51c:	17ffff07 	b	112c138 <sm2_ltc_pke_decrypt+0xcc>
 112c520:	2a0003fc 	mov	w28, w0
	uint8_t *eom = NULL;
 112c524:	d2800017 	mov	x23, #0x0                   	// #0
	uint8_t *t = NULL;
 112c528:	d280001b 	mov	x27, #0x0                   	// #0
	ecc_point *x2y2p = NULL;
 112c52c:	d2800013 	mov	x19, #0x0                   	// #0
	ecc_point *S = NULL;
 112c530:	d2800014 	mov	x20, #0x0                   	// #0
	ecc_point *C1 = NULL;
 112c534:	d2800015 	mov	x21, #0x0                   	// #0
 112c538:	17ffff00 	b	112c138 <sm2_ltc_pke_decrypt+0xcc>
	uint8_t *eom = NULL;
 112c53c:	d2800017 	mov	x23, #0x0                   	// #0
	uint8_t *t = NULL;
 112c540:	d280001b 	mov	x27, #0x0                   	// #0
	ecc_point *x2y2p = NULL;
 112c544:	d2800013 	mov	x19, #0x0                   	// #0
	ecc_point *S = NULL;
 112c548:	d2800014 	mov	x20, #0x0                   	// #0
			res = TEE_ERROR_OUT_OF_MEMORY;
 112c54c:	129ffe7c 	mov	w28, #0xffff000c            	// #-65524
 112c550:	17fffefa 	b	112c138 <sm2_ltc_pke_decrypt+0xcc>
	uint8_t *eom = NULL;
 112c554:	d2800017 	mov	x23, #0x0                   	// #0
	uint8_t *t = NULL;
 112c558:	d280001b 	mov	x27, #0x0                   	// #0
	ecc_point *x2y2p = NULL;
 112c55c:	d2800013 	mov	x19, #0x0                   	// #0
 112c560:	17fffffb 	b	112c54c <sm2_ltc_pke_decrypt+0x4e0>
	uint8_t *eom = NULL;
 112c564:	d2800017 	mov	x23, #0x0                   	// #0
	uint8_t *t = NULL;
 112c568:	d280001b 	mov	x27, #0x0                   	// #0
	ecc_point *x2y2p = NULL;
 112c56c:	d2800013 	mov	x19, #0x0                   	// #0
		res = TEE_ERROR_BAD_STATE;
 112c570:	129fff1c 	mov	w28, #0xffff0007            	// #-65529
 112c574:	17fffef1 	b	112c138 <sm2_ltc_pke_decrypt+0xcc>
	uint8_t *eom = NULL;
 112c578:	d2800017 	mov	x23, #0x0                   	// #0
	uint8_t *t = NULL;
 112c57c:	d280001b 	mov	x27, #0x0                   	// #0
 112c580:	17fffff3 	b	112c54c <sm2_ltc_pke_decrypt+0x4e0>
	uint8_t *eom = NULL;
 112c584:	d2800017 	mov	x23, #0x0                   	// #0
	uint8_t *t = NULL;
 112c588:	d280001b 	mov	x27, #0x0                   	// #0
 112c58c:	17fffff9 	b	112c570 <sm2_ltc_pke_decrypt+0x504>
	uint8_t *eom = NULL;
 112c590:	d2800017 	mov	x23, #0x0                   	// #0
	uint8_t *t = NULL;
 112c594:	d280001b 	mov	x27, #0x0                   	// #0
 112c598:	129fff3c 	mov	w28, #0xffff0006            	// #-65530
 112c59c:	17fffee7 	b	112c138 <sm2_ltc_pke_decrypt+0xcc>
	uint8_t *eom = NULL;
 112c5a0:	d2800017 	mov	x23, #0x0                   	// #0
 112c5a4:	17ffffea 	b	112c54c <sm2_ltc_pke_decrypt+0x4e0>
 112c5a8:	d2800017 	mov	x23, #0x0                   	// #0
 112c5ac:	17fffee3 	b	112c138 <sm2_ltc_pke_decrypt+0xcc>
		res = TEE_ERROR_CIPHERTEXT_INVALID;
 112c5b0:	528000dc 	mov	w28, #0x6                   	// #6
	uint8_t *eom = NULL;
 112c5b4:	d2800017 	mov	x23, #0x0                   	// #0
		res = TEE_ERROR_CIPHERTEXT_INVALID;
 112c5b8:	72be021c 	movk	w28, #0xf010, lsl #16
 112c5bc:	17fffedf 	b	112c138 <sm2_ltc_pke_decrypt+0xcc>
	uint8_t *eom = NULL;
 112c5c0:	d2800017 	mov	x23, #0x0                   	// #0
	uint8_t *t = NULL;
 112c5c4:	d280001b 	mov	x27, #0x0                   	// #0
	ecc_point *x2y2p = NULL;
 112c5c8:	d2800013 	mov	x19, #0x0                   	// #0
	ecc_point *S = NULL;
 112c5cc:	d2800014 	mov	x20, #0x0                   	// #0
 112c5d0:	17fffff2 	b	112c598 <sm2_ltc_pke_decrypt+0x52c>

000000000112c5d4 <sm2_ltc_pke_encrypt>:
 * GM/T 0003.12012 Part 4 Section 6.1
 * Encryption algorithm
 */
TEE_Result sm2_ltc_pke_encrypt(struct ecc_public_key *key, const uint8_t *src,
			       size_t src_len, uint8_t *dst, size_t *dst_len)
{
 112c5d4:	a9a27bfd 	stp	x29, x30, [sp, #-480]!
 112c5d8:	910003fd 	mov	x29, sp
 112c5dc:	a9046bf9 	stp	x25, x26, [sp, #64]
	TEE_Result res = TEE_SUCCESS;
	ecc_key ltc_key = { };
 112c5e0:	9103a3f9 	add	x25, sp, #0xe8
{
 112c5e4:	aa0203fa 	mov	x26, x2
	ecc_key ltc_key = { };
 112c5e8:	d2801f02 	mov	x2, #0xf8                  	// #248
{
 112c5ec:	a90153f3 	stp	x19, x20, [sp, #16]
 112c5f0:	aa0003f3 	mov	x19, x0
	ecc_key ltc_key = { };
 112c5f4:	aa1903e0 	mov	x0, x25
{
 112c5f8:	a9025bf5 	stp	x21, x22, [sp, #32]
 112c5fc:	a90363f7 	stp	x23, x24, [sp, #48]
 112c600:	aa0303f8 	mov	x24, x3
 112c604:	a90573fb 	stp	x27, x28, [sp, #80]
 112c608:	aa0403fb 	mov	x27, x4
 112c60c:	f90037e1 	str	x1, [sp, #104]
	ecc_key ltc_key = { };
 112c610:	52800001 	mov	w1, #0x0                   	// #0
 112c614:	94005db3 	bl	1143ce0 <memset>
	uint8_t x2y2[64] = { };
	uint8_t *t = NULL;
	int ltc_res = 0;
	void *k = NULL;
	void *h = NULL;
	int inf = 0;
 112c618:	b9008fff 	str	wzr, [sp, #140]
	size_t C1_len = 0;
	void *ctx = NULL;
	size_t i = 0;

	ltc_res = mp_init_multi(&k, &h, NULL);
 112c61c:	910263e1 	add	x1, sp, #0x98
 112c620:	910243e0 	add	x0, sp, #0x90
 112c624:	d2800002 	mov	x2, #0x0                   	// #0
	void *h = NULL;
 112c628:	a9097fff 	stp	xzr, xzr, [sp, #144]
	uint8_t x2y2[64] = { };
 112c62c:	a90a7fff 	stp	xzr, xzr, [sp, #160]
 112c630:	a90b7fff 	stp	xzr, xzr, [sp, #176]
 112c634:	a90c7fff 	stp	xzr, xzr, [sp, #192]
 112c638:	a90d7fff 	stp	xzr, xzr, [sp, #208]
 112c63c:	f90073ff 	str	xzr, [sp, #224]
	ltc_res = mp_init_multi(&k, &h, NULL);
 112c640:	9400161d 	bl	1131eb4 <ltc_init_multi>
	if (ltc_res != CRYPT_OK)
 112c644:	35002460 	cbnz	w0, 112cad0 <sm2_ltc_pke_encrypt+0x4fc>
		return TEE_ERROR_OUT_OF_MEMORY;

	res = ecc_populate_ltc_public_key(&ltc_key, key, TEE_ALG_SM2_PKE, NULL);
 112c648:	d2800003 	mov	x3, #0x0                   	// #0
 112c64c:	528008a2 	mov	w2, #0x45                  	// #69
 112c650:	aa1303e1 	mov	x1, x19
 112c654:	aa1903e0 	mov	x0, x25
 112c658:	72b00002 	movk	w2, #0x8000, lsl #16
 112c65c:	97fff75b 	bl	112a3c8 <ecc_populate_ltc_public_key>
 112c660:	2a0003e3 	mov	w3, w0
	if (res)
 112c664:	35001fa0 	cbnz	w0, 112ca58 <sm2_ltc_pke_encrypt+0x484>
		goto out;

	/* Step A1: generate random number 1 <= k < n */

	ltc_res = rand_bn_upto(k, ltc_key.dp.order, NULL,
 112c668:	f9404bf3 	ldr	x19, [sp, #144]
 112c66c:	d0000140 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 112c670:	f9408bf4 	ldr	x20, [sp, #272]
 112c674:	9113d800 	add	x0, x0, #0x4f6
 112c678:	940017da 	bl	11325e0 <find_prng>
 112c67c:	2a0003e3 	mov	w3, w0
 112c680:	aa1403e1 	mov	x1, x20
 112c684:	aa1303e0 	mov	x0, x19
 112c688:	d2800002 	mov	x2, #0x0                   	// #0
 112c68c:	94001735 	bl	1132360 <rand_bn_upto>
			       find_prng("prng_crypto"));
	if (ltc_res != CRYPT_OK) {
 112c690:	35001ee0 	cbnz	w0, 112ca6c <sm2_ltc_pke_encrypt+0x498>
		goto out;
	}

	/* Step A2: compute C1 = [k]G */

	C1 = ltc_ecc_new_point();
 112c694:	94002be8 	bl	1137634 <ltc_ecc_new_point>
 112c698:	aa0003f5 	mov	x21, x0
	if (!C1) {
 112c69c:	b4001f40 	cbz	x0, 112ca84 <sm2_ltc_pke_encrypt+0x4b0>
		res = TEE_ERROR_OUT_OF_MEMORY;
		goto out;
	}

	ltc_res = ltc_ecc_mulmod(k, &ltc_key.dp.base, C1, ltc_key.dp.A,
 112c6a0:	a94f8fe4 	ldp	x4, x3, [sp, #248]
 112c6a4:	aa0003e2 	mov	x2, x0
 112c6a8:	f9404be0 	ldr	x0, [sp, #144]
 112c6ac:	9100c321 	add	x1, x25, #0x30
 112c6b0:	52800025 	mov	w5, #0x1                   	// #1
 112c6b4:	9400293a 	bl	1136b9c <ltc_ecc_mulmod>
				 ltc_key.dp.prime, 1);
	if (ltc_res != CRYPT_OK) {
 112c6b8:	35001f00 	cbnz	w0, 112ca98 <sm2_ltc_pke_encrypt+0x4c4>
		goto out;
	}

	/* Step A3: compute S = [h]PB and check for infinity */

	if (ltc_key.dp.cofactor != 1) {
 112c6bc:	f9409be0 	ldr	x0, [sp, #304]
 112c6c0:	f100041f 	cmp	x0, #0x1
 112c6c4:	54001540 	b.eq	112c96c <sm2_ltc_pke_encrypt+0x398>  // b.none
		S = ltc_ecc_new_point();
 112c6c8:	94002bdb 	bl	1137634 <ltc_ecc_new_point>
 112c6cc:	aa0003f6 	mov	x22, x0
		if (!S) {
 112c6d0:	b4001ea0 	cbz	x0, 112caa4 <sm2_ltc_pke_encrypt+0x4d0>
			res = TEE_ERROR_OUT_OF_MEMORY;
			goto out;
		}

		ltc_res = mp_set_int(h, ltc_key.dp.cofactor);
 112c6d4:	d0000177 	adrp	x23, 115a000 <__scattered_array_1phys_mem_map+0x8>
 112c6d8:	f9404fe0 	ldr	x0, [sp, #152]
 112c6dc:	f941d6f7 	ldr	x23, [x23, #936]
 112c6e0:	f9409be1 	ldr	x1, [sp, #304]
 112c6e4:	f94022e2 	ldr	x2, [x23, #64]
 112c6e8:	d63f0040 	blr	x2
		if (ltc_res != CRYPT_OK) {
 112c6ec:	35001e00 	cbnz	w0, 112caac <sm2_ltc_pke_encrypt+0x4d8>
			res = TEE_ERROR_BAD_STATE;
			goto out;
		}

		ltc_res = ltc_ecc_mulmod(h, &ltc_key.pubkey, S, ltc_key.dp.A,
 112c6f0:	a94f8fe4 	ldp	x4, x3, [sp, #248]
 112c6f4:	aa1603e2 	mov	x2, x22
 112c6f8:	f9404fe0 	ldr	x0, [sp, #152]
 112c6fc:	91036321 	add	x1, x25, #0xd8
 112c700:	52800025 	mov	w5, #0x1                   	// #1
 112c704:	94002926 	bl	1136b9c <ltc_ecc_mulmod>
					 ltc_key.dp.prime, 1);
		if (ltc_res != CRYPT_OK) {
 112c708:	35001d20 	cbnz	w0, 112caac <sm2_ltc_pke_encrypt+0x4d8>
			res = TEE_ERROR_BAD_STATE;
			goto out;
		}

		ltc_res = ltc_ecc_is_point_at_infinity(S, ltc_key.dp.prime,
 112c70c:	f9407fe1 	ldr	x1, [sp, #248]
 112c710:	910233e2 	add	x2, sp, #0x8c
 112c714:	aa1603e0 	mov	x0, x22
 112c718:	94002859 	bl	113687c <ltc_ecc_is_point_at_infinity>
	}
	if (ltc_res != CRYPT_OK) {
		res = TEE_ERROR_BAD_STATE;
		goto out;
	}
	if (inf) {
 112c71c:	b9408fe1 	ldr	w1, [sp, #140]
 112c720:	2a010000 	orr	w0, w0, w1
 112c724:	35001c40 	cbnz	w0, 112caac <sm2_ltc_pke_encrypt+0x4d8>
		goto out;
	}

	/* Step A4: compute (x2, y2) = [k]PB */

	x2y2p = ltc_ecc_new_point();
 112c728:	94002bc3 	bl	1137634 <ltc_ecc_new_point>
 112c72c:	aa0003f4 	mov	x20, x0
	if (!x2y2p) {
 112c730:	b4001c20 	cbz	x0, 112cab4 <sm2_ltc_pke_encrypt+0x4e0>
		res = TEE_ERROR_OUT_OF_MEMORY;
		goto out;
	}

	ltc_res = ltc_ecc_mulmod(k, &ltc_key.pubkey, x2y2p, ltc_key.dp.A,
 112c734:	a94f8fe4 	ldp	x4, x3, [sp, #248]
 112c738:	aa0003e2 	mov	x2, x0
 112c73c:	f9404be0 	ldr	x0, [sp, #144]
 112c740:	91036321 	add	x1, x25, #0xd8
 112c744:	52800025 	mov	w5, #0x1                   	// #1
 112c748:	94002915 	bl	1136b9c <ltc_ecc_mulmod>
				 ltc_key.dp.prime, 1);
	if (ltc_res != CRYPT_OK) {
 112c74c:	35001b80 	cbnz	w0, 112cabc <sm2_ltc_pke_encrypt+0x4e8>
		res = TEE_ERROR_BAD_STATE;
		goto out;
	}

	if (mp_unsigned_bin_size(x2y2p->x) > SM2_INT_SIZE_BYTES ||
 112c750:	d0000177 	adrp	x23, 115a000 <__scattered_array_1phys_mem_map+0x8>
 112c754:	f9400280 	ldr	x0, [x20]
 112c758:	f941d6f7 	ldr	x23, [x23, #936]
 112c75c:	f9404ee1 	ldr	x1, [x23, #152]
 112c760:	d63f0020 	blr	x1
 112c764:	f100801f 	cmp	x0, #0x20
 112c768:	54001aa8 	b.hi	112cabc <sm2_ltc_pke_encrypt+0x4e8>  // b.pmore
	    mp_unsigned_bin_size(x2y2p->y) > SM2_INT_SIZE_BYTES) {
 112c76c:	f9400680 	ldr	x0, [x20, #8]
 112c770:	f9404ee1 	ldr	x1, [x23, #152]
 112c774:	d63f0020 	blr	x1
	if (mp_unsigned_bin_size(x2y2p->x) > SM2_INT_SIZE_BYTES ||
 112c778:	f100801f 	cmp	x0, #0x20
 112c77c:	54001a08 	b.hi	112cabc <sm2_ltc_pke_encrypt+0x4e8>  // b.pmore
		res = TEE_ERROR_BAD_STATE;
		goto out;
	}

	mp_to_unsigned_bin2(x2y2p->x, x2y2, SM2_INT_SIZE_BYTES);
 112c780:	a9498ae1 	ldp	x1, x2, [x23, #152]
 112c784:	f90033e2 	str	x2, [sp, #96]
 112c788:	f9400293 	ldr	x19, [x20]
 112c78c:	9102a3fc 	add	x28, sp, #0xa8
 112c790:	aa1303e0 	mov	x0, x19
 112c794:	d63f0020 	blr	x1
 112c798:	cb000381 	sub	x1, x28, x0
 112c79c:	f94033e2 	ldr	x2, [sp, #96]
 112c7a0:	91008021 	add	x1, x1, #0x20
 112c7a4:	aa1303e0 	mov	x0, x19
 112c7a8:	d63f0040 	blr	x2
	mp_to_unsigned_bin2(x2y2p->y, x2y2 + SM2_INT_SIZE_BYTES,
 112c7ac:	a9498ae1 	ldp	x1, x2, [x23, #152]
 112c7b0:	f90033e2 	str	x2, [sp, #96]
 112c7b4:	f9400693 	ldr	x19, [x20, #8]
 112c7b8:	d2800817 	mov	x23, #0x40                  	// #64
 112c7bc:	aa1303e0 	mov	x0, x19
 112c7c0:	d63f0020 	blr	x1
 112c7c4:	cb0002e1 	sub	x1, x23, x0
 112c7c8:	f94033e2 	ldr	x2, [sp, #96]
 112c7cc:	8b010381 	add	x1, x28, x1
 112c7d0:	aa1303e0 	mov	x0, x19
 112c7d4:	d63f0040 	blr	x2
			    SM2_INT_SIZE_BYTES);

	/* Step A5: compute t = KDF(x2 || y2, klen) */

	t = calloc(1, src_len);
 112c7d8:	aa1a03e1 	mov	x1, x26
 112c7dc:	d2800020 	mov	x0, #0x1                   	// #1
 112c7e0:	94005b3c 	bl	11434d0 <calloc>
 112c7e4:	aa0003f3 	mov	x19, x0
	if (!t) {
 112c7e8:	b4001540 	cbz	x0, 112ca90 <sm2_ltc_pke_encrypt+0x4bc>
		res = TEE_ERROR_OUT_OF_MEMORY;
		goto out;
	}

	res = sm2_kdf(x2y2, sizeof(x2y2), t, src_len);
 112c7ec:	aa1a03e3 	mov	x3, x26
 112c7f0:	aa0003e2 	mov	x2, x0
 112c7f4:	aa1703e1 	mov	x1, x23
 112c7f8:	aa1c03e0 	mov	x0, x28
 112c7fc:	97ff8e87 	bl	1110218 <sm2_kdf>
 112c800:	2a0003e3 	mov	w3, w0
	if (res)
 112c804:	35000820 	cbnz	w0, 112c908 <sm2_ltc_pke_encrypt+0x334>
	for (i = 0; i < size; i++)
 112c808:	d2800000 	mov	x0, #0x0                   	// #0
	uint8_t v = 0;
 112c80c:	52800001 	mov	w1, #0x0                   	// #0
	for (i = 0; i < size; i++)
 112c810:	eb00035f 	cmp	x26, x0
 112c814:	54000b81 	b.ne	112c984 <sm2_ltc_pke_encrypt+0x3b0>  // b.any
		goto out;

	if (is_zero(t, src_len)) {
 112c818:	34001561 	cbz	w1, 112cac4 <sm2_ltc_pke_encrypt+0x4f0>
	size_t xsize = mp_unsigned_bin_size(p->x);
 112c81c:	d0000177 	adrp	x23, 115a000 <__scattered_array_1phys_mem_map+0x8>
	 * Compute C3 = Hash(x2 || M || y2)
	 * Output C = C1 || C2 || C3
	 */

	/* C1 */
	C1_len = *dst_len;
 112c820:	f9400362 	ldr	x2, [x27]
 112c824:	f9003be2 	str	x2, [sp, #112]
	size_t xsize = mp_unsigned_bin_size(p->x);
 112c828:	f941d6f7 	ldr	x23, [x23, #936]
 112c82c:	f94002a0 	ldr	x0, [x21]
 112c830:	f9404ee1 	ldr	x1, [x23, #152]
 112c834:	d63f0020 	blr	x1
 112c838:	aa0003e1 	mov	x1, x0
	size_t ysize = mp_unsigned_bin_size(p->y);
 112c83c:	f94006a0 	ldr	x0, [x21, #8]
	size_t xsize = mp_unsigned_bin_size(p->x);
 112c840:	f90033e1 	str	x1, [sp, #96]
	size_t ysize = mp_unsigned_bin_size(p->y);
 112c844:	f9404ee3 	ldr	x3, [x23, #152]
 112c848:	d63f0060 	blr	x3
	if (xsize > SM2_INT_SIZE_BYTES || ysize > SM2_INT_SIZE_BYTES ||
 112c84c:	f94033e1 	ldr	x1, [sp, #96]
 112c850:	f100803f 	cmp	x1, #0x20
 112c854:	d2800401 	mov	x1, #0x20                  	// #32
 112c858:	fa419002 	ccmp	x0, x1, #0x2, ls  // ls = plast
 112c85c:	54001108 	b.hi	112ca7c <sm2_ltc_pke_encrypt+0x4a8>  // b.pmore
 112c860:	f9403be2 	ldr	x2, [sp, #112]
 112c864:	f101005f 	cmp	x2, #0x40
 112c868:	540010a9 	b.ls	112ca7c <sm2_ltc_pke_encrypt+0x4a8>  // b.plast
	memset(buf, 0, sz);
 112c86c:	d2800822 	mov	x2, #0x41                  	// #65
 112c870:	52800001 	mov	w1, #0x0                   	// #0
 112c874:	aa1803e0 	mov	x0, x24
 112c878:	f9003fe2 	str	x2, [sp, #120]
 112c87c:	94005d19 	bl	1143ce0 <memset>
	buf[0] = 0x04;  /* Uncompressed form indicator */
 112c880:	52800080 	mov	w0, #0x4                   	// #4
 112c884:	39000300 	strb	w0, [x24]
	mp_to_unsigned_bin2(p->x, buf + 1, SM2_INT_SIZE_BYTES);
 112c888:	a94992e1 	ldp	x1, x4, [x23, #152]
 112c88c:	f9003be4 	str	x4, [sp, #112]
 112c890:	f94002a3 	ldr	x3, [x21]
 112c894:	f90033e3 	str	x3, [sp, #96]
 112c898:	aa0303e0 	mov	x0, x3
 112c89c:	d63f0020 	blr	x1
 112c8a0:	cb000301 	sub	x1, x24, x0
 112c8a4:	f94033e3 	ldr	x3, [sp, #96]
 112c8a8:	91008421 	add	x1, x1, #0x21
 112c8ac:	f9403be4 	ldr	x4, [sp, #112]
 112c8b0:	aa0303e0 	mov	x0, x3
 112c8b4:	d63f0080 	blr	x4
	mp_to_unsigned_bin2(p->y, buf + 1 + SM2_INT_SIZE_BYTES,
 112c8b8:	a94992e1 	ldp	x1, x4, [x23, #152]
 112c8bc:	f9003be4 	str	x4, [sp, #112]
 112c8c0:	f94006a3 	ldr	x3, [x21, #8]
 112c8c4:	f90033e3 	str	x3, [sp, #96]
 112c8c8:	aa0303e0 	mov	x0, x3
 112c8cc:	d63f0020 	blr	x1
 112c8d0:	a9470be4 	ldp	x4, x2, [sp, #112]
 112c8d4:	f94033e3 	ldr	x3, [sp, #96]
 112c8d8:	cb000041 	sub	x1, x2, x0
 112c8dc:	aa0303e0 	mov	x0, x3
 112c8e0:	8b010301 	add	x1, x24, x1
 112c8e4:	d63f0080 	blr	x4
	res = sm2_point_to_bytes(dst, &C1_len, C1);
	if (res)
		goto out;

	if (*dst_len < C1_len + src_len + TEE_SM3_HASH_SIZE) {
 112c8e8:	91018740 	add	x0, x26, #0x61
 112c8ec:	f90033e0 	str	x0, [sp, #96]
 112c8f0:	f9400360 	ldr	x0, [x27]
 112c8f4:	91018741 	add	x1, x26, #0x61
 112c8f8:	eb01001f 	cmp	x0, x1
 112c8fc:	54000a82 	b.cs	112ca4c <sm2_ltc_pke_encrypt+0x478>  // b.hs, b.nlast
		*dst_len = C1_len + src_len + TEE_SM3_HASH_SIZE;
		res = TEE_ERROR_SHORT_BUFFER;
 112c900:	129ffde3 	mov	w3, #0xffff0010            	// #-65520
		*dst_len = C1_len + src_len + TEE_SM3_HASH_SIZE;
 112c904:	f9000361 	str	x1, [x27]
        if (res)
                goto out;

	*dst_len = C1_len + src_len + TEE_SM3_HASH_SIZE;
out:
	crypto_hash_free_ctx(ctx);
 112c908:	f94053e0 	ldr	x0, [sp, #160]
 112c90c:	b90063e3 	str	w3, [sp, #96]
 112c910:	97ff8260 	bl	110d290 <crypto_hash_free_ctx>
	free(t);
 112c914:	aa1303e0 	mov	x0, x19
 112c918:	94005b32 	bl	11435e0 <free>
	ltc_ecc_del_point(x2y2p);
 112c91c:	aa1403e0 	mov	x0, x20
 112c920:	94002b5b 	bl	113768c <ltc_ecc_del_point>
	ltc_ecc_del_point(S);
 112c924:	aa1603e0 	mov	x0, x22
 112c928:	94002b59 	bl	113768c <ltc_ecc_del_point>
	ltc_ecc_del_point(C1);
 112c92c:	aa1503e0 	mov	x0, x21
 112c930:	94002b57 	bl	113768c <ltc_ecc_del_point>
	ecc_free(&ltc_key);
 112c934:	aa1903e0 	mov	x0, x25
 112c938:	940022e1 	bl	11354bc <ecc_free>
	mp_clear_multi(k, h, NULL);
 112c93c:	a94907e0 	ldp	x0, x1, [sp, #144]
 112c940:	d2800002 	mov	x2, #0x0                   	// #0
 112c944:	940015f6 	bl	113211c <ltc_deinit_multi>
	return res;
 112c948:	b94063e3 	ldr	w3, [sp, #96]
}
 112c94c:	2a0303e0 	mov	w0, w3
 112c950:	a94153f3 	ldp	x19, x20, [sp, #16]
 112c954:	a9425bf5 	ldp	x21, x22, [sp, #32]
 112c958:	a94363f7 	ldp	x23, x24, [sp, #48]
 112c95c:	a9446bf9 	ldp	x25, x26, [sp, #64]
 112c960:	a94573fb 	ldp	x27, x28, [sp, #80]
 112c964:	a8de7bfd 	ldp	x29, x30, [sp], #480
 112c968:	d65f03c0 	ret
		ltc_res = ltc_ecc_is_point_at_infinity(&ltc_key.pubkey,
 112c96c:	f9407fe1 	ldr	x1, [sp, #248]
 112c970:	910233e2 	add	x2, sp, #0x8c
 112c974:	91036320 	add	x0, x25, #0xd8
	ecc_point *S = NULL;
 112c978:	d2800016 	mov	x22, #0x0                   	// #0
		ltc_res = ltc_ecc_is_point_at_infinity(&ltc_key.pubkey,
 112c97c:	940027c0 	bl	113687c <ltc_ecc_is_point_at_infinity>
 112c980:	17ffff67 	b	112c71c <sm2_ltc_pke_encrypt+0x148>
		v |= buf[i];
 112c984:	38606a62 	ldrb	w2, [x19, x0]
	for (i = 0; i < size; i++)
 112c988:	91000400 	add	x0, x0, #0x1
		v |= buf[i];
 112c98c:	2a010041 	orr	w1, w2, w1
	for (i = 0; i < size; i++)
 112c990:	17ffffa0 	b	112c810 <sm2_ltc_pke_encrypt+0x23c>
		dst[i + C1_len] = src[i] ^ t[i];
 112c994:	f94037e0 	ldr	x0, [sp, #104]
 112c998:	38776a62 	ldrb	w2, [x19, x23]
 112c99c:	38776800 	ldrb	w0, [x0, x23]
 112c9a0:	4a020000 	eor	w0, w0, w2
 112c9a4:	38376820 	strb	w0, [x1, x23]
	for (i = 0; i < src_len; i++)
 112c9a8:	910006f7 	add	x23, x23, #0x1
 112c9ac:	eb1a02ff 	cmp	x23, x26
 112c9b0:	54ffff21 	b.ne	112c994 <sm2_ltc_pke_encrypt+0x3c0>  // b.any
        res = crypto_hash_alloc_ctx(&ctx, TEE_ALG_SM3);
 112c9b4:	528000e1 	mov	w1, #0x7                   	// #7
 112c9b8:	910283e0 	add	x0, sp, #0xa0
 112c9bc:	72aa0001 	movk	w1, #0x5000, lsl #16
 112c9c0:	97ff820f 	bl	110d1fc <crypto_hash_alloc_ctx>
 112c9c4:	2a0003e3 	mov	w3, w0
        if (res)
 112c9c8:	35fffa00 	cbnz	w0, 112c908 <sm2_ltc_pke_encrypt+0x334>
        res = crypto_hash_init(ctx);
 112c9cc:	f94053e0 	ldr	x0, [sp, #160]
 112c9d0:	97ff824a 	bl	110d2f8 <crypto_hash_init>
 112c9d4:	2a0003e3 	mov	w3, w0
        if (res)
 112c9d8:	35fff980 	cbnz	w0, 112c908 <sm2_ltc_pke_encrypt+0x334>
        res = crypto_hash_update(ctx, x2y2, SM2_INT_SIZE_BYTES);
 112c9dc:	f94053e0 	ldr	x0, [sp, #160]
 112c9e0:	aa1c03e1 	mov	x1, x28
 112c9e4:	d2800402 	mov	x2, #0x20                  	// #32
 112c9e8:	97ff824f 	bl	110d324 <crypto_hash_update>
 112c9ec:	2a0003e3 	mov	w3, w0
        if (res)
 112c9f0:	35fff8c0 	cbnz	w0, 112c908 <sm2_ltc_pke_encrypt+0x334>
        res = crypto_hash_update(ctx, src, src_len);
 112c9f4:	f94037e1 	ldr	x1, [sp, #104]
 112c9f8:	aa1703e2 	mov	x2, x23
 112c9fc:	f94053e0 	ldr	x0, [sp, #160]
 112ca00:	97ff8249 	bl	110d324 <crypto_hash_update>
 112ca04:	2a0003e3 	mov	w3, w0
        if (res)
 112ca08:	35fff800 	cbnz	w0, 112c908 <sm2_ltc_pke_encrypt+0x334>
        res = crypto_hash_update(ctx, x2y2 + SM2_INT_SIZE_BYTES,
 112ca0c:	f94053e0 	ldr	x0, [sp, #160]
 112ca10:	d2800402 	mov	x2, #0x20                  	// #32
 112ca14:	8b020381 	add	x1, x28, x2
 112ca18:	97ff8243 	bl	110d324 <crypto_hash_update>
 112ca1c:	2a0003e3 	mov	w3, w0
        if (res)
 112ca20:	35fff740 	cbnz	w0, 112c908 <sm2_ltc_pke_encrypt+0x334>
        res = crypto_hash_final(ctx, dst + C1_len + src_len, TEE_SM3_HASH_SIZE);
 112ca24:	f94053e0 	ldr	x0, [sp, #160]
	if (*dst_len < C1_len + src_len + TEE_SM3_HASH_SIZE) {
 112ca28:	910106e1 	add	x1, x23, #0x41
        res = crypto_hash_final(ctx, dst + C1_len + src_len, TEE_SM3_HASH_SIZE);
 112ca2c:	8b010301 	add	x1, x24, x1
 112ca30:	d2800402 	mov	x2, #0x20                  	// #32
 112ca34:	97ff824d 	bl	110d368 <crypto_hash_final>
 112ca38:	2a0003e3 	mov	w3, w0
        if (res)
 112ca3c:	35fff660 	cbnz	w0, 112c908 <sm2_ltc_pke_encrypt+0x334>
	*dst_len = C1_len + src_len + TEE_SM3_HASH_SIZE;
 112ca40:	f94033e0 	ldr	x0, [sp, #96]
 112ca44:	f9000360 	str	x0, [x27]
 112ca48:	17ffffb0 	b	112c908 <sm2_ltc_pke_encrypt+0x334>
		dst[i + C1_len] = src[i] ^ t[i];
 112ca4c:	91010701 	add	x1, x24, #0x41
	for (i = 0; i < src_len; i++)
 112ca50:	d2800017 	mov	x23, #0x0                   	// #0
 112ca54:	17ffffd6 	b	112c9ac <sm2_ltc_pke_encrypt+0x3d8>
	uint8_t *t = NULL;
 112ca58:	d2800013 	mov	x19, #0x0                   	// #0
	ecc_point *S = NULL;
 112ca5c:	d2800016 	mov	x22, #0x0                   	// #0
	ecc_point *C1 = NULL;
 112ca60:	d2800015 	mov	x21, #0x0                   	// #0
	ecc_point *x2y2p = NULL;
 112ca64:	d2800014 	mov	x20, #0x0                   	// #0
 112ca68:	17ffffa8 	b	112c908 <sm2_ltc_pke_encrypt+0x334>
	uint8_t *t = NULL;
 112ca6c:	d2800013 	mov	x19, #0x0                   	// #0
	ecc_point *S = NULL;
 112ca70:	d2800016 	mov	x22, #0x0                   	// #0
	ecc_point *C1 = NULL;
 112ca74:	d2800015 	mov	x21, #0x0                   	// #0
	ecc_point *x2y2p = NULL;
 112ca78:	d2800014 	mov	x20, #0x0                   	// #0
		return TEE_ERROR_BAD_STATE;
 112ca7c:	129fff03 	mov	w3, #0xffff0007            	// #-65529
 112ca80:	17ffffa2 	b	112c908 <sm2_ltc_pke_encrypt+0x334>
	uint8_t *t = NULL;
 112ca84:	d2800013 	mov	x19, #0x0                   	// #0
	ecc_point *S = NULL;
 112ca88:	d2800016 	mov	x22, #0x0                   	// #0
	ecc_point *x2y2p = NULL;
 112ca8c:	d2800014 	mov	x20, #0x0                   	// #0
			res = TEE_ERROR_OUT_OF_MEMORY;
 112ca90:	129ffe63 	mov	w3, #0xffff000c            	// #-65524
 112ca94:	17ffff9d 	b	112c908 <sm2_ltc_pke_encrypt+0x334>
	uint8_t *t = NULL;
 112ca98:	d2800013 	mov	x19, #0x0                   	// #0
	ecc_point *S = NULL;
 112ca9c:	d2800016 	mov	x22, #0x0                   	// #0
 112caa0:	17fffff6 	b	112ca78 <sm2_ltc_pke_encrypt+0x4a4>
	uint8_t *t = NULL;
 112caa4:	d2800013 	mov	x19, #0x0                   	// #0
 112caa8:	17fffff9 	b	112ca8c <sm2_ltc_pke_encrypt+0x4b8>
 112caac:	d2800013 	mov	x19, #0x0                   	// #0
 112cab0:	17fffff2 	b	112ca78 <sm2_ltc_pke_encrypt+0x4a4>
 112cab4:	d2800013 	mov	x19, #0x0                   	// #0
 112cab8:	17fffff6 	b	112ca90 <sm2_ltc_pke_encrypt+0x4bc>
 112cabc:	d2800013 	mov	x19, #0x0                   	// #0
 112cac0:	17ffffef 	b	112ca7c <sm2_ltc_pke_encrypt+0x4a8>
		res = TEE_ERROR_CIPHERTEXT_INVALID;
 112cac4:	528000c3 	mov	w3, #0x6                   	// #6
 112cac8:	72be0203 	movk	w3, #0xf010, lsl #16
 112cacc:	17ffff8f 	b	112c908 <sm2_ltc_pke_encrypt+0x334>
		return TEE_ERROR_OUT_OF_MEMORY;
 112cad0:	129ffe63 	mov	w3, #0xffff000c            	// #-65524
 112cad4:	17ffff9e 	b	112c94c <sm2_ltc_pke_encrypt+0x378>

000000000112cad8 <sm2_kep_compute_S.constprop.0>:
 * On the initiator's side:
 *   S1 = SM3(0x02 || yU || SM3(xU || ZA || ZB || x1 || y1 || x2 || y2))
 * On the responder's side:
 *   S2 = SM3(0x03 || yV || SM3(xV || ZA || ZB || x1 || y1 || x2 || y2))
 */
static TEE_Result sm2_kep_compute_S(uint8_t *S, size_t S_len, uint8_t flag,
 112cad8:	a9b47bfd 	stp	x29, x30, [sp, #-192]!
 112cadc:	910003fd 	mov	x29, sp
 112cae0:	3901bfe1 	strb	w1, [sp, #111]
	void *ctx = NULL;

	if (S_len < TEE_SM3_HASH_SIZE)
		return TEE_ERROR_SHORT_BUFFER;

	res = crypto_hash_alloc_ctx(&ctx, TEE_ALG_SM3);
 112cae4:	528000e1 	mov	w1, #0x7                   	// #7
 112cae8:	72aa0001 	movk	w1, #0x5000, lsl #16
static TEE_Result sm2_kep_compute_S(uint8_t *S, size_t S_len, uint8_t flag,
 112caec:	a90153f3 	stp	x19, x20, [sp, #16]
 112caf0:	aa0003f4 	mov	x20, x0
	res = crypto_hash_alloc_ctx(&ctx, TEE_ALG_SM3);
 112caf4:	9101e3e0 	add	x0, sp, #0x78
static TEE_Result sm2_kep_compute_S(uint8_t *S, size_t S_len, uint8_t flag,
 112caf8:	a9025bf5 	stp	x21, x22, [sp, #32]
 112cafc:	aa0203f6 	mov	x22, x2
 112cb00:	a90363f7 	stp	x23, x24, [sp, #48]
 112cb04:	aa0503f8 	mov	x24, x5
 112cb08:	a9046bf9 	stp	x25, x26, [sp, #64]
 112cb0c:	aa0303fa 	mov	x26, x3
 112cb10:	aa0403f9 	mov	x25, x4
 112cb14:	a90573fb 	stp	x27, x28, [sp, #80]
	void *ctx = NULL;
 112cb18:	f9003fff 	str	xzr, [sp, #120]
	uint8_t hash[TEE_SM3_HASH_SIZE] = { };
 112cb1c:	a9087fff 	stp	xzr, xzr, [sp, #128]
 112cb20:	a9097fff 	stp	xzr, xzr, [sp, #144]
	res = crypto_hash_alloc_ctx(&ctx, TEE_ALG_SM3);
 112cb24:	97ff81b6 	bl	110d1fc <crypto_hash_alloc_ctx>
 112cb28:	2a0003f3 	mov	w19, w0
	if (res)
 112cb2c:	35001040 	cbnz	w0, 112cd34 <sm2_kep_compute_S.constprop.0+0x25c>
		goto out;

	/* Compute the inner hash */

	res = crypto_hash_init(ctx);
 112cb30:	f9403fe0 	ldr	x0, [sp, #120]
 112cb34:	97ff81f1 	bl	110d2f8 <crypto_hash_init>
 112cb38:	2a0003f3 	mov	w19, w0
	if (res)
 112cb3c:	35000fc0 	cbnz	w0, 112cd34 <sm2_kep_compute_S.constprop.0+0x25c>
		goto out;

	/* xU or xV */
	mp_to_unsigned_bin2(UV->x, buf, SM2_INT_SIZE_BYTES);
 112cb40:	d000017b 	adrp	x27, 115a000 <__scattered_array_1phys_mem_map+0x8>
 112cb44:	910283f5 	add	x21, sp, #0xa0
 112cb48:	f94002d3 	ldr	x19, [x22]
 112cb4c:	d2800417 	mov	x23, #0x20                  	// #32
 112cb50:	f941d77b 	ldr	x27, [x27, #936]
 112cb54:	aa1303e0 	mov	x0, x19
 112cb58:	a949f361 	ldp	x1, x28, [x27, #152]
 112cb5c:	d63f0020 	blr	x1
 112cb60:	cb0002e1 	sub	x1, x23, x0
 112cb64:	8b0102a1 	add	x1, x21, x1
 112cb68:	aa1303e0 	mov	x0, x19
 112cb6c:	d63f0380 	blr	x28
	res = crypto_hash_update(ctx, buf, sizeof(buf));
 112cb70:	f9403fe0 	ldr	x0, [sp, #120]
 112cb74:	aa1703e2 	mov	x2, x23
 112cb78:	aa1503e1 	mov	x1, x21
 112cb7c:	97ff81ea 	bl	110d324 <crypto_hash_update>
 112cb80:	2a0003f3 	mov	w19, w0
	if (res)
 112cb84:	35000d80 	cbnz	w0, 112cd34 <sm2_kep_compute_S.constprop.0+0x25c>
		goto out;

	/* ZA || ZB */
	res = crypto_hash_update(ctx, ZAZB, ZAZB_len);
 112cb88:	f9403fe0 	ldr	x0, [sp, #120]
 112cb8c:	aa1a03e1 	mov	x1, x26
 112cb90:	d2800802 	mov	x2, #0x40                  	// #64
 112cb94:	97ff81e4 	bl	110d324 <crypto_hash_update>
 112cb98:	2a0003f3 	mov	w19, w0
	if (res)
 112cb9c:	35000cc0 	cbnz	w0, 112cd34 <sm2_kep_compute_S.constprop.0+0x25c>
		goto out;

	/* x1 */
	mp_to_unsigned_bin2(initiator_eph_key->pubkey.x, buf,
 112cba0:	a949eb61 	ldp	x1, x26, [x27, #152]
 112cba4:	f9406f33 	ldr	x19, [x25, #216]
 112cba8:	aa1303e0 	mov	x0, x19
 112cbac:	d63f0020 	blr	x1
 112cbb0:	cb0002e1 	sub	x1, x23, x0
 112cbb4:	8b0102a1 	add	x1, x21, x1
 112cbb8:	aa1303e0 	mov	x0, x19
 112cbbc:	d63f0340 	blr	x26
			    SM2_INT_SIZE_BYTES);
	res = crypto_hash_update(ctx, buf, sizeof(buf));
 112cbc0:	f9403fe0 	ldr	x0, [sp, #120]
 112cbc4:	aa1703e2 	mov	x2, x23
 112cbc8:	aa1503e1 	mov	x1, x21
 112cbcc:	97ff81d6 	bl	110d324 <crypto_hash_update>
 112cbd0:	2a0003f3 	mov	w19, w0
	if (res)
 112cbd4:	35000b00 	cbnz	w0, 112cd34 <sm2_kep_compute_S.constprop.0+0x25c>
		goto out;

	/* y1 */
	mp_to_unsigned_bin2(initiator_eph_key->pubkey.y, buf,
 112cbd8:	f9407333 	ldr	x19, [x25, #224]
 112cbdc:	a949e761 	ldp	x1, x25, [x27, #152]
 112cbe0:	aa1303e0 	mov	x0, x19
 112cbe4:	d63f0020 	blr	x1
 112cbe8:	cb0002e1 	sub	x1, x23, x0
 112cbec:	8b0102a1 	add	x1, x21, x1
 112cbf0:	aa1303e0 	mov	x0, x19
 112cbf4:	d63f0320 	blr	x25
			    SM2_INT_SIZE_BYTES);
	res = crypto_hash_update(ctx, buf, sizeof(buf));
 112cbf8:	f9403fe0 	ldr	x0, [sp, #120]
 112cbfc:	aa1703e2 	mov	x2, x23
 112cc00:	aa1503e1 	mov	x1, x21
 112cc04:	97ff81c8 	bl	110d324 <crypto_hash_update>
 112cc08:	2a0003f3 	mov	w19, w0
	if (res)
 112cc0c:	35000940 	cbnz	w0, 112cd34 <sm2_kep_compute_S.constprop.0+0x25c>
		goto out;

	/* x2 */
	mp_to_unsigned_bin2(responder_eph_key->pubkey.x, buf,
 112cc10:	a949e761 	ldp	x1, x25, [x27, #152]
 112cc14:	f9406f13 	ldr	x19, [x24, #216]
 112cc18:	aa1303e0 	mov	x0, x19
 112cc1c:	d63f0020 	blr	x1
 112cc20:	cb0002e1 	sub	x1, x23, x0
 112cc24:	8b0102a1 	add	x1, x21, x1
 112cc28:	aa1303e0 	mov	x0, x19
 112cc2c:	d63f0320 	blr	x25
			    SM2_INT_SIZE_BYTES);
	res = crypto_hash_update(ctx, buf, sizeof(buf));
 112cc30:	f9403fe0 	ldr	x0, [sp, #120]
 112cc34:	aa1703e2 	mov	x2, x23
 112cc38:	aa1503e1 	mov	x1, x21
 112cc3c:	97ff81ba 	bl	110d324 <crypto_hash_update>
 112cc40:	2a0003f3 	mov	w19, w0
	if (res)
 112cc44:	35000780 	cbnz	w0, 112cd34 <sm2_kep_compute_S.constprop.0+0x25c>
		goto out;

	/* y2 */
	mp_to_unsigned_bin2(responder_eph_key->pubkey.y, buf,
 112cc48:	f9407313 	ldr	x19, [x24, #224]
 112cc4c:	a949e361 	ldp	x1, x24, [x27, #152]
 112cc50:	aa1303e0 	mov	x0, x19
 112cc54:	d63f0020 	blr	x1
 112cc58:	cb0002e1 	sub	x1, x23, x0
 112cc5c:	8b0102a1 	add	x1, x21, x1
 112cc60:	aa1303e0 	mov	x0, x19
 112cc64:	d63f0300 	blr	x24
			   SM2_INT_SIZE_BYTES);
	res = crypto_hash_update(ctx, buf, sizeof(buf));
 112cc68:	f9403fe0 	ldr	x0, [sp, #120]
 112cc6c:	aa1703e2 	mov	x2, x23
 112cc70:	aa1503e1 	mov	x1, x21
 112cc74:	97ff81ac 	bl	110d324 <crypto_hash_update>
 112cc78:	2a0003f3 	mov	w19, w0
	if (res)
 112cc7c:	350005c0 	cbnz	w0, 112cd34 <sm2_kep_compute_S.constprop.0+0x25c>
		goto out;

	res = crypto_hash_final(ctx, hash, sizeof(hash));
 112cc80:	f9403fe0 	ldr	x0, [sp, #120]
 112cc84:	910203f8 	add	x24, sp, #0x80
 112cc88:	aa1703e2 	mov	x2, x23
 112cc8c:	aa1803e1 	mov	x1, x24
 112cc90:	97ff81b6 	bl	110d368 <crypto_hash_final>
 112cc94:	2a0003f3 	mov	w19, w0
	if (res)
 112cc98:	350004e0 	cbnz	w0, 112cd34 <sm2_kep_compute_S.constprop.0+0x25c>
		goto out;

	/* Now compute S */

	res = crypto_hash_init(ctx);
 112cc9c:	f9403fe0 	ldr	x0, [sp, #120]
 112cca0:	97ff8196 	bl	110d2f8 <crypto_hash_init>
 112cca4:	2a0003f3 	mov	w19, w0
	if (res)
 112cca8:	35000460 	cbnz	w0, 112cd34 <sm2_kep_compute_S.constprop.0+0x25c>
		goto out;

	/* 0x02 or 0x03  */
	res = crypto_hash_update(ctx, &flag, sizeof(flag));
 112ccac:	f9403fe0 	ldr	x0, [sp, #120]
 112ccb0:	9101bfe1 	add	x1, sp, #0x6f
 112ccb4:	d2800022 	mov	x2, #0x1                   	// #1
 112ccb8:	97ff819b 	bl	110d324 <crypto_hash_update>
 112ccbc:	2a0003f3 	mov	w19, w0
	if (res)
 112ccc0:	350003a0 	cbnz	w0, 112cd34 <sm2_kep_compute_S.constprop.0+0x25c>
		goto out;

	/* yU or yV */
	mp_to_unsigned_bin2(UV->y, buf, SM2_INT_SIZE_BYTES);
 112ccc4:	d000017b 	adrp	x27, 115a000 <__scattered_array_1phys_mem_map+0x8>
 112ccc8:	f94006d3 	ldr	x19, [x22, #8]
 112cccc:	d2800416 	mov	x22, #0x20                  	// #32
 112ccd0:	f941d77b 	ldr	x27, [x27, #936]
 112ccd4:	aa1303e0 	mov	x0, x19
 112ccd8:	a949df61 	ldp	x1, x23, [x27, #152]
 112ccdc:	d63f0020 	blr	x1
 112cce0:	cb0002c1 	sub	x1, x22, x0
 112cce4:	8b0102a1 	add	x1, x21, x1
 112cce8:	aa1303e0 	mov	x0, x19
 112ccec:	d63f02e0 	blr	x23
	res = crypto_hash_update(ctx, buf, sizeof(buf));
 112ccf0:	f9403fe0 	ldr	x0, [sp, #120]
 112ccf4:	aa1603e2 	mov	x2, x22
 112ccf8:	aa1503e1 	mov	x1, x21
 112ccfc:	97ff818a 	bl	110d324 <crypto_hash_update>
 112cd00:	2a0003f3 	mov	w19, w0
	if (res)
 112cd04:	35000180 	cbnz	w0, 112cd34 <sm2_kep_compute_S.constprop.0+0x25c>
		goto out;

	/* Inner SM3(...) */
	res = crypto_hash_update(ctx, hash, sizeof(hash));
 112cd08:	f9403fe0 	ldr	x0, [sp, #120]
 112cd0c:	aa1603e2 	mov	x2, x22
 112cd10:	aa1803e1 	mov	x1, x24
 112cd14:	97ff8184 	bl	110d324 <crypto_hash_update>
 112cd18:	2a0003f3 	mov	w19, w0
	if (res)
 112cd1c:	350000c0 	cbnz	w0, 112cd34 <sm2_kep_compute_S.constprop.0+0x25c>
		goto out;

	res = crypto_hash_final(ctx, S, TEE_SM3_HASH_SIZE);
 112cd20:	f9403fe0 	ldr	x0, [sp, #120]
 112cd24:	aa1603e2 	mov	x2, x22
 112cd28:	aa1403e1 	mov	x1, x20
 112cd2c:	97ff818f 	bl	110d368 <crypto_hash_final>
 112cd30:	2a0003f3 	mov	w19, w0

out:
	crypto_hash_free_ctx(ctx);
 112cd34:	f9403fe0 	ldr	x0, [sp, #120]
 112cd38:	97ff8156 	bl	110d290 <crypto_hash_free_ctx>
	return res;

}
 112cd3c:	2a1303e0 	mov	w0, w19
 112cd40:	a94153f3 	ldp	x19, x20, [sp, #16]
 112cd44:	a9425bf5 	ldp	x21, x22, [sp, #32]
 112cd48:	a94363f7 	ldp	x23, x24, [sp, #48]
 112cd4c:	a9446bf9 	ldp	x25, x26, [sp, #64]
 112cd50:	a94573fb 	ldp	x27, x28, [sp, #80]
 112cd54:	a8cc7bfd 	ldp	x29, x30, [sp], #192
 112cd58:	d65f03c0 	ret

000000000112cd5c <sm2_kep_compute_Z.constprop.0>:
static TEE_Result sm2_kep_compute_Z(uint8_t *Z, size_t Zlen, const uint8_t *id,
 112cd5c:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
 112cd60:	910003fd 	mov	x29, sp
 112cd64:	a90153f3 	stp	x19, x20, [sp, #16]
 112cd68:	aa0003f4 	mov	x20, x0
	ENTLEN[0] = (idlen * 8) >> 8;
 112cd6c:	d345f040 	ubfx	x0, x2, #5, #56
static TEE_Result sm2_kep_compute_Z(uint8_t *Z, size_t Zlen, const uint8_t *id,
 112cd70:	a90363f7 	stp	x23, x24, [sp, #48]
 112cd74:	aa0103f7 	mov	x23, x1
	res = crypto_hash_alloc_ctx(&ctx, TEE_ALG_SM3);
 112cd78:	528000e1 	mov	w1, #0x7                   	// #7
	ENTLEN[0] = (idlen * 8) >> 8;
 112cd7c:	390143e0 	strb	w0, [sp, #80]
	ENTLEN[1] = idlen * 8;
 112cd80:	531d1040 	ubfiz	w0, w2, #3, #5
	res = crypto_hash_alloc_ctx(&ctx, TEE_ALG_SM3);
 112cd84:	72aa0001 	movk	w1, #0x5000, lsl #16
static TEE_Result sm2_kep_compute_Z(uint8_t *Z, size_t Zlen, const uint8_t *id,
 112cd88:	a9025bf5 	stp	x21, x22, [sp, #32]
 112cd8c:	aa0203f6 	mov	x22, x2
 112cd90:	aa0303f5 	mov	x21, x3
 112cd94:	f90023f9 	str	x25, [sp, #64]
	ENTLEN[1] = idlen * 8;
 112cd98:	390147e0 	strb	w0, [sp, #81]
	res = crypto_hash_alloc_ctx(&ctx, TEE_ALG_SM3);
 112cd9c:	910163e0 	add	x0, sp, #0x58
	void *ctx = NULL;
 112cda0:	f9002fff 	str	xzr, [sp, #88]
	res = crypto_hash_alloc_ctx(&ctx, TEE_ALG_SM3);
 112cda4:	97ff8116 	bl	110d1fc <crypto_hash_alloc_ctx>
 112cda8:	2a0003f3 	mov	w19, w0
	if (res)
 112cdac:	35000dc0 	cbnz	w0, 112cf64 <sm2_kep_compute_Z.constprop.0+0x208>
	res = crypto_hash_init(ctx);
 112cdb0:	f9402fe0 	ldr	x0, [sp, #88]
 112cdb4:	97ff8151 	bl	110d2f8 <crypto_hash_init>
 112cdb8:	2a0003f3 	mov	w19, w0
	if (res)
 112cdbc:	35000d40 	cbnz	w0, 112cf64 <sm2_kep_compute_Z.constprop.0+0x208>
	res = crypto_hash_update(ctx, ENTLEN, sizeof(ENTLEN));
 112cdc0:	f9402fe0 	ldr	x0, [sp, #88]
 112cdc4:	910143e1 	add	x1, sp, #0x50
 112cdc8:	d2800042 	mov	x2, #0x2                   	// #2
 112cdcc:	97ff8156 	bl	110d324 <crypto_hash_update>
 112cdd0:	2a0003f3 	mov	w19, w0
	if (res)
 112cdd4:	35000c80 	cbnz	w0, 112cf64 <sm2_kep_compute_Z.constprop.0+0x208>
	res = crypto_hash_update(ctx, id, idlen);
 112cdd8:	f9402fe0 	ldr	x0, [sp, #88]
 112cddc:	aa1603e2 	mov	x2, x22
 112cde0:	aa1703e1 	mov	x1, x23
 112cde4:	97ff8150 	bl	110d324 <crypto_hash_update>
 112cde8:	2a0003f3 	mov	w19, w0
	if (res)
 112cdec:	35000bc0 	cbnz	w0, 112cf64 <sm2_kep_compute_Z.constprop.0+0x208>
	mp_to_unsigned_bin2(key->dp.A, buf, SM2_INT_SIZE_BYTES);
 112cdf0:	d0000178 	adrp	x24, 115a000 <__scattered_array_1phys_mem_map+0x8>
 112cdf4:	910183f6 	add	x22, sp, #0x60
 112cdf8:	f9400eb3 	ldr	x19, [x21, #24]
 112cdfc:	d2800417 	mov	x23, #0x20                  	// #32
 112ce00:	f941d718 	ldr	x24, [x24, #936]
 112ce04:	aa1303e0 	mov	x0, x19
 112ce08:	a949e701 	ldp	x1, x25, [x24, #152]
 112ce0c:	d63f0020 	blr	x1
 112ce10:	cb0002e1 	sub	x1, x23, x0
 112ce14:	8b0102c1 	add	x1, x22, x1
 112ce18:	aa1303e0 	mov	x0, x19
 112ce1c:	d63f0320 	blr	x25
	res = crypto_hash_update(ctx, buf, sizeof(buf));
 112ce20:	f9402fe0 	ldr	x0, [sp, #88]
 112ce24:	aa1703e2 	mov	x2, x23
 112ce28:	aa1603e1 	mov	x1, x22
 112ce2c:	97ff813e 	bl	110d324 <crypto_hash_update>
 112ce30:	2a0003f3 	mov	w19, w0
	if (res)
 112ce34:	35000980 	cbnz	w0, 112cf64 <sm2_kep_compute_Z.constprop.0+0x208>
	mp_to_unsigned_bin2(key->dp.B, buf, SM2_INT_SIZE_BYTES);
 112ce38:	a949e701 	ldp	x1, x25, [x24, #152]
 112ce3c:	f94012b3 	ldr	x19, [x21, #32]
 112ce40:	aa1303e0 	mov	x0, x19
 112ce44:	d63f0020 	blr	x1
 112ce48:	cb0002e1 	sub	x1, x23, x0
 112ce4c:	8b0102c1 	add	x1, x22, x1
 112ce50:	aa1303e0 	mov	x0, x19
 112ce54:	d63f0320 	blr	x25
	res = crypto_hash_update(ctx, buf, sizeof(buf));
 112ce58:	f9402fe0 	ldr	x0, [sp, #88]
 112ce5c:	aa1703e2 	mov	x2, x23
 112ce60:	aa1603e1 	mov	x1, x22
 112ce64:	97ff8130 	bl	110d324 <crypto_hash_update>
 112ce68:	2a0003f3 	mov	w19, w0
	if (res)
 112ce6c:	350007c0 	cbnz	w0, 112cf64 <sm2_kep_compute_Z.constprop.0+0x208>
	mp_to_unsigned_bin2(key->dp.base.x, buf, SM2_INT_SIZE_BYTES);
 112ce70:	a949e701 	ldp	x1, x25, [x24, #152]
 112ce74:	f9401ab3 	ldr	x19, [x21, #48]
 112ce78:	aa1303e0 	mov	x0, x19
 112ce7c:	d63f0020 	blr	x1
 112ce80:	cb0002e1 	sub	x1, x23, x0
 112ce84:	8b0102c1 	add	x1, x22, x1
 112ce88:	aa1303e0 	mov	x0, x19
 112ce8c:	d63f0320 	blr	x25
	res = crypto_hash_update(ctx, buf, sizeof(buf));
 112ce90:	f9402fe0 	ldr	x0, [sp, #88]
 112ce94:	aa1703e2 	mov	x2, x23
 112ce98:	aa1603e1 	mov	x1, x22
 112ce9c:	97ff8122 	bl	110d324 <crypto_hash_update>
 112cea0:	2a0003f3 	mov	w19, w0
	if (res)
 112cea4:	35000600 	cbnz	w0, 112cf64 <sm2_kep_compute_Z.constprop.0+0x208>
	mp_to_unsigned_bin2(key->dp.base.y, buf, SM2_INT_SIZE_BYTES);
 112cea8:	a949e701 	ldp	x1, x25, [x24, #152]
 112ceac:	f9401eb3 	ldr	x19, [x21, #56]
 112ceb0:	aa1303e0 	mov	x0, x19
 112ceb4:	d63f0020 	blr	x1
 112ceb8:	cb0002e1 	sub	x1, x23, x0
 112cebc:	8b0102c1 	add	x1, x22, x1
 112cec0:	aa1303e0 	mov	x0, x19
 112cec4:	d63f0320 	blr	x25
	res = crypto_hash_update(ctx, buf, sizeof(buf));
 112cec8:	f9402fe0 	ldr	x0, [sp, #88]
 112cecc:	aa1703e2 	mov	x2, x23
 112ced0:	aa1603e1 	mov	x1, x22
 112ced4:	97ff8114 	bl	110d324 <crypto_hash_update>
 112ced8:	2a0003f3 	mov	w19, w0
	if (res)
 112cedc:	35000440 	cbnz	w0, 112cf64 <sm2_kep_compute_Z.constprop.0+0x208>
	mp_to_unsigned_bin2(key->pubkey.x, buf, SM2_INT_SIZE_BYTES);
 112cee0:	a949e701 	ldp	x1, x25, [x24, #152]
 112cee4:	f9406eb3 	ldr	x19, [x21, #216]
 112cee8:	aa1303e0 	mov	x0, x19
 112ceec:	d63f0020 	blr	x1
 112cef0:	cb0002e1 	sub	x1, x23, x0
 112cef4:	8b0102c1 	add	x1, x22, x1
 112cef8:	aa1303e0 	mov	x0, x19
 112cefc:	d63f0320 	blr	x25
	res = crypto_hash_update(ctx, buf, sizeof(buf));
 112cf00:	f9402fe0 	ldr	x0, [sp, #88]
 112cf04:	aa1703e2 	mov	x2, x23
 112cf08:	aa1603e1 	mov	x1, x22
 112cf0c:	97ff8106 	bl	110d324 <crypto_hash_update>
 112cf10:	2a0003f3 	mov	w19, w0
	if (res)
 112cf14:	35000280 	cbnz	w0, 112cf64 <sm2_kep_compute_Z.constprop.0+0x208>
	mp_to_unsigned_bin2(key->pubkey.y, buf, SM2_INT_SIZE_BYTES);
 112cf18:	f94072b3 	ldr	x19, [x21, #224]
 112cf1c:	a949d701 	ldp	x1, x21, [x24, #152]
 112cf20:	aa1303e0 	mov	x0, x19
 112cf24:	d63f0020 	blr	x1
 112cf28:	cb0002e1 	sub	x1, x23, x0
 112cf2c:	8b0102c1 	add	x1, x22, x1
 112cf30:	aa1303e0 	mov	x0, x19
 112cf34:	d63f02a0 	blr	x21
	res = crypto_hash_update(ctx, buf, sizeof(buf));
 112cf38:	f9402fe0 	ldr	x0, [sp, #88]
 112cf3c:	aa1703e2 	mov	x2, x23
 112cf40:	aa1603e1 	mov	x1, x22
 112cf44:	97ff80f8 	bl	110d324 <crypto_hash_update>
 112cf48:	2a0003f3 	mov	w19, w0
	if (res)
 112cf4c:	350000c0 	cbnz	w0, 112cf64 <sm2_kep_compute_Z.constprop.0+0x208>
	res = crypto_hash_final(ctx, Z, TEE_SM3_HASH_SIZE);
 112cf50:	f9402fe0 	ldr	x0, [sp, #88]
 112cf54:	aa1703e2 	mov	x2, x23
 112cf58:	aa1403e1 	mov	x1, x20
 112cf5c:	97ff8103 	bl	110d368 <crypto_hash_final>
 112cf60:	2a0003f3 	mov	w19, w0
	crypto_hash_free_ctx(ctx);
 112cf64:	f9402fe0 	ldr	x0, [sp, #88]
 112cf68:	97ff80ca 	bl	110d290 <crypto_hash_free_ctx>
}
 112cf6c:	2a1303e0 	mov	w0, w19
 112cf70:	a94153f3 	ldp	x19, x20, [sp, #16]
 112cf74:	a9425bf5 	ldp	x21, x22, [sp, #32]
 112cf78:	a94363f7 	ldp	x23, x24, [sp, #48]
 112cf7c:	f94023f9 	ldr	x25, [sp, #64]
 112cf80:	a8c87bfd 	ldp	x29, x30, [sp], #128
 112cf84:	d65f03c0 	ret

000000000112cf88 <crypto_acipher_sm2_kep_derive>:
TEE_Result crypto_acipher_sm2_kep_derive(struct ecc_keypair *my_key,
					 struct ecc_keypair *my_eph_key,
					 struct ecc_public_key *peer_key,
					 struct ecc_public_key *peer_eph_key,
					 struct sm2_kep_parms *p)
{
 112cf88:	d11643ff 	sub	sp, sp, #0x590
 112cf8c:	a9017bfd 	stp	x29, x30, [sp, #16]
 112cf90:	910043fd 	add	x29, sp, #0x10
 112cf94:	a90463f7 	stp	x23, x24, [sp, #64]
	TEE_Result res = TEE_SUCCESS;
	ecc_key ltc_my_key = { };
 112cf98:	9106c3f8 	add	x24, sp, #0x1b0
{
 112cf9c:	aa0203f7 	mov	x23, x2
	ecc_key ltc_my_key = { };
 112cfa0:	d2801f02 	mov	x2, #0xf8                  	// #248
{
 112cfa4:	a90253f3 	stp	x19, x20, [sp, #32]
 112cfa8:	aa0303f4 	mov	x20, x3
 112cfac:	aa0403f3 	mov	x19, x4
 112cfb0:	a9035bf5 	stp	x21, x22, [sp, #48]
	ecc_key ltc_my_eph_key = { };
	ecc_key ltc_peer_key = { };
 112cfb4:	910e83f6 	add	x22, sp, #0x3a0
{
 112cfb8:	a9056bf9 	stp	x25, x26, [sp, #80]
 112cfbc:	aa0103fa 	mov	x26, x1
	ecc_key ltc_my_eph_key = { };
 112cfc0:	910aa3f9 	add	x25, sp, #0x2a8
	ecc_key ltc_my_key = { };
 112cfc4:	52800001 	mov	w1, #0x0                   	// #0
{
 112cfc8:	a90673fb 	stp	x27, x28, [sp, #96]
 112cfcc:	aa0003fb 	mov	x27, x0
	ecc_key ltc_my_key = { };
 112cfd0:	aa1803e0 	mov	x0, x24
 112cfd4:	94005b43 	bl	1143ce0 <memset>
	ecc_key ltc_my_eph_key = { };
 112cfd8:	d2801f02 	mov	x2, #0xf8                  	// #248
 112cfdc:	52800001 	mov	w1, #0x0                   	// #0
 112cfe0:	aa1903e0 	mov	x0, x25
 112cfe4:	94005b3f 	bl	1143ce0 <memset>
	ecc_key ltc_peer_key = { };
 112cfe8:	d2801f02 	mov	x2, #0xf8                  	// #248
 112cfec:	52800001 	mov	w1, #0x0                   	// #0
 112cff0:	aa1603e0 	mov	x0, x22
	ecc_key ltc_peer_eph_key = { };
 112cff4:	911263f5 	add	x21, sp, #0x498
	ecc_key ltc_peer_key = { };
 112cff8:	94005b3a 	bl	1143ce0 <memset>
	ecc_key ltc_peer_eph_key = { };
 112cffc:	d2801f02 	mov	x2, #0xf8                  	// #248
 112d000:	52800001 	mov	w1, #0x0                   	// #0
 112d004:	aa1503e0 	mov	x0, x21
 112d008:	94005b36 	bl	1143ce0 <memset>

	res = ecc_populate_ltc_private_key(&ltc_my_key, my_key,
 112d00c:	528008a2 	mov	w2, #0x45                  	// #69
 112d010:	aa1b03e1 	mov	x1, x27
 112d014:	aa1803e0 	mov	x0, x24
 112d018:	d2800003 	mov	x3, #0x0                   	// #0
 112d01c:	72ac0002 	movk	w2, #0x6000, lsl #16
 112d020:	97fff476 	bl	112a1f8 <ecc_populate_ltc_private_key>
 112d024:	2a0003fc 	mov	w28, w0
					   TEE_ALG_SM2_KEP, NULL);
	if (res)
 112d028:	35000940 	cbnz	w0, 112d150 <crypto_acipher_sm2_kep_derive+0x1c8>
		goto out;

	res = ecc_populate_ltc_private_key(&ltc_my_eph_key, my_eph_key,
 112d02c:	528008a2 	mov	w2, #0x45                  	// #69
 112d030:	aa1a03e1 	mov	x1, x26
 112d034:	aa1903e0 	mov	x0, x25
 112d038:	d2800003 	mov	x3, #0x0                   	// #0
 112d03c:	72ac0002 	movk	w2, #0x6000, lsl #16
 112d040:	97fff46e 	bl	112a1f8 <ecc_populate_ltc_private_key>
 112d044:	2a0003fc 	mov	w28, w0
					   TEE_ALG_SM2_KEP, NULL);
	if (res)
 112d048:	35000840 	cbnz	w0, 112d150 <crypto_acipher_sm2_kep_derive+0x1c8>
		goto out;

	res = ecc_populate_ltc_public_key(&ltc_peer_key, peer_key,
 112d04c:	528008a2 	mov	w2, #0x45                  	// #69
 112d050:	aa1703e1 	mov	x1, x23
 112d054:	aa1603e0 	mov	x0, x22
 112d058:	d2800003 	mov	x3, #0x0                   	// #0
 112d05c:	72ac0002 	movk	w2, #0x6000, lsl #16
 112d060:	97fff4da 	bl	112a3c8 <ecc_populate_ltc_public_key>
 112d064:	2a0003fc 	mov	w28, w0
					  TEE_ALG_SM2_KEP, NULL);
	if (res)
 112d068:	35000740 	cbnz	w0, 112d150 <crypto_acipher_sm2_kep_derive+0x1c8>
		goto out;

	res = ecc_populate_ltc_public_key(&ltc_peer_eph_key, peer_eph_key,
 112d06c:	528008a2 	mov	w2, #0x45                  	// #69
 112d070:	aa1403e1 	mov	x1, x20
 112d074:	aa1503e0 	mov	x0, x21
 112d078:	d2800003 	mov	x3, #0x0                   	// #0
 112d07c:	72ac0002 	movk	w2, #0x6000, lsl #16
 112d080:	97fff4d2 	bl	112a3c8 <ecc_populate_ltc_public_key>
 112d084:	2a0003fc 	mov	w28, w0
					  TEE_ALG_SM2_KEP, NULL);
	if (res)
 112d088:	35000640 	cbnz	w0, 112d150 <crypto_acipher_sm2_kep_derive+0x1c8>
	ecc_key *initiator_eph_key = p->is_initiator ? my_eph_key :
 112d08c:	39404260 	ldrb	w0, [x19, #16]
	uint8_t xUyUZAZB[2 * SM2_INT_SIZE_BYTES + 2 * TEE_SM3_HASH_SIZE] = { };
 112d090:	a9137fff 	stp	xzr, xzr, [sp, #304]
 112d094:	a9147fff 	stp	xzr, xzr, [sp, #320]
 112d098:	a9157fff 	stp	xzr, xzr, [sp, #336]
 112d09c:	a9167fff 	stp	xzr, xzr, [sp, #352]
 112d0a0:	a9177fff 	stp	xzr, xzr, [sp, #368]
 112d0a4:	a9187fff 	stp	xzr, xzr, [sp, #384]
 112d0a8:	a9197fff 	stp	xzr, xzr, [sp, #400]
 112d0ac:	a91a7fff 	stp	xzr, xzr, [sp, #416]
	ecc_key *initiator_eph_key = p->is_initiator ? my_eph_key :
 112d0b0:	34000720 	cbz	w0, 112d194 <crypto_acipher_sm2_kep_derive+0x20c>
	ecc_key *responder_eph_key = p->is_initiator ? peer_eph_key :
 112d0b4:	aa1503fb 	mov	x27, x21
	ecc_key *initiator_eph_key = p->is_initiator ? my_eph_key :
 112d0b8:	f9003ff9 	str	x25, [sp, #120]
	ecc_key *initiator_key = p->is_initiator ? my_key : peer_key;
 112d0bc:	a908e3f6 	stp	x22, x24, [sp, #136]
	ltc_res = mp_init_multi(&x1bar, &x2bar, &tA, &h, &htA, &mu, &ma, &one,
 112d0c0:	9102c3e1 	add	x1, sp, #0xb0
 112d0c4:	f90003ff 	str	xzr, [sp]
 112d0c8:	9103a3e7 	add	x7, sp, #0xe8
 112d0cc:	910383e6 	add	x6, sp, #0xe0
 112d0d0:	910363e5 	add	x5, sp, #0xd8
 112d0d4:	910323e4 	add	x4, sp, #0xc8
 112d0d8:	910303e3 	add	x3, sp, #0xc0
 112d0dc:	9102e3e2 	add	x2, sp, #0xb8
 112d0e0:	9102a3e0 	add	x0, sp, #0xa8
	int inf = 0;
 112d0e4:	b900a7ff 	str	wzr, [sp, #164]
	void *x2bar = NULL;
 112d0e8:	a90affff 	stp	xzr, xzr, [sp, #168]
	void *h = NULL;
 112d0ec:	a90bffff 	stp	xzr, xzr, [sp, #184]
	void *mp = NULL;
 112d0f0:	a90cffff 	stp	xzr, xzr, [sp, #200]
	void *ma = NULL;
 112d0f4:	a90dffff 	stp	xzr, xzr, [sp, #216]
	void *one = NULL;
 112d0f8:	f90077ff 	str	xzr, [sp, #232]
	void *n = my_key->dp.order;
 112d0fc:	f940effc 	ldr	x28, [sp, #472]
	ltc_res = mp_init_multi(&x1bar, &x2bar, &tA, &h, &htA, &mu, &ma, &one,
 112d100:	9400136d 	bl	1131eb4 <ltc_init_multi>
	if (ltc_res != CRYPT_OK) {
 112d104:	b0000161 	adrp	x1, 115a000 <__scattered_array_1phys_mem_map+0x8>
 112d108:	f90043e1 	str	x1, [sp, #128]
 112d10c:	340004c0 	cbz	w0, 112d1a4 <crypto_acipher_sm2_kep_derive+0x21c>
	ecc_point *U = NULL;
 112d110:	d2800014 	mov	x20, #0x0                   	// #0
		res = TEE_ERROR_OUT_OF_MEMORY;
 112d114:	129ffe7c 	mov	w28, #0xffff000c            	// #-65524
	mp_montgomery_free(mp);
 112d118:	b0000160 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 112d11c:	f941d400 	ldr	x0, [x0, #936]
 112d120:	f940a401 	ldr	x1, [x0, #328]
 112d124:	f9406be0 	ldr	x0, [sp, #208]
 112d128:	d63f0020 	blr	x1
	ltc_ecc_del_point(U);
 112d12c:	aa1403e0 	mov	x0, x20
 112d130:	94002957 	bl	113768c <ltc_ecc_del_point>
	mp_clear_multi(x1bar, x2bar, tA, h, htA, mu, ma, one, NULL);
 112d134:	a94a87e0 	ldp	x0, x1, [sp, #168]
 112d138:	f90003ff 	str	xzr, [sp]
 112d13c:	a94b8fe2 	ldp	x2, x3, [sp, #184]
 112d140:	a94d9be5 	ldp	x5, x6, [sp, #216]
 112d144:	f94067e4 	ldr	x4, [sp, #200]
 112d148:	f94077e7 	ldr	x7, [sp, #232]
 112d14c:	940013f4 	bl	113211c <ltc_deinit_multi>
		goto out;

	res = sm2_kep_derive(&ltc_my_key, &ltc_my_eph_key, &ltc_peer_key,
			     &ltc_peer_eph_key, p);
out:
	ecc_free(&ltc_peer_eph_key);
 112d150:	aa1503e0 	mov	x0, x21
 112d154:	940020da 	bl	11354bc <ecc_free>
	ecc_free(&ltc_peer_key);
 112d158:	aa1603e0 	mov	x0, x22
 112d15c:	940020d8 	bl	11354bc <ecc_free>
	ecc_free(&ltc_my_eph_key);
 112d160:	aa1903e0 	mov	x0, x25
 112d164:	940020d6 	bl	11354bc <ecc_free>
	ecc_free(&ltc_my_key);
 112d168:	aa1803e0 	mov	x0, x24
 112d16c:	940020d4 	bl	11354bc <ecc_free>
	return res;
}
 112d170:	2a1c03e0 	mov	w0, w28
 112d174:	a9417bfd 	ldp	x29, x30, [sp, #16]
 112d178:	a94253f3 	ldp	x19, x20, [sp, #32]
 112d17c:	a9435bf5 	ldp	x21, x22, [sp, #48]
 112d180:	a94463f7 	ldp	x23, x24, [sp, #64]
 112d184:	a9456bf9 	ldp	x25, x26, [sp, #80]
 112d188:	a94673fb 	ldp	x27, x28, [sp, #96]
 112d18c:	911643ff 	add	sp, sp, #0x590
 112d190:	d65f03c0 	ret
	ecc_key *responder_eph_key = p->is_initiator ? peer_eph_key :
 112d194:	aa1903fb 	mov	x27, x25
	ecc_key *initiator_eph_key = p->is_initiator ? my_eph_key :
 112d198:	f9003ff5 	str	x21, [sp, #120]
	ecc_key *initiator_key = p->is_initiator ? my_key : peer_key;
 112d19c:	a908dbf8 	stp	x24, x22, [sp, #136]
 112d1a0:	17ffffc8 	b	112d0c0 <crypto_acipher_sm2_kep_derive+0x138>
	U = ltc_ecc_new_point();
 112d1a4:	94002924 	bl	1137634 <ltc_ecc_new_point>
 112d1a8:	aa0003f4 	mov	x20, x0
	if (!U) {
 112d1ac:	b4fffb20 	cbz	x0, 112d110 <crypto_acipher_sm2_kep_derive+0x188>
	mp_to_unsigned_bin2(my_eph_key->pubkey.x, tmp, SM2_INT_SIZE_BYTES);
 112d1b0:	b0000160 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 112d1b4:	f941c3f7 	ldr	x23, [sp, #896]
 112d1b8:	f941d41a 	ldr	x26, [x0, #936]
 112d1bc:	aa1703e0 	mov	x0, x23
 112d1c0:	a9498b41 	ldp	x1, x2, [x26, #152]
 112d1c4:	f9004fe2 	str	x2, [sp, #152]
 112d1c8:	d63f0020 	blr	x1
 112d1cc:	9103c3e1 	add	x1, sp, #0xf0
 112d1d0:	f90043e1 	str	x1, [sp, #128]
 112d1d4:	f9404fe2 	ldr	x2, [sp, #152]
 112d1d8:	d2800401 	mov	x1, #0x20                  	// #32
 112d1dc:	cb000021 	sub	x1, x1, x0
 112d1e0:	f94043e0 	ldr	x0, [sp, #128]
 112d1e4:	8b010001 	add	x1, x0, x1
 112d1e8:	aa1703e0 	mov	x0, x23
 112d1ec:	d63f0040 	blr	x2
	tmp[SM2_INT_SIZE_BYTES / 2] |= 0x80;
 112d1f0:	394403e0 	ldrb	w0, [sp, #256]
	mp_read_unsigned_bin(x1bar, tmp + SM2_INT_SIZE_BYTES / 2,
 112d1f4:	d2800202 	mov	x2, #0x10                  	// #16
 112d1f8:	f9405743 	ldr	x3, [x26, #168]
	tmp[SM2_INT_SIZE_BYTES / 2] |= 0x80;
 112d1fc:	32196000 	orr	w0, w0, #0xffffff80
 112d200:	390403e0 	strb	w0, [sp, #256]
	mp_read_unsigned_bin(x1bar, tmp + SM2_INT_SIZE_BYTES / 2,
 112d204:	f94043e0 	ldr	x0, [sp, #128]
 112d208:	91004017 	add	x23, x0, #0x10
 112d20c:	f94057e0 	ldr	x0, [sp, #168]
 112d210:	aa1703e1 	mov	x1, x23
 112d214:	d63f0060 	blr	x3
	ltc_res = mp_mulmod(x1bar, my_eph_key->k, n, tA);
 112d218:	f94057e0 	ldr	x0, [sp, #168]
 112d21c:	aa1c03e2 	mov	x2, x28
 112d220:	f9405fe3 	ldr	x3, [sp, #184]
 112d224:	f9408f45 	ldr	x5, [x26, #280]
 112d228:	f941cfe1 	ldr	x1, [sp, #920]
 112d22c:	d63f00a0 	blr	x5
	if (ltc_res != CRYPT_OK)
 112d230:	35001620 	cbnz	w0, 112d4f4 <crypto_acipher_sm2_kep_derive+0x56c>
	ltc_res = mp_addmod(tA, my_key->k, n, tA);
 112d234:	f9405fe3 	ldr	x3, [sp, #184]
 112d238:	aa1c03e2 	mov	x2, x28
 112d23c:	f940cf45 	ldr	x5, [x26, #408]
 112d240:	aa0303e0 	mov	x0, x3
 112d244:	f94153e1 	ldr	x1, [sp, #672]
 112d248:	d63f00a0 	blr	x5
	if (ltc_res != CRYPT_OK)
 112d24c:	35001540 	cbnz	w0, 112d4f4 <crypto_acipher_sm2_kep_derive+0x56c>
	ltc_res = ltc_ecc_is_point(&peer_eph_key->dp, peer_eph_key->pubkey.x,
 112d250:	f942bbe1 	ldr	x1, [sp, #1392]
 112d254:	910022a0 	add	x0, x21, #0x8
 112d258:	f942bfe2 	ldr	x2, [sp, #1400]
 112d25c:	9400250f 	bl	1136698 <ltc_ecc_is_point>
	if (ltc_res != CRYPT_OK)
 112d260:	350014a0 	cbnz	w0, 112d4f4 <crypto_acipher_sm2_kep_derive+0x56c>
	mp_to_unsigned_bin2(peer_eph_key->pubkey.x, tmp, SM2_INT_SIZE_BYTES);
 112d264:	a9498b41 	ldp	x1, x2, [x26, #152]
 112d268:	f9004fe2 	str	x2, [sp, #152]
 112d26c:	f942bbfc 	ldr	x28, [sp, #1392]
 112d270:	aa1c03e0 	mov	x0, x28
 112d274:	d63f0020 	blr	x1
 112d278:	f9404fe2 	ldr	x2, [sp, #152]
 112d27c:	d2800401 	mov	x1, #0x20                  	// #32
 112d280:	cb000021 	sub	x1, x1, x0
 112d284:	f94043e0 	ldr	x0, [sp, #128]
 112d288:	8b010001 	add	x1, x0, x1
 112d28c:	aa1c03e0 	mov	x0, x28
 112d290:	d63f0040 	blr	x2
	tmp[SM2_INT_SIZE_BYTES / 2] |= 0x80;
 112d294:	394403e0 	ldrb	w0, [sp, #256]
	mp_read_unsigned_bin(x2bar, tmp + SM2_INT_SIZE_BYTES / 2,
 112d298:	aa1703e1 	mov	x1, x23
 112d29c:	f9405743 	ldr	x3, [x26, #168]
	tmp[SM2_INT_SIZE_BYTES / 2] |= 0x80;
 112d2a0:	32196000 	orr	w0, w0, #0xffffff80
 112d2a4:	390403e0 	strb	w0, [sp, #256]
	mp_read_unsigned_bin(x2bar, tmp + SM2_INT_SIZE_BYTES / 2,
 112d2a8:	d2800202 	mov	x2, #0x10                  	// #16
 112d2ac:	f9405be0 	ldr	x0, [sp, #176]
 112d2b0:	d63f0060 	blr	x3
	ltc_res = mp_montgomery_setup(peer_key->dp.prime, &mp);
 112d2b4:	f9409b42 	ldr	x2, [x26, #304]
 112d2b8:	910343e1 	add	x1, sp, #0xd0
 112d2bc:	f941dbe0 	ldr	x0, [sp, #944]
 112d2c0:	d63f0040 	blr	x2
	if (ltc_res != CRYPT_OK)
 112d2c4:	35001180 	cbnz	w0, 112d4f4 <crypto_acipher_sm2_kep_derive+0x56c>
	ltc_res = mp_montgomery_normalization(mu, peer_key->dp.prime);
 112d2c8:	f9406fe0 	ldr	x0, [sp, #216]
 112d2cc:	f9409f42 	ldr	x2, [x26, #312]
 112d2d0:	f941dbe1 	ldr	x1, [sp, #944]
 112d2d4:	d63f0040 	blr	x2
	if (ltc_res != CRYPT_OK)
 112d2d8:	350010e0 	cbnz	w0, 112d4f4 <crypto_acipher_sm2_kep_derive+0x56c>
	ltc_res = mp_mulmod(peer_key->dp.A, mu, peer_key->dp.prime, ma);
 112d2dc:	a94d8fe1 	ldp	x1, x3, [sp, #216]
 112d2e0:	f9408f45 	ldr	x5, [x26, #280]
 112d2e4:	f941dbe2 	ldr	x2, [sp, #944]
 112d2e8:	f941dfe0 	ldr	x0, [sp, #952]
 112d2ec:	d63f00a0 	blr	x5
	if (ltc_res != CRYPT_OK)
 112d2f0:	35001020 	cbnz	w0, 112d4f4 <crypto_acipher_sm2_kep_derive+0x56c>
	ltc_res = mp_set_int(one, 1);
 112d2f4:	f9402342 	ldr	x2, [x26, #64]
 112d2f8:	d2800021 	mov	x1, #0x1                   	// #1
 112d2fc:	f94077e0 	ldr	x0, [sp, #232]
 112d300:	d63f0040 	blr	x2
	if (ltc_res != CRYPT_OK)
 112d304:	35000f80 	cbnz	w0, 112d4f4 <crypto_acipher_sm2_kep_derive+0x56c>
	ltc_res = ltc_ecc_mul2add(&peer_key->pubkey, one, &peer_eph_key->pubkey,
 112d308:	a94e07e5 	ldp	x5, x1, [sp, #224]
 112d30c:	aa1403e4 	mov	x4, x20
 112d310:	f9405be3 	ldr	x3, [sp, #176]
 112d314:	910362a2 	add	x2, x21, #0xd8
 112d318:	f941dbe6 	ldr	x6, [sp, #944]
 112d31c:	910362c0 	add	x0, x22, #0xd8
 112d320:	94002761 	bl	11370a4 <ltc_ecc_mul2add>
	if (ltc_res != CRYPT_OK)
 112d324:	35000e80 	cbnz	w0, 112d4f4 <crypto_acipher_sm2_kep_derive+0x56c>
	ltc_res = mp_set_int(h, peer_key->dp.cofactor);
 112d328:	b0000160 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 112d32c:	f941f7e1 	ldr	x1, [sp, #1000]
 112d330:	f941d41c 	ldr	x28, [x0, #936]
 112d334:	f94063e0 	ldr	x0, [sp, #192]
 112d338:	f9402382 	ldr	x2, [x28, #64]
 112d33c:	d63f0040 	blr	x2
	if (ltc_res != CRYPT_OK)
 112d340:	35000da0 	cbnz	w0, 112d4f4 <crypto_acipher_sm2_kep_derive+0x56c>
	ltc_res = mp_mul(h, tA, htA);
 112d344:	a94b83e1 	ldp	x1, x0, [sp, #184]
 112d348:	f94067e2 	ldr	x2, [sp, #200]
 112d34c:	f9406b83 	ldr	x3, [x28, #208]
 112d350:	d63f0060 	blr	x3
	if (ltc_res != CRYPT_OK)
 112d354:	35000d00 	cbnz	w0, 112d4f4 <crypto_acipher_sm2_kep_derive+0x56c>
	ltc_res = ltc_ecc_mulmod(htA, U, U, peer_key->dp.A, peer_key->dp.prime,
 112d358:	f94067e0 	ldr	x0, [sp, #200]
 112d35c:	aa1403e2 	mov	x2, x20
 112d360:	f941dbe4 	ldr	x4, [sp, #944]
 112d364:	aa1403e1 	mov	x1, x20
 112d368:	f941dfe3 	ldr	x3, [sp, #952]
 112d36c:	52800025 	mov	w5, #0x1                   	// #1
 112d370:	9400260b 	bl	1136b9c <ltc_ecc_mulmod>
	if (ltc_res != CRYPT_OK)
 112d374:	35000c00 	cbnz	w0, 112d4f4 <crypto_acipher_sm2_kep_derive+0x56c>
	ltc_res = ltc_ecc_is_point_at_infinity(U, peer_key->dp.prime, &inf);
 112d378:	f941dbe1 	ldr	x1, [sp, #944]
 112d37c:	910293e2 	add	x2, sp, #0xa4
 112d380:	aa1403e0 	mov	x0, x20
 112d384:	9400253e 	bl	113687c <ltc_ecc_is_point_at_infinity>
	if (inf)
 112d388:	b940a7e1 	ldr	w1, [sp, #164]
 112d38c:	2a010000 	orr	w0, w0, w1
 112d390:	35000b20 	cbnz	w0, 112d4f4 <crypto_acipher_sm2_kep_derive+0x56c>
	mp_to_unsigned_bin2(U->x, xUyUZAZB, SM2_INT_SIZE_BYTES);
 112d394:	a9498f81 	ldp	x1, x3, [x28, #152]
 112d398:	f9004fe3 	str	x3, [sp, #152]
 112d39c:	f9400282 	ldr	x2, [x20]
 112d3a0:	f90043e2 	str	x2, [sp, #128]
 112d3a4:	9104c3f7 	add	x23, sp, #0x130
 112d3a8:	aa0203e0 	mov	x0, x2
	res = sm2_kep_compute_Z(xUyUZAZB + 2 * SM2_INT_SIZE_BYTES,
 112d3ac:	910102fa 	add	x26, x23, #0x40
	mp_to_unsigned_bin2(U->x, xUyUZAZB, SM2_INT_SIZE_BYTES);
 112d3b0:	d63f0020 	blr	x1
 112d3b4:	cb0002e1 	sub	x1, x23, x0
 112d3b8:	f94043e2 	ldr	x2, [sp, #128]
 112d3bc:	91008021 	add	x1, x1, #0x20
 112d3c0:	f9404fe3 	ldr	x3, [sp, #152]
 112d3c4:	aa0203e0 	mov	x0, x2
 112d3c8:	d63f0060 	blr	x3
	mp_to_unsigned_bin2(U->y, xUyUZAZB + SM2_INT_SIZE_BYTES,
 112d3cc:	a9498f81 	ldp	x1, x3, [x28, #152]
 112d3d0:	f9004fe3 	str	x3, [sp, #152]
 112d3d4:	f9400682 	ldr	x2, [x20, #8]
 112d3d8:	f90043e2 	str	x2, [sp, #128]
 112d3dc:	aa0203e0 	mov	x0, x2
 112d3e0:	d63f0020 	blr	x1
 112d3e4:	cb0002e1 	sub	x1, x23, x0
 112d3e8:	f94043e2 	ldr	x2, [sp, #128]
 112d3ec:	91010021 	add	x1, x1, #0x40
 112d3f0:	f9404fe3 	ldr	x3, [sp, #152]
 112d3f4:	aa0203e0 	mov	x0, x2
 112d3f8:	d63f0060 	blr	x3
	res = sm2_kep_compute_Z(xUyUZAZB + 2 * SM2_INT_SIZE_BYTES,
 112d3fc:	a9418a61 	ldp	x1, x2, [x19, #24]
 112d400:	aa1a03e0 	mov	x0, x26
 112d404:	f9404be3 	ldr	x3, [sp, #144]
 112d408:	97fffe55 	bl	112cd5c <sm2_kep_compute_Z.constprop.0>
 112d40c:	2a0003fc 	mov	w28, w0
	if (res)
 112d410:	35ffe840 	cbnz	w0, 112d118 <crypto_acipher_sm2_kep_derive+0x190>
	res = sm2_kep_compute_Z(xUyUZAZB + 2 * SM2_INT_SIZE_BYTES +
 112d414:	a9428a61 	ldp	x1, x2, [x19, #40]
 112d418:	910182e0 	add	x0, x23, #0x60
 112d41c:	f94047e3 	ldr	x3, [sp, #136]
 112d420:	97fffe4f 	bl	112cd5c <sm2_kep_compute_Z.constprop.0>
 112d424:	2a0003fc 	mov	w28, w0
	if (res)
 112d428:	35ffe780 	cbnz	w0, 112d118 <crypto_acipher_sm2_kep_derive+0x190>
	res = sm2_kdf(xUyUZAZB, sizeof(xUyUZAZB), p->out, p->out_len);
 112d42c:	a9400e62 	ldp	x2, x3, [x19]
 112d430:	aa1703e0 	mov	x0, x23
 112d434:	d2801001 	mov	x1, #0x80                  	// #128
 112d438:	97ff8b78 	bl	1110218 <sm2_kdf>
 112d43c:	2a0003fc 	mov	w28, w0
	if (res)
 112d440:	35ffe6c0 	cbnz	w0, 112d118 <crypto_acipher_sm2_kep_derive+0x190>
	if (p->conf_in) {
 112d444:	f9401e60 	ldr	x0, [x19, #56]
 112d448:	b4000380 	cbz	x0, 112d4b8 <crypto_acipher_sm2_kep_derive+0x530>
		uint8_t flag = p->is_initiator ? 0x02 : 0x03;
 112d44c:	39404260 	ldrb	w0, [x19, #16]
 112d450:	7100001f 	cmp	w0, #0x0
		if (p->conf_in_len < TEE_SM3_HASH_SIZE) {
 112d454:	f9402260 	ldr	x0, [x19, #64]
		uint8_t flag = p->is_initiator ? 0x02 : 0x03;
 112d458:	1a9f17e1 	cset	w1, eq  // eq = none
 112d45c:	11000821 	add	w1, w1, #0x2
		if (p->conf_in_len < TEE_SM3_HASH_SIZE) {
 112d460:	f1007c1f 	cmp	x0, #0x1f
 112d464:	54000249 	b.ls	112d4ac <crypto_acipher_sm2_kep_derive+0x524>  // b.plast
		res = sm2_kep_compute_S(S1, sizeof(S1), flag, U,
 112d468:	f9403fe4 	ldr	x4, [sp, #120]
 112d46c:	910443e6 	add	x6, sp, #0x110
 112d470:	aa1b03e5 	mov	x5, x27
 112d474:	aa1a03e3 	mov	x3, x26
 112d478:	aa1403e2 	mov	x2, x20
 112d47c:	aa0603e0 	mov	x0, x6
 112d480:	f90043e6 	str	x6, [sp, #128]
 112d484:	97fffd95 	bl	112cad8 <sm2_kep_compute_S.constprop.0>
		if (res)
 112d488:	35000140 	cbnz	w0, 112d4b0 <crypto_acipher_sm2_kep_derive+0x528>
		if (consttime_memcmp(S1, p->conf_in, sizeof(S1))) {
 112d48c:	f9401e61 	ldr	x1, [x19, #56]
 112d490:	d2800402 	mov	x2, #0x20                  	// #32
 112d494:	f94043e6 	ldr	x6, [sp, #128]
 112d498:	aa0603e0 	mov	x0, x6
 112d49c:	94005ebd 	bl	1144f90 <consttime_memcmp>
 112d4a0:	340000c0 	cbz	w0, 112d4b8 <crypto_acipher_sm2_kep_derive+0x530>
			res = TEE_ERROR_BAD_STATE;
 112d4a4:	129fff00 	mov	w0, #0xffff0007            	// #-65529
 112d4a8:	14000002 	b	112d4b0 <crypto_acipher_sm2_kep_derive+0x528>
			res = TEE_ERROR_BAD_PARAMETERS;
 112d4ac:	129fff20 	mov	w0, #0xffff0006            	// #-65530
		res = sm2_kep_compute_S(p->conf_out, TEE_SM3_HASH_SIZE, flag, U,
 112d4b0:	2a0003fc 	mov	w28, w0
out:
 112d4b4:	17ffff19 	b	112d118 <crypto_acipher_sm2_kep_derive+0x190>
	if (p->conf_out) {
 112d4b8:	f9402660 	ldr	x0, [x19, #72]
 112d4bc:	b4ffe2e0 	cbz	x0, 112d118 <crypto_acipher_sm2_kep_derive+0x190>
		uint8_t flag = p->is_initiator ? 0x03 : 0x02;
 112d4c0:	39404261 	ldrb	w1, [x19, #16]
		if (p->conf_out_len < TEE_SM3_HASH_SIZE) {
 112d4c4:	f9402a62 	ldr	x2, [x19, #80]
		uint8_t flag = p->is_initiator ? 0x03 : 0x02;
 112d4c8:	7100003f 	cmp	w1, #0x0
 112d4cc:	1a9f07e1 	cset	w1, ne  // ne = any
 112d4d0:	11000821 	add	w1, w1, #0x2
		if (p->conf_out_len < TEE_SM3_HASH_SIZE) {
 112d4d4:	f1007c5f 	cmp	x2, #0x1f
 112d4d8:	54000129 	b.ls	112d4fc <crypto_acipher_sm2_kep_derive+0x574>  // b.plast
		res = sm2_kep_compute_S(p->conf_out, TEE_SM3_HASH_SIZE, flag, U,
 112d4dc:	f9403fe4 	ldr	x4, [sp, #120]
 112d4e0:	aa1b03e5 	mov	x5, x27
 112d4e4:	910102e3 	add	x3, x23, #0x40
 112d4e8:	aa1403e2 	mov	x2, x20
 112d4ec:	97fffd7b 	bl	112cad8 <sm2_kep_compute_S.constprop.0>
 112d4f0:	17fffff0 	b	112d4b0 <crypto_acipher_sm2_kep_derive+0x528>
	TEE_Result res = TEE_ERROR_BAD_STATE;
 112d4f4:	129fff1c 	mov	w28, #0xffff0007            	// #-65529
 112d4f8:	17ffff08 	b	112d118 <crypto_acipher_sm2_kep_derive+0x190>
			res = TEE_ERROR_BAD_PARAMETERS;
 112d4fc:	129fff3c 	mov	w28, #0xffff0006            	// #-65530
 112d500:	17ffff06 	b	112d118 <crypto_acipher_sm2_kep_derive+0x190>

000000000112d504 <get_int>:
		return CRYPT_MEM;
	return CRYPT_OK;
}

static unsigned long get_int(void *a)
{
 112d504:	aa0003e1 	mov	x1, x0
	mbedtls_mpi *bn = a;

	if (!bn->n)
 112d508:	f9400400 	ldr	x0, [x0, #8]
 112d50c:	b4000080 	cbz	x0, 112d51c <get_int+0x18>
		return 0;

	return bn->p[bn->n - 1];
 112d510:	f9400821 	ldr	x1, [x1, #16]
 112d514:	8b000c20 	add	x0, x1, x0, lsl #3
 112d518:	f85f8000 	ldur	x0, [x0, #-8]
}
 112d51c:	d65f03c0 	ret

000000000112d520 <get_digit>:
{
	mbedtls_mpi *bn = a;

	COMPILE_TIME_ASSERT(sizeof(ltc_mp_digit) >= sizeof(mbedtls_mpi_uint));

	if (n < 0 || (size_t)n >= bn->n)
 112d520:	37f80101 	tbnz	w1, #31, 112d540 <get_digit+0x20>
 112d524:	f9400403 	ldr	x3, [x0, #8]
 112d528:	93407c22 	sxtw	x2, w1
 112d52c:	eb21c07f 	cmp	x3, w1, sxtw
 112d530:	54000089 	b.ls	112d540 <get_digit+0x20>  // b.plast
		return 0;

	return bn->p[n];
 112d534:	f9400800 	ldr	x0, [x0, #16]
 112d538:	f8627800 	ldr	x0, [x0, x2, lsl #3]
}
 112d53c:	d65f03c0 	ret
		return 0;
 112d540:	d2800000 	mov	x0, #0x0                   	// #0
 112d544:	17fffffe 	b	112d53c <get_digit+0x1c>

000000000112d548 <mpi_rand>:

	return CRYPT_OK;
}

static int mpi_rand(void *a, int size)
{
 112d548:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	if (mbedtls_mpi_fill_random(a, size, rng_read, NULL))
 112d54c:	93407c21 	sxtw	x1, w1
 112d550:	d2800003 	mov	x3, #0x0                   	// #0
{
 112d554:	910003fd 	mov	x29, sp
	if (mbedtls_mpi_fill_random(a, size, rng_read, NULL))
 112d558:	90000002 	adrp	x2, 112d000 <crypto_acipher_sm2_kep_derive+0x78>
 112d55c:	9115e042 	add	x2, x2, #0x578
 112d560:	94005350 	bl	11422a0 <mbedtls_mpi_fill_random>
		return CRYPT_MEM;
 112d564:	7100001f 	cmp	w0, #0x0

	return CRYPT_OK;
}
 112d568:	528001a1 	mov	w1, #0xd                   	// #13
 112d56c:	1a810000 	csel	w0, w0, w1, eq  // eq = none
 112d570:	a8c17bfd 	ldp	x29, x30, [sp], #16
 112d574:	d65f03c0 	ret

000000000112d578 <rng_read>:
{
 112d578:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 112d57c:	aa0103e0 	mov	x0, x1
 112d580:	aa0203e1 	mov	x1, x2
 112d584:	910003fd 	mov	x29, sp
	if (crypto_rng_read(buf, blen))
 112d588:	97ff8809 	bl	110f5ac <crypto_rng_read>
		return MBEDTLS_ERR_MPI_FILE_IO_ERROR;
 112d58c:	7100001f 	cmp	w0, #0x0
}
 112d590:	a8c17bfd 	ldp	x29, x30, [sp], #16
 112d594:	12800020 	mov	w0, #0xfffffffe            	// #-2
 112d598:	1a9f1000 	csel	w0, w0, wzr, ne  // ne = any
 112d59c:	d65f03c0 	ret

000000000112d5a0 <mod>:
{
 112d5a0:	aa0003e3 	mov	x3, x0
 112d5a4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 112d5a8:	aa0203e0 	mov	x0, x2
 112d5ac:	910003fd 	mov	x29, sp
	int res = mbedtls_mpi_mod_mpi(c, a, b);
 112d5b0:	aa0103e2 	mov	x2, x1
 112d5b4:	aa0303e1 	mov	x1, x3
 112d5b8:	94004fcc 	bl	11414e8 <mbedtls_mpi_mod_mpi>
	if (res == MBEDTLS_ERR_MPI_ALLOC_FAILED)
 112d5bc:	3100401f 	cmn	w0, #0x10
 112d5c0:	540000a0 	b.eq	112d5d4 <mod+0x34>  // b.none
	if (res)
 112d5c4:	7100001f 	cmp	w0, #0x0
 112d5c8:	1a9f07e0 	cset	w0, ne  // ne = any
}
 112d5cc:	a8c17bfd 	ldp	x29, x30, [sp], #16
 112d5d0:	d65f03c0 	ret
		return CRYPT_MEM;
 112d5d4:	528001a0 	mov	w0, #0xd                   	// #13
 112d5d8:	17fffffd 	b	112d5cc <mod+0x2c>

000000000112d5dc <isprime>:
{
 112d5dc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	int res = mbedtls_mpi_is_prime(a, rng_read, NULL);
 112d5e0:	90000001 	adrp	x1, 112d000 <crypto_acipher_sm2_kep_derive+0x78>
 112d5e4:	9115e021 	add	x1, x1, #0x578
{
 112d5e8:	910003fd 	mov	x29, sp
 112d5ec:	f9000bf3 	str	x19, [sp, #16]
 112d5f0:	aa0203f3 	mov	x19, x2
	int res = mbedtls_mpi_is_prime(a, rng_read, NULL);
 112d5f4:	d2800002 	mov	x2, #0x0                   	// #0
 112d5f8:	94005525 	bl	1142a8c <mbedtls_mpi_is_prime>
	if (res == MBEDTLS_ERR_MPI_ALLOC_FAILED)
 112d5fc:	3100401f 	cmn	w0, #0x10
 112d600:	54000140 	b.eq	112d628 <isprime+0x4c>  // b.none
	if (res)
 112d604:	340000c0 	cbz	w0, 112d61c <isprime+0x40>
	return CRYPT_OK;
 112d608:	52800000 	mov	w0, #0x0                   	// #0
		*c = LTC_MP_NO;
 112d60c:	b900027f 	str	wzr, [x19]
}
 112d610:	f9400bf3 	ldr	x19, [sp, #16]
 112d614:	a8c27bfd 	ldp	x29, x30, [sp], #32
 112d618:	d65f03c0 	ret
		*c = LTC_MP_YES;
 112d61c:	52800021 	mov	w1, #0x1                   	// #1
 112d620:	b9000261 	str	w1, [x19]
 112d624:	17fffffb 	b	112d610 <isprime+0x34>
		return CRYPT_MEM;
 112d628:	528001a0 	mov	w0, #0xd                   	// #13
 112d62c:	17fffff9 	b	112d610 <isprime+0x34>

000000000112d630 <set_int>:
	if (b32 != b)
 112d630:	f2607c3f 	tst	x1, #0xffffffff00000000
 112d634:	54000281 	b.ne	112d684 <set_int+0x54>  // b.any
{
 112d638:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 112d63c:	910003fd 	mov	x29, sp
	mbedtls_mpi_uint p = b32;
 112d640:	f9000be1 	str	x1, [sp, #16]
	mbedtls_mpi bn = { .s = 1, .n = 1, .p = &p };
 112d644:	52800021 	mov	w1, #0x1                   	// #1
 112d648:	790033e1 	strh	w1, [sp, #24]
 112d64c:	d2800021 	mov	x1, #0x1                   	// #1
 112d650:	f90013e1 	str	x1, [sp, #32]
 112d654:	910043e1 	add	x1, sp, #0x10
 112d658:	790037ff 	strh	wzr, [sp, #26]
 112d65c:	79003bff 	strh	wzr, [sp, #28]
 112d660:	79003fff 	strh	wzr, [sp, #30]
 112d664:	f90017e1 	str	x1, [sp, #40]
	if (mbedtls_mpi_copy(a, &bn))
 112d668:	910063e1 	add	x1, sp, #0x18
 112d66c:	94004aae 	bl	1140124 <mbedtls_mpi_copy>
		return CRYPT_MEM;
 112d670:	7100001f 	cmp	w0, #0x0
 112d674:	528001a1 	mov	w1, #0xd                   	// #13
 112d678:	1a810000 	csel	w0, w0, w1, eq  // eq = none
}
 112d67c:	a8c37bfd 	ldp	x29, x30, [sp], #48
 112d680:	d65f03c0 	ret
		return CRYPT_INVALID_ARG;
 112d684:	52800200 	mov	w0, #0x10                  	// #16
}
 112d688:	d65f03c0 	ret

000000000112d68c <copy>:
{
 112d68c:	aa0003e2 	mov	x2, x0
 112d690:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 112d694:	aa0103e0 	mov	x0, x1
 112d698:	910003fd 	mov	x29, sp
	if (mbedtls_mpi_copy(b, a))
 112d69c:	aa0203e1 	mov	x1, x2
 112d6a0:	94004aa1 	bl	1140124 <mbedtls_mpi_copy>
		return CRYPT_MEM;
 112d6a4:	7100001f 	cmp	w0, #0x0
}
 112d6a8:	528001a1 	mov	w1, #0xd                   	// #13
 112d6ac:	a8c17bfd 	ldp	x29, x30, [sp], #16
 112d6b0:	1a810000 	csel	w0, w0, w1, eq  // eq = none
 112d6b4:	d65f03c0 	ret

000000000112d6b8 <neg>:
{
 112d6b8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 112d6bc:	910003fd 	mov	x29, sp
 112d6c0:	f9000bf3 	str	x19, [sp, #16]
 112d6c4:	aa0103f3 	mov	x19, x1
	if (mbedtls_mpi_copy(b, a))
 112d6c8:	aa0003e1 	mov	x1, x0
 112d6cc:	aa1303e0 	mov	x0, x19
 112d6d0:	94004a95 	bl	1140124 <mbedtls_mpi_copy>
 112d6d4:	350000e0 	cbnz	w0, 112d6f0 <neg+0x38>
	((mbedtls_mpi *)b)->s *= -1;
 112d6d8:	79400261 	ldrh	w1, [x19]
 112d6dc:	4b0103e1 	neg	w1, w1
 112d6e0:	79000261 	strh	w1, [x19]
}
 112d6e4:	f9400bf3 	ldr	x19, [sp, #16]
 112d6e8:	a8c27bfd 	ldp	x29, x30, [sp], #32
 112d6ec:	d65f03c0 	ret
		return CRYPT_MEM;
 112d6f0:	528001a0 	mov	w0, #0xd                   	// #13
 112d6f4:	17fffffc 	b	112d6e4 <neg+0x2c>

000000000112d6f8 <exptmod>:
{
 112d6f8:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
	if (d == a || d == b || d == c) {
 112d6fc:	eb00007f 	cmp	x3, x0
 112d700:	fa411064 	ccmp	x3, x1, #0x4, ne  // ne = any
{
 112d704:	910003fd 	mov	x29, sp
 112d708:	a90153f3 	stp	x19, x20, [sp, #16]
 112d70c:	aa0003f3 	mov	x19, x0
 112d710:	aa0303f4 	mov	x20, x3
 112d714:	a9025bf5 	stp	x21, x22, [sp, #32]
 112d718:	aa0103f5 	mov	x21, x1
 112d71c:	aa0203f6 	mov	x22, x2
 112d720:	f9001bf7 	str	x23, [sp, #48]
	if (d == a || d == b || d == c) {
 112d724:	54000060 	b.eq	112d730 <exptmod+0x38>  // b.none
 112d728:	eb02007f 	cmp	x3, x2
 112d72c:	54000341 	b.ne	112d794 <exptmod+0x9c>  // b.any
		mbedtls_mpi_init_mempool(&dest);
 112d730:	910123f7 	add	x23, sp, #0x48
 112d734:	aa1703e0 	mov	x0, x23
 112d738:	94004a1c 	bl	113ffa8 <mbedtls_mpi_init_mempool>
		res = mbedtls_mpi_exp_mod(&dest, a, b, c, NULL);
 112d73c:	aa1303e1 	mov	x1, x19
 112d740:	aa1603e3 	mov	x3, x22
 112d744:	aa1503e2 	mov	x2, x21
 112d748:	aa1703e0 	mov	x0, x23
 112d74c:	d2800004 	mov	x4, #0x0                   	// #0
 112d750:	940050c3 	bl	1141a5c <mbedtls_mpi_exp_mod>
 112d754:	2a0003f3 	mov	w19, w0
		if (!res)
 112d758:	350000a0 	cbnz	w0, 112d76c <exptmod+0x74>
			res = mbedtls_mpi_copy(d, &dest);
 112d75c:	aa1703e1 	mov	x1, x23
 112d760:	aa1403e0 	mov	x0, x20
 112d764:	94004a70 	bl	1140124 <mbedtls_mpi_copy>
 112d768:	2a0003f3 	mov	w19, w0
		mbedtls_mpi_free(&dest);
 112d76c:	aa1703e0 	mov	x0, x23
 112d770:	94004a18 	bl	113ffd0 <mbedtls_mpi_free>
		return CRYPT_MEM;
 112d774:	7100027f 	cmp	w19, #0x0
}
 112d778:	528001a0 	mov	w0, #0xd                   	// #13
 112d77c:	1a800260 	csel	w0, w19, w0, eq  // eq = none
 112d780:	a94153f3 	ldp	x19, x20, [sp, #16]
 112d784:	a9425bf5 	ldp	x21, x22, [sp, #32]
 112d788:	f9401bf7 	ldr	x23, [sp, #48]
 112d78c:	a8c67bfd 	ldp	x29, x30, [sp], #96
 112d790:	d65f03c0 	ret
		res = mbedtls_mpi_exp_mod(d, a, b, c, NULL);
 112d794:	aa0203e3 	mov	x3, x2
 112d798:	d2800004 	mov	x4, #0x0                   	// #0
 112d79c:	aa0103e2 	mov	x2, x1
 112d7a0:	aa0003e1 	mov	x1, x0
 112d7a4:	aa1403e0 	mov	x0, x20
 112d7a8:	940050ad 	bl	1141a5c <mbedtls_mpi_exp_mod>
 112d7ac:	2a0003f3 	mov	w19, w0
 112d7b0:	17fffff1 	b	112d774 <exptmod+0x7c>

000000000112d7b4 <modi>:
{
 112d7b4:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
 112d7b8:	910003fd 	mov	x29, sp
 112d7bc:	a9025bf5 	stp	x21, x22, [sp, #32]
	mbedtls_mpi_init_mempool(&bn_b);
 112d7c0:	910103f5 	add	x21, sp, #0x40
{
 112d7c4:	aa0203f6 	mov	x22, x2
 112d7c8:	a90153f3 	stp	x19, x20, [sp, #16]
 112d7cc:	aa0103f3 	mov	x19, x1
	mbedtls_mpi_init_mempool(&bn_c);
 112d7d0:	910163f4 	add	x20, sp, #0x58
{
 112d7d4:	f9001bf7 	str	x23, [sp, #48]
 112d7d8:	aa0003f7 	mov	x23, x0
	mbedtls_mpi_init_mempool(&bn_b);
 112d7dc:	aa1503e0 	mov	x0, x21
 112d7e0:	940049f2 	bl	113ffa8 <mbedtls_mpi_init_mempool>
	mbedtls_mpi_init_mempool(&bn_c);
 112d7e4:	aa1403e0 	mov	x0, x20
 112d7e8:	940049f0 	bl	113ffa8 <mbedtls_mpi_init_mempool>
	res = set_int(&bn_b, b);
 112d7ec:	aa1303e1 	mov	x1, x19
 112d7f0:	aa1503e0 	mov	x0, x21
 112d7f4:	97ffff8f 	bl	112d630 <set_int>
	if (res)
 112d7f8:	350002e0 	cbnz	w0, 112d854 <modi+0xa0>
	res = mbedtls_mpi_mod_mpi(&bn_c, &bn_b, a);
 112d7fc:	aa1703e2 	mov	x2, x23
 112d800:	aa1503e1 	mov	x1, x21
 112d804:	aa1403e0 	mov	x0, x20
 112d808:	94004f38 	bl	11414e8 <mbedtls_mpi_mod_mpi>
 112d80c:	2a0003f3 	mov	w19, w0
	if (!res)
 112d810:	35000080 	cbnz	w0, 112d820 <modi+0x6c>
		*c = get_int(&bn_c);
 112d814:	aa1403e0 	mov	x0, x20
 112d818:	97ffff3b 	bl	112d504 <get_int>
 112d81c:	f90002c0 	str	x0, [x22]
	mbedtls_mpi_free(&bn_b);
 112d820:	aa1503e0 	mov	x0, x21
 112d824:	940049eb 	bl	113ffd0 <mbedtls_mpi_free>
	mbedtls_mpi_free(&bn_c);
 112d828:	aa1403e0 	mov	x0, x20
 112d82c:	940049e9 	bl	113ffd0 <mbedtls_mpi_free>
		return CRYPT_MEM;
 112d830:	7100027f 	cmp	w19, #0x0
 112d834:	528001a0 	mov	w0, #0xd                   	// #13
 112d838:	1a800273 	csel	w19, w19, w0, eq  // eq = none
}
 112d83c:	2a1303e0 	mov	w0, w19
 112d840:	a94153f3 	ldp	x19, x20, [sp, #16]
 112d844:	a9425bf5 	ldp	x21, x22, [sp, #32]
 112d848:	f9401bf7 	ldr	x23, [sp, #48]
 112d84c:	a8c77bfd 	ldp	x29, x30, [sp], #112
 112d850:	d65f03c0 	ret
 112d854:	2a0003f3 	mov	w19, w0
 112d858:	17fffff9 	b	112d83c <modi+0x88>

000000000112d85c <montgomery_deinit>:
	free(a);
 112d85c:	14005761 	b	11435e0 <free>

000000000112d860 <compare>:
{
 112d860:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 112d864:	910003fd 	mov	x29, sp
	int ret = mbedtls_mpi_cmp_mpi(a, b);
 112d868:	94004bcd 	bl	114079c <mbedtls_mpi_cmp_mpi>
	if (ret < 0)
 112d86c:	7100001f 	cmp	w0, #0x0
	if (ret > 0)
 112d870:	1a9f07e1 	cset	w1, ne  // ne = any
 112d874:	5a9fa020 	csinv	w0, w1, wzr, ge  // ge = tcont
}
 112d878:	a8c17bfd 	ldp	x29, x30, [sp], #16
 112d87c:	d65f03c0 	ret

000000000112d880 <montgomery_reduce>:
{
 112d880:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
 112d884:	910003fd 	mov	x29, sp
 112d888:	a90153f3 	stp	x19, x20, [sp, #16]
 112d88c:	aa0103f4 	mov	x20, x1
	mbedtls_mpi_init_mempool(&A);
 112d890:	910103f3 	add	x19, sp, #0x40
{
 112d894:	a9025bf5 	stp	x21, x22, [sp, #32]
	mbedtls_mpi_init_mempool(&T);
 112d898:	910163f6 	add	x22, sp, #0x58
{
 112d89c:	aa0003f5 	mov	x21, x0
	mbedtls_mpi_init_mempool(&T);
 112d8a0:	aa1603e0 	mov	x0, x22
{
 112d8a4:	f9001bf7 	str	x23, [sp, #48]
 112d8a8:	aa0203f7 	mov	x23, x2
	mbedtls_mpi_init_mempool(&T);
 112d8ac:	940049bf 	bl	113ffa8 <mbedtls_mpi_init_mempool>
	mbedtls_mpi_init_mempool(&A);
 112d8b0:	aa1303e0 	mov	x0, x19
 112d8b4:	940049bd 	bl	113ffa8 <mbedtls_mpi_init_mempool>
	if (mbedtls_mpi_grow(&T, (N->n + 1) * 2))
 112d8b8:	f9400681 	ldr	x1, [x20, #8]
 112d8bc:	aa1603e0 	mov	x0, x22
 112d8c0:	91000421 	add	x1, x1, #0x1
 112d8c4:	d37ff821 	lsl	x1, x1, #1
 112d8c8:	940049dd 	bl	114003c <mbedtls_mpi_grow>
 112d8cc:	35000200 	cbnz	w0, 112d90c <montgomery_reduce+0x8c>
	if (mbedtls_mpi_cmp_mpi(a, N) > 0) {
 112d8d0:	aa1403e1 	mov	x1, x20
 112d8d4:	aa1503e0 	mov	x0, x21
 112d8d8:	94004bb1 	bl	114079c <mbedtls_mpi_cmp_mpi>
 112d8dc:	7100001f 	cmp	w0, #0x0
 112d8e0:	540001ad 	b.le	112d914 <montgomery_reduce+0x94>
		if (mbedtls_mpi_mod_mpi(&A, a, N))
 112d8e4:	aa1403e2 	mov	x2, x20
 112d8e8:	aa1503e1 	mov	x1, x21
 112d8ec:	aa1303e0 	mov	x0, x19
 112d8f0:	94004efe 	bl	11414e8 <mbedtls_mpi_mod_mpi>
 112d8f4:	350000c0 	cbnz	w0, 112d90c <montgomery_reduce+0x8c>
	if (mbedtls_mpi_grow(&A, N->n + 1))
 112d8f8:	f9400681 	ldr	x1, [x20, #8]
 112d8fc:	aa1303e0 	mov	x0, x19
 112d900:	91000421 	add	x1, x1, #0x1
 112d904:	940049ce 	bl	114003c <mbedtls_mpi_grow>
 112d908:	340000e0 	cbz	w0, 112d924 <montgomery_reduce+0xa4>
	int ret = CRYPT_MEM;
 112d90c:	528001b4 	mov	w20, #0xd                   	// #13
		goto out;
 112d910:	14000010 	b	112d950 <montgomery_reduce+0xd0>
		if (mbedtls_mpi_copy(&A, a))
 112d914:	aa1503e1 	mov	x1, x21
 112d918:	aa1303e0 	mov	x0, x19
 112d91c:	94004a02 	bl	1140124 <mbedtls_mpi_copy>
 112d920:	17fffff5 	b	112d8f4 <montgomery_reduce+0x74>
	if (mbedtls_mpi_montred(&A, N, *mm, &T))
 112d924:	f94002e2 	ldr	x2, [x23]
 112d928:	aa1603e3 	mov	x3, x22
 112d92c:	aa1403e1 	mov	x1, x20
 112d930:	aa1303e0 	mov	x0, x19
 112d934:	9400503c 	bl	1141a24 <mbedtls_mpi_montred>
 112d938:	35fffea0 	cbnz	w0, 112d90c <montgomery_reduce+0x8c>
	if (mbedtls_mpi_copy(a, &A))
 112d93c:	aa1303e1 	mov	x1, x19
 112d940:	aa1503e0 	mov	x0, x21
 112d944:	940049f8 	bl	1140124 <mbedtls_mpi_copy>
 112d948:	2a0003f4 	mov	w20, w0
 112d94c:	35fffe00 	cbnz	w0, 112d90c <montgomery_reduce+0x8c>
	mbedtls_mpi_free(&A);
 112d950:	aa1303e0 	mov	x0, x19
 112d954:	9400499f 	bl	113ffd0 <mbedtls_mpi_free>
	mbedtls_mpi_free(&T);
 112d958:	aa1603e0 	mov	x0, x22
 112d95c:	9400499d 	bl	113ffd0 <mbedtls_mpi_free>
}
 112d960:	2a1403e0 	mov	w0, w20
 112d964:	a94153f3 	ldp	x19, x20, [sp, #16]
 112d968:	a9425bf5 	ldp	x21, x22, [sp, #32]
 112d96c:	f9401bf7 	ldr	x23, [sp, #48]
 112d970:	a8c77bfd 	ldp	x29, x30, [sp], #112
 112d974:	d65f03c0 	ret

000000000112d978 <unsigned_size>:
	return mbedtls_mpi_size(a);
 112d978:	14004a81 	b	114037c <mbedtls_mpi_size>

000000000112d97c <get_digit_count>:
{
 112d97c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 112d980:	910003fd 	mov	x29, sp
	return ROUNDUP(mbedtls_mpi_size(a), sizeof(mbedtls_mpi_uint)) /
 112d984:	94004a7e 	bl	114037c <mbedtls_mpi_size>
 112d988:	91001c00 	add	x0, x0, #0x7
}
 112d98c:	a8c17bfd 	ldp	x29, x30, [sp], #16
 112d990:	d3438800 	ubfx	x0, x0, #3, #32
 112d994:	d65f03c0 	ret

000000000112d998 <montgomery_setup>:
{
 112d998:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 112d99c:	910003fd 	mov	x29, sp
 112d9a0:	a90153f3 	stp	x19, x20, [sp, #16]
 112d9a4:	aa0103f4 	mov	x20, x1
 112d9a8:	aa0003f3 	mov	x19, x0
	*b = malloc(sizeof(mbedtls_mpi_uint));
 112d9ac:	d2800100 	mov	x0, #0x8                   	// #8
 112d9b0:	940056aa 	bl	1143458 <malloc>
 112d9b4:	f9000280 	str	x0, [x20]
	if (!*b)
 112d9b8:	b40000e0 	cbz	x0, 112d9d4 <montgomery_setup+0x3c>
	mbedtls_mpi_montg_init(*b, a);
 112d9bc:	aa1303e1 	mov	x1, x19
 112d9c0:	94004fbe 	bl	11418b8 <mbedtls_mpi_montg_init>
	return CRYPT_OK;
 112d9c4:	52800000 	mov	w0, #0x0                   	// #0
}
 112d9c8:	a94153f3 	ldp	x19, x20, [sp, #16]
 112d9cc:	a8c27bfd 	ldp	x29, x30, [sp], #32
 112d9d0:	d65f03c0 	ret
		return CRYPT_MEM;
 112d9d4:	528001a0 	mov	w0, #0xd                   	// #13
 112d9d8:	17fffffc 	b	112d9c8 <montgomery_setup+0x30>

000000000112d9dc <invmod>:
{
 112d9dc:	aa0003e3 	mov	x3, x0
 112d9e0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 112d9e4:	aa0203e0 	mov	x0, x2
 112d9e8:	910003fd 	mov	x29, sp
	int res = mbedtls_mpi_inv_mod(c, a, b);
 112d9ec:	aa0103e2 	mov	x2, x1
 112d9f0:	aa0303e1 	mov	x1, x3
 112d9f4:	940052f6 	bl	11425cc <mbedtls_mpi_inv_mod>
	if (res == MBEDTLS_ERR_MPI_ALLOC_FAILED)
 112d9f8:	3100401f 	cmn	w0, #0x10
 112d9fc:	540000a0 	b.eq	112da10 <invmod+0x34>  // b.none
	if (res)
 112da00:	7100001f 	cmp	w0, #0x0
 112da04:	1a9f07e0 	cset	w0, ne  // ne = any
}
 112da08:	a8c17bfd 	ldp	x29, x30, [sp], #16
 112da0c:	d65f03c0 	ret
		return CRYPT_MEM;
 112da10:	528001a0 	mov	w0, #0xd                   	// #13
 112da14:	17fffffd 	b	112da08 <invmod+0x2c>

000000000112da18 <mul>:
{
 112da18:	aa0003e3 	mov	x3, x0
 112da1c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 112da20:	aa0203e0 	mov	x0, x2
 112da24:	910003fd 	mov	x29, sp
	if (mbedtls_mpi_mul_mpi(c, a, b))
 112da28:	aa0103e2 	mov	x2, x1
 112da2c:	aa0303e1 	mov	x1, x3
 112da30:	94004c7d 	bl	1140c24 <mbedtls_mpi_mul_mpi>
		return CRYPT_MEM;
 112da34:	7100001f 	cmp	w0, #0x0
}
 112da38:	528001a1 	mov	w1, #0xd                   	// #13
 112da3c:	1a810000 	csel	w0, w0, w1, eq  // eq = none
 112da40:	a8c17bfd 	ldp	x29, x30, [sp], #16
 112da44:	d65f03c0 	ret

000000000112da48 <mulmod>:
{
 112da48:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
 112da4c:	910003fd 	mov	x29, sp
 112da50:	a9025bf5 	stp	x21, x22, [sp, #32]
	mbedtls_mpi_init_mempool(&ta);
 112da54:	910103f6 	add	x22, sp, #0x40
	mbedtls_mpi_init_mempool(&tb);
 112da58:	910163f5 	add	x21, sp, #0x58
{
 112da5c:	a90153f3 	stp	x19, x20, [sp, #16]
 112da60:	aa0203f4 	mov	x20, x2
 112da64:	aa0003f3 	mov	x19, x0
	mbedtls_mpi_init_mempool(&ta);
 112da68:	aa1603e0 	mov	x0, x22
{
 112da6c:	a90363f7 	stp	x23, x24, [sp, #48]
 112da70:	aa0103f8 	mov	x24, x1
 112da74:	aa0303f7 	mov	x23, x3
	mbedtls_mpi_init_mempool(&ta);
 112da78:	9400494c 	bl	113ffa8 <mbedtls_mpi_init_mempool>
	mbedtls_mpi_init_mempool(&tb);
 112da7c:	aa1503e0 	mov	x0, x21
 112da80:	9400494a 	bl	113ffa8 <mbedtls_mpi_init_mempool>
	res = mod(a, c, &ta);
 112da84:	aa1303e0 	mov	x0, x19
 112da88:	aa1603e2 	mov	x2, x22
 112da8c:	aa1403e1 	mov	x1, x20
 112da90:	97fffec4 	bl	112d5a0 <mod>
 112da94:	2a0003f3 	mov	w19, w0
	if (res)
 112da98:	35000240 	cbnz	w0, 112dae0 <mulmod+0x98>
	res = mod(b, c, &tb);
 112da9c:	aa1503e2 	mov	x2, x21
 112daa0:	aa1403e1 	mov	x1, x20
 112daa4:	aa1803e0 	mov	x0, x24
 112daa8:	97fffebe 	bl	112d5a0 <mod>
 112daac:	2a0003f3 	mov	w19, w0
	if (res)
 112dab0:	35000180 	cbnz	w0, 112dae0 <mulmod+0x98>
	res = mul(&ta, &tb, d);
 112dab4:	aa1703e2 	mov	x2, x23
 112dab8:	aa1503e1 	mov	x1, x21
 112dabc:	aa1603e0 	mov	x0, x22
 112dac0:	97ffffd6 	bl	112da18 <mul>
 112dac4:	2a0003f3 	mov	w19, w0
	if (res)
 112dac8:	350000c0 	cbnz	w0, 112dae0 <mulmod+0x98>
	res = mod(d, c, d);
 112dacc:	aa1703e2 	mov	x2, x23
 112dad0:	aa1403e1 	mov	x1, x20
 112dad4:	aa1703e0 	mov	x0, x23
 112dad8:	97fffeb2 	bl	112d5a0 <mod>
 112dadc:	2a0003f3 	mov	w19, w0
	mbedtls_mpi_free(&ta);
 112dae0:	aa1603e0 	mov	x0, x22
 112dae4:	9400493b 	bl	113ffd0 <mbedtls_mpi_free>
	mbedtls_mpi_free(&tb);
 112dae8:	aa1503e0 	mov	x0, x21
 112daec:	94004939 	bl	113ffd0 <mbedtls_mpi_free>
}
 112daf0:	2a1303e0 	mov	w0, w19
 112daf4:	a94153f3 	ldp	x19, x20, [sp, #16]
 112daf8:	a9425bf5 	ldp	x21, x22, [sp, #32]
 112dafc:	a94363f7 	ldp	x23, x24, [sp, #48]
 112db00:	a8c77bfd 	ldp	x29, x30, [sp], #112
 112db04:	d65f03c0 	ret

000000000112db08 <sqrmod>:
	return mulmod(a, a, b, c);
 112db08:	aa0203e3 	mov	x3, x2
 112db0c:	aa0103e2 	mov	x2, x1
 112db10:	aa0003e1 	mov	x1, x0
 112db14:	17ffffcd 	b	112da48 <mulmod>

000000000112db18 <sqr>:
	return mul(a, a, b);
 112db18:	aa0103e2 	mov	x2, x1
 112db1c:	aa0003e1 	mov	x1, x0
 112db20:	17ffffbe 	b	112da18 <mul>

000000000112db24 <gcd>:
{
 112db24:	aa0003e3 	mov	x3, x0
 112db28:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 112db2c:	aa0203e0 	mov	x0, x2
 112db30:	910003fd 	mov	x29, sp
	if (mbedtls_mpi_gcd(c, a, b))
 112db34:	aa0103e2 	mov	x2, x1
 112db38:	aa0303e1 	mov	x1, x3
 112db3c:	94005170 	bl	11420fc <mbedtls_mpi_gcd>
		return CRYPT_MEM;
 112db40:	7100001f 	cmp	w0, #0x0
}
 112db44:	528001a1 	mov	w1, #0xd                   	// #13
 112db48:	1a810000 	csel	w0, w0, w1, eq  // eq = none
 112db4c:	a8c17bfd 	ldp	x29, x30, [sp], #16
 112db50:	d65f03c0 	ret

000000000112db54 <divide>:
{
 112db54:	aa0003e4 	mov	x4, x0
 112db58:	aa0103e5 	mov	x5, x1
 112db5c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 112db60:	aa0203e0 	mov	x0, x2
 112db64:	aa0303e1 	mov	x1, x3
 112db68:	910003fd 	mov	x29, sp
	int res = mbedtls_mpi_div_mpi(c, d, a, b);
 112db6c:	aa0503e3 	mov	x3, x5
 112db70:	aa0403e2 	mov	x2, x4
 112db74:	94004d06 	bl	1140f8c <mbedtls_mpi_div_mpi>
	if (res == MBEDTLS_ERR_MPI_ALLOC_FAILED)
 112db78:	3100401f 	cmn	w0, #0x10
 112db7c:	540000a0 	b.eq	112db90 <divide+0x3c>  // b.none
	if (res)
 112db80:	7100001f 	cmp	w0, #0x0
 112db84:	1a9f07e0 	cset	w0, ne  // ne = any
}
 112db88:	a8c17bfd 	ldp	x29, x30, [sp], #16
 112db8c:	d65f03c0 	ret
		return CRYPT_MEM;
 112db90:	528001a0 	mov	w0, #0xd                   	// #13
 112db94:	17fffffd 	b	112db88 <divide+0x34>

000000000112db98 <lcm>:
{
 112db98:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 112db9c:	910003fd 	mov	x29, sp
 112dba0:	a90153f3 	stp	x19, x20, [sp, #16]
	mbedtls_mpi_init_mempool(&tmp);
 112dba4:	9100e3f4 	add	x20, sp, #0x38
{
 112dba8:	aa0203f3 	mov	x19, x2
 112dbac:	a9025bf5 	stp	x21, x22, [sp, #32]
 112dbb0:	aa0103f6 	mov	x22, x1
 112dbb4:	aa0003f5 	mov	x21, x0
	mbedtls_mpi_init_mempool(&tmp);
 112dbb8:	aa1403e0 	mov	x0, x20
 112dbbc:	940048fb 	bl	113ffa8 <mbedtls_mpi_init_mempool>
	if (mbedtls_mpi_mul_mpi(&tmp, a, b))
 112dbc0:	aa1603e2 	mov	x2, x22
 112dbc4:	aa1503e1 	mov	x1, x21
 112dbc8:	aa1403e0 	mov	x0, x20
 112dbcc:	94004c16 	bl	1140c24 <mbedtls_mpi_mul_mpi>
 112dbd0:	34000120 	cbz	w0, 112dbf4 <lcm+0x5c>
	int res = CRYPT_MEM;
 112dbd4:	528001b3 	mov	w19, #0xd                   	// #13
	mbedtls_mpi_free(&tmp);
 112dbd8:	aa1403e0 	mov	x0, x20
 112dbdc:	940048fd 	bl	113ffd0 <mbedtls_mpi_free>
}
 112dbe0:	2a1303e0 	mov	w0, w19
 112dbe4:	a94153f3 	ldp	x19, x20, [sp, #16]
 112dbe8:	a9425bf5 	ldp	x21, x22, [sp, #32]
 112dbec:	a8c57bfd 	ldp	x29, x30, [sp], #80
 112dbf0:	d65f03c0 	ret
	if (mbedtls_mpi_gcd(c, a, b))
 112dbf4:	aa1603e2 	mov	x2, x22
 112dbf8:	aa1503e1 	mov	x1, x21
 112dbfc:	aa1303e0 	mov	x0, x19
 112dc00:	9400513f 	bl	11420fc <mbedtls_mpi_gcd>
 112dc04:	35fffe80 	cbnz	w0, 112dbd4 <lcm+0x3c>
	res = divide(&tmp, c, c, NULL);
 112dc08:	aa1303e2 	mov	x2, x19
 112dc0c:	aa1303e1 	mov	x1, x19
 112dc10:	aa1403e0 	mov	x0, x20
 112dc14:	d2800003 	mov	x3, #0x0                   	// #0
 112dc18:	97ffffcf 	bl	112db54 <divide>
 112dc1c:	2a0003f3 	mov	w19, w0
 112dc20:	17ffffee 	b	112dbd8 <lcm+0x40>

000000000112dc24 <sub>:
{
 112dc24:	aa0003e3 	mov	x3, x0
 112dc28:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 112dc2c:	aa0203e0 	mov	x0, x2
 112dc30:	910003fd 	mov	x29, sp
	if (mbedtls_mpi_sub_mpi(c, a, b))
 112dc34:	aa0103e2 	mov	x2, x1
 112dc38:	aa0303e1 	mov	x1, x3
 112dc3c:	94004bb9 	bl	1140b20 <mbedtls_mpi_sub_mpi>
		return CRYPT_MEM;
 112dc40:	7100001f 	cmp	w0, #0x0
}
 112dc44:	528001a1 	mov	w1, #0xd                   	// #13
 112dc48:	1a810000 	csel	w0, w0, w1, eq  // eq = none
 112dc4c:	a8c17bfd 	ldp	x29, x30, [sp], #16
 112dc50:	d65f03c0 	ret

000000000112dc54 <subi>:
	if (b32 != b)
 112dc54:	f2607c3f 	tst	x1, #0xffffffff00000000
 112dc58:	54000221 	b.ne	112dc9c <subi+0x48>  // b.any
{
 112dc5c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 112dc60:	910003fd 	mov	x29, sp
	mbedtls_mpi_uint p = b32;
 112dc64:	f9000be1 	str	x1, [sp, #16]
	mbedtls_mpi bn = { .s = 1, .n = 1, .p = &p };
 112dc68:	52800021 	mov	w1, #0x1                   	// #1
 112dc6c:	790033e1 	strh	w1, [sp, #24]
 112dc70:	d2800021 	mov	x1, #0x1                   	// #1
 112dc74:	f90013e1 	str	x1, [sp, #32]
 112dc78:	910043e1 	add	x1, sp, #0x10
 112dc7c:	790037ff 	strh	wzr, [sp, #26]
 112dc80:	79003bff 	strh	wzr, [sp, #28]
 112dc84:	79003fff 	strh	wzr, [sp, #30]
 112dc88:	f90017e1 	str	x1, [sp, #40]
	return sub(a, &bn, c);
 112dc8c:	910063e1 	add	x1, sp, #0x18
 112dc90:	97ffffe5 	bl	112dc24 <sub>
}
 112dc94:	a8c37bfd 	ldp	x29, x30, [sp], #48
 112dc98:	d65f03c0 	ret
		return CRYPT_INVALID_ARG;
 112dc9c:	52800200 	mov	w0, #0x10                  	// #16
}
 112dca0:	d65f03c0 	ret

000000000112dca4 <add>:
{
 112dca4:	aa0003e3 	mov	x3, x0
 112dca8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 112dcac:	aa0203e0 	mov	x0, x2
 112dcb0:	910003fd 	mov	x29, sp
	if (mbedtls_mpi_add_mpi(c, a, b))
 112dcb4:	aa0103e2 	mov	x2, x1
 112dcb8:	aa0303e1 	mov	x1, x3
 112dcbc:	94004b79 	bl	1140aa0 <mbedtls_mpi_add_mpi>
		return CRYPT_MEM;
 112dcc0:	7100001f 	cmp	w0, #0x0
}
 112dcc4:	528001a1 	mov	w1, #0xd                   	// #13
 112dcc8:	1a810000 	csel	w0, w0, w1, eq  // eq = none
 112dccc:	a8c17bfd 	ldp	x29, x30, [sp], #16
 112dcd0:	d65f03c0 	ret

000000000112dcd4 <addi>:
	if (b32 != b)
 112dcd4:	f2607c3f 	tst	x1, #0xffffffff00000000
 112dcd8:	54000221 	b.ne	112dd1c <addi+0x48>  // b.any
{
 112dcdc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 112dce0:	910003fd 	mov	x29, sp
	mbedtls_mpi_uint p = b32;
 112dce4:	f9000be1 	str	x1, [sp, #16]
	mbedtls_mpi bn = { .s = 1, .n = 1, .p = &p };
 112dce8:	52800021 	mov	w1, #0x1                   	// #1
 112dcec:	790033e1 	strh	w1, [sp, #24]
 112dcf0:	d2800021 	mov	x1, #0x1                   	// #1
 112dcf4:	f90013e1 	str	x1, [sp, #32]
 112dcf8:	910043e1 	add	x1, sp, #0x10
 112dcfc:	790037ff 	strh	wzr, [sp, #26]
 112dd00:	79003bff 	strh	wzr, [sp, #28]
 112dd04:	79003fff 	strh	wzr, [sp, #30]
 112dd08:	f90017e1 	str	x1, [sp, #40]
	return add(a, &bn, c);
 112dd0c:	910063e1 	add	x1, sp, #0x18
 112dd10:	97ffffe5 	bl	112dca4 <add>
}
 112dd14:	a8c37bfd 	ldp	x29, x30, [sp], #48
 112dd18:	d65f03c0 	ret
		return CRYPT_INVALID_ARG;
 112dd1c:	52800200 	mov	w0, #0x10                  	// #16
}
 112dd20:	d65f03c0 	ret

000000000112dd24 <unsigned_read>:
{
 112dd24:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 112dd28:	910003fd 	mov	x29, sp
	int res = mbedtls_mpi_read_binary(a, b, len);
 112dd2c:	9400499b 	bl	1140398 <mbedtls_mpi_read_binary>
	if (res == MBEDTLS_ERR_MPI_ALLOC_FAILED)
 112dd30:	3100401f 	cmn	w0, #0x10
 112dd34:	540000a0 	b.eq	112dd48 <unsigned_read+0x24>  // b.none
	if (res)
 112dd38:	7100001f 	cmp	w0, #0x0
 112dd3c:	1a9f07e0 	cset	w0, ne  // ne = any
}
 112dd40:	a8c17bfd 	ldp	x29, x30, [sp], #16
 112dd44:	d65f03c0 	ret
		return CRYPT_MEM;
 112dd48:	528001a0 	mov	w0, #0xd                   	// #13
 112dd4c:	17fffffd 	b	112dd40 <unsigned_read+0x1c>

000000000112dd50 <unsigned_write>:
{
 112dd50:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 112dd54:	910003fd 	mov	x29, sp
 112dd58:	a90153f3 	stp	x19, x20, [sp, #16]
 112dd5c:	aa0003f3 	mov	x19, x0
 112dd60:	aa0103f4 	mov	x20, x1
	return mbedtls_mpi_size(a);
 112dd64:	94004986 	bl	114037c <mbedtls_mpi_size>
	int res = mbedtls_mpi_write_binary(a, b, unsigned_size(a));
 112dd68:	aa0003e2 	mov	x2, x0
 112dd6c:	aa1403e1 	mov	x1, x20
 112dd70:	aa1303e0 	mov	x0, x19
 112dd74:	940049bb 	bl	1140460 <mbedtls_mpi_write_binary>
	if (res == MBEDTLS_ERR_MPI_ALLOC_FAILED)
 112dd78:	3100401f 	cmn	w0, #0x10
 112dd7c:	540000c0 	b.eq	112dd94 <unsigned_write+0x44>  // b.none
	if (res)
 112dd80:	7100001f 	cmp	w0, #0x0
 112dd84:	1a9f07e0 	cset	w0, ne  // ne = any
}
 112dd88:	a94153f3 	ldp	x19, x20, [sp, #16]
 112dd8c:	a8c27bfd 	ldp	x29, x30, [sp], #32
 112dd90:	d65f03c0 	ret
		return CRYPT_MEM;
 112dd94:	528001a0 	mov	w0, #0xd                   	// #13
 112dd98:	17fffffc 	b	112dd88 <unsigned_write+0x38>

000000000112dd9c <write_radix>:
{
 112dd9c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 112dda0:	aa0103e5 	mov	x5, x1
	size_t ol = SIZE_MAX;
 112dda4:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
{
 112dda8:	910003fd 	mov	x29, sp
 112ddac:	2a0203e1 	mov	w1, w2
	int res = mbedtls_mpi_write_string(a, radix, b, ol, &ol);
 112ddb0:	910063e4 	add	x4, sp, #0x18
 112ddb4:	aa0503e2 	mov	x2, x5
	size_t ol = SIZE_MAX;
 112ddb8:	f9000fe3 	str	x3, [sp, #24]
	int res = mbedtls_mpi_write_string(a, radix, b, ol, &ol);
 112ddbc:	94004e0d 	bl	11415f0 <mbedtls_mpi_write_string>
	if (res == MBEDTLS_ERR_MPI_ALLOC_FAILED)
 112ddc0:	3100401f 	cmn	w0, #0x10
 112ddc4:	540000a0 	b.eq	112ddd8 <write_radix+0x3c>  // b.none
	if (res)
 112ddc8:	7100001f 	cmp	w0, #0x0
 112ddcc:	1a9f07e0 	cset	w0, ne  // ne = any
}
 112ddd0:	a8c27bfd 	ldp	x29, x30, [sp], #32
 112ddd4:	d65f03c0 	ret
		return CRYPT_MEM;
 112ddd8:	528001a0 	mov	w0, #0xd                   	// #13
 112dddc:	17fffffd 	b	112ddd0 <write_radix+0x34>

000000000112dde0 <read_radix>:
{
 112dde0:	aa0103e3 	mov	x3, x1
 112dde4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 112dde8:	2a0203e1 	mov	w1, w2
 112ddec:	910003fd 	mov	x29, sp
	int res = mbedtls_mpi_read_string(a, radix, b);
 112ddf0:	aa0303e2 	mov	x2, x3
 112ddf4:	94004bec 	bl	1140da4 <mbedtls_mpi_read_string>
	if (res == MBEDTLS_ERR_MPI_ALLOC_FAILED)
 112ddf8:	3100401f 	cmn	w0, #0x10
 112ddfc:	540000a0 	b.eq	112de10 <read_radix+0x30>  // b.none
	if (res)
 112de00:	7100001f 	cmp	w0, #0x0
 112de04:	1a9f07e0 	cset	w0, ne  // ne = any
}
 112de08:	a8c17bfd 	ldp	x29, x30, [sp], #16
 112de0c:	d65f03c0 	ret
		return CRYPT_MEM;
 112de10:	528001a0 	mov	w0, #0xd                   	// #13
 112de14:	17fffffd 	b	112de08 <read_radix+0x28>

000000000112de18 <twoexpt>:
{
 112de18:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	if (mbedtls_mpi_set_bit(a, n, 1))
 112de1c:	93407c21 	sxtw	x1, w1
 112de20:	52800022 	mov	w2, #0x1                   	// #1
{
 112de24:	910003fd 	mov	x29, sp
	if (mbedtls_mpi_set_bit(a, n, 1))
 112de28:	94004906 	bl	1140240 <mbedtls_mpi_set_bit>
		return CRYPT_MEM;
 112de2c:	7100001f 	cmp	w0, #0x0
}
 112de30:	528001a1 	mov	w1, #0xd                   	// #13
 112de34:	1a810000 	csel	w0, w0, w1, eq  // eq = none
 112de38:	a8c17bfd 	ldp	x29, x30, [sp], #16
 112de3c:	d65f03c0 	ret

000000000112de40 <count_lsb_bits>:
{
 112de40:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 112de44:	910003fd 	mov	x29, sp
	return mbedtls_mpi_lsb(a);
 112de48:	94004921 	bl	11402cc <mbedtls_mpi_lsb>
}
 112de4c:	a8c17bfd 	ldp	x29, x30, [sp], #16
 112de50:	d65f03c0 	ret

000000000112de54 <count_bits>:
{
 112de54:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 112de58:	910003fd 	mov	x29, sp
	return mbedtls_mpi_bitlen(a);
 112de5c:	94004931 	bl	1140320 <mbedtls_mpi_bitlen>
}
 112de60:	a8c17bfd 	ldp	x29, x30, [sp], #16
 112de64:	d65f03c0 	ret

000000000112de68 <compare_d>:
{
 112de68:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 112de6c:	910003fd 	mov	x29, sp
 112de70:	a90153f3 	stp	x19, x20, [sp, #16]
	mbedtls_mpi_init_mempool(&bn);
 112de74:	9100e3f3 	add	x19, sp, #0x38
{
 112de78:	aa0103f4 	mov	x20, x1
 112de7c:	f90013f5 	str	x21, [sp, #32]
 112de80:	aa0003f5 	mov	x21, x0
	mbedtls_mpi_init_mempool(&bn);
 112de84:	aa1303e0 	mov	x0, x19
 112de88:	94004848 	bl	113ffa8 <mbedtls_mpi_init_mempool>
		mbedtls_mpi_add_int(&bn, &bn, v & mask);
 112de8c:	92407a82 	and	x2, x20, #0x7fffffff
 112de90:	aa1303e1 	mov	x1, x19
 112de94:	aa1303e0 	mov	x0, x19
		v >>= shift;
 112de98:	d35ffe94 	lsr	x20, x20, #31
		mbedtls_mpi_add_int(&bn, &bn, v & mask);
 112de9c:	94004b42 	bl	1140ba4 <mbedtls_mpi_add_int>
		if (!v)
 112dea0:	b40000b4 	cbz	x20, 112deb4 <compare_d+0x4c>
		mbedtls_mpi_shift_l(&bn, shift);
 112dea4:	aa1303e0 	mov	x0, x19
 112dea8:	d28003e1 	mov	x1, #0x1f                  	// #31
 112deac:	9400499e 	bl	1140524 <mbedtls_mpi_shift_l>
		mbedtls_mpi_add_int(&bn, &bn, v & mask);
 112deb0:	17fffff7 	b	112de8c <compare_d+0x24>
	int ret = compare(a, &bn);
 112deb4:	aa1303e1 	mov	x1, x19
 112deb8:	aa1503e0 	mov	x0, x21
 112debc:	97fffe69 	bl	112d860 <compare>
 112dec0:	2a0003f4 	mov	w20, w0
	mbedtls_mpi_free(&bn);
 112dec4:	aa1303e0 	mov	x0, x19
 112dec8:	94004842 	bl	113ffd0 <mbedtls_mpi_free>
}
 112decc:	2a1403e0 	mov	w0, w20
 112ded0:	a94153f3 	ldp	x19, x20, [sp, #16]
 112ded4:	f94013f5 	ldr	x21, [sp, #32]
 112ded8:	a8c57bfd 	ldp	x29, x30, [sp], #80
 112dedc:	d65f03c0 	ret

000000000112dee0 <deinit>:
{
 112dee0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 112dee4:	910003fd 	mov	x29, sp
 112dee8:	f9000bf3 	str	x19, [sp, #16]
 112deec:	aa0003f3 	mov	x19, x0
	mbedtls_mpi_free((mbedtls_mpi *)a);
 112def0:	94004838 	bl	113ffd0 <mbedtls_mpi_free>
	mempool_free(mbedtls_mpi_mempool, a);
 112def4:	b0000162 	adrp	x2, 115a000 <__scattered_array_1phys_mem_map+0x8>
 112def8:	aa1303e1 	mov	x1, x19
}
 112defc:	f9400bf3 	ldr	x19, [sp, #16]
	mempool_free(mbedtls_mpi_mempool, a);
 112df00:	f9424c42 	ldr	x2, [x2, #1176]
}
 112df04:	a8c27bfd 	ldp	x29, x30, [sp], #32
	mempool_free(mbedtls_mpi_mempool, a);
 112df08:	f9400040 	ldr	x0, [x2]
 112df0c:	14005c0f 	b	1144f48 <mempool_free>

000000000112df10 <init_size>:
{
 112df10:	aa0103e0 	mov	x0, x1
	return init(a);
 112df14:	17ff4e9b 	b	1101980 <init>

000000000112df18 <montgomery_normalization>:
{
 112df18:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 112df1c:	910003fd 	mov	x29, sp
 112df20:	a90153f3 	stp	x19, x20, [sp, #16]
 112df24:	aa0003f4 	mov	x20, x0
	size_t c = ROUNDUP(mbedtls_mpi_size(b), sizeof(mbedtls_mpi_uint)) * 8;
 112df28:	aa0103e0 	mov	x0, x1
{
 112df2c:	f90013f5 	str	x21, [sp, #32]
 112df30:	aa0103f5 	mov	x21, x1
	size_t c = ROUNDUP(mbedtls_mpi_size(b), sizeof(mbedtls_mpi_uint)) * 8;
 112df34:	94004912 	bl	114037c <mbedtls_mpi_size>
 112df38:	aa0003f3 	mov	x19, x0
	if (mbedtls_mpi_lset(a, 1))
 112df3c:	d2800021 	mov	x1, #0x1                   	// #1
 112df40:	aa1403e0 	mov	x0, x20
 112df44:	940048a5 	bl	11401d8 <mbedtls_mpi_lset>
 112df48:	35000180 	cbnz	w0, 112df78 <montgomery_normalization+0x60>
	size_t c = ROUNDUP(mbedtls_mpi_size(b), sizeof(mbedtls_mpi_uint)) * 8;
 112df4c:	91001e73 	add	x19, x19, #0x7
	if (mbedtls_mpi_shift_l(a, c))
 112df50:	aa1403e0 	mov	x0, x20
	size_t c = ROUNDUP(mbedtls_mpi_size(b), sizeof(mbedtls_mpi_uint)) * 8;
 112df54:	927df273 	and	x19, x19, #0xfffffffffffffff8
	if (mbedtls_mpi_shift_l(a, c))
 112df58:	d37df261 	lsl	x1, x19, #3
 112df5c:	94004972 	bl	1140524 <mbedtls_mpi_shift_l>
 112df60:	350000c0 	cbnz	w0, 112df78 <montgomery_normalization+0x60>
	if (mbedtls_mpi_mod_mpi(a, a, b))
 112df64:	aa1503e2 	mov	x2, x21
 112df68:	aa1403e1 	mov	x1, x20
 112df6c:	aa1403e0 	mov	x0, x20
 112df70:	94004d5e 	bl	11414e8 <mbedtls_mpi_mod_mpi>
 112df74:	34000040 	cbz	w0, 112df7c <montgomery_normalization+0x64>
		return CRYPT_MEM;
 112df78:	528001a0 	mov	w0, #0xd                   	// #13
}
 112df7c:	a94153f3 	ldp	x19, x20, [sp, #16]
 112df80:	f94013f5 	ldr	x21, [sp, #32]
 112df84:	a8c37bfd 	ldp	x29, x30, [sp], #48
 112df88:	d65f03c0 	ret

000000000112df8c <div_2>:
{
 112df8c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 112df90:	910003fd 	mov	x29, sp
 112df94:	f9000bf3 	str	x19, [sp, #16]
 112df98:	aa0103f3 	mov	x19, x1
	if (mbedtls_mpi_copy(b, a))
 112df9c:	aa0003e1 	mov	x1, x0
 112dfa0:	aa1303e0 	mov	x0, x19
 112dfa4:	94004860 	bl	1140124 <mbedtls_mpi_copy>
 112dfa8:	350000a0 	cbnz	w0, 112dfbc <div_2+0x30>
	if (mbedtls_mpi_shift_r(b, 1))
 112dfac:	aa1303e0 	mov	x0, x19
 112dfb0:	d2800021 	mov	x1, #0x1                   	// #1
 112dfb4:	940049a1 	bl	1140638 <mbedtls_mpi_shift_r>
 112dfb8:	34000040 	cbz	w0, 112dfc0 <div_2+0x34>
		return CRYPT_MEM;
 112dfbc:	528001a0 	mov	w0, #0xd                   	// #13
}
 112dfc0:	f9400bf3 	ldr	x19, [sp, #16]
 112dfc4:	a8c27bfd 	ldp	x29, x30, [sp], #32
 112dfc8:	d65f03c0 	ret

000000000112dfcc <muli>:
{
 112dfcc:	aa0003e3 	mov	x3, x0
 112dfd0:	aa0203e0 	mov	x0, x2
	if (b > (unsigned long) UINT32_MAX)
 112dfd4:	b2407fe2 	mov	x2, #0xffffffff            	// #4294967295
 112dfd8:	eb02003f 	cmp	x1, x2
 112dfdc:	54000168 	b.hi	112e008 <muli+0x3c>  // b.pmore
{
 112dfe0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	if (mbedtls_mpi_mul_int(c, a, b))
 112dfe4:	aa0103e2 	mov	x2, x1
 112dfe8:	aa0303e1 	mov	x1, x3
{
 112dfec:	910003fd 	mov	x29, sp
	if (mbedtls_mpi_mul_int(c, a, b))
 112dff0:	94004b60 	bl	1140d70 <mbedtls_mpi_mul_int>
		return CRYPT_MEM;
 112dff4:	7100001f 	cmp	w0, #0x0
 112dff8:	528001a1 	mov	w1, #0xd                   	// #13
 112dffc:	1a810000 	csel	w0, w0, w1, eq  // eq = none
}
 112e000:	a8c17bfd 	ldp	x29, x30, [sp], #16
 112e004:	d65f03c0 	ret
		return CRYPT_INVALID_ARG;
 112e008:	52800200 	mov	w0, #0x10                  	// #16
}
 112e00c:	d65f03c0 	ret

000000000112e010 <submod>:
{
 112e010:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 112e014:	910003fd 	mov	x29, sp
 112e018:	a90153f3 	stp	x19, x20, [sp, #16]
 112e01c:	aa0203f4 	mov	x20, x2
 112e020:	aa0303f3 	mov	x19, x3
	int res = sub(a, b, d);
 112e024:	aa0303e2 	mov	x2, x3
 112e028:	97fffeff 	bl	112dc24 <sub>
	if (res)
 112e02c:	350000e0 	cbnz	w0, 112e048 <submod+0x38>
	return mod(d, c, d);
 112e030:	aa1303e2 	mov	x2, x19
 112e034:	aa1403e1 	mov	x1, x20
 112e038:	aa1303e0 	mov	x0, x19
}
 112e03c:	a94153f3 	ldp	x19, x20, [sp, #16]
 112e040:	a8c27bfd 	ldp	x29, x30, [sp], #32
	return mod(d, c, d);
 112e044:	17fffd57 	b	112d5a0 <mod>
}
 112e048:	a94153f3 	ldp	x19, x20, [sp, #16]
 112e04c:	a8c27bfd 	ldp	x29, x30, [sp], #32
 112e050:	d65f03c0 	ret

000000000112e054 <init_copy>:
{
 112e054:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 112e058:	910003fd 	mov	x29, sp
 112e05c:	a90153f3 	stp	x19, x20, [sp, #16]
 112e060:	aa0003f4 	mov	x20, x0
 112e064:	aa0103f3 	mov	x19, x1
	if (init(a) != CRYPT_OK) {
 112e068:	97ff4e46 	bl	1101980 <init>
 112e06c:	350000c0 	cbnz	w0, 112e084 <init_copy+0x30>
	return copy(b, *a);
 112e070:	aa1303e0 	mov	x0, x19
 112e074:	f9400281 	ldr	x1, [x20]
}
 112e078:	a94153f3 	ldp	x19, x20, [sp, #16]
 112e07c:	a8c27bfd 	ldp	x29, x30, [sp], #32
	return copy(b, *a);
 112e080:	17fffd83 	b	112d68c <copy>
}
 112e084:	528001a0 	mov	w0, #0xd                   	// #13
 112e088:	a94153f3 	ldp	x19, x20, [sp, #16]
 112e08c:	a8c27bfd 	ldp	x29, x30, [sp], #32
 112e090:	d65f03c0 	ret

000000000112e094 <addmod>:
{
 112e094:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 112e098:	910003fd 	mov	x29, sp
 112e09c:	a90153f3 	stp	x19, x20, [sp, #16]
 112e0a0:	aa0203f4 	mov	x20, x2
 112e0a4:	aa0303f3 	mov	x19, x3
	int res = add(a, b, d);
 112e0a8:	aa0303e2 	mov	x2, x3
 112e0ac:	97fffefe 	bl	112dca4 <add>
	if (res)
 112e0b0:	350000e0 	cbnz	w0, 112e0cc <addmod+0x38>
	return mod(d, c, d);
 112e0b4:	aa1303e2 	mov	x2, x19
 112e0b8:	aa1403e1 	mov	x1, x20
 112e0bc:	aa1303e0 	mov	x0, x19
}
 112e0c0:	a94153f3 	ldp	x19, x20, [sp, #16]
 112e0c4:	a8c27bfd 	ldp	x29, x30, [sp], #32
	return mod(d, c, d);
 112e0c8:	17fffd36 	b	112d5a0 <mod>
}
 112e0cc:	a94153f3 	ldp	x19, x20, [sp, #16]
 112e0d0:	a8c27bfd 	ldp	x29, x30, [sp], #32
 112e0d4:	d65f03c0 	ret

000000000112e0d8 <init_mp_tomcrypt>:
{
 112e0d8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	return mempool_alloc_pool(data, sizeof(data), NULL);
 112e0dc:	90000180 	adrp	x0, 115e000 <state+0x80>
 112e0e0:	d2800002 	mov	x2, #0x0                   	// #0
{
 112e0e4:	910003fd 	mov	x29, sp
	return mempool_alloc_pool(data, sizeof(data), NULL);
 112e0e8:	91076000 	add	x0, x0, #0x1d8
 112e0ec:	d2950001 	mov	x1, #0xa800                	// #43008
 112e0f0:	94005b43 	bl	1144dfc <mempool_alloc_pool>
	if (!p)
 112e0f4:	b5000100 	cbnz	x0, 112e114 <init_mp_tomcrypt+0x3c>
		panic();
 112e0f8:	90000142 	adrp	x2, 1156000 <ta_pub_key_modulus+0x7>
 112e0fc:	90000140 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 112e100:	911ac842 	add	x2, x2, #0x6b2
 112e104:	9119e400 	add	x0, x0, #0x679
 112e108:	d2800003 	mov	x3, #0x0                   	// #0
 112e10c:	52800721 	mov	w1, #0x39                  	// #57
 112e110:	97ff94d6 	bl	1113468 <__do_panic>
	mbedtls_mpi_mempool = p;
 112e114:	90000161 	adrp	x1, 115a000 <__scattered_array_1phys_mem_map+0x8>
 112e118:	f9424c22 	ldr	x2, [x1, #1176]
	assert(!mempool_default);
 112e11c:	f9418821 	ldr	x1, [x1, #784]
	mbedtls_mpi_mempool = p;
 112e120:	f9000040 	str	x0, [x2]
	assert(!mempool_default);
 112e124:	f9400022 	ldr	x2, [x1]
 112e128:	b4000142 	cbz	x2, 112e150 <init_mp_tomcrypt+0x78>
 112e12c:	90000143 	adrp	x3, 1156000 <ta_pub_key_modulus+0x7>
 112e130:	90000141 	adrp	x1, 1156000 <ta_pub_key_modulus+0x7>
 112e134:	911ac863 	add	x3, x3, #0x6b2
 112e138:	9119e421 	add	x1, x1, #0x679
 112e13c:	90000140 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 112e140:	911a6400 	add	x0, x0, #0x699
 112e144:	52800762 	mov	w2, #0x3b                  	// #59
 112e148:	97ff9059 	bl	11122ac <_assert_log>
 112e14c:	97ff9069 	bl	11122f0 <_assert_break>
	mempool_default = p;
 112e150:	f9000020 	str	x0, [x1]
}
 112e154:	a8c17bfd 	ldp	x29, x30, [sp], #16
 112e158:	d65f03c0 	ret

000000000112e15c <crypto_bignum_num_bytes>:

};

size_t crypto_bignum_num_bytes(struct bignum *a)
{
	return mbedtls_mpi_size((mbedtls_mpi *)a);
 112e15c:	14004888 	b	114037c <mbedtls_mpi_size>

000000000112e160 <crypto_bignum_bn2bin>:
{
	return mbedtls_mpi_cmp_mpi((mbedtls_mpi *)a, (mbedtls_mpi *)b);
}

void crypto_bignum_bn2bin(const struct bignum *from, uint8_t *to)
{
 112e160:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 112e164:	910003fd 	mov	x29, sp
 112e168:	a90153f3 	stp	x19, x20, [sp, #16]
 112e16c:	aa0003f3 	mov	x19, x0
 112e170:	aa0103f4 	mov	x20, x1
	const mbedtls_mpi *f = (const mbedtls_mpi *)from;
	int rc __maybe_unused = 0;

	rc = mbedtls_mpi_write_binary(f, (void *)to, mbedtls_mpi_size(f));
 112e174:	94004882 	bl	114037c <mbedtls_mpi_size>
 112e178:	aa0003e2 	mov	x2, x0
 112e17c:	aa1403e1 	mov	x1, x20
 112e180:	aa1303e0 	mov	x0, x19
 112e184:	940048b7 	bl	1140460 <mbedtls_mpi_write_binary>
	assert(!rc);
 112e188:	34000140 	cbz	w0, 112e1b0 <crypto_bignum_bn2bin+0x50>
 112e18c:	90000143 	adrp	x3, 1156000 <ta_pub_key_modulus+0x7>
 112e190:	90000141 	adrp	x1, 1156000 <ta_pub_key_modulus+0x7>
 112e194:	911b0c63 	add	x3, x3, #0x6c3
 112e198:	9119e421 	add	x1, x1, #0x679
 112e19c:	90000140 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 112e1a0:	911aa800 	add	x0, x0, #0x6aa
 112e1a4:	52805b62 	mov	w2, #0x2db                 	// #731
 112e1a8:	97ff9041 	bl	11122ac <_assert_log>
 112e1ac:	97ff9051 	bl	11122f0 <_assert_break>
}
 112e1b0:	a94153f3 	ldp	x19, x20, [sp, #16]
 112e1b4:	a8c27bfd 	ldp	x29, x30, [sp], #32
 112e1b8:	d65f03c0 	ret

000000000112e1bc <crypto_bignum_bin2bn>:

TEE_Result crypto_bignum_bin2bn(const uint8_t *from, size_t fromsize,
			 struct bignum *to)
{
 112e1bc:	aa0003e3 	mov	x3, x0
 112e1c0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 112e1c4:	aa0203e0 	mov	x0, x2
 112e1c8:	910003fd 	mov	x29, sp
	if (mbedtls_mpi_read_binary((mbedtls_mpi *)to, (const void *)from,
 112e1cc:	aa0103e2 	mov	x2, x1
 112e1d0:	aa0303e1 	mov	x1, x3
 112e1d4:	94004871 	bl	1140398 <mbedtls_mpi_read_binary>
				    fromsize))
		return TEE_ERROR_BAD_PARAMETERS;
 112e1d8:	7100001f 	cmp	w0, #0x0
	return TEE_SUCCESS;
}
 112e1dc:	a8c17bfd 	ldp	x29, x30, [sp], #16
 112e1e0:	129fff20 	mov	w0, #0xffff0006            	// #-65530
 112e1e4:	1a9f1000 	csel	w0, w0, wzr, ne  // ne = any
 112e1e8:	d65f03c0 	ret

000000000112e1ec <crypto_bignum_copy>:

void crypto_bignum_copy(struct bignum *to, const struct bignum *from)
{
 112e1ec:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 112e1f0:	910003fd 	mov	x29, sp
	int rc __maybe_unused = 0;

	rc = mbedtls_mpi_copy((mbedtls_mpi *)to, (const mbedtls_mpi *)from);
 112e1f4:	940047cc 	bl	1140124 <mbedtls_mpi_copy>
	assert(!rc);
 112e1f8:	34000140 	cbz	w0, 112e220 <crypto_bignum_copy+0x34>
 112e1fc:	90000143 	adrp	x3, 1156000 <ta_pub_key_modulus+0x7>
 112e200:	90000141 	adrp	x1, 1156000 <ta_pub_key_modulus+0x7>
 112e204:	911b6063 	add	x3, x3, #0x6d8
 112e208:	9119e421 	add	x1, x1, #0x679
 112e20c:	90000140 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 112e210:	911aa800 	add	x0, x0, #0x6aa
 112e214:	52805d82 	mov	w2, #0x2ec                 	// #748
 112e218:	97ff9025 	bl	11122ac <_assert_log>
 112e21c:	97ff9035 	bl	11122f0 <_assert_break>
}
 112e220:	a8c17bfd 	ldp	x29, x30, [sp], #16
 112e224:	d65f03c0 	ret

000000000112e228 <crypto_bignum_allocate>:

struct bignum *crypto_bignum_allocate(size_t size_bits)
{
 112e228:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 112e22c:	910003fd 	mov	x29, sp
 112e230:	a90153f3 	stp	x19, x20, [sp, #16]
 112e234:	aa0003f4 	mov	x20, x0
	mbedtls_mpi *bn = malloc(sizeof(*bn));
 112e238:	d2800300 	mov	x0, #0x18                  	// #24
 112e23c:	94005487 	bl	1143458 <malloc>
 112e240:	aa0003f3 	mov	x19, x0

	if (!bn)
 112e244:	b4000160 	cbz	x0, 112e270 <crypto_bignum_allocate+0x48>
		return NULL;

	mbedtls_mpi_init(bn);
 112e248:	94004754 	bl	113ff98 <mbedtls_mpi_init>
	if (mbedtls_mpi_grow(bn, BITS_TO_LIMBS(size_bits))) {
 112e24c:	f240169f 	tst	x20, #0x3f
 112e250:	d346fe81 	lsr	x1, x20, #6
 112e254:	9a810421 	cinc	x1, x1, ne  // ne = any
 112e258:	aa1303e0 	mov	x0, x19
 112e25c:	94004778 	bl	114003c <mbedtls_mpi_grow>
 112e260:	34000080 	cbz	w0, 112e270 <crypto_bignum_allocate+0x48>
		free(bn);
 112e264:	aa1303e0 	mov	x0, x19
		return NULL;
 112e268:	d2800013 	mov	x19, #0x0                   	// #0
		free(bn);
 112e26c:	940054dd 	bl	11435e0 <free>
	}

	return (struct bignum *)bn;
}
 112e270:	aa1303e0 	mov	x0, x19
 112e274:	a94153f3 	ldp	x19, x20, [sp, #16]
 112e278:	a8c27bfd 	ldp	x29, x30, [sp], #32
 112e27c:	d65f03c0 	ret

000000000112e280 <crypto_bignum_free>:

void crypto_bignum_free(struct bignum *s)
{
 112e280:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 112e284:	910003fd 	mov	x29, sp
 112e288:	f9000bf3 	str	x19, [sp, #16]
 112e28c:	aa0003f3 	mov	x19, x0
	mbedtls_mpi_free((mbedtls_mpi *)s);
 112e290:	94004750 	bl	113ffd0 <mbedtls_mpi_free>
	free(s);
 112e294:	aa1303e0 	mov	x0, x19
}
 112e298:	f9400bf3 	ldr	x19, [sp, #16]
 112e29c:	a8c27bfd 	ldp	x29, x30, [sp], #32
	free(s);
 112e2a0:	140054d0 	b	11435e0 <free>

000000000112e2a4 <crypto_bignum_clear>:

void crypto_bignum_clear(struct bignum *s)
{
 112e2a4:	aa0003e1 	mov	x1, x0
	mbedtls_mpi *bn = (mbedtls_mpi *)s;

	bn->s = 1;
 112e2a8:	52800020 	mov	w0, #0x1                   	// #1
 112e2ac:	79000020 	strh	w0, [x1]
	if (bn->p)
 112e2b0:	f9400820 	ldr	x0, [x1, #16]
 112e2b4:	b40000a0 	cbz	x0, 112e2c8 <crypto_bignum_clear+0x24>
		memset(bn->p, 0, sizeof(*bn->p) * bn->n);
 112e2b8:	f9400422 	ldr	x2, [x1, #8]
 112e2bc:	52800001 	mov	w1, #0x0                   	// #0
 112e2c0:	d37df042 	lsl	x2, x2, #3
 112e2c4:	14005687 	b	1143ce0 <memset>
}
 112e2c8:	d65f03c0 	ret

000000000112e2cc <prng_crypto_start>:
#if defined(_CFG_CORE_LTC_ACIPHER)
/* Random generator */
static int prng_crypto_start(prng_state *prng __unused)
{
	return CRYPT_OK;
}
 112e2cc:	52800000 	mov	w0, #0x0                   	// #0
 112e2d0:	d65f03c0 	ret

000000000112e2d4 <prng_crypto_add_entropy>:
				   unsigned long inlen __unused,
				   prng_state *prng __unused)
{
	/* No entropy is required */
	return CRYPT_OK;
}
 112e2d4:	52800000 	mov	w0, #0x0                   	// #0
 112e2d8:	d65f03c0 	ret

000000000112e2dc <prng_crypto_export>:
static int prng_crypto_export(unsigned char *out __unused,
			      unsigned long *outlen __unused,
			      prng_state *prng __unused)
{
	return CRYPT_OK;
}
 112e2dc:	52800000 	mov	w0, #0x0                   	// #0
 112e2e0:	d65f03c0 	ret

000000000112e2e4 <prng_crypto_test>:
}

static int prng_crypto_test(void)
{
	return CRYPT_OK;
}
 112e2e4:	52800000 	mov	w0, #0x0                   	// #0
 112e2e8:	d65f03c0 	ret

000000000112e2ec <prng_crypto_read>:
{
 112e2ec:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 112e2f0:	910003fd 	mov	x29, sp
 112e2f4:	f9000bf3 	str	x19, [sp, #16]
 112e2f8:	aa0103f3 	mov	x19, x1
	if (crypto_rng_read(out, outlen))
 112e2fc:	97ff84ac 	bl	110f5ac <crypto_rng_read>
		return 0;
 112e300:	7100001f 	cmp	w0, #0x0
}
 112e304:	9a9f0260 	csel	x0, x19, xzr, eq  // eq = none
 112e308:	f9400bf3 	ldr	x19, [sp, #16]
 112e30c:	a8c27bfd 	ldp	x29, x30, [sp], #32
 112e310:	d65f03c0 	ret

000000000112e314 <prng_crypto_import>:
 112e314:	52800000 	mov	w0, #0x0                   	// #0
 112e318:	d65f03c0 	ret

000000000112e31c <prng_crypto_ready>:
 112e31c:	52800000 	mov	w0, #0x0                   	// #0
 112e320:	d65f03c0 	ret

000000000112e324 <prng_crypto_done>:
 112e324:	52800000 	mov	w0, #0x0                   	// #0
 112e328:	d65f03c0 	ret

000000000112e32c <crypto_init>:
	tee_ltc_reg_algs();
}

#if defined(CFG_CRYPTOLIB_NAME_tomcrypt)
TEE_Result crypto_init(void)
{
 112e32c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 112e330:	910003fd 	mov	x29, sp
 112e334:	f9000bf3 	str	x19, [sp, #16]
	register_cipher(&aes_desc);
 112e338:	90000173 	adrp	x19, 115a000 <__scattered_array_1phys_mem_map+0x8>
	init_mp_tomcrypt();
 112e33c:	97ffff67 	bl	112e0d8 <init_mp_tomcrypt>
	register_cipher(&aes_desc);
 112e340:	f9424a60 	ldr	x0, [x19, #1168]
 112e344:	94001100 	bl	1132744 <register_cipher>
	register_cipher(&des_desc);
 112e348:	f941ae60 	ldr	x0, [x19, #856]
 112e34c:	940010fe 	bl	1132744 <register_cipher>
	register_cipher(&des3_desc);
 112e350:	f941c660 	ldr	x0, [x19, #904]
 112e354:	940010fc 	bl	1132744 <register_cipher>
	register_hash(&md5_desc);
 112e358:	f941ee60 	ldr	x0, [x19, #984]
 112e35c:	94001127 	bl	11327f8 <register_hash>
	register_hash(&sha1_desc);
 112e360:	f9416660 	ldr	x0, [x19, #712]
 112e364:	94001125 	bl	11327f8 <register_hash>
	register_hash(&sha224_desc);
 112e368:	f9413660 	ldr	x0, [x19, #616]
 112e36c:	94001123 	bl	11327f8 <register_hash>
	register_hash(&sha256_desc);
 112e370:	f9413260 	ldr	x0, [x19, #608]
 112e374:	94001121 	bl	11327f8 <register_hash>
	register_hash(&sha384_desc);
 112e378:	f941b260 	ldr	x0, [x19, #864]
 112e37c:	9400111f 	bl	11327f8 <register_hash>
	register_hash(&sha512_desc);
 112e380:	f9419e60 	ldr	x0, [x19, #824]
 112e384:	9400111d 	bl	11327f8 <register_hash>
	register_prng(&prng_crypto_desc);
 112e388:	d0000160 	adrp	x0, 115c000 <ltc_ctr_ops+0x20>
 112e38c:	910c0000 	add	x0, x0, #0x300
 112e390:	94001144 	bl	11328a0 <register_prng>
	ltc_init();

	return TEE_SUCCESS;
}
 112e394:	52800000 	mov	w0, #0x0                   	// #0
 112e398:	f9400bf3 	ldr	x19, [sp, #16]
 112e39c:	a8c27bfd 	ldp	x29, x30, [sp], #32
 112e3a0:	d65f03c0 	ret

000000000112e3a4 <des_test>:
        for (y = 0; y < 8; y++) if (tmp[y] != 0) return CRYPT_FAIL_TESTVECTOR;
    }

    return CRYPT_OK;
  #endif
}
 112e3a4:	52800040 	mov	w0, #0x2                   	// #2
 112e3a8:	d65f03c0 	ret

000000000112e3ac <des_done>:
   @param skey    The scheduled key
*/
void des_done(symmetric_key *skey)
{
  LTC_UNUSED_PARAM(skey);
}
 112e3ac:	d65f03c0 	ret

000000000112e3b0 <des_keysize>:
  @param keysize [in/out] The length of the recommended key (in bytes).  This function will store the suitable size back in this variable.
  @return CRYPT_OK if the input key size is acceptable.
*/
int des_keysize(int *keysize)
{
    LTC_ARGCHK(keysize != NULL);
 112e3b0:	b4000100 	cbz	x0, 112e3d0 <des_keysize+0x20>
    if(*keysize < 8) {
 112e3b4:	b9400001 	ldr	w1, [x0]
 112e3b8:	71001c3f 	cmp	w1, #0x7
 112e3bc:	540000ed 	b.le	112e3d8 <des_keysize+0x28>
        return CRYPT_INVALID_KEYSIZE;
    }
    *keysize = 8;
 112e3c0:	52800101 	mov	w1, #0x8                   	// #8
 112e3c4:	b9000001 	str	w1, [x0]
    return CRYPT_OK;
 112e3c8:	52800000 	mov	w0, #0x0                   	// #0
}
 112e3cc:	d65f03c0 	ret
    LTC_ARGCHK(keysize != NULL);
 112e3d0:	52800200 	mov	w0, #0x10                  	// #16
 112e3d4:	17fffffe 	b	112e3cc <des_keysize+0x1c>
        return CRYPT_INVALID_KEYSIZE;
 112e3d8:	52800060 	mov	w0, #0x3                   	// #3
 112e3dc:	17fffffc 	b	112e3cc <des_keysize+0x1c>

000000000112e3e0 <des3_keysize>:
  @param keysize [in/out] The length of the recommended key (in bytes).  This function will store the suitable size back in this variable.
  @return CRYPT_OK if the input key size is acceptable.
*/
int des3_keysize(int *keysize)
{
    LTC_ARGCHK(keysize != NULL);
 112e3e0:	b4000180 	cbz	x0, 112e410 <des3_keysize+0x30>
    if (*keysize < 16) {
 112e3e4:	b9400001 	ldr	w1, [x0]
 112e3e8:	71003c3f 	cmp	w1, #0xf
 112e3ec:	5400016d 	b.le	112e418 <des3_keysize+0x38>
       return CRYPT_INVALID_KEYSIZE;
    }
    if (*keysize < 24) {
 112e3f0:	71005c3f 	cmp	w1, #0x17
 112e3f4:	540000ac 	b.gt	112e408 <des3_keysize+0x28>
       *keysize = 16;
 112e3f8:	52800201 	mov	w1, #0x10                  	// #16
       return CRYPT_OK;
    }
    *keysize = 24;
 112e3fc:	b9000001 	str	w1, [x0]
    return CRYPT_OK;
 112e400:	52800000 	mov	w0, #0x0                   	// #0
}
 112e404:	d65f03c0 	ret
    *keysize = 24;
 112e408:	52800301 	mov	w1, #0x18                  	// #24
 112e40c:	17fffffc 	b	112e3fc <des3_keysize+0x1c>
    LTC_ARGCHK(keysize != NULL);
 112e410:	52800200 	mov	w0, #0x10                  	// #16
 112e414:	17fffffc 	b	112e404 <des3_keysize+0x24>
       return CRYPT_INVALID_KEYSIZE;
 112e418:	52800060 	mov	w0, #0x3                   	// #3
 112e41c:	17fffffa 	b	112e404 <des3_keysize+0x24>

000000000112e420 <desfunc>:
    right = block[1];
 112e420:	29401003 	ldp	w3, w4, [x0]
              ^  SP5[(work >>  8) & 0x3fL]
 112e424:	90000109 	adrp	x9, 114e000 <ldelf_data+0x8000>
              ^  SP3[(work >> 16) & 0x3fL]
 112e428:	90000108 	adrp	x8, 114e000 <ldelf_data+0x8000>
        leftt ^= SP7[work        & 0x3fL]
 112e42c:	9000010d 	adrp	x13, 114e000 <ldelf_data+0x8000>
        leftt ^= SP8[ work        & 0x3fL]
 112e430:	b000010c 	adrp	x12, 114f000 <SP7+0xd8>
              ^  SP1[(work >> 24) & 0x3fL];
 112e434:	90000107 	adrp	x7, 114e000 <ldelf_data+0x8000>
    work = ((leftt >> 4)  ^ right) & 0x0f0f0f0fL;
 112e438:	4a431082 	eor	w2, w4, w3, lsr #4
              ^  SP6[(work >>  8) & 0x3fL]
 112e43c:	9000010e 	adrp	x14, 114e000 <ldelf_data+0x8000>
    work = ((leftt >> 4)  ^ right) & 0x0f0f0f0fL;
 112e440:	1200cc42 	and	w2, w2, #0xf0f0f0f
              ^  SP4[(work >> 16) & 0x3fL]
 112e444:	9000010b 	adrp	x11, 114e000 <ldelf_data+0x8000>
    right ^= work;
 112e448:	4a020084 	eor	w4, w4, w2
              ^  SP2[(work >> 24) & 0x3fL];
 112e44c:	9000010a 	adrp	x10, 114e000 <ldelf_data+0x8000>
    leftt ^= (work << 4);
 112e450:	4a021063 	eor	w3, w3, w2, lsl #4
    work = ((leftt >> 16) ^ right) & 0x0000ffffL;
 112e454:	9102002f 	add	x15, x1, #0x80
              ^  SP5[(work >>  8) & 0x3fL]
 112e458:	9134a129 	add	x9, x9, #0xd28
              ^  SP3[(work >> 16) & 0x3fL]
 112e45c:	912ca108 	add	x8, x8, #0xb28
    work = ((leftt >> 16) ^ right) & 0x0000ffffL;
 112e460:	4a434082 	eor	w2, w4, w3, lsr #16
        leftt ^= SP7[work        & 0x3fL]
 112e464:	913ca1ad 	add	x13, x13, #0xf28
    work = ((leftt >> 16) ^ right) & 0x0000ffffL;
 112e468:	12003c42 	and	w2, w2, #0xffff
        leftt ^= SP8[ work        & 0x3fL]
 112e46c:	9100a18c 	add	x12, x12, #0x28
    right ^= work;
 112e470:	4a020084 	eor	w4, w4, w2
              ^  SP1[(work >> 24) & 0x3fL];
 112e474:	9124a0e7 	add	x7, x7, #0x928
    leftt ^= (work << 16);
 112e478:	4a024062 	eor	w2, w3, w2, lsl #16
              ^  SP6[(work >>  8) & 0x3fL]
 112e47c:	9138a1ce 	add	x14, x14, #0xe28
    work = ((right >> 2)  ^ leftt) & 0x33333333L;
 112e480:	4a440843 	eor	w3, w2, w4, lsr #2
              ^  SP4[(work >> 16) & 0x3fL]
 112e484:	9130a16b 	add	x11, x11, #0xc28
    work = ((right >> 2)  ^ leftt) & 0x33333333L;
 112e488:	1200e463 	and	w3, w3, #0x33333333
              ^  SP2[(work >> 24) & 0x3fL];
 112e48c:	9128a14a 	add	x10, x10, #0xa28
    leftt ^= work;
 112e490:	4a030042 	eor	w2, w2, w3
    right ^= (work << 2);
 112e494:	4a030884 	eor	w4, w4, w3, lsl #2
    work = ((right >> 8)  ^ leftt) & 0x00ff00ffL;
 112e498:	4a442043 	eor	w3, w2, w4, lsr #8
 112e49c:	12009c63 	and	w3, w3, #0xff00ff
    leftt ^= work;
 112e4a0:	4a030042 	eor	w2, w2, w3
    right ^= (work << 8);
 112e4a4:	4a032083 	eor	w3, w4, w3, lsl #8
    work = (leftt ^ right) & 0xaaaaaaaaL;
 112e4a8:	4ac37c44 	eor	w4, w2, w3, ror #31
 112e4ac:	1201f084 	and	w4, w4, #0xaaaaaaaa
    leftt ^= work;
 112e4b0:	4a040042 	eor	w2, w2, w4
    right ^= work;
 112e4b4:	4ac37c83 	eor	w3, w4, w3, ror #31
    leftt = ROLc(leftt, 1);
 112e4b8:	13827c42 	ror	w2, w2, #31
        work  = right ^ *keys++;
 112e4bc:	29401426 	ldp	w6, w5, [x1]
 112e4c0:	91004021 	add	x1, x1, #0x10
 112e4c4:	4a050065 	eor	w5, w3, w5
        work  = RORc(right, 4) ^ *keys++;
 112e4c8:	4ac310c6 	eor	w6, w6, w3, ror #4
        leftt ^= SP8[ work        & 0x3fL]
 112e4cc:	924014b1 	and	x17, x5, #0x3f
              ^  SP5[(work >>  8) & 0x3fL]
 112e4d0:	d34834c4 	ubfx	x4, x6, #8, #6
              ^  SP3[(work >> 16) & 0x3fL]
 112e4d4:	d35054d0 	ubfx	x16, x6, #16, #6
        leftt ^= SP8[ work        & 0x3fL]
 112e4d8:	b8717991 	ldr	w17, [x12, x17, lsl #2]
 112e4dc:	b8707910 	ldr	w16, [x8, x16, lsl #2]
 112e4e0:	b8647924 	ldr	w4, [x9, x4, lsl #2]
 112e4e4:	4a100084 	eor	w4, w4, w16
        leftt ^= SP7[work        & 0x3fL]
 112e4e8:	924014d0 	and	x16, x6, #0x3f
              ^  SP1[(work >> 24) & 0x3fL];
 112e4ec:	d35874c6 	ubfx	x6, x6, #24, #6
        leftt ^= SP8[ work        & 0x3fL]
 112e4f0:	b87079b0 	ldr	w16, [x13, x16, lsl #2]
 112e4f4:	b86678e6 	ldr	w6, [x7, x6, lsl #2]
 112e4f8:	4a110210 	eor	w16, w16, w17
 112e4fc:	4a100084 	eor	w4, w4, w16
              ^  SP6[(work >>  8) & 0x3fL]
 112e500:	d34834b0 	ubfx	x16, x5, #8, #6
        leftt ^= SP8[ work        & 0x3fL]
 112e504:	b87079d0 	ldr	w16, [x14, x16, lsl #2]
 112e508:	4a1000c6 	eor	w6, w6, w16
 112e50c:	4a060084 	eor	w4, w4, w6
              ^  SP4[(work >> 16) & 0x3fL]
 112e510:	d35054a6 	ubfx	x6, x5, #16, #6
              ^  SP2[(work >> 24) & 0x3fL];
 112e514:	d35874a5 	ubfx	x5, x5, #24, #6
        leftt ^= SP8[ work        & 0x3fL]
 112e518:	b8667966 	ldr	w6, [x11, x6, lsl #2]
 112e51c:	b8657945 	ldr	w5, [x10, x5, lsl #2]
 112e520:	4a0500c5 	eor	w5, w6, w5
 112e524:	4a050084 	eor	w4, w4, w5
        work = RORc(leftt, 4) ^ *keys++;
 112e528:	b85f8025 	ldur	w5, [x1, #-8]
        leftt ^= SP8[ work        & 0x3fL]
 112e52c:	4a040042 	eor	w2, w2, w4
    for (cur_round = 0; cur_round < 8; cur_round++) {
 112e530:	eb0f003f 	cmp	x1, x15
        work = RORc(leftt, 4) ^ *keys++;
 112e534:	4ac210a5 	eor	w5, w5, w2, ror #4
        work  = leftt ^ *keys++;
 112e538:	b85fc026 	ldur	w6, [x1, #-4]
        right ^= SP7[ work        & 0x3fL]
 112e53c:	924014b0 	and	x16, x5, #0x3f
        work  = leftt ^ *keys++;
 112e540:	4a060046 	eor	w6, w2, w6
        right ^= SP8[ work        & 0x3fL]
 112e544:	b87079b0 	ldr	w16, [x13, x16, lsl #2]
              ^  SP6[(work >>  8) & 0x3fL]
 112e548:	d34834c4 	ubfx	x4, x6, #8, #6
 112e54c:	b86479c4 	ldr	w4, [x14, x4, lsl #2]
 112e550:	4a100084 	eor	w4, w4, w16
        right ^= SP8[ work        & 0x3fL]
 112e554:	924014d0 	and	x16, x6, #0x3f
 112e558:	b8707990 	ldr	w16, [x12, x16, lsl #2]
 112e55c:	4a100063 	eor	w3, w3, w16
 112e560:	4a030083 	eor	w3, w4, w3
              ^  SP4[(work >> 16) & 0x3fL]
 112e564:	d35054c4 	ubfx	x4, x6, #16, #6
              ^  SP2[(work >> 24) & 0x3fL];
 112e568:	d35874c6 	ubfx	x6, x6, #24, #6
 112e56c:	b8647964 	ldr	w4, [x11, x4, lsl #2]
 112e570:	b8667946 	ldr	w6, [x10, x6, lsl #2]
 112e574:	4a060084 	eor	w4, w4, w6
              ^  SP3[(work >> 16) & 0x3fL]
 112e578:	d35054a6 	ubfx	x6, x5, #16, #6
 112e57c:	4a040063 	eor	w3, w3, w4
              ^  SP5[(work >>  8) & 0x3fL]
 112e580:	d34834a4 	ubfx	x4, x5, #8, #6
              ^  SP1[(work >> 24) & 0x3fL];
 112e584:	d35874a5 	ubfx	x5, x5, #24, #6
 112e588:	b8667906 	ldr	w6, [x8, x6, lsl #2]
 112e58c:	b8647924 	ldr	w4, [x9, x4, lsl #2]
 112e590:	4a060084 	eor	w4, w4, w6
 112e594:	4a040063 	eor	w3, w3, w4
        right ^= SP8[ work        & 0x3fL]
 112e598:	b86578e4 	ldr	w4, [x7, x5, lsl #2]
 112e59c:	4a040063 	eor	w3, w3, w4
    for (cur_round = 0; cur_round < 8; cur_round++) {
 112e5a0:	54fff8e1 	b.ne	112e4bc <desfunc+0x9c>  // b.any
    work = (leftt ^ right) & 0xaaaaaaaaL;
 112e5a4:	4ac30441 	eor	w1, w2, w3, ror #1
 112e5a8:	1201f021 	and	w1, w1, #0xaaaaaaaa
    leftt ^= work;
 112e5ac:	4a010042 	eor	w2, w2, w1
    right ^= work;
 112e5b0:	4ac30423 	eor	w3, w1, w3, ror #1
    leftt = RORc(leftt, 1);
 112e5b4:	13820442 	ror	w2, w2, #1
    work = ((leftt >> 8) ^ right) & 0x00ff00ffL;
 112e5b8:	4a422061 	eor	w1, w3, w2, lsr #8
 112e5bc:	12009c21 	and	w1, w1, #0xff00ff
    right ^= work;
 112e5c0:	4a010063 	eor	w3, w3, w1
    leftt ^= (work << 8);
 112e5c4:	4a012042 	eor	w2, w2, w1, lsl #8
    work = ((leftt >> 2) ^ right) & 0x33333333L;
 112e5c8:	4a420861 	eor	w1, w3, w2, lsr #2
 112e5cc:	1200e421 	and	w1, w1, #0x33333333
    right ^= work;
 112e5d0:	4a010063 	eor	w3, w3, w1
    leftt ^= (work << 2);
 112e5d4:	4a010841 	eor	w1, w2, w1, lsl #2
    work = ((right >> 16) ^ leftt) & 0x0000ffffL;
 112e5d8:	4a434022 	eor	w2, w1, w3, lsr #16
 112e5dc:	12003c42 	and	w2, w2, #0xffff
    leftt ^= work;
 112e5e0:	4a020021 	eor	w1, w1, w2
    right ^= (work << 16);
 112e5e4:	4a024063 	eor	w3, w3, w2, lsl #16
    work = ((right >> 4) ^ leftt) & 0x0f0f0f0fL;
 112e5e8:	4a431022 	eor	w2, w1, w3, lsr #4
 112e5ec:	1200cc42 	and	w2, w2, #0xf0f0f0f
    leftt ^= work;
 112e5f0:	4a020021 	eor	w1, w1, w2
    right ^= (work << 4);
 112e5f4:	4a021063 	eor	w3, w3, w2, lsl #4
    block[1] = leftt;
 112e5f8:	29000403 	stp	w3, w1, [x0]
   burn_stack(sizeof(ulong32) * 4 + sizeof(int));
 112e5fc:	d2800280 	mov	x0, #0x14                  	// #20
 112e600:	14000f86 	b	1132418 <burn_stack>

000000000112e604 <_deskey>:
{
 112e604:	a9a87bfd 	stp	x29, x30, [sp, #-384]!
 112e608:	aa0003e5 	mov	x5, x0
        l = (ulong32)pc1[j];
 112e60c:	90000147 	adrp	x7, 1156000 <ta_pub_key_modulus+0x7>
{
 112e610:	aa0203e0 	mov	x0, x2
        pc1m[j] = (unsigned char)((key[l >> 3U] & bytebit[m]) == bytebit[m] ? 1 : 0);
 112e614:	b0000106 	adrp	x6, 114f000 <SP7+0xd8>
{
 112e618:	13003c21 	sxth	w1, w1
        l = (ulong32)pc1[j];
 112e61c:	911bace7 	add	x7, x7, #0x6eb
        pc1m[j] = (unsigned char)((key[l >> 3U] & bytebit[m]) == bytebit[m] ? 1 : 0);
 112e620:	910620c6 	add	x6, x6, #0x188
 112e624:	910043e2 	add	x2, sp, #0x10
{
 112e628:	d2800003 	mov	x3, #0x0                   	// #0
 112e62c:	910003fd 	mov	x29, sp
        l = (ulong32)pc1[j];
 112e630:	38676864 	ldrb	w4, [x3, x7]
        pc1m[j] = (unsigned char)((key[l >> 3U] & bytebit[m]) == bytebit[m] ? 1 : 0);
 112e634:	92400888 	and	x8, x4, #0x7
 112e638:	d3431c84 	ubfx	x4, x4, #3, #5
 112e63c:	b86878c8 	ldr	w8, [x6, x8, lsl #2]
 112e640:	386468a4 	ldrb	w4, [x5, x4]
 112e644:	6a24011f 	bics	wzr, w8, w4
 112e648:	1a9f17e4 	cset	w4, eq  // eq = none
 112e64c:	38226864 	strb	w4, [x3, x2]
    for (j=0; j < 56; j++) {
 112e650:	91000463 	add	x3, x3, #0x1
 112e654:	f100e07f 	cmp	x3, #0x38
 112e658:	54fffec1 	b.ne	112e630 <_deskey+0x2c>  // b.any
            l = j + (ulong32)totrot[i];
 112e65c:	9000014b 	adrp	x11, 1156000 <ta_pub_key_modulus+0x7>
        kn[m] = kn[n] = 0L;
 112e660:	910203e3 	add	x3, sp, #0x80
            l = j + (ulong32)totrot[i];
 112e664:	911d4d6b 	add	x11, x11, #0x753
 112e668:	910123e9 	add	x9, sp, #0x48
 112e66c:	d2800007 	mov	x7, #0x0                   	// #0
 112e670:	1280002d 	mov	w13, #0xfffffffe            	// #-2
 112e674:	9000014e 	adrp	x14, 1156000 <ta_pub_key_modulus+0x7>
 112e678:	b000010f 	adrp	x15, 114f000 <SP7+0xd8>
        if (edf == DE1) {
 112e67c:	1b0d7ce4 	mul	w4, w7, w13
 112e680:	7100043f 	cmp	w1, #0x1
            l = j + (ulong32)totrot[i];
 112e684:	386b68e6 	ldrb	w6, [x7, x11]
 112e688:	11007885 	add	w5, w4, #0x1e
 112e68c:	531f78e4 	lsl	w4, w7, #1
 112e690:	9a851084 	csel	x4, x4, x5, ne  // ne = any
 112e694:	2a0603ea 	mov	w10, w6
        kn[m] = kn[n] = 0L;
 112e698:	11000488 	add	w8, w4, #0x1
               pcr[j] = pc1m[l];
 112e69c:	8b260050 	add	x16, x2, w6, uxtb
            l = j + (ulong32)totrot[i];
 112e6a0:	d2800005 	mov	x5, #0x0                   	// #0
        kn[m] = kn[n] = 0L;
 112e6a4:	b828787f 	str	wzr, [x3, x8, lsl #2]
 112e6a8:	b824787f 	str	wzr, [x3, x4, lsl #2]
            if (l < 28) {
 112e6ac:	71006d5f 	cmp	w10, #0x1b
 112e6b0:	54000a08 	b.hi	112e7f0 <_deskey+0x1ec>  // b.pmore
               pcr[j] = pc1m[l];
 112e6b4:	38656a0c 	ldrb	w12, [x16, x5]
 112e6b8:	382968ac 	strb	w12, [x5, x9]
        for (j=0; j < 28; j++) {
 112e6bc:	910004a5 	add	x5, x5, #0x1
 112e6c0:	1100054a 	add	w10, w10, #0x1
 112e6c4:	f10070bf 	cmp	x5, #0x1c
 112e6c8:	54ffff21 	b.ne	112e6ac <_deskey+0xa8>  // b.any
 112e6cc:	110070ca 	add	w10, w6, #0x1c
               pcr[j] = pc1m[l - 28];
 112e6d0:	92401cc6 	and	x6, x6, #0xff
 112e6d4:	d10070c6 	sub	x6, x6, #0x1c
 112e6d8:	8b060046 	add	x6, x2, x6
            if (l < 56) {
 112e6dc:	7100dd5f 	cmp	w10, #0x37
 112e6e0:	540008e8 	b.hi	112e7fc <_deskey+0x1f8>  // b.pmore
               pcr[j] = pc1m[l];
 112e6e4:	386a484c 	ldrb	w12, [x2, w10, uxtw]
 112e6e8:	3825692c 	strb	w12, [x9, x5]
        for (/*j = 28*/; j < 56; j++) {
 112e6ec:	910004a5 	add	x5, x5, #0x1
 112e6f0:	1100054a 	add	w10, w10, #0x1
 112e6f4:	f100e0bf 	cmp	x5, #0x38
 112e6f8:	54ffff21 	b.ne	112e6dc <_deskey+0xd8>  // b.any
 112e6fc:	911c8dca 	add	x10, x14, #0x723
 112e700:	9104a1e6 	add	x6, x15, #0x128
               kn[m] |= bigbyte[j];
 112e704:	d37ef484 	lsl	x4, x4, #2
               kn[n] |= bigbyte[j];
 112e708:	d37ef505 	lsl	x5, x8, #2
        for (j=0; j < 24; j++)  {
 112e70c:	5280000c 	mov	w12, #0x0                   	// #0
            if ((int)pcr[(int)pc2[j]] != 0) {
 112e710:	39400148 	ldrb	w8, [x10]
 112e714:	38686928 	ldrb	w8, [x9, x8]
 112e718:	340000a8 	cbz	w8, 112e72c <_deskey+0x128>
               kn[m] |= bigbyte[j];
 112e71c:	b8646868 	ldr	w8, [x3, x4]
 112e720:	b94000d0 	ldr	w16, [x6]
 112e724:	2a100108 	orr	w8, w8, w16
 112e728:	b8246868 	str	w8, [x3, x4]
            if ((int)pcr[(int)pc2[j+24]] != 0) {
 112e72c:	39406148 	ldrb	w8, [x10, #24]
 112e730:	38686928 	ldrb	w8, [x9, x8]
 112e734:	340000a8 	cbz	w8, 112e748 <_deskey+0x144>
               kn[n] |= bigbyte[j];
 112e738:	b8656868 	ldr	w8, [x3, x5]
 112e73c:	b94000d0 	ldr	w16, [x6]
 112e740:	2a100108 	orr	w8, w8, w16
 112e744:	b8256868 	str	w8, [x3, x5]
        for (j=0; j < 24; j++)  {
 112e748:	1100058c 	add	w12, w12, #0x1
 112e74c:	9100054a 	add	x10, x10, #0x1
 112e750:	910010c6 	add	x6, x6, #0x4
 112e754:	7100619f 	cmp	w12, #0x18
 112e758:	54fffdc1 	b.ne	112e710 <_deskey+0x10c>  // b.any
    for (i=0; i < 16; i++) {
 112e75c:	910004e7 	add	x7, x7, #0x1
 112e760:	f10040ff 	cmp	x7, #0x10
 112e764:	54fff8c1 	b.ne	112e67c <_deskey+0x78>  // b.any
    cook = dough;
 112e768:	910403e2 	add	x2, sp, #0x100
    for(i=0; i < 16; i++, raw1++)
 112e76c:	52800008 	mov	w8, #0x0                   	// #0
 112e770:	aa0203e1 	mov	x1, x2
        *cook   |= (*raw1 & 0x00fc0000L) >> 10;
 112e774:	29401864 	ldp	w4, w6, [x3]
    for(i=0; i < 16; i++, raw1++)
 112e778:	11000508 	add	w8, w8, #0x1
 112e77c:	7100411f 	cmp	w8, #0x10
 112e780:	91002063 	add	x3, x3, #0x8
        *cook   |= (*raw0 & 0x00000fc0L) << 10;
 112e784:	d376d485 	lsl	x5, x4, #10
        *cook   |= (*raw1 & 0x00fc0000L) >> 10;
 112e788:	530a7cc7 	lsr	w7, w6, #10
 112e78c:	121814e7 	and	w7, w7, #0x3f00
        *cook   |= (*raw0 & 0x00000fc0L) << 10;
 112e790:	121014a5 	and	w5, w5, #0x3f0000
        *cook++ |= (*raw1 & 0x00000fc0L) >> 6;
 112e794:	2a0700a5 	orr	w5, w5, w7
        *cook    = (*raw0 & 0x00fc0000L) << 6;
 112e798:	d37ae487 	lsl	x7, x4, #6
        *cook++ |= (*raw1 & 0x00000fc0L) >> 6;
 112e79c:	d3462cc9 	ubfx	x9, x6, #6, #6
        *cook    = (*raw0 & 0x00fc0000L) << 6;
 112e7a0:	120814e7 	and	w7, w7, #0x3f000000
        *cook++ |= (*raw1 & 0x00000fc0L) >> 6;
 112e7a4:	2a0900e7 	orr	w7, w7, w9
 112e7a8:	2a0700a5 	orr	w5, w5, w7
        *cook   |= (*raw1 & 0x0003f000L) >> 4;
 112e7ac:	53047cc7 	lsr	w7, w6, #4
        *cook++ |= (*raw1 & 0x00000fc0L) >> 6;
 112e7b0:	b8008445 	str	w5, [x2], #8
        *cook   |= (*raw0 & 0x0000003fL) << 16;
 112e7b4:	53101485 	ubfiz	w5, w4, #16, #6
        *cook    = (*raw0 & 0x0003f000L) << 12;
 112e7b8:	d374cc84 	lsl	x4, x4, #12
        *cook   |= (*raw1 & 0x0003f000L) >> 4;
 112e7bc:	121814e7 	and	w7, w7, #0x3f00
        *cook    = (*raw0 & 0x0003f000L) << 12;
 112e7c0:	12081484 	and	w4, w4, #0x3f000000
        *cook++ |= (*raw1 & 0x0000003fL);
 112e7c4:	120014c6 	and	w6, w6, #0x3f
 112e7c8:	2a0700a5 	orr	w5, w5, w7
 112e7cc:	2a060084 	orr	w4, w4, w6
 112e7d0:	2a0400a4 	orr	w4, w5, w4
 112e7d4:	b81fc044 	stur	w4, [x2, #-4]
    for(i=0; i < 16; i++, raw1++)
 112e7d8:	54fffce1 	b.ne	112e774 <_deskey+0x170>  // b.any
    XMEMCPY(keyout, dough, sizeof(dough));
 112e7dc:	d2801002 	mov	x2, #0x80                  	// #128
 112e7e0:	97ff52ec 	bl	1103390 <memcpy>
}
 112e7e4:	a8d87bfd 	ldp	x29, x30, [sp], #384
   burn_stack(sizeof(ulong32 *) * 2 + sizeof(ulong32)*32 + sizeof(int));
 112e7e8:	d2801280 	mov	x0, #0x94                  	// #148
 112e7ec:	14000f0b 	b	1132418 <burn_stack>
               pcr[j] = pc1m[l - 28];
 112e7f0:	5100714c 	sub	w12, w10, #0x1c
 112e7f4:	386c684c 	ldrb	w12, [x2, x12]
 112e7f8:	17ffffb0 	b	112e6b8 <_deskey+0xb4>
               pcr[j] = pc1m[l - 28];
 112e7fc:	386568cc 	ldrb	w12, [x6, x5]
 112e800:	17ffffba 	b	112e6e8 <_deskey+0xe4>

000000000112e804 <deskey>:
{
 112e804:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 112e808:	910003fd 	mov	x29, sp
   _deskey(key, edf, keyout);
 112e80c:	97ffff7e 	bl	112e604 <_deskey>
}
 112e810:	a8c17bfd 	ldp	x29, x30, [sp], #16
   burn_stack(sizeof(int)*5 + sizeof(ulong32)*32 + sizeof(unsigned char)*112);
 112e814:	d2802080 	mov	x0, #0x104                 	// #260
 112e818:	14000f00 	b	1132418 <burn_stack>

000000000112e81c <des_setup>:
{
 112e81c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 112e820:	910003fd 	mov	x29, sp
 112e824:	a90153f3 	stp	x19, x20, [sp, #16]
 112e828:	f90013f5 	str	x21, [sp, #32]
    LTC_ARGCHK(key != NULL);
 112e82c:	b4000280 	cbz	x0, 112e87c <des_setup+0x60>
 112e830:	aa0303f4 	mov	x20, x3
    LTC_ARGCHK(skey != NULL);
 112e834:	b4000243 	cbz	x3, 112e87c <des_setup+0x60>
    if (num_rounds != 0 && num_rounds != 16) {
 112e838:	721b7853 	ands	w19, w2, #0xffffffef
 112e83c:	54000241 	b.ne	112e884 <des_setup+0x68>  // b.any
    if (keylen != 8) {
 112e840:	7100203f 	cmp	w1, #0x8
 112e844:	54000241 	b.ne	112e88c <des_setup+0x70>  // b.any
 112e848:	aa0003f5 	mov	x21, x0
    deskey(key, EN0, skey->des.ek);
 112e84c:	aa0303e2 	mov	x2, x3
 112e850:	52800001 	mov	w1, #0x0                   	// #0
 112e854:	97ffffec 	bl	112e804 <deskey>
    deskey(key, DE1, skey->des.dk);
 112e858:	91020282 	add	x2, x20, #0x80
 112e85c:	aa1503e0 	mov	x0, x21
 112e860:	52800021 	mov	w1, #0x1                   	// #1
 112e864:	97ffffe8 	bl	112e804 <deskey>
}
 112e868:	2a1303e0 	mov	w0, w19
 112e86c:	a94153f3 	ldp	x19, x20, [sp, #16]
 112e870:	f94013f5 	ldr	x21, [sp, #32]
 112e874:	a8c37bfd 	ldp	x29, x30, [sp], #48
 112e878:	d65f03c0 	ret
    LTC_ARGCHK(key != NULL);
 112e87c:	52800213 	mov	w19, #0x10                  	// #16
 112e880:	17fffffa 	b	112e868 <des_setup+0x4c>
        return CRYPT_INVALID_ROUNDS;
 112e884:	52800093 	mov	w19, #0x4                   	// #4
 112e888:	17fffff8 	b	112e868 <des_setup+0x4c>
        return CRYPT_INVALID_KEYSIZE;
 112e88c:	52800073 	mov	w19, #0x3                   	// #3
 112e890:	17fffff6 	b	112e868 <des_setup+0x4c>

000000000112e894 <des3_setup>:
{
 112e894:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 112e898:	910003fd 	mov	x29, sp
 112e89c:	a90153f3 	stp	x19, x20, [sp, #16]
 112e8a0:	a9025bf5 	stp	x21, x22, [sp, #32]
 112e8a4:	f9001bf7 	str	x23, [sp, #48]
    LTC_ARGCHK(key != NULL);
 112e8a8:	b4000600 	cbz	x0, 112e968 <des3_setup+0xd4>
 112e8ac:	aa0303f3 	mov	x19, x3
    LTC_ARGCHK(skey != NULL);
 112e8b0:	b40005c3 	cbz	x3, 112e968 <des3_setup+0xd4>
    if(num_rounds != 0 && num_rounds != 16) {
 112e8b4:	721b7854 	ands	w20, w2, #0xffffffef
 112e8b8:	540005c1 	b.ne	112e970 <des3_setup+0xdc>  // b.any
 112e8bc:	2a0103f6 	mov	w22, w1
    if (keylen != 24 && keylen != 16) {
 112e8c0:	121c7821 	and	w1, w1, #0xfffffff7
 112e8c4:	7100403f 	cmp	w1, #0x10
 112e8c8:	54000581 	b.ne	112e978 <des3_setup+0xe4>  // b.any
 112e8cc:	aa0003f5 	mov	x21, x0
    deskey(key,    EN0, skey->des3.ek[0]);
 112e8d0:	aa0303e2 	mov	x2, x3
 112e8d4:	52800001 	mov	w1, #0x0                   	// #0
    deskey(key+8,  DE1, skey->des3.ek[1]);
 112e8d8:	910022b7 	add	x23, x21, #0x8
    deskey(key,    EN0, skey->des3.ek[0]);
 112e8dc:	97ffffca 	bl	112e804 <deskey>
    deskey(key+8,  DE1, skey->des3.ek[1]);
 112e8e0:	91020262 	add	x2, x19, #0x80
 112e8e4:	52800021 	mov	w1, #0x1                   	// #1
 112e8e8:	aa1703e0 	mov	x0, x23
 112e8ec:	97ffffc6 	bl	112e804 <deskey>
    if (keylen == 24) {
 112e8f0:	91040262 	add	x2, x19, #0x100
 112e8f4:	710062df 	cmp	w22, #0x18
        deskey(key+16, EN0, skey->des3.ek[2]);
 112e8f8:	52800001 	mov	w1, #0x0                   	// #0
    if (keylen == 24) {
 112e8fc:	540002e1 	b.ne	112e958 <des3_setup+0xc4>  // b.any
        deskey(key+16, EN0, skey->des3.ek[2]);
 112e900:	910042a0 	add	x0, x21, #0x10
        deskey(key, EN0, skey->des3.ek[2]);
 112e904:	97ffffc0 	bl	112e804 <deskey>
    deskey(key,    DE1, skey->des3.dk[2]);
 112e908:	910a0262 	add	x2, x19, #0x280
 112e90c:	aa1503e0 	mov	x0, x21
 112e910:	52800021 	mov	w1, #0x1                   	// #1
 112e914:	97ffffbc 	bl	112e804 <deskey>
    deskey(key+8,  EN0, skey->des3.dk[1]);
 112e918:	91080262 	add	x2, x19, #0x200
 112e91c:	52800001 	mov	w1, #0x0                   	// #0
 112e920:	aa1703e0 	mov	x0, x23
 112e924:	97ffffb8 	bl	112e804 <deskey>
    if (keylen == 24) {
 112e928:	91060262 	add	x2, x19, #0x180
 112e92c:	710062df 	cmp	w22, #0x18
        deskey(key+16, DE1, skey->des3.dk[0]);
 112e930:	52800021 	mov	w1, #0x1                   	// #1
    if (keylen == 24) {
 112e934:	54000161 	b.ne	112e960 <des3_setup+0xcc>  // b.any
        deskey(key+16, DE1, skey->des3.dk[0]);
 112e938:	910042a0 	add	x0, x21, #0x10
        deskey(key, DE1, skey->des3.dk[0]);
 112e93c:	97ffffb2 	bl	112e804 <deskey>
}
 112e940:	2a1403e0 	mov	w0, w20
 112e944:	a94153f3 	ldp	x19, x20, [sp, #16]
 112e948:	a9425bf5 	ldp	x21, x22, [sp, #32]
 112e94c:	f9401bf7 	ldr	x23, [sp, #48]
 112e950:	a8c47bfd 	ldp	x29, x30, [sp], #64
 112e954:	d65f03c0 	ret
        deskey(key, EN0, skey->des3.ek[2]);
 112e958:	aa1503e0 	mov	x0, x21
 112e95c:	17ffffea 	b	112e904 <des3_setup+0x70>
        deskey(key, DE1, skey->des3.dk[0]);
 112e960:	aa1503e0 	mov	x0, x21
 112e964:	17fffff6 	b	112e93c <des3_setup+0xa8>
    LTC_ARGCHK(key != NULL);
 112e968:	52800214 	mov	w20, #0x10                  	// #16
 112e96c:	17fffff5 	b	112e940 <des3_setup+0xac>
        return CRYPT_INVALID_ROUNDS;
 112e970:	52800094 	mov	w20, #0x4                   	// #4
 112e974:	17fffff3 	b	112e940 <des3_setup+0xac>
        return CRYPT_INVALID_KEYSIZE;
 112e978:	52800074 	mov	w20, #0x3                   	// #3
 112e97c:	17fffff1 	b	112e940 <des3_setup+0xac>

000000000112e980 <des_ecb_encrypt>:
    LTC_ARGCHK(pt   != NULL);
 112e980:	b4000600 	cbz	x0, 112ea40 <des_ecb_encrypt+0xc0>
{
 112e984:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 112e988:	910003fd 	mov	x29, sp
 112e98c:	a90153f3 	stp	x19, x20, [sp, #16]
 112e990:	aa0103f3 	mov	x19, x1
 112e994:	a9025bf5 	stp	x21, x22, [sp, #32]
    LTC_ARGCHK(ct   != NULL);
 112e998:	b4000581 	cbz	x1, 112ea48 <des_ecb_encrypt+0xc8>
 112e99c:	aa0203f6 	mov	x22, x2
    LTC_ARGCHK(skey != NULL);
 112e9a0:	b4000542 	cbz	x2, 112ea48 <des_ecb_encrypt+0xc8>
    LOAD32H(work[0], pt+0);
 112e9a4:	9100e3f4 	add	x20, sp, #0x38
 112e9a8:	aa0003e1 	mov	x1, x0
 112e9ac:	aa0003f5 	mov	x21, x0
 112e9b0:	d2800082 	mov	x2, #0x4                   	// #4
 112e9b4:	aa1403e0 	mov	x0, x20
 112e9b8:	97ff5276 	bl	1103390 <memcpy>
 112e9bc:	b9403be0 	ldr	w0, [sp, #56]
    LOAD32H(work[1], pt+4);
 112e9c0:	d2800082 	mov	x2, #0x4                   	// #4
 112e9c4:	8b0202a1 	add	x1, x21, x2
    LOAD32H(work[0], pt+0);
 112e9c8:	5ac00800 	rev	w0, w0
 112e9cc:	b9003be0 	str	w0, [sp, #56]
    LOAD32H(work[1], pt+4);
 112e9d0:	8b020280 	add	x0, x20, x2
 112e9d4:	97ff526f 	bl	1103390 <memcpy>
 112e9d8:	b9403fe0 	ldr	w0, [sp, #60]
    desfunc(work, skey->des.ek);
 112e9dc:	aa1603e1 	mov	x1, x22
    LOAD32H(work[1], pt+4);
 112e9e0:	5ac00800 	rev	w0, w0
 112e9e4:	b9003fe0 	str	w0, [sp, #60]
    desfunc(work, skey->des.ek);
 112e9e8:	aa1403e0 	mov	x0, x20
 112e9ec:	97fffe8d 	bl	112e420 <desfunc>
    STORE32H(work[0],ct+0);
 112e9f0:	b9403be0 	ldr	w0, [sp, #56]
 112e9f4:	9100d3f4 	add	x20, sp, #0x34
 112e9f8:	aa1403e1 	mov	x1, x20
 112e9fc:	d2800082 	mov	x2, #0x4                   	// #4
 112ea00:	5ac00800 	rev	w0, w0
 112ea04:	b90037e0 	str	w0, [sp, #52]
 112ea08:	aa1303e0 	mov	x0, x19
 112ea0c:	97ff5261 	bl	1103390 <memcpy>
    STORE32H(work[1],ct+4);
 112ea10:	b9403fe0 	ldr	w0, [sp, #60]
 112ea14:	d2800082 	mov	x2, #0x4                   	// #4
 112ea18:	aa1403e1 	mov	x1, x20
 112ea1c:	5ac00800 	rev	w0, w0
 112ea20:	b90037e0 	str	w0, [sp, #52]
 112ea24:	8b020260 	add	x0, x19, x2
 112ea28:	97ff525a 	bl	1103390 <memcpy>
    return CRYPT_OK;
 112ea2c:	52800000 	mov	w0, #0x0                   	// #0
}
 112ea30:	a94153f3 	ldp	x19, x20, [sp, #16]
 112ea34:	a9425bf5 	ldp	x21, x22, [sp, #32]
 112ea38:	a8c47bfd 	ldp	x29, x30, [sp], #64
 112ea3c:	d65f03c0 	ret
    LTC_ARGCHK(pt   != NULL);
 112ea40:	52800200 	mov	w0, #0x10                  	// #16
}
 112ea44:	d65f03c0 	ret
    LTC_ARGCHK(pt   != NULL);
 112ea48:	52800200 	mov	w0, #0x10                  	// #16
 112ea4c:	17fffff9 	b	112ea30 <des_ecb_encrypt+0xb0>

000000000112ea50 <des_ecb_decrypt>:
    LTC_ARGCHK(pt   != NULL);
 112ea50:	b4000601 	cbz	x1, 112eb10 <des_ecb_decrypt+0xc0>
{
 112ea54:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 112ea58:	910003fd 	mov	x29, sp
 112ea5c:	a90153f3 	stp	x19, x20, [sp, #16]
 112ea60:	a9025bf5 	stp	x21, x22, [sp, #32]
 112ea64:	aa0003f5 	mov	x21, x0
    LTC_ARGCHK(ct   != NULL);
 112ea68:	b4000580 	cbz	x0, 112eb18 <des_ecb_decrypt+0xc8>
 112ea6c:	aa0203f6 	mov	x22, x2
    LTC_ARGCHK(skey != NULL);
 112ea70:	b4000542 	cbz	x2, 112eb18 <des_ecb_decrypt+0xc8>
    LOAD32H(work[0], ct+0);
 112ea74:	9100e3f4 	add	x20, sp, #0x38
 112ea78:	aa0103f3 	mov	x19, x1
 112ea7c:	d2800082 	mov	x2, #0x4                   	// #4
 112ea80:	aa0003e1 	mov	x1, x0
 112ea84:	aa1403e0 	mov	x0, x20
 112ea88:	97ff5242 	bl	1103390 <memcpy>
 112ea8c:	b9403be0 	ldr	w0, [sp, #56]
    LOAD32H(work[1], ct+4);
 112ea90:	d2800082 	mov	x2, #0x4                   	// #4
 112ea94:	8b0202a1 	add	x1, x21, x2
    LOAD32H(work[0], ct+0);
 112ea98:	5ac00800 	rev	w0, w0
 112ea9c:	b9003be0 	str	w0, [sp, #56]
    LOAD32H(work[1], ct+4);
 112eaa0:	8b020280 	add	x0, x20, x2
 112eaa4:	97ff523b 	bl	1103390 <memcpy>
 112eaa8:	b9403fe0 	ldr	w0, [sp, #60]
    desfunc(work, skey->des.dk);
 112eaac:	910202c1 	add	x1, x22, #0x80
    LOAD32H(work[1], ct+4);
 112eab0:	5ac00800 	rev	w0, w0
 112eab4:	b9003fe0 	str	w0, [sp, #60]
    desfunc(work, skey->des.dk);
 112eab8:	aa1403e0 	mov	x0, x20
 112eabc:	97fffe59 	bl	112e420 <desfunc>
    STORE32H(work[0],pt+0);
 112eac0:	b9403be0 	ldr	w0, [sp, #56]
 112eac4:	9100d3f4 	add	x20, sp, #0x34
 112eac8:	aa1403e1 	mov	x1, x20
 112eacc:	d2800082 	mov	x2, #0x4                   	// #4
 112ead0:	5ac00800 	rev	w0, w0
 112ead4:	b90037e0 	str	w0, [sp, #52]
 112ead8:	aa1303e0 	mov	x0, x19
 112eadc:	97ff522d 	bl	1103390 <memcpy>
    STORE32H(work[1],pt+4);
 112eae0:	b9403fe0 	ldr	w0, [sp, #60]
 112eae4:	d2800082 	mov	x2, #0x4                   	// #4
 112eae8:	aa1403e1 	mov	x1, x20
 112eaec:	5ac00800 	rev	w0, w0
 112eaf0:	b90037e0 	str	w0, [sp, #52]
 112eaf4:	8b020260 	add	x0, x19, x2
 112eaf8:	97ff5226 	bl	1103390 <memcpy>
    return CRYPT_OK;
 112eafc:	52800000 	mov	w0, #0x0                   	// #0
}
 112eb00:	a94153f3 	ldp	x19, x20, [sp, #16]
 112eb04:	a9425bf5 	ldp	x21, x22, [sp, #32]
 112eb08:	a8c47bfd 	ldp	x29, x30, [sp], #64
 112eb0c:	d65f03c0 	ret
    LTC_ARGCHK(pt   != NULL);
 112eb10:	52800200 	mov	w0, #0x10                  	// #16
}
 112eb14:	d65f03c0 	ret
    LTC_ARGCHK(pt   != NULL);
 112eb18:	52800200 	mov	w0, #0x10                  	// #16
 112eb1c:	17fffff9 	b	112eb00 <des_ecb_decrypt+0xb0>

000000000112eb20 <des3_ecb_encrypt>:
    LTC_ARGCHK(pt   != NULL);
 112eb20:	b40006c0 	cbz	x0, 112ebf8 <des3_ecb_encrypt+0xd8>
{
 112eb24:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 112eb28:	910003fd 	mov	x29, sp
 112eb2c:	a90153f3 	stp	x19, x20, [sp, #16]
 112eb30:	a9025bf5 	stp	x21, x22, [sp, #32]
 112eb34:	aa0103f5 	mov	x21, x1
    LTC_ARGCHK(ct   != NULL);
 112eb38:	b4000641 	cbz	x1, 112ec00 <des3_ecb_encrypt+0xe0>
 112eb3c:	aa0203f4 	mov	x20, x2
    LTC_ARGCHK(skey != NULL);
 112eb40:	b4000602 	cbz	x2, 112ec00 <des3_ecb_encrypt+0xe0>
    LOAD32H(work[0], pt+0);
 112eb44:	9100e3f3 	add	x19, sp, #0x38
 112eb48:	aa0003e1 	mov	x1, x0
 112eb4c:	aa0003f6 	mov	x22, x0
 112eb50:	d2800082 	mov	x2, #0x4                   	// #4
 112eb54:	aa1303e0 	mov	x0, x19
 112eb58:	97ff520e 	bl	1103390 <memcpy>
 112eb5c:	b9403be0 	ldr	w0, [sp, #56]
    LOAD32H(work[1], pt+4);
 112eb60:	d2800082 	mov	x2, #0x4                   	// #4
 112eb64:	8b0202c1 	add	x1, x22, x2
    LOAD32H(work[0], pt+0);
 112eb68:	5ac00800 	rev	w0, w0
 112eb6c:	b9003be0 	str	w0, [sp, #56]
    LOAD32H(work[1], pt+4);
 112eb70:	8b020260 	add	x0, x19, x2
 112eb74:	97ff5207 	bl	1103390 <memcpy>
 112eb78:	b9403fe0 	ldr	w0, [sp, #60]
    desfunc(work, skey->des3.ek[0]);
 112eb7c:	aa1403e1 	mov	x1, x20
    LOAD32H(work[1], pt+4);
 112eb80:	5ac00800 	rev	w0, w0
 112eb84:	b9003fe0 	str	w0, [sp, #60]
    desfunc(work, skey->des3.ek[0]);
 112eb88:	aa1303e0 	mov	x0, x19
 112eb8c:	97fffe25 	bl	112e420 <desfunc>
    desfunc(work, skey->des3.ek[1]);
 112eb90:	aa1303e0 	mov	x0, x19
 112eb94:	91020281 	add	x1, x20, #0x80
 112eb98:	97fffe22 	bl	112e420 <desfunc>
    desfunc(work, skey->des3.ek[2]);
 112eb9c:	aa1303e0 	mov	x0, x19
 112eba0:	91040281 	add	x1, x20, #0x100
 112eba4:	97fffe1f 	bl	112e420 <desfunc>
    STORE32H(work[0],ct+0);
 112eba8:	9100d3f3 	add	x19, sp, #0x34
 112ebac:	b9403be0 	ldr	w0, [sp, #56]
 112ebb0:	aa1303e1 	mov	x1, x19
 112ebb4:	d2800082 	mov	x2, #0x4                   	// #4
 112ebb8:	5ac00800 	rev	w0, w0
 112ebbc:	b90037e0 	str	w0, [sp, #52]
 112ebc0:	aa1503e0 	mov	x0, x21
 112ebc4:	97ff51f3 	bl	1103390 <memcpy>
    STORE32H(work[1],ct+4);
 112ebc8:	b9403fe0 	ldr	w0, [sp, #60]
 112ebcc:	d2800082 	mov	x2, #0x4                   	// #4
 112ebd0:	aa1303e1 	mov	x1, x19
 112ebd4:	5ac00800 	rev	w0, w0
 112ebd8:	b90037e0 	str	w0, [sp, #52]
 112ebdc:	8b0202a0 	add	x0, x21, x2
 112ebe0:	97ff51ec 	bl	1103390 <memcpy>
    return CRYPT_OK;
 112ebe4:	52800000 	mov	w0, #0x0                   	// #0
}
 112ebe8:	a94153f3 	ldp	x19, x20, [sp, #16]
 112ebec:	a9425bf5 	ldp	x21, x22, [sp, #32]
 112ebf0:	a8c47bfd 	ldp	x29, x30, [sp], #64
 112ebf4:	d65f03c0 	ret
    LTC_ARGCHK(pt   != NULL);
 112ebf8:	52800200 	mov	w0, #0x10                  	// #16
}
 112ebfc:	d65f03c0 	ret
    LTC_ARGCHK(pt   != NULL);
 112ec00:	52800200 	mov	w0, #0x10                  	// #16
 112ec04:	17fffff9 	b	112ebe8 <des3_ecb_encrypt+0xc8>

000000000112ec08 <des3_ecb_decrypt>:
    LTC_ARGCHK(pt   != NULL);
 112ec08:	b40006c1 	cbz	x1, 112ece0 <des3_ecb_decrypt+0xd8>
{
 112ec0c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 112ec10:	910003fd 	mov	x29, sp
 112ec14:	a90153f3 	stp	x19, x20, [sp, #16]
 112ec18:	a9025bf5 	stp	x21, x22, [sp, #32]
 112ec1c:	aa0003f6 	mov	x22, x0
    LTC_ARGCHK(ct   != NULL);
 112ec20:	b4000640 	cbz	x0, 112ece8 <des3_ecb_decrypt+0xe0>
 112ec24:	aa0203f4 	mov	x20, x2
    LTC_ARGCHK(skey != NULL);
 112ec28:	b4000602 	cbz	x2, 112ece8 <des3_ecb_decrypt+0xe0>
    LOAD32H(work[0], ct+0);
 112ec2c:	9100e3f3 	add	x19, sp, #0x38
 112ec30:	aa0103f5 	mov	x21, x1
 112ec34:	d2800082 	mov	x2, #0x4                   	// #4
 112ec38:	aa0003e1 	mov	x1, x0
 112ec3c:	aa1303e0 	mov	x0, x19
 112ec40:	97ff51d4 	bl	1103390 <memcpy>
 112ec44:	b9403be0 	ldr	w0, [sp, #56]
    LOAD32H(work[1], ct+4);
 112ec48:	d2800082 	mov	x2, #0x4                   	// #4
 112ec4c:	8b0202c1 	add	x1, x22, x2
    LOAD32H(work[0], ct+0);
 112ec50:	5ac00800 	rev	w0, w0
 112ec54:	b9003be0 	str	w0, [sp, #56]
    LOAD32H(work[1], ct+4);
 112ec58:	8b020260 	add	x0, x19, x2
 112ec5c:	97ff51cd 	bl	1103390 <memcpy>
 112ec60:	b9403fe0 	ldr	w0, [sp, #60]
    desfunc(work, skey->des3.dk[0]);
 112ec64:	91060281 	add	x1, x20, #0x180
    LOAD32H(work[1], ct+4);
 112ec68:	5ac00800 	rev	w0, w0
 112ec6c:	b9003fe0 	str	w0, [sp, #60]
    desfunc(work, skey->des3.dk[0]);
 112ec70:	aa1303e0 	mov	x0, x19
 112ec74:	97fffdeb 	bl	112e420 <desfunc>
    desfunc(work, skey->des3.dk[1]);
 112ec78:	aa1303e0 	mov	x0, x19
 112ec7c:	91080281 	add	x1, x20, #0x200
 112ec80:	97fffde8 	bl	112e420 <desfunc>
    desfunc(work, skey->des3.dk[2]);
 112ec84:	aa1303e0 	mov	x0, x19
 112ec88:	910a0281 	add	x1, x20, #0x280
 112ec8c:	97fffde5 	bl	112e420 <desfunc>
    STORE32H(work[0],pt+0);
 112ec90:	9100d3f3 	add	x19, sp, #0x34
 112ec94:	b9403be0 	ldr	w0, [sp, #56]
 112ec98:	aa1303e1 	mov	x1, x19
 112ec9c:	d2800082 	mov	x2, #0x4                   	// #4
 112eca0:	5ac00800 	rev	w0, w0
 112eca4:	b90037e0 	str	w0, [sp, #52]
 112eca8:	aa1503e0 	mov	x0, x21
 112ecac:	97ff51b9 	bl	1103390 <memcpy>
    STORE32H(work[1],pt+4);
 112ecb0:	b9403fe0 	ldr	w0, [sp, #60]
 112ecb4:	d2800082 	mov	x2, #0x4                   	// #4
 112ecb8:	aa1303e1 	mov	x1, x19
 112ecbc:	5ac00800 	rev	w0, w0
 112ecc0:	b90037e0 	str	w0, [sp, #52]
 112ecc4:	8b0202a0 	add	x0, x21, x2
 112ecc8:	97ff51b2 	bl	1103390 <memcpy>
    return CRYPT_OK;
 112eccc:	52800000 	mov	w0, #0x0                   	// #0
}
 112ecd0:	a94153f3 	ldp	x19, x20, [sp, #16]
 112ecd4:	a9425bf5 	ldp	x21, x22, [sp, #32]
 112ecd8:	a8c47bfd 	ldp	x29, x30, [sp], #64
 112ecdc:	d65f03c0 	ret
    LTC_ARGCHK(pt   != NULL);
 112ece0:	52800200 	mov	w0, #0x10                  	// #16
}
 112ece4:	d65f03c0 	ret
    LTC_ARGCHK(pt   != NULL);
 112ece8:	52800200 	mov	w0, #0x10                  	// #16
 112ecec:	17fffff9 	b	112ecd0 <des3_ecb_decrypt+0xc8>

000000000112ecf0 <des3_done>:
 112ecf0:	d65f03c0 	ret

000000000112ecf4 <des3_test>:
 112ecf4:	52800040 	mov	w0, #0x2                   	// #2
 112ecf8:	d65f03c0 	ret

000000000112ecfc <setup_mix>:
#define __LTC_AES_TAB_C__
#include "aes_tab.c"

static ulong32 setup_mix(ulong32 temp)
{
   return (Te4_3[LTC_BYTE(temp, 2)]) ^
 112ecfc:	d3505c02 	ubfx	x2, x0, #16, #8
 112ed00:	b0000101 	adrp	x1, 114f000 <SP7+0xd8>
 112ed04:	9136a021 	add	x1, x1, #0xda8
 112ed08:	b8627823 	ldr	w3, [x1, x2, lsl #2]
          (Te4_2[LTC_BYTE(temp, 1)]) ^
 112ed0c:	d3483c02 	ubfx	x2, x0, #8, #8
   return (Te4_3[LTC_BYTE(temp, 2)]) ^
 112ed10:	12081c63 	and	w3, w3, #0xff000000
          (Te4_2[LTC_BYTE(temp, 1)]) ^
 112ed14:	b8627822 	ldr	w2, [x1, x2, lsl #2]
 112ed18:	12101c42 	and	w2, w2, #0xff0000
   return (Te4_3[LTC_BYTE(temp, 2)]) ^
 112ed1c:	2a020063 	orr	w3, w3, w2
          (Te4_1[LTC_BYTE(temp, 0)]) ^
 112ed20:	92401c02 	and	x2, x0, #0xff
          (Te4_0[LTC_BYTE(temp, 3)]);
 112ed24:	53187c00 	lsr	w0, w0, #24
          (Te4_1[LTC_BYTE(temp, 0)]) ^
 112ed28:	b8627822 	ldr	w2, [x1, x2, lsl #2]
          (Te4_0[LTC_BYTE(temp, 3)]);
 112ed2c:	b8607820 	ldr	w0, [x1, x0, lsl #2]
          (Te4_1[LTC_BYTE(temp, 0)]) ^
 112ed30:	12181c42 	and	w2, w2, #0xff00
          (Te4_0[LTC_BYTE(temp, 3)]);
 112ed34:	12001c00 	and	w0, w0, #0xff
          (Te4_1[LTC_BYTE(temp, 0)]) ^
 112ed38:	2a000040 	orr	w0, w2, w0
}
 112ed3c:	2a000060 	orr	w0, w3, w0
 112ed40:	d65f03c0 	ret

000000000112ed44 <setup_mix2>:
#ifndef ENCRYPT_ONLY
#ifdef LTC_SMALL_CODE
static ulong32 setup_mix2(ulong32 temp)
{
   return Td0(255 & Te4[LTC_BYTE(temp, 3)]) ^
          Td1(255 & Te4[LTC_BYTE(temp, 2)]) ^
 112ed44:	d3505c03 	ubfx	x3, x0, #16, #8
 112ed48:	b0000102 	adrp	x2, 114f000 <SP7+0xd8>
 112ed4c:	9136a042 	add	x2, x2, #0xda8
 112ed50:	b0000101 	adrp	x1, 114f000 <SP7+0xd8>
 112ed54:	9106a021 	add	x1, x1, #0x1a8
 112ed58:	b8637843 	ldr	w3, [x2, x3, lsl #2]
 112ed5c:	92401c63 	and	x3, x3, #0xff
          Td2(255 & Te4[LTC_BYTE(temp, 1)]) ^
 112ed60:	b8637824 	ldr	w4, [x1, x3, lsl #2]
 112ed64:	d3483c03 	ubfx	x3, x0, #8, #8
 112ed68:	b8637843 	ldr	w3, [x2, x3, lsl #2]
 112ed6c:	92401c63 	and	x3, x3, #0xff
 112ed70:	b8637823 	ldr	w3, [x1, x3, lsl #2]
 112ed74:	13834063 	ror	w3, w3, #16
 112ed78:	4ac42064 	eor	w4, w3, w4, ror #8
          Td3(255 & Te4[LTC_BYTE(temp, 0)]);
 112ed7c:	92401c03 	and	x3, x0, #0xff
   return Td0(255 & Te4[LTC_BYTE(temp, 3)]) ^
 112ed80:	53187c00 	lsr	w0, w0, #24
          Td3(255 & Te4[LTC_BYTE(temp, 0)]);
 112ed84:	b8637843 	ldr	w3, [x2, x3, lsl #2]
   return Td0(255 & Te4[LTC_BYTE(temp, 3)]) ^
 112ed88:	b8607840 	ldr	w0, [x2, x0, lsl #2]
          Td3(255 & Te4[LTC_BYTE(temp, 0)]);
 112ed8c:	92401c63 	and	x3, x3, #0xff
   return Td0(255 & Te4[LTC_BYTE(temp, 3)]) ^
 112ed90:	92401c00 	and	x0, x0, #0xff
          Td2(255 & Te4[LTC_BYTE(temp, 1)]) ^
 112ed94:	b8637823 	ldr	w3, [x1, x3, lsl #2]
 112ed98:	b8607820 	ldr	w0, [x1, x0, lsl #2]
 112ed9c:	4ac36000 	eor	w0, w0, w3, ror #24
}
 112eda0:	4a000080 	eor	w0, w4, w0
 112eda4:	d65f03c0 	ret

000000000112eda8 <rijndael_test>:
    for (y = 0; y < 1000; y++) rijndael_ecb_decrypt(tmp[0], tmp[0], &key);
    for (y = 0; y < 16; y++) if (tmp[0][y] != 0) return CRYPT_FAIL_TESTVECTOR;
  }
  return CRYPT_OK;
 #endif
}
 112eda8:	52800040 	mov	w0, #0x2                   	// #2
 112edac:	d65f03c0 	ret

000000000112edb0 <rijndael_done>:
   @param skey    The scheduled key
*/
void ECB_DONE(symmetric_key *skey)
{
  LTC_UNUSED_PARAM(skey);
}
 112edb0:	d65f03c0 	ret

000000000112edb4 <rijndael_keysize>:
  @param keysize [in/out] The length of the recommended key (in bytes).  This function will store the suitable size back in this variable.
  @return CRYPT_OK if the input key size is acceptable.
*/
int ECB_KS(int *keysize)
{
   LTC_ARGCHK(keysize != NULL);
 112edb4:	b4000200 	cbz	x0, 112edf4 <rijndael_keysize+0x40>

   if (*keysize < 16) {
 112edb8:	b9400001 	ldr	w1, [x0]
 112edbc:	71003c3f 	cmp	w1, #0xf
 112edc0:	540001ed 	b.le	112edfc <rijndael_keysize+0x48>
      return CRYPT_INVALID_KEYSIZE;
   }
   if (*keysize < 24) {
 112edc4:	71005c3f 	cmp	w1, #0x17
 112edc8:	540000ac 	b.gt	112eddc <rijndael_keysize+0x28>
      *keysize = 16;
 112edcc:	52800201 	mov	w1, #0x10                  	// #16
   }
   if (*keysize < 32) {
      *keysize = 24;
      return CRYPT_OK;
   }
   *keysize = 32;
 112edd0:	b9000001 	str	w1, [x0]
   return CRYPT_OK;
 112edd4:	52800000 	mov	w0, #0x0                   	// #0
}
 112edd8:	d65f03c0 	ret
   if (*keysize < 32) {
 112eddc:	71007c3f 	cmp	w1, #0x1f
 112ede0:	5400006c 	b.gt	112edec <rijndael_keysize+0x38>
      *keysize = 24;
 112ede4:	52800301 	mov	w1, #0x18                  	// #24
 112ede8:	17fffffa 	b	112edd0 <rijndael_keysize+0x1c>
   *keysize = 32;
 112edec:	52800401 	mov	w1, #0x20                  	// #32
 112edf0:	17fffff8 	b	112edd0 <rijndael_keysize+0x1c>
   LTC_ARGCHK(keysize != NULL);
 112edf4:	52800200 	mov	w0, #0x10                  	// #16
 112edf8:	17fffff8 	b	112edd8 <rijndael_keysize+0x24>
      return CRYPT_INVALID_KEYSIZE;
 112edfc:	52800060 	mov	w0, #0x3                   	// #3
 112ee00:	17fffff6 	b	112edd8 <rijndael_keysize+0x24>

000000000112ee04 <rijndael_ecb_encrypt>:
{
 112ee04:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
 112ee08:	910003fd 	mov	x29, sp
 112ee0c:	a90153f3 	stp	x19, x20, [sp, #16]
 112ee10:	a9025bf5 	stp	x21, x22, [sp, #32]
 112ee14:	a90363f7 	stp	x23, x24, [sp, #48]
 112ee18:	a9046bf9 	stp	x25, x26, [sp, #64]
 112ee1c:	a90573fb 	stp	x27, x28, [sp, #80]
    LTC_ARGCHK(pt != NULL);
 112ee20:	b4001b60 	cbz	x0, 112f18c <rijndael_ecb_encrypt+0x388>
 112ee24:	aa0103f7 	mov	x23, x1
    LTC_ARGCHK(ct != NULL);
 112ee28:	b4001b21 	cbz	x1, 112f18c <rijndael_ecb_encrypt+0x388>
 112ee2c:	aa0203f5 	mov	x21, x2
    LTC_ARGCHK(skey != NULL);
 112ee30:	b4001ae2 	cbz	x2, 112f18c <rijndael_ecb_encrypt+0x388>
    Nr = skey->rijndael.Nr;
 112ee34:	b941e05c 	ldr	w28, [x2, #480]
    if (Nr < 2 || Nr > 16)
 112ee38:	51000b9c 	sub	w28, w28, #0x2
 112ee3c:	71003b9f 	cmp	w28, #0xe
 112ee40:	54001aa8 	b.hi	112f194 <rijndael_ecb_encrypt+0x390>  // b.pmore
 112ee44:	aa0003f3 	mov	x19, x0
    LOAD32H(s0, pt      ); s0 ^= rk[0];
 112ee48:	aa0003e1 	mov	x1, x0
 112ee4c:	d2800082 	mov	x2, #0x4                   	// #4
 112ee50:	9101b3e0 	add	x0, sp, #0x6c
 112ee54:	97ff514f 	bl	1103390 <memcpy>
 112ee58:	b9406ffb 	ldr	w27, [sp, #108]
 112ee5c:	b94002a0 	ldr	w0, [x21]
    LOAD32H(s1, pt  +  4); s1 ^= rk[1];
 112ee60:	d2800082 	mov	x2, #0x4                   	// #4
    LOAD32H(s0, pt      ); s0 ^= rk[0];
 112ee64:	5ac00b7b 	rev	w27, w27
    LOAD32H(s1, pt  +  4); s1 ^= rk[1];
 112ee68:	8b020261 	add	x1, x19, x2
    LOAD32H(s0, pt      ); s0 ^= rk[0];
 112ee6c:	4a00037b 	eor	w27, w27, w0
    LOAD32H(s1, pt  +  4); s1 ^= rk[1];
 112ee70:	9101c3e0 	add	x0, sp, #0x70
 112ee74:	97ff5147 	bl	1103390 <memcpy>
 112ee78:	b94073f4 	ldr	w20, [sp, #112]
 112ee7c:	b94006a0 	ldr	w0, [x21, #4]
    LOAD32H(s2, pt  +  8); s2 ^= rk[2];
 112ee80:	91002261 	add	x1, x19, #0x8
    LOAD32H(s1, pt  +  4); s1 ^= rk[1];
 112ee84:	5ac00a94 	rev	w20, w20
    LOAD32H(s2, pt  +  8); s2 ^= rk[2];
 112ee88:	d2800082 	mov	x2, #0x4                   	// #4
    LOAD32H(s1, pt  +  4); s1 ^= rk[1];
 112ee8c:	4a000294 	eor	w20, w20, w0
    LOAD32H(s2, pt  +  8); s2 ^= rk[2];
 112ee90:	9101d3e0 	add	x0, sp, #0x74
    LOAD32H(s1, pt  +  4); s1 ^= rk[1];
 112ee94:	b90073f4 	str	w20, [sp, #112]
    LOAD32H(s2, pt  +  8); s2 ^= rk[2];
 112ee98:	97ff513e 	bl	1103390 <memcpy>
 112ee9c:	b94077f6 	ldr	w22, [sp, #116]
    LOAD32H(s3, pt  + 12); s3 ^= rk[3];
 112eea0:	91003261 	add	x1, x19, #0xc
    LOAD32H(s2, pt  +  8); s2 ^= rk[2];
 112eea4:	b9400aa0 	ldr	w0, [x21, #8]
    LOAD32H(s3, pt  + 12); s3 ^= rk[3];
 112eea8:	d2800082 	mov	x2, #0x4                   	// #4
    LOAD32H(s2, pt  +  8); s2 ^= rk[2];
 112eeac:	5ac00ad6 	rev	w22, w22
 112eeb0:	4a0002d6 	eor	w22, w22, w0
    LOAD32H(s3, pt  + 12); s3 ^= rk[3];
 112eeb4:	9101e3e0 	add	x0, sp, #0x78
    LOAD32H(s2, pt  +  8); s2 ^= rk[2];
 112eeb8:	b90077f6 	str	w22, [sp, #116]
    LOAD32H(s3, pt  + 12); s3 ^= rk[3];
 112eebc:	97ff5135 	bl	1103390 <memcpy>
 112eec0:	b9407bf3 	ldr	w19, [sp, #120]
    rk = skey->rijndael.eK;
 112eec4:	aa1503e1 	mov	x1, x21
    LOAD32H(s3, pt  + 12); s3 ^= rk[3];
 112eec8:	b9400ea0 	ldr	w0, [x21, #12]
    for (r = 0; ; r++) {
 112eecc:	52800003 	mov	w3, #0x0                   	// #0
    LOAD32H(s3, pt  + 12); s3 ^= rk[3];
 112eed0:	5ac00a73 	rev	w19, w19
 112eed4:	4a000273 	eor	w19, w19, w0
            Te1(LTC_BYTE(s1, 2)) ^
 112eed8:	b0000100 	adrp	x0, 114f000 <SP7+0xd8>
 112eedc:	9116a000 	add	x0, x0, #0x5a8
    LOAD32H(s3, pt  + 12); s3 ^= rk[3];
 112eee0:	b9007bf3 	str	w19, [sp, #120]
            Te1(LTC_BYTE(s1, 2)) ^
 112eee4:	d3505e82 	ubfx	x2, x20, #16, #8
        t0 =
 112eee8:	b8410c24 	ldr	w4, [x1, #16]!
        if (r == Nr-2) {
 112eeec:	6b03039f 	cmp	w28, w3
        t0 =
 112eef0:	b862781a 	ldr	w26, [x0, x2, lsl #2]
            Te2(LTC_BYTE(s2, 1)) ^
 112eef4:	d3483ec2 	ubfx	x2, x22, #8, #8
        t0 =
 112eef8:	b8627802 	ldr	w2, [x0, x2, lsl #2]
 112eefc:	13824042 	ror	w2, w2, #16
 112ef00:	4ada205a 	eor	w26, w2, w26, ror #8
            Te0(LTC_BYTE(s0, 3)) ^
 112ef04:	53187f62 	lsr	w2, w27, #24
        t0 =
 112ef08:	b8627802 	ldr	w2, [x0, x2, lsl #2]
 112ef0c:	4a040042 	eor	w2, w2, w4
            Te3(LTC_BYTE(s3, 0)) ^
 112ef10:	92401e64 	and	x4, x19, #0xff
        t0 =
 112ef14:	4a020342 	eor	w2, w26, w2
 112ef18:	b864781a 	ldr	w26, [x0, x4, lsl #2]
        t1 =
 112ef1c:	b9400424 	ldr	w4, [x1, #4]
        t0 =
 112ef20:	4ada605a 	eor	w26, w2, w26, ror #24
            Te1(LTC_BYTE(s2, 2)) ^
 112ef24:	d3505ec2 	ubfx	x2, x22, #16, #8
        t1 =
 112ef28:	b8627819 	ldr	w25, [x0, x2, lsl #2]
            Te2(LTC_BYTE(s3, 1)) ^
 112ef2c:	d3483e62 	ubfx	x2, x19, #8, #8
        t1 =
 112ef30:	b8627802 	ldr	w2, [x0, x2, lsl #2]
 112ef34:	13824042 	ror	w2, w2, #16
 112ef38:	4ad92059 	eor	w25, w2, w25, ror #8
            Te0(LTC_BYTE(s1, 3)) ^
 112ef3c:	53187e82 	lsr	w2, w20, #24
        t1 =
 112ef40:	b8627802 	ldr	w2, [x0, x2, lsl #2]
 112ef44:	4a040042 	eor	w2, w2, w4
            Te3(LTC_BYTE(s0, 0)) ^
 112ef48:	92401f64 	and	x4, x27, #0xff
        t1 =
 112ef4c:	4a020322 	eor	w2, w25, w2
 112ef50:	b8647819 	ldr	w25, [x0, x4, lsl #2]
        t2 =
 112ef54:	b9400824 	ldr	w4, [x1, #8]
        t1 =
 112ef58:	4ad96059 	eor	w25, w2, w25, ror #24
            Te1(LTC_BYTE(s3, 2)) ^
 112ef5c:	d3505e62 	ubfx	x2, x19, #16, #8
            Te0(LTC_BYTE(s3, 3)) ^
 112ef60:	53187e73 	lsr	w19, w19, #24
        t2 =
 112ef64:	b8627818 	ldr	w24, [x0, x2, lsl #2]
            Te2(LTC_BYTE(s0, 1)) ^
 112ef68:	d3483f62 	ubfx	x2, x27, #8, #8
            Te1(LTC_BYTE(s0, 2)) ^
 112ef6c:	d3505f7b 	ubfx	x27, x27, #16, #8
        t3 =
 112ef70:	b8737813 	ldr	w19, [x0, x19, lsl #2]
        t2 =
 112ef74:	b8627802 	ldr	w2, [x0, x2, lsl #2]
 112ef78:	13824042 	ror	w2, w2, #16
 112ef7c:	4ad82058 	eor	w24, w2, w24, ror #8
            Te0(LTC_BYTE(s2, 3)) ^
 112ef80:	53187ec2 	lsr	w2, w22, #24
            Te3(LTC_BYTE(s2, 0)) ^
 112ef84:	92401ed6 	and	x22, x22, #0xff
        t2 =
 112ef88:	b8627802 	ldr	w2, [x0, x2, lsl #2]
 112ef8c:	4a040042 	eor	w2, w2, w4
            Te3(LTC_BYTE(s1, 0)) ^
 112ef90:	92401e84 	and	x4, x20, #0xff
            Te2(LTC_BYTE(s1, 1)) ^
 112ef94:	d3483e94 	ubfx	x20, x20, #8, #8
        t2 =
 112ef98:	4a020302 	eor	w2, w24, w2
 112ef9c:	b8647818 	ldr	w24, [x0, x4, lsl #2]
        t3 =
 112efa0:	b8747804 	ldr	w4, [x0, x20, lsl #2]
        t2 =
 112efa4:	4ad86058 	eor	w24, w2, w24, ror #24
        t3 =
 112efa8:	b87b7802 	ldr	w2, [x0, x27, lsl #2]
 112efac:	13844084 	ror	w4, w4, #16
 112efb0:	4ac22082 	eor	w2, w4, w2, ror #8
 112efb4:	b9400c24 	ldr	w4, [x1, #12]
 112efb8:	4a040273 	eor	w19, w19, w4
 112efbc:	4a130042 	eor	w2, w2, w19
 112efc0:	b8767813 	ldr	w19, [x0, x22, lsl #2]
 112efc4:	4ad36053 	eor	w19, w2, w19, ror #24
        if (r == Nr-2) {
 112efc8:	540000c0 	b.eq	112efe0 <rijndael_ecb_encrypt+0x1dc>  // b.none
    for (r = 0; ; r++) {
 112efcc:	11000463 	add	w3, w3, #0x1
        t2 =
 112efd0:	2a1803f6 	mov	w22, w24
        t1 =
 112efd4:	2a1903f4 	mov	w20, w25
        t0 =
 112efd8:	2a1a03fb 	mov	w27, w26
        rk += 4;
 112efdc:	17ffffc2 	b	112eee4 <rijndael_ecb_encrypt+0xe0>
        (Te4_2[LTC_BYTE(t1, 2)]) ^
 112efe0:	d3505f20 	ubfx	x0, x25, #16, #8
        (Te4_3[LTC_BYTE(t0, 3)]) ^
 112efe4:	53187f41 	lsr	w1, w26, #24
        (Te4_2[LTC_BYTE(t1, 2)]) ^
 112efe8:	b0000114 	adrp	x20, 114f000 <SP7+0xd8>
 112efec:	9136a294 	add	x20, x20, #0xda8
 112eff0:	8b3cd2b5 	add	x21, x21, w28, sxtw #4
    STORE32H(s0, ct);
 112eff4:	9101f3f6 	add	x22, sp, #0x7c
        (Te4_2[LTC_BYTE(t1, 2)]) ^
 112eff8:	b8607a80 	ldr	w0, [x20, x0, lsl #2]
        (Te4_3[LTC_BYTE(t0, 3)]) ^
 112effc:	b8617a81 	ldr	w1, [x20, x1, lsl #2]
        (Te4_2[LTC_BYTE(t1, 2)]) ^
 112f000:	12101c00 	and	w0, w0, #0xff0000
        (Te4_0[LTC_BYTE(t3, 0)]) ^
 112f004:	b94022a2 	ldr	w2, [x21, #32]
        (Te4_3[LTC_BYTE(t0, 3)]) ^
 112f008:	12081c21 	and	w1, w1, #0xff000000
 112f00c:	2a010000 	orr	w0, w0, w1
        (Te4_1[LTC_BYTE(t2, 1)]) ^
 112f010:	d3483f01 	ubfx	x1, x24, #8, #8
 112f014:	b8617a81 	ldr	w1, [x20, x1, lsl #2]
 112f018:	12181c21 	and	w1, w1, #0xff00
        (Te4_0[LTC_BYTE(t3, 0)]) ^
 112f01c:	4a010000 	eor	w0, w0, w1
 112f020:	92401e61 	and	x1, x19, #0xff
 112f024:	b8617a81 	ldr	w1, [x20, x1, lsl #2]
 112f028:	12001c21 	and	w1, w1, #0xff
 112f02c:	4a020021 	eor	w1, w1, w2
    STORE32H(s0, ct);
 112f030:	d2800082 	mov	x2, #0x4                   	// #4
        (Te4_0[LTC_BYTE(t3, 0)]) ^
 112f034:	4a010000 	eor	w0, w0, w1
    STORE32H(s0, ct);
 112f038:	aa1603e1 	mov	x1, x22
 112f03c:	5ac00800 	rev	w0, w0
 112f040:	b9007fe0 	str	w0, [sp, #124]
 112f044:	aa1703e0 	mov	x0, x23
 112f048:	97ff50d2 	bl	1103390 <memcpy>
        (Te4_2[LTC_BYTE(t2, 2)]) ^
 112f04c:	d3505f00 	ubfx	x0, x24, #16, #8
        (Te4_3[LTC_BYTE(t1, 3)]) ^
 112f050:	53187f21 	lsr	w1, w25, #24
        (Te4_0[LTC_BYTE(t0, 0)]) ^
 112f054:	b94026a2 	ldr	w2, [x21, #36]
        (Te4_2[LTC_BYTE(t2, 2)]) ^
 112f058:	b8607a80 	ldr	w0, [x20, x0, lsl #2]
        (Te4_3[LTC_BYTE(t1, 3)]) ^
 112f05c:	b8617a81 	ldr	w1, [x20, x1, lsl #2]
        (Te4_2[LTC_BYTE(t2, 2)]) ^
 112f060:	12101c00 	and	w0, w0, #0xff0000
        (Te4_3[LTC_BYTE(t1, 3)]) ^
 112f064:	12081c21 	and	w1, w1, #0xff000000
 112f068:	2a010000 	orr	w0, w0, w1
        (Te4_1[LTC_BYTE(t3, 1)]) ^
 112f06c:	d3483e61 	ubfx	x1, x19, #8, #8
 112f070:	b8617a81 	ldr	w1, [x20, x1, lsl #2]
 112f074:	12181c21 	and	w1, w1, #0xff00
        (Te4_0[LTC_BYTE(t0, 0)]) ^
 112f078:	4a010000 	eor	w0, w0, w1
 112f07c:	92401f41 	and	x1, x26, #0xff
 112f080:	b8617a81 	ldr	w1, [x20, x1, lsl #2]
 112f084:	12001c21 	and	w1, w1, #0xff
 112f088:	4a020021 	eor	w1, w1, w2
    STORE32H(s1, ct+4);
 112f08c:	d2800082 	mov	x2, #0x4                   	// #4
        (Te4_0[LTC_BYTE(t0, 0)]) ^
 112f090:	4a010000 	eor	w0, w0, w1
    STORE32H(s1, ct+4);
 112f094:	aa1603e1 	mov	x1, x22
 112f098:	5ac00800 	rev	w0, w0
 112f09c:	b9007fe0 	str	w0, [sp, #124]
 112f0a0:	8b0202e0 	add	x0, x23, x2
 112f0a4:	97ff50bb 	bl	1103390 <memcpy>
        (Te4_2[LTC_BYTE(t3, 2)]) ^
 112f0a8:	d3505e60 	ubfx	x0, x19, #16, #8
        (Te4_3[LTC_BYTE(t2, 3)]) ^
 112f0ac:	53187f01 	lsr	w1, w24, #24
        (Te4_0[LTC_BYTE(t1, 0)]) ^
 112f0b0:	b9402aa2 	ldr	w2, [x21, #40]
        (Te4_3[LTC_BYTE(t3, 3)]) ^
 112f0b4:	53187e73 	lsr	w19, w19, #24
        (Te4_0[LTC_BYTE(t2, 0)]) ^
 112f0b8:	92401f18 	and	x24, x24, #0xff
        (Te4_2[LTC_BYTE(t3, 2)]) ^
 112f0bc:	b8607a80 	ldr	w0, [x20, x0, lsl #2]
        (Te4_3[LTC_BYTE(t2, 3)]) ^
 112f0c0:	b8617a81 	ldr	w1, [x20, x1, lsl #2]
        (Te4_2[LTC_BYTE(t3, 2)]) ^
 112f0c4:	12101c00 	and	w0, w0, #0xff0000
        (Te4_3[LTC_BYTE(t2, 3)]) ^
 112f0c8:	12081c21 	and	w1, w1, #0xff000000
 112f0cc:	2a010000 	orr	w0, w0, w1
        (Te4_1[LTC_BYTE(t0, 1)]) ^
 112f0d0:	d3483f41 	ubfx	x1, x26, #8, #8
        (Te4_2[LTC_BYTE(t0, 2)]) ^
 112f0d4:	d3505f5a 	ubfx	x26, x26, #16, #8
        (Te4_1[LTC_BYTE(t0, 1)]) ^
 112f0d8:	b8617a81 	ldr	w1, [x20, x1, lsl #2]
 112f0dc:	12181c21 	and	w1, w1, #0xff00
        (Te4_0[LTC_BYTE(t1, 0)]) ^
 112f0e0:	4a010000 	eor	w0, w0, w1
 112f0e4:	92401f21 	and	x1, x25, #0xff
        (Te4_1[LTC_BYTE(t1, 1)]) ^
 112f0e8:	d3483f39 	ubfx	x25, x25, #8, #8
        (Te4_0[LTC_BYTE(t1, 0)]) ^
 112f0ec:	b8617a81 	ldr	w1, [x20, x1, lsl #2]
 112f0f0:	12001c21 	and	w1, w1, #0xff
 112f0f4:	4a020021 	eor	w1, w1, w2
    STORE32H(s2, ct+8);
 112f0f8:	d2800082 	mov	x2, #0x4                   	// #4
        (Te4_0[LTC_BYTE(t1, 0)]) ^
 112f0fc:	4a010000 	eor	w0, w0, w1
    STORE32H(s2, ct+8);
 112f100:	aa1603e1 	mov	x1, x22
 112f104:	5ac00800 	rev	w0, w0
 112f108:	b9007fe0 	str	w0, [sp, #124]
 112f10c:	910022e0 	add	x0, x23, #0x8
 112f110:	97ff50a0 	bl	1103390 <memcpy>
        (Te4_3[LTC_BYTE(t3, 3)]) ^
 112f114:	b8737a81 	ldr	w1, [x20, x19, lsl #2]
    return CRYPT_OK;
 112f118:	52800013 	mov	w19, #0x0                   	// #0
        (Te4_2[LTC_BYTE(t0, 2)]) ^
 112f11c:	b87a7a80 	ldr	w0, [x20, x26, lsl #2]
        (Te4_3[LTC_BYTE(t3, 3)]) ^
 112f120:	12081c21 	and	w1, w1, #0xff000000
        (Te4_0[LTC_BYTE(t2, 0)]) ^
 112f124:	b9402ea2 	ldr	w2, [x21, #44]
        (Te4_2[LTC_BYTE(t0, 2)]) ^
 112f128:	12101c00 	and	w0, w0, #0xff0000
        (Te4_3[LTC_BYTE(t3, 3)]) ^
 112f12c:	2a010000 	orr	w0, w0, w1
        (Te4_1[LTC_BYTE(t1, 1)]) ^
 112f130:	b8797a81 	ldr	w1, [x20, x25, lsl #2]
 112f134:	12181c21 	and	w1, w1, #0xff00
        (Te4_0[LTC_BYTE(t2, 0)]) ^
 112f138:	4a010000 	eor	w0, w0, w1
 112f13c:	b8787a81 	ldr	w1, [x20, x24, lsl #2]
 112f140:	12001c21 	and	w1, w1, #0xff
 112f144:	4a020021 	eor	w1, w1, w2
    STORE32H(s3, ct+12);
 112f148:	d2800082 	mov	x2, #0x4                   	// #4
        (Te4_0[LTC_BYTE(t2, 0)]) ^
 112f14c:	4a010000 	eor	w0, w0, w1
    STORE32H(s3, ct+12);
 112f150:	aa1603e1 	mov	x1, x22
 112f154:	5ac00800 	rev	w0, w0
 112f158:	b9007fe0 	str	w0, [sp, #124]
 112f15c:	910032e0 	add	x0, x23, #0xc
 112f160:	97ff508c 	bl	1103390 <memcpy>
   burn_stack(sizeof(unsigned long)*8 + sizeof(unsigned long*) + sizeof(int)*2);
 112f164:	d2800a00 	mov	x0, #0x50                  	// #80
 112f168:	94000cac 	bl	1132418 <burn_stack>
}
 112f16c:	2a1303e0 	mov	w0, w19
 112f170:	a94153f3 	ldp	x19, x20, [sp, #16]
 112f174:	a9425bf5 	ldp	x21, x22, [sp, #32]
 112f178:	a94363f7 	ldp	x23, x24, [sp, #48]
 112f17c:	a9446bf9 	ldp	x25, x26, [sp, #64]
 112f180:	a94573fb 	ldp	x27, x28, [sp, #80]
 112f184:	a8c87bfd 	ldp	x29, x30, [sp], #128
 112f188:	d65f03c0 	ret
    LTC_ARGCHK(pt != NULL);
 112f18c:	52800213 	mov	w19, #0x10                  	// #16
 112f190:	17fffff5 	b	112f164 <rijndael_ecb_encrypt+0x360>
        return CRYPT_INVALID_ROUNDS;
 112f194:	52800093 	mov	w19, #0x4                   	// #4
 112f198:	17fffff3 	b	112f164 <rijndael_ecb_encrypt+0x360>

000000000112f19c <rijndael_ecb_decrypt>:
{
 112f19c:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
 112f1a0:	910003fd 	mov	x29, sp
 112f1a4:	a90153f3 	stp	x19, x20, [sp, #16]
 112f1a8:	a9025bf5 	stp	x21, x22, [sp, #32]
 112f1ac:	a90363f7 	stp	x23, x24, [sp, #48]
 112f1b0:	a9046bf9 	stp	x25, x26, [sp, #64]
 112f1b4:	a90573fb 	stp	x27, x28, [sp, #80]
    LTC_ARGCHK(pt != NULL);
 112f1b8:	b4001b81 	cbz	x1, 112f528 <rijndael_ecb_decrypt+0x38c>
 112f1bc:	aa0003f3 	mov	x19, x0
    LTC_ARGCHK(ct != NULL);
 112f1c0:	b4001b40 	cbz	x0, 112f528 <rijndael_ecb_decrypt+0x38c>
 112f1c4:	aa0203f8 	mov	x24, x2
    LTC_ARGCHK(skey != NULL);
 112f1c8:	b4001b02 	cbz	x2, 112f528 <rijndael_ecb_decrypt+0x38c>
    Nr = skey->rijndael.Nr;
 112f1cc:	b941e055 	ldr	w21, [x2, #480]
    if (Nr < 2 || Nr > 16)
 112f1d0:	51000ab5 	sub	w21, w21, #0x2
 112f1d4:	71003abf 	cmp	w21, #0xe
 112f1d8:	54001ac8 	b.hi	112f530 <rijndael_ecb_decrypt+0x394>  // b.pmore
    rk = skey->rijndael.dK;
 112f1dc:	9103c05c 	add	x28, x2, #0xf0
 112f1e0:	aa0103f7 	mov	x23, x1
    LOAD32H(s0, ct      ); s0 ^= rk[0];
 112f1e4:	d2800082 	mov	x2, #0x4                   	// #4
 112f1e8:	aa0003e1 	mov	x1, x0
 112f1ec:	9101b3e0 	add	x0, sp, #0x6c
 112f1f0:	97ff5068 	bl	1103390 <memcpy>
 112f1f4:	b9406ffb 	ldr	w27, [sp, #108]
    LOAD32H(s1, ct  +  4); s1 ^= rk[1];
 112f1f8:	d2800082 	mov	x2, #0x4                   	// #4
    LOAD32H(s0, ct      ); s0 ^= rk[0];
 112f1fc:	b940f300 	ldr	w0, [x24, #240]
    LOAD32H(s1, ct  +  4); s1 ^= rk[1];
 112f200:	8b020261 	add	x1, x19, x2
    LOAD32H(s0, ct      ); s0 ^= rk[0];
 112f204:	5ac00b7b 	rev	w27, w27
 112f208:	4a00037b 	eor	w27, w27, w0
    LOAD32H(s1, ct  +  4); s1 ^= rk[1];
 112f20c:	9101c3e0 	add	x0, sp, #0x70
 112f210:	97ff5060 	bl	1103390 <memcpy>
 112f214:	b94073f6 	ldr	w22, [sp, #112]
 112f218:	b940f700 	ldr	w0, [x24, #244]
    LOAD32H(s2, ct  +  8); s2 ^= rk[2];
 112f21c:	91002261 	add	x1, x19, #0x8
    LOAD32H(s1, ct  +  4); s1 ^= rk[1];
 112f220:	5ac00ad6 	rev	w22, w22
    LOAD32H(s2, ct  +  8); s2 ^= rk[2];
 112f224:	d2800082 	mov	x2, #0x4                   	// #4
    LOAD32H(s1, ct  +  4); s1 ^= rk[1];
 112f228:	4a0002d6 	eor	w22, w22, w0
    LOAD32H(s2, ct  +  8); s2 ^= rk[2];
 112f22c:	9101d3e0 	add	x0, sp, #0x74
    LOAD32H(s1, ct  +  4); s1 ^= rk[1];
 112f230:	b90073f6 	str	w22, [sp, #112]
    LOAD32H(s2, ct  +  8); s2 ^= rk[2];
 112f234:	97ff5057 	bl	1103390 <memcpy>
 112f238:	b94077f4 	ldr	w20, [sp, #116]
    LOAD32H(s3, ct  + 12); s3 ^= rk[3];
 112f23c:	91003261 	add	x1, x19, #0xc
    LOAD32H(s2, ct  +  8); s2 ^= rk[2];
 112f240:	b940fb00 	ldr	w0, [x24, #248]
    LOAD32H(s3, ct  + 12); s3 ^= rk[3];
 112f244:	d2800082 	mov	x2, #0x4                   	// #4
    LOAD32H(s2, ct  +  8); s2 ^= rk[2];
 112f248:	5ac00a94 	rev	w20, w20
 112f24c:	4a000294 	eor	w20, w20, w0
    LOAD32H(s3, ct  + 12); s3 ^= rk[3];
 112f250:	9101e3e0 	add	x0, sp, #0x78
    LOAD32H(s2, ct  +  8); s2 ^= rk[2];
 112f254:	b90077f4 	str	w20, [sp, #116]
    LOAD32H(s3, ct  + 12); s3 ^= rk[3];
 112f258:	97ff504e 	bl	1103390 <memcpy>
 112f25c:	b9407bf3 	ldr	w19, [sp, #120]
    rk = skey->rijndael.dK;
 112f260:	aa1c03e1 	mov	x1, x28
    LOAD32H(s3, ct  + 12); s3 ^= rk[3];
 112f264:	b940ff00 	ldr	w0, [x24, #252]
    for (r = 0; ; r++) {
 112f268:	52800003 	mov	w3, #0x0                   	// #0
    LOAD32H(s3, ct  + 12); s3 ^= rk[3];
 112f26c:	5ac00a73 	rev	w19, w19
 112f270:	4a000273 	eor	w19, w19, w0
            Td1(LTC_BYTE(s3, 2)) ^
 112f274:	90000100 	adrp	x0, 114f000 <SP7+0xd8>
 112f278:	9106a000 	add	x0, x0, #0x1a8
    LOAD32H(s3, ct  + 12); s3 ^= rk[3];
 112f27c:	b9007bf3 	str	w19, [sp, #120]
            Td1(LTC_BYTE(s3, 2)) ^
 112f280:	d3505e62 	ubfx	x2, x19, #16, #8
        t0 =
 112f284:	b8410c24 	ldr	w4, [x1, #16]!
        if (r == Nr-2) {
 112f288:	6b0302bf 	cmp	w21, w3
        t0 =
 112f28c:	b8627818 	ldr	w24, [x0, x2, lsl #2]
            Td2(LTC_BYTE(s2, 1)) ^
 112f290:	d3483e82 	ubfx	x2, x20, #8, #8
        t0 =
 112f294:	b8627802 	ldr	w2, [x0, x2, lsl #2]
 112f298:	13824042 	ror	w2, w2, #16
 112f29c:	4ad82058 	eor	w24, w2, w24, ror #8
            Td0(LTC_BYTE(s0, 3)) ^
 112f2a0:	53187f62 	lsr	w2, w27, #24
        t0 =
 112f2a4:	b8627802 	ldr	w2, [x0, x2, lsl #2]
 112f2a8:	4a040042 	eor	w2, w2, w4
            Td3(LTC_BYTE(s1, 0)) ^
 112f2ac:	92401ec4 	and	x4, x22, #0xff
        t0 =
 112f2b0:	4a020302 	eor	w2, w24, w2
 112f2b4:	b8647818 	ldr	w24, [x0, x4, lsl #2]
        t1 =
 112f2b8:	b9400424 	ldr	w4, [x1, #4]
        t0 =
 112f2bc:	4ad86058 	eor	w24, w2, w24, ror #24
            Td1(LTC_BYTE(s0, 2)) ^
 112f2c0:	d3505f62 	ubfx	x2, x27, #16, #8
        t1 =
 112f2c4:	b8627819 	ldr	w25, [x0, x2, lsl #2]
            Td2(LTC_BYTE(s3, 1)) ^
 112f2c8:	d3483e62 	ubfx	x2, x19, #8, #8
        t1 =
 112f2cc:	b8627802 	ldr	w2, [x0, x2, lsl #2]
 112f2d0:	13824042 	ror	w2, w2, #16
 112f2d4:	4ad92059 	eor	w25, w2, w25, ror #8
            Td0(LTC_BYTE(s1, 3)) ^
 112f2d8:	53187ec2 	lsr	w2, w22, #24
        t1 =
 112f2dc:	b8627802 	ldr	w2, [x0, x2, lsl #2]
 112f2e0:	4a040042 	eor	w2, w2, w4
            Td3(LTC_BYTE(s2, 0)) ^
 112f2e4:	92401e84 	and	x4, x20, #0xff
        t1 =
 112f2e8:	4a020322 	eor	w2, w25, w2
 112f2ec:	b8647819 	ldr	w25, [x0, x4, lsl #2]
        t2 =
 112f2f0:	b9400824 	ldr	w4, [x1, #8]
        t1 =
 112f2f4:	4ad96059 	eor	w25, w2, w25, ror #24
            Td1(LTC_BYTE(s1, 2)) ^
 112f2f8:	d3505ec2 	ubfx	x2, x22, #16, #8
            Td2(LTC_BYTE(s1, 1)) ^
 112f2fc:	d3483ed6 	ubfx	x22, x22, #8, #8
        t2 =
 112f300:	b862781a 	ldr	w26, [x0, x2, lsl #2]
            Td2(LTC_BYTE(s0, 1)) ^
 112f304:	d3483f62 	ubfx	x2, x27, #8, #8
            Td3(LTC_BYTE(s0, 0)) ^
 112f308:	92401f7b 	and	x27, x27, #0xff
        t2 =
 112f30c:	b8627802 	ldr	w2, [x0, x2, lsl #2]
 112f310:	13824042 	ror	w2, w2, #16
 112f314:	4ada205a 	eor	w26, w2, w26, ror #8
            Td0(LTC_BYTE(s2, 3)) ^
 112f318:	53187e82 	lsr	w2, w20, #24
            Td1(LTC_BYTE(s2, 2)) ^
 112f31c:	d3505e94 	ubfx	x20, x20, #16, #8
        t2 =
 112f320:	b8627802 	ldr	w2, [x0, x2, lsl #2]
 112f324:	4a040042 	eor	w2, w2, w4
            Td3(LTC_BYTE(s3, 0)) ^
 112f328:	92401e64 	and	x4, x19, #0xff
        t2 =
 112f32c:	4a020342 	eor	w2, w26, w2
            Td0(LTC_BYTE(s3, 3)) ^
 112f330:	53187e73 	lsr	w19, w19, #24
        t2 =
 112f334:	b864781a 	ldr	w26, [x0, x4, lsl #2]
        t3 =
 112f338:	b8767804 	ldr	w4, [x0, x22, lsl #2]
 112f33c:	b8737813 	ldr	w19, [x0, x19, lsl #2]
        t2 =
 112f340:	4ada605a 	eor	w26, w2, w26, ror #24
        t3 =
 112f344:	b8747802 	ldr	w2, [x0, x20, lsl #2]
 112f348:	13844084 	ror	w4, w4, #16
 112f34c:	4ac22082 	eor	w2, w4, w2, ror #8
 112f350:	b9400c24 	ldr	w4, [x1, #12]
 112f354:	4a040273 	eor	w19, w19, w4
 112f358:	4a130042 	eor	w2, w2, w19
 112f35c:	b87b7813 	ldr	w19, [x0, x27, lsl #2]
 112f360:	4ad36053 	eor	w19, w2, w19, ror #24
        if (r == Nr-2) {
 112f364:	540000c0 	b.eq	112f37c <rijndael_ecb_decrypt+0x1e0>  // b.none
    for (r = 0; ; r++) {
 112f368:	11000463 	add	w3, w3, #0x1
        t1 =
 112f36c:	2a1903f6 	mov	w22, w25
        t2 =
 112f370:	2a1a03f4 	mov	w20, w26
        t0 =
 112f374:	2a1803fb 	mov	w27, w24
        rk += 4;
 112f378:	17ffffc2 	b	112f280 <rijndael_ecb_decrypt+0xe4>
        (Td4[LTC_BYTE(t3, 2)] & 0x00ff0000) ^
 112f37c:	d3505e60 	ubfx	x0, x19, #16, #8
        (Td4[LTC_BYTE(t0, 3)] & 0xff000000) ^
 112f380:	53187f01 	lsr	w1, w24, #24
        (Td4[LTC_BYTE(t3, 2)] & 0x00ff0000) ^
 112f384:	90000114 	adrp	x20, 114f000 <SP7+0xd8>
 112f388:	9126a294 	add	x20, x20, #0x9a8
 112f38c:	8b35d395 	add	x21, x28, w21, sxtw #4
    STORE32H(s0, pt);
 112f390:	9101f3f6 	add	x22, sp, #0x7c
        (Td4[LTC_BYTE(t3, 2)] & 0x00ff0000) ^
 112f394:	b8607a80 	ldr	w0, [x20, x0, lsl #2]
        (Td4[LTC_BYTE(t0, 3)] & 0xff000000) ^
 112f398:	b8617a81 	ldr	w1, [x20, x1, lsl #2]
        (Td4[LTC_BYTE(t3, 2)] & 0x00ff0000) ^
 112f39c:	12101c00 	and	w0, w0, #0xff0000
        (Td4[LTC_BYTE(t1, 0)] & 0x000000ff) ^
 112f3a0:	b94022a2 	ldr	w2, [x21, #32]
        (Td4[LTC_BYTE(t0, 3)] & 0xff000000) ^
 112f3a4:	12081c21 	and	w1, w1, #0xff000000
 112f3a8:	2a010000 	orr	w0, w0, w1
        (Td4[LTC_BYTE(t2, 1)] & 0x0000ff00) ^
 112f3ac:	d3483f41 	ubfx	x1, x26, #8, #8
 112f3b0:	b8617a81 	ldr	w1, [x20, x1, lsl #2]
 112f3b4:	12181c21 	and	w1, w1, #0xff00
        (Td4[LTC_BYTE(t1, 0)] & 0x000000ff) ^
 112f3b8:	4a010000 	eor	w0, w0, w1
 112f3bc:	92401f21 	and	x1, x25, #0xff
 112f3c0:	b8617a81 	ldr	w1, [x20, x1, lsl #2]
 112f3c4:	12001c21 	and	w1, w1, #0xff
 112f3c8:	4a020021 	eor	w1, w1, w2
    STORE32H(s0, pt);
 112f3cc:	d2800082 	mov	x2, #0x4                   	// #4
        (Td4[LTC_BYTE(t1, 0)] & 0x000000ff) ^
 112f3d0:	4a010000 	eor	w0, w0, w1
    STORE32H(s0, pt);
 112f3d4:	aa1603e1 	mov	x1, x22
 112f3d8:	5ac00800 	rev	w0, w0
 112f3dc:	b9007fe0 	str	w0, [sp, #124]
 112f3e0:	aa1703e0 	mov	x0, x23
 112f3e4:	97ff4feb 	bl	1103390 <memcpy>
        (Td4[LTC_BYTE(t0, 2)] & 0x00ff0000) ^
 112f3e8:	d3505f00 	ubfx	x0, x24, #16, #8
        (Td4[LTC_BYTE(t1, 3)] & 0xff000000) ^
 112f3ec:	53187f21 	lsr	w1, w25, #24
        (Td4[LTC_BYTE(t2, 0)] & 0x000000ff) ^
 112f3f0:	b94026a2 	ldr	w2, [x21, #36]
        (Td4[LTC_BYTE(t0, 2)] & 0x00ff0000) ^
 112f3f4:	b8607a80 	ldr	w0, [x20, x0, lsl #2]
        (Td4[LTC_BYTE(t1, 3)] & 0xff000000) ^
 112f3f8:	b8617a81 	ldr	w1, [x20, x1, lsl #2]
        (Td4[LTC_BYTE(t0, 2)] & 0x00ff0000) ^
 112f3fc:	12101c00 	and	w0, w0, #0xff0000
        (Td4[LTC_BYTE(t1, 3)] & 0xff000000) ^
 112f400:	12081c21 	and	w1, w1, #0xff000000
 112f404:	2a010000 	orr	w0, w0, w1
        (Td4[LTC_BYTE(t3, 1)] & 0x0000ff00) ^
 112f408:	d3483e61 	ubfx	x1, x19, #8, #8
 112f40c:	b8617a81 	ldr	w1, [x20, x1, lsl #2]
 112f410:	12181c21 	and	w1, w1, #0xff00
        (Td4[LTC_BYTE(t2, 0)] & 0x000000ff) ^
 112f414:	4a010000 	eor	w0, w0, w1
 112f418:	92401f41 	and	x1, x26, #0xff
 112f41c:	b8617a81 	ldr	w1, [x20, x1, lsl #2]
 112f420:	12001c21 	and	w1, w1, #0xff
 112f424:	4a020021 	eor	w1, w1, w2
    STORE32H(s1, pt+4);
 112f428:	d2800082 	mov	x2, #0x4                   	// #4
        (Td4[LTC_BYTE(t2, 0)] & 0x000000ff) ^
 112f42c:	4a010000 	eor	w0, w0, w1
    STORE32H(s1, pt+4);
 112f430:	aa1603e1 	mov	x1, x22
 112f434:	5ac00800 	rev	w0, w0
 112f438:	b9007fe0 	str	w0, [sp, #124]
 112f43c:	8b0202e0 	add	x0, x23, x2
 112f440:	97ff4fd4 	bl	1103390 <memcpy>
        (Td4[LTC_BYTE(t1, 2)] & 0x00ff0000) ^
 112f444:	d3505f20 	ubfx	x0, x25, #16, #8
        (Td4[LTC_BYTE(t2, 3)] & 0xff000000) ^
 112f448:	53187f41 	lsr	w1, w26, #24
        (Td4[LTC_BYTE(t3, 0)] & 0x000000ff) ^
 112f44c:	b9402aa2 	ldr	w2, [x21, #40]
        (Td4[LTC_BYTE(t2, 2)] & 0x00ff0000) ^
 112f450:	d3505f5a 	ubfx	x26, x26, #16, #8
        (Td4[LTC_BYTE(t1, 1)] & 0x0000ff00) ^
 112f454:	d3483f39 	ubfx	x25, x25, #8, #8
        (Td4[LTC_BYTE(t1, 2)] & 0x00ff0000) ^
 112f458:	b8607a80 	ldr	w0, [x20, x0, lsl #2]
        (Td4[LTC_BYTE(t2, 3)] & 0xff000000) ^
 112f45c:	b8617a81 	ldr	w1, [x20, x1, lsl #2]
        (Td4[LTC_BYTE(t1, 2)] & 0x00ff0000) ^
 112f460:	12101c00 	and	w0, w0, #0xff0000
        (Td4[LTC_BYTE(t2, 3)] & 0xff000000) ^
 112f464:	12081c21 	and	w1, w1, #0xff000000
 112f468:	2a010000 	orr	w0, w0, w1
        (Td4[LTC_BYTE(t0, 1)] & 0x0000ff00) ^
 112f46c:	d3483f01 	ubfx	x1, x24, #8, #8
        (Td4[LTC_BYTE(t0, 0)] & 0x000000ff) ^
 112f470:	92401f18 	and	x24, x24, #0xff
        (Td4[LTC_BYTE(t0, 1)] & 0x0000ff00) ^
 112f474:	b8617a81 	ldr	w1, [x20, x1, lsl #2]
 112f478:	12181c21 	and	w1, w1, #0xff00
        (Td4[LTC_BYTE(t3, 0)] & 0x000000ff) ^
 112f47c:	4a010000 	eor	w0, w0, w1
 112f480:	92401e61 	and	x1, x19, #0xff
        (Td4[LTC_BYTE(t3, 3)] & 0xff000000) ^
 112f484:	53187e73 	lsr	w19, w19, #24
        (Td4[LTC_BYTE(t3, 0)] & 0x000000ff) ^
 112f488:	b8617a81 	ldr	w1, [x20, x1, lsl #2]
 112f48c:	12001c21 	and	w1, w1, #0xff
 112f490:	4a020021 	eor	w1, w1, w2
    STORE32H(s2, pt+8);
 112f494:	d2800082 	mov	x2, #0x4                   	// #4
        (Td4[LTC_BYTE(t3, 0)] & 0x000000ff) ^
 112f498:	4a010000 	eor	w0, w0, w1
    STORE32H(s2, pt+8);
 112f49c:	aa1603e1 	mov	x1, x22
 112f4a0:	5ac00800 	rev	w0, w0
 112f4a4:	b9007fe0 	str	w0, [sp, #124]
 112f4a8:	910022e0 	add	x0, x23, #0x8
 112f4ac:	97ff4fb9 	bl	1103390 <memcpy>
        (Td4[LTC_BYTE(t3, 3)] & 0xff000000) ^
 112f4b0:	b8737a81 	ldr	w1, [x20, x19, lsl #2]
    return CRYPT_OK;
 112f4b4:	52800013 	mov	w19, #0x0                   	// #0
        (Td4[LTC_BYTE(t2, 2)] & 0x00ff0000) ^
 112f4b8:	b87a7a80 	ldr	w0, [x20, x26, lsl #2]
        (Td4[LTC_BYTE(t3, 3)] & 0xff000000) ^
 112f4bc:	12081c21 	and	w1, w1, #0xff000000
        (Td4[LTC_BYTE(t0, 0)] & 0x000000ff) ^
 112f4c0:	b9402ea2 	ldr	w2, [x21, #44]
        (Td4[LTC_BYTE(t2, 2)] & 0x00ff0000) ^
 112f4c4:	12101c00 	and	w0, w0, #0xff0000
        (Td4[LTC_BYTE(t3, 3)] & 0xff000000) ^
 112f4c8:	2a010000 	orr	w0, w0, w1
        (Td4[LTC_BYTE(t1, 1)] & 0x0000ff00) ^
 112f4cc:	b8797a81 	ldr	w1, [x20, x25, lsl #2]
 112f4d0:	12181c21 	and	w1, w1, #0xff00
        (Td4[LTC_BYTE(t0, 0)] & 0x000000ff) ^
 112f4d4:	4a010000 	eor	w0, w0, w1
 112f4d8:	b8787a81 	ldr	w1, [x20, x24, lsl #2]
 112f4dc:	12001c21 	and	w1, w1, #0xff
 112f4e0:	4a020021 	eor	w1, w1, w2
    STORE32H(s3, pt+12);
 112f4e4:	d2800082 	mov	x2, #0x4                   	// #4
        (Td4[LTC_BYTE(t0, 0)] & 0x000000ff) ^
 112f4e8:	4a010000 	eor	w0, w0, w1
    STORE32H(s3, pt+12);
 112f4ec:	aa1603e1 	mov	x1, x22
 112f4f0:	5ac00800 	rev	w0, w0
 112f4f4:	b9007fe0 	str	w0, [sp, #124]
 112f4f8:	910032e0 	add	x0, x23, #0xc
 112f4fc:	97ff4fa5 	bl	1103390 <memcpy>
   burn_stack(sizeof(unsigned long)*8 + sizeof(unsigned long*) + sizeof(int)*2);
 112f500:	d2800a00 	mov	x0, #0x50                  	// #80
 112f504:	94000bc5 	bl	1132418 <burn_stack>
}
 112f508:	2a1303e0 	mov	w0, w19
 112f50c:	a94153f3 	ldp	x19, x20, [sp, #16]
 112f510:	a9425bf5 	ldp	x21, x22, [sp, #32]
 112f514:	a94363f7 	ldp	x23, x24, [sp, #48]
 112f518:	a9446bf9 	ldp	x25, x26, [sp, #64]
 112f51c:	a94573fb 	ldp	x27, x28, [sp, #80]
 112f520:	a8c87bfd 	ldp	x29, x30, [sp], #128
 112f524:	d65f03c0 	ret
    LTC_ARGCHK(pt != NULL);
 112f528:	52800213 	mov	w19, #0x10                  	// #16
 112f52c:	17fffff5 	b	112f500 <rijndael_ecb_decrypt+0x364>
        return CRYPT_INVALID_ROUNDS;
 112f530:	52800093 	mov	w19, #0x4                   	// #4
 112f534:	17fffff3 	b	112f500 <rijndael_ecb_decrypt+0x364>

000000000112f538 <rijndael_setup>:
    LTC_ARGCHK(key  != NULL);
 112f538:	b4001d40 	cbz	x0, 112f8e0 <rijndael_setup+0x3a8>
{
 112f53c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 112f540:	910003fd 	mov	x29, sp
 112f544:	a90153f3 	stp	x19, x20, [sp, #16]
 112f548:	aa0303f3 	mov	x19, x3
 112f54c:	f90013f5 	str	x21, [sp, #32]
    LTC_ARGCHK(skey != NULL);
 112f550:	b4001cc3 	cbz	x3, 112f8e8 <rijndael_setup+0x3b0>
 112f554:	aa0003f5 	mov	x21, x0
    if (keylen != 16 && keylen != 24 && keylen != 32) {
 112f558:	121c7820 	and	w0, w1, #0xfffffff7
 112f55c:	2a0103f4 	mov	w20, w1
 112f560:	7100401f 	cmp	w0, #0x10
 112f564:	54000060 	b.eq	112f570 <rijndael_setup+0x38>  // b.none
 112f568:	7100803f 	cmp	w1, #0x20
 112f56c:	54001c21 	b.ne	112f8f0 <rijndael_setup+0x3b8>  // b.any
    if (num_rounds != 0 && num_rounds != (10 + ((keylen/8)-2)*2)) {
 112f570:	52800100 	mov	w0, #0x8                   	// #8
 112f574:	1ac00e80 	sdiv	w0, w20, w0
 112f578:	11000c00 	add	w0, w0, #0x3
 112f57c:	531f7800 	lsl	w0, w0, #1
 112f580:	34000062 	cbz	w2, 112f58c <rijndael_setup+0x54>
 112f584:	6b00005f 	cmp	w2, w0
 112f588:	54001b81 	b.ne	112f8f8 <rijndael_setup+0x3c0>  // b.any
    skey->rijndael.Nr = 10 + ((keylen/8)-2)*2;
 112f58c:	b901e260 	str	w0, [x19, #480]
    LOAD32H(rk[0], key     );
 112f590:	aa1503e1 	mov	x1, x21
 112f594:	d2800082 	mov	x2, #0x4                   	// #4
 112f598:	aa1303e0 	mov	x0, x19
 112f59c:	97ff4f7d 	bl	1103390 <memcpy>
 112f5a0:	aa1303e0 	mov	x0, x19
 112f5a4:	b9400261 	ldr	w1, [x19]
    LOAD32H(rk[1], key +  4);
 112f5a8:	d2800082 	mov	x2, #0x4                   	// #4
    LOAD32H(rk[0], key     );
 112f5ac:	5ac00821 	rev	w1, w1
 112f5b0:	b8004401 	str	w1, [x0], #4
    LOAD32H(rk[1], key +  4);
 112f5b4:	8b0202a1 	add	x1, x21, x2
 112f5b8:	97ff4f76 	bl	1103390 <memcpy>
 112f5bc:	b9400660 	ldr	w0, [x19, #4]
    LOAD32H(rk[2], key +  8);
 112f5c0:	910022a1 	add	x1, x21, #0x8
 112f5c4:	d2800082 	mov	x2, #0x4                   	// #4
    LOAD32H(rk[1], key +  4);
 112f5c8:	5ac00800 	rev	w0, w0
 112f5cc:	b9000660 	str	w0, [x19, #4]
    LOAD32H(rk[2], key +  8);
 112f5d0:	91002260 	add	x0, x19, #0x8
 112f5d4:	97ff4f6f 	bl	1103390 <memcpy>
 112f5d8:	b9400a60 	ldr	w0, [x19, #8]
    LOAD32H(rk[3], key + 12);
 112f5dc:	910032a1 	add	x1, x21, #0xc
 112f5e0:	d2800082 	mov	x2, #0x4                   	// #4
    LOAD32H(rk[2], key +  8);
 112f5e4:	5ac00800 	rev	w0, w0
 112f5e8:	b9000a60 	str	w0, [x19, #8]
    LOAD32H(rk[3], key + 12);
 112f5ec:	91003260 	add	x0, x19, #0xc
 112f5f0:	97ff4f68 	bl	1103390 <memcpy>
 112f5f4:	b9400e60 	ldr	w0, [x19, #12]
    if (keylen == 16) {
 112f5f8:	7100429f 	cmp	w20, #0x10
    LOAD32H(rk[3], key + 12);
 112f5fc:	5ac00800 	rev	w0, w0
 112f600:	b9000e60 	str	w0, [x19, #12]
    if (keylen == 16) {
 112f604:	54000321 	b.ne	112f668 <rijndael_setup+0x130>  // b.any
 112f608:	b0000105 	adrp	x5, 1150000 <Te4+0x258>
 112f60c:	91024267 	add	x7, x19, #0x90
 112f610:	9106a0a5 	add	x5, x5, #0x1a8
 112f614:	aa1303e4 	mov	x4, x19
            temp  = rk[3];
 112f618:	b9400c86 	ldr	w6, [x4, #12]
            rk[4] = rk[0] ^ setup_mix(temp) ^ rcon[i];
 112f61c:	2a0603e0 	mov	w0, w6
 112f620:	97fffdb7 	bl	112ecfc <setup_mix>
 112f624:	b9400081 	ldr	w1, [x4]
            if (++i == 10) {
 112f628:	eb07009f 	cmp	x4, x7
            rk[4] = rk[0] ^ setup_mix(temp) ^ rcon[i];
 112f62c:	4a010000 	eor	w0, w0, w1
 112f630:	b84044a1 	ldr	w1, [x5], #4
 112f634:	4a010000 	eor	w0, w0, w1
            rk[5] = rk[1] ^ rk[4];
 112f638:	b9400481 	ldr	w1, [x4, #4]
            rk[4] = rk[0] ^ setup_mix(temp) ^ rcon[i];
 112f63c:	b9001080 	str	w0, [x4, #16]
            rk[5] = rk[1] ^ rk[4];
 112f640:	4a010000 	eor	w0, w0, w1
            rk[6] = rk[2] ^ rk[5];
 112f644:	b9400881 	ldr	w1, [x4, #8]
            rk[5] = rk[1] ^ rk[4];
 112f648:	b9001480 	str	w0, [x4, #20]
            rk[6] = rk[2] ^ rk[5];
 112f64c:	4a010000 	eor	w0, w0, w1
 112f650:	b9001880 	str	w0, [x4, #24]
            rk[7] = rk[3] ^ rk[6];
 112f654:	4a0000c0 	eor	w0, w6, w0
 112f658:	b9001c80 	str	w0, [x4, #28]
            if (++i == 10) {
 112f65c:	54000ea0 	b.eq	112f830 <rijndael_setup+0x2f8>  // b.none
            rk += 4;
 112f660:	91004084 	add	x4, x4, #0x10
            temp  = rk[3];
 112f664:	17ffffed 	b	112f618 <rijndael_setup+0xe0>
    } else if (keylen == 24) {
 112f668:	7100629f 	cmp	w20, #0x18
 112f66c:	540005a1 	b.ne	112f720 <rijndael_setup+0x1e8>  // b.any
        LOAD32H(rk[4], key + 16);
 112f670:	910042a1 	add	x1, x21, #0x10
 112f674:	d2800082 	mov	x2, #0x4                   	// #4
 112f678:	91004260 	add	x0, x19, #0x10
 112f67c:	97ff4f45 	bl	1103390 <memcpy>
 112f680:	b9401260 	ldr	w0, [x19, #16]
        LOAD32H(rk[5], key + 20);
 112f684:	910052a1 	add	x1, x21, #0x14
 112f688:	d2800082 	mov	x2, #0x4                   	// #4
        LOAD32H(rk[4], key + 16);
 112f68c:	5ac00800 	rev	w0, w0
 112f690:	b9001260 	str	w0, [x19, #16]
        LOAD32H(rk[5], key + 20);
 112f694:	91005260 	add	x0, x19, #0x14
 112f698:	97ff4f3e 	bl	1103390 <memcpy>
 112f69c:	b9401660 	ldr	w0, [x19, #20]
 112f6a0:	b0000106 	adrp	x6, 1150000 <Te4+0x258>
 112f6a4:	9102a267 	add	x7, x19, #0xa8
 112f6a8:	9106a0c6 	add	x6, x6, #0x1a8
 112f6ac:	aa1303e4 	mov	x4, x19
 112f6b0:	5ac00800 	rev	w0, w0
 112f6b4:	b9001660 	str	w0, [x19, #20]
            temp = rk[5];
 112f6b8:	b9401485 	ldr	w5, [x4, #20]
            rk[ 6] = rk[ 0] ^ setup_mix(temp) ^ rcon[i];
 112f6bc:	2a0503e0 	mov	w0, w5
 112f6c0:	97fffd8f 	bl	112ecfc <setup_mix>
 112f6c4:	b9400081 	ldr	w1, [x4]
            if (++i == 8) {
 112f6c8:	eb07009f 	cmp	x4, x7
            rk[ 6] = rk[ 0] ^ setup_mix(temp) ^ rcon[i];
 112f6cc:	4a010000 	eor	w0, w0, w1
 112f6d0:	b84044c1 	ldr	w1, [x6], #4
 112f6d4:	4a010000 	eor	w0, w0, w1
            rk[ 7] = rk[ 1] ^ rk[ 6];
 112f6d8:	b9400481 	ldr	w1, [x4, #4]
            rk[ 6] = rk[ 0] ^ setup_mix(temp) ^ rcon[i];
 112f6dc:	b9001880 	str	w0, [x4, #24]
            rk[ 7] = rk[ 1] ^ rk[ 6];
 112f6e0:	4a010000 	eor	w0, w0, w1
            rk[ 8] = rk[ 2] ^ rk[ 7];
 112f6e4:	b9400881 	ldr	w1, [x4, #8]
            rk[ 7] = rk[ 1] ^ rk[ 6];
 112f6e8:	b9001c80 	str	w0, [x4, #28]
            rk[ 8] = rk[ 2] ^ rk[ 7];
 112f6ec:	4a010000 	eor	w0, w0, w1
            rk[ 9] = rk[ 3] ^ rk[ 8];
 112f6f0:	b9400c81 	ldr	w1, [x4, #12]
            rk[ 8] = rk[ 2] ^ rk[ 7];
 112f6f4:	b9002080 	str	w0, [x4, #32]
            rk[ 9] = rk[ 3] ^ rk[ 8];
 112f6f8:	4a010000 	eor	w0, w0, w1
 112f6fc:	b9002480 	str	w0, [x4, #36]
            if (++i == 8) {
 112f700:	54000980 	b.eq	112f830 <rijndael_setup+0x2f8>  // b.none
            rk[10] = rk[ 4] ^ rk[ 9];
 112f704:	b9401081 	ldr	w1, [x4, #16]
            rk += 6;
 112f708:	91006084 	add	x4, x4, #0x18
            rk[10] = rk[ 4] ^ rk[ 9];
 112f70c:	4a010000 	eor	w0, w0, w1
 112f710:	b9001080 	str	w0, [x4, #16]
            rk[11] = rk[ 5] ^ rk[10];
 112f714:	4a0000a0 	eor	w0, w5, w0
 112f718:	b9001480 	str	w0, [x4, #20]
            temp = rk[5];
 112f71c:	17ffffe7 	b	112f6b8 <rijndael_setup+0x180>
    } else if (keylen == 32) {
 112f720:	7100829f 	cmp	w20, #0x20
 112f724:	54000ee1 	b.ne	112f900 <rijndael_setup+0x3c8>  // b.any
        LOAD32H(rk[4], key + 16);
 112f728:	910042a1 	add	x1, x21, #0x10
 112f72c:	d2800082 	mov	x2, #0x4                   	// #4
 112f730:	91004260 	add	x0, x19, #0x10
 112f734:	97ff4f17 	bl	1103390 <memcpy>
 112f738:	b9401260 	ldr	w0, [x19, #16]
        LOAD32H(rk[5], key + 20);
 112f73c:	910052a1 	add	x1, x21, #0x14
 112f740:	d2800082 	mov	x2, #0x4                   	// #4
        LOAD32H(rk[4], key + 16);
 112f744:	5ac00800 	rev	w0, w0
 112f748:	b9001260 	str	w0, [x19, #16]
        LOAD32H(rk[5], key + 20);
 112f74c:	91005260 	add	x0, x19, #0x14
 112f750:	97ff4f10 	bl	1103390 <memcpy>
 112f754:	b9401660 	ldr	w0, [x19, #20]
        LOAD32H(rk[6], key + 24);
 112f758:	910062a1 	add	x1, x21, #0x18
 112f75c:	d2800082 	mov	x2, #0x4                   	// #4
        LOAD32H(rk[5], key + 20);
 112f760:	5ac00800 	rev	w0, w0
 112f764:	b9001660 	str	w0, [x19, #20]
        LOAD32H(rk[6], key + 24);
 112f768:	91006260 	add	x0, x19, #0x18
 112f76c:	97ff4f09 	bl	1103390 <memcpy>
 112f770:	b9401a60 	ldr	w0, [x19, #24]
        LOAD32H(rk[7], key + 28);
 112f774:	910072a1 	add	x1, x21, #0x1c
 112f778:	d2800082 	mov	x2, #0x4                   	// #4
        LOAD32H(rk[6], key + 24);
 112f77c:	5ac00800 	rev	w0, w0
 112f780:	b9001a60 	str	w0, [x19, #24]
        LOAD32H(rk[7], key + 28);
 112f784:	91007260 	add	x0, x19, #0x1c
 112f788:	97ff4f02 	bl	1103390 <memcpy>
 112f78c:	b9401e60 	ldr	w0, [x19, #28]
 112f790:	b0000106 	adrp	x6, 1150000 <Te4+0x258>
 112f794:	91030267 	add	x7, x19, #0xc0
 112f798:	9106a0c6 	add	x6, x6, #0x1a8
 112f79c:	aa1303e4 	mov	x4, x19
 112f7a0:	5ac00800 	rev	w0, w0
 112f7a4:	b9001e60 	str	w0, [x19, #28]
            temp = rk[7];
 112f7a8:	b9401c85 	ldr	w5, [x4, #28]
            rk[ 8] = rk[ 0] ^ setup_mix(temp) ^ rcon[i];
 112f7ac:	2a0503e0 	mov	w0, w5
 112f7b0:	97fffd53 	bl	112ecfc <setup_mix>
 112f7b4:	b9400081 	ldr	w1, [x4]
            if (++i == 7) {
 112f7b8:	eb07009f 	cmp	x4, x7
            rk[ 8] = rk[ 0] ^ setup_mix(temp) ^ rcon[i];
 112f7bc:	4a010000 	eor	w0, w0, w1
 112f7c0:	b84044c1 	ldr	w1, [x6], #4
 112f7c4:	4a010000 	eor	w0, w0, w1
            rk[ 9] = rk[ 1] ^ rk[ 8];
 112f7c8:	b9400481 	ldr	w1, [x4, #4]
            rk[ 8] = rk[ 0] ^ setup_mix(temp) ^ rcon[i];
 112f7cc:	b9002080 	str	w0, [x4, #32]
            rk[ 9] = rk[ 1] ^ rk[ 8];
 112f7d0:	4a010000 	eor	w0, w0, w1
            rk[10] = rk[ 2] ^ rk[ 9];
 112f7d4:	b9400881 	ldr	w1, [x4, #8]
            rk[ 9] = rk[ 1] ^ rk[ 8];
 112f7d8:	b9002480 	str	w0, [x4, #36]
            rk[10] = rk[ 2] ^ rk[ 9];
 112f7dc:	4a010000 	eor	w0, w0, w1
            rk[11] = rk[ 3] ^ rk[10];
 112f7e0:	b9400c81 	ldr	w1, [x4, #12]
            rk[10] = rk[ 2] ^ rk[ 9];
 112f7e4:	b9002880 	str	w0, [x4, #40]
            rk[11] = rk[ 3] ^ rk[10];
 112f7e8:	4a010000 	eor	w0, w0, w1
 112f7ec:	b9002c80 	str	w0, [x4, #44]
            if (++i == 7) {
 112f7f0:	54000200 	b.eq	112f830 <rijndael_setup+0x2f8>  // b.none
            rk[12] = rk[ 4] ^ setup_mix(RORc(temp, 8));
 112f7f4:	13802000 	ror	w0, w0, #8
 112f7f8:	97fffd41 	bl	112ecfc <setup_mix>
 112f7fc:	b9401081 	ldr	w1, [x4, #16]
            rk += 8;
 112f800:	91008084 	add	x4, x4, #0x20
            rk[12] = rk[ 4] ^ setup_mix(RORc(temp, 8));
 112f804:	4a010000 	eor	w0, w0, w1
            rk[13] = rk[ 5] ^ rk[12];
 112f808:	b85f4081 	ldur	w1, [x4, #-12]
            rk[12] = rk[ 4] ^ setup_mix(RORc(temp, 8));
 112f80c:	b9001080 	str	w0, [x4, #16]
            rk[13] = rk[ 5] ^ rk[12];
 112f810:	4a010000 	eor	w0, w0, w1
            rk[14] = rk[ 6] ^ rk[13];
 112f814:	b85f8081 	ldur	w1, [x4, #-8]
            rk[13] = rk[ 5] ^ rk[12];
 112f818:	b9001480 	str	w0, [x4, #20]
            rk[14] = rk[ 6] ^ rk[13];
 112f81c:	4a010000 	eor	w0, w0, w1
 112f820:	b9001880 	str	w0, [x4, #24]
            rk[15] = rk[ 7] ^ rk[14];
 112f824:	4a0000a0 	eor	w0, w5, w0
 112f828:	b9001c80 	str	w0, [x4, #28]
            temp = rk[7];
 112f82c:	17ffffdf 	b	112f7a8 <rijndael_setup+0x270>
    rrk  = skey->rijndael.eK + (28 + keylen) - 4;
 112f830:	11007294 	add	w20, w20, #0x1c
 112f834:	928001e1 	mov	x1, #0xfffffffffffffff0    	// #-16
    rk   = skey->rijndael.dK;
 112f838:	9103c266 	add	x6, x19, #0xf0
    for (i = 1; i < skey->rijndael.Nr; i++) {
 112f83c:	52800027 	mov	w7, #0x1                   	// #1
    rrk  = skey->rijndael.eK + (28 + keylen) - 4;
 112f840:	8b34c834 	add	x20, x1, w20, sxtw #2
 112f844:	8b140265 	add	x5, x19, x20
    *rk++ = *rrk++;
 112f848:	b8746a60 	ldr	w0, [x19, x20]
 112f84c:	b900f260 	str	w0, [x19, #240]
    *rk++ = *rrk++;
 112f850:	b94004a0 	ldr	w0, [x5, #4]
 112f854:	b900f660 	str	w0, [x19, #244]
    *rk++ = *rrk++;
 112f858:	b94008a0 	ldr	w0, [x5, #8]
 112f85c:	b900fa60 	str	w0, [x19, #248]
    *rk   = *rrk;
 112f860:	b9400ca0 	ldr	w0, [x5, #12]
 112f864:	b900fe60 	str	w0, [x19, #252]
    for (i = 1; i < skey->rijndael.Nr; i++) {
 112f868:	b941e260 	ldr	w0, [x19, #480]
 112f86c:	6b0000ff 	cmp	w7, w0
 112f870:	540001cb 	b.lt	112f8a8 <rijndael_setup+0x370>  // b.tstop
    *rk++ = *rrk++;
 112f874:	b85f00a0 	ldur	w0, [x5, #-16]
 112f878:	b90010c0 	str	w0, [x6, #16]
    *rk++ = *rrk++;
 112f87c:	b85f40a0 	ldur	w0, [x5, #-12]
 112f880:	b90014c0 	str	w0, [x6, #20]
    *rk++ = *rrk++;
 112f884:	b85f80a0 	ldur	w0, [x5, #-8]
 112f888:	b90018c0 	str	w0, [x6, #24]
    *rk   = *rrk;
 112f88c:	b85fc0a0 	ldur	w0, [x5, #-4]
 112f890:	b9001cc0 	str	w0, [x6, #28]
    return CRYPT_OK;
 112f894:	52800000 	mov	w0, #0x0                   	// #0
}
 112f898:	a94153f3 	ldp	x19, x20, [sp, #16]
 112f89c:	f94013f5 	ldr	x21, [sp, #32]
 112f8a0:	a8c37bfd 	ldp	x29, x30, [sp], #48
 112f8a4:	d65f03c0 	ret
        rk[0] = setup_mix2(temp);
 112f8a8:	b85f0ca0 	ldr	w0, [x5, #-16]!
 112f8ac:	97fffd26 	bl	112ed44 <setup_mix2>
 112f8b0:	b8010cc0 	str	w0, [x6, #16]!
        rk[1] = setup_mix2(temp);
 112f8b4:	b94004a0 	ldr	w0, [x5, #4]
 112f8b8:	97fffd23 	bl	112ed44 <setup_mix2>
 112f8bc:	b90004c0 	str	w0, [x6, #4]
        rk[2] = setup_mix2(temp);
 112f8c0:	b94008a0 	ldr	w0, [x5, #8]
 112f8c4:	97fffd20 	bl	112ed44 <setup_mix2>
 112f8c8:	b90008c0 	str	w0, [x6, #8]
        rk[3] = setup_mix2(temp);
 112f8cc:	b9400ca0 	ldr	w0, [x5, #12]
 112f8d0:	97fffd1d 	bl	112ed44 <setup_mix2>
    for (i = 1; i < skey->rijndael.Nr; i++) {
 112f8d4:	110004e7 	add	w7, w7, #0x1
        rk[3] = setup_mix2(temp);
 112f8d8:	b9000cc0 	str	w0, [x6, #12]
    for (i = 1; i < skey->rijndael.Nr; i++) {
 112f8dc:	17ffffe3 	b	112f868 <rijndael_setup+0x330>
    LTC_ARGCHK(key  != NULL);
 112f8e0:	52800200 	mov	w0, #0x10                  	// #16
}
 112f8e4:	d65f03c0 	ret
    LTC_ARGCHK(key  != NULL);
 112f8e8:	52800200 	mov	w0, #0x10                  	// #16
 112f8ec:	17ffffeb 	b	112f898 <rijndael_setup+0x360>
       return CRYPT_INVALID_KEYSIZE;
 112f8f0:	52800060 	mov	w0, #0x3                   	// #3
 112f8f4:	17ffffe9 	b	112f898 <rijndael_setup+0x360>
       return CRYPT_INVALID_ROUNDS;
 112f8f8:	52800080 	mov	w0, #0x4                   	// #4
 112f8fc:	17ffffe7 	b	112f898 <rijndael_setup+0x360>
       return CRYPT_ERROR;
 112f900:	52800020 	mov	w0, #0x1                   	// #1
 112f904:	17ffffe5 	b	112f898 <rijndael_setup+0x360>

000000000112f908 <ccm_init>:
int ccm_init(ccm_state *ccm, int cipher,
             const unsigned char *key, int keylen, int ptlen, int taglen, int aadlen)
{
   int            err;

   LTC_ARGCHK(ccm    != NULL);
 112f908:	b5000140 	cbnz	x0, 112f930 <ccm_init+0x28>
 112f90c:	52800200 	mov	w0, #0x10                  	// #16
      ccm->L = 2;
   }

   ccm->aadlen = aadlen;
   return CRYPT_OK;
}
 112f910:	d65f03c0 	ret
   LTC_ARGCHK(ccm    != NULL);
 112f914:	52800200 	mov	w0, #0x10                  	// #16
}
 112f918:	a94153f3 	ldp	x19, x20, [sp, #16]
 112f91c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 112f920:	a94363f7 	ldp	x23, x24, [sp, #48]
 112f924:	f94023f9 	ldr	x25, [sp, #64]
 112f928:	a8c57bfd 	ldp	x29, x30, [sp], #80
 112f92c:	d65f03c0 	ret
{
 112f930:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 112f934:	910003fd 	mov	x29, sp
 112f938:	a90153f3 	stp	x19, x20, [sp, #16]
 112f93c:	a9025bf5 	stp	x21, x22, [sp, #32]
 112f940:	a90363f7 	stp	x23, x24, [sp, #48]
 112f944:	aa0203f8 	mov	x24, x2
 112f948:	f90023f9 	str	x25, [sp, #64]
   LTC_ARGCHK(key    != NULL);
 112f94c:	b4fffe42 	cbz	x2, 112f914 <ccm_init+0xc>
 112f950:	2a0103f5 	mov	w21, w1
   XMEMSET(ccm, 0, sizeof(ccm_state));
 112f954:	d2806f02 	mov	x2, #0x378                 	// #888
 112f958:	52800001 	mov	w1, #0x0                   	// #0
 112f95c:	aa0003f3 	mov	x19, x0
 112f960:	2a0303f9 	mov	w25, w3
 112f964:	2a0403f7 	mov	w23, w4
 112f968:	2a0503f6 	mov	w22, w5
 112f96c:	93407cd4 	sxtw	x20, w6
 112f970:	940050dc 	bl	1143ce0 <memset>
   if ((err = cipher_is_valid(cipher)) != CRYPT_OK) {
 112f974:	2a1503e0 	mov	w0, w21
 112f978:	94000ab6 	bl	1132450 <cipher_is_valid>
 112f97c:	35fffce0 	cbnz	w0, 112f918 <ccm_init+0x10>
   if (cipher_descriptor[cipher]->block_length != 16) {
 112f980:	f0000140 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 112f984:	f941c000 	ldr	x0, [x0, #896]
 112f988:	f875d800 	ldr	x0, [x0, w21, sxtw #3]
 112f98c:	b9401401 	ldr	w1, [x0, #20]
 112f990:	7100403f 	cmp	w1, #0x10
 112f994:	540003c1 	b.ne	112fa0c <ccm_init+0x104>  // b.any
   if (taglen < 4 || taglen > 16 || (taglen % 2) == 1) {
 112f998:	510012c1 	sub	w1, w22, #0x4
 112f99c:	7100303f 	cmp	w1, #0xc
 112f9a0:	54fffba8 	b.hi	112f914 <ccm_init+0xc>  // b.pmore
 112f9a4:	3707fb96 	tbnz	w22, #0, 112f914 <ccm_init+0xc>
   if ((err = cipher_descriptor[cipher]->setup(key, keylen, 0, &ccm->K)) != CRYPT_OK) {
 112f9a8:	f9401004 	ldr	x4, [x0, #32]
   ccm->taglen = taglen;
 112f9ac:	b9030676 	str	w22, [x19, #772]
   if ((err = cipher_descriptor[cipher]->setup(key, keylen, 0, &ccm->K)) != CRYPT_OK) {
 112f9b0:	aa1303e3 	mov	x3, x19
 112f9b4:	2a1903e1 	mov	w1, w25
 112f9b8:	aa1803e0 	mov	x0, x24
 112f9bc:	52800002 	mov	w2, #0x0                   	// #0
 112f9c0:	d63f0080 	blr	x4
 112f9c4:	35fffaa0 	cbnz	w0, 112f918 <ccm_init+0x10>
   ccm->ptlen = ptlen;
 112f9c8:	93407ee0 	sxtw	x0, w23
 112f9cc:	f9018e60 	str	x0, [x19, #792]
   while (ptlen) {
 112f9d0:	2a1703e0 	mov	w0, w23
   ccm->cipher = cipher;
 112f9d4:	b9030275 	str	w21, [x19, #768]
   ccm->L   = 0;
 112f9d8:	f9018a7f 	str	xzr, [x19, #784]
   while (ptlen) {
 112f9dc:	f9418a61 	ldr	x1, [x19, #784]
 112f9e0:	350000e0 	cbnz	w0, 112f9fc <ccm_init+0xf4>
   if (ccm->L <= 1) {
 112f9e4:	f100043f 	cmp	x1, #0x1
 112f9e8:	54000068 	b.hi	112f9f4 <ccm_init+0xec>  // b.pmore
      ccm->L = 2;
 112f9ec:	d2800041 	mov	x1, #0x2                   	// #2
 112f9f0:	f9018a61 	str	x1, [x19, #784]
   ccm->aadlen = aadlen;
 112f9f4:	f9019674 	str	x20, [x19, #808]
   return CRYPT_OK;
 112f9f8:	17ffffc8 	b	112f918 <ccm_init+0x10>
      ++ccm->L;
 112f9fc:	91000421 	add	x1, x1, #0x1
      ptlen >>= 8;
 112fa00:	13087c00 	asr	w0, w0, #8
      ++ccm->L;
 112fa04:	f9018a61 	str	x1, [x19, #784]
      ptlen >>= 8;
 112fa08:	17fffff5 	b	112f9dc <ccm_init+0xd4>
      return CRYPT_INVALID_CIPHER;
 112fa0c:	52800140 	mov	w0, #0xa                   	// #10
 112fa10:	17ffffc2 	b	112f918 <ccm_init+0x10>

000000000112fa14 <ccm_add_nonce>:
                  const unsigned char *nonce,     unsigned long noncelen)
{
   unsigned long x, y, len;
   int           err;

   LTC_ARGCHK(ccm   != NULL);
 112fa14:	b40011e0 	cbz	x0, 112fc50 <ccm_add_nonce+0x23c>
{
 112fa18:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 112fa1c:	910003fd 	mov	x29, sp
 112fa20:	a90153f3 	stp	x19, x20, [sp, #16]
 112fa24:	aa0103f4 	mov	x20, x1
   LTC_ARGCHK(nonce != NULL);
 112fa28:	b4001181 	cbz	x1, 112fc58 <ccm_add_nonce+0x244>
 112fa2c:	aa0003f3 	mov	x19, x0

   /* increase L to match the nonce len */
   ccm->noncelen = (noncelen > 13) ? 13 : noncelen;
 112fa30:	f100345f 	cmp	x2, #0xd
 112fa34:	d28001a0 	mov	x0, #0xd                   	// #13
 112fa38:	9a809042 	csel	x2, x2, x0, ls  // ls = plast
   if ((15 - ccm->noncelen) > ccm->L) {
 112fa3c:	d28001e0 	mov	x0, #0xf                   	// #15
 112fa40:	cb020001 	sub	x1, x0, x2
 112fa44:	f9418a63 	ldr	x3, [x19, #784]
   ccm->noncelen = (noncelen > 13) ? 13 : noncelen;
 112fa48:	f9019e62 	str	x2, [x19, #824]
   if ((15 - ccm->noncelen) > ccm->L) {
 112fa4c:	eb03003f 	cmp	x1, x3
 112fa50:	54000049 	b.ls	112fa58 <ccm_add_nonce+0x44>  // b.plast
      ccm->L = 15 - ccm->noncelen;
 112fa54:	f9018a61 	str	x1, [x19, #784]
   }

   /* decrease noncelen to match L */
   if ((ccm->noncelen + ccm->L) > 15) {
 112fa58:	f9418a63 	ldr	x3, [x19, #784]
 112fa5c:	8b030042 	add	x2, x2, x3
 112fa60:	cb030000 	sub	x0, x0, x3
 112fa64:	f1003c5f 	cmp	x2, #0xf
 112fa68:	54000049 	b.ls	112fa70 <ccm_add_nonce+0x5c>  // b.plast
      ccm->noncelen = 15 - ccm->L;
 112fa6c:	f9019e60 	str	x0, [x19, #824]
   }

   /* form B_0 == flags | Nonce N | l(m) */
   x = 0;
   ccm->PAD[x++] = (unsigned char)(((ccm->aadlen > 0) ? (1<<6) : 0) |
                   (((ccm->taglen - 2)>>1)<<3)        |
 112fa70:	b9430662 	ldr	w2, [x19, #772]
   ccm->PAD[x++] = (unsigned char)(((ccm->aadlen > 0) ? (1<<6) : 0) |
 112fa74:	f9419661 	ldr	x1, [x19, #808]
                   (((ccm->taglen - 2)>>1)<<3)        |
 112fa78:	51000842 	sub	w2, w2, #0x2
   ccm->PAD[x++] = (unsigned char)(((ccm->aadlen > 0) ? (1<<6) : 0) |
 112fa7c:	f100003f 	cmp	x1, #0x0
                   (((ccm->taglen - 2)>>1)<<3)        |
 112fa80:	13017c42 	asr	w2, w2, #1
   ccm->PAD[x++] = (unsigned char)(((ccm->aadlen > 0) ? (1<<6) : 0) |
 112fa84:	1a9f07e1 	cset	w1, ne  // ne = any
                   (((ccm->taglen - 2)>>1)<<3)        |
 112fa88:	531d7042 	lsl	w2, w2, #3
   ccm->PAD[x++] = (unsigned char)(((ccm->aadlen > 0) ? (1<<6) : 0) |
 112fa8c:	2a011842 	orr	w2, w2, w1, lsl #6
                   (ccm->L-1));
 112fa90:	51000461 	sub	w1, w3, #0x1
   ccm->PAD[x++] = (unsigned char)(((ccm->aadlen > 0) ? (1<<6) : 0) |
 112fa94:	2a010042 	orr	w2, w2, w1
 112fa98:	390d0262 	strb	w2, [x19, #832]

   /* nonce */
   for (y = 0; y < (16 - (ccm->L + 1)); y++) {
      ccm->PAD[x++] = nonce[y];
 112fa9c:	910d0662 	add	x2, x19, #0x341
   for (y = 0; y < (16 - (ccm->L + 1)); y++) {
 112faa0:	d2800001 	mov	x1, #0x0                   	// #0
 112faa4:	eb00003f 	cmp	x1, x0
 112faa8:	54000201 	b.ne	112fae8 <ccm_add_nonce+0xd4>  // b.any
   }

   /* store len */
   len = ccm->ptlen;
 112faac:	f9418e62 	ldr	x2, [x19, #792]
 112fab0:	d2800200 	mov	x0, #0x10                  	// #16
   if ((ccm->noncelen + ccm->L) > 15) {
 112fab4:	aa0303e1 	mov	x1, x3
 112fab8:	cb030000 	sub	x0, x0, x3

   /* shift len so the upper bytes of len are the contents of the length */
   for (y = ccm->L; y < 4; y++) {
 112fabc:	f1000c3f 	cmp	x1, #0x3
 112fac0:	540001c9 	b.ls	112faf8 <ccm_add_nonce+0xe4>  // b.plast
      len <<= 8;
   }

   /* store l(m) (only store 32-bits) */
   for (y = 0; ccm->L > 4 && (ccm->L-y)>4; y++) {
      ccm->PAD[x++] = 0;
 112fac4:	910cfe65 	add	x5, x19, #0x33f
   for (y = 0; ccm->L > 4 && (ccm->L-y)>4; y++) {
 112fac8:	d2800001 	mov	x1, #0x0                   	// #0
 112facc:	f100107f 	cmp	x3, #0x4
 112fad0:	54000089 	b.ls	112fae0 <ccm_add_nonce+0xcc>  // b.plast
 112fad4:	cb010064 	sub	x4, x3, x1
 112fad8:	f100109f 	cmp	x4, #0x4
 112fadc:	54000148 	b.hi	112fb04 <ccm_add_nonce+0xf0>  // b.pmore
 112fae0:	8b000260 	add	x0, x19, x0
 112fae4:	14000010 	b	112fb24 <ccm_add_nonce+0x110>
      ccm->PAD[x++] = nonce[y];
 112fae8:	38616a84 	ldrb	w4, [x20, x1]
 112faec:	38216844 	strb	w4, [x2, x1]
   for (y = 0; y < (16 - (ccm->L + 1)); y++) {
 112faf0:	91000421 	add	x1, x1, #0x1
 112faf4:	17ffffec 	b	112faa4 <ccm_add_nonce+0x90>
      len <<= 8;
 112faf8:	d378dc42 	lsl	x2, x2, #8
   for (y = ccm->L; y < 4; y++) {
 112fafc:	91000421 	add	x1, x1, #0x1
 112fb00:	17ffffef 	b	112fabc <ccm_add_nonce+0xa8>
      ccm->PAD[x++] = 0;
 112fb04:	91000400 	add	x0, x0, #0x1
   for (y = 0; ccm->L > 4 && (ccm->L-y)>4; y++) {
 112fb08:	91000421 	add	x1, x1, #0x1
      ccm->PAD[x++] = 0;
 112fb0c:	382068bf 	strb	wzr, [x5, x0]
   for (y = 0; ccm->L > 4 && (ccm->L-y)>4; y++) {
 112fb10:	17ffffef 	b	112facc <ccm_add_nonce+0xb8>
   }
   for (; y < ccm->L; y++) {
      ccm->PAD[x++] = (unsigned char)((len >> 24) & 255);
 112fb14:	d358fc44 	lsr	x4, x2, #24
   for (; y < ccm->L; y++) {
 112fb18:	91000421 	add	x1, x1, #0x1
      len <<= 8;
 112fb1c:	d378dc42 	lsl	x2, x2, #8
      ccm->PAD[x++] = (unsigned char)((len >> 24) & 255);
 112fb20:	390cfc04 	strb	w4, [x0, #831]
   for (; y < ccm->L; y++) {
 112fb24:	91000400 	add	x0, x0, #0x1
 112fb28:	eb01007f 	cmp	x3, x1
 112fb2c:	54ffff48 	b.hi	112fb14 <ccm_add_nonce+0x100>  // b.pmore
   }

   /* encrypt PAD */
   if ((err = cipher_descriptor[ccm->cipher]->ecb_encrypt(ccm->PAD, ccm->PAD, &ccm->K)) != CRYPT_OK) {
 112fb30:	f0000140 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 112fb34:	b9830262 	ldrsw	x2, [x19, #768]
 112fb38:	910d0261 	add	x1, x19, #0x340
 112fb3c:	f941c000 	ldr	x0, [x0, #896]
 112fb40:	f8627800 	ldr	x0, [x0, x2, lsl #3]
 112fb44:	aa1303e2 	mov	x2, x19
 112fb48:	f9401403 	ldr	x3, [x0, #40]
 112fb4c:	aa0103e0 	mov	x0, x1
 112fb50:	d63f0060 	blr	x3
 112fb54:	35000400 	cbnz	w0, 112fbd4 <ccm_add_nonce+0x1c0>
      return err;
   }

   /* handle header */
   ccm->x = 0;
   if (ccm->aadlen > 0) {
 112fb58:	f9419662 	ldr	x2, [x19, #808]
   ccm->x = 0;
 112fb5c:	b9030a7f 	str	wzr, [x19, #776]
   if (ccm->aadlen > 0) {
 112fb60:	b40001c2 	cbz	x2, 112fb98 <ccm_add_nonce+0x184>
      /* store length */
      if (ccm->aadlen < ((1UL<<16) - (1UL<<8))) {
 112fb64:	d29fdfe6 	mov	x6, #0xfeff                	// #65279
 112fb68:	394d0264 	ldrb	w4, [x19, #832]
 112fb6c:	394d0665 	ldrb	w5, [x19, #833]
 112fb70:	53083c41 	ubfx	w1, w2, #8, #8
 112fb74:	12001c43 	and	w3, w2, #0xff
 112fb78:	eb06005f 	cmp	x2, x6
 112fb7c:	54000328 	b.hi	112fbe0 <ccm_add_nonce+0x1cc>  // b.pmore
         ccm->PAD[ccm->x++] ^= (ccm->aadlen>>8) & 255;
 112fb80:	4a010084 	eor	w4, w4, w1
         ccm->PAD[ccm->x++] ^= ccm->aadlen & 255;
 112fb84:	4a050063 	eor	w3, w3, w5
 112fb88:	52800041 	mov	w1, #0x2                   	// #2
 112fb8c:	b9030a61 	str	w1, [x19, #776]
         ccm->PAD[ccm->x++] ^= (ccm->aadlen>>8) & 255;
 112fb90:	390d0264 	strb	w4, [x19, #832]
         ccm->PAD[ccm->x++] ^= ccm->aadlen & 255;
 112fb94:	390d0663 	strb	w3, [x19, #833]

   /* setup the ctr counter */
   x = 0;

   /* flags */
   ccm->ctr[x++] = (unsigned char)ccm->L-1;
 112fb98:	f9418a63 	ldr	x3, [x19, #784]

   /* nonce */
   for (y = 0; y < (16 - (ccm->L+1)); ++y) {
      ccm->ctr[x++] = nonce[y];
 112fb9c:	910d4664 	add	x4, x19, #0x351
   for (y = 0; y < (16 - (ccm->L+1)); ++y) {
 112fba0:	d2800002 	mov	x2, #0x0                   	// #0
   ccm->ctr[x++] = (unsigned char)ccm->L-1;
 112fba4:	51000461 	sub	w1, w3, #0x1
 112fba8:	390d4261 	strb	w1, [x19, #848]
   for (y = 0; y < (16 - (ccm->L+1)); ++y) {
 112fbac:	d28001e1 	mov	x1, #0xf                   	// #15
 112fbb0:	cb030021 	sub	x1, x1, x3
 112fbb4:	eb02003f 	cmp	x1, x2
 112fbb8:	540003e8 	b.hi	112fc34 <ccm_add_nonce+0x220>  // b.pmore
 112fbbc:	d2800201 	mov	x1, #0x10                  	// #16
   }
   /* offset */
   while (x < 16) {
      ccm->ctr[x++] = 0;
 112fbc0:	910d3e62 	add	x2, x19, #0x34f
 112fbc4:	cb030021 	sub	x1, x1, x3
   while (x < 16) {
 112fbc8:	f100403f 	cmp	x1, #0x10
 112fbcc:	540003c1 	b.ne	112fc44 <ccm_add_nonce+0x230>  // b.any
   }

   ccm->CTRlen = 16;
 112fbd0:	390dc261 	strb	w1, [x19, #880]
   return CRYPT_OK;
}
 112fbd4:	a94153f3 	ldp	x19, x20, [sp, #16]
 112fbd8:	a8c27bfd 	ldp	x29, x30, [sp], #32
 112fbdc:	d65f03c0 	ret
         ccm->PAD[ccm->x++] ^= 0xFF;
 112fbe0:	2a2403e4 	mvn	w4, w4
         ccm->PAD[ccm->x++] ^= 0xFE;
 112fbe4:	521f78a5 	eor	w5, w5, #0xfffffffe
         ccm->PAD[ccm->x++] ^= 0xFF;
 112fbe8:	390d0264 	strb	w4, [x19, #832]
         ccm->PAD[ccm->x++] ^= (ccm->aadlen>>24) & 255;
 112fbec:	394d0a64 	ldrb	w4, [x19, #834]
         ccm->PAD[ccm->x++] ^= 0xFE;
 112fbf0:	390d0665 	strb	w5, [x19, #833]
         ccm->PAD[ccm->x++] ^= (ccm->aadlen>>24) & 255;
 112fbf4:	d358fc45 	lsr	x5, x2, #24
 112fbf8:	4a050084 	eor	w4, w4, w5
 112fbfc:	390d0a64 	strb	w4, [x19, #834]
         ccm->PAD[ccm->x++] ^= (ccm->aadlen>>16) & 255;
 112fc00:	394d0e64 	ldrb	w4, [x19, #835]
 112fc04:	d350fc42 	lsr	x2, x2, #16
 112fc08:	4a020082 	eor	w2, w4, w2
         ccm->PAD[ccm->x++] ^= (ccm->aadlen>>8) & 255;
 112fc0c:	394d1264 	ldrb	w4, [x19, #836]
         ccm->PAD[ccm->x++] ^= (ccm->aadlen>>16) & 255;
 112fc10:	390d0e62 	strb	w2, [x19, #835]
         ccm->PAD[ccm->x++] ^= (ccm->aadlen>>8) & 255;
 112fc14:	4a040024 	eor	w4, w1, w4
         ccm->PAD[ccm->x++] ^= ccm->aadlen & 255;
 112fc18:	528000c1 	mov	w1, #0x6                   	// #6
 112fc1c:	b9030a61 	str	w1, [x19, #776]
 112fc20:	394d1661 	ldrb	w1, [x19, #837]
         ccm->PAD[ccm->x++] ^= (ccm->aadlen>>8) & 255;
 112fc24:	390d1264 	strb	w4, [x19, #836]
         ccm->PAD[ccm->x++] ^= ccm->aadlen & 255;
 112fc28:	4a010063 	eor	w3, w3, w1
 112fc2c:	390d1663 	strb	w3, [x19, #837]
 112fc30:	17ffffda 	b	112fb98 <ccm_add_nonce+0x184>
      ccm->ctr[x++] = nonce[y];
 112fc34:	38626a85 	ldrb	w5, [x20, x2]
 112fc38:	38226885 	strb	w5, [x4, x2]
   for (y = 0; y < (16 - (ccm->L+1)); ++y) {
 112fc3c:	91000442 	add	x2, x2, #0x1
 112fc40:	17ffffdd 	b	112fbb4 <ccm_add_nonce+0x1a0>
      ccm->ctr[x++] = 0;
 112fc44:	91000421 	add	x1, x1, #0x1
 112fc48:	3821685f 	strb	wzr, [x2, x1]
 112fc4c:	17ffffdf 	b	112fbc8 <ccm_add_nonce+0x1b4>
   LTC_ARGCHK(ccm   != NULL);
 112fc50:	52800200 	mov	w0, #0x10                  	// #16
}
 112fc54:	d65f03c0 	ret
   LTC_ARGCHK(ccm   != NULL);
 112fc58:	52800200 	mov	w0, #0x10                  	// #16
 112fc5c:	17ffffde 	b	112fbd4 <ccm_add_nonce+0x1c0>

000000000112fc60 <ccm_add_aad>:
                const unsigned char *adata,  unsigned long adatalen)
{
   unsigned long y;
   int            err;

   LTC_ARGCHK(ccm   != NULL);
 112fc60:	b4000840 	cbz	x0, 112fd68 <ccm_add_aad+0x108>
{
 112fc64:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 112fc68:	910003fd 	mov	x29, sp
 112fc6c:	a90153f3 	stp	x19, x20, [sp, #16]
 112fc70:	aa0103f4 	mov	x20, x1
 112fc74:	a9025bf5 	stp	x21, x22, [sp, #32]
 112fc78:	f9001bf7 	str	x23, [sp, #48]
   LTC_ARGCHK(adata != NULL);
 112fc7c:	b40007a1 	cbz	x1, 112fd70 <ccm_add_aad+0x110>
 112fc80:	aa0003f3 	mov	x19, x0

   if (ccm->aadlen < ccm->current_aadlen + adatalen) {
 112fc84:	f9419401 	ldr	x1, [x0, #808]
 112fc88:	f9419800 	ldr	x0, [x0, #816]
 112fc8c:	8b000040 	add	x0, x2, x0
 112fc90:	eb00003f 	cmp	x1, x0
 112fc94:	540006e3 	b.cc	112fd70 <ccm_add_aad+0x110>  // b.lo, b.ul, b.last

   /* now add the data */
   for (y = 0; y < adatalen; y++) {
      if (ccm->x == 16) {
         /* full block so let's encrypt it */
         if ((err = cipher_descriptor[ccm->cipher]->ecb_encrypt(ccm->PAD, ccm->PAD, &ccm->K)) != CRYPT_OK) {
 112fc98:	f0000156 	adrp	x22, 115a000 <__scattered_array_1phys_mem_map+0x8>
 112fc9c:	8b020295 	add	x21, x20, x2
 112fca0:	910d0277 	add	x23, x19, #0x340
   ccm->current_aadlen += adatalen;
 112fca4:	f9019a60 	str	x0, [x19, #816]
         if ((err = cipher_descriptor[ccm->cipher]->ecb_encrypt(ccm->PAD, ccm->PAD, &ccm->K)) != CRYPT_OK) {
 112fca8:	f941c2d6 	ldr	x22, [x22, #896]
   for (y = 0; y < adatalen; y++) {
 112fcac:	eb15029f 	cmp	x20, x21
 112fcb0:	54000141 	b.ne	112fcd8 <ccm_add_aad+0x78>  // b.any
      }
      ccm->PAD[ccm->x++] ^= adata[y];
   }

   /* remainder? */
   if (ccm->aadlen == ccm->current_aadlen) {
 112fcb4:	f9419661 	ldr	x1, [x19, #808]
 112fcb8:	f9419a60 	ldr	x0, [x19, #816]
 112fcbc:	eb00003f 	cmp	x1, x0
 112fcc0:	54000081 	b.ne	112fcd0 <ccm_add_aad+0x70>  // b.any
      if (ccm->x != 0) {
 112fcc4:	b9430a60 	ldr	w0, [x19, #776]
 112fcc8:	35000320 	cbnz	w0, 112fd2c <ccm_add_aad+0xcc>
         if ((err = cipher_descriptor[ccm->cipher]->ecb_encrypt(ccm->PAD, ccm->PAD, &ccm->K)) != CRYPT_OK) {
            return err;
         }
      }
      ccm->x = 0;
 112fccc:	b9030a7f 	str	wzr, [x19, #776]
   }

   return CRYPT_OK;
 112fcd0:	52800000 	mov	w0, #0x0                   	// #0
 112fcd4:	14000020 	b	112fd54 <ccm_add_aad+0xf4>
      if (ccm->x == 16) {
 112fcd8:	b9430a60 	ldr	w0, [x19, #776]
 112fcdc:	7100401f 	cmp	w0, #0x10
 112fce0:	54000141 	b.ne	112fd08 <ccm_add_aad+0xa8>  // b.any
         if ((err = cipher_descriptor[ccm->cipher]->ecb_encrypt(ccm->PAD, ccm->PAD, &ccm->K)) != CRYPT_OK) {
 112fce4:	b9830260 	ldrsw	x0, [x19, #768]
 112fce8:	aa1303e2 	mov	x2, x19
 112fcec:	aa1703e1 	mov	x1, x23
 112fcf0:	f8607ac0 	ldr	x0, [x22, x0, lsl #3]
 112fcf4:	f9401403 	ldr	x3, [x0, #40]
 112fcf8:	aa1703e0 	mov	x0, x23
 112fcfc:	d63f0060 	blr	x3
 112fd00:	350002a0 	cbnz	w0, 112fd54 <ccm_add_aad+0xf4>
         ccm->x = 0;
 112fd04:	b9030a7f 	str	wzr, [x19, #776]
      ccm->PAD[ccm->x++] ^= adata[y];
 112fd08:	b9430a60 	ldr	w0, [x19, #776]
 112fd0c:	11000401 	add	w1, w0, #0x1
 112fd10:	b9030a61 	str	w1, [x19, #776]
 112fd14:	8b20c260 	add	x0, x19, w0, sxtw
 112fd18:	38401681 	ldrb	w1, [x20], #1
 112fd1c:	394d0002 	ldrb	w2, [x0, #832]
 112fd20:	4a010042 	eor	w2, w2, w1
 112fd24:	390d0002 	strb	w2, [x0, #832]
   for (y = 0; y < adatalen; y++) {
 112fd28:	17ffffe1 	b	112fcac <ccm_add_aad+0x4c>
         if ((err = cipher_descriptor[ccm->cipher]->ecb_encrypt(ccm->PAD, ccm->PAD, &ccm->K)) != CRYPT_OK) {
 112fd2c:	f0000140 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 112fd30:	b9830262 	ldrsw	x2, [x19, #768]
 112fd34:	910d0261 	add	x1, x19, #0x340
 112fd38:	f941c000 	ldr	x0, [x0, #896]
 112fd3c:	f8627800 	ldr	x0, [x0, x2, lsl #3]
 112fd40:	aa1303e2 	mov	x2, x19
 112fd44:	f9401403 	ldr	x3, [x0, #40]
 112fd48:	aa0103e0 	mov	x0, x1
 112fd4c:	d63f0060 	blr	x3
 112fd50:	34fffbe0 	cbz	w0, 112fccc <ccm_add_aad+0x6c>
}
 112fd54:	a94153f3 	ldp	x19, x20, [sp, #16]
 112fd58:	a9425bf5 	ldp	x21, x22, [sp, #32]
 112fd5c:	f9401bf7 	ldr	x23, [sp, #48]
 112fd60:	a8c47bfd 	ldp	x29, x30, [sp], #64
 112fd64:	d65f03c0 	ret
   LTC_ARGCHK(ccm   != NULL);
 112fd68:	52800200 	mov	w0, #0x10                  	// #16
}
 112fd6c:	d65f03c0 	ret
   LTC_ARGCHK(ccm   != NULL);
 112fd70:	52800200 	mov	w0, #0x10                  	// #16
 112fd74:	17fffff8 	b	112fd54 <ccm_add_aad+0xf4>

000000000112fd78 <ccm_process>:
 */
int ccm_process(ccm_state *ccm,
                unsigned char *pt,     unsigned long ptlen,
                unsigned char *ct,
                int direction)
{
 112fd78:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
 112fd7c:	910003fd 	mov	x29, sp
 112fd80:	a90153f3 	stp	x19, x20, [sp, #16]
 112fd84:	a9025bf5 	stp	x21, x22, [sp, #32]
 112fd88:	a90363f7 	stp	x23, x24, [sp, #48]
 112fd8c:	a9046bf9 	stp	x25, x26, [sp, #64]
 112fd90:	a90573fb 	stp	x27, x28, [sp, #80]
 112fd94:	b9006fe4 	str	w4, [sp, #108]
   unsigned char z, b;
   unsigned long y;
   int err;

   LTC_ARGCHK(ccm != NULL);
 112fd98:	b5000120 	cbnz	x0, 112fdbc <ccm_process+0x44>
 112fd9c:	52800200 	mov	w0, #0x10                  	// #16
         ccm->PAD[ccm->x++] ^= b;
      }
   }

   return CRYPT_OK;
}
 112fda0:	a94153f3 	ldp	x19, x20, [sp, #16]
 112fda4:	a9425bf5 	ldp	x21, x22, [sp, #32]
 112fda8:	a94363f7 	ldp	x23, x24, [sp, #48]
 112fdac:	a9446bf9 	ldp	x25, x26, [sp, #64]
 112fdb0:	a94573fb 	ldp	x27, x28, [sp, #80]
 112fdb4:	a8c77bfd 	ldp	x29, x30, [sp], #112
 112fdb8:	d65f03c0 	ret
 112fdbc:	aa0003f3 	mov	x19, x0
 112fdc0:	aa0103f4 	mov	x20, x1
   if (ccm->aadlen != ccm->current_aadlen) {
 112fdc4:	f9419401 	ldr	x1, [x0, #808]
 112fdc8:	f9419800 	ldr	x0, [x0, #816]
 112fdcc:	eb00003f 	cmp	x1, x0
 112fdd0:	54000ae1 	b.ne	112ff2c <ccm_process+0x1b4>  // b.any
   if (ccm->ptlen < ccm->current_ptlen + ptlen) {
 112fdd4:	f9419260 	ldr	x0, [x19, #800]
 112fdd8:	aa0203fc 	mov	x28, x2
 112fddc:	f9418e61 	ldr	x1, [x19, #792]
 112fde0:	8b000040 	add	x0, x2, x0
 112fde4:	eb00003f 	cmp	x1, x0
 112fde8:	54000a23 	b.cc	112ff2c <ccm_process+0x1b4>  // b.lo, b.ul, b.last
   ccm->current_ptlen += ptlen;
 112fdec:	f9019260 	str	x0, [x19, #800]
   if (ptlen > 0) {
 112fdf0:	b5000062 	cbnz	x2, 112fdfc <ccm_process+0x84>
   return CRYPT_OK;
 112fdf4:	52800000 	mov	w0, #0x0                   	// #0
 112fdf8:	17ffffea 	b	112fda0 <ccm_process+0x28>
      LTC_ARGCHK(pt != NULL);
 112fdfc:	b4fffd14 	cbz	x20, 112fd9c <ccm_process+0x24>
 112fe00:	aa0303f6 	mov	x22, x3
      LTC_ARGCHK(ct != NULL);
 112fe04:	b4fffcc3 	cbz	x3, 112fd9c <ccm_process+0x24>
            if ((err = cipher_descriptor[ccm->cipher]->ecb_encrypt(ccm->ctr, ccm->CTRPAD, &ccm->K)) != CRYPT_OK) {
 112fe08:	f0000155 	adrp	x21, 115a000 <__scattered_array_1phys_mem_map+0x8>
 112fe0c:	910d8277 	add	x23, x19, #0x360
 112fe10:	910d4278 	add	x24, x19, #0x350
      for (y = 0; y < ptlen; y++) {
 112fe14:	d280001b 	mov	x27, #0x0                   	// #0
            if ((err = cipher_descriptor[ccm->cipher]->ecb_encrypt(ccm->ctr, ccm->CTRPAD, &ccm->K)) != CRYPT_OK) {
 112fe18:	f941c2b9 	ldr	x25, [x21, #896]
         if (ccm->CTRlen == 16) {
 112fe1c:	394dc260 	ldrb	w0, [x19, #880]
 112fe20:	7100401f 	cmp	w0, #0x10
 112fe24:	540002a1 	b.ne	112fe78 <ccm_process+0x100>  // b.any
            for (z = 15; z > 15-ccm->L; z--) {
 112fe28:	f9418a61 	ldr	x1, [x19, #784]
 112fe2c:	d28001e0 	mov	x0, #0xf                   	// #15
 112fe30:	cb010001 	sub	x1, x0, x1
 112fe34:	eb20003f 	cmp	x1, w0, uxtb
 112fe38:	540000e2 	b.cs	112fe54 <ccm_process+0xdc>  // b.hs, b.nlast
               ccm->ctr[z] = (ccm->ctr[z] + 1) & 255;
 112fe3c:	8b20c262 	add	x2, x19, w0, sxtw
 112fe40:	394d4044 	ldrb	w4, [x2, #848]
 112fe44:	11000484 	add	w4, w4, #0x1
 112fe48:	12001c84 	and	w4, w4, #0xff
 112fe4c:	390d4044 	strb	w4, [x2, #848]
               if (ccm->ctr[z]) break;
 112fe50:	340005a4 	cbz	w4, 112ff04 <ccm_process+0x18c>
            if ((err = cipher_descriptor[ccm->cipher]->ecb_encrypt(ccm->ctr, ccm->CTRPAD, &ccm->K)) != CRYPT_OK) {
 112fe54:	b9830260 	ldrsw	x0, [x19, #768]
 112fe58:	aa1303e2 	mov	x2, x19
 112fe5c:	aa1703e1 	mov	x1, x23
 112fe60:	f8607b20 	ldr	x0, [x25, x0, lsl #3]
 112fe64:	f9401404 	ldr	x4, [x0, #40]
 112fe68:	aa1803e0 	mov	x0, x24
 112fe6c:	d63f0080 	blr	x4
 112fe70:	35fff980 	cbnz	w0, 112fda0 <ccm_process+0x28>
            ccm->CTRlen = 0;
 112fe74:	390dc27f 	strb	wzr, [x19, #880]
         if (direction == CCM_ENCRYPT) {
 112fe78:	b9406fe2 	ldr	w2, [sp, #108]
 112fe7c:	394dc260 	ldrb	w0, [x19, #880]
 112fe80:	11000401 	add	w1, w0, #0x1
 112fe84:	12001c21 	and	w1, w1, #0xff
 112fe88:	35000442 	cbnz	w2, 112ff10 <ccm_process+0x198>
            ct[y] = b ^ ccm->CTRPAD[ccm->CTRlen++];
 112fe8c:	8b000260 	add	x0, x19, x0
            b     = pt[y];
 112fe90:	387b6a9a 	ldrb	w26, [x20, x27]
            ct[y] = b ^ ccm->CTRPAD[ccm->CTRlen++];
 112fe94:	390dc261 	strb	w1, [x19, #880]
 112fe98:	394d8000 	ldrb	w0, [x0, #864]
 112fe9c:	4a000340 	eor	w0, w26, w0
 112fea0:	383b6ac0 	strb	w0, [x22, x27]
         if (ccm->x == 16) {
 112fea4:	b9430a60 	ldr	w0, [x19, #776]
 112fea8:	7100401f 	cmp	w0, #0x10
 112feac:	54000161 	b.ne	112fed8 <ccm_process+0x160>  // b.any
            if ((err = cipher_descriptor[ccm->cipher]->ecb_encrypt(ccm->PAD, ccm->PAD, &ccm->K)) != CRYPT_OK) {
 112feb0:	b9830262 	ldrsw	x2, [x19, #768]
 112feb4:	910d0261 	add	x1, x19, #0x340
 112feb8:	f941c2a0 	ldr	x0, [x21, #896]
 112febc:	f8627800 	ldr	x0, [x0, x2, lsl #3]
 112fec0:	aa1303e2 	mov	x2, x19
 112fec4:	f9401404 	ldr	x4, [x0, #40]
 112fec8:	aa0103e0 	mov	x0, x1
 112fecc:	d63f0080 	blr	x4
 112fed0:	35fff680 	cbnz	w0, 112fda0 <ccm_process+0x28>
            ccm->x = 0;
 112fed4:	b9030a7f 	str	wzr, [x19, #776]
         ccm->PAD[ccm->x++] ^= b;
 112fed8:	b9430a60 	ldr	w0, [x19, #776]
      for (y = 0; y < ptlen; y++) {
 112fedc:	9100077b 	add	x27, x27, #0x1
 112fee0:	eb1b039f 	cmp	x28, x27
         ccm->PAD[ccm->x++] ^= b;
 112fee4:	11000401 	add	w1, w0, #0x1
 112fee8:	b9030a61 	str	w1, [x19, #776]
 112feec:	8b20c260 	add	x0, x19, w0, sxtw
 112fef0:	394d0001 	ldrb	w1, [x0, #832]
 112fef4:	4a01035a 	eor	w26, w26, w1
 112fef8:	390d001a 	strb	w26, [x0, #832]
      for (y = 0; y < ptlen; y++) {
 112fefc:	54fff901 	b.ne	112fe1c <ccm_process+0xa4>  // b.any
 112ff00:	17ffffbd 	b	112fdf4 <ccm_process+0x7c>
            for (z = 15; z > 15-ccm->L; z--) {
 112ff04:	51000400 	sub	w0, w0, #0x1
 112ff08:	12001c00 	and	w0, w0, #0xff
 112ff0c:	17ffffca 	b	112fe34 <ccm_process+0xbc>
            b     = ct[y] ^ ccm->CTRPAD[ccm->CTRlen++];
 112ff10:	8b000260 	add	x0, x19, x0
 112ff14:	387b6ac2 	ldrb	w2, [x22, x27]
 112ff18:	390dc261 	strb	w1, [x19, #880]
 112ff1c:	394d801a 	ldrb	w26, [x0, #864]
 112ff20:	4a02035a 	eor	w26, w26, w2
            pt[y] = b;
 112ff24:	383b6a9a 	strb	w26, [x20, x27]
 112ff28:	17ffffdf 	b	112fea4 <ccm_process+0x12c>
      return CRYPT_ERROR;
 112ff2c:	52800020 	mov	w0, #0x1                   	// #1
 112ff30:	17ffff9c 	b	112fda0 <ccm_process+0x28>

000000000112ff34 <ccm_done>:
  @param taglen  [in/out]  The length of the MAC tag
  @return CRYPT_OK on success
 */
int ccm_done(ccm_state *ccm,
             unsigned char *tag,    unsigned long *taglen)
{
 112ff34:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 112ff38:	910003fd 	mov	x29, sp
 112ff3c:	a90153f3 	stp	x19, x20, [sp, #16]
 112ff40:	a9025bf5 	stp	x21, x22, [sp, #32]
 112ff44:	a90363f7 	stp	x23, x24, [sp, #48]
   unsigned long x, y;
   int            err;

   LTC_ARGCHK(ccm != NULL);
 112ff48:	b40008c0 	cbz	x0, 1130060 <ccm_done+0x12c>
 112ff4c:	aa0003f3 	mov	x19, x0
 112ff50:	aa0103f7 	mov	x23, x1

   /* Check all data have been processed */
   if (ccm->ptlen != ccm->current_ptlen) {
 112ff54:	f9418c01 	ldr	x1, [x0, #792]
 112ff58:	f9419000 	ldr	x0, [x0, #800]
 112ff5c:	eb00003f 	cmp	x1, x0
 112ff60:	540007c1 	b.ne	1130058 <ccm_done+0x124>  // b.any
      return CRYPT_ERROR;
   }

   LTC_ARGCHK(tag    != NULL);
 112ff64:	b40007f7 	cbz	x23, 1130060 <ccm_done+0x12c>
 112ff68:	aa0203f6 	mov	x22, x2
   LTC_ARGCHK(taglen != NULL);
 112ff6c:	b40007a2 	cbz	x2, 1130060 <ccm_done+0x12c>

   if (ccm->x != 0) {
 112ff70:	b9430a60 	ldr	w0, [x19, #776]
 112ff74:	350004a0 	cbnz	w0, 1130008 <ccm_done+0xd4>
         return err;
      }
   }

   /* setup CTR for the TAG (zero the count) */
   for (y = 15; y > 15 - ccm->L; y--) {
 112ff78:	f9418a62 	ldr	x2, [x19, #784]
 112ff7c:	d28001e1 	mov	x1, #0xf                   	// #15
 112ff80:	910d4260 	add	x0, x19, #0x350
 112ff84:	cb020022 	sub	x2, x1, x2
 112ff88:	eb01005f 	cmp	x2, x1
 112ff8c:	54000603 	b.cc	113004c <ccm_done+0x118>  // b.lo, b.ul, b.last
      ccm->ctr[y] = 0x00;
   }
   if ((err = cipher_descriptor[ccm->cipher]->ecb_encrypt(ccm->ctr, ccm->CTRPAD, &ccm->K)) != CRYPT_OK) {
 112ff90:	f0000143 	adrp	x3, 115a000 <__scattered_array_1phys_mem_map+0x8>
 112ff94:	b9830261 	ldrsw	x1, [x19, #768]
 112ff98:	910d8278 	add	x24, x19, #0x360
 112ff9c:	aa1303e2 	mov	x2, x19
 112ffa0:	f941c075 	ldr	x21, [x3, #896]
 112ffa4:	f8617aa1 	ldr	x1, [x21, x1, lsl #3]
 112ffa8:	f9401423 	ldr	x3, [x1, #40]
 112ffac:	aa1803e1 	mov	x1, x24
 112ffb0:	d63f0060 	blr	x3
 112ffb4:	2a0003f4 	mov	w20, w0
 112ffb8:	350003e0 	cbnz	w0, 1130034 <ccm_done+0x100>
      return err;
   }

   cipher_descriptor[ccm->cipher]->done(&ccm->K);
 112ffbc:	b9830260 	ldrsw	x0, [x19, #768]
 112ffc0:	f8607aa0 	ldr	x0, [x21, x0, lsl #3]
 112ffc4:	f9402001 	ldr	x1, [x0, #64]
 112ffc8:	aa1303e0 	mov	x0, x19

   /* store the TAG */
   for (x = 0; x < 16 && x < *taglen; x++) {
      tag[x] = ccm->PAD[x] ^ ccm->CTRPAD[x];
 112ffcc:	910d0273 	add	x19, x19, #0x340
   cipher_descriptor[ccm->cipher]->done(&ccm->K);
 112ffd0:	d63f0020 	blr	x1
   for (x = 0; x < 16 && x < *taglen; x++) {
 112ffd4:	d2800000 	mov	x0, #0x0                   	// #0
 112ffd8:	f94002c1 	ldr	x1, [x22]
 112ffdc:	eb00003f 	cmp	x1, x0
 112ffe0:	54000109 	b.ls	1130000 <ccm_done+0xcc>  // b.plast
      tag[x] = ccm->PAD[x] ^ ccm->CTRPAD[x];
 112ffe4:	38606a62 	ldrb	w2, [x19, x0]
 112ffe8:	38606b01 	ldrb	w1, [x24, x0]
 112ffec:	4a010042 	eor	w2, w2, w1
 112fff0:	38206ae2 	strb	w2, [x23, x0]
   for (x = 0; x < 16 && x < *taglen; x++) {
 112fff4:	91000400 	add	x0, x0, #0x1
 112fff8:	f100401f 	cmp	x0, #0x10
 112fffc:	54fffee1 	b.ne	112ffd8 <ccm_done+0xa4>  // b.any
   }
   *taglen = x;
 1130000:	f90002c0 	str	x0, [x22]

   return CRYPT_OK;
 1130004:	1400000c 	b	1130034 <ccm_done+0x100>
      if ((err = cipher_descriptor[ccm->cipher]->ecb_encrypt(ccm->PAD, ccm->PAD, &ccm->K)) != CRYPT_OK) {
 1130008:	d0000143 	adrp	x3, 115a000 <__scattered_array_1phys_mem_map+0x8>
 113000c:	b9830260 	ldrsw	x0, [x19, #768]
 1130010:	910d0261 	add	x1, x19, #0x340
 1130014:	aa1303e2 	mov	x2, x19
 1130018:	f941c063 	ldr	x3, [x3, #896]
 113001c:	f8607860 	ldr	x0, [x3, x0, lsl #3]
 1130020:	f9401403 	ldr	x3, [x0, #40]
 1130024:	aa0103e0 	mov	x0, x1
 1130028:	d63f0060 	blr	x3
 113002c:	2a0003f4 	mov	w20, w0
 1130030:	34fffa40 	cbz	w0, 112ff78 <ccm_done+0x44>
}
 1130034:	2a1403e0 	mov	w0, w20
 1130038:	a94153f3 	ldp	x19, x20, [sp, #16]
 113003c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1130040:	a94363f7 	ldp	x23, x24, [sp, #48]
 1130044:	a8c47bfd 	ldp	x29, x30, [sp], #64
 1130048:	d65f03c0 	ret
      ccm->ctr[y] = 0x00;
 113004c:	3821681f 	strb	wzr, [x0, x1]
   for (y = 15; y > 15 - ccm->L; y--) {
 1130050:	d1000421 	sub	x1, x1, #0x1
 1130054:	17ffffcd 	b	112ff88 <ccm_done+0x54>
      return CRYPT_ERROR;
 1130058:	52800034 	mov	w20, #0x1                   	// #1
 113005c:	17fffff6 	b	1130034 <ccm_done+0x100>
   LTC_ARGCHK(ccm != NULL);
 1130060:	52800214 	mov	w20, #0x10                  	// #16
 1130064:	17fffff4 	b	1130034 <ccm_done+0x100>

0000000001130068 <ccm_reset>:
  @param ccm   The CCM state to reset
  @return CRYPT_OK on success
*/
int ccm_reset(ccm_state *ccm)
{
   LTC_ARGCHK(ccm != NULL);
 1130068:	b40002a0 	cbz	x0, 11300bc <ccm_reset+0x54>
{
 113006c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   zeromem(ccm->PAD, sizeof(ccm->PAD));
 1130070:	d2800201 	mov	x1, #0x10                  	// #16
{
 1130074:	910003fd 	mov	x29, sp
 1130078:	f9000bf3 	str	x19, [sp, #16]
 113007c:	aa0003f3 	mov	x19, x0
   zeromem(ccm->PAD, sizeof(ccm->PAD));
 1130080:	910d0000 	add	x0, x0, #0x340
 1130084:	940008f0 	bl	1132444 <zeromem>
   zeromem(ccm->ctr, sizeof(ccm->ctr));
 1130088:	910d4260 	add	x0, x19, #0x350
 113008c:	d2800201 	mov	x1, #0x10                  	// #16
 1130090:	940008ed 	bl	1132444 <zeromem>
   zeromem(ccm->CTRPAD, sizeof(ccm->CTRPAD));
 1130094:	910d8260 	add	x0, x19, #0x360
 1130098:	d2800201 	mov	x1, #0x10                  	// #16
 113009c:	940008ea 	bl	1132444 <zeromem>
   ccm->CTRlen = 0;
   ccm->current_ptlen = 0;
 11300a0:	f901927f 	str	xzr, [x19, #800]
   ccm->current_aadlen = 0;
 11300a4:	f9019a7f 	str	xzr, [x19, #816]

   return CRYPT_OK;
 11300a8:	52800000 	mov	w0, #0x0                   	// #0
   ccm->CTRlen = 0;
 11300ac:	390dc27f 	strb	wzr, [x19, #880]
}
 11300b0:	f9400bf3 	ldr	x19, [sp, #16]
 11300b4:	a8c27bfd 	ldp	x29, x30, [sp], #32
 11300b8:	d65f03c0 	ret
   LTC_ARGCHK(ccm != NULL);
 11300bc:	52800200 	mov	w0, #0x10                  	// #16
}
 11300c0:	d65f03c0 	ret

00000000011300c4 <md5_init>:
   @param md   The hash state you wish to initialize
   @return CRYPT_OK if successful
*/
int md5_init(hash_state * md)
{
   LTC_ARGCHK(md != NULL);
 11300c4:	b40001c0 	cbz	x0, 11300fc <md5_init+0x38>
   md->md5.state[0] = 0x67452301UL;
 11300c8:	d2846021 	mov	x1, #0x2301                	// #8961
   md->md5.state[1] = 0xefcdab89UL;
   md->md5.state[2] = 0x98badcfeUL;
   md->md5.state[3] = 0x10325476UL;
   md->md5.curlen = 0;
 11300cc:	b900181f 	str	wzr, [x0, #24]
   md->md5.state[0] = 0x67452301UL;
 11300d0:	f2ace8a1 	movk	x1, #0x6745, lsl #16
 11300d4:	f2d57121 	movk	x1, #0xab89, lsl #32
 11300d8:	f2fdf9a1 	movk	x1, #0xefcd, lsl #48
 11300dc:	a900041f 	stp	xzr, x1, [x0]
   md->md5.state[2] = 0x98badcfeUL;
 11300e0:	d29b9fc1 	mov	x1, #0xdcfe                	// #56574
 11300e4:	f2b31741 	movk	x1, #0x98ba, lsl #16
 11300e8:	f2ca8ec1 	movk	x1, #0x5476, lsl #32
 11300ec:	f2e20641 	movk	x1, #0x1032, lsl #48
 11300f0:	f9000801 	str	x1, [x0, #16]
   md->md5.length = 0;
   return CRYPT_OK;
 11300f4:	52800000 	mov	w0, #0x0                   	// #0
}
 11300f8:	d65f03c0 	ret
   LTC_ARGCHK(md != NULL);
 11300fc:	52800200 	mov	w0, #0x10                  	// #16
 1130100:	17fffffe 	b	11300f8 <md5_init+0x34>

0000000001130104 <md5_test>:
         return CRYPT_FAIL_TESTVECTOR;
      }
  }
  return CRYPT_OK;
 #endif
}
 1130104:	52800040 	mov	w0, #0x2                   	// #2
 1130108:	d65f03c0 	ret

000000000113010c <md5_compress>:
{
 113010c:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
 1130110:	910003fd 	mov	x29, sp
 1130114:	a90153f3 	stp	x19, x20, [sp, #16]
 1130118:	aa0003f3 	mov	x19, x0
        LOAD32L(W[i], buf + (4*i));
 113011c:	9100c3f4 	add	x20, sp, #0x30
{
 1130120:	a9025bf5 	stp	x21, x22, [sp, #32]
 1130124:	aa0103f6 	mov	x22, x1
 1130128:	d2800015 	mov	x21, #0x0                   	// #0
        LOAD32L(W[i], buf + (4*i));
 113012c:	8b1502c1 	add	x1, x22, x21
 1130130:	8b150280 	add	x0, x20, x21
 1130134:	d2800082 	mov	x2, #0x4                   	// #4
 1130138:	910012b5 	add	x21, x21, #0x4
 113013c:	97ff4c95 	bl	1103390 <memcpy>
    for (i = 0; i < 16; i++) {
 1130140:	f10102bf 	cmp	x21, #0x40
 1130144:	54ffff41 	b.ne	113012c <md5_compress+0x20>  // b.any
    b = md->md5.state[1];
 1130148:	29412a6b 	ldp	w11, w10, [x19, #8]
        FF(a,b,c,d,W[Worder[i]],Rorder[i],Korder[i]);
 113014c:	9000010e 	adrp	x14, 1150000 <Te4+0x258>
    d = md->md5.state[3];
 1130150:	29422269 	ldp	w9, w8, [x19, #16]
        FF(a,b,c,d,W[Worder[i]],Rorder[i],Korder[i]);
 1130154:	d000012d 	adrp	x13, 1156000 <ta_pub_key_modulus+0x7>
 1130158:	d000012c 	adrp	x12, 1156000 <ta_pub_key_modulus+0x7>
 113015c:	910741d2 	add	x18, x14, #0x1d0
 1130160:	911eb1b1 	add	x17, x13, #0x7ac
 1130164:	911db190 	add	x16, x12, #0x76c
    a = md->md5.state[0];
 1130168:	2a0b03e6 	mov	w6, w11
    b = md->md5.state[1];
 113016c:	2a0a03e3 	mov	w3, w10
    d = md->md5.state[3];
 1130170:	2a0803e4 	mov	w4, w8
    c = md->md5.state[2];
 1130174:	2a0903e0 	mov	w0, w9
    d = md->md5.state[3];
 1130178:	d2800001 	mov	x1, #0x0                   	// #0
        FF(a,b,c,d,W[Worder[i]],Rorder[i],Korder[i]);
 113017c:	5280040f 	mov	w15, #0x20                  	// #32
 1130180:	38616a25 	ldrb	w5, [x17, x1]
 1130184:	4a040007 	eor	w7, w0, w4
 1130188:	b8617a42 	ldr	w2, [x18, x1, lsl #2]
 113018c:	0a0300e7 	and	w7, w7, w3
 1130190:	4a0400e7 	eor	w7, w7, w4
 1130194:	0b0200c2 	add	w2, w6, w2
 1130198:	b8657a86 	ldr	w6, [x20, x5, lsl #2]
 113019c:	0b0600e6 	add	w6, w7, w6
 11301a0:	38706827 	ldrb	w7, [x1, x16]
 11301a4:	0b0200c5 	add	w5, w6, w2
 11301a8:	0b0200c6 	add	w6, w6, w2
 11301ac:	120010e7 	and	w7, w7, #0x1f
 11301b0:	91000421 	add	x1, x1, #0x1
 11301b4:	4b0701e2 	sub	w2, w15, w7
    for (i = 0; i < 16; ++i) {
 11301b8:	f100403f 	cmp	x1, #0x10
        FF(a,b,c,d,W[Worder[i]],Rorder[i],Korder[i]);
 11301bc:	12001042 	and	w2, w2, #0x1f
 11301c0:	9ac224c6 	lsr	x6, x6, x2
 11301c4:	1ac720a2 	lsl	w2, w5, w7
 11301c8:	2a060046 	orr	w6, w2, w6
 11301cc:	2a0303e7 	mov	w7, w3
 11301d0:	0b060063 	add	w3, w3, w6
    for (i = 0; i < 16; ++i) {
 11301d4:	2a0403e6 	mov	w6, w4
 11301d8:	54000b61 	b.ne	1130344 <md5_compress+0x238>  // b.any
        GG(a,b,c,d,W[Worder[i]],Rorder[i],Korder[i]);
 11301dc:	910741d2 	add	x18, x14, #0x1d0
 11301e0:	911eb1b1 	add	x17, x13, #0x7ac
 11301e4:	911db190 	add	x16, x12, #0x76c
 11301e8:	5280040f 	mov	w15, #0x20                  	// #32
 11301ec:	38616a22 	ldrb	w2, [x17, x1]
 11301f0:	4a070066 	eor	w6, w3, w7
 11301f4:	b8617a45 	ldr	w5, [x18, x1, lsl #2]
 11301f8:	0a0000c6 	and	w6, w6, w0
 11301fc:	4a0700c6 	eor	w6, w6, w7
 1130200:	0b050084 	add	w4, w4, w5
 1130204:	b8627a85 	ldr	w5, [x20, x2, lsl #2]
 1130208:	0b0500c5 	add	w5, w6, w5
 113020c:	38706826 	ldrb	w6, [x1, x16]
 1130210:	0b0400a2 	add	w2, w5, w4
 1130214:	0b0400a5 	add	w5, w5, w4
 1130218:	120010c6 	and	w6, w6, #0x1f
 113021c:	91000421 	add	x1, x1, #0x1
 1130220:	4b0601e4 	sub	w4, w15, w6
    for (; i < 32; ++i) {
 1130224:	f100803f 	cmp	x1, #0x20
        GG(a,b,c,d,W[Worder[i]],Rorder[i],Korder[i]);
 1130228:	12001084 	and	w4, w4, #0x1f
 113022c:	1ac62042 	lsl	w2, w2, w6
 1130230:	9ac424a5 	lsr	x5, x5, x4
 1130234:	2a050045 	orr	w5, w2, w5
 1130238:	0b0300a2 	add	w2, w5, w3
    for (; i < 32; ++i) {
 113023c:	2a0003e4 	mov	w4, w0
 1130240:	54000881 	b.ne	1130350 <md5_compress+0x244>  // b.any
        HH(a,b,c,d,W[Worder[i]],Rorder[i],Korder[i]);
 1130244:	911eb1b2 	add	x18, x13, #0x7ac
 1130248:	910741d1 	add	x17, x14, #0x1d0
 113024c:	911db190 	add	x16, x12, #0x76c
 1130250:	2a0103ef 	mov	w15, w1
 1130254:	38616a44 	ldrb	w4, [x18, x1]
 1130258:	38706826 	ldrb	w6, [x1, x16]
 113025c:	120010c6 	and	w6, w6, #0x1f
 1130260:	b8647a85 	ldr	w5, [x20, x4, lsl #2]
 1130264:	4a030044 	eor	w4, w2, w3
 1130268:	4a070084 	eor	w4, w4, w7
 113026c:	0b050000 	add	w0, w0, w5
 1130270:	b8617a25 	ldr	w5, [x17, x1, lsl #2]
 1130274:	91000421 	add	x1, x1, #0x1
 1130278:	0b050085 	add	w5, w4, w5
    for (; i < 48; ++i) {
 113027c:	f100c03f 	cmp	x1, #0x30
        HH(a,b,c,d,W[Worder[i]],Rorder[i],Korder[i]);
 1130280:	0b0000a4 	add	w4, w5, w0
 1130284:	0b0000a5 	add	w5, w5, w0
 1130288:	4b0601e0 	sub	w0, w15, w6
 113028c:	12001000 	and	w0, w0, #0x1f
 1130290:	1ac62084 	lsl	w4, w4, w6
 1130294:	9ac024a5 	lsr	x5, x5, x0
 1130298:	2a050085 	orr	w5, w4, w5
 113029c:	0b0200a4 	add	w4, w5, w2
    for (; i < 48; ++i) {
 11302a0:	2a0703e0 	mov	w0, w7
 11302a4:	540005e1 	b.ne	1130360 <md5_compress+0x254>  // b.any
        II(a,b,c,d,W[Worder[i]],Rorder[i],Korder[i]);
 11302a8:	910741ce 	add	x14, x14, #0x1d0
 11302ac:	911eb1ad 	add	x13, x13, #0x7ac
 11302b0:	911db18c 	add	x12, x12, #0x76c
 11302b4:	5280040f 	mov	w15, #0x20                  	// #32
 11302b8:	b86179c0 	ldr	w0, [x14, x1, lsl #2]
 11302bc:	2a230085 	orn	w5, w4, w3
 11302c0:	386c6826 	ldrb	w6, [x1, x12]
 11302c4:	4a0200a5 	eor	w5, w5, w2
 11302c8:	0b0000e7 	add	w7, w7, w0
 11302cc:	386169a0 	ldrb	w0, [x13, x1]
 11302d0:	120010c6 	and	w6, w6, #0x1f
 11302d4:	91000421 	add	x1, x1, #0x1
    for (; i < 64; ++i) {
 11302d8:	f101003f 	cmp	x1, #0x40
        II(a,b,c,d,W[Worder[i]],Rorder[i],Korder[i]);
 11302dc:	b8607a80 	ldr	w0, [x20, x0, lsl #2]
 11302e0:	0b0000a0 	add	w0, w5, w0
 11302e4:	0b070005 	add	w5, w0, w7
 11302e8:	0b070000 	add	w0, w0, w7
 11302ec:	4b0601e7 	sub	w7, w15, w6
 11302f0:	120010e7 	and	w7, w7, #0x1f
 11302f4:	1ac620a5 	lsl	w5, w5, w6
 11302f8:	9ac72400 	lsr	x0, x0, x7
 11302fc:	2a0000a0 	orr	w0, w5, w0
 1130300:	0b040000 	add	w0, w0, w4
    for (; i < 64; ++i) {
 1130304:	2a0403e5 	mov	w5, w4
 1130308:	2a0303e7 	mov	w7, w3
 113030c:	54000321 	b.ne	1130370 <md5_compress+0x264>  // b.any
    md->md5.state[0] = md->md5.state[0] + a;
 1130310:	0b030163 	add	w3, w11, w3
    md->md5.state[2] = md->md5.state[2] + c;
 1130314:	0b040124 	add	w4, w9, w4
    md->md5.state[3] = md->md5.state[3] + d;
 1130318:	0b020102 	add	w2, w8, w2
    md->md5.state[1] = md->md5.state[1] + b;
 113031c:	0b000140 	add	w0, w10, w0
 1130320:	29010263 	stp	w3, w0, [x19, #8]
   burn_stack(sizeof(ulong32) * 21);
 1130324:	d2800a80 	mov	x0, #0x54                  	// #84
    md->md5.state[3] = md->md5.state[3] + d;
 1130328:	29020a64 	stp	w4, w2, [x19, #16]
   burn_stack(sizeof(ulong32) * 21);
 113032c:	9400083b 	bl	1132418 <burn_stack>
}
 1130330:	52800000 	mov	w0, #0x0                   	// #0
 1130334:	a94153f3 	ldp	x19, x20, [sp, #16]
 1130338:	a9425bf5 	ldp	x21, x22, [sp, #32]
 113033c:	a8c77bfd 	ldp	x29, x30, [sp], #112
 1130340:	d65f03c0 	ret
 1130344:	2a0003e4 	mov	w4, w0
 1130348:	2a0703e0 	mov	w0, w7
 113034c:	17ffff8d 	b	1130180 <md5_compress+0x74>
 1130350:	2a0703e0 	mov	w0, w7
 1130354:	2a0303e7 	mov	w7, w3
        GG(a,b,c,d,W[Worder[i]],Rorder[i],Korder[i]);
 1130358:	2a0203e3 	mov	w3, w2
 113035c:	17ffffa4 	b	11301ec <md5_compress+0xe0>
 1130360:	2a0303e7 	mov	w7, w3
 1130364:	2a0203e3 	mov	w3, w2
        HH(a,b,c,d,W[Worder[i]],Rorder[i],Korder[i]);
 1130368:	2a0403e2 	mov	w2, w4
 113036c:	17ffffba 	b	1130254 <md5_compress+0x148>
 1130370:	2a0203e3 	mov	w3, w2
        II(a,b,c,d,W[Worder[i]],Rorder[i],Korder[i]);
 1130374:	2a0003e4 	mov	w4, w0
 1130378:	2a0503e2 	mov	w2, w5
 113037c:	17ffffcf 	b	11302b8 <md5_compress+0x1ac>

0000000001130380 <md5_process>:
HASH_PROCESS(md5_process, md5_compress, md5, 64)
 1130380:	b40007c0 	cbz	x0, 1130478 <md5_process+0xf8>
 1130384:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 1130388:	910003fd 	mov	x29, sp
 113038c:	a90153f3 	stp	x19, x20, [sp, #16]
 1130390:	a9025bf5 	stp	x21, x22, [sp, #32]
 1130394:	aa0103f5 	mov	x21, x1
 1130398:	a90363f7 	stp	x23, x24, [sp, #48]
 113039c:	b4000721 	cbz	x1, 1130480 <md5_process+0x100>
 11303a0:	aa0003f3 	mov	x19, x0
 11303a4:	b9401800 	ldr	w0, [x0, #24]
 11303a8:	7101001f 	cmp	w0, #0x40
 11303ac:	540006a8 	b.hi	1130480 <md5_process+0x100>  // b.pmore
 11303b0:	f9400260 	ldr	x0, [x19]
 11303b4:	aa0203f4 	mov	x20, x2
 11303b8:	ab02001f 	cmn	x0, x2
 11303bc:	54000662 	b.cs	1130488 <md5_process+0x108>  // b.hs, b.nlast
 11303c0:	91007277 	add	x23, x19, #0x1c
 11303c4:	52800818 	mov	w24, #0x40                  	// #64
 11303c8:	b50000f4 	cbnz	x20, 11303e4 <md5_process+0x64>
 11303cc:	52800000 	mov	w0, #0x0                   	// #0
 11303d0:	a94153f3 	ldp	x19, x20, [sp, #16]
 11303d4:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11303d8:	a94363f7 	ldp	x23, x24, [sp, #48]
 11303dc:	a8c47bfd 	ldp	x29, x30, [sp], #64
 11303e0:	d65f03c0 	ret
 11303e4:	b9401a60 	ldr	w0, [x19, #24]
 11303e8:	350001a0 	cbnz	w0, 113041c <md5_process+0x9c>
 11303ec:	f100fe9f 	cmp	x20, #0x3f
 11303f0:	54000169 	b.ls	113041c <md5_process+0x9c>  // b.plast
 11303f4:	aa1503e1 	mov	x1, x21
 11303f8:	aa1303e0 	mov	x0, x19
 11303fc:	97ffff44 	bl	113010c <md5_compress>
 1130400:	35fffe80 	cbnz	w0, 11303d0 <md5_process+0x50>
 1130404:	f9400260 	ldr	x0, [x19]
 1130408:	910102b5 	add	x21, x21, #0x40
 113040c:	d1010294 	sub	x20, x20, #0x40
 1130410:	91080000 	add	x0, x0, #0x200
 1130414:	f9000260 	str	x0, [x19]
 1130418:	17ffffec 	b	11303c8 <md5_process+0x48>
 113041c:	4b000316 	sub	w22, w24, w0
 1130420:	aa1503e1 	mov	x1, x21
 1130424:	eb1402df 	cmp	x22, x20
 1130428:	8b2042e0 	add	x0, x23, w0, uxtw
 113042c:	9a9492d6 	csel	x22, x22, x20, ls  // ls = plast
 1130430:	aa1603e2 	mov	x2, x22
 1130434:	8b1602b5 	add	x21, x21, x22
 1130438:	97ff4bd6 	bl	1103390 <memcpy>
 113043c:	cb160294 	sub	x20, x20, x22
 1130440:	b9401a60 	ldr	w0, [x19, #24]
 1130444:	0b160000 	add	w0, w0, w22
 1130448:	b9001a60 	str	w0, [x19, #24]
 113044c:	7101001f 	cmp	w0, #0x40
 1130450:	54fffbc1 	b.ne	11303c8 <md5_process+0x48>  // b.any
 1130454:	aa1703e1 	mov	x1, x23
 1130458:	aa1303e0 	mov	x0, x19
 113045c:	97ffff2c 	bl	113010c <md5_compress>
 1130460:	35fffb80 	cbnz	w0, 11303d0 <md5_process+0x50>
 1130464:	f9400260 	ldr	x0, [x19]
 1130468:	b9001a7f 	str	wzr, [x19, #24]
 113046c:	91080000 	add	x0, x0, #0x200
 1130470:	f9000260 	str	x0, [x19]
 1130474:	17ffffd5 	b	11303c8 <md5_process+0x48>
 1130478:	52800200 	mov	w0, #0x10                  	// #16
 113047c:	d65f03c0 	ret
 1130480:	52800200 	mov	w0, #0x10                  	// #16
 1130484:	17ffffd3 	b	11303d0 <md5_process+0x50>
 1130488:	52800320 	mov	w0, #0x19                  	// #25
 113048c:	17ffffd1 	b	11303d0 <md5_process+0x50>

0000000001130490 <md5_done>:
    LTC_ARGCHK(md  != NULL);
 1130490:	b4000920 	cbz	x0, 11305b4 <md5_done+0x124>
{
 1130494:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 1130498:	910003fd 	mov	x29, sp
 113049c:	a90153f3 	stp	x19, x20, [sp, #16]
 11304a0:	a9025bf5 	stp	x21, x22, [sp, #32]
 11304a4:	aa0103f5 	mov	x21, x1
 11304a8:	f9001bf7 	str	x23, [sp, #48]
    LTC_ARGCHK(out != NULL);
 11304ac:	b4000881 	cbz	x1, 11305bc <md5_done+0x12c>
 11304b0:	aa0003f3 	mov	x19, x0
    if (md->md5.curlen >= sizeof(md->md5.buf)) {
 11304b4:	b9401800 	ldr	w0, [x0, #24]
 11304b8:	7100fc1f 	cmp	w0, #0x3f
 11304bc:	54000808 	b.hi	11305bc <md5_done+0x12c>  // b.pmore
    md->md5.length += md->md5.curlen * 8;
 11304c0:	f9400261 	ldr	x1, [x19]
 11304c4:	531d7002 	lsl	w2, w0, #3
 11304c8:	8b020021 	add	x1, x1, x2
 11304cc:	f9000261 	str	x1, [x19]
    md->md5.buf[md->md5.curlen++] = (unsigned char)0x80;
 11304d0:	11000401 	add	w1, w0, #0x1
 11304d4:	8b204260 	add	x0, x19, w0, uxtw
 11304d8:	b9001a61 	str	w1, [x19, #24]
 11304dc:	12800fe2 	mov	w2, #0xffffff80            	// #-128
    if (md->md5.curlen > 56) {
 11304e0:	7100e03f 	cmp	w1, #0x38
    md->md5.buf[md->md5.curlen++] = (unsigned char)0x80;
 11304e4:	39007002 	strb	w2, [x0, #28]
    if (md->md5.curlen > 56) {
 11304e8:	540004c8 	b.hi	1130580 <md5_done+0xf0>  // b.pmore
    while (md->md5.curlen < 56) {
 11304ec:	b9401a60 	ldr	w0, [x19, #24]
 11304f0:	7100dc1f 	cmp	w0, #0x37
 11304f4:	54000569 	b.ls	11305a0 <md5_done+0x110>  // b.plast
    STORE64L(md->md5.length, md->md5.buf+56);
 11304f8:	aa1303e0 	mov	x0, x19
 11304fc:	910123f6 	add	x22, sp, #0x48
 1130500:	d2800102 	mov	x2, #0x8                   	// #8
        STORE32L(md->md5.state[i], out+(4*i));
 1130504:	91002277 	add	x23, x19, #0x8
    md5_compress(md, md->md5.buf);
 1130508:	d2800014 	mov	x20, #0x0                   	// #0
    STORE64L(md->md5.length, md->md5.buf+56);
 113050c:	f8454401 	ldr	x1, [x0], #84
 1130510:	f90027e1 	str	x1, [sp, #72]
 1130514:	aa1603e1 	mov	x1, x22
 1130518:	97ff4b9e 	bl	1103390 <memcpy>
    md5_compress(md, md->md5.buf);
 113051c:	91007261 	add	x1, x19, #0x1c
 1130520:	aa1303e0 	mov	x0, x19
 1130524:	97fffefa 	bl	113010c <md5_compress>
        STORE32L(md->md5.state[i], out+(4*i));
 1130528:	b8746ae0 	ldr	w0, [x23, x20]
 113052c:	aa1603e1 	mov	x1, x22
 1130530:	d2800082 	mov	x2, #0x4                   	// #4
 1130534:	b9004be0 	str	w0, [sp, #72]
 1130538:	8b1402a0 	add	x0, x21, x20
 113053c:	91001294 	add	x20, x20, #0x4
 1130540:	97ff4b94 	bl	1103390 <memcpy>
    for (i = 0; i < 4; i++) {
 1130544:	f100429f 	cmp	x20, #0x10
 1130548:	54ffff01 	b.ne	1130528 <md5_done+0x98>  // b.any
    zeromem(md, sizeof(hash_state));
 113054c:	aa1303e0 	mov	x0, x19
 1130550:	d2801a01 	mov	x1, #0xd0                  	// #208
 1130554:	940007bc 	bl	1132444 <zeromem>
 1130558:	52800000 	mov	w0, #0x0                   	// #0
}
 113055c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1130560:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1130564:	f9401bf7 	ldr	x23, [sp, #48]
 1130568:	a8c57bfd 	ldp	x29, x30, [sp], #80
 113056c:	d65f03c0 	ret
            md->md5.buf[md->md5.curlen++] = (unsigned char)0;
 1130570:	11000401 	add	w1, w0, #0x1
 1130574:	8b204260 	add	x0, x19, w0, uxtw
 1130578:	b9001a61 	str	w1, [x19, #24]
 113057c:	3900701f 	strb	wzr, [x0, #28]
        while (md->md5.curlen < 64) {
 1130580:	b9401a60 	ldr	w0, [x19, #24]
 1130584:	7100fc1f 	cmp	w0, #0x3f
 1130588:	54ffff49 	b.ls	1130570 <md5_done+0xe0>  // b.plast
        md5_compress(md, md->md5.buf);
 113058c:	91007261 	add	x1, x19, #0x1c
 1130590:	aa1303e0 	mov	x0, x19
 1130594:	97fffede 	bl	113010c <md5_compress>
        md->md5.curlen = 0;
 1130598:	b9001a7f 	str	wzr, [x19, #24]
 113059c:	17ffffd4 	b	11304ec <md5_done+0x5c>
        md->md5.buf[md->md5.curlen++] = (unsigned char)0;
 11305a0:	11000401 	add	w1, w0, #0x1
 11305a4:	8b204260 	add	x0, x19, w0, uxtw
 11305a8:	b9001a61 	str	w1, [x19, #24]
 11305ac:	3900701f 	strb	wzr, [x0, #28]
 11305b0:	17ffffcf 	b	11304ec <md5_done+0x5c>
    LTC_ARGCHK(md  != NULL);
 11305b4:	52800200 	mov	w0, #0x10                  	// #16
}
 11305b8:	d65f03c0 	ret
    LTC_ARGCHK(md  != NULL);
 11305bc:	52800200 	mov	w0, #0x10                  	// #16
 11305c0:	17ffffe7 	b	113055c <md5_done+0xcc>

00000000011305c4 <sha1_init>:
   @param md   The hash state you wish to initialize
   @return CRYPT_OK if successful
*/
int sha1_init(hash_state * md)
{
   LTC_ARGCHK(md != NULL);
 11305c4:	b4000200 	cbz	x0, 1130604 <sha1_init+0x40>
   md->sha1.state[0] = 0x67452301UL;
 11305c8:	d2846021 	mov	x1, #0x2301                	// #8961
 11305cc:	f2ace8a1 	movk	x1, #0x6745, lsl #16
 11305d0:	f2d57121 	movk	x1, #0xab89, lsl #32
 11305d4:	f2fdf9a1 	movk	x1, #0xefcd, lsl #48
 11305d8:	a900041f 	stp	xzr, x1, [x0]
   md->sha1.state[1] = 0xefcdab89UL;
   md->sha1.state[2] = 0x98badcfeUL;
 11305dc:	d29b9fc1 	mov	x1, #0xdcfe                	// #56574
 11305e0:	f2b31741 	movk	x1, #0x98ba, lsl #16
 11305e4:	f2ca8ec1 	movk	x1, #0x5476, lsl #32
 11305e8:	f2e20641 	movk	x1, #0x1032, lsl #48
 11305ec:	f9000801 	str	x1, [x0, #16]
   md->sha1.state[3] = 0x10325476UL;
   md->sha1.state[4] = 0xc3d2e1f0UL;
 11305f0:	d29c3e01 	mov	x1, #0xe1f0                	// #57840
 11305f4:	f2b87a41 	movk	x1, #0xc3d2, lsl #16
 11305f8:	f9000c01 	str	x1, [x0, #24]
   md->sha1.curlen = 0;
   md->sha1.length = 0;
   return CRYPT_OK;
 11305fc:	52800000 	mov	w0, #0x0                   	// #0
}
 1130600:	d65f03c0 	ret
   LTC_ARGCHK(md != NULL);
 1130604:	52800200 	mov	w0, #0x10                  	// #16
 1130608:	17fffffe 	b	1130600 <sha1_init+0x3c>

000000000113060c <sha1_test>:
         return CRYPT_FAIL_TESTVECTOR;
      }
  }
  return CRYPT_OK;
  #endif
}
 113060c:	52800040 	mov	w0, #0x2                   	// #2
 1130610:	d65f03c0 	ret

0000000001130614 <_sha1_compress>:
{
 1130614:	a9a87bfd 	stp	x29, x30, [sp, #-384]!
 1130618:	910003fd 	mov	x29, sp
 113061c:	a90153f3 	stp	x19, x20, [sp, #16]
 1130620:	910103f3 	add	x19, sp, #0x40
 1130624:	aa0003f4 	mov	x20, x0
 1130628:	aa1303e3 	mov	x3, x19
 113062c:	a9025bf5 	stp	x21, x22, [sp, #32]
 1130630:	aa0103f6 	mov	x22, x1
 1130634:	aa1303f5 	mov	x21, x19
 1130638:	f9001bf7 	str	x23, [sp, #48]
 113063c:	91010037 	add	x23, x1, #0x40
        LOAD32H(W[i], buf + (4*i));
 1130640:	aa1603e1 	mov	x1, x22
 1130644:	aa0303e0 	mov	x0, x3
 1130648:	d2800082 	mov	x2, #0x4                   	// #4
 113064c:	97ff4b51 	bl	1103390 <memcpy>
 1130650:	aa0003e3 	mov	x3, x0
 1130654:	b9400000 	ldr	w0, [x0]
 1130658:	910012d6 	add	x22, x22, #0x4
 113065c:	5ac00800 	rev	w0, w0
    for (i = 0; i < 16; i++) {
 1130660:	eb1602ff 	cmp	x23, x22
        LOAD32H(W[i], buf + (4*i));
 1130664:	b8004460 	str	w0, [x3], #4
    for (i = 0; i < 16; i++) {
 1130668:	54fffec1 	b.ne	1130640 <_sha1_compress+0x2c>  // b.any
    b = md->sha1.state[1];
 113066c:	2941268a 	ldp	w10, w9, [x20, #8]
    for (i = 16; i < 80; i++) {
 1130670:	52800202 	mov	w2, #0x10                  	// #16
    d = md->sha1.state[3];
 1130674:	29421e88 	ldp	w8, w7, [x20, #16]
    e = md->sha1.state[4];
 1130678:	b9401a80 	ldr	w0, [x20, #24]
        W[i] = ROL(W[i-3] ^ W[i-8] ^ W[i-14] ^ W[i-16], 1);
 113067c:	b9402263 	ldr	w3, [x19, #32]
    for (i = 16; i < 80; i++) {
 1130680:	11000442 	add	w2, w2, #0x1
        W[i] = ROL(W[i-3] ^ W[i-8] ^ W[i-14] ^ W[i-16], 1);
 1130684:	b9403661 	ldr	w1, [x19, #52]
    for (i = 16; i < 80; i++) {
 1130688:	7101405f 	cmp	w2, #0x50
        W[i] = ROL(W[i-3] ^ W[i-8] ^ W[i-14] ^ W[i-16], 1);
 113068c:	b9400264 	ldr	w4, [x19]
 1130690:	91001273 	add	x19, x19, #0x4
 1130694:	4a030021 	eor	w1, w1, w3
 1130698:	b9400663 	ldr	w3, [x19, #4]
 113069c:	4a040063 	eor	w3, w3, w4
 11306a0:	4a030021 	eor	w1, w1, w3
 11306a4:	13817c21 	ror	w1, w1, #31
 11306a8:	b9003e61 	str	w1, [x19, #60]
    for (i = 16; i < 80; i++) {
 11306ac:	54fffe81 	b.ne	113067c <_sha1_compress+0x68>  // b.any
 11306b0:	528f332e 	mov	w14, #0x7999                	// #31129
    e = md->sha1.state[4];
 11306b4:	2a0003e6 	mov	w6, w0
    d = md->sha1.state[3];
 11306b8:	2a0703e2 	mov	w2, w7
    c = md->sha1.state[2];
 11306bc:	2a0803ec 	mov	w12, w8
    b = md->sha1.state[1];
 11306c0:	2a0903e5 	mov	w5, w9
    a = md->sha1.state[0];
 11306c4:	2a0a03ed 	mov	w13, w10
 11306c8:	d2800004 	mov	x4, #0x0                   	// #0
 11306cc:	72ab504e 	movk	w14, #0x5a82, lsl #16
       FF0(a,b,c,d,e,i++); t = e; e = d; d = c; c = b; b = a; a = t;
 11306d0:	4a020181 	eor	w1, w12, w2
 11306d4:	b8647aab 	ldr	w11, [x21, x4, lsl #2]
 11306d8:	0a050021 	and	w1, w1, w5
 11306dc:	91000484 	add	x4, x4, #0x1
 11306e0:	4a020021 	eor	w1, w1, w2
    for (i = 0; i < 20; ) {
 11306e4:	f100509f 	cmp	x4, #0x14
 11306e8:	0b0e0023 	add	w3, w1, w14
       FF0(a,b,c,d,e,i++); t = e; e = d; d = c; c = b; b = a; a = t;
 11306ec:	138d6da1 	ror	w1, w13, #27
 11306f0:	0b0b0021 	add	w1, w1, w11
 11306f4:	138508ab 	ror	w11, w5, #2
 11306f8:	0b010061 	add	w1, w3, w1
 11306fc:	2a0d03e5 	mov	w5, w13
 1130700:	0b060021 	add	w1, w1, w6
    for (i = 0; i < 20; ) {
 1130704:	2a0203e6 	mov	w6, w2
 1130708:	54000821 	b.ne	113080c <_sha1_compress+0x1f8>  // b.any
 113070c:	529d742e 	mov	w14, #0xeba1                	// #60321
 1130710:	72addb2e 	movk	w14, #0x6ed9, lsl #16
       FF1(a,b,c,d,e,i++); t = e; e = d; d = c; c = b; b = a; a = t;
 1130714:	b8647aa3 	ldr	w3, [x21, x4, lsl #2]
 1130718:	13816c25 	ror	w5, w1, #27
 113071c:	91000484 	add	x4, x4, #0x1
 1130720:	138d09a6 	ror	w6, w13, #2
 1130724:	0b0300a5 	add	w5, w5, w3
 1130728:	4a0b01a3 	eor	w3, w13, w11
 113072c:	4a0c0063 	eor	w3, w3, w12
 1130730:	2a0103ed 	mov	w13, w1
 1130734:	0b0e0063 	add	w3, w3, w14
    for (; i < 40; ) {
 1130738:	f100a09f 	cmp	x4, #0x28
 113073c:	0b0300a5 	add	w5, w5, w3
       FF1(a,b,c,d,e,i++); t = e; e = d; d = c; c = b; b = a; a = t;
 1130740:	0b0200a5 	add	w5, w5, w2
    for (; i < 40; ) {
 1130744:	2a0c03e2 	mov	w2, w12
 1130748:	540006a1 	b.ne	113081c <_sha1_compress+0x208>  // b.any
 113074c:	52979b8e 	mov	w14, #0xbcdc                	// #48348
 1130750:	72b1e36e 	movk	w14, #0x8f1b, lsl #16
       FF2(a,b,c,d,e,i++); t = e; e = d; d = c; c = b; b = a; a = t;
 1130754:	2a060022 	orr	w2, w1, w6
 1130758:	0a060023 	and	w3, w1, w6
 113075c:	0a0b0042 	and	w2, w2, w11
 1130760:	b8647aad 	ldr	w13, [x21, x4, lsl #2]
 1130764:	2a030042 	orr	w2, w2, w3
 1130768:	91000484 	add	x4, x4, #0x1
 113076c:	0b0e0043 	add	w3, w2, w14
 1130770:	13856ca2 	ror	w2, w5, #27
 1130774:	0b0d0042 	add	w2, w2, w13
    for (; i < 60; ) {
 1130778:	f100f09f 	cmp	x4, #0x3c
 113077c:	0b020062 	add	w2, w3, w2
       FF2(a,b,c,d,e,i++); t = e; e = d; d = c; c = b; b = a; a = t;
 1130780:	13810823 	ror	w3, w1, #2
 1130784:	0b020182 	add	w2, w12, w2
    for (; i < 60; ) {
 1130788:	2a0503e1 	mov	w1, w5
 113078c:	2a0b03ec 	mov	w12, w11
 1130790:	540004e1 	b.ne	113082c <_sha1_compress+0x218>  // b.any
 1130794:	52983acd 	mov	w13, #0xc1d6                	// #49622
 1130798:	72b94c4d 	movk	w13, #0xca62, lsl #16
       FF3(a,b,c,d,e,i++); t = e; e = d; d = c; c = b; b = a; a = t;
 113079c:	b8647aac 	ldr	w12, [x21, x4, lsl #2]
 11307a0:	13826c41 	ror	w1, w2, #27
 11307a4:	91000484 	add	x4, x4, #0x1
 11307a8:	0b0c0021 	add	w1, w1, w12
 11307ac:	4a0300ac 	eor	w12, w5, w3
 11307b0:	4a06018c 	eor	w12, w12, w6
    for (; i < 80; ) {
 11307b4:	f101409f 	cmp	x4, #0x50
 11307b8:	0b0d018c 	add	w12, w12, w13
 11307bc:	0b0c0021 	add	w1, w1, w12
       FF3(a,b,c,d,e,i++); t = e; e = d; d = c; c = b; b = a; a = t;
 11307c0:	138508ac 	ror	w12, w5, #2
 11307c4:	0b010161 	add	w1, w11, w1
    for (; i < 80; ) {
 11307c8:	2a0203e5 	mov	w5, w2
 11307cc:	2a0603eb 	mov	w11, w6
 11307d0:	54000361 	b.ne	113083c <_sha1_compress+0x228>  // b.any
    md->sha1.state[4] = md->sha1.state[4] + e;
 11307d4:	0b060006 	add	w6, w0, w6
    md->sha1.state[0] = md->sha1.state[0] + a;
 11307d8:	0b010141 	add	w1, w10, w1
    md->sha1.state[1] = md->sha1.state[1] + b;
 11307dc:	0b020122 	add	w2, w9, w2
    md->sha1.state[2] = md->sha1.state[2] + c;
 11307e0:	0b0c0108 	add	w8, w8, w12
    md->sha1.state[3] = md->sha1.state[3] + d;
 11307e4:	0b0300e7 	add	w7, w7, w3
}
 11307e8:	52800000 	mov	w0, #0x0                   	// #0
 11307ec:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11307f0:	f9401bf7 	ldr	x23, [sp, #48]
    md->sha1.state[1] = md->sha1.state[1] + b;
 11307f4:	29010a81 	stp	w1, w2, [x20, #8]
    md->sha1.state[3] = md->sha1.state[3] + d;
 11307f8:	29021e88 	stp	w8, w7, [x20, #16]
    md->sha1.state[4] = md->sha1.state[4] + e;
 11307fc:	b9001a86 	str	w6, [x20, #24]
}
 1130800:	a94153f3 	ldp	x19, x20, [sp, #16]
 1130804:	a8d87bfd 	ldp	x29, x30, [sp], #384
 1130808:	d65f03c0 	ret
 113080c:	2a0c03e2 	mov	w2, w12
       FF0(a,b,c,d,e,i++); t = e; e = d; d = c; c = b; b = a; a = t;
 1130810:	2a0103ed 	mov	w13, w1
 1130814:	2a0b03ec 	mov	w12, w11
 1130818:	17ffffae 	b	11306d0 <_sha1_compress+0xbc>
 113081c:	2a0b03ec 	mov	w12, w11
       FF1(a,b,c,d,e,i++); t = e; e = d; d = c; c = b; b = a; a = t;
 1130820:	2a0503e1 	mov	w1, w5
 1130824:	2a0603eb 	mov	w11, w6
 1130828:	17ffffbb 	b	1130714 <_sha1_compress+0x100>
 113082c:	2a0603eb 	mov	w11, w6
       FF2(a,b,c,d,e,i++); t = e; e = d; d = c; c = b; b = a; a = t;
 1130830:	2a0203e5 	mov	w5, w2
 1130834:	2a0303e6 	mov	w6, w3
 1130838:	17ffffc7 	b	1130754 <_sha1_compress+0x140>
 113083c:	2a0303e6 	mov	w6, w3
       FF3(a,b,c,d,e,i++); t = e; e = d; d = c; c = b; b = a; a = t;
 1130840:	2a0103e2 	mov	w2, w1
 1130844:	2a0c03e3 	mov	w3, w12
 1130848:	17ffffd5 	b	113079c <_sha1_compress+0x188>

000000000113084c <sha1_compress>:
{
 113084c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1130850:	910003fd 	mov	x29, sp
 1130854:	f9000bf3 	str	x19, [sp, #16]
   err = _sha1_compress(md, buf);
 1130858:	97ffff6f 	bl	1130614 <_sha1_compress>
 113085c:	2a0003f3 	mov	w19, w0
   burn_stack(sizeof(ulong32) * 87);
 1130860:	d2802b80 	mov	x0, #0x15c                 	// #348
 1130864:	940006ed 	bl	1132418 <burn_stack>
}
 1130868:	2a1303e0 	mov	w0, w19
 113086c:	f9400bf3 	ldr	x19, [sp, #16]
 1130870:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1130874:	d65f03c0 	ret

0000000001130878 <sha1_process>:
HASH_PROCESS(sha1_process, sha1_compress, sha1, 64)
 1130878:	b40007c0 	cbz	x0, 1130970 <sha1_process+0xf8>
 113087c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 1130880:	910003fd 	mov	x29, sp
 1130884:	a90153f3 	stp	x19, x20, [sp, #16]
 1130888:	a9025bf5 	stp	x21, x22, [sp, #32]
 113088c:	aa0103f5 	mov	x21, x1
 1130890:	a90363f7 	stp	x23, x24, [sp, #48]
 1130894:	b4000721 	cbz	x1, 1130978 <sha1_process+0x100>
 1130898:	aa0003f3 	mov	x19, x0
 113089c:	b9401c00 	ldr	w0, [x0, #28]
 11308a0:	7101001f 	cmp	w0, #0x40
 11308a4:	540006a8 	b.hi	1130978 <sha1_process+0x100>  // b.pmore
 11308a8:	f9400260 	ldr	x0, [x19]
 11308ac:	aa0203f4 	mov	x20, x2
 11308b0:	ab02001f 	cmn	x0, x2
 11308b4:	54000662 	b.cs	1130980 <sha1_process+0x108>  // b.hs, b.nlast
 11308b8:	91008277 	add	x23, x19, #0x20
 11308bc:	52800818 	mov	w24, #0x40                  	// #64
 11308c0:	b50000f4 	cbnz	x20, 11308dc <sha1_process+0x64>
 11308c4:	52800000 	mov	w0, #0x0                   	// #0
 11308c8:	a94153f3 	ldp	x19, x20, [sp, #16]
 11308cc:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11308d0:	a94363f7 	ldp	x23, x24, [sp, #48]
 11308d4:	a8c47bfd 	ldp	x29, x30, [sp], #64
 11308d8:	d65f03c0 	ret
 11308dc:	b9401e60 	ldr	w0, [x19, #28]
 11308e0:	350001a0 	cbnz	w0, 1130914 <sha1_process+0x9c>
 11308e4:	f100fe9f 	cmp	x20, #0x3f
 11308e8:	54000169 	b.ls	1130914 <sha1_process+0x9c>  // b.plast
 11308ec:	aa1503e1 	mov	x1, x21
 11308f0:	aa1303e0 	mov	x0, x19
 11308f4:	97ffffd6 	bl	113084c <sha1_compress>
 11308f8:	35fffe80 	cbnz	w0, 11308c8 <sha1_process+0x50>
 11308fc:	f9400260 	ldr	x0, [x19]
 1130900:	910102b5 	add	x21, x21, #0x40
 1130904:	d1010294 	sub	x20, x20, #0x40
 1130908:	91080000 	add	x0, x0, #0x200
 113090c:	f9000260 	str	x0, [x19]
 1130910:	17ffffec 	b	11308c0 <sha1_process+0x48>
 1130914:	4b000316 	sub	w22, w24, w0
 1130918:	aa1503e1 	mov	x1, x21
 113091c:	eb1402df 	cmp	x22, x20
 1130920:	8b2042e0 	add	x0, x23, w0, uxtw
 1130924:	9a9492d6 	csel	x22, x22, x20, ls  // ls = plast
 1130928:	aa1603e2 	mov	x2, x22
 113092c:	8b1602b5 	add	x21, x21, x22
 1130930:	97ff4a98 	bl	1103390 <memcpy>
 1130934:	cb160294 	sub	x20, x20, x22
 1130938:	b9401e60 	ldr	w0, [x19, #28]
 113093c:	0b160000 	add	w0, w0, w22
 1130940:	b9001e60 	str	w0, [x19, #28]
 1130944:	7101001f 	cmp	w0, #0x40
 1130948:	54fffbc1 	b.ne	11308c0 <sha1_process+0x48>  // b.any
 113094c:	aa1703e1 	mov	x1, x23
 1130950:	aa1303e0 	mov	x0, x19
 1130954:	97ffffbe 	bl	113084c <sha1_compress>
 1130958:	35fffb80 	cbnz	w0, 11308c8 <sha1_process+0x50>
 113095c:	f9400260 	ldr	x0, [x19]
 1130960:	b9001e7f 	str	wzr, [x19, #28]
 1130964:	91080000 	add	x0, x0, #0x200
 1130968:	f9000260 	str	x0, [x19]
 113096c:	17ffffd5 	b	11308c0 <sha1_process+0x48>
 1130970:	52800200 	mov	w0, #0x10                  	// #16
 1130974:	d65f03c0 	ret
 1130978:	52800200 	mov	w0, #0x10                  	// #16
 113097c:	17ffffd3 	b	11308c8 <sha1_process+0x50>
 1130980:	52800320 	mov	w0, #0x19                  	// #25
 1130984:	17ffffd1 	b	11308c8 <sha1_process+0x50>

0000000001130988 <sha1_done>:
    LTC_ARGCHK(md  != NULL);
 1130988:	b4000960 	cbz	x0, 1130ab4 <sha1_done+0x12c>
{
 113098c:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 1130990:	910003fd 	mov	x29, sp
 1130994:	a90153f3 	stp	x19, x20, [sp, #16]
 1130998:	a9025bf5 	stp	x21, x22, [sp, #32]
 113099c:	aa0103f5 	mov	x21, x1
 11309a0:	f9001bf7 	str	x23, [sp, #48]
    LTC_ARGCHK(out != NULL);
 11309a4:	b40008c1 	cbz	x1, 1130abc <sha1_done+0x134>
 11309a8:	aa0003f3 	mov	x19, x0
    if (md->sha1.curlen >= sizeof(md->sha1.buf)) {
 11309ac:	b9401c00 	ldr	w0, [x0, #28]
 11309b0:	7100fc1f 	cmp	w0, #0x3f
 11309b4:	54000848 	b.hi	1130abc <sha1_done+0x134>  // b.pmore
    md->sha1.length += md->sha1.curlen * 8;
 11309b8:	f9400261 	ldr	x1, [x19]
 11309bc:	531d7002 	lsl	w2, w0, #3
 11309c0:	8b020021 	add	x1, x1, x2
 11309c4:	f9000261 	str	x1, [x19]
    md->sha1.buf[md->sha1.curlen++] = (unsigned char)0x80;
 11309c8:	11000401 	add	w1, w0, #0x1
 11309cc:	8b204260 	add	x0, x19, w0, uxtw
 11309d0:	b9001e61 	str	w1, [x19, #28]
 11309d4:	12800fe2 	mov	w2, #0xffffff80            	// #-128
    if (md->sha1.curlen > 56) {
 11309d8:	7100e03f 	cmp	w1, #0x38
    md->sha1.buf[md->sha1.curlen++] = (unsigned char)0x80;
 11309dc:	39008002 	strb	w2, [x0, #32]
    if (md->sha1.curlen > 56) {
 11309e0:	54000508 	b.hi	1130a80 <sha1_done+0xf8>  // b.pmore
    while (md->sha1.curlen < 56) {
 11309e4:	b9401e60 	ldr	w0, [x19, #28]
 11309e8:	7100dc1f 	cmp	w0, #0x37
 11309ec:	540005a9 	b.ls	1130aa0 <sha1_done+0x118>  // b.plast
    STORE64H(md->sha1.length, md->sha1.buf+56);
 11309f0:	aa1303e0 	mov	x0, x19
 11309f4:	910123f6 	add	x22, sp, #0x48
 11309f8:	d2800102 	mov	x2, #0x8                   	// #8
        STORE32H(md->sha1.state[i], out+(4*i));
 11309fc:	91002277 	add	x23, x19, #0x8
    sha1_compress(md, md->sha1.buf);
 1130a00:	d2800014 	mov	x20, #0x0                   	// #0
    STORE64H(md->sha1.length, md->sha1.buf+56);
 1130a04:	f8458401 	ldr	x1, [x0], #88
 1130a08:	dac00c21 	rev	x1, x1
 1130a0c:	f90027e1 	str	x1, [sp, #72]
 1130a10:	aa1603e1 	mov	x1, x22
 1130a14:	97ff4a5f 	bl	1103390 <memcpy>
    sha1_compress(md, md->sha1.buf);
 1130a18:	91008261 	add	x1, x19, #0x20
 1130a1c:	aa1303e0 	mov	x0, x19
 1130a20:	97ffff8b 	bl	113084c <sha1_compress>
        STORE32H(md->sha1.state[i], out+(4*i));
 1130a24:	b8746ae0 	ldr	w0, [x23, x20]
 1130a28:	aa1603e1 	mov	x1, x22
 1130a2c:	d2800082 	mov	x2, #0x4                   	// #4
 1130a30:	5ac00800 	rev	w0, w0
 1130a34:	b9004be0 	str	w0, [sp, #72]
 1130a38:	8b1402a0 	add	x0, x21, x20
 1130a3c:	91001294 	add	x20, x20, #0x4
 1130a40:	97ff4a54 	bl	1103390 <memcpy>
    for (i = 0; i < 5; i++) {
 1130a44:	f100529f 	cmp	x20, #0x14
 1130a48:	54fffee1 	b.ne	1130a24 <sha1_done+0x9c>  // b.any
    zeromem(md, sizeof(hash_state));
 1130a4c:	aa1303e0 	mov	x0, x19
 1130a50:	d2801a01 	mov	x1, #0xd0                  	// #208
 1130a54:	9400067c 	bl	1132444 <zeromem>
 1130a58:	52800000 	mov	w0, #0x0                   	// #0
}
 1130a5c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1130a60:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1130a64:	f9401bf7 	ldr	x23, [sp, #48]
 1130a68:	a8c57bfd 	ldp	x29, x30, [sp], #80
 1130a6c:	d65f03c0 	ret
            md->sha1.buf[md->sha1.curlen++] = (unsigned char)0;
 1130a70:	11000401 	add	w1, w0, #0x1
 1130a74:	8b204260 	add	x0, x19, w0, uxtw
 1130a78:	b9001e61 	str	w1, [x19, #28]
 1130a7c:	3900801f 	strb	wzr, [x0, #32]
        while (md->sha1.curlen < 64) {
 1130a80:	b9401e60 	ldr	w0, [x19, #28]
 1130a84:	7100fc1f 	cmp	w0, #0x3f
 1130a88:	54ffff49 	b.ls	1130a70 <sha1_done+0xe8>  // b.plast
        sha1_compress(md, md->sha1.buf);
 1130a8c:	91008261 	add	x1, x19, #0x20
 1130a90:	aa1303e0 	mov	x0, x19
 1130a94:	97ffff6e 	bl	113084c <sha1_compress>
        md->sha1.curlen = 0;
 1130a98:	b9001e7f 	str	wzr, [x19, #28]
 1130a9c:	17ffffd2 	b	11309e4 <sha1_done+0x5c>
        md->sha1.buf[md->sha1.curlen++] = (unsigned char)0;
 1130aa0:	11000401 	add	w1, w0, #0x1
 1130aa4:	8b204260 	add	x0, x19, w0, uxtw
 1130aa8:	b9001e61 	str	w1, [x19, #28]
 1130aac:	3900801f 	strb	wzr, [x0, #32]
 1130ab0:	17ffffcd 	b	11309e4 <sha1_done+0x5c>
    LTC_ARGCHK(md  != NULL);
 1130ab4:	52800200 	mov	w0, #0x10                  	// #16
}
 1130ab8:	d65f03c0 	ret
    LTC_ARGCHK(md  != NULL);
 1130abc:	52800200 	mov	w0, #0x10                  	// #16
 1130ac0:	17ffffe7 	b	1130a5c <sha1_done+0xd4>

0000000001130ac4 <sha224_init>:
   @param md   The hash state you wish to initialize
   @return CRYPT_OK if successful
*/
int sha224_init(hash_state * md)
{
    LTC_ARGCHK(md != NULL);
 1130ac4:	b4000300 	cbz	x0, 1130b24 <sha224_init+0x60>

    md->sha256.curlen = 0;
    md->sha256.length = 0;
    md->sha256.state[0] = 0xc1059ed8UL;
 1130ac8:	d293db01 	mov	x1, #0x9ed8                	// #40664
    md->sha256.curlen = 0;
 1130acc:	b900281f 	str	wzr, [x0, #40]
    md->sha256.state[0] = 0xc1059ed8UL;
 1130ad0:	f2b820a1 	movk	x1, #0xc105, lsl #16
 1130ad4:	f2daa0e1 	movk	x1, #0xd507, lsl #32
 1130ad8:	f2e6cf81 	movk	x1, #0x367c, lsl #48
 1130adc:	a900041f 	stp	xzr, x1, [x0]
    md->sha256.state[1] = 0x367cd507UL;
    md->sha256.state[2] = 0x3070dd17UL;
 1130ae0:	d29ba2e1 	mov	x1, #0xdd17                	// #56599
 1130ae4:	f2a60e01 	movk	x1, #0x3070, lsl #16
 1130ae8:	f2cb2721 	movk	x1, #0x5939, lsl #32
 1130aec:	f2fee1c1 	movk	x1, #0xf70e, lsl #48
 1130af0:	f9000801 	str	x1, [x0, #16]
    md->sha256.state[3] = 0xf70e5939UL;
    md->sha256.state[4] = 0xffc00b31UL;
 1130af4:	d2816621 	mov	x1, #0xb31                 	// #2865
 1130af8:	f2bff801 	movk	x1, #0xffc0, lsl #16
 1130afc:	f2c2a221 	movk	x1, #0x1511, lsl #32
 1130b00:	f2ed0b01 	movk	x1, #0x6858, lsl #48
 1130b04:	f9000c01 	str	x1, [x0, #24]
    md->sha256.state[5] = 0x68581511UL;
    md->sha256.state[6] = 0x64f98fa7UL;
 1130b08:	d291f4e1 	mov	x1, #0x8fa7                	// #36775
 1130b0c:	f2ac9f21 	movk	x1, #0x64f9, lsl #16
 1130b10:	f2c9f481 	movk	x1, #0x4fa4, lsl #32
 1130b14:	f2f7df41 	movk	x1, #0xbefa, lsl #48
 1130b18:	f9001001 	str	x1, [x0, #32]
    md->sha256.state[7] = 0xbefa4fa4UL;
    return CRYPT_OK;
 1130b1c:	52800000 	mov	w0, #0x0                   	// #0
}
 1130b20:	d65f03c0 	ret
    LTC_ARGCHK(md != NULL);
 1130b24:	52800200 	mov	w0, #0x10                  	// #16
 1130b28:	17fffffe 	b	1130b20 <sha224_init+0x5c>

0000000001130b2c <sha224_test>:
         return CRYPT_FAIL_TESTVECTOR;
      }
  }
  return CRYPT_OK;
 #endif
}
 1130b2c:	52800040 	mov	w0, #0x2                   	// #2
 1130b30:	d65f03c0 	ret

0000000001130b34 <sha224_done>:
{
 1130b34:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 1130b38:	910003fd 	mov	x29, sp
 1130b3c:	a90153f3 	stp	x19, x20, [sp, #16]
 1130b40:	f90013f5 	str	x21, [sp, #32]
    LTC_ARGCHK(md  != NULL);
 1130b44:	b4000260 	cbz	x0, 1130b90 <sha224_done+0x5c>
 1130b48:	aa0103f4 	mov	x20, x1
    LTC_ARGCHK(out != NULL);
 1130b4c:	b4000221 	cbz	x1, 1130b90 <sha224_done+0x5c>
    err = sha256_done(md, buf);
 1130b50:	9100c3f5 	add	x21, sp, #0x30
 1130b54:	aa1503e1 	mov	x1, x21
 1130b58:	940000e6 	bl	1130ef0 <sha256_done>
    XMEMCPY(out, buf, 28);
 1130b5c:	d2800382 	mov	x2, #0x1c                  	// #28
 1130b60:	aa1503e1 	mov	x1, x21
    err = sha256_done(md, buf);
 1130b64:	2a0003f3 	mov	w19, w0
    XMEMCPY(out, buf, 28);
 1130b68:	aa1403e0 	mov	x0, x20
 1130b6c:	97ff4a09 	bl	1103390 <memcpy>
    zeromem(buf, sizeof(buf));
 1130b70:	aa1503e0 	mov	x0, x21
 1130b74:	d2800401 	mov	x1, #0x20                  	// #32
 1130b78:	94000633 	bl	1132444 <zeromem>
}
 1130b7c:	2a1303e0 	mov	w0, w19
 1130b80:	a94153f3 	ldp	x19, x20, [sp, #16]
 1130b84:	f94013f5 	ldr	x21, [sp, #32]
 1130b88:	a8c57bfd 	ldp	x29, x30, [sp], #80
 1130b8c:	d65f03c0 	ret
    LTC_ARGCHK(md  != NULL);
 1130b90:	52800213 	mov	w19, #0x10                  	// #16
 1130b94:	17fffffa 	b	1130b7c <sha224_done+0x48>

0000000001130b98 <sha256_init>:
   @param md   The hash state you wish to initialize
   @return CRYPT_OK if successful
*/
int sha256_init(hash_state * md)
{
    LTC_ARGCHK(md != NULL);
 1130b98:	b4000300 	cbz	x0, 1130bf8 <sha256_init+0x60>

    md->sha256.curlen = 0;
    md->sha256.length = 0;
    md->sha256.state[0] = 0x6A09E667UL;
 1130b9c:	d29ccce1 	mov	x1, #0xe667                	// #58983
    md->sha256.curlen = 0;
 1130ba0:	b900281f 	str	wzr, [x0, #40]
    md->sha256.state[0] = 0x6A09E667UL;
 1130ba4:	f2ad4121 	movk	x1, #0x6a09, lsl #16
 1130ba8:	f2d5d0a1 	movk	x1, #0xae85, lsl #32
 1130bac:	f2f76ce1 	movk	x1, #0xbb67, lsl #48
 1130bb0:	a900041f 	stp	xzr, x1, [x0]
    md->sha256.state[1] = 0xBB67AE85UL;
    md->sha256.state[2] = 0x3C6EF372UL;
 1130bb4:	d29e6e41 	mov	x1, #0xf372                	// #62322
 1130bb8:	f2a78dc1 	movk	x1, #0x3c6e, lsl #16
 1130bbc:	f2dea741 	movk	x1, #0xf53a, lsl #32
 1130bc0:	f2f4a9e1 	movk	x1, #0xa54f, lsl #48
 1130bc4:	f9000801 	str	x1, [x0, #16]
    md->sha256.state[3] = 0xA54FF53AUL;
    md->sha256.state[4] = 0x510E527FUL;
 1130bc8:	d28a4fe1 	mov	x1, #0x527f                	// #21119
 1130bcc:	f2aa21c1 	movk	x1, #0x510e, lsl #16
 1130bd0:	f2cd1181 	movk	x1, #0x688c, lsl #32
 1130bd4:	f2f360a1 	movk	x1, #0x9b05, lsl #48
 1130bd8:	f9000c01 	str	x1, [x0, #24]
    md->sha256.state[5] = 0x9B05688CUL;
    md->sha256.state[6] = 0x1F83D9ABUL;
 1130bdc:	d29b3561 	mov	x1, #0xd9ab                	// #55723
 1130be0:	f2a3f061 	movk	x1, #0x1f83, lsl #16
 1130be4:	f2d9a321 	movk	x1, #0xcd19, lsl #32
 1130be8:	f2eb7c01 	movk	x1, #0x5be0, lsl #48
 1130bec:	f9001001 	str	x1, [x0, #32]
    md->sha256.state[7] = 0x5BE0CD19UL;
    return CRYPT_OK;
 1130bf0:	52800000 	mov	w0, #0x0                   	// #0
}
 1130bf4:	d65f03c0 	ret
    LTC_ARGCHK(md != NULL);
 1130bf8:	52800200 	mov	w0, #0x10                  	// #16
 1130bfc:	17fffffe 	b	1130bf4 <sha256_init+0x5c>

0000000001130c00 <sha256_test>:
         return CRYPT_FAIL_TESTVECTOR;
      }
  }
  return CRYPT_OK;
 #endif
}
 1130c00:	52800040 	mov	w0, #0x2                   	// #2
 1130c04:	d65f03c0 	ret

0000000001130c08 <_sha256_compress>:
{
 1130c08:	a9aa7bfd 	stp	x29, x30, [sp, #-352]!
 1130c0c:	910003fd 	mov	x29, sp
 1130c10:	a9025bf5 	stp	x21, x22, [sp, #32]
 1130c14:	91002015 	add	x21, x0, #0x8
        S[i] = md->sha256.state[i];
 1130c18:	910103f6 	add	x22, sp, #0x40
{
 1130c1c:	a90153f3 	stp	x19, x20, [sp, #16]
 1130c20:	aa0103f4 	mov	x20, x1
 1130c24:	d2800001 	mov	x1, #0x0                   	// #0
 1130c28:	a90363f7 	stp	x23, x24, [sp, #48]
        S[i] = md->sha256.state[i];
 1130c2c:	b8616aa0 	ldr	w0, [x21, x1]
 1130c30:	b8366820 	str	w0, [x1, x22]
    for (i = 0; i < 8; i++) {
 1130c34:	91001021 	add	x1, x1, #0x4
 1130c38:	f100803f 	cmp	x1, #0x20
 1130c3c:	54ffff81 	b.ne	1130c2c <_sha256_compress+0x24>  // b.any
 1130c40:	910183f3 	add	x19, sp, #0x60
 1130c44:	91010298 	add	x24, x20, #0x40
 1130c48:	aa1303e3 	mov	x3, x19
 1130c4c:	aa1303f7 	mov	x23, x19
        LOAD32H(W[i], buf + (4*i));
 1130c50:	aa1403e1 	mov	x1, x20
 1130c54:	aa0303e0 	mov	x0, x3
 1130c58:	d2800082 	mov	x2, #0x4                   	// #4
 1130c5c:	97ff49cd 	bl	1103390 <memcpy>
 1130c60:	aa0003e3 	mov	x3, x0
 1130c64:	b9400000 	ldr	w0, [x0]
 1130c68:	91001294 	add	x20, x20, #0x4
 1130c6c:	5ac00800 	rev	w0, w0
    for (i = 0; i < 16; i++) {
 1130c70:	eb14031f 	cmp	x24, x20
        LOAD32H(W[i], buf + (4*i));
 1130c74:	b8004460 	str	w0, [x3], #4
    for (i = 0; i < 16; i++) {
 1130c78:	54fffec1 	b.ne	1130c50 <_sha256_compress+0x48>  // b.any
    for (i = 16; i < 64; i++) {
 1130c7c:	52800202 	mov	w2, #0x10                  	// #16
        W[i] = Gamma1(W[i - 2]) + W[i - 7] + Gamma0(W[i - 15]) + W[i - 16];
 1130c80:	b9403a61 	ldr	w1, [x19, #56]
    for (i = 16; i < 64; i++) {
 1130c84:	11000442 	add	w2, w2, #0x1
        W[i] = Gamma1(W[i - 2]) + W[i - 7] + Gamma0(W[i - 15]) + W[i - 16];
 1130c88:	b9400660 	ldr	w0, [x19, #4]
    for (i = 16; i < 64; i++) {
 1130c8c:	7101005f 	cmp	w2, #0x40
 1130c90:	91001273 	add	x19, x19, #0x4
        W[i] = Gamma1(W[i - 2]) + W[i - 7] + Gamma0(W[i - 15]) + W[i - 16];
 1130c94:	13814c23 	ror	w3, w1, #19
 1130c98:	4ac14463 	eor	w3, w3, w1, ror #17
 1130c9c:	4a412861 	eor	w1, w3, w1, lsr #10
 1130ca0:	13804803 	ror	w3, w0, #18
 1130ca4:	4ac01c63 	eor	w3, w3, w0, ror #7
 1130ca8:	4a400c60 	eor	w0, w3, w0, lsr #3
 1130cac:	b85fc263 	ldur	w3, [x19, #-4]
 1130cb0:	0b000021 	add	w1, w1, w0
 1130cb4:	b9402260 	ldr	w0, [x19, #32]
 1130cb8:	0b030000 	add	w0, w0, w3
 1130cbc:	0b000021 	add	w1, w1, w0
 1130cc0:	b9003e61 	str	w1, [x19, #60]
    for (i = 16; i < 64; i++) {
 1130cc4:	54fffde1 	b.ne	1130c80 <_sha256_compress+0x78>  // b.any
 1130cc8:	294803e2 	ldp	w2, w0, [sp, #64]
         RND(S[0],S[1],S[2],S[3],S[4],S[5],S[6],S[7],i);
 1130ccc:	9000010a 	adrp	x10, 1150000 <Te4+0x258>
 1130cd0:	29492fe8 	ldp	w8, w11, [sp, #72]
 1130cd4:	910b414a 	add	x10, x10, #0x2d0
 1130cd8:	294a27e3 	ldp	w3, w9, [sp, #80]
    for (i = 16; i < 64; i++) {
 1130cdc:	d2800006 	mov	x6, #0x0                   	// #0
 1130ce0:	294b33e5 	ldp	w5, w12, [sp, #88]
         RND(S[0],S[1],S[2],S[3],S[4],S[5],S[6],S[7],i);
 1130ce4:	13832c61 	ror	w1, w3, #11
 1130ce8:	4a0900a4 	eor	w4, w5, w9
 1130cec:	4ac31821 	eor	w1, w1, w3, ror #6
 1130cf0:	0a030084 	and	w4, w4, w3
 1130cf4:	4ac36421 	eor	w1, w1, w3, ror #25
 1130cf8:	4a050084 	eor	w4, w4, w5
 1130cfc:	b8666ae7 	ldr	w7, [x23, x6]
 1130d00:	0b040021 	add	w1, w1, w4
 1130d04:	b86a68c4 	ldr	w4, [x6, x10]
 1130d08:	910010c6 	add	x6, x6, #0x4
 1130d0c:	0b070084 	add	w4, w4, w7
 1130d10:	2a020007 	orr	w7, w0, w2
 1130d14:	0b040021 	add	w1, w1, w4
 1130d18:	13823444 	ror	w4, w2, #13
 1130d1c:	0b0c0021 	add	w1, w1, w12
 1130d20:	4ac20884 	eor	w4, w4, w2, ror #2
 1130d24:	0a02000c 	and	w12, w0, w2
 1130d28:	0a0800e7 	and	w7, w7, w8
 1130d2c:	2a0c00e7 	orr	w7, w7, w12
 1130d30:	4ac25884 	eor	w4, w4, w2, ror #22
 1130d34:	0b070084 	add	w4, w4, w7
 1130d38:	2a0503ec 	mov	w12, w5
 1130d3c:	0b010167 	add	w7, w11, w1
     for (i = 0; i < 64; ++i) {
 1130d40:	f10400df 	cmp	x6, #0x100
         RND(S[0],S[1],S[2],S[3],S[4],S[5],S[6],S[7],i);
 1130d44:	0b040021 	add	w1, w1, w4
     for (i = 0; i < 64; ++i) {
 1130d48:	2a0803eb 	mov	w11, w8
 1130d4c:	54000261 	b.ne	1130d98 <_sha256_compress+0x190>  // b.any
 1130d50:	29080be1 	stp	w1, w2, [sp, #64]
 1130d54:	d2800001 	mov	x1, #0x0                   	// #0
 1130d58:	290923e0 	stp	w0, w8, [sp, #72]
 1130d5c:	290a0fe7 	stp	w7, w3, [sp, #80]
 1130d60:	290b17e9 	stp	w9, w5, [sp, #88]
        md->sha256.state[i] = md->sha256.state[i] + S[i];
 1130d64:	b8616aa0 	ldr	w0, [x21, x1]
 1130d68:	b8616ac2 	ldr	w2, [x22, x1]
 1130d6c:	0b020000 	add	w0, w0, w2
 1130d70:	b8216aa0 	str	w0, [x21, x1]
    for (i = 0; i < 8; i++) {
 1130d74:	91001021 	add	x1, x1, #0x4
 1130d78:	f100803f 	cmp	x1, #0x20
 1130d7c:	54ffff41 	b.ne	1130d64 <_sha256_compress+0x15c>  // b.any
}
 1130d80:	52800000 	mov	w0, #0x0                   	// #0
 1130d84:	a94153f3 	ldp	x19, x20, [sp, #16]
 1130d88:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1130d8c:	a94363f7 	ldp	x23, x24, [sp, #48]
 1130d90:	a8d67bfd 	ldp	x29, x30, [sp], #352
 1130d94:	d65f03c0 	ret
 1130d98:	2a0003e8 	mov	w8, w0
 1130d9c:	2a0903e5 	mov	w5, w9
 1130da0:	2a0203e0 	mov	w0, w2
 1130da4:	2a0303e9 	mov	w9, w3
         RND(S[0],S[1],S[2],S[3],S[4],S[5],S[6],S[7],i);
 1130da8:	2a0103e2 	mov	w2, w1
 1130dac:	2a0703e3 	mov	w3, w7
 1130db0:	17ffffcd 	b	1130ce4 <_sha256_compress+0xdc>

0000000001130db4 <sha256_compress>:
{
 1130db4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1130db8:	910003fd 	mov	x29, sp
 1130dbc:	f9000bf3 	str	x19, [sp, #16]
    err = _sha256_compress(md, buf);
 1130dc0:	97ffff92 	bl	1130c08 <_sha256_compress>
 1130dc4:	2a0003f3 	mov	w19, w0
    burn_stack(sizeof(ulong32) * 74);
 1130dc8:	d2802500 	mov	x0, #0x128                 	// #296
 1130dcc:	94000593 	bl	1132418 <burn_stack>
}
 1130dd0:	2a1303e0 	mov	w0, w19
 1130dd4:	f9400bf3 	ldr	x19, [sp, #16]
 1130dd8:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1130ddc:	d65f03c0 	ret

0000000001130de0 <sha256_process>:
HASH_PROCESS(sha256_process, sha256_compress, sha256, 64)
 1130de0:	b40007c0 	cbz	x0, 1130ed8 <sha256_process+0xf8>
 1130de4:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 1130de8:	910003fd 	mov	x29, sp
 1130dec:	a90153f3 	stp	x19, x20, [sp, #16]
 1130df0:	a9025bf5 	stp	x21, x22, [sp, #32]
 1130df4:	aa0103f5 	mov	x21, x1
 1130df8:	a90363f7 	stp	x23, x24, [sp, #48]
 1130dfc:	b4000721 	cbz	x1, 1130ee0 <sha256_process+0x100>
 1130e00:	aa0003f3 	mov	x19, x0
 1130e04:	b9402800 	ldr	w0, [x0, #40]
 1130e08:	7101001f 	cmp	w0, #0x40
 1130e0c:	540006a8 	b.hi	1130ee0 <sha256_process+0x100>  // b.pmore
 1130e10:	f9400260 	ldr	x0, [x19]
 1130e14:	aa0203f4 	mov	x20, x2
 1130e18:	ab02001f 	cmn	x0, x2
 1130e1c:	54000662 	b.cs	1130ee8 <sha256_process+0x108>  // b.hs, b.nlast
 1130e20:	9100b277 	add	x23, x19, #0x2c
 1130e24:	52800818 	mov	w24, #0x40                  	// #64
 1130e28:	b50000f4 	cbnz	x20, 1130e44 <sha256_process+0x64>
 1130e2c:	52800000 	mov	w0, #0x0                   	// #0
 1130e30:	a94153f3 	ldp	x19, x20, [sp, #16]
 1130e34:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1130e38:	a94363f7 	ldp	x23, x24, [sp, #48]
 1130e3c:	a8c47bfd 	ldp	x29, x30, [sp], #64
 1130e40:	d65f03c0 	ret
 1130e44:	b9402a60 	ldr	w0, [x19, #40]
 1130e48:	350001a0 	cbnz	w0, 1130e7c <sha256_process+0x9c>
 1130e4c:	f100fe9f 	cmp	x20, #0x3f
 1130e50:	54000169 	b.ls	1130e7c <sha256_process+0x9c>  // b.plast
 1130e54:	aa1503e1 	mov	x1, x21
 1130e58:	aa1303e0 	mov	x0, x19
 1130e5c:	97ffffd6 	bl	1130db4 <sha256_compress>
 1130e60:	35fffe80 	cbnz	w0, 1130e30 <sha256_process+0x50>
 1130e64:	f9400260 	ldr	x0, [x19]
 1130e68:	910102b5 	add	x21, x21, #0x40
 1130e6c:	d1010294 	sub	x20, x20, #0x40
 1130e70:	91080000 	add	x0, x0, #0x200
 1130e74:	f9000260 	str	x0, [x19]
 1130e78:	17ffffec 	b	1130e28 <sha256_process+0x48>
 1130e7c:	4b000316 	sub	w22, w24, w0
 1130e80:	aa1503e1 	mov	x1, x21
 1130e84:	eb1402df 	cmp	x22, x20
 1130e88:	8b2042e0 	add	x0, x23, w0, uxtw
 1130e8c:	9a9492d6 	csel	x22, x22, x20, ls  // ls = plast
 1130e90:	aa1603e2 	mov	x2, x22
 1130e94:	8b1602b5 	add	x21, x21, x22
 1130e98:	97ff493e 	bl	1103390 <memcpy>
 1130e9c:	cb160294 	sub	x20, x20, x22
 1130ea0:	b9402a60 	ldr	w0, [x19, #40]
 1130ea4:	0b160000 	add	w0, w0, w22
 1130ea8:	b9002a60 	str	w0, [x19, #40]
 1130eac:	7101001f 	cmp	w0, #0x40
 1130eb0:	54fffbc1 	b.ne	1130e28 <sha256_process+0x48>  // b.any
 1130eb4:	aa1703e1 	mov	x1, x23
 1130eb8:	aa1303e0 	mov	x0, x19
 1130ebc:	97ffffbe 	bl	1130db4 <sha256_compress>
 1130ec0:	35fffb80 	cbnz	w0, 1130e30 <sha256_process+0x50>
 1130ec4:	f9400260 	ldr	x0, [x19]
 1130ec8:	b9002a7f 	str	wzr, [x19, #40]
 1130ecc:	91080000 	add	x0, x0, #0x200
 1130ed0:	f9000260 	str	x0, [x19]
 1130ed4:	17ffffd5 	b	1130e28 <sha256_process+0x48>
 1130ed8:	52800200 	mov	w0, #0x10                  	// #16
 1130edc:	d65f03c0 	ret
 1130ee0:	52800200 	mov	w0, #0x10                  	// #16
 1130ee4:	17ffffd3 	b	1130e30 <sha256_process+0x50>
 1130ee8:	52800320 	mov	w0, #0x19                  	// #25
 1130eec:	17ffffd1 	b	1130e30 <sha256_process+0x50>

0000000001130ef0 <sha256_done>:
    LTC_ARGCHK(md  != NULL);
 1130ef0:	b4000960 	cbz	x0, 113101c <sha256_done+0x12c>
{
 1130ef4:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 1130ef8:	910003fd 	mov	x29, sp
 1130efc:	a90153f3 	stp	x19, x20, [sp, #16]
 1130f00:	a9025bf5 	stp	x21, x22, [sp, #32]
 1130f04:	aa0103f5 	mov	x21, x1
 1130f08:	f9001bf7 	str	x23, [sp, #48]
    LTC_ARGCHK(out != NULL);
 1130f0c:	b40008c1 	cbz	x1, 1131024 <sha256_done+0x134>
 1130f10:	aa0003f3 	mov	x19, x0
    if (md->sha256.curlen >= sizeof(md->sha256.buf)) {
 1130f14:	b9402800 	ldr	w0, [x0, #40]
 1130f18:	7100fc1f 	cmp	w0, #0x3f
 1130f1c:	54000848 	b.hi	1131024 <sha256_done+0x134>  // b.pmore
    md->sha256.length += md->sha256.curlen * 8;
 1130f20:	f9400261 	ldr	x1, [x19]
 1130f24:	531d7002 	lsl	w2, w0, #3
 1130f28:	8b020021 	add	x1, x1, x2
 1130f2c:	f9000261 	str	x1, [x19]
    md->sha256.buf[md->sha256.curlen++] = (unsigned char)0x80;
 1130f30:	11000401 	add	w1, w0, #0x1
 1130f34:	8b204260 	add	x0, x19, w0, uxtw
 1130f38:	b9002a61 	str	w1, [x19, #40]
 1130f3c:	12800fe2 	mov	w2, #0xffffff80            	// #-128
    if (md->sha256.curlen > 56) {
 1130f40:	7100e03f 	cmp	w1, #0x38
    md->sha256.buf[md->sha256.curlen++] = (unsigned char)0x80;
 1130f44:	3900b002 	strb	w2, [x0, #44]
    if (md->sha256.curlen > 56) {
 1130f48:	54000508 	b.hi	1130fe8 <sha256_done+0xf8>  // b.pmore
    while (md->sha256.curlen < 56) {
 1130f4c:	b9402a60 	ldr	w0, [x19, #40]
 1130f50:	7100dc1f 	cmp	w0, #0x37
 1130f54:	540005a9 	b.ls	1131008 <sha256_done+0x118>  // b.plast
    STORE64H(md->sha256.length, md->sha256.buf+56);
 1130f58:	aa1303e0 	mov	x0, x19
 1130f5c:	910123f6 	add	x22, sp, #0x48
 1130f60:	d2800102 	mov	x2, #0x8                   	// #8
        STORE32H(md->sha256.state[i], out+(4*i));
 1130f64:	91002277 	add	x23, x19, #0x8
    sha256_compress(md, md->sha256.buf);
 1130f68:	d2800014 	mov	x20, #0x0                   	// #0
    STORE64H(md->sha256.length, md->sha256.buf+56);
 1130f6c:	f8464401 	ldr	x1, [x0], #100
 1130f70:	dac00c21 	rev	x1, x1
 1130f74:	f90027e1 	str	x1, [sp, #72]
 1130f78:	aa1603e1 	mov	x1, x22
 1130f7c:	97ff4905 	bl	1103390 <memcpy>
    sha256_compress(md, md->sha256.buf);
 1130f80:	9100b261 	add	x1, x19, #0x2c
 1130f84:	aa1303e0 	mov	x0, x19
 1130f88:	97ffff8b 	bl	1130db4 <sha256_compress>
        STORE32H(md->sha256.state[i], out+(4*i));
 1130f8c:	b8746ae0 	ldr	w0, [x23, x20]
 1130f90:	aa1603e1 	mov	x1, x22
 1130f94:	d2800082 	mov	x2, #0x4                   	// #4
 1130f98:	5ac00800 	rev	w0, w0
 1130f9c:	b9004be0 	str	w0, [sp, #72]
 1130fa0:	8b1402a0 	add	x0, x21, x20
 1130fa4:	91001294 	add	x20, x20, #0x4
 1130fa8:	97ff48fa 	bl	1103390 <memcpy>
    for (i = 0; i < 8; i++) {
 1130fac:	f100829f 	cmp	x20, #0x20
 1130fb0:	54fffee1 	b.ne	1130f8c <sha256_done+0x9c>  // b.any
    zeromem(md, sizeof(hash_state));
 1130fb4:	aa1303e0 	mov	x0, x19
 1130fb8:	d2801a01 	mov	x1, #0xd0                  	// #208
 1130fbc:	94000522 	bl	1132444 <zeromem>
 1130fc0:	52800000 	mov	w0, #0x0                   	// #0
}
 1130fc4:	a94153f3 	ldp	x19, x20, [sp, #16]
 1130fc8:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1130fcc:	f9401bf7 	ldr	x23, [sp, #48]
 1130fd0:	a8c57bfd 	ldp	x29, x30, [sp], #80
 1130fd4:	d65f03c0 	ret
            md->sha256.buf[md->sha256.curlen++] = (unsigned char)0;
 1130fd8:	11000401 	add	w1, w0, #0x1
 1130fdc:	8b204260 	add	x0, x19, w0, uxtw
 1130fe0:	b9002a61 	str	w1, [x19, #40]
 1130fe4:	3900b01f 	strb	wzr, [x0, #44]
        while (md->sha256.curlen < 64) {
 1130fe8:	b9402a60 	ldr	w0, [x19, #40]
 1130fec:	7100fc1f 	cmp	w0, #0x3f
 1130ff0:	54ffff49 	b.ls	1130fd8 <sha256_done+0xe8>  // b.plast
        sha256_compress(md, md->sha256.buf);
 1130ff4:	9100b261 	add	x1, x19, #0x2c
 1130ff8:	aa1303e0 	mov	x0, x19
 1130ffc:	97ffff6e 	bl	1130db4 <sha256_compress>
        md->sha256.curlen = 0;
 1131000:	b9002a7f 	str	wzr, [x19, #40]
 1131004:	17ffffd2 	b	1130f4c <sha256_done+0x5c>
        md->sha256.buf[md->sha256.curlen++] = (unsigned char)0;
 1131008:	11000401 	add	w1, w0, #0x1
 113100c:	8b204260 	add	x0, x19, w0, uxtw
 1131010:	b9002a61 	str	w1, [x19, #40]
 1131014:	3900b01f 	strb	wzr, [x0, #44]
 1131018:	17ffffcd 	b	1130f4c <sha256_done+0x5c>
    LTC_ARGCHK(md  != NULL);
 113101c:	52800200 	mov	w0, #0x10                  	// #16
}
 1131020:	d65f03c0 	ret
    LTC_ARGCHK(md  != NULL);
 1131024:	52800200 	mov	w0, #0x10                  	// #16
 1131028:	17ffffe7 	b	1130fc4 <sha256_done+0xd4>

000000000113102c <sha384_init>:
   @param md   The hash state you wish to initialize
   @return CRYPT_OK if successful
*/
int sha384_init(hash_state * md)
{
    LTC_ARGCHK(md != NULL);
 113102c:	b4000580 	cbz	x0, 11310dc <sha384_init+0xb0>

    md->sha512.curlen = 0;
    md->sha512.length = 0;
    md->sha512.state[0] = CONST64(0xcbbb9d5dc1059ed8);
 1131030:	d293db01 	mov	x1, #0x9ed8                	// #40664
    md->sha512.curlen = 0;
 1131034:	f900241f 	str	xzr, [x0, #72]
    md->sha512.state[0] = CONST64(0xcbbb9d5dc1059ed8);
 1131038:	f2b820a1 	movk	x1, #0xc105, lsl #16
 113103c:	f2d3aba1 	movk	x1, #0x9d5d, lsl #32
 1131040:	f2f97761 	movk	x1, #0xcbbb, lsl #48
 1131044:	a900041f 	stp	xzr, x1, [x0]
    md->sha512.state[1] = CONST64(0x629a292a367cd507);
 1131048:	d29aa0e1 	mov	x1, #0xd507                	// #54535
 113104c:	f2a6cf81 	movk	x1, #0x367c, lsl #16
 1131050:	f2c52541 	movk	x1, #0x292a, lsl #32
 1131054:	f2ec5341 	movk	x1, #0x629a, lsl #48
 1131058:	f9000801 	str	x1, [x0, #16]
    md->sha512.state[2] = CONST64(0x9159015a3070dd17);
 113105c:	d29ba2e1 	mov	x1, #0xdd17                	// #56599
 1131060:	f2a60e01 	movk	x1, #0x3070, lsl #16
 1131064:	f2c02b41 	movk	x1, #0x15a, lsl #32
 1131068:	f2f22b21 	movk	x1, #0x9159, lsl #48
 113106c:	f9000c01 	str	x1, [x0, #24]
    md->sha512.state[3] = CONST64(0x152fecd8f70e5939);
 1131070:	d28b2721 	mov	x1, #0x5939                	// #22841
 1131074:	f2bee1c1 	movk	x1, #0xf70e, lsl #16
 1131078:	f2dd9b01 	movk	x1, #0xecd8, lsl #32
 113107c:	f2e2a5e1 	movk	x1, #0x152f, lsl #48
 1131080:	f9001001 	str	x1, [x0, #32]
    md->sha512.state[4] = CONST64(0x67332667ffc00b31);
 1131084:	d2816621 	mov	x1, #0xb31                 	// #2865
 1131088:	f2bff801 	movk	x1, #0xffc0, lsl #16
 113108c:	f2c4cce1 	movk	x1, #0x2667, lsl #32
 1131090:	f2ece661 	movk	x1, #0x6733, lsl #48
 1131094:	f9001401 	str	x1, [x0, #40]
    md->sha512.state[5] = CONST64(0x8eb44a8768581511);
 1131098:	d282a221 	mov	x1, #0x1511                	// #5393
 113109c:	f2ad0b01 	movk	x1, #0x6858, lsl #16
 11310a0:	f2c950e1 	movk	x1, #0x4a87, lsl #32
 11310a4:	f2f1d681 	movk	x1, #0x8eb4, lsl #48
 11310a8:	f9001801 	str	x1, [x0, #48]
    md->sha512.state[6] = CONST64(0xdb0c2e0d64f98fa7);
 11310ac:	d291f4e1 	mov	x1, #0x8fa7                	// #36775
 11310b0:	f2ac9f21 	movk	x1, #0x64f9, lsl #16
 11310b4:	f2c5c1a1 	movk	x1, #0x2e0d, lsl #32
 11310b8:	f2fb6181 	movk	x1, #0xdb0c, lsl #48
 11310bc:	f9001c01 	str	x1, [x0, #56]
    md->sha512.state[7] = CONST64(0x47b5481dbefa4fa4);
 11310c0:	d289f481 	mov	x1, #0x4fa4                	// #20388
 11310c4:	f2b7df41 	movk	x1, #0xbefa, lsl #16
 11310c8:	f2c903a1 	movk	x1, #0x481d, lsl #32
 11310cc:	f2e8f6a1 	movk	x1, #0x47b5, lsl #48
 11310d0:	f9002001 	str	x1, [x0, #64]
    return CRYPT_OK;
 11310d4:	52800000 	mov	w0, #0x0                   	// #0
}
 11310d8:	d65f03c0 	ret
    LTC_ARGCHK(md != NULL);
 11310dc:	52800200 	mov	w0, #0x10                  	// #16
 11310e0:	17fffffe 	b	11310d8 <sha384_init+0xac>

00000000011310e4 <sha384_test>:
         return CRYPT_FAIL_TESTVECTOR;
      }
  }
  return CRYPT_OK;
 #endif
}
 11310e4:	52800040 	mov	w0, #0x2                   	// #2
 11310e8:	d65f03c0 	ret

00000000011310ec <sha384_done>:
   LTC_ARGCHK(md  != NULL);
 11310ec:	b40002e0 	cbz	x0, 1131148 <sha384_done+0x5c>
{
 11310f0:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
 11310f4:	910003fd 	mov	x29, sp
 11310f8:	a90153f3 	stp	x19, x20, [sp, #16]
 11310fc:	aa0103f3 	mov	x19, x1
   LTC_ARGCHK(out != NULL);
 1131100:	b4000281 	cbz	x1, 1131150 <sha384_done+0x64>
    if (md->sha512.curlen >= sizeof(md->sha512.buf)) {
 1131104:	f9402401 	ldr	x1, [x0, #72]
 1131108:	f101fc3f 	cmp	x1, #0x7f
 113110c:	54000228 	b.hi	1131150 <sha384_done+0x64>  // b.pmore
   sha512_done(md, buf);
 1131110:	910083f4 	add	x20, sp, #0x20
 1131114:	aa1403e1 	mov	x1, x20
 1131118:	940000fe 	bl	1131510 <sha512_done>
   XMEMCPY(out, buf, 48);
 113111c:	d2800602 	mov	x2, #0x30                  	// #48
 1131120:	aa1403e1 	mov	x1, x20
 1131124:	aa1303e0 	mov	x0, x19
 1131128:	97ff489a 	bl	1103390 <memcpy>
   zeromem(buf, sizeof(buf));
 113112c:	aa1403e0 	mov	x0, x20
 1131130:	d2800801 	mov	x1, #0x40                  	// #64
 1131134:	940004c4 	bl	1132444 <zeromem>
   return CRYPT_OK;
 1131138:	52800000 	mov	w0, #0x0                   	// #0
}
 113113c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1131140:	a8c67bfd 	ldp	x29, x30, [sp], #96
 1131144:	d65f03c0 	ret
   LTC_ARGCHK(md  != NULL);
 1131148:	52800200 	mov	w0, #0x10                  	// #16
}
 113114c:	d65f03c0 	ret
   LTC_ARGCHK(md  != NULL);
 1131150:	52800200 	mov	w0, #0x10                  	// #16
 1131154:	17fffffa 	b	113113c <sha384_done+0x50>

0000000001131158 <sha512_init>:
   @param md   The hash state you wish to initialize
   @return CRYPT_OK if successful
*/
int sha512_init(hash_state * md)
{
    LTC_ARGCHK(md != NULL);
 1131158:	b4000580 	cbz	x0, 1131208 <sha512_init+0xb0>
    md->sha512.curlen = 0;
    md->sha512.length = 0;
    md->sha512.state[0] = CONST64(0x6a09e667f3bcc908);
 113115c:	d2992101 	mov	x1, #0xc908                	// #51464
    md->sha512.curlen = 0;
 1131160:	f900241f 	str	xzr, [x0, #72]
    md->sha512.state[0] = CONST64(0x6a09e667f3bcc908);
 1131164:	f2be7781 	movk	x1, #0xf3bc, lsl #16
 1131168:	f2dccce1 	movk	x1, #0xe667, lsl #32
 113116c:	f2ed4121 	movk	x1, #0x6a09, lsl #48
 1131170:	a900041f 	stp	xzr, x1, [x0]
    md->sha512.state[1] = CONST64(0xbb67ae8584caa73b);
 1131174:	d294e761 	mov	x1, #0xa73b                	// #42811
 1131178:	f2b09941 	movk	x1, #0x84ca, lsl #16
 113117c:	f2d5d0a1 	movk	x1, #0xae85, lsl #32
 1131180:	f2f76ce1 	movk	x1, #0xbb67, lsl #48
 1131184:	f9000801 	str	x1, [x0, #16]
    md->sha512.state[2] = CONST64(0x3c6ef372fe94f82b);
 1131188:	d29f0561 	mov	x1, #0xf82b                	// #63531
 113118c:	f2bfd281 	movk	x1, #0xfe94, lsl #16
 1131190:	f2de6e41 	movk	x1, #0xf372, lsl #32
 1131194:	f2e78dc1 	movk	x1, #0x3c6e, lsl #48
 1131198:	f9000c01 	str	x1, [x0, #24]
    md->sha512.state[3] = CONST64(0xa54ff53a5f1d36f1);
 113119c:	d286de21 	mov	x1, #0x36f1                	// #14065
 11311a0:	f2abe3a1 	movk	x1, #0x5f1d, lsl #16
 11311a4:	f2dea741 	movk	x1, #0xf53a, lsl #32
 11311a8:	f2f4a9e1 	movk	x1, #0xa54f, lsl #48
 11311ac:	f9001001 	str	x1, [x0, #32]
    md->sha512.state[4] = CONST64(0x510e527fade682d1);
 11311b0:	d2905a21 	mov	x1, #0x82d1                	// #33489
 11311b4:	f2b5bcc1 	movk	x1, #0xade6, lsl #16
 11311b8:	f2ca4fe1 	movk	x1, #0x527f, lsl #32
 11311bc:	f2ea21c1 	movk	x1, #0x510e, lsl #48
 11311c0:	f9001401 	str	x1, [x0, #40]
    md->sha512.state[5] = CONST64(0x9b05688c2b3e6c1f);
 11311c4:	d28d83e1 	mov	x1, #0x6c1f                	// #27679
 11311c8:	f2a567c1 	movk	x1, #0x2b3e, lsl #16
 11311cc:	f2cd1181 	movk	x1, #0x688c, lsl #32
 11311d0:	f2f360a1 	movk	x1, #0x9b05, lsl #48
 11311d4:	f9001801 	str	x1, [x0, #48]
    md->sha512.state[6] = CONST64(0x1f83d9abfb41bd6b);
 11311d8:	d297ad61 	mov	x1, #0xbd6b                	// #48491
 11311dc:	f2bf6821 	movk	x1, #0xfb41, lsl #16
 11311e0:	f2db3561 	movk	x1, #0xd9ab, lsl #32
 11311e4:	f2e3f061 	movk	x1, #0x1f83, lsl #48
 11311e8:	f9001c01 	str	x1, [x0, #56]
    md->sha512.state[7] = CONST64(0x5be0cd19137e2179);
 11311ec:	d2842f21 	mov	x1, #0x2179                	// #8569
 11311f0:	f2a26fc1 	movk	x1, #0x137e, lsl #16
 11311f4:	f2d9a321 	movk	x1, #0xcd19, lsl #32
 11311f8:	f2eb7c01 	movk	x1, #0x5be0, lsl #48
 11311fc:	f9002001 	str	x1, [x0, #64]
    return CRYPT_OK;
 1131200:	52800000 	mov	w0, #0x0                   	// #0
}
 1131204:	d65f03c0 	ret
    LTC_ARGCHK(md != NULL);
 1131208:	52800200 	mov	w0, #0x10                  	// #16
 113120c:	17fffffe 	b	1131204 <sha512_init+0xac>

0000000001131210 <sha512_test>:
         return CRYPT_FAIL_TESTVECTOR;
      }
  }
  return CRYPT_OK;
  #endif
}
 1131210:	52800040 	mov	w0, #0x2                   	// #2
 1131214:	d65f03c0 	ret

0000000001131218 <_sha512_compress>:
{
 1131218:	d10c03ff 	sub	sp, sp, #0x300
 113121c:	a9007bfd 	stp	x29, x30, [sp]
 1131220:	910003fd 	mov	x29, sp
 1131224:	a9025bf5 	stp	x21, x22, [sp, #32]
 1131228:	aa0003f5 	mov	x21, x0
        S[i] = md->sha512.state[i];
 113122c:	910103f6 	add	x22, sp, #0x40
 1131230:	910022a2 	add	x2, x21, #0x8
{
 1131234:	a90153f3 	stp	x19, x20, [sp, #16]
 1131238:	aa0103f4 	mov	x20, x1
 113123c:	d2800000 	mov	x0, #0x0                   	// #0
 1131240:	a90363f7 	stp	x23, x24, [sp, #48]
        S[i] = md->sha512.state[i];
 1131244:	f8606841 	ldr	x1, [x2, x0]
 1131248:	f8366801 	str	x1, [x0, x22]
    for (i = 0; i < 8; i++) {
 113124c:	91002000 	add	x0, x0, #0x8
 1131250:	f101001f 	cmp	x0, #0x40
 1131254:	54ffff81 	b.ne	1131244 <_sha512_compress+0x2c>  // b.any
 1131258:	910203f3 	add	x19, sp, #0x80
 113125c:	91020298 	add	x24, x20, #0x80
 1131260:	aa1303e3 	mov	x3, x19
 1131264:	aa1303f7 	mov	x23, x19
        LOAD64H(W[i], buf + (8*i));
 1131268:	aa1403e1 	mov	x1, x20
 113126c:	aa0303e0 	mov	x0, x3
 1131270:	d2800102 	mov	x2, #0x8                   	// #8
 1131274:	97ff4847 	bl	1103390 <memcpy>
 1131278:	aa0003e3 	mov	x3, x0
 113127c:	91002294 	add	x20, x20, #0x8
 1131280:	f9400000 	ldr	x0, [x0]
    for (i = 0; i < 16; i++) {
 1131284:	eb14031f 	cmp	x24, x20
        LOAD64H(W[i], buf + (8*i));
 1131288:	dac00c00 	rev	x0, x0
 113128c:	f8008460 	str	x0, [x3], #8
    for (i = 0; i < 16; i++) {
 1131290:	54fffec1 	b.ne	1131268 <_sha512_compress+0x50>  // b.any
    for (i = 16; i < 80; i++) {
 1131294:	52800202 	mov	w2, #0x10                  	// #16
        W[i] = Gamma1(W[i - 2]) + W[i - 7] + Gamma0(W[i - 15]) + W[i - 16];
 1131298:	f9403a61 	ldr	x1, [x19, #112]
    for (i = 16; i < 80; i++) {
 113129c:	11000442 	add	w2, w2, #0x1
        W[i] = Gamma1(W[i - 2]) + W[i - 7] + Gamma0(W[i - 15]) + W[i - 16];
 11312a0:	f9400660 	ldr	x0, [x19, #8]
    for (i = 16; i < 80; i++) {
 11312a4:	7101405f 	cmp	w2, #0x50
 11312a8:	91002273 	add	x19, x19, #0x8
        W[i] = Gamma1(W[i - 2]) + W[i - 7] + Gamma0(W[i - 15]) + W[i - 16];
 11312ac:	93c1f423 	ror	x3, x1, #61
 11312b0:	cac14c63 	eor	x3, x3, x1, ror #19
 11312b4:	ca411861 	eor	x1, x3, x1, lsr #6
 11312b8:	93c02003 	ror	x3, x0, #8
 11312bc:	cac00463 	eor	x3, x3, x0, ror #1
 11312c0:	ca401c60 	eor	x0, x3, x0, lsr #7
 11312c4:	8b000021 	add	x1, x1, x0
 11312c8:	f85f8263 	ldur	x3, [x19, #-8]
 11312cc:	f9402260 	ldr	x0, [x19, #64]
 11312d0:	8b030000 	add	x0, x0, x3
 11312d4:	8b000021 	add	x1, x1, x0
 11312d8:	f9003e61 	str	x1, [x19, #120]
    for (i = 16; i < 80; i++) {
 11312dc:	54fffde1 	b.ne	1131298 <_sha512_compress+0x80>  // b.any
 11312e0:	a94403e2 	ldp	x2, x0, [sp, #64]
        t0 = S[7] + Sigma1(S[4]) + Ch(S[4], S[5], S[6]) + K[i] + W[i];
 11312e4:	b00000ea 	adrp	x10, 114e000 <ldelf_data+0x8000>
 11312e8:	a9452fe8 	ldp	x8, x11, [sp, #80]
 11312ec:	910c014a 	add	x10, x10, #0x300
 11312f0:	a94627e3 	ldp	x3, x9, [sp, #96]
    for (i = 16; i < 80; i++) {
 11312f4:	d2800006 	mov	x6, #0x0                   	// #0
 11312f8:	a94733e5 	ldp	x5, x12, [sp, #112]
        t0 = S[7] + Sigma1(S[4]) + Ch(S[4], S[5], S[6]) + K[i] + W[i];
 11312fc:	93c34861 	ror	x1, x3, #18
 1131300:	ca0900a4 	eor	x4, x5, x9
 1131304:	cac33821 	eor	x1, x1, x3, ror #14
 1131308:	8a030084 	and	x4, x4, x3
 113130c:	cac3a421 	eor	x1, x1, x3, ror #41
 1131310:	ca050084 	eor	x4, x4, x5
 1131314:	8b040021 	add	x1, x1, x4
 1131318:	f8666ae7 	ldr	x7, [x23, x6]
 113131c:	f86a68c4 	ldr	x4, [x6, x10]
 1131320:	910020c6 	add	x6, x6, #0x8
    for (i = 0; i < 80; i++) {
 1131324:	f10a00df 	cmp	x6, #0x280
        t0 = S[7] + Sigma1(S[4]) + Ch(S[4], S[5], S[6]) + K[i] + W[i];
 1131328:	8b070084 	add	x4, x4, x7
        t1 = Sigma0(S[0]) + Maj(S[0], S[1], S[2]);
 113132c:	aa020007 	orr	x7, x0, x2
        t0 = S[7] + Sigma1(S[4]) + Ch(S[4], S[5], S[6]) + K[i] + W[i];
 1131330:	8b040021 	add	x1, x1, x4
        t1 = Sigma0(S[0]) + Maj(S[0], S[1], S[2]);
 1131334:	93c28844 	ror	x4, x2, #34
        t0 = S[7] + Sigma1(S[4]) + Ch(S[4], S[5], S[6]) + K[i] + W[i];
 1131338:	8b0c0021 	add	x1, x1, x12
        t1 = Sigma0(S[0]) + Maj(S[0], S[1], S[2]);
 113133c:	cac27084 	eor	x4, x4, x2, ror #28
 1131340:	8a02000c 	and	x12, x0, x2
 1131344:	8a0800e7 	and	x7, x7, x8
 1131348:	aa0c00e7 	orr	x7, x7, x12
 113134c:	cac29c84 	eor	x4, x4, x2, ror #39
 1131350:	8b070084 	add	x4, x4, x7
        S[4] = S[3] + t0;
 1131354:	aa0503ec 	mov	x12, x5
 1131358:	8b010167 	add	x7, x11, x1
        S[0] = t0 + t1;
 113135c:	8b040021 	add	x1, x1, x4
    for (i = 0; i < 80; i++) {
 1131360:	aa0803eb 	mov	x11, x8
 1131364:	540002a1 	b.ne	11313b8 <_sha512_compress+0x1a0>  // b.any
 1131368:	a9040be1 	stp	x1, x2, [sp, #64]
 113136c:	d2800021 	mov	x1, #0x1                   	// #1
 1131370:	a90523e0 	stp	x0, x8, [sp, #80]
 1131374:	a9060fe7 	stp	x7, x3, [sp, #96]
 1131378:	a90717e9 	stp	x9, x5, [sp, #112]
        md->sha512.state[i] = md->sha512.state[i] + S[i];
 113137c:	8b010ec2 	add	x2, x22, x1, lsl #3
 1131380:	f8617aa0 	ldr	x0, [x21, x1, lsl #3]
 1131384:	f85f8042 	ldur	x2, [x2, #-8]
 1131388:	8b020000 	add	x0, x0, x2
 113138c:	f8217aa0 	str	x0, [x21, x1, lsl #3]
    for (i = 0; i < 8; i++) {
 1131390:	91000421 	add	x1, x1, #0x1
 1131394:	f100243f 	cmp	x1, #0x9
 1131398:	54ffff21 	b.ne	113137c <_sha512_compress+0x164>  // b.any
}
 113139c:	52800000 	mov	w0, #0x0                   	// #0
 11313a0:	a9407bfd 	ldp	x29, x30, [sp]
 11313a4:	a94153f3 	ldp	x19, x20, [sp, #16]
 11313a8:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11313ac:	a94363f7 	ldp	x23, x24, [sp, #48]
 11313b0:	910c03ff 	add	sp, sp, #0x300
 11313b4:	d65f03c0 	ret
 11313b8:	aa0003e8 	mov	x8, x0
 11313bc:	aa0903e5 	mov	x5, x9
 11313c0:	aa0203e0 	mov	x0, x2
 11313c4:	aa0303e9 	mov	x9, x3
        S[0] = t0 + t1;
 11313c8:	aa0103e2 	mov	x2, x1
        S[4] = S[3] + t0;
 11313cc:	aa0703e3 	mov	x3, x7
 11313d0:	17ffffcb 	b	11312fc <_sha512_compress+0xe4>

00000000011313d4 <sha512_compress>:
{
 11313d4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 11313d8:	910003fd 	mov	x29, sp
 11313dc:	f9000bf3 	str	x19, [sp, #16]
    err = _sha512_compress(md, buf);
 11313e0:	97ffff8e 	bl	1131218 <_sha512_compress>
 11313e4:	2a0003f3 	mov	w19, w0
    burn_stack(sizeof(ulong64) * 90 + sizeof(int));
 11313e8:	d2805a80 	mov	x0, #0x2d4                 	// #724
 11313ec:	9400040b 	bl	1132418 <burn_stack>
}
 11313f0:	2a1303e0 	mov	w0, w19
 11313f4:	f9400bf3 	ldr	x19, [sp, #16]
 11313f8:	a8c27bfd 	ldp	x29, x30, [sp], #32
 11313fc:	d65f03c0 	ret

0000000001131400 <sha512_process>:
HASH_PROCESS(sha512_process, sha512_compress, sha512, 128)
 1131400:	b40007c0 	cbz	x0, 11314f8 <sha512_process+0xf8>
 1131404:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 1131408:	910003fd 	mov	x29, sp
 113140c:	a90153f3 	stp	x19, x20, [sp, #16]
 1131410:	a9025bf5 	stp	x21, x22, [sp, #32]
 1131414:	aa0103f5 	mov	x21, x1
 1131418:	a90363f7 	stp	x23, x24, [sp, #48]
 113141c:	b4000721 	cbz	x1, 1131500 <sha512_process+0x100>
 1131420:	aa0003f3 	mov	x19, x0
 1131424:	f9402400 	ldr	x0, [x0, #72]
 1131428:	f102001f 	cmp	x0, #0x80
 113142c:	540006a8 	b.hi	1131500 <sha512_process+0x100>  // b.pmore
 1131430:	f9400260 	ldr	x0, [x19]
 1131434:	aa0203f4 	mov	x20, x2
 1131438:	ab02001f 	cmn	x0, x2
 113143c:	54000662 	b.cs	1131508 <sha512_process+0x108>  // b.hs, b.nlast
 1131440:	91014277 	add	x23, x19, #0x50
 1131444:	d2801018 	mov	x24, #0x80                  	// #128
 1131448:	b50000f4 	cbnz	x20, 1131464 <sha512_process+0x64>
 113144c:	52800000 	mov	w0, #0x0                   	// #0
 1131450:	a94153f3 	ldp	x19, x20, [sp, #16]
 1131454:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1131458:	a94363f7 	ldp	x23, x24, [sp, #48]
 113145c:	a8c47bfd 	ldp	x29, x30, [sp], #64
 1131460:	d65f03c0 	ret
 1131464:	f9402660 	ldr	x0, [x19, #72]
 1131468:	b50001a0 	cbnz	x0, 113149c <sha512_process+0x9c>
 113146c:	f101fe9f 	cmp	x20, #0x7f
 1131470:	54000169 	b.ls	113149c <sha512_process+0x9c>  // b.plast
 1131474:	aa1503e1 	mov	x1, x21
 1131478:	aa1303e0 	mov	x0, x19
 113147c:	97ffffd6 	bl	11313d4 <sha512_compress>
 1131480:	35fffe80 	cbnz	w0, 1131450 <sha512_process+0x50>
 1131484:	f9400260 	ldr	x0, [x19]
 1131488:	910202b5 	add	x21, x21, #0x80
 113148c:	d1020294 	sub	x20, x20, #0x80
 1131490:	91100000 	add	x0, x0, #0x400
 1131494:	f9000260 	str	x0, [x19]
 1131498:	17ffffec 	b	1131448 <sha512_process+0x48>
 113149c:	cb000316 	sub	x22, x24, x0
 11314a0:	aa1503e1 	mov	x1, x21
 11314a4:	eb1402df 	cmp	x22, x20
 11314a8:	8b0002e0 	add	x0, x23, x0
 11314ac:	9a9492d6 	csel	x22, x22, x20, ls  // ls = plast
 11314b0:	aa1603e2 	mov	x2, x22
 11314b4:	8b1602b5 	add	x21, x21, x22
 11314b8:	97ff47b6 	bl	1103390 <memcpy>
 11314bc:	cb160294 	sub	x20, x20, x22
 11314c0:	f9402660 	ldr	x0, [x19, #72]
 11314c4:	8b0002c0 	add	x0, x22, x0
 11314c8:	f9002660 	str	x0, [x19, #72]
 11314cc:	f102001f 	cmp	x0, #0x80
 11314d0:	54fffbc1 	b.ne	1131448 <sha512_process+0x48>  // b.any
 11314d4:	aa1703e1 	mov	x1, x23
 11314d8:	aa1303e0 	mov	x0, x19
 11314dc:	97ffffbe 	bl	11313d4 <sha512_compress>
 11314e0:	35fffb80 	cbnz	w0, 1131450 <sha512_process+0x50>
 11314e4:	f9400260 	ldr	x0, [x19]
 11314e8:	f900267f 	str	xzr, [x19, #72]
 11314ec:	91100000 	add	x0, x0, #0x400
 11314f0:	f9000260 	str	x0, [x19]
 11314f4:	17ffffd5 	b	1131448 <sha512_process+0x48>
 11314f8:	52800200 	mov	w0, #0x10                  	// #16
 11314fc:	d65f03c0 	ret
 1131500:	52800200 	mov	w0, #0x10                  	// #16
 1131504:	17ffffd3 	b	1131450 <sha512_process+0x50>
 1131508:	52800320 	mov	w0, #0x19                  	// #25
 113150c:	17ffffd1 	b	1131450 <sha512_process+0x50>

0000000001131510 <sha512_done>:
    LTC_ARGCHK(md  != NULL);
 1131510:	b4000940 	cbz	x0, 1131638 <sha512_done+0x128>
{
 1131514:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 1131518:	910003fd 	mov	x29, sp
 113151c:	a90153f3 	stp	x19, x20, [sp, #16]
 1131520:	a9025bf5 	stp	x21, x22, [sp, #32]
 1131524:	aa0103f5 	mov	x21, x1
 1131528:	f9001bf7 	str	x23, [sp, #48]
    LTC_ARGCHK(out != NULL);
 113152c:	b40008a1 	cbz	x1, 1131640 <sha512_done+0x130>
 1131530:	aa0003f3 	mov	x19, x0
    if (md->sha512.curlen >= sizeof(md->sha512.buf)) {
 1131534:	f9402400 	ldr	x0, [x0, #72]
 1131538:	f101fc1f 	cmp	x0, #0x7f
 113153c:	54000828 	b.hi	1131640 <sha512_done+0x130>  // b.pmore
    md->sha512.length += md->sha512.curlen * CONST64(8);
 1131540:	f9400261 	ldr	x1, [x19]
    md->sha512.buf[md->sha512.curlen++] = (unsigned char)0x80;
 1131544:	12800fe2 	mov	w2, #0xffffff80            	// #-128
    md->sha512.length += md->sha512.curlen * CONST64(8);
 1131548:	8b000c21 	add	x1, x1, x0, lsl #3
 113154c:	f9000261 	str	x1, [x19]
    md->sha512.buf[md->sha512.curlen++] = (unsigned char)0x80;
 1131550:	91000401 	add	x1, x0, #0x1
 1131554:	8b000260 	add	x0, x19, x0
 1131558:	f9002661 	str	x1, [x19, #72]
    if (md->sha512.curlen > 112) {
 113155c:	f101c03f 	cmp	x1, #0x70
    md->sha512.buf[md->sha512.curlen++] = (unsigned char)0x80;
 1131560:	39014002 	strb	w2, [x0, #80]
    if (md->sha512.curlen > 112) {
 1131564:	54000508 	b.hi	1131604 <sha512_done+0xf4>  // b.pmore
    while (md->sha512.curlen < 120) {
 1131568:	f9402660 	ldr	x0, [x19, #72]
 113156c:	f101dc1f 	cmp	x0, #0x77
 1131570:	540005a9 	b.ls	1131624 <sha512_done+0x114>  // b.plast
    STORE64H(md->sha512.length, md->sha512.buf+120);
 1131574:	aa1303e0 	mov	x0, x19
 1131578:	910123f6 	add	x22, sp, #0x48
 113157c:	d2800102 	mov	x2, #0x8                   	// #8
        STORE64H(md->sha512.state[i], out+(8*i));
 1131580:	91002277 	add	x23, x19, #0x8
    sha512_compress(md, md->sha512.buf);
 1131584:	d2800014 	mov	x20, #0x0                   	// #0
    STORE64H(md->sha512.length, md->sha512.buf+120);
 1131588:	f84c8401 	ldr	x1, [x0], #200
 113158c:	dac00c21 	rev	x1, x1
 1131590:	f90027e1 	str	x1, [sp, #72]
 1131594:	aa1603e1 	mov	x1, x22
 1131598:	97ff477e 	bl	1103390 <memcpy>
    sha512_compress(md, md->sha512.buf);
 113159c:	91014261 	add	x1, x19, #0x50
 11315a0:	aa1303e0 	mov	x0, x19
 11315a4:	97ffff8c 	bl	11313d4 <sha512_compress>
        STORE64H(md->sha512.state[i], out+(8*i));
 11315a8:	f8746ae0 	ldr	x0, [x23, x20]
 11315ac:	aa1603e1 	mov	x1, x22
 11315b0:	d2800102 	mov	x2, #0x8                   	// #8
 11315b4:	dac00c00 	rev	x0, x0
 11315b8:	f90027e0 	str	x0, [sp, #72]
 11315bc:	8b1402a0 	add	x0, x21, x20
 11315c0:	91002294 	add	x20, x20, #0x8
 11315c4:	97ff4773 	bl	1103390 <memcpy>
    for (i = 0; i < 8; i++) {
 11315c8:	f101029f 	cmp	x20, #0x40
 11315cc:	54fffee1 	b.ne	11315a8 <sha512_done+0x98>  // b.any
    zeromem(md, sizeof(hash_state));
 11315d0:	aa1303e0 	mov	x0, x19
 11315d4:	d2801a01 	mov	x1, #0xd0                  	// #208
 11315d8:	9400039b 	bl	1132444 <zeromem>
 11315dc:	52800000 	mov	w0, #0x0                   	// #0
}
 11315e0:	a94153f3 	ldp	x19, x20, [sp, #16]
 11315e4:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11315e8:	f9401bf7 	ldr	x23, [sp, #48]
 11315ec:	a8c57bfd 	ldp	x29, x30, [sp], #80
 11315f0:	d65f03c0 	ret
            md->sha512.buf[md->sha512.curlen++] = (unsigned char)0;
 11315f4:	91000401 	add	x1, x0, #0x1
 11315f8:	8b000260 	add	x0, x19, x0
 11315fc:	f9002661 	str	x1, [x19, #72]
 1131600:	3901401f 	strb	wzr, [x0, #80]
        while (md->sha512.curlen < 128) {
 1131604:	f9402660 	ldr	x0, [x19, #72]
 1131608:	f101fc1f 	cmp	x0, #0x7f
 113160c:	54ffff49 	b.ls	11315f4 <sha512_done+0xe4>  // b.plast
        sha512_compress(md, md->sha512.buf);
 1131610:	91014261 	add	x1, x19, #0x50
 1131614:	aa1303e0 	mov	x0, x19
 1131618:	97ffff6f 	bl	11313d4 <sha512_compress>
        md->sha512.curlen = 0;
 113161c:	f900267f 	str	xzr, [x19, #72]
 1131620:	17ffffd2 	b	1131568 <sha512_done+0x58>
        md->sha512.buf[md->sha512.curlen++] = (unsigned char)0;
 1131624:	91000401 	add	x1, x0, #0x1
 1131628:	8b000260 	add	x0, x19, x0
 113162c:	f9002661 	str	x1, [x19, #72]
 1131630:	3901401f 	strb	wzr, [x0, #80]
 1131634:	17ffffcd 	b	1131568 <sha512_done+0x58>
    LTC_ARGCHK(md  != NULL);
 1131638:	52800200 	mov	w0, #0x10                  	// #16
}
 113163c:	d65f03c0 	ret
    LTC_ARGCHK(md  != NULL);
 1131640:	52800200 	mov	w0, #0x10                  	// #16
 1131644:	17ffffe7 	b	11315e0 <sha512_done+0xd0>

0000000001131648 <hmac_done>:
   @param out     [out] The destination of the HMAC authentication tag
   @param outlen  [in/out]  The max size and resulting size of the HMAC authentication tag
   @return CRYPT_OK if successful
*/
int hmac_done(hmac_state *hmac, unsigned char *out, unsigned long *outlen)
{
 1131648:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
 113164c:	910003fd 	mov	x29, sp
 1131650:	a90153f3 	stp	x19, x20, [sp, #16]
 1131654:	a9025bf5 	stp	x21, x22, [sp, #32]
 1131658:	a90363f7 	stp	x23, x24, [sp, #48]
 113165c:	a9046bf9 	stp	x25, x26, [sp, #64]
 1131660:	f9002bfb 	str	x27, [sp, #80]
    unsigned char *buf, *isha;
    unsigned long hashsize, i;
    int hash, err;

    LTC_ARGCHK(hmac  != NULL);
 1131664:	b4000de0 	cbz	x0, 1131820 <hmac_done+0x1d8>
 1131668:	aa0103f9 	mov	x25, x1
    LTC_ARGCHK(out   != NULL);
 113166c:	b4000da1 	cbz	x1, 1131820 <hmac_done+0x1d8>

    /* test hash */
    hash = hmac->hash;
 1131670:	b940d01a 	ldr	w26, [x0, #208]
 1131674:	aa0003f5 	mov	x21, x0
 1131678:	aa0203f8 	mov	x24, x2
    if((err = hash_is_valid(hash)) != CRYPT_OK) {
 113167c:	2a1a03e0 	mov	w0, w26
 1131680:	940003fd 	bl	1132674 <hash_is_valid>
 1131684:	2a0003f3 	mov	w19, w0
 1131688:	35000a40 	cbnz	w0, 11317d0 <hmac_done+0x188>
        return err;
    }

    /* get the hash message digest size */
    hashsize = hash_descriptor[hash]->hashsize;
 113168c:	b000015b 	adrp	x27, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1131690:	93407f5a 	sxtw	x26, w26
 1131694:	f941a37b 	ldr	x27, [x27, #832]
 1131698:	f87a7b73 	ldr	x19, [x27, x26, lsl #3]

    /* allocate buffers */
    buf  = XMALLOC(LTC_HMAC_BLOCKSIZE);
 113169c:	a9410277 	ldp	x23, x0, [x19, #16]
 11316a0:	9400476e 	bl	1143458 <malloc>
 11316a4:	aa0003f4 	mov	x20, x0
    isha = XMALLOC(hashsize);
 11316a8:	aa1703e0 	mov	x0, x23
 11316ac:	9400476b 	bl	1143458 <malloc>
    if (buf == NULL || isha == NULL) {
 11316b0:	f100029f 	cmp	x20, #0x0
    isha = XMALLOC(hashsize);
 11316b4:	aa0003f6 	mov	x22, x0
    if (buf == NULL || isha == NULL) {
 11316b8:	fa401804 	ccmp	x0, #0x0, #0x4, ne  // ne = any
 11316bc:	54000121 	b.ne	11316e0 <hmac_done+0x98>  // b.any
       if (buf != NULL) {
 11316c0:	b4000074 	cbz	x20, 11316cc <hmac_done+0x84>
          XFREE(buf);
 11316c4:	aa1403e0 	mov	x0, x20
 11316c8:	940047c6 	bl	11435e0 <free>
       }
       if (isha != NULL) {
 11316cc:	b4000076 	cbz	x22, 11316d8 <hmac_done+0x90>
          XFREE(isha);
 11316d0:	aa1603e0 	mov	x0, x22
 11316d4:	940047c3 	bl	11435e0 <free>
       }
       return CRYPT_MEM;
 11316d8:	528001b3 	mov	w19, #0xd                   	// #13
 11316dc:	1400003d 	b	11317d0 <hmac_done+0x188>
    }

    /* Get the hash of the first HMAC vector plus the data */
    if ((err = hash_descriptor[hash]->done(&hmac->md, isha)) != CRYPT_OK) {
 11316e0:	f9405e62 	ldr	x2, [x19, #184]
 11316e4:	aa0003e1 	mov	x1, x0
 11316e8:	aa1503e0 	mov	x0, x21
 11316ec:	d63f0040 	blr	x2
 11316f0:	2a0003f3 	mov	w19, w0
 11316f4:	35000540 	cbnz	w0, 113179c <hmac_done+0x154>
       goto LBL_ERR;
    }

    /* Create the second HMAC vector vector for step (3) */
    for(i=0; i < LTC_HMAC_BLOCKSIZE; i++) {
 11316f8:	f87a7b62 	ldr	x2, [x27, x26, lsl #3]
        buf[i] = hmac->key[i] ^ 0x5C;
 11316fc:	9106a2a3 	add	x3, x21, #0x1a8
    for(i=0; i < LTC_HMAC_BLOCKSIZE; i++) {
 1131700:	d2800000 	mov	x0, #0x0                   	// #0
        buf[i] = hmac->key[i] ^ 0x5C;
 1131704:	52800b84 	mov	w4, #0x5c                  	// #92
    for(i=0; i < LTC_HMAC_BLOCKSIZE; i++) {
 1131708:	f9400c41 	ldr	x1, [x2, #24]
 113170c:	eb00003f 	cmp	x1, x0
 1131710:	54000708 	b.hi	11317f0 <hmac_done+0x1a8>  // b.pmore
    }

    /* Now calculate the "outer" hash for step (5), (6), and (7) */
    if ((err = hash_descriptor[hash]->init(&hmac->md)) != CRYPT_OK) {
 1131714:	f9405441 	ldr	x1, [x2, #168]
 1131718:	aa1503e0 	mov	x0, x21
 113171c:	d63f0020 	blr	x1
 1131720:	2a0003f3 	mov	w19, w0
 1131724:	350003c0 	cbnz	w0, 113179c <hmac_done+0x154>
       goto LBL_ERR;
    }
    if ((err = hash_descriptor[hash]->process(&hmac->md, buf, LTC_HMAC_BLOCKSIZE)) != CRYPT_OK) {
 1131728:	b000015b 	adrp	x27, 115a000 <__scattered_array_1phys_mem_map+0x8>
 113172c:	aa1403e1 	mov	x1, x20
 1131730:	f941a37b 	ldr	x27, [x27, #832]
 1131734:	f87a7b60 	ldr	x0, [x27, x26, lsl #3]
 1131738:	f9400c02 	ldr	x2, [x0, #24]
 113173c:	f9405803 	ldr	x3, [x0, #176]
 1131740:	aa1503e0 	mov	x0, x21
 1131744:	d63f0060 	blr	x3
 1131748:	2a0003f3 	mov	w19, w0
 113174c:	35000280 	cbnz	w0, 113179c <hmac_done+0x154>
       goto LBL_ERR;
    }
    if ((err = hash_descriptor[hash]->process(&hmac->md, isha, hashsize)) != CRYPT_OK) {
 1131750:	f87a7b60 	ldr	x0, [x27, x26, lsl #3]
 1131754:	aa1703e2 	mov	x2, x23
 1131758:	aa1603e1 	mov	x1, x22
 113175c:	f9405803 	ldr	x3, [x0, #176]
 1131760:	aa1503e0 	mov	x0, x21
 1131764:	d63f0060 	blr	x3
 1131768:	2a0003f3 	mov	w19, w0
 113176c:	35000180 	cbnz	w0, 113179c <hmac_done+0x154>
       goto LBL_ERR;
    }
    if ((err = hash_descriptor[hash]->done(&hmac->md, buf)) != CRYPT_OK) {
 1131770:	f87a7b60 	ldr	x0, [x27, x26, lsl #3]
 1131774:	aa1403e1 	mov	x1, x20
 1131778:	f9405c02 	ldr	x2, [x0, #184]
 113177c:	aa1503e0 	mov	x0, x21
 1131780:	d63f0040 	blr	x2
 1131784:	2a0003f3 	mov	w19, w0
 1131788:	350000a0 	cbnz	w0, 113179c <hmac_done+0x154>
       goto LBL_ERR;
    }

    /* copy to output  */
    for (i = 0; i < hashsize && i < *outlen; i++) {
 113178c:	d2800000 	mov	x0, #0x0                   	// #0
 1131790:	eb17001f 	cmp	x0, x23
 1131794:	54000381 	b.ne	1131804 <hmac_done+0x1bc>  // b.any
        out[i] = buf[i];
    }
    *outlen = i;
 1131798:	f9000300 	str	x0, [x24]

    err = CRYPT_OK;
LBL_ERR:
#ifdef LTC_CLEAN_STACK
    zeromem(isha, hashsize);
 113179c:	aa1703e1 	mov	x1, x23
 11317a0:	aa1603e0 	mov	x0, x22
 11317a4:	94000328 	bl	1132444 <zeromem>
    zeromem(buf,  hashsize);
 11317a8:	aa1703e1 	mov	x1, x23
 11317ac:	aa1403e0 	mov	x0, x20
 11317b0:	94000325 	bl	1132444 <zeromem>
    zeromem(hmac, sizeof(*hmac));
 11317b4:	d2804701 	mov	x1, #0x238                 	// #568
 11317b8:	aa1503e0 	mov	x0, x21
 11317bc:	94000322 	bl	1132444 <zeromem>
#endif

    XFREE(isha);
 11317c0:	aa1603e0 	mov	x0, x22
 11317c4:	94004787 	bl	11435e0 <free>
    XFREE(buf);
 11317c8:	aa1403e0 	mov	x0, x20
 11317cc:	94004785 	bl	11435e0 <free>

    return err;
}
 11317d0:	2a1303e0 	mov	w0, w19
 11317d4:	a94153f3 	ldp	x19, x20, [sp, #16]
 11317d8:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11317dc:	a94363f7 	ldp	x23, x24, [sp, #48]
 11317e0:	a9446bf9 	ldp	x25, x26, [sp, #64]
 11317e4:	f9402bfb 	ldr	x27, [sp, #80]
 11317e8:	a8c67bfd 	ldp	x29, x30, [sp], #96
 11317ec:	d65f03c0 	ret
        buf[i] = hmac->key[i] ^ 0x5C;
 11317f0:	38606861 	ldrb	w1, [x3, x0]
 11317f4:	4a040021 	eor	w1, w1, w4
 11317f8:	38206a81 	strb	w1, [x20, x0]
    for(i=0; i < LTC_HMAC_BLOCKSIZE; i++) {
 11317fc:	91000400 	add	x0, x0, #0x1
 1131800:	17ffffc2 	b	1131708 <hmac_done+0xc0>
    for (i = 0; i < hashsize && i < *outlen; i++) {
 1131804:	f9400301 	ldr	x1, [x24]
 1131808:	eb00003f 	cmp	x1, x0
 113180c:	54fffc69 	b.ls	1131798 <hmac_done+0x150>  // b.plast
        out[i] = buf[i];
 1131810:	38606a81 	ldrb	w1, [x20, x0]
 1131814:	38206b21 	strb	w1, [x25, x0]
    for (i = 0; i < hashsize && i < *outlen; i++) {
 1131818:	91000400 	add	x0, x0, #0x1
 113181c:	17ffffdd 	b	1131790 <hmac_done+0x148>
    LTC_ARGCHK(hmac  != NULL);
 1131820:	52800213 	mov	w19, #0x10                  	// #16
 1131824:	17ffffeb 	b	11317d0 <hmac_done+0x188>

0000000001131828 <hmac_init>:
   @param key      The secret key
   @param keylen   The length of the secret key (octets)
   @return CRYPT_OK if successful
*/
int hmac_init(hmac_state *hmac, int hash, const unsigned char *key, unsigned long keylen)
{
 1131828:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
 113182c:	910003fd 	mov	x29, sp
 1131830:	a90153f3 	stp	x19, x20, [sp, #16]
 1131834:	a9025bf5 	stp	x21, x22, [sp, #32]
 1131838:	a90363f7 	stp	x23, x24, [sp, #48]
 113183c:	a9046bf9 	stp	x25, x26, [sp, #64]
 1131840:	a90573fb 	stp	x27, x28, [sp, #80]
    unsigned char *buf;
    unsigned long hashsize;
    unsigned long i, z;
    int err;

    LTC_ARGCHK(hmac != NULL);
 1131844:	b4000bc0 	cbz	x0, 11319bc <hmac_init+0x194>
 1131848:	aa0203fb 	mov	x27, x2
    LTC_ARGCHK(key  != NULL);
 113184c:	b4000b82 	cbz	x2, 11319bc <hmac_init+0x194>
 1131850:	aa0003f5 	mov	x21, x0
 1131854:	2a0103fa 	mov	w26, w1
 1131858:	aa0303f6 	mov	x22, x3

    /* valid hash? */
    if ((err = hash_is_valid(hash)) != CRYPT_OK) {
 113185c:	2a0103e0 	mov	w0, w1
 1131860:	94000385 	bl	1132674 <hash_is_valid>
 1131864:	2a0003f3 	mov	w19, w0
 1131868:	35000480 	cbnz	w0, 11318f8 <hmac_init+0xd0>
        return err;
    }
    hmac->hash = hash;
 113186c:	b900d2ba 	str	w26, [x21, #208]
    hashsize   = hash_descriptor[hash]->hashsize;

    /* valid key length? */
    if (keylen == 0) {
 1131870:	b4000ab6 	cbz	x22, 11319c4 <hmac_init+0x19c>
    hashsize   = hash_descriptor[hash]->hashsize;
 1131874:	b0000159 	adrp	x25, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1131878:	93407f58 	sxtw	x24, w26
 113187c:	aa1903f7 	mov	x23, x25
 1131880:	f941a320 	ldr	x0, [x25, #832]
 1131884:	f8787800 	ldr	x0, [x0, x24, lsl #3]
        return CRYPT_INVALID_KEYSIZE;
    }

    /* allocate ram for buf */
    buf = XMALLOC(LTC_HMAC_BLOCKSIZE);
 1131888:	a9414c05 	ldp	x5, x19, [x0, #16]
    hashsize   = hash_descriptor[hash]->hashsize;
 113188c:	f90037e5 	str	x5, [sp, #104]
    buf = XMALLOC(LTC_HMAC_BLOCKSIZE);
 1131890:	aa1303e0 	mov	x0, x19
 1131894:	940046f1 	bl	1143458 <malloc>
 1131898:	aa0003f4 	mov	x20, x0
    if (buf == NULL) {
 113189c:	b4000980 	cbz	x0, 11319cc <hmac_init+0x1a4>
       return CRYPT_MEM;
    }

    /* check hash block fits */
    if (sizeof(hmac->key) < LTC_HMAC_BLOCKSIZE) {
 11318a0:	f102427f 	cmp	x19, #0x90
 11318a4:	54000888 	b.hi	11319b4 <hmac_init+0x18c>  // b.pmore
        err = CRYPT_BUFFER_OVERFLOW;
        goto LBL_ERR;
    }

    /* (1) make sure we have a large enough key */
    if(keylen > LTC_HMAC_BLOCKSIZE) {
 11318a8:	9106a2bc 	add	x28, x21, #0x1a8
 11318ac:	eb16027f 	cmp	x19, x22
 11318b0:	54000342 	b.cs	1131918 <hmac_init+0xf0>  // b.hs, b.nlast
        z = LTC_HMAC_BLOCKSIZE;
        if ((err = hash_memory(hash, key, keylen, hmac->key, &z)) != CRYPT_OK) {
 11318b4:	9101e3e4 	add	x4, sp, #0x78
 11318b8:	aa1c03e3 	mov	x3, x28
 11318bc:	aa1603e2 	mov	x2, x22
 11318c0:	aa1b03e1 	mov	x1, x27
 11318c4:	2a1a03e0 	mov	w0, w26
        z = LTC_HMAC_BLOCKSIZE;
 11318c8:	f9003ff3 	str	x19, [sp, #120]
        if ((err = hash_memory(hash, key, keylen, hmac->key, &z)) != CRYPT_OK) {
 11318cc:	94001bf8 	bl	11388ac <hash_memory>
 11318d0:	2a0003f3 	mov	w19, w0
 11318d4:	f94037e5 	ldr	x5, [sp, #104]
 11318d8:	340002a0 	cbz	w0, 113192c <hmac_init+0x104>
       goto LBL_ERR;
    }

LBL_ERR:
#ifdef LTC_CLEAN_STACK
   zeromem(buf, LTC_HMAC_BLOCKSIZE);
 11318dc:	f941a2f7 	ldr	x23, [x23, #832]
 11318e0:	f8787ae0 	ldr	x0, [x23, x24, lsl #3]
 11318e4:	f9400c01 	ldr	x1, [x0, #24]
 11318e8:	aa1403e0 	mov	x0, x20
 11318ec:	940002d6 	bl	1132444 <zeromem>
#endif

   XFREE(buf);
 11318f0:	aa1403e0 	mov	x0, x20
 11318f4:	9400473b 	bl	11435e0 <free>
   return err;
}
 11318f8:	2a1303e0 	mov	w0, w19
 11318fc:	a94153f3 	ldp	x19, x20, [sp, #16]
 1131900:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1131904:	a94363f7 	ldp	x23, x24, [sp, #48]
 1131908:	a9446bf9 	ldp	x25, x26, [sp, #64]
 113190c:	a94573fb 	ldp	x27, x28, [sp, #80]
 1131910:	a8c87bfd 	ldp	x29, x30, [sp], #128
 1131914:	d65f03c0 	ret
        XMEMCPY(hmac->key, key, (size_t)keylen);
 1131918:	aa1603e2 	mov	x2, x22
 113191c:	aa1b03e1 	mov	x1, x27
 1131920:	aa1c03e0 	mov	x0, x28
 1131924:	97ff469b 	bl	1103390 <memcpy>
 1131928:	aa1603e5 	mov	x5, x22
    if(keylen < LTC_HMAC_BLOCKSIZE) {
 113192c:	f941a2e0 	ldr	x0, [x23, #832]
 1131930:	f8787800 	ldr	x0, [x0, x24, lsl #3]
 1131934:	f9400c01 	ldr	x1, [x0, #24]
 1131938:	eb05003f 	cmp	x1, x5
 113193c:	54000089 	b.ls	113194c <hmac_init+0x124>  // b.plast
       zeromem((hmac->key) + keylen, (size_t)(LTC_HMAC_BLOCKSIZE - keylen));
 1131940:	cb050021 	sub	x1, x1, x5
 1131944:	8b050380 	add	x0, x28, x5
 1131948:	940002bf 	bl	1132444 <zeromem>
    for(i=0; i < LTC_HMAC_BLOCKSIZE;   i++) {
 113194c:	f941a2e0 	ldr	x0, [x23, #832]
       buf[i] = hmac->key[i] ^ 0x36;
 1131950:	528006c3 	mov	w3, #0x36                  	// #54
    for(i=0; i < LTC_HMAC_BLOCKSIZE;   i++) {
 1131954:	f8787802 	ldr	x2, [x0, x24, lsl #3]
 1131958:	d2800000 	mov	x0, #0x0                   	// #0
 113195c:	f9400c41 	ldr	x1, [x2, #24]
 1131960:	eb00003f 	cmp	x1, x0
 1131964:	540001e8 	b.hi	11319a0 <hmac_init+0x178>  // b.pmore
    if ((err = hash_descriptor[hash]->init(&hmac->md)) != CRYPT_OK) {
 1131968:	f9405441 	ldr	x1, [x2, #168]
 113196c:	aa1503e0 	mov	x0, x21
 1131970:	d63f0020 	blr	x1
 1131974:	2a0003f3 	mov	w19, w0
 1131978:	35fffb20 	cbnz	w0, 11318dc <hmac_init+0xb4>
    if ((err = hash_descriptor[hash]->process(&hmac->md, buf, LTC_HMAC_BLOCKSIZE)) != CRYPT_OK) {
 113197c:	f941a2e0 	ldr	x0, [x23, #832]
 1131980:	aa1403e1 	mov	x1, x20
 1131984:	f8787800 	ldr	x0, [x0, x24, lsl #3]
 1131988:	f9400c02 	ldr	x2, [x0, #24]
 113198c:	f9405803 	ldr	x3, [x0, #176]
 1131990:	aa1503e0 	mov	x0, x21
 1131994:	d63f0060 	blr	x3
 1131998:	2a0003f3 	mov	w19, w0
LBL_ERR:
 113199c:	17ffffd0 	b	11318dc <hmac_init+0xb4>
       buf[i] = hmac->key[i] ^ 0x36;
 11319a0:	38606b81 	ldrb	w1, [x28, x0]
 11319a4:	4a030021 	eor	w1, w1, w3
 11319a8:	38206a81 	strb	w1, [x20, x0]
    for(i=0; i < LTC_HMAC_BLOCKSIZE;   i++) {
 11319ac:	91000400 	add	x0, x0, #0x1
 11319b0:	17ffffeb 	b	113195c <hmac_init+0x134>
        err = CRYPT_BUFFER_OVERFLOW;
 11319b4:	528000d3 	mov	w19, #0x6                   	// #6
 11319b8:	17ffffc9 	b	11318dc <hmac_init+0xb4>
    LTC_ARGCHK(hmac != NULL);
 11319bc:	52800213 	mov	w19, #0x10                  	// #16
 11319c0:	17ffffce 	b	11318f8 <hmac_init+0xd0>
        return CRYPT_INVALID_KEYSIZE;
 11319c4:	52800073 	mov	w19, #0x3                   	// #3
 11319c8:	17ffffcc 	b	11318f8 <hmac_init+0xd0>
       return CRYPT_MEM;
 11319cc:	528001b3 	mov	w19, #0xd                   	// #13
 11319d0:	17ffffca 	b	11318f8 <hmac_init+0xd0>

00000000011319d4 <hmac_process>:
  @return CRYPT_OK if successful
*/
int hmac_process(hmac_state *hmac, const unsigned char *in, unsigned long inlen)
{
    int err;
    LTC_ARGCHK(hmac != NULL);
 11319d4:	b4000320 	cbz	x0, 1131a38 <hmac_process+0x64>
{
 11319d8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 11319dc:	910003fd 	mov	x29, sp
 11319e0:	a90153f3 	stp	x19, x20, [sp, #16]
 11319e4:	aa0103f4 	mov	x20, x1
 11319e8:	f90013f5 	str	x21, [sp, #32]
    LTC_ARGCHK(in != NULL);
 11319ec:	b40002a1 	cbz	x1, 1131a40 <hmac_process+0x6c>
 11319f0:	aa0003f3 	mov	x19, x0
    if ((err = hash_is_valid(hmac->hash)) != CRYPT_OK) {
 11319f4:	b940d000 	ldr	w0, [x0, #208]
 11319f8:	aa0203f5 	mov	x21, x2
 11319fc:	9400031e 	bl	1132674 <hash_is_valid>
 1131a00:	35000220 	cbnz	w0, 1131a44 <hmac_process+0x70>
        return err;
    }
    return hash_descriptor[hmac->hash]->process(&hmac->md, in, inlen);
 1131a04:	b0000140 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1131a08:	b980d261 	ldrsw	x1, [x19, #208]
 1131a0c:	aa1503e2 	mov	x2, x21
 1131a10:	f941a000 	ldr	x0, [x0, #832]
}
 1131a14:	f94013f5 	ldr	x21, [sp, #32]
    return hash_descriptor[hmac->hash]->process(&hmac->md, in, inlen);
 1131a18:	f8617800 	ldr	x0, [x0, x1, lsl #3]
 1131a1c:	aa1403e1 	mov	x1, x20
 1131a20:	f9405803 	ldr	x3, [x0, #176]
 1131a24:	aa1303e0 	mov	x0, x19
}
 1131a28:	a94153f3 	ldp	x19, x20, [sp, #16]
    return hash_descriptor[hmac->hash]->process(&hmac->md, in, inlen);
 1131a2c:	aa0303f0 	mov	x16, x3
}
 1131a30:	a8c37bfd 	ldp	x29, x30, [sp], #48
    return hash_descriptor[hmac->hash]->process(&hmac->md, in, inlen);
 1131a34:	d61f0200 	br	x16
    LTC_ARGCHK(hmac != NULL);
 1131a38:	52800200 	mov	w0, #0x10                  	// #16
}
 1131a3c:	d65f03c0 	ret
    LTC_ARGCHK(hmac != NULL);
 1131a40:	52800200 	mov	w0, #0x10                  	// #16
}
 1131a44:	a94153f3 	ldp	x19, x20, [sp, #16]
 1131a48:	f94013f5 	ldr	x21, [sp, #32]
 1131a4c:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1131a50:	d65f03c0 	ret

0000000001131a54 <omac_done>:
  @param out    [out] Destination for the authentication tag
  @param outlen [in/out]  The max size and resulting size of the authentication tag
  @return CRYPT_OK if successful
*/
int omac_done(omac_state *omac, unsigned char *out, unsigned long *outlen)
{
 1131a54:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 1131a58:	910003fd 	mov	x29, sp
 1131a5c:	a90153f3 	stp	x19, x20, [sp, #16]
 1131a60:	a9025bf5 	stp	x21, x22, [sp, #32]
 1131a64:	a90363f7 	stp	x23, x24, [sp, #48]
 1131a68:	f90023f9 	str	x25, [sp, #64]
   int       err, mode;
   unsigned  x;

   LTC_ARGCHK(omac   != NULL);
 1131a6c:	b5000120 	cbnz	x0, 1131a90 <omac_done+0x3c>
 1131a70:	52800214 	mov	w20, #0x10                  	// #16

#ifdef LTC_CLEAN_STACK
   zeromem(omac, sizeof(*omac));
#endif
   return CRYPT_OK;
}
 1131a74:	2a1403e0 	mov	w0, w20
 1131a78:	a94153f3 	ldp	x19, x20, [sp, #16]
 1131a7c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1131a80:	a94363f7 	ldp	x23, x24, [sp, #48]
 1131a84:	f94023f9 	ldr	x25, [sp, #64]
 1131a88:	a8c57bfd 	ldp	x29, x30, [sp], #80
 1131a8c:	d65f03c0 	ret
 1131a90:	aa0103f6 	mov	x22, x1
   LTC_ARGCHK(out    != NULL);
 1131a94:	b4fffee1 	cbz	x1, 1131a70 <omac_done+0x1c>
 1131a98:	aa0203f5 	mov	x21, x2
   LTC_ARGCHK(outlen != NULL);
 1131a9c:	b4fffea2 	cbz	x2, 1131a70 <omac_done+0x1c>
 1131aa0:	aa0003f3 	mov	x19, x0
   if ((err = cipher_is_valid(omac->cipher_idx)) != CRYPT_OK) {
 1131aa4:	b9400000 	ldr	w0, [x0]
 1131aa8:	9400026a 	bl	1132450 <cipher_is_valid>
 1131aac:	2a0003f4 	mov	w20, w0
 1131ab0:	35fffe20 	cbnz	w0, 1131a74 <omac_done+0x20>
   if ((omac->buflen > (int)sizeof(omac->block)) || (omac->buflen < 0) ||
 1131ab4:	b9400660 	ldr	w0, [x19, #4]
 1131ab8:	7102401f 	cmp	w0, #0x90
 1131abc:	54fffda8 	b.hi	1131a70 <omac_done+0x1c>  // b.pmore
       (omac->blklen > (int)sizeof(omac->block)) || (omac->buflen > omac->blklen)) {
 1131ac0:	b9400a62 	ldr	w2, [x19, #8]
   if ((omac->buflen > (int)sizeof(omac->block)) || (omac->buflen < 0) ||
 1131ac4:	7102405f 	cmp	w2, #0x90
 1131ac8:	54fffd4c 	b.gt	1131a70 <omac_done+0x1c>
       (omac->blklen > (int)sizeof(omac->block)) || (omac->buflen > omac->blklen)) {
 1131acc:	6b02001f 	cmp	w0, w2
 1131ad0:	54fffd0c 	b.gt	1131a70 <omac_done+0x1c>
   if (omac->buflen != omac->blklen) {
 1131ad4:	54000140 	b.eq	1131afc <omac_done+0xa8>  // b.none
      omac->block[omac->buflen++] = 0x80;
 1131ad8:	11000401 	add	w1, w0, #0x1
 1131adc:	8b20c260 	add	x0, x19, w0, sxtw
 1131ae0:	b9000661 	str	w1, [x19, #4]
 1131ae4:	12800fe1 	mov	w1, #0xffffff80            	// #-128
 1131ae8:	39003001 	strb	w1, [x0, #12]
      while (omac->buflen < omac->blklen) {
 1131aec:	b9400660 	ldr	w0, [x19, #4]
 1131af0:	6b00005f 	cmp	w2, w0
 1131af4:	5400052c 	b.gt	1131b98 <omac_done+0x144>
      mode = 1;
 1131af8:	52800034 	mov	w20, #0x1                   	// #1
   for (x = 0; x < (unsigned)omac->blklen; x++) {
 1131afc:	d2802560 	mov	x0, #0x12b                 	// #299
 1131b00:	52801201 	mov	w1, #0x90                  	// #144
 1131b04:	9b210294 	smaddl	x20, w20, w1, x0
 1131b08:	aa1303e0 	mov	x0, x19
 1131b0c:	91000400 	add	x0, x0, #0x1
 1131b10:	51000401 	sub	w1, w0, #0x1
 1131b14:	4b130021 	sub	w1, w1, w19
 1131b18:	6b01005f 	cmp	w2, w1
 1131b1c:	54000488 	b.hi	1131bac <omac_done+0x158>  // b.pmore
   if ((err = cipher_descriptor[omac->cipher_idx]->ecb_encrypt(omac->block, omac->block, &omac->key)) != CRYPT_OK) {
 1131b20:	b0000157 	adrp	x23, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1131b24:	b9800260 	ldrsw	x0, [x19]
 1131b28:	91003278 	add	x24, x19, #0xc
 1131b2c:	91094279 	add	x25, x19, #0x250
 1131b30:	f941c2f7 	ldr	x23, [x23, #896]
 1131b34:	aa1903e2 	mov	x2, x25
 1131b38:	aa1803e1 	mov	x1, x24
 1131b3c:	f8607ae0 	ldr	x0, [x23, x0, lsl #3]
 1131b40:	f9401403 	ldr	x3, [x0, #40]
 1131b44:	aa1803e0 	mov	x0, x24
 1131b48:	d63f0060 	blr	x3
 1131b4c:	2a0003f4 	mov	w20, w0
 1131b50:	35fff920 	cbnz	w0, 1131a74 <omac_done+0x20>
   cipher_descriptor[omac->cipher_idx]->done(&omac->key);
 1131b54:	b9800260 	ldrsw	x0, [x19]
 1131b58:	f8607ae0 	ldr	x0, [x23, x0, lsl #3]
 1131b5c:	f9402001 	ldr	x1, [x0, #64]
 1131b60:	aa1903e0 	mov	x0, x25
 1131b64:	d63f0020 	blr	x1
   for (x = 0; x < (unsigned)omac->blklen && x < *outlen; x++) {
 1131b68:	d2800000 	mov	x0, #0x0                   	// #0
 1131b6c:	b9400a61 	ldr	w1, [x19, #8]
 1131b70:	6b00003f 	cmp	w1, w0
 1131b74:	54000089 	b.ls	1131b84 <omac_done+0x130>  // b.plast
 1131b78:	f94002a1 	ldr	x1, [x21]
 1131b7c:	eb00003f 	cmp	x1, x0
 1131b80:	54000248 	b.hi	1131bc8 <omac_done+0x174>  // b.pmore
   *outlen = x;
 1131b84:	f90002a0 	str	x0, [x21]
   zeromem(omac, sizeof(*omac));
 1131b88:	d280aa01 	mov	x1, #0x550                 	// #1360
 1131b8c:	aa1303e0 	mov	x0, x19
 1131b90:	9400022d 	bl	1132444 <zeromem>
   return CRYPT_OK;
 1131b94:	17ffffb8 	b	1131a74 <omac_done+0x20>
         omac->block[omac->buflen++] = 0x00;
 1131b98:	11000401 	add	w1, w0, #0x1
 1131b9c:	8b20c260 	add	x0, x19, w0, sxtw
 1131ba0:	b9000661 	str	w1, [x19, #4]
 1131ba4:	3900301f 	strb	wzr, [x0, #12]
 1131ba8:	17ffffd1 	b	1131aec <omac_done+0x98>
       omac->block[x] ^= omac->prev[x] ^ omac->Lu[mode][x];
 1131bac:	39402c01 	ldrb	w1, [x0, #11]
 1131bb0:	39426c03 	ldrb	w3, [x0, #155]
 1131bb4:	4a030021 	eor	w1, w1, w3
 1131bb8:	38746803 	ldrb	w3, [x0, x20]
 1131bbc:	4a030021 	eor	w1, w1, w3
 1131bc0:	39002c01 	strb	w1, [x0, #11]
   for (x = 0; x < (unsigned)omac->blklen; x++) {
 1131bc4:	17ffffd2 	b	1131b0c <omac_done+0xb8>
       out[x] = omac->block[x];
 1131bc8:	38606b01 	ldrb	w1, [x24, x0]
 1131bcc:	38206ac1 	strb	w1, [x22, x0]
   for (x = 0; x < (unsigned)omac->blklen && x < *outlen; x++) {
 1131bd0:	91000400 	add	x0, x0, #0x1
 1131bd4:	17ffffe6 	b	1131b6c <omac_done+0x118>

0000000001131bd8 <omac_init>:
   @param key     The secret key
   @param keylen  The length of the secret key (octets)
   @return CRYPT_OK if successful
*/
int omac_init(omac_state *omac, int cipher, const unsigned char *key, unsigned long keylen)
{
 1131bd8:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
 1131bdc:	910003fd 	mov	x29, sp
 1131be0:	a90153f3 	stp	x19, x20, [sp, #16]
 1131be4:	a9025bf5 	stp	x21, x22, [sp, #32]
 1131be8:	a90363f7 	stp	x23, x24, [sp, #48]
 1131bec:	a9046bf9 	stp	x25, x26, [sp, #64]
 1131bf0:	a90573fb 	stp	x27, x28, [sp, #80]
   int err, x, y, mask, msb, len;

   LTC_ARGCHK(omac != NULL);
 1131bf4:	b4000c40 	cbz	x0, 1131d7c <omac_init+0x1a4>
 1131bf8:	aa0203f8 	mov	x24, x2
   LTC_ARGCHK(key  != NULL);
 1131bfc:	b4000c02 	cbz	x2, 1131d7c <omac_init+0x1a4>
 1131c00:	aa0003f4 	mov	x20, x0
 1131c04:	2a0103f6 	mov	w22, w1
 1131c08:	aa0303fa 	mov	x26, x3

   /* schedule the key */
   if ((err = cipher_is_valid(cipher)) != CRYPT_OK) {
 1131c0c:	2a0103e0 	mov	w0, w1
 1131c10:	94000210 	bl	1132450 <cipher_is_valid>
 1131c14:	2a0003f3 	mov	w19, w0
 1131c18:	350008c0 	cbnz	w0, 1131d30 <omac_init+0x158>
       return CRYPT_INVALID_ARG;
   }
#endif

   /* now setup the system */
   switch (cipher_descriptor[cipher]->block_length) {
 1131c1c:	b0000140 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1131c20:	93407ed9 	sxtw	x25, w22
 1131c24:	f941c000 	ldr	x0, [x0, #896]
 1131c28:	f8797800 	ldr	x0, [x0, x25, lsl #3]
 1131c2c:	b9401415 	ldr	w21, [x0, #20]
 1131c30:	710022bf 	cmp	w21, #0x8
 1131c34:	540008e0 	b.eq	1131d50 <omac_init+0x178>  // b.none
 1131c38:	710042bf 	cmp	w21, #0x10
 1131c3c:	54000a01 	b.ne	1131d7c <omac_init+0x1a4>  // b.any
 1131c40:	528010f7 	mov	w23, #0x87                  	// #135
                len  = 16;
                break;
       default: return CRYPT_INVALID_ARG;
   }

   if ((err = cipher_descriptor[cipher]->setup(key, keylen, 0, &omac->key)) != CRYPT_OK) {
 1131c44:	f9401004 	ldr	x4, [x0, #32]
 1131c48:	9109429b 	add	x27, x20, #0x250
 1131c4c:	aa1b03e3 	mov	x3, x27
 1131c50:	2a1a03e1 	mov	w1, w26
 1131c54:	aa1803e0 	mov	x0, x24
 1131c58:	52800002 	mov	w2, #0x0                   	// #0
 1131c5c:	d63f0080 	blr	x4
 1131c60:	2a0003f3 	mov	w19, w0
 1131c64:	35000660 	cbnz	w0, 1131d30 <omac_init+0x158>
   }

   /* ok now we need Lu and Lu^2 [calc one from the other] */

   /* first calc L which is Ek(0) */
   zeromem(omac->Lu[0], cipher_descriptor[cipher]->block_length);
 1131c68:	b0000140 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1131c6c:	9104b29a 	add	x26, x20, #0x12c
 1131c70:	f941c013 	ldr	x19, [x0, #896]
 1131c74:	f8797a60 	ldr	x0, [x19, x25, lsl #3]
 1131c78:	b9801401 	ldrsw	x1, [x0, #20]
 1131c7c:	aa1a03e0 	mov	x0, x26
 1131c80:	940001f1 	bl	1132444 <zeromem>
   if ((err = cipher_descriptor[cipher]->ecb_encrypt(omac->Lu[0], omac->Lu[0], &omac->key)) != CRYPT_OK) {
 1131c84:	f8797a60 	ldr	x0, [x19, x25, lsl #3]
 1131c88:	aa1b03e2 	mov	x2, x27
 1131c8c:	aa1a03e1 	mov	x1, x26
 1131c90:	f9401403 	ldr	x3, [x0, #40]
 1131c94:	aa1a03e0 	mov	x0, x26
 1131c98:	d63f0060 	blr	x3
 1131c9c:	2a0003f3 	mov	w19, w0
 1131ca0:	35000480 	cbnz	w0, 1131d30 <omac_init+0x158>
 1131ca4:	aa1403f9 	mov	x25, x20
 1131ca8:	8b35c298 	add	x24, x20, w21, sxtw
   for (x = 0; x < 2; x++) {
       /* if msb(L * u^(x+1)) = 0 then just shift, otherwise shift and xor constant mask */
       msb = omac->Lu[x][0] >> 7;

       /* shift left */
       for (y = 0; y < (len - 1); y++) {
 1131cac:	510006bc 	sub	w28, w21, #0x1
       }
       omac->Lu[x][len - 1] = ((omac->Lu[x][len - 1] << 1) ^ (msb ? mask : 0)) & 255;

       /* copy up as require */
       if (x == 0) {
          XMEMCPY(omac->Lu[1], omac->Lu[0], sizeof(omac->Lu[0]));
 1131cb0:	9106f285 	add	x5, x20, #0x1bc
   for (x = 0; x < 2; x++) {
 1131cb4:	5280001b 	mov	w27, #0x0                   	// #0
       msb = omac->Lu[x][0] >> 7;
 1131cb8:	3944b321 	ldrb	w1, [x25, #300]
       for (y = 0; y < (len - 1); y++) {
 1131cbc:	aa1903e0 	mov	x0, x25
 1131cc0:	52800002 	mov	w2, #0x0                   	// #0
       msb = omac->Lu[x][0] >> 7;
 1131cc4:	53077c21 	lsr	w1, w1, #7
       for (y = 0; y < (len - 1); y++) {
 1131cc8:	91000400 	add	x0, x0, #0x1
 1131ccc:	6b02039f 	cmp	w28, w2
 1131cd0:	5400048c 	b.gt	1131d60 <omac_init+0x188>
       omac->Lu[x][len - 1] = ((omac->Lu[x][len - 1] << 1) ^ (msb ? mask : 0)) & 255;
 1131cd4:	3944af00 	ldrb	w0, [x24, #299]
 1131cd8:	7100003f 	cmp	w1, #0x0
 1131cdc:	1a9f12e1 	csel	w1, w23, wzr, ne  // ne = any
 1131ce0:	93401800 	sbfx	x0, x0, #0, #7
 1131ce4:	4a000420 	eor	w0, w1, w0, lsl #1
 1131ce8:	3904af00 	strb	w0, [x24, #299]
       if (x == 0) {
 1131cec:	350000db 	cbnz	w27, 1131d04 <omac_init+0x12c>
          XMEMCPY(omac->Lu[1], omac->Lu[0], sizeof(omac->Lu[0]));
 1131cf0:	aa0503e0 	mov	x0, x5
 1131cf4:	aa1a03e1 	mov	x1, x26
 1131cf8:	d2801202 	mov	x2, #0x90                  	// #144
 1131cfc:	97ff45a5 	bl	1103390 <memcpy>
 1131d00:	aa0003e5 	mov	x5, x0
   for (x = 0; x < 2; x++) {
 1131d04:	91024339 	add	x25, x25, #0x90
 1131d08:	91024318 	add	x24, x24, #0x90
 1131d0c:	3400027b 	cbz	w27, 1131d58 <omac_init+0x180>
       }
   }

   /* setup state */
   omac->cipher_idx = cipher;
   omac->buflen     = 0;
 1131d10:	29007e96 	stp	w22, wzr, [x20]
   omac->blklen     = len;
   zeromem(omac->prev,  sizeof(omac->prev));
 1131d14:	91027280 	add	x0, x20, #0x9c
   omac->blklen     = len;
 1131d18:	b9000a95 	str	w21, [x20, #8]
   zeromem(omac->prev,  sizeof(omac->prev));
 1131d1c:	d2801201 	mov	x1, #0x90                  	// #144
 1131d20:	940001c9 	bl	1132444 <zeromem>
   zeromem(omac->block, sizeof(omac->block));
 1131d24:	91003280 	add	x0, x20, #0xc
 1131d28:	d2801201 	mov	x1, #0x90                  	// #144
 1131d2c:	940001c6 	bl	1132444 <zeromem>

   return CRYPT_OK;
}
 1131d30:	2a1303e0 	mov	w0, w19
 1131d34:	a94153f3 	ldp	x19, x20, [sp, #16]
 1131d38:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1131d3c:	a94363f7 	ldp	x23, x24, [sp, #48]
 1131d40:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1131d44:	a94573fb 	ldp	x27, x28, [sp, #80]
 1131d48:	a8c67bfd 	ldp	x29, x30, [sp], #96
 1131d4c:	d65f03c0 	ret
       case 8:  mask = 0x1B;
 1131d50:	52800377 	mov	w23, #0x1b                  	// #27
 1131d54:	17ffffbc 	b	1131c44 <omac_init+0x6c>
 1131d58:	5280003b 	mov	w27, #0x1                   	// #1
 1131d5c:	17ffffd7 	b	1131cb8 <omac_init+0xe0>
           omac->Lu[x][y] = ((omac->Lu[x][y] << 1) | (omac->Lu[x][y+1] >> 7)) & 255;
 1131d60:	3944b004 	ldrb	w4, [x0, #300]
 1131d64:	11000442 	add	w2, w2, #0x1
 1131d68:	3944ac03 	ldrb	w3, [x0, #299]
 1131d6c:	53077c84 	lsr	w4, w4, #7
 1131d70:	2a030483 	orr	w3, w4, w3, lsl #1
 1131d74:	3904ac03 	strb	w3, [x0, #299]
       for (y = 0; y < (len - 1); y++) {
 1131d78:	17ffffd4 	b	1131cc8 <omac_init+0xf0>
   switch (cipher_descriptor[cipher]->block_length) {
 1131d7c:	52800213 	mov	w19, #0x10                  	// #16
 1131d80:	17ffffec 	b	1131d30 <omac_init+0x158>

0000000001131d84 <omac_process>:
   @param in       The input data to send through OMAC
   @param inlen    The length of the input (octets)
   @return CRYPT_OK if successful
*/
int omac_process(omac_state *omac, const unsigned char *in, unsigned long inlen)
{
 1131d84:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 1131d88:	910003fd 	mov	x29, sp
 1131d8c:	a90153f3 	stp	x19, x20, [sp, #16]
 1131d90:	a9025bf5 	stp	x21, x22, [sp, #32]
 1131d94:	a90363f7 	stp	x23, x24, [sp, #48]
 1131d98:	a9046bf9 	stp	x25, x26, [sp, #64]
   unsigned long n, x;
   int           err;

   LTC_ARGCHK(omac  != NULL);
 1131d9c:	b5000120 	cbnz	x0, 1131dc0 <omac_process+0x3c>
 1131da0:	52800215 	mov	w21, #0x10                  	// #16
       inlen         -= n;
       in            += n;
   }

   return CRYPT_OK;
}
 1131da4:	2a1503e0 	mov	w0, w21
 1131da8:	a94153f3 	ldp	x19, x20, [sp, #16]
 1131dac:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1131db0:	a94363f7 	ldp	x23, x24, [sp, #48]
 1131db4:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1131db8:	a8c57bfd 	ldp	x29, x30, [sp], #80
 1131dbc:	d65f03c0 	ret
 1131dc0:	aa0103f6 	mov	x22, x1
   LTC_ARGCHK(in    != NULL);
 1131dc4:	b4fffee1 	cbz	x1, 1131da0 <omac_process+0x1c>
 1131dc8:	aa0003f3 	mov	x19, x0
   if ((err = cipher_is_valid(omac->cipher_idx)) != CRYPT_OK) {
 1131dcc:	b9400000 	ldr	w0, [x0]
 1131dd0:	aa0203f4 	mov	x20, x2
 1131dd4:	9400019f 	bl	1132450 <cipher_is_valid>
 1131dd8:	2a0003f5 	mov	w21, w0
 1131ddc:	35fffe40 	cbnz	w0, 1131da4 <omac_process+0x20>
   if ((omac->buflen > (int)sizeof(omac->block)) || (omac->buflen < 0) ||
 1131de0:	b9400661 	ldr	w1, [x19, #4]
 1131de4:	7102403f 	cmp	w1, #0x90
 1131de8:	54fffdc8 	b.hi	1131da0 <omac_process+0x1c>  // b.pmore
       (omac->blklen > (int)sizeof(omac->block)) || (omac->buflen > omac->blklen)) {
 1131dec:	b9400a60 	ldr	w0, [x19, #8]
   if ((omac->buflen > (int)sizeof(omac->block)) || (omac->buflen < 0) ||
 1131df0:	7102401f 	cmp	w0, #0x90
 1131df4:	54fffd6c 	b.gt	1131da0 <omac_process+0x1c>
       (omac->blklen > (int)sizeof(omac->block)) || (omac->buflen > omac->blklen)) {
 1131df8:	6b00003f 	cmp	w1, w0
 1131dfc:	54fffd2c 	b.gt	1131da0 <omac_process+0x1c>
          if ((err = cipher_descriptor[omac->cipher_idx]->ecb_encrypt(omac->block, omac->prev, &omac->key)) != CRYPT_OK) {
 1131e00:	b0000159 	adrp	x25, 115a000 <__scattered_array_1phys_mem_map+0x8>
          for (x = 0; x < (unsigned long)omac->blklen; x++) {
 1131e04:	92800178 	mov	x24, #0xfffffffffffffff4    	// #-12
 1131e08:	9100327a 	add	x26, x19, #0xc
 1131e0c:	cb130318 	sub	x24, x24, x19
          if ((err = cipher_descriptor[omac->cipher_idx]->ecb_encrypt(omac->block, omac->prev, &omac->key)) != CRYPT_OK) {
 1131e10:	f941c339 	ldr	x25, [x25, #896]
   while (inlen != 0) {
 1131e14:	b4fffc94 	cbz	x20, 1131da4 <omac_process+0x20>
       if (omac->buflen == omac->blklen) {
 1131e18:	29408261 	ldp	w1, w0, [x19, #4]
 1131e1c:	6b00003f 	cmp	w1, w0
 1131e20:	540001e1 	b.ne	1131e5c <omac_process+0xd8>  // b.any
 1131e24:	aa1a03e0 	mov	x0, x26
          for (x = 0; x < (unsigned long)omac->blklen; x++) {
 1131e28:	93407c21 	sxtw	x1, w1
 1131e2c:	8b000302 	add	x2, x24, x0
 1131e30:	eb02003f 	cmp	x1, x2
 1131e34:	54000328 	b.hi	1131e98 <omac_process+0x114>  // b.pmore
          if ((err = cipher_descriptor[omac->cipher_idx]->ecb_encrypt(omac->block, omac->prev, &omac->key)) != CRYPT_OK) {
 1131e38:	aa1303e1 	mov	x1, x19
 1131e3c:	91094262 	add	x2, x19, #0x250
 1131e40:	b889c420 	ldrsw	x0, [x1], #156
 1131e44:	f8607b20 	ldr	x0, [x25, x0, lsl #3]
 1131e48:	f9401403 	ldr	x3, [x0, #40]
 1131e4c:	aa1a03e0 	mov	x0, x26
 1131e50:	d63f0060 	blr	x3
 1131e54:	350002c0 	cbnz	w0, 1131eac <omac_process+0x128>
          omac->buflen = 0;
 1131e58:	b900067f 	str	wzr, [x19, #4]
       n = MIN(inlen, (unsigned long)(omac->blklen - omac->buflen));
 1131e5c:	29408660 	ldp	w0, w1, [x19, #4]
 1131e60:	4b000021 	sub	w1, w1, w0
       XMEMCPY(omac->block + omac->buflen, in, n);
 1131e64:	8b20c340 	add	x0, x26, w0, sxtw
       n = MIN(inlen, (unsigned long)(omac->blklen - omac->buflen));
 1131e68:	eb21c29f 	cmp	x20, w1, sxtw
 1131e6c:	93407c37 	sxtw	x23, w1
 1131e70:	9a9422f7 	csel	x23, x23, x20, cs  // cs = hs, nlast
       XMEMCPY(omac->block + omac->buflen, in, n);
 1131e74:	aa1603e1 	mov	x1, x22
 1131e78:	aa1703e2 	mov	x2, x23
       inlen         -= n;
 1131e7c:	cb170294 	sub	x20, x20, x23
       XMEMCPY(omac->block + omac->buflen, in, n);
 1131e80:	97ff4544 	bl	1103390 <memcpy>
       in            += n;
 1131e84:	8b1702d6 	add	x22, x22, x23
       omac->buflen  += n;
 1131e88:	b9400660 	ldr	w0, [x19, #4]
 1131e8c:	0b170000 	add	w0, w0, w23
 1131e90:	b9000660 	str	w0, [x19, #4]
       in            += n;
 1131e94:	17ffffe0 	b	1131e14 <omac_process+0x90>
              omac->block[x] ^= omac->prev[x];
 1131e98:	39400002 	ldrb	w2, [x0]
 1131e9c:	39424003 	ldrb	w3, [x0, #144]
 1131ea0:	4a030042 	eor	w2, w2, w3
 1131ea4:	38001402 	strb	w2, [x0], #1
          for (x = 0; x < (unsigned long)omac->blklen; x++) {
 1131ea8:	17ffffe1 	b	1131e2c <omac_process+0xa8>
          if ((err = cipher_descriptor[omac->cipher_idx]->ecb_encrypt(omac->block, omac->prev, &omac->key)) != CRYPT_OK) {
 1131eac:	2a0003f5 	mov	w21, w0
 1131eb0:	17ffffbd 	b	1131da4 <omac_process+0x20>

0000000001131eb4 <ltc_init_multi>:

#ifdef LTC_MPI
#include <stdarg.h>

int ltc_init_multi(void **a, ...)
{
 1131eb4:	a9b47bfd 	stp	x29, x30, [sp, #-192]!
 1131eb8:	910003fd 	mov	x29, sp
 1131ebc:	a9088be1 	stp	x1, x2, [sp, #136]
   int       np  = 0;
   va_list   args;

   va_start(args, a);
   while (cur != NULL) {
       if (mp_init(cur) != CRYPT_OK) {
 1131ec0:	b0000141 	adrp	x1, 115a000 <__scattered_array_1phys_mem_map+0x8>
{
 1131ec4:	a9025bf5 	stp	x21, x22, [sp, #32]
 1131ec8:	aa0003f5 	mov	x21, x0
   va_start(args, a);
 1131ecc:	910303e0 	add	x0, sp, #0xc0
{
 1131ed0:	f9001bf7 	str	x23, [sp, #48]
   va_start(args, a);
 1131ed4:	910203f6 	add	x22, sp, #0x80
       if (mp_init(cur) != CRYPT_OK) {
 1131ed8:	f941d437 	ldr	x23, [x1, #936]
   va_start(args, a);
 1131edc:	a90403e0 	stp	x0, x0, [sp, #64]
 1131ee0:	128006e0 	mov	w0, #0xffffffc8            	// #-56
{
 1131ee4:	a90153f3 	stp	x19, x20, [sp, #16]
 1131ee8:	aa0103f3 	mov	x19, x1
   int       np  = 0;
 1131eec:	52800014 	mov	w20, #0x0                   	// #0
   va_start(args, a);
 1131ef0:	b9005be0 	str	w0, [sp, #88]
   void    **cur = a;
 1131ef4:	aa1503e0 	mov	x0, x21
   va_start(args, a);
 1131ef8:	f9002bf6 	str	x22, [sp, #80]
 1131efc:	b9005fff 	str	wzr, [sp, #92]
{
 1131f00:	a90993e3 	stp	x3, x4, [sp, #152]
 1131f04:	a90a9be5 	stp	x5, x6, [sp, #168]
 1131f08:	f9005fe7 	str	x7, [sp, #184]
   while (cur != NULL) {
 1131f0c:	b40001e0 	cbz	x0, 1131f48 <ltc_init_multi+0x94>
       if (mp_init(cur) != CRYPT_OK) {
 1131f10:	f9400ae1 	ldr	x1, [x23, #16]
 1131f14:	d63f0020 	blr	x1
 1131f18:	34000460 	cbz	w0, 1131fa4 <ltc_init_multi+0xf0>
          va_list clean_list;

          va_start(clean_list, a);
          cur = a;
          while (np--) {
              mp_clear(*cur);
 1131f1c:	f941d673 	ldr	x19, [x19, #936]
          va_start(clean_list, a);
 1131f20:	910303e0 	add	x0, sp, #0xc0
 1131f24:	a90603e0 	stp	x0, x0, [sp, #96]
 1131f28:	128006e0 	mov	w0, #0xffffffc8            	// #-56
 1131f2c:	f9003bf6 	str	x22, [sp, #112]
 1131f30:	b9007be0 	str	w0, [sp, #120]
 1131f34:	b9007fff 	str	wzr, [sp, #124]
          while (np--) {
 1131f38:	51000694 	sub	w20, w20, #0x1
 1131f3c:	3100069f 	cmn	w20, #0x1
 1131f40:	540000e1 	b.ne	1131f5c <ltc_init_multi+0xa8>  // b.any
              cur = va_arg(clean_list, void**);
          }
          va_end(clean_list);
          va_end(args);
          return CRYPT_MEM;
 1131f44:	528001a0 	mov	w0, #0xd                   	// #13
       ++np;
       cur = va_arg(args, void**);
   }
   va_end(args);
   return CRYPT_OK;
}
 1131f48:	a94153f3 	ldp	x19, x20, [sp, #16]
 1131f4c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1131f50:	f9401bf7 	ldr	x23, [sp, #48]
 1131f54:	a8cc7bfd 	ldp	x29, x30, [sp], #192
 1131f58:	d65f03c0 	ret
              mp_clear(*cur);
 1131f5c:	f94002a0 	ldr	x0, [x21]
 1131f60:	f9401661 	ldr	x1, [x19, #40]
 1131f64:	d63f0020 	blr	x1
              cur = va_arg(clean_list, void**);
 1131f68:	b9407be1 	ldr	w1, [sp, #120]
 1131f6c:	f94033e0 	ldr	x0, [sp, #96]
 1131f70:	37f800c1 	tbnz	w1, #31, 1131f88 <ltc_init_multi+0xd4>
 1131f74:	91003c01 	add	x1, x0, #0xf
 1131f78:	927df021 	and	x1, x1, #0xfffffffffffffff8
 1131f7c:	f90033e1 	str	x1, [sp, #96]
 1131f80:	f9400015 	ldr	x21, [x0]
 1131f84:	17ffffed 	b	1131f38 <ltc_init_multi+0x84>
 1131f88:	11002022 	add	w2, w1, #0x8
 1131f8c:	b9007be2 	str	w2, [sp, #120]
 1131f90:	7100005f 	cmp	w2, #0x0
 1131f94:	54ffff0c 	b.gt	1131f74 <ltc_init_multi+0xc0>
 1131f98:	f94037e0 	ldr	x0, [sp, #104]
 1131f9c:	8b21c000 	add	x0, x0, w1, sxtw
 1131fa0:	17fffff8 	b	1131f80 <ltc_init_multi+0xcc>
       cur = va_arg(args, void**);
 1131fa4:	b9405be0 	ldr	w0, [sp, #88]
       ++np;
 1131fa8:	11000694 	add	w20, w20, #0x1
       cur = va_arg(args, void**);
 1131fac:	f94023e1 	ldr	x1, [sp, #64]
 1131fb0:	37f800c0 	tbnz	w0, #31, 1131fc8 <ltc_init_multi+0x114>
 1131fb4:	91003c20 	add	x0, x1, #0xf
 1131fb8:	927df000 	and	x0, x0, #0xfffffffffffffff8
 1131fbc:	f90023e0 	str	x0, [sp, #64]
 1131fc0:	f9400020 	ldr	x0, [x1]
 1131fc4:	17ffffd2 	b	1131f0c <ltc_init_multi+0x58>
 1131fc8:	11002002 	add	w2, w0, #0x8
 1131fcc:	b9005be2 	str	w2, [sp, #88]
 1131fd0:	7100005f 	cmp	w2, #0x0
 1131fd4:	54ffff0c 	b.gt	1131fb4 <ltc_init_multi+0x100>
 1131fd8:	f94027e1 	ldr	x1, [sp, #72]
 1131fdc:	8b20c021 	add	x1, x1, w0, sxtw
 1131fe0:	17fffff8 	b	1131fc0 <ltc_init_multi+0x10c>

0000000001131fe4 <ltc_init_multi_size>:

int ltc_init_multi_size(int size_bits, void **a, ...)
{
 1131fe4:	a9b57bfd 	stp	x29, x30, [sp, #-176]!
 1131fe8:	910003fd 	mov	x29, sp
 1131fec:	a9080fe2 	stp	x2, x3, [sp, #128]
   int       np  = 0;
   va_list   args;

   va_start(args, a);
   while (cur != NULL) {
       if (mp_init_size(size_bits, cur) != CRYPT_OK) {
 1131ff0:	b0000142 	adrp	x2, 115a000 <__scattered_array_1phys_mem_map+0x8>
{
 1131ff4:	a90363f7 	stp	x23, x24, [sp, #48]
   va_start(args, a);
 1131ff8:	910203f7 	add	x23, sp, #0x80
       if (mp_init_size(size_bits, cur) != CRYPT_OK) {
 1131ffc:	f941d458 	ldr	x24, [x2, #936]
{
 1132000:	a90153f3 	stp	x19, x20, [sp, #16]
 1132004:	aa0203f3 	mov	x19, x2
 1132008:	a9025bf5 	stp	x21, x22, [sp, #32]
 113200c:	2a0003f6 	mov	w22, w0
 1132010:	aa0103f5 	mov	x21, x1
   va_start(args, a);
 1132014:	9102c3e0 	add	x0, sp, #0xb0
   int       np  = 0;
 1132018:	52800014 	mov	w20, #0x0                   	// #0
   va_start(args, a);
 113201c:	a90403e0 	stp	x0, x0, [sp, #64]
 1132020:	128005e0 	mov	w0, #0xffffffd0            	// #-48
 1132024:	f9002bf7 	str	x23, [sp, #80]
 1132028:	b9005be0 	str	w0, [sp, #88]
 113202c:	b9005fff 	str	wzr, [sp, #92]
{
 1132030:	a90917e4 	stp	x4, x5, [sp, #144]
 1132034:	a90a1fe6 	stp	x6, x7, [sp, #160]
   while (cur != NULL) {
 1132038:	b5000061 	cbnz	x1, 1132044 <ltc_init_multi_size+0x60>
       }
       ++np;
       cur = va_arg(args, void**);
   }
   va_end(args);
   return CRYPT_OK;
 113203c:	52800000 	mov	w0, #0x0                   	// #0
 1132040:	14000010 	b	1132080 <ltc_init_multi_size+0x9c>
       if (mp_init_size(size_bits, cur) != CRYPT_OK) {
 1132044:	f9400f02 	ldr	x2, [x24, #24]
 1132048:	2a1603e0 	mov	w0, w22
 113204c:	d63f0040 	blr	x2
 1132050:	34000460 	cbz	w0, 11320dc <ltc_init_multi_size+0xf8>
              mp_clear(*cur);
 1132054:	f941d673 	ldr	x19, [x19, #936]
          va_start(clean_list, a);
 1132058:	9102c3e0 	add	x0, sp, #0xb0
 113205c:	a90603e0 	stp	x0, x0, [sp, #96]
 1132060:	128005e0 	mov	w0, #0xffffffd0            	// #-48
 1132064:	f9003bf7 	str	x23, [sp, #112]
 1132068:	b9007be0 	str	w0, [sp, #120]
 113206c:	b9007fff 	str	wzr, [sp, #124]
          while (np--) {
 1132070:	51000694 	sub	w20, w20, #0x1
 1132074:	3100069f 	cmn	w20, #0x1
 1132078:	540000e1 	b.ne	1132094 <ltc_init_multi_size+0xb0>  // b.any
          return CRYPT_MEM;
 113207c:	528001a0 	mov	w0, #0xd                   	// #13
}
 1132080:	a94153f3 	ldp	x19, x20, [sp, #16]
 1132084:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1132088:	a94363f7 	ldp	x23, x24, [sp, #48]
 113208c:	a8cb7bfd 	ldp	x29, x30, [sp], #176
 1132090:	d65f03c0 	ret
              mp_clear(*cur);
 1132094:	f94002a0 	ldr	x0, [x21]
 1132098:	f9401661 	ldr	x1, [x19, #40]
 113209c:	d63f0020 	blr	x1
              cur = va_arg(clean_list, void**);
 11320a0:	b9407be1 	ldr	w1, [sp, #120]
 11320a4:	f94033e0 	ldr	x0, [sp, #96]
 11320a8:	37f800c1 	tbnz	w1, #31, 11320c0 <ltc_init_multi_size+0xdc>
 11320ac:	91003c01 	add	x1, x0, #0xf
 11320b0:	927df021 	and	x1, x1, #0xfffffffffffffff8
 11320b4:	f90033e1 	str	x1, [sp, #96]
 11320b8:	f9400015 	ldr	x21, [x0]
 11320bc:	17ffffed 	b	1132070 <ltc_init_multi_size+0x8c>
 11320c0:	11002022 	add	w2, w1, #0x8
 11320c4:	b9007be2 	str	w2, [sp, #120]
 11320c8:	7100005f 	cmp	w2, #0x0
 11320cc:	54ffff0c 	b.gt	11320ac <ltc_init_multi_size+0xc8>
 11320d0:	f94037e0 	ldr	x0, [sp, #104]
 11320d4:	8b21c000 	add	x0, x0, w1, sxtw
 11320d8:	17fffff8 	b	11320b8 <ltc_init_multi_size+0xd4>
       cur = va_arg(args, void**);
 11320dc:	b9405be0 	ldr	w0, [sp, #88]
       ++np;
 11320e0:	11000694 	add	w20, w20, #0x1
       cur = va_arg(args, void**);
 11320e4:	f94023e2 	ldr	x2, [sp, #64]
 11320e8:	37f800c0 	tbnz	w0, #31, 1132100 <ltc_init_multi_size+0x11c>
 11320ec:	91003c40 	add	x0, x2, #0xf
 11320f0:	927df000 	and	x0, x0, #0xfffffffffffffff8
 11320f4:	f90023e0 	str	x0, [sp, #64]
 11320f8:	f9400041 	ldr	x1, [x2]
 11320fc:	17ffffcf 	b	1132038 <ltc_init_multi_size+0x54>
 1132100:	11002001 	add	w1, w0, #0x8
 1132104:	b9005be1 	str	w1, [sp, #88]
 1132108:	7100003f 	cmp	w1, #0x0
 113210c:	54ffff0c 	b.gt	11320ec <ltc_init_multi_size+0x108>
 1132110:	f94027e2 	ldr	x2, [sp, #72]
 1132114:	8b20c042 	add	x2, x2, w0, sxtw
 1132118:	17fffff8 	b	11320f8 <ltc_init_multi_size+0x114>

000000000113211c <ltc_deinit_multi>:

void ltc_deinit_multi(void *a, ...)
{
 113211c:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
 1132120:	910003fd 	mov	x29, sp
 1132124:	f9000bf3 	str	x19, [sp, #16]
   void     *cur = a;
   va_list   args;

   va_start(args, a);
   while (cur != NULL) {
       mp_clear(cur);
 1132128:	90000153 	adrp	x19, 115a000 <__scattered_array_1phys_mem_map+0x8>
{
 113212c:	a9048be1 	stp	x1, x2, [sp, #72]
   va_start(args, a);
 1132130:	910203e1 	add	x1, sp, #0x80
       mp_clear(cur);
 1132134:	f941d673 	ldr	x19, [x19, #936]
   va_start(args, a);
 1132138:	a90207e1 	stp	x1, x1, [sp, #32]
 113213c:	910103e1 	add	x1, sp, #0x40
 1132140:	f9001be1 	str	x1, [sp, #48]
 1132144:	128006e1 	mov	w1, #0xffffffc8            	// #-56
 1132148:	b9003be1 	str	w1, [sp, #56]
 113214c:	b9003fff 	str	wzr, [sp, #60]
{
 1132150:	a90593e3 	stp	x3, x4, [sp, #88]
 1132154:	a9069be5 	stp	x5, x6, [sp, #104]
 1132158:	f9003fe7 	str	x7, [sp, #120]
   while (cur != NULL) {
 113215c:	b5000080 	cbnz	x0, 113216c <ltc_deinit_multi+0x50>
       cur = va_arg(args, void *);
   }
   va_end(args);
}
 1132160:	f9400bf3 	ldr	x19, [sp, #16]
 1132164:	a8c87bfd 	ldp	x29, x30, [sp], #128
 1132168:	d65f03c0 	ret
       mp_clear(cur);
 113216c:	f9401661 	ldr	x1, [x19, #40]
 1132170:	d63f0020 	blr	x1
       cur = va_arg(args, void *);
 1132174:	b9403be1 	ldr	w1, [sp, #56]
 1132178:	f94013e0 	ldr	x0, [sp, #32]
 113217c:	37f800c1 	tbnz	w1, #31, 1132194 <ltc_deinit_multi+0x78>
 1132180:	91003c01 	add	x1, x0, #0xf
 1132184:	927df021 	and	x1, x1, #0xfffffffffffffff8
 1132188:	f90013e1 	str	x1, [sp, #32]
 113218c:	f9400000 	ldr	x0, [x0]
 1132190:	17fffff3 	b	113215c <ltc_deinit_multi+0x40>
 1132194:	11002022 	add	w2, w1, #0x8
 1132198:	b9003be2 	str	w2, [sp, #56]
 113219c:	7100005f 	cmp	w2, #0x0
 11321a0:	54ffff0c 	b.gt	1132180 <ltc_deinit_multi+0x64>
 11321a4:	f94017e0 	ldr	x0, [sp, #40]
 11321a8:	8b21c000 	add	x0, x0, w1, sxtw
 11321ac:	17fffff8 	b	113218c <ltc_deinit_multi+0x70>

00000000011321b0 <ltc_cleanup_multi>:

void ltc_cleanup_multi(void **a, ...)
{
 11321b0:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
 11321b4:	910003fd 	mov	x29, sp
 11321b8:	a90153f3 	stp	x19, x20, [sp, #16]
   va_list args;

   va_start(args, a);
   while (cur != NULL) {
      if (*cur != NULL) {
         mp_clear(*cur);
 11321bc:	90000154 	adrp	x20, 115a000 <__scattered_array_1phys_mem_map+0x8>
{
 11321c0:	aa0003f3 	mov	x19, x0
         mp_clear(*cur);
 11321c4:	f941d694 	ldr	x20, [x20, #936]
   va_start(args, a);
 11321c8:	910203e0 	add	x0, sp, #0x80
 11321cc:	a90203e0 	stp	x0, x0, [sp, #32]
 11321d0:	910103e0 	add	x0, sp, #0x40
 11321d4:	f9001be0 	str	x0, [sp, #48]
 11321d8:	128006e0 	mov	w0, #0xffffffc8            	// #-56
 11321dc:	b9003be0 	str	w0, [sp, #56]
 11321e0:	b9003fff 	str	wzr, [sp, #60]
{
 11321e4:	a9048be1 	stp	x1, x2, [sp, #72]
 11321e8:	a90593e3 	stp	x3, x4, [sp, #88]
 11321ec:	a9069be5 	stp	x5, x6, [sp, #104]
 11321f0:	f9003fe7 	str	x7, [sp, #120]
   while (cur != NULL) {
 11321f4:	b5000093 	cbnz	x19, 1132204 <ltc_cleanup_multi+0x54>
         *cur = NULL;
      }
      cur = va_arg(args, void**);
   }
   va_end(args);
}
 11321f8:	a94153f3 	ldp	x19, x20, [sp, #16]
 11321fc:	a8c87bfd 	ldp	x29, x30, [sp], #128
 1132200:	d65f03c0 	ret
      if (*cur != NULL) {
 1132204:	f9400260 	ldr	x0, [x19]
 1132208:	b4000080 	cbz	x0, 1132218 <ltc_cleanup_multi+0x68>
         mp_clear(*cur);
 113220c:	f9401681 	ldr	x1, [x20, #40]
 1132210:	d63f0020 	blr	x1
         *cur = NULL;
 1132214:	f900027f 	str	xzr, [x19]
      cur = va_arg(args, void**);
 1132218:	b9403be1 	ldr	w1, [sp, #56]
 113221c:	f94013e0 	ldr	x0, [sp, #32]
 1132220:	37f800c1 	tbnz	w1, #31, 1132238 <ltc_cleanup_multi+0x88>
 1132224:	91003c01 	add	x1, x0, #0xf
 1132228:	927df021 	and	x1, x1, #0xfffffffffffffff8
 113222c:	f90013e1 	str	x1, [sp, #32]
 1132230:	f9400013 	ldr	x19, [x0]
 1132234:	17fffff0 	b	11321f4 <ltc_cleanup_multi+0x44>
 1132238:	11002022 	add	w2, w1, #0x8
 113223c:	b9003be2 	str	w2, [sp, #56]
 1132240:	7100005f 	cmp	w2, #0x0
 1132244:	54ffff0c 	b.gt	1132224 <ltc_cleanup_multi+0x74>
 1132248:	f94017e0 	ldr	x0, [sp, #40]
 113224c:	8b21c000 	add	x0, x0, w1, sxtw
 1132250:	17fffff8 	b	1132230 <ltc_cleanup_multi+0x80>

0000000001132254 <rand_bn_bits>:
/**
  Generate a random number N with given bitlength (note: MSB can be 0)
*/

int rand_bn_bits(void *N, int bits, prng_state *prng, int wprng)
{
 1132254:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 1132258:	910003fd 	mov	x29, sp
 113225c:	a90153f3 	stp	x19, x20, [sp, #16]
 1132260:	a9025bf5 	stp	x21, x22, [sp, #32]
 1132264:	a90363f7 	stp	x23, x24, [sp, #48]
 1132268:	f90023f9 	str	x25, [sp, #64]
   int res, bytes;
   unsigned char *buf, mask;

   LTC_ARGCHK(N != NULL);
 113226c:	b4000720 	cbz	x0, 1132350 <rand_bn_bits+0xfc>
 1132270:	2a0103f6 	mov	w22, w1
   LTC_ARGCHK(bits > 1);
 1132274:	7100043f 	cmp	w1, #0x1
 1132278:	540006cd 	b.le	1132350 <rand_bn_bits+0xfc>
 113227c:	aa0003f7 	mov	x23, x0
 1132280:	aa0203f9 	mov	x25, x2
 1132284:	2a0303f8 	mov	w24, w3

   /* check PRNG */
   if ((res = prng_is_valid(wprng)) != CRYPT_OK) return res;
 1132288:	2a0303e0 	mov	w0, w3
 113228c:	94000114 	bl	11326dc <prng_is_valid>
 1132290:	2a0003f3 	mov	w19, w0
 1132294:	350004c0 	cbnz	w0, 113232c <rand_bn_bits+0xd8>

   bytes = (bits+7) >> 3;
 1132298:	11001ed4 	add	w20, w22, #0x7
   mask = 0xff << (8 - bits % 8);

   /* allocate buffer */
   if ((buf = XCALLOC(1, bytes)) == NULL) return CRYPT_MEM;
 113229c:	d2800020 	mov	x0, #0x1                   	// #1
   bytes = (bits+7) >> 3;
 11322a0:	13037e94 	asr	w20, w20, #3
   if ((buf = XCALLOC(1, bytes)) == NULL) return CRYPT_MEM;
 11322a4:	93407e94 	sxtw	x20, w20
 11322a8:	aa1403e1 	mov	x1, x20
 11322ac:	94004489 	bl	11434d0 <calloc>
 11322b0:	aa0003f5 	mov	x21, x0
 11322b4:	b4000520 	cbz	x0, 1132358 <rand_bn_bits+0x104>

   /* generate random bytes */
   if (prng_descriptor[wprng]->read(buf, bytes, prng) != (unsigned long)bytes) {
 11322b8:	90000153 	adrp	x19, 115a000 <__scattered_array_1phys_mem_map+0x8>
 11322bc:	aa1903e2 	mov	x2, x25
 11322c0:	f9422e61 	ldr	x1, [x19, #1112]
 11322c4:	f878d821 	ldr	x1, [x1, w24, sxtw #3]
 11322c8:	f9401423 	ldr	x3, [x1, #40]
 11322cc:	aa1403e1 	mov	x1, x20
 11322d0:	d63f0060 	blr	x3
 11322d4:	eb00029f 	cmp	x20, x0
 11322d8:	54000381 	b.ne	1132348 <rand_bn_bits+0xf4>  // b.any
      goto cleanup;
   }
   /* mask bits */
   buf[0] &= ~mask;
   /* load value */
   if ((res = mp_read_unsigned_bin(N, buf, bytes)) != CRYPT_OK) goto cleanup;
 11322dc:	f941d673 	ldr	x19, [x19, #936]
   mask = 0xff << (8 - bits % 8);
 11322e0:	12000ad6 	and	w22, w22, #0x7
   buf[0] &= ~mask;
 11322e4:	394002a0 	ldrb	w0, [x21]
   mask = 0xff << (8 - bits % 8);
 11322e8:	52800101 	mov	w1, #0x8                   	// #8
 11322ec:	4b160021 	sub	w1, w1, w22
 11322f0:	52801ff6 	mov	w22, #0xff                  	// #255
   if ((res = mp_read_unsigned_bin(N, buf, bytes)) != CRYPT_OK) goto cleanup;
 11322f4:	f9405663 	ldr	x3, [x19, #168]
   mask = 0xff << (8 - bits % 8);
 11322f8:	1ac122d6 	lsl	w22, w22, w1
   buf[0] &= ~mask;
 11322fc:	0a360016 	bic	w22, w0, w22
 1132300:	390002b6 	strb	w22, [x21]
   if ((res = mp_read_unsigned_bin(N, buf, bytes)) != CRYPT_OK) goto cleanup;
 1132304:	aa1403e2 	mov	x2, x20
 1132308:	aa1503e1 	mov	x1, x21
 113230c:	aa1703e0 	mov	x0, x23
 1132310:	d63f0060 	blr	x3
 1132314:	2a0003f3 	mov	w19, w0

   res = CRYPT_OK;

cleanup:
#ifdef LTC_CLEAN_STACK
   zeromem(buf, bytes);
 1132318:	aa1403e1 	mov	x1, x20
 113231c:	aa1503e0 	mov	x0, x21
 1132320:	94000049 	bl	1132444 <zeromem>
#endif
   XFREE(buf);
 1132324:	aa1503e0 	mov	x0, x21
 1132328:	940044ae 	bl	11435e0 <free>
   return res;
}
 113232c:	2a1303e0 	mov	w0, w19
 1132330:	a94153f3 	ldp	x19, x20, [sp, #16]
 1132334:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1132338:	a94363f7 	ldp	x23, x24, [sp, #48]
 113233c:	f94023f9 	ldr	x25, [sp, #64]
 1132340:	a8c57bfd 	ldp	x29, x30, [sp], #80
 1132344:	d65f03c0 	ret
      res = CRYPT_ERROR_READPRNG;
 1132348:	52800133 	mov	w19, #0x9                   	// #9
 113234c:	17fffff3 	b	1132318 <rand_bn_bits+0xc4>
   LTC_ARGCHK(N != NULL);
 1132350:	52800213 	mov	w19, #0x10                  	// #16
 1132354:	17fffff6 	b	113232c <rand_bn_bits+0xd8>
   if ((buf = XCALLOC(1, bytes)) == NULL) return CRYPT_MEM;
 1132358:	528001b3 	mov	w19, #0xd                   	// #13
 113235c:	17fffff4 	b	113232c <rand_bn_bits+0xd8>

0000000001132360 <rand_bn_upto>:

/**
  Generate a random number N in a range: 1 <= N < limit
*/
int rand_bn_upto(void *N, void *limit, prng_state *prng, int wprng)
{
 1132360:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 1132364:	910003fd 	mov	x29, sp
 1132368:	a90153f3 	stp	x19, x20, [sp, #16]
 113236c:	a9025bf5 	stp	x21, x22, [sp, #32]
 1132370:	a90363f7 	stp	x23, x24, [sp, #48]
 1132374:	f90023f9 	str	x25, [sp, #64]
   int res, bits;

   LTC_ARGCHK(N != NULL);
 1132378:	b40004c0 	cbz	x0, 1132410 <rand_bn_upto+0xb0>
 113237c:	aa0103f5 	mov	x21, x1
   LTC_ARGCHK(limit != NULL);
 1132380:	b4000481 	cbz	x1, 1132410 <rand_bn_upto+0xb0>

   bits = mp_count_bits(limit);
 1132384:	90000141 	adrp	x1, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1132388:	aa0003f4 	mov	x20, x0
 113238c:	aa0203f7 	mov	x23, x2
 1132390:	2a0303f8 	mov	w24, w3
 1132394:	f941d439 	ldr	x25, [x1, #936]
 1132398:	aa1503e0 	mov	x0, x21
 113239c:	f9403b21 	ldr	x1, [x25, #112]
 11323a0:	d63f0020 	blr	x1
 11323a4:	2a0003f6 	mov	w22, w0
   do {
     res = rand_bn_bits(N, bits, prng, wprng);
 11323a8:	2a1803e3 	mov	w3, w24
 11323ac:	aa1703e2 	mov	x2, x23
 11323b0:	2a1603e1 	mov	w1, w22
 11323b4:	aa1403e0 	mov	x0, x20
 11323b8:	97ffffa7 	bl	1132254 <rand_bn_bits>
 11323bc:	2a0003f3 	mov	w19, w0
     if (res != CRYPT_OK) return res;
 11323c0:	350001a0 	cbnz	w0, 11323f4 <rand_bn_upto+0x94>
   } while (mp_cmp_d(N, 0) != LTC_MP_GT || mp_cmp(N, limit) != LTC_MP_LT);
 11323c4:	f9403722 	ldr	x2, [x25, #104]
 11323c8:	aa1403e0 	mov	x0, x20
 11323cc:	d2800001 	mov	x1, #0x0                   	// #0
 11323d0:	d63f0040 	blr	x2
 11323d4:	7100041f 	cmp	w0, #0x1
 11323d8:	54fffe81 	b.ne	11323a8 <rand_bn_upto+0x48>  // b.any
 11323dc:	f9403322 	ldr	x2, [x25, #96]
 11323e0:	aa1503e1 	mov	x1, x21
 11323e4:	aa1403e0 	mov	x0, x20
 11323e8:	d63f0040 	blr	x2
 11323ec:	3100041f 	cmn	w0, #0x1
 11323f0:	54fffdc1 	b.ne	11323a8 <rand_bn_upto+0x48>  // b.any

   return CRYPT_OK;
}
 11323f4:	2a1303e0 	mov	w0, w19
 11323f8:	a94153f3 	ldp	x19, x20, [sp, #16]
 11323fc:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1132400:	a94363f7 	ldp	x23, x24, [sp, #48]
 1132404:	f94023f9 	ldr	x25, [sp, #64]
 1132408:	a8c57bfd 	ldp	x29, x30, [sp], #80
 113240c:	d65f03c0 	ret
   LTC_ARGCHK(N != NULL);
 1132410:	52800213 	mov	w19, #0x10                  	// #16
 1132414:	17fffff8 	b	11323f4 <rand_bn_upto+0x94>

0000000001132418 <burn_stack>:
/**
   Burn some stack memory
   @param len amount of stack to burn in bytes
*/
void burn_stack(unsigned long len)
{
 1132418:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 113241c:	aa0003e1 	mov	x1, x0
   unsigned char buf[len];
 1132420:	91003c00 	add	x0, x0, #0xf
 1132424:	927cec00 	and	x0, x0, #0xfffffffffffffff0
{
 1132428:	910003fd 	mov	x29, sp
   unsigned char buf[len];
 113242c:	cb2063ff 	sub	sp, sp, x0
   zeromem(buf, sizeof(buf));
 1132430:	910003e0 	mov	x0, sp
 1132434:	94000004 	bl	1132444 <zeromem>
}
 1132438:	910003bf 	mov	sp, x29
 113243c:	a8c17bfd 	ldp	x29, x30, [sp], #16
 1132440:	d65f03c0 	ret

0000000001132444 <zeromem>:
   @param out    The destination of the area to zero
   @param outlen The length of the area to zero (octets)
*/
void zeromem(volatile void *out, size_t outlen)
{
   LTC_ARGCHKVD(out != NULL);
 1132444:	b4000040 	cbz	x0, 113244c <zeromem+0x8>
   memzero_explicit((void *)out, outlen);
 1132448:	14004aee 	b	1145000 <memzero_explicit>
}
 113244c:	d65f03c0 	ret

0000000001132450 <cipher_is_valid>:
   Test if a cipher index is valid
   @param idx   The index of the cipher to search for
   @return CRYPT_OK if valid
*/
int cipher_is_valid(int idx)
{
 1132450:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1132454:	910003fd 	mov	x29, sp
 1132458:	a90153f3 	stp	x19, x20, [sp, #16]
   LTC_MUTEX_LOCK(&ltc_cipher_mutex);
 113245c:	90000153 	adrp	x19, 115a000 <__scattered_array_1phys_mem_map+0x8>
{
 1132460:	2a0003f4 	mov	w20, w0
 1132464:	f90013f5 	str	x21, [sp, #32]
   LTC_MUTEX_LOCK(&ltc_cipher_mutex);
 1132468:	f9418275 	ldr	x21, [x19, #768]
 113246c:	aa1503e0 	mov	x0, x21
 1132470:	97ff8c39 	bl	1115554 <mutex_lock>
   if (idx < 0 || idx >= TAB_SIZE || cipher_descriptor[idx] == NULL) {
 1132474:	7100869f 	cmp	w20, #0x21
 1132478:	54000088 	b.hi	1132488 <cipher_is_valid+0x38>  // b.pmore
 113247c:	f941c273 	ldr	x19, [x19, #896]
 1132480:	f874da60 	ldr	x0, [x19, w20, sxtw #3]
 1132484:	b5000120 	cbnz	x0, 11324a8 <cipher_is_valid+0x58>
      LTC_MUTEX_UNLOCK(&ltc_cipher_mutex);
 1132488:	90000153 	adrp	x19, 115a000 <__scattered_array_1phys_mem_map+0x8>
 113248c:	f9418260 	ldr	x0, [x19, #768]
 1132490:	97ff8c10 	bl	11154d0 <mutex_unlock>
      return CRYPT_INVALID_CIPHER;
 1132494:	52800140 	mov	w0, #0xa                   	// #10
   }
   LTC_MUTEX_UNLOCK(&ltc_cipher_mutex);
   return CRYPT_OK;
}
 1132498:	a94153f3 	ldp	x19, x20, [sp, #16]
 113249c:	f94013f5 	ldr	x21, [sp, #32]
 11324a0:	a8c37bfd 	ldp	x29, x30, [sp], #48
 11324a4:	d65f03c0 	ret
   LTC_MUTEX_UNLOCK(&ltc_cipher_mutex);
 11324a8:	aa1503e0 	mov	x0, x21
 11324ac:	97ff8c09 	bl	11154d0 <mutex_unlock>
   return CRYPT_OK;
 11324b0:	52800000 	mov	w0, #0x0                   	// #0
 11324b4:	17fffff9 	b	1132498 <cipher_is_valid+0x48>

00000000011324b8 <find_cipher>:
   Find a registered cipher by name
   @param name   The name of the cipher to look for
   @return >= 0 if found, -1 if not present
*/
int find_cipher(const char *name)
{
 11324b8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 11324bc:	910003fd 	mov	x29, sp
 11324c0:	a90153f3 	stp	x19, x20, [sp, #16]
 11324c4:	a9025bf5 	stp	x21, x22, [sp, #32]
 11324c8:	a90363f7 	stp	x23, x24, [sp, #48]
   int x;
   LTC_ARGCHK(name != NULL);
 11324cc:	b40003c0 	cbz	x0, 1132544 <find_cipher+0x8c>
   LTC_MUTEX_LOCK(&ltc_cipher_mutex);
 11324d0:	90000154 	adrp	x20, 115a000 <__scattered_array_1phys_mem_map+0x8>
 11324d4:	aa0003f5 	mov	x21, x0
 11324d8:	aa1403f7 	mov	x23, x20
 11324dc:	d2800013 	mov	x19, #0x0                   	// #0
 11324e0:	f9418280 	ldr	x0, [x20, #768]
 11324e4:	97ff8c1c 	bl	1115554 <mutex_lock>
   for (x = 0; x < TAB_SIZE; x++) {
       if (cipher_descriptor[x] != NULL && !XSTRCMP(cipher_descriptor[x]->name, name)) {
 11324e8:	f941c298 	ldr	x24, [x20, #896]
 11324ec:	2a1303f6 	mov	w22, w19
 11324f0:	f8737b00 	ldr	x0, [x24, x19, lsl #3]
 11324f4:	b40001a0 	cbz	x0, 1132528 <find_cipher+0x70>
 11324f8:	f9400000 	ldr	x0, [x0]
 11324fc:	aa1503e1 	mov	x1, x21
 1132500:	940045ff 	bl	1143cfc <strcmp>
 1132504:	35000120 	cbnz	w0, 1132528 <find_cipher+0x70>
          LTC_MUTEX_UNLOCK(&ltc_cipher_mutex);
 1132508:	f94182e0 	ldr	x0, [x23, #768]
 113250c:	97ff8bf1 	bl	11154d0 <mutex_unlock>
          return x;
       }
   }
   LTC_MUTEX_UNLOCK(&ltc_cipher_mutex);
   return -1;
}
 1132510:	2a1603e0 	mov	w0, w22
 1132514:	a94153f3 	ldp	x19, x20, [sp, #16]
 1132518:	a9425bf5 	ldp	x21, x22, [sp, #32]
 113251c:	a94363f7 	ldp	x23, x24, [sp, #48]
 1132520:	a8c47bfd 	ldp	x29, x30, [sp], #64
 1132524:	d65f03c0 	ret
   for (x = 0; x < TAB_SIZE; x++) {
 1132528:	91000673 	add	x19, x19, #0x1
 113252c:	f1008a7f 	cmp	x19, #0x22
 1132530:	54fffde1 	b.ne	11324ec <find_cipher+0x34>  // b.any
   LTC_MUTEX_UNLOCK(&ltc_cipher_mutex);
 1132534:	f94182e0 	ldr	x0, [x23, #768]
   return -1;
 1132538:	12800016 	mov	w22, #0xffffffff            	// #-1
   LTC_MUTEX_UNLOCK(&ltc_cipher_mutex);
 113253c:	97ff8be5 	bl	11154d0 <mutex_unlock>
   return -1;
 1132540:	17fffff4 	b	1132510 <find_cipher+0x58>
   LTC_ARGCHK(name != NULL);
 1132544:	52800216 	mov	w22, #0x10                  	// #16
 1132548:	17fffff2 	b	1132510 <find_cipher+0x58>

000000000113254c <find_hash>:
   Find a registered hash by name
   @param name   The name of the hash to look for
   @return >= 0 if found, -1 if not present
*/
int find_hash(const char *name)
{
 113254c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 1132550:	910003fd 	mov	x29, sp
 1132554:	a90153f3 	stp	x19, x20, [sp, #16]
 1132558:	a9025bf5 	stp	x21, x22, [sp, #32]
 113255c:	a90363f7 	stp	x23, x24, [sp, #48]
   int x;
   LTC_ARGCHK(name != NULL);
 1132560:	b40003c0 	cbz	x0, 11325d8 <find_hash+0x8c>
   LTC_MUTEX_LOCK(&ltc_hash_mutex);
 1132564:	90000154 	adrp	x20, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1132568:	aa0003f5 	mov	x21, x0
 113256c:	aa1403f7 	mov	x23, x20
 1132570:	d2800013 	mov	x19, #0x0                   	// #0
 1132574:	f9422a80 	ldr	x0, [x20, #1104]
 1132578:	97ff8bf7 	bl	1115554 <mutex_lock>
   for (x = 0; x < TAB_SIZE; x++) {
       if (hash_descriptor[x] != NULL && XSTRCMP(hash_descriptor[x]->name, name) == 0) {
 113257c:	f941a298 	ldr	x24, [x20, #832]
 1132580:	2a1303f6 	mov	w22, w19
 1132584:	f8737b00 	ldr	x0, [x24, x19, lsl #3]
 1132588:	b40001a0 	cbz	x0, 11325bc <find_hash+0x70>
 113258c:	f9400000 	ldr	x0, [x0]
 1132590:	aa1503e1 	mov	x1, x21
 1132594:	940045da 	bl	1143cfc <strcmp>
 1132598:	35000120 	cbnz	w0, 11325bc <find_hash+0x70>
          LTC_MUTEX_UNLOCK(&ltc_hash_mutex);
 113259c:	f9422ae0 	ldr	x0, [x23, #1104]
 11325a0:	97ff8bcc 	bl	11154d0 <mutex_unlock>
          return x;
       }
   }
   LTC_MUTEX_UNLOCK(&ltc_hash_mutex);
   return -1;
}
 11325a4:	2a1603e0 	mov	w0, w22
 11325a8:	a94153f3 	ldp	x19, x20, [sp, #16]
 11325ac:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11325b0:	a94363f7 	ldp	x23, x24, [sp, #48]
 11325b4:	a8c47bfd 	ldp	x29, x30, [sp], #64
 11325b8:	d65f03c0 	ret
   for (x = 0; x < TAB_SIZE; x++) {
 11325bc:	91000673 	add	x19, x19, #0x1
 11325c0:	f1008a7f 	cmp	x19, #0x22
 11325c4:	54fffde1 	b.ne	1132580 <find_hash+0x34>  // b.any
   LTC_MUTEX_UNLOCK(&ltc_hash_mutex);
 11325c8:	f9422ae0 	ldr	x0, [x23, #1104]
   return -1;
 11325cc:	12800016 	mov	w22, #0xffffffff            	// #-1
   LTC_MUTEX_UNLOCK(&ltc_hash_mutex);
 11325d0:	97ff8bc0 	bl	11154d0 <mutex_unlock>
   return -1;
 11325d4:	17fffff4 	b	11325a4 <find_hash+0x58>
   LTC_ARGCHK(name != NULL);
 11325d8:	52800216 	mov	w22, #0x10                  	// #16
 11325dc:	17fffff2 	b	11325a4 <find_hash+0x58>

00000000011325e0 <find_prng>:
   Find a registered PRNG by name
   @param name   The name of the PRNG to look for
   @return >= 0 if found, -1 if not present
*/
int find_prng(const char *name)
{
 11325e0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 11325e4:	910003fd 	mov	x29, sp
 11325e8:	a90153f3 	stp	x19, x20, [sp, #16]
 11325ec:	a9025bf5 	stp	x21, x22, [sp, #32]
 11325f0:	a90363f7 	stp	x23, x24, [sp, #48]
   int x;
   LTC_ARGCHK(name != NULL);
 11325f4:	b40003c0 	cbz	x0, 113266c <find_prng+0x8c>
   LTC_MUTEX_LOCK(&ltc_prng_mutex);
 11325f8:	90000154 	adrp	x20, 115a000 <__scattered_array_1phys_mem_map+0x8>
 11325fc:	aa0003f5 	mov	x21, x0
 1132600:	aa1403f7 	mov	x23, x20
 1132604:	d2800013 	mov	x19, #0x0                   	// #0
 1132608:	f9421e80 	ldr	x0, [x20, #1080]
 113260c:	97ff8bd2 	bl	1115554 <mutex_lock>
   for (x = 0; x < TAB_SIZE; x++) {
       if ((prng_descriptor[x] != NULL) && XSTRCMP(prng_descriptor[x]->name, name) == 0) {
 1132610:	f9422e98 	ldr	x24, [x20, #1112]
 1132614:	2a1303f6 	mov	w22, w19
 1132618:	f8737b00 	ldr	x0, [x24, x19, lsl #3]
 113261c:	b40001a0 	cbz	x0, 1132650 <find_prng+0x70>
 1132620:	f9400000 	ldr	x0, [x0]
 1132624:	aa1503e1 	mov	x1, x21
 1132628:	940045b5 	bl	1143cfc <strcmp>
 113262c:	35000120 	cbnz	w0, 1132650 <find_prng+0x70>
          LTC_MUTEX_UNLOCK(&ltc_prng_mutex);
 1132630:	f9421ee0 	ldr	x0, [x23, #1080]
 1132634:	97ff8ba7 	bl	11154d0 <mutex_unlock>
          return x;
       }
   }
   LTC_MUTEX_UNLOCK(&ltc_prng_mutex);
   return -1;
}
 1132638:	2a1603e0 	mov	w0, w22
 113263c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1132640:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1132644:	a94363f7 	ldp	x23, x24, [sp, #48]
 1132648:	a8c47bfd 	ldp	x29, x30, [sp], #64
 113264c:	d65f03c0 	ret
   for (x = 0; x < TAB_SIZE; x++) {
 1132650:	91000673 	add	x19, x19, #0x1
 1132654:	f1008a7f 	cmp	x19, #0x22
 1132658:	54fffde1 	b.ne	1132614 <find_prng+0x34>  // b.any
   LTC_MUTEX_UNLOCK(&ltc_prng_mutex);
 113265c:	f9421ee0 	ldr	x0, [x23, #1080]
   return -1;
 1132660:	12800016 	mov	w22, #0xffffffff            	// #-1
   LTC_MUTEX_UNLOCK(&ltc_prng_mutex);
 1132664:	97ff8b9b 	bl	11154d0 <mutex_unlock>
   return -1;
 1132668:	17fffff4 	b	1132638 <find_prng+0x58>
   LTC_ARGCHK(name != NULL);
 113266c:	52800216 	mov	w22, #0x10                  	// #16
 1132670:	17fffff2 	b	1132638 <find_prng+0x58>

0000000001132674 <hash_is_valid>:
   Test if a hash index is valid
   @param idx   The index of the hash to search for
   @return CRYPT_OK if valid
*/
int hash_is_valid(int idx)
{
 1132674:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1132678:	910003fd 	mov	x29, sp
 113267c:	a90153f3 	stp	x19, x20, [sp, #16]
   LTC_MUTEX_LOCK(&ltc_hash_mutex);
 1132680:	90000153 	adrp	x19, 115a000 <__scattered_array_1phys_mem_map+0x8>
{
 1132684:	2a0003f4 	mov	w20, w0
 1132688:	f90013f5 	str	x21, [sp, #32]
   LTC_MUTEX_LOCK(&ltc_hash_mutex);
 113268c:	f9422a75 	ldr	x21, [x19, #1104]
 1132690:	aa1503e0 	mov	x0, x21
 1132694:	97ff8bb0 	bl	1115554 <mutex_lock>
   if (idx < 0 || idx >= TAB_SIZE || hash_descriptor[idx] == NULL) {
 1132698:	7100869f 	cmp	w20, #0x21
 113269c:	54000088 	b.hi	11326ac <hash_is_valid+0x38>  // b.pmore
 11326a0:	f941a273 	ldr	x19, [x19, #832]
 11326a4:	f874da60 	ldr	x0, [x19, w20, sxtw #3]
 11326a8:	b5000120 	cbnz	x0, 11326cc <hash_is_valid+0x58>
      LTC_MUTEX_UNLOCK(&ltc_hash_mutex);
 11326ac:	90000153 	adrp	x19, 115a000 <__scattered_array_1phys_mem_map+0x8>
 11326b0:	f9422a60 	ldr	x0, [x19, #1104]
 11326b4:	97ff8b87 	bl	11154d0 <mutex_unlock>
      return CRYPT_INVALID_HASH;
 11326b8:	52800160 	mov	w0, #0xb                   	// #11
   }
   LTC_MUTEX_UNLOCK(&ltc_hash_mutex);
   return CRYPT_OK;
}
 11326bc:	a94153f3 	ldp	x19, x20, [sp, #16]
 11326c0:	f94013f5 	ldr	x21, [sp, #32]
 11326c4:	a8c37bfd 	ldp	x29, x30, [sp], #48
 11326c8:	d65f03c0 	ret
   LTC_MUTEX_UNLOCK(&ltc_hash_mutex);
 11326cc:	aa1503e0 	mov	x0, x21
 11326d0:	97ff8b80 	bl	11154d0 <mutex_unlock>
   return CRYPT_OK;
 11326d4:	52800000 	mov	w0, #0x0                   	// #0
 11326d8:	17fffff9 	b	11326bc <hash_is_valid+0x48>

00000000011326dc <prng_is_valid>:
   Test if a PRNG index is valid
   @param idx   The index of the PRNG to search for
   @return CRYPT_OK if valid
*/
int prng_is_valid(int idx)
{
 11326dc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 11326e0:	910003fd 	mov	x29, sp
 11326e4:	a90153f3 	stp	x19, x20, [sp, #16]
   LTC_MUTEX_LOCK(&ltc_prng_mutex);
 11326e8:	90000153 	adrp	x19, 115a000 <__scattered_array_1phys_mem_map+0x8>
{
 11326ec:	2a0003f4 	mov	w20, w0
 11326f0:	f90013f5 	str	x21, [sp, #32]
   LTC_MUTEX_LOCK(&ltc_prng_mutex);
 11326f4:	f9421e75 	ldr	x21, [x19, #1080]
 11326f8:	aa1503e0 	mov	x0, x21
 11326fc:	97ff8b96 	bl	1115554 <mutex_lock>
   if (idx < 0 || idx >= TAB_SIZE || prng_descriptor[idx] == NULL) {
 1132700:	7100869f 	cmp	w20, #0x21
 1132704:	54000088 	b.hi	1132714 <prng_is_valid+0x38>  // b.pmore
 1132708:	f9422e73 	ldr	x19, [x19, #1112]
 113270c:	f874da60 	ldr	x0, [x19, w20, sxtw #3]
 1132710:	b5000120 	cbnz	x0, 1132734 <prng_is_valid+0x58>
      LTC_MUTEX_UNLOCK(&ltc_prng_mutex);
 1132714:	90000153 	adrp	x19, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1132718:	f9421e60 	ldr	x0, [x19, #1080]
 113271c:	97ff8b6d 	bl	11154d0 <mutex_unlock>
      return CRYPT_INVALID_PRNG;
 1132720:	52800180 	mov	w0, #0xc                   	// #12
   }
   LTC_MUTEX_UNLOCK(&ltc_prng_mutex);
   return CRYPT_OK;
}
 1132724:	a94153f3 	ldp	x19, x20, [sp, #16]
 1132728:	f94013f5 	ldr	x21, [sp, #32]
 113272c:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1132730:	d65f03c0 	ret
   LTC_MUTEX_UNLOCK(&ltc_prng_mutex);
 1132734:	aa1503e0 	mov	x0, x21
 1132738:	97ff8b66 	bl	11154d0 <mutex_unlock>
   return CRYPT_OK;
 113273c:	52800000 	mov	w0, #0x0                   	// #0
 1132740:	17fffff9 	b	1132724 <prng_is_valid+0x48>

0000000001132744 <register_cipher>:
   Register a cipher with the descriptor table
   @param cipher   The cipher you wish to register
   @return value >= 0 if successfully added (or already present), -1 if unsuccessful
*/
int register_cipher(const struct ltc_cipher_descriptor *cipher)
{
 1132744:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1132748:	910003fd 	mov	x29, sp
 113274c:	a90153f3 	stp	x19, x20, [sp, #16]
 1132750:	f90013f5 	str	x21, [sp, #32]
   int x;

   LTC_ARGCHK(cipher != NULL);
 1132754:	b40004e0 	cbz	x0, 11327f0 <register_cipher+0xac>

   /* is it already registered? */
   LTC_MUTEX_LOCK(&ltc_cipher_mutex);
 1132758:	90000155 	adrp	x21, 115a000 <__scattered_array_1phys_mem_map+0x8>
 113275c:	aa0003f4 	mov	x20, x0
 1132760:	f94182a0 	ldr	x0, [x21, #768]
 1132764:	97ff8b7c 	bl	1115554 <mutex_lock>
   for (x = 0; x < TAB_SIZE; x++) {
       if (cipher_descriptor[x] != NULL && cipher_descriptor[x]->ID == cipher->ID) {
 1132768:	f941c2a3 	ldr	x3, [x21, #896]
 113276c:	aa1503e0 	mov	x0, x21
   LTC_MUTEX_LOCK(&ltc_cipher_mutex);
 1132770:	d2800001 	mov	x1, #0x0                   	// #0
       if (cipher_descriptor[x] != NULL && cipher_descriptor[x]->ID == cipher->ID) {
 1132774:	f8617862 	ldr	x2, [x3, x1, lsl #3]
 1132778:	2a0103f3 	mov	w19, w1
 113277c:	b4000182 	cbz	x2, 11327ac <register_cipher+0x68>
 1132780:	39402044 	ldrb	w4, [x2, #8]
 1132784:	39402282 	ldrb	w2, [x20, #8]
 1132788:	6b02009f 	cmp	w4, w2
 113278c:	54000101 	b.ne	11327ac <register_cipher+0x68>  // b.any

   /* find a blank spot */
   for (x = 0; x < TAB_SIZE; x++) {
       if (cipher_descriptor[x] == NULL) {
          cipher_descriptor[x] = cipher;
          LTC_MUTEX_UNLOCK(&ltc_cipher_mutex);
 1132790:	f9418000 	ldr	x0, [x0, #768]
 1132794:	97ff8b4f 	bl	11154d0 <mutex_unlock>
   }

   /* no spot */
   LTC_MUTEX_UNLOCK(&ltc_cipher_mutex);
   return -1;
}
 1132798:	2a1303e0 	mov	w0, w19
 113279c:	a94153f3 	ldp	x19, x20, [sp, #16]
 11327a0:	f94013f5 	ldr	x21, [sp, #32]
 11327a4:	a8c37bfd 	ldp	x29, x30, [sp], #48
 11327a8:	d65f03c0 	ret
   for (x = 0; x < TAB_SIZE; x++) {
 11327ac:	91000421 	add	x1, x1, #0x1
 11327b0:	f100883f 	cmp	x1, #0x22
 11327b4:	54fffe01 	b.ne	1132774 <register_cipher+0x30>  // b.any
       if (cipher_descriptor[x] == NULL) {
 11327b8:	f941c002 	ldr	x2, [x0, #896]
 11327bc:	d2800001 	mov	x1, #0x0                   	// #0
 11327c0:	f8617843 	ldr	x3, [x2, x1, lsl #3]
 11327c4:	2a0103f3 	mov	w19, w1
 11327c8:	b5000063 	cbnz	x3, 11327d4 <register_cipher+0x90>
          cipher_descriptor[x] = cipher;
 11327cc:	f833d854 	str	x20, [x2, w19, sxtw #3]
 11327d0:	17fffff0 	b	1132790 <register_cipher+0x4c>
   for (x = 0; x < TAB_SIZE; x++) {
 11327d4:	91000421 	add	x1, x1, #0x1
 11327d8:	f100883f 	cmp	x1, #0x22
 11327dc:	54ffff21 	b.ne	11327c0 <register_cipher+0x7c>  // b.any
   LTC_MUTEX_UNLOCK(&ltc_cipher_mutex);
 11327e0:	f9418000 	ldr	x0, [x0, #768]
   return -1;
 11327e4:	12800013 	mov	w19, #0xffffffff            	// #-1
   LTC_MUTEX_UNLOCK(&ltc_cipher_mutex);
 11327e8:	97ff8b3a 	bl	11154d0 <mutex_unlock>
   return -1;
 11327ec:	17ffffeb 	b	1132798 <register_cipher+0x54>
   LTC_ARGCHK(cipher != NULL);
 11327f0:	52800213 	mov	w19, #0x10                  	// #16
 11327f4:	17ffffe9 	b	1132798 <register_cipher+0x54>

00000000011327f8 <register_hash>:
   Register a hash with the descriptor table
   @param hash   The hash you wish to register
   @return value >= 0 if successfully added (or already present), -1 if unsuccessful
*/
int register_hash(const struct ltc_hash_descriptor *hash)
{
 11327f8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 11327fc:	910003fd 	mov	x29, sp
 1132800:	a90153f3 	stp	x19, x20, [sp, #16]
 1132804:	f90013f5 	str	x21, [sp, #32]
   int x;

   LTC_ARGCHK(hash != NULL);
 1132808:	b4000480 	cbz	x0, 1132898 <register_hash+0xa0>

   /* is it already registered? */
   LTC_MUTEX_LOCK(&ltc_hash_mutex);
 113280c:	90000155 	adrp	x21, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1132810:	aa0003f4 	mov	x20, x0
 1132814:	f9422aa0 	ldr	x0, [x21, #1104]
 1132818:	97ff8b4f 	bl	1115554 <mutex_lock>
   for (x = 0; x < TAB_SIZE; x++) {
       if (hash_descriptor[x] == hash) {
 113281c:	f941a2a2 	ldr	x2, [x21, #832]
 1132820:	aa1503e0 	mov	x0, x21
   LTC_MUTEX_LOCK(&ltc_hash_mutex);
 1132824:	d2800001 	mov	x1, #0x0                   	// #0
       if (hash_descriptor[x] == hash) {
 1132828:	f8617843 	ldr	x3, [x2, x1, lsl #3]
 113282c:	2a0103f3 	mov	w19, w1
 1132830:	eb14007f 	cmp	x3, x20
 1132834:	54000101 	b.ne	1132854 <register_hash+0x5c>  // b.any

   /* find a blank spot */
   for (x = 0; x < TAB_SIZE; x++) {
       if (hash_descriptor[x] == NULL) {
          hash_descriptor[x] = hash;
          LTC_MUTEX_UNLOCK(&ltc_hash_mutex);
 1132838:	f9422800 	ldr	x0, [x0, #1104]
 113283c:	97ff8b25 	bl	11154d0 <mutex_unlock>
   }

   /* no spot */
   LTC_MUTEX_UNLOCK(&ltc_hash_mutex);
   return -1;
}
 1132840:	2a1303e0 	mov	w0, w19
 1132844:	a94153f3 	ldp	x19, x20, [sp, #16]
 1132848:	f94013f5 	ldr	x21, [sp, #32]
 113284c:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1132850:	d65f03c0 	ret
   for (x = 0; x < TAB_SIZE; x++) {
 1132854:	91000421 	add	x1, x1, #0x1
 1132858:	f100883f 	cmp	x1, #0x22
 113285c:	54fffe61 	b.ne	1132828 <register_hash+0x30>  // b.any
       if (hash_descriptor[x] == NULL) {
 1132860:	f941a002 	ldr	x2, [x0, #832]
 1132864:	d2800001 	mov	x1, #0x0                   	// #0
 1132868:	f8617843 	ldr	x3, [x2, x1, lsl #3]
 113286c:	2a0103f3 	mov	w19, w1
 1132870:	b5000063 	cbnz	x3, 113287c <register_hash+0x84>
          hash_descriptor[x] = hash;
 1132874:	f833d854 	str	x20, [x2, w19, sxtw #3]
 1132878:	17fffff0 	b	1132838 <register_hash+0x40>
   for (x = 0; x < TAB_SIZE; x++) {
 113287c:	91000421 	add	x1, x1, #0x1
 1132880:	f100883f 	cmp	x1, #0x22
 1132884:	54ffff21 	b.ne	1132868 <register_hash+0x70>  // b.any
   LTC_MUTEX_UNLOCK(&ltc_hash_mutex);
 1132888:	f9422800 	ldr	x0, [x0, #1104]
   return -1;
 113288c:	12800013 	mov	w19, #0xffffffff            	// #-1
   LTC_MUTEX_UNLOCK(&ltc_hash_mutex);
 1132890:	97ff8b10 	bl	11154d0 <mutex_unlock>
   return -1;
 1132894:	17ffffeb 	b	1132840 <register_hash+0x48>
   LTC_ARGCHK(hash != NULL);
 1132898:	52800213 	mov	w19, #0x10                  	// #16
 113289c:	17ffffe9 	b	1132840 <register_hash+0x48>

00000000011328a0 <register_prng>:
   Register a PRNG with the descriptor table
   @param prng   The PRNG you wish to register
   @return value >= 0 if successfully added (or already present), -1 if unsuccessful
*/
int register_prng(const struct ltc_prng_descriptor *prng)
{
 11328a0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 11328a4:	910003fd 	mov	x29, sp
 11328a8:	a90153f3 	stp	x19, x20, [sp, #16]
 11328ac:	f90013f5 	str	x21, [sp, #32]
   int x;

   LTC_ARGCHK(prng != NULL);
 11328b0:	b4000480 	cbz	x0, 1132940 <register_prng+0xa0>

   /* is it already registered? */
   LTC_MUTEX_LOCK(&ltc_prng_mutex);
 11328b4:	90000155 	adrp	x21, 115a000 <__scattered_array_1phys_mem_map+0x8>
 11328b8:	aa0003f4 	mov	x20, x0
 11328bc:	f9421ea0 	ldr	x0, [x21, #1080]
 11328c0:	97ff8b25 	bl	1115554 <mutex_lock>
   for (x = 0; x < TAB_SIZE; x++) {
       if (prng_descriptor[x] == prng) {
 11328c4:	f9422ea2 	ldr	x2, [x21, #1112]
 11328c8:	aa1503e0 	mov	x0, x21
   LTC_MUTEX_LOCK(&ltc_prng_mutex);
 11328cc:	d2800001 	mov	x1, #0x0                   	// #0
       if (prng_descriptor[x] == prng) {
 11328d0:	f8617843 	ldr	x3, [x2, x1, lsl #3]
 11328d4:	2a0103f3 	mov	w19, w1
 11328d8:	eb14007f 	cmp	x3, x20
 11328dc:	54000101 	b.ne	11328fc <register_prng+0x5c>  // b.any

   /* find a blank spot */
   for (x = 0; x < TAB_SIZE; x++) {
       if (prng_descriptor[x] == NULL) {
	  prng_descriptor[x] = prng;
          LTC_MUTEX_UNLOCK(&ltc_prng_mutex);
 11328e0:	f9421c00 	ldr	x0, [x0, #1080]
 11328e4:	97ff8afb 	bl	11154d0 <mutex_unlock>
   }

   /* no spot */
   LTC_MUTEX_UNLOCK(&ltc_prng_mutex);
   return -1;
}
 11328e8:	2a1303e0 	mov	w0, w19
 11328ec:	a94153f3 	ldp	x19, x20, [sp, #16]
 11328f0:	f94013f5 	ldr	x21, [sp, #32]
 11328f4:	a8c37bfd 	ldp	x29, x30, [sp], #48
 11328f8:	d65f03c0 	ret
   for (x = 0; x < TAB_SIZE; x++) {
 11328fc:	91000421 	add	x1, x1, #0x1
 1132900:	f100883f 	cmp	x1, #0x22
 1132904:	54fffe61 	b.ne	11328d0 <register_prng+0x30>  // b.any
       if (prng_descriptor[x] == NULL) {
 1132908:	f9422c02 	ldr	x2, [x0, #1112]
 113290c:	d2800001 	mov	x1, #0x0                   	// #0
 1132910:	f8617843 	ldr	x3, [x2, x1, lsl #3]
 1132914:	2a0103f3 	mov	w19, w1
 1132918:	b5000063 	cbnz	x3, 1132924 <register_prng+0x84>
	  prng_descriptor[x] = prng;
 113291c:	f833d854 	str	x20, [x2, w19, sxtw #3]
 1132920:	17fffff0 	b	11328e0 <register_prng+0x40>
   for (x = 0; x < TAB_SIZE; x++) {
 1132924:	91000421 	add	x1, x1, #0x1
 1132928:	f100883f 	cmp	x1, #0x22
 113292c:	54ffff21 	b.ne	1132910 <register_prng+0x70>  // b.any
   LTC_MUTEX_UNLOCK(&ltc_prng_mutex);
 1132930:	f9421c00 	ldr	x0, [x0, #1080]
   return -1;
 1132934:	12800013 	mov	w19, #0xffffffff            	// #-1
   LTC_MUTEX_UNLOCK(&ltc_prng_mutex);
 1132938:	97ff8ae6 	bl	11154d0 <mutex_unlock>
   return -1;
 113293c:	17ffffeb 	b	11328e8 <register_prng+0x48>
   LTC_ARGCHK(prng != NULL);
 1132940:	52800213 	mov	w19, #0x10                  	// #16
 1132944:	17ffffe9 	b	11328e8 <register_prng+0x48>

0000000001132948 <cbc_decrypt>:
  @param len    The number of bytes to process (must be multiple of block length)
  @param cbc    CBC state
  @return CRYPT_OK if successful
*/
int cbc_decrypt(const unsigned char *ct, unsigned char *pt, unsigned long len, symmetric_CBC *cbc)
{
 1132948:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
 113294c:	910003fd 	mov	x29, sp
 1132950:	a90153f3 	stp	x19, x20, [sp, #16]
 1132954:	a9025bf5 	stp	x21, x22, [sp, #32]
 1132958:	a90363f7 	stp	x23, x24, [sp, #48]
 113295c:	a9046bf9 	stp	x25, x26, [sp, #64]
 1132960:	f9002bfb 	str	x27, [sp, #80]
   LTC_FAST_TYPE tmpy;
#else
   unsigned char tmpy;
#endif

   LTC_ARGCHK(pt  != NULL);
 1132964:	b5000141 	cbnz	x1, 113298c <cbc_decrypt+0x44>
 1132968:	52800214 	mov	w20, #0x10                  	// #16
      ct  += cbc->blocklen;
      pt  += cbc->blocklen;
      len -= cbc->blocklen;
   }
   return CRYPT_OK;
}
 113296c:	2a1403e0 	mov	w0, w20
 1132970:	a94153f3 	ldp	x19, x20, [sp, #16]
 1132974:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1132978:	a94363f7 	ldp	x23, x24, [sp, #48]
 113297c:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1132980:	f9402bfb 	ldr	x27, [sp, #80]
 1132984:	a8c77bfd 	ldp	x29, x30, [sp], #112
 1132988:	d65f03c0 	ret
 113298c:	aa0003f5 	mov	x21, x0
   LTC_ARGCHK(ct  != NULL);
 1132990:	b4fffec0 	cbz	x0, 1132968 <cbc_decrypt+0x20>
 1132994:	aa0303f3 	mov	x19, x3
   LTC_ARGCHK(cbc != NULL);
 1132998:	b4fffe83 	cbz	x3, 1132968 <cbc_decrypt+0x20>
   if ((err = cipher_is_valid(cbc->cipher)) != CRYPT_OK) {
 113299c:	b9400060 	ldr	w0, [x3]
 11329a0:	aa0103f7 	mov	x23, x1
 11329a4:	aa0203f6 	mov	x22, x2
 11329a8:	97fffeaa 	bl	1132450 <cipher_is_valid>
 11329ac:	2a0003f4 	mov	w20, w0
 11329b0:	35fffde0 	cbnz	w0, 113296c <cbc_decrypt+0x24>
   if (cbc->blocklen < 1 || cbc->blocklen > (int)sizeof(cbc->IV) || cbc->blocklen > (int)sizeof(tmp)) {
 11329b4:	b9400660 	ldr	w0, [x19, #4]
 11329b8:	51000401 	sub	w1, w0, #0x1
 11329bc:	71003c3f 	cmp	w1, #0xf
 11329c0:	54fffd48 	b.hi	1132968 <cbc_decrypt+0x20>  // b.pmore
   if (len % cbc->blocklen) {
 11329c4:	93407c00 	sxtw	x0, w0
 11329c8:	9ac00ac2 	udiv	x2, x22, x0
 11329cc:	9b00d840 	msub	x0, x2, x0, x22
 11329d0:	b5fffcc0 	cbnz	x0, 1132968 <cbc_decrypt+0x20>
   if (cipher_descriptor[cbc->cipher]->accel_cbc_decrypt != NULL) {
 11329d4:	90000140 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 11329d8:	b9800263 	ldrsw	x3, [x19]
 11329dc:	aa0003fa 	mov	x26, x0
 11329e0:	f941c001 	ldr	x1, [x0, #896]
 11329e4:	f8637821 	ldr	x1, [x1, x3, lsl #3]
 11329e8:	f9403425 	ldr	x5, [x1, #104]
 11329ec:	b50002c5 	cbnz	x5, 1132a44 <cbc_decrypt+0xfc>
      if ((err = cipher_descriptor[cbc->cipher]->ecb_decrypt(ct, tmp, &cbc->key)) != CRYPT_OK) {
 11329f0:	9102627b 	add	x27, x19, #0x98
 11329f4:	910183f8 	add	x24, sp, #0x60
 11329f8:	91002279 	add	x25, x19, #0x8
   while (len) {
 11329fc:	b4fffb96 	cbz	x22, 113296c <cbc_decrypt+0x24>
      if ((err = cipher_descriptor[cbc->cipher]->ecb_decrypt(ct, tmp, &cbc->key)) != CRYPT_OK) {
 1132a00:	b9800261 	ldrsw	x1, [x19]
 1132a04:	aa1b03e2 	mov	x2, x27
 1132a08:	f941c340 	ldr	x0, [x26, #896]
 1132a0c:	f8617800 	ldr	x0, [x0, x1, lsl #3]
 1132a10:	aa1803e1 	mov	x1, x24
 1132a14:	f9401803 	ldr	x3, [x0, #48]
 1132a18:	aa1503e0 	mov	x0, x21
 1132a1c:	d63f0060 	blr	x3
 1132a20:	350001c0 	cbnz	w0, 1132a58 <cbc_decrypt+0x110>
 1132a24:	d2800000 	mov	x0, #0x0                   	// #0
      for (x = 0; x < cbc->blocklen; x++) {
 1132a28:	b9400663 	ldr	w3, [x19, #4]
 1132a2c:	6b00007f 	cmp	w3, w0
 1132a30:	5400018c 	b.gt	1132a60 <cbc_decrypt+0x118>
      ct  += cbc->blocklen;
 1132a34:	8b23c2b5 	add	x21, x21, w3, sxtw
      pt  += cbc->blocklen;
 1132a38:	8b23c2f7 	add	x23, x23, w3, sxtw
      len -= cbc->blocklen;
 1132a3c:	cb23c2d6 	sub	x22, x22, w3, sxtw
 1132a40:	17ffffef 	b	11329fc <cbc_decrypt+0xb4>
      return cipher_descriptor[cbc->cipher]->accel_cbc_decrypt(ct, pt, len / cbc->blocklen, cbc->IV, &cbc->key);
 1132a44:	91026264 	add	x4, x19, #0x98
 1132a48:	91002263 	add	x3, x19, #0x8
 1132a4c:	aa1703e1 	mov	x1, x23
 1132a50:	aa1503e0 	mov	x0, x21
 1132a54:	d63f00a0 	blr	x5
      if ((err = cipher_descriptor[cbc->cipher]->ecb_decrypt(ct, tmp, &cbc->key)) != CRYPT_OK) {
 1132a58:	2a0003f4 	mov	w20, w0
 1132a5c:	17ffffc4 	b	113296c <cbc_decrypt+0x24>
         tmpy       = tmp[x] ^ cbc->IV[x];
 1132a60:	38606b21 	ldrb	w1, [x25, x0]
 1132a64:	38606b03 	ldrb	w3, [x24, x0]
 1132a68:	4a010063 	eor	w3, w3, w1
         cbc->IV[x] = ct[x];
 1132a6c:	38606aa1 	ldrb	w1, [x21, x0]
 1132a70:	38206b21 	strb	w1, [x25, x0]
         pt[x]      = tmpy;
 1132a74:	38206ae3 	strb	w3, [x23, x0]
      for (x = 0; x < cbc->blocklen; x++) {
 1132a78:	91000400 	add	x0, x0, #0x1
 1132a7c:	17ffffeb 	b	1132a28 <cbc_decrypt+0xe0>

0000000001132a80 <cbc_done>:
/** Terminate the chain
  @param cbc    The CBC chain to terminate
  @return CRYPT_OK on success
*/
int cbc_done(symmetric_CBC *cbc)
{
 1132a80:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1132a84:	910003fd 	mov	x29, sp
 1132a88:	a90153f3 	stp	x19, x20, [sp, #16]
   int err;
   LTC_ARGCHK(cbc != NULL);
 1132a8c:	b4000220 	cbz	x0, 1132ad0 <cbc_done+0x50>
 1132a90:	aa0003f3 	mov	x19, x0

   if ((err = cipher_is_valid(cbc->cipher)) != CRYPT_OK) {
 1132a94:	b9400000 	ldr	w0, [x0]
 1132a98:	97fffe6e 	bl	1132450 <cipher_is_valid>
 1132a9c:	2a0003f4 	mov	w20, w0
 1132aa0:	35000100 	cbnz	w0, 1132ac0 <cbc_done+0x40>
      return err;
   }
   cipher_descriptor[cbc->cipher]->done(&cbc->key);
 1132aa4:	aa1303e0 	mov	x0, x19
 1132aa8:	90000141 	adrp	x1, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1132aac:	f941c021 	ldr	x1, [x1, #896]
 1132ab0:	b8898402 	ldrsw	x2, [x0], #152
 1132ab4:	f8627821 	ldr	x1, [x1, x2, lsl #3]
 1132ab8:	f9402021 	ldr	x1, [x1, #64]
 1132abc:	d63f0020 	blr	x1
   return CRYPT_OK;
}
 1132ac0:	2a1403e0 	mov	w0, w20
 1132ac4:	a94153f3 	ldp	x19, x20, [sp, #16]
 1132ac8:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1132acc:	d65f03c0 	ret
   LTC_ARGCHK(cbc != NULL);
 1132ad0:	52800214 	mov	w20, #0x10                  	// #16
 1132ad4:	17fffffb 	b	1132ac0 <cbc_done+0x40>

0000000001132ad8 <cbc_encrypt>:
  @param len    The number of bytes to process (must be multiple of block length)
  @param cbc    CBC state
  @return CRYPT_OK if successful
*/
int cbc_encrypt(const unsigned char *pt, unsigned char *ct, unsigned long len, symmetric_CBC *cbc)
{
 1132ad8:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 1132adc:	910003fd 	mov	x29, sp
 1132ae0:	a90153f3 	stp	x19, x20, [sp, #16]
 1132ae4:	a9025bf5 	stp	x21, x22, [sp, #32]
 1132ae8:	a90363f7 	stp	x23, x24, [sp, #48]
 1132aec:	a9046bf9 	stp	x25, x26, [sp, #64]
   int x, err;

   LTC_ARGCHK(pt != NULL);
 1132af0:	b40008c0 	cbz	x0, 1132c08 <cbc_encrypt+0x130>
 1132af4:	aa0103f4 	mov	x20, x1
   LTC_ARGCHK(ct != NULL);
 1132af8:	b4000881 	cbz	x1, 1132c08 <cbc_encrypt+0x130>
 1132afc:	aa0303f3 	mov	x19, x3
   LTC_ARGCHK(cbc != NULL);
 1132b00:	b4000843 	cbz	x3, 1132c08 <cbc_encrypt+0x130>
 1132b04:	aa0003f5 	mov	x21, x0

   if ((err = cipher_is_valid(cbc->cipher)) != CRYPT_OK) {
 1132b08:	b9400060 	ldr	w0, [x3]
 1132b0c:	aa0203f6 	mov	x22, x2
 1132b10:	97fffe50 	bl	1132450 <cipher_is_valid>
 1132b14:	2a0003f7 	mov	w23, w0
 1132b18:	350007a0 	cbnz	w0, 1132c0c <cbc_encrypt+0x134>
       return err;
   }

   /* is blocklen valid? */
   if (cbc->blocklen < 1 || cbc->blocklen > (int)sizeof(cbc->IV)) {
 1132b1c:	b9400661 	ldr	w1, [x19, #4]
 1132b20:	51000420 	sub	w0, w1, #0x1
 1132b24:	71023c1f 	cmp	w0, #0x8f
 1132b28:	54000708 	b.hi	1132c08 <cbc_encrypt+0x130>  // b.pmore
      return CRYPT_INVALID_ARG;
   }

   if (len % cbc->blocklen) {
 1132b2c:	93407c21 	sxtw	x1, w1
 1132b30:	9ac10ac2 	udiv	x2, x22, x1
 1132b34:	9b01d841 	msub	x1, x2, x1, x22
 1132b38:	b5000681 	cbnz	x1, 1132c08 <cbc_encrypt+0x130>
   if (cbc->blocklen % sizeof(LTC_FAST_TYPE)) {
      return CRYPT_INVALID_ARG;
   }
#endif

   if (cipher_descriptor[cbc->cipher]->accel_cbc_encrypt != NULL) {
 1132b3c:	90000140 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1132b40:	b9800261 	ldrsw	x1, [x19]
 1132b44:	f941c000 	ldr	x0, [x0, #896]
 1132b48:	f8617801 	ldr	x1, [x0, x1, lsl #3]
 1132b4c:	f9403025 	ldr	x5, [x1, #96]
 1132b50:	b5000105 	cbnz	x5, 1132b70 <cbc_encrypt+0x98>
 1132b54:	91002278 	add	x24, x19, #0x8
         cbc->IV[x] ^= pt[x];
      }
#endif

      /* encrypt */
      if ((err = cipher_descriptor[cbc->cipher]->ecb_encrypt(cbc->IV, ct, &cbc->key)) != CRYPT_OK) {
 1132b58:	9102627a 	add	x26, x19, #0x98
 1132b5c:	aa0003f9 	mov	x25, x0
   while (len) {
 1132b60:	b4000576 	cbz	x22, 1132c0c <cbc_encrypt+0x134>
      for (x = 0; x < cbc->blocklen; x++) {
 1132b64:	b9400663 	ldr	w3, [x19, #4]
 1132b68:	d2800000 	mov	x0, #0x0                   	// #0
 1132b6c:	14000011 	b	1132bb0 <cbc_encrypt+0xd8>
      return cipher_descriptor[cbc->cipher]->accel_cbc_encrypt(pt, ct, len / cbc->blocklen, cbc->IV, &cbc->key);
 1132b70:	91026264 	add	x4, x19, #0x98
 1132b74:	91002263 	add	x3, x19, #0x8
 1132b78:	aa1403e1 	mov	x1, x20
 1132b7c:	aa1503e0 	mov	x0, x21
      ct  += cbc->blocklen;
      pt  += cbc->blocklen;
      len -= cbc->blocklen;
   }
   return CRYPT_OK;
}
 1132b80:	a94153f3 	ldp	x19, x20, [sp, #16]
      return cipher_descriptor[cbc->cipher]->accel_cbc_encrypt(pt, ct, len / cbc->blocklen, cbc->IV, &cbc->key);
 1132b84:	aa0503f0 	mov	x16, x5
}
 1132b88:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1132b8c:	a94363f7 	ldp	x23, x24, [sp, #48]
 1132b90:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1132b94:	a8c57bfd 	ldp	x29, x30, [sp], #80
      return cipher_descriptor[cbc->cipher]->accel_cbc_encrypt(pt, ct, len / cbc->blocklen, cbc->IV, &cbc->key);
 1132b98:	d61f0200 	br	x16
         cbc->IV[x] ^= pt[x];
 1132b9c:	38606b01 	ldrb	w1, [x24, x0]
 1132ba0:	38606aa2 	ldrb	w2, [x21, x0]
 1132ba4:	4a020021 	eor	w1, w1, w2
 1132ba8:	38206b01 	strb	w1, [x24, x0]
      for (x = 0; x < cbc->blocklen; x++) {
 1132bac:	91000400 	add	x0, x0, #0x1
 1132bb0:	6b00007f 	cmp	w3, w0
 1132bb4:	54ffff4c 	b.gt	1132b9c <cbc_encrypt+0xc4>
      if ((err = cipher_descriptor[cbc->cipher]->ecb_encrypt(cbc->IV, ct, &cbc->key)) != CRYPT_OK) {
 1132bb8:	b9800260 	ldrsw	x0, [x19]
 1132bbc:	aa1a03e2 	mov	x2, x26
 1132bc0:	aa1403e1 	mov	x1, x20
 1132bc4:	f8607b20 	ldr	x0, [x25, x0, lsl #3]
 1132bc8:	f9401403 	ldr	x3, [x0, #40]
 1132bcc:	aa1803e0 	mov	x0, x24
 1132bd0:	d63f0060 	blr	x3
 1132bd4:	350002a0 	cbnz	w0, 1132c28 <cbc_encrypt+0x150>
      for (x = 0; x < cbc->blocklen; x++) {
 1132bd8:	b9400661 	ldr	w1, [x19, #4]
 1132bdc:	d2800000 	mov	x0, #0x0                   	// #0
 1132be0:	6b00003f 	cmp	w1, w0
 1132be4:	540000ac 	b.gt	1132bf8 <cbc_encrypt+0x120>
      ct  += cbc->blocklen;
 1132be8:	8b21c294 	add	x20, x20, w1, sxtw
      pt  += cbc->blocklen;
 1132bec:	8b21c2b5 	add	x21, x21, w1, sxtw
      len -= cbc->blocklen;
 1132bf0:	cb21c2d6 	sub	x22, x22, w1, sxtw
 1132bf4:	17ffffdb 	b	1132b60 <cbc_encrypt+0x88>
         cbc->IV[x] = ct[x];
 1132bf8:	38606a82 	ldrb	w2, [x20, x0]
 1132bfc:	38206b02 	strb	w2, [x24, x0]
      for (x = 0; x < cbc->blocklen; x++) {
 1132c00:	91000400 	add	x0, x0, #0x1
 1132c04:	17fffff7 	b	1132be0 <cbc_encrypt+0x108>
   LTC_ARGCHK(pt != NULL);
 1132c08:	52800217 	mov	w23, #0x10                  	// #16
}
 1132c0c:	2a1703e0 	mov	w0, w23
 1132c10:	a94153f3 	ldp	x19, x20, [sp, #16]
 1132c14:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1132c18:	a94363f7 	ldp	x23, x24, [sp, #48]
 1132c1c:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1132c20:	a8c57bfd 	ldp	x29, x30, [sp], #80
 1132c24:	d65f03c0 	ret
      if ((err = cipher_descriptor[cbc->cipher]->ecb_encrypt(cbc->IV, ct, &cbc->key)) != CRYPT_OK) {
 1132c28:	2a0003f7 	mov	w23, w0
 1132c2c:	17fffff8 	b	1132c0c <cbc_encrypt+0x134>

0000000001132c30 <cbc_start>:
int cbc_start(int cipher, const unsigned char *IV, const unsigned char *key,
              int keylen, int num_rounds, symmetric_CBC *cbc)
{
   int x, err;

   LTC_ARGCHK(IV != NULL);
 1132c30:	b40005a1 	cbz	x1, 1132ce4 <cbc_start+0xb4>
{
 1132c34:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 1132c38:	910003fd 	mov	x29, sp
 1132c3c:	a90153f3 	stp	x19, x20, [sp, #16]
 1132c40:	a9025bf5 	stp	x21, x22, [sp, #32]
 1132c44:	a90363f7 	stp	x23, x24, [sp, #48]
 1132c48:	aa0203f7 	mov	x23, x2
 1132c4c:	a9046bf9 	stp	x25, x26, [sp, #64]
   LTC_ARGCHK(key != NULL);
 1132c50:	b40004e2 	cbz	x2, 1132cec <cbc_start+0xbc>
 1132c54:	aa0503f3 	mov	x19, x5
   LTC_ARGCHK(cbc != NULL);
 1132c58:	b40004a5 	cbz	x5, 1132cec <cbc_start+0xbc>
 1132c5c:	2a0003f5 	mov	w21, w0
 1132c60:	aa0103f4 	mov	x20, x1
 1132c64:	2a0303f8 	mov	w24, w3
 1132c68:	2a0403f9 	mov	w25, w4

   /* bad param? */
   if ((err = cipher_is_valid(cipher)) != CRYPT_OK) {
 1132c6c:	97fffdf9 	bl	1132450 <cipher_is_valid>
 1132c70:	35000260 	cbnz	w0, 1132cbc <cbc_start+0x8c>
      return err;
   }

   /* setup cipher */
   if ((err = cipher_descriptor[cipher]->setup(key, keylen, num_rounds, &cbc->key)) != CRYPT_OK) {
 1132c74:	90000156 	adrp	x22, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1132c78:	93407eba 	sxtw	x26, w21
 1132c7c:	91026263 	add	x3, x19, #0x98
 1132c80:	2a1903e2 	mov	w2, w25
 1132c84:	f941c2d6 	ldr	x22, [x22, #896]
 1132c88:	2a1803e1 	mov	w1, w24
 1132c8c:	f87a7ac0 	ldr	x0, [x22, x26, lsl #3]
 1132c90:	f9401004 	ldr	x4, [x0, #32]
 1132c94:	aa1703e0 	mov	x0, x23
 1132c98:	d63f0080 	blr	x4
 1132c9c:	35000100 	cbnz	w0, 1132cbc <cbc_start+0x8c>
      return err;
   }

   /* copy IV */
   cbc->blocklen = cipher_descriptor[cipher]->block_length;
 1132ca0:	f87a7ac1 	ldr	x1, [x22, x26, lsl #3]
   cbc->cipher   = cipher;
   for (x = 0; x < cbc->blocklen; x++) {
 1132ca4:	d2800002 	mov	x2, #0x0                   	// #0
   cbc->blocklen = cipher_descriptor[cipher]->block_length;
 1132ca8:	b9401421 	ldr	w1, [x1, #20]
 1132cac:	b9000661 	str	w1, [x19, #4]
   cbc->cipher   = cipher;
 1132cb0:	b8008675 	str	w21, [x19], #8
   for (x = 0; x < cbc->blocklen; x++) {
 1132cb4:	6b02003f 	cmp	w1, w2
 1132cb8:	540000ec 	b.gt	1132cd4 <cbc_start+0xa4>
       cbc->IV[x] = IV[x];
   }
   return CRYPT_OK;
}
 1132cbc:	a94153f3 	ldp	x19, x20, [sp, #16]
 1132cc0:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1132cc4:	a94363f7 	ldp	x23, x24, [sp, #48]
 1132cc8:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1132ccc:	a8c57bfd 	ldp	x29, x30, [sp], #80
 1132cd0:	d65f03c0 	ret
       cbc->IV[x] = IV[x];
 1132cd4:	38626a83 	ldrb	w3, [x20, x2]
 1132cd8:	38226a63 	strb	w3, [x19, x2]
   for (x = 0; x < cbc->blocklen; x++) {
 1132cdc:	91000442 	add	x2, x2, #0x1
 1132ce0:	17fffff5 	b	1132cb4 <cbc_start+0x84>
   LTC_ARGCHK(IV != NULL);
 1132ce4:	52800200 	mov	w0, #0x10                  	// #16
}
 1132ce8:	d65f03c0 	ret
   LTC_ARGCHK(IV != NULL);
 1132cec:	52800200 	mov	w0, #0x10                  	// #16
 1132cf0:	17fffff3 	b	1132cbc <cbc_start+0x8c>

0000000001132cf4 <ctr_decrypt>:
   @param ctr     CTR state
   @return CRYPT_OK if successful
*/
int ctr_decrypt(const unsigned char *ct, unsigned char *pt, unsigned long len, symmetric_CTR *ctr)
{
   LTC_ARGCHK(pt != NULL);
 1132cf4:	b4000081 	cbz	x1, 1132d04 <ctr_decrypt+0x10>
   LTC_ARGCHK(ct != NULL);
 1132cf8:	b4000060 	cbz	x0, 1132d04 <ctr_decrypt+0x10>
   LTC_ARGCHK(ctr != NULL);
 1132cfc:	b4000043 	cbz	x3, 1132d04 <ctr_decrypt+0x10>

   return ctr_encrypt(ct, pt, len, ctr);
 1132d00:	14000065 	b	1132e94 <ctr_encrypt>
}
 1132d04:	52800200 	mov	w0, #0x10                  	// #16
 1132d08:	d65f03c0 	ret

0000000001132d0c <ctr_done>:
/** Terminate the chain
  @param ctr    The CTR chain to terminate
  @return CRYPT_OK on success
*/
int ctr_done(symmetric_CTR *ctr)
{
 1132d0c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1132d10:	910003fd 	mov	x29, sp
 1132d14:	a90153f3 	stp	x19, x20, [sp, #16]
   int err;
   LTC_ARGCHK(ctr != NULL);
 1132d18:	b4000220 	cbz	x0, 1132d5c <ctr_done+0x50>
 1132d1c:	aa0003f3 	mov	x19, x0

   if ((err = cipher_is_valid(ctr->cipher)) != CRYPT_OK) {
 1132d20:	b9400000 	ldr	w0, [x0]
 1132d24:	97fffdcb 	bl	1132450 <cipher_is_valid>
 1132d28:	2a0003f4 	mov	w20, w0
 1132d2c:	35000100 	cbnz	w0, 1132d4c <ctr_done+0x40>
      return err;
   }
   cipher_descriptor[ctr->cipher]->done(&ctr->key);
 1132d30:	90000140 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1132d34:	b9800261 	ldrsw	x1, [x19]
 1132d38:	f941c000 	ldr	x0, [x0, #896]
 1132d3c:	f8617800 	ldr	x0, [x0, x1, lsl #3]
 1132d40:	f9402001 	ldr	x1, [x0, #64]
 1132d44:	9104e260 	add	x0, x19, #0x138
 1132d48:	d63f0020 	blr	x1
   return CRYPT_OK;
}
 1132d4c:	2a1403e0 	mov	w0, w20
 1132d50:	a94153f3 	ldp	x19, x20, [sp, #16]
 1132d54:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1132d58:	d65f03c0 	ret
   LTC_ARGCHK(ctr != NULL);
 1132d5c:	52800214 	mov	w20, #0x10                  	// #16
 1132d60:	17fffffb 	b	1132d4c <ctr_done+0x40>

0000000001132d64 <_ctr_encrypt>:
  @param len    Length of plaintext (octets)
  @param ctr    CTR state
  @return CRYPT_OK if successful
*/
static int _ctr_encrypt(const unsigned char *pt, unsigned char *ct, unsigned long len, symmetric_CTR *ctr)
{
 1132d64:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
 1132d68:	910003fd 	mov	x29, sp
 1132d6c:	a9046bf9 	stp	x25, x26, [sp, #64]

   while (len) {
      /* is the pad empty? */
      if (ctr->padlen == ctr->blocklen) {
        /* encrypt counter into pad */
        if ((err = cipher_descriptor[ctr->cipher]->ecb_encrypt(ctr->ctr, ctr->pad, &ctr->key)) != CRYPT_OK) {
 1132d70:	90000159 	adrp	x25, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1132d74:	9104e07a 	add	x26, x3, #0x138
 1132d78:	f941c339 	ldr	x25, [x25, #896]
{
 1132d7c:	a90153f3 	stp	x19, x20, [sp, #16]
 1132d80:	aa0303f3 	mov	x19, x3
 1132d84:	a9025bf5 	stp	x21, x22, [sp, #32]
 1132d88:	aa0003f6 	mov	x22, x0
 1132d8c:	aa0203f5 	mov	x21, x2
 1132d90:	a90363f7 	stp	x23, x24, [sp, #48]
 1132d94:	aa0103f7 	mov	x23, x1
        if ((err = cipher_descriptor[ctr->cipher]->ecb_encrypt(ctr->ctr, ctr->pad, &ctr->key)) != CRYPT_OK) {
 1132d98:	91005078 	add	x24, x3, #0x14
{
 1132d9c:	f9002bfb 	str	x27, [sp, #80]
        if ((err = cipher_descriptor[ctr->cipher]->ecb_encrypt(ctr->ctr, ctr->pad, &ctr->key)) != CRYPT_OK) {
 1132da0:	9102907b 	add	x27, x3, #0xa4
   while (len) {
 1132da4:	d2800014 	mov	x20, #0x0                   	// #0
 1132da8:	eb1402bf 	cmp	x21, x20
 1132dac:	54000121 	b.ne	1132dd0 <_ctr_encrypt+0x6c>  // b.any
      /* done with one full block? if so, set counter for next block. */
      if (ctr->padlen == ctr->blocklen) {
         ctr_increment_counter(ctr);
      }
   }
   return CRYPT_OK;
 1132db0:	52800000 	mov	w0, #0x0                   	// #0
}
 1132db4:	a94153f3 	ldp	x19, x20, [sp, #16]
 1132db8:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1132dbc:	a94363f7 	ldp	x23, x24, [sp, #48]
 1132dc0:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1132dc4:	f9402bfb 	ldr	x27, [sp, #80]
 1132dc8:	a8c67bfd 	ldp	x29, x30, [sp], #96
 1132dcc:	d65f03c0 	ret
      if (ctr->padlen == ctr->blocklen) {
 1132dd0:	29408660 	ldp	w0, w1, [x19, #4]
 1132dd4:	6b00003f 	cmp	w1, w0
 1132dd8:	54000141 	b.ne	1132e00 <_ctr_encrypt+0x9c>  // b.any
        if ((err = cipher_descriptor[ctr->cipher]->ecb_encrypt(ctr->ctr, ctr->pad, &ctr->key)) != CRYPT_OK) {
 1132ddc:	b9800260 	ldrsw	x0, [x19]
 1132de0:	aa1a03e2 	mov	x2, x26
 1132de4:	aa1b03e1 	mov	x1, x27
 1132de8:	f8607b20 	ldr	x0, [x25, x0, lsl #3]
 1132dec:	f9401403 	ldr	x3, [x0, #40]
 1132df0:	aa1803e0 	mov	x0, x24
 1132df4:	d63f0060 	blr	x3
 1132df8:	35fffde0 	cbnz	w0, 1132db4 <_ctr_encrypt+0x50>
        ctr->padlen = 0;
 1132dfc:	b9000a7f 	str	wzr, [x19, #8]
      *ct++ = *pt++ ^ ctr->pad[ctr->padlen++];
 1132e00:	b9400a63 	ldr	w3, [x19, #8]
 1132e04:	38746ac0 	ldrb	w0, [x22, x20]
 1132e08:	11000461 	add	w1, w3, #0x1
 1132e0c:	b9000a61 	str	w1, [x19, #8]
 1132e10:	8b23c263 	add	x3, x19, w3, sxtw
 1132e14:	39429061 	ldrb	w1, [x3, #164]
 1132e18:	4a010000 	eor	w0, w0, w1
 1132e1c:	38346ae0 	strb	w0, [x23, x20]
      if (ctr->padlen == ctr->blocklen) {
 1132e20:	29408e60 	ldp	w0, w3, [x19, #4]
 1132e24:	6b00007f 	cmp	w3, w0
 1132e28:	54000060 	b.eq	1132e34 <_ctr_encrypt+0xd0>  // b.none
 1132e2c:	91000694 	add	x20, x20, #0x1
 1132e30:	17ffffde 	b	1132da8 <_ctr_encrypt+0x44>
	if (ctr->mode == CTR_COUNTER_LITTLE_ENDIAN) {
 1132e34:	29418261 	ldp	w1, w0, [x19, #12]
 1132e38:	35000181 	cbnz	w1, 1132e68 <_ctr_encrypt+0x104>
 1132e3c:	aa1303e4 	mov	x4, x19
		for (x = 0; x < ctr->ctrlen; x++) {
 1132e40:	4b130081 	sub	w1, w4, w19
 1132e44:	6b00003f 	cmp	w1, w0
 1132e48:	54ffff2a 	b.ge	1132e2c <_ctr_encrypt+0xc8>  // b.tcont
			ctr->ctr[x] = (ctr->ctr[x] + 1) & 0xff;
 1132e4c:	39405083 	ldrb	w3, [x4, #20]
 1132e50:	91000484 	add	x4, x4, #0x1
 1132e54:	11000463 	add	w3, w3, #0x1
 1132e58:	12001c63 	and	w3, w3, #0xff
 1132e5c:	39004c83 	strb	w3, [x4, #19]
			if (ctr->ctr[x])
 1132e60:	34ffff03 	cbz	w3, 1132e40 <_ctr_encrypt+0xdc>
 1132e64:	17fffff2 	b	1132e2c <_ctr_encrypt+0xc8>
		for (x = ctr->blocklen - 1; x >= ctr->ctrlen; x--) {
 1132e68:	51000463 	sub	w3, w3, #0x1
 1132e6c:	93407c63 	sxtw	x3, w3
 1132e70:	6b03001f 	cmp	w0, w3
 1132e74:	54fffdcc 	b.gt	1132e2c <_ctr_encrypt+0xc8>
			ctr->ctr[x] = (ctr->ctr[x] + 1) & 0xff;
 1132e78:	38636b04 	ldrb	w4, [x24, x3]
 1132e7c:	11000484 	add	w4, w4, #0x1
 1132e80:	12001c84 	and	w4, w4, #0xff
 1132e84:	38236b04 	strb	w4, [x24, x3]
			if (ctr->ctr[x]) {
 1132e88:	d1000463 	sub	x3, x3, #0x1
 1132e8c:	34ffff24 	cbz	w4, 1132e70 <_ctr_encrypt+0x10c>
 1132e90:	17ffffe7 	b	1132e2c <_ctr_encrypt+0xc8>

0000000001132e94 <ctr_encrypt>:
  @param len    Length of plaintext (octets)
  @param ctr    CTR state
  @return CRYPT_OK if successful
*/
int ctr_encrypt(const unsigned char *pt, unsigned char *ct, unsigned long len, symmetric_CTR *ctr)
{
 1132e94:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 1132e98:	910003fd 	mov	x29, sp
 1132e9c:	a9025bf5 	stp	x21, x22, [sp, #32]
   if (ctr->blocklen % sizeof(LTC_FAST_TYPE)) {
      return CRYPT_INVALID_ARG;
   }
#endif

   if (cipher_descriptor[ctr->cipher]->accel_ctr_encrypt != NULL ) {
 1132ea0:	90000156 	adrp	x22, 115a000 <__scattered_array_1phys_mem_map+0x8>
{
 1132ea4:	aa0003f5 	mov	x21, x0
   if (cipher_descriptor[ctr->cipher]->accel_ctr_encrypt != NULL ) {
 1132ea8:	f941c2d6 	ldr	x22, [x22, #896]
{
 1132eac:	a90153f3 	stp	x19, x20, [sp, #16]
 1132eb0:	aa0203f4 	mov	x20, x2
 1132eb4:	aa0303f3 	mov	x19, x3
 1132eb8:	a90363f7 	stp	x23, x24, [sp, #48]
     /* handle acceleration only if not in the middle of a block, accelerator is present and length is >= a block size */
     if ((ctr->padlen == 0 || ctr->padlen == ctr->blocklen) && len >= (unsigned long)ctr->blocklen) {
       if ((err = cipher_descriptor[ctr->cipher]->accel_ctr_encrypt(pt, ct, len/ctr->blocklen, ctr->ctr, ctr->mode, &ctr->key)) != CRYPT_OK) {
 1132ebc:	9104e077 	add	x23, x3, #0x138
 1132ec0:	91005078 	add	x24, x3, #0x14
{
 1132ec4:	a9046bf9 	stp	x25, x26, [sp, #64]
 1132ec8:	aa0103f9 	mov	x25, x1
   LTC_ARGCHK(pt != NULL);
 1132ecc:	b5000115 	cbnz	x21, 1132eec <ctr_encrypt+0x58>
 1132ed0:	52800200 	mov	w0, #0x10                  	// #16
       return ctr_encrypt(pt, ct, len, ctr);
     }
   }

   return _ctr_encrypt(pt, ct, len, ctr);
}
 1132ed4:	a94153f3 	ldp	x19, x20, [sp, #16]
 1132ed8:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1132edc:	a94363f7 	ldp	x23, x24, [sp, #48]
 1132ee0:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1132ee4:	a8c57bfd 	ldp	x29, x30, [sp], #80
 1132ee8:	d65f03c0 	ret
   LTC_ARGCHK(ct != NULL);
 1132eec:	b4ffff39 	cbz	x25, 1132ed0 <ctr_encrypt+0x3c>
   LTC_ARGCHK(ctr != NULL);
 1132ef0:	b4ffff13 	cbz	x19, 1132ed0 <ctr_encrypt+0x3c>
   if ((err = cipher_is_valid(ctr->cipher)) != CRYPT_OK) {
 1132ef4:	b9400260 	ldr	w0, [x19]
 1132ef8:	97fffd56 	bl	1132450 <cipher_is_valid>
 1132efc:	35fffec0 	cbnz	w0, 1132ed4 <ctr_encrypt+0x40>
   if ((ctr->blocklen < 1) || (ctr->blocklen > (int)sizeof(ctr->ctr)) ||
 1132f00:	b9400660 	ldr	w0, [x19, #4]
 1132f04:	51000401 	sub	w1, w0, #0x1
 1132f08:	71023c3f 	cmp	w1, #0x8f
 1132f0c:	54fffe28 	b.hi	1132ed0 <ctr_encrypt+0x3c>  // b.pmore
       (ctr->padlen   < 0) || (ctr->padlen   > (int)sizeof(ctr->pad))) {
 1132f10:	b9400a61 	ldr	w1, [x19, #8]
 1132f14:	7102403f 	cmp	w1, #0x90
 1132f18:	54fffdc8 	b.hi	1132ed0 <ctr_encrypt+0x3c>  // b.pmore
   if (cipher_descriptor[ctr->cipher]->accel_ctr_encrypt != NULL ) {
 1132f1c:	b9800262 	ldrsw	x2, [x19]
 1132f20:	f8627ac2 	ldr	x2, [x22, x2, lsl #3]
 1132f24:	f9403846 	ldr	x6, [x2, #112]
 1132f28:	b4000506 	cbz	x6, 1132fc8 <ctr_encrypt+0x134>
     if ((ctr->padlen == 0 || ctr->padlen == ctr->blocklen) && len >= (unsigned long)ctr->blocklen) {
 1132f2c:	34000061 	cbz	w1, 1132f38 <ctr_encrypt+0xa4>
 1132f30:	6b01001f 	cmp	w0, w1
 1132f34:	54000281 	b.ne	1132f84 <ctr_encrypt+0xf0>  // b.any
 1132f38:	93407c02 	sxtw	x2, w0
 1132f3c:	eb20c29f 	cmp	x20, w0, sxtw
 1132f40:	54000223 	b.cc	1132f84 <ctr_encrypt+0xf0>  // b.lo, b.ul, b.last
       if ((err = cipher_descriptor[ctr->cipher]->accel_ctr_encrypt(pt, ct, len/ctr->blocklen, ctr->ctr, ctr->mode, &ctr->key)) != CRYPT_OK) {
 1132f44:	9ac20a82 	udiv	x2, x20, x2
 1132f48:	b9400e64 	ldr	w4, [x19, #12]
 1132f4c:	aa1703e5 	mov	x5, x23
 1132f50:	aa1803e3 	mov	x3, x24
 1132f54:	aa1903e1 	mov	x1, x25
 1132f58:	aa1503e0 	mov	x0, x21
 1132f5c:	d63f00c0 	blr	x6
 1132f60:	35fffba0 	cbnz	w0, 1132ed4 <ctr_encrypt+0x40>
       pt += (len / ctr->blocklen) * ctr->blocklen;
 1132f64:	b9400661 	ldr	w1, [x19, #4]
       ctr->padlen = ctr->blocklen;
 1132f68:	b9000a61 	str	w1, [x19, #8]
       pt += (len / ctr->blocklen) * ctr->blocklen;
 1132f6c:	93407c22 	sxtw	x2, w1
 1132f70:	9ac20a80 	udiv	x0, x20, x2
 1132f74:	9b027c00 	mul	x0, x0, x2
 1132f78:	8b0002b5 	add	x21, x21, x0
       ct += (len / ctr->blocklen) * ctr->blocklen;
 1132f7c:	8b000339 	add	x25, x25, x0
       len %= ctr->blocklen;
 1132f80:	cb000294 	sub	x20, x20, x0
     incr = ctr->blocklen - ctr->padlen;
 1132f84:	29408261 	ldp	w1, w0, [x19, #4]
 1132f88:	4b000020 	sub	w0, w1, w0
     if (len >= incr + (unsigned long)ctr->blocklen) {
 1132f8c:	93407c21 	sxtw	x1, w1
     incr = ctr->blocklen - ctr->padlen;
 1132f90:	93407c1a 	sxtw	x26, w0
     if (len >= incr + (unsigned long)ctr->blocklen) {
 1132f94:	8b20c020 	add	x0, x1, w0, sxtw
 1132f98:	eb14001f 	cmp	x0, x20
 1132f9c:	54000168 	b.hi	1132fc8 <ctr_encrypt+0x134>  // b.pmore
       if ((err = _ctr_encrypt(pt, ct, incr, ctr)) != CRYPT_OK) {
 1132fa0:	aa1303e3 	mov	x3, x19
 1132fa4:	aa1a03e2 	mov	x2, x26
 1132fa8:	aa1903e1 	mov	x1, x25
 1132fac:	aa1503e0 	mov	x0, x21
 1132fb0:	97ffff6d 	bl	1132d64 <_ctr_encrypt>
 1132fb4:	35fff900 	cbnz	w0, 1132ed4 <ctr_encrypt+0x40>
       pt += incr;
 1132fb8:	8b1a02b5 	add	x21, x21, x26
       ct += incr;
 1132fbc:	8b1a0339 	add	x25, x25, x26
       len -= incr;
 1132fc0:	cb1a0294 	sub	x20, x20, x26
       return ctr_encrypt(pt, ct, len, ctr);
 1132fc4:	17ffffc2 	b	1132ecc <ctr_encrypt+0x38>
   return _ctr_encrypt(pt, ct, len, ctr);
 1132fc8:	aa1303e3 	mov	x3, x19
 1132fcc:	aa1403e2 	mov	x2, x20
 1132fd0:	aa1903e1 	mov	x1, x25
 1132fd4:	aa1503e0 	mov	x0, x21
}
 1132fd8:	a94153f3 	ldp	x19, x20, [sp, #16]
 1132fdc:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1132fe0:	a94363f7 	ldp	x23, x24, [sp, #48]
 1132fe4:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1132fe8:	a8c57bfd 	ldp	x29, x30, [sp], #80
   return _ctr_encrypt(pt, ct, len, ctr);
 1132fec:	17ffff5e 	b	1132d64 <_ctr_encrypt>

0000000001132ff0 <ctr_start>:
                             int  num_rounds, int ctr_mode,
                   symmetric_CTR *ctr)
{
   int x, err;

   LTC_ARGCHK(IV  != NULL);
 1132ff0:	b5000161 	cbnz	x1, 113301c <ctr_start+0x2c>
 1132ff4:	52800200 	mov	w0, #0x10                  	// #16
         }
      }
   }

   return cipher_descriptor[ctr->cipher]->ecb_encrypt(ctr->ctr, ctr->pad, &ctr->key);
}
 1132ff8:	d65f03c0 	ret
   LTC_ARGCHK(IV  != NULL);
 1132ffc:	52800200 	mov	w0, #0x10                  	// #16
}
 1133000:	a94153f3 	ldp	x19, x20, [sp, #16]
 1133004:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1133008:	a94363f7 	ldp	x23, x24, [sp, #48]
 113300c:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1133010:	a94573fb 	ldp	x27, x28, [sp, #80]
 1133014:	a8c77bfd 	ldp	x29, x30, [sp], #112
 1133018:	d65f03c0 	ret
{
 113301c:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
 1133020:	910003fd 	mov	x29, sp
 1133024:	a90153f3 	stp	x19, x20, [sp, #16]
 1133028:	a9025bf5 	stp	x21, x22, [sp, #32]
 113302c:	a90363f7 	stp	x23, x24, [sp, #48]
 1133030:	a9046bf9 	stp	x25, x26, [sp, #64]
 1133034:	aa0203f9 	mov	x25, x2
 1133038:	a90573fb 	stp	x27, x28, [sp, #80]
   LTC_ARGCHK(key != NULL);
 113303c:	b4fffe02 	cbz	x2, 1132ffc <ctr_start+0xc>
 1133040:	aa0603f3 	mov	x19, x6
   LTC_ARGCHK(ctr != NULL);
 1133044:	b4fffdc6 	cbz	x6, 1132ffc <ctr_start+0xc>
 1133048:	2a0003f6 	mov	w22, w0
 113304c:	aa0103f5 	mov	x21, x1
 1133050:	2a0303fa 	mov	w26, w3
 1133054:	2a0403fb 	mov	w27, w4
 1133058:	2a0503f4 	mov	w20, w5
   if ((err = cipher_is_valid(cipher)) != CRYPT_OK) {
 113305c:	97fffcfd 	bl	1132450 <cipher_is_valid>
 1133060:	35fffd00 	cbnz	w0, 1133000 <ctr_start+0x10>
   ctr->ctrlen   = (ctr_mode & 255) ? (ctr_mode & 255) : cipher_descriptor[cipher]->block_length;
 1133064:	f0000120 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1133068:	93407ed8 	sxtw	x24, w22
 113306c:	aa0003f7 	mov	x23, x0
 1133070:	f941c001 	ldr	x1, [x0, #896]
 1133074:	72001e80 	ands	w0, w20, #0xff
 1133078:	f8787821 	ldr	x1, [x1, x24, lsl #3]
 113307c:	b9401425 	ldr	w5, [x1, #20]
 1133080:	1a851000 	csel	w0, w0, w5, ne  // ne = any
 1133084:	b9001260 	str	w0, [x19, #16]
   if (ctr->ctrlen > cipher_descriptor[cipher]->block_length) {
 1133088:	6b05001f 	cmp	w0, w5
 113308c:	54fffb8c 	b.gt	1132ffc <ctr_start+0xc>
   if ((ctr_mode & 0x1000) == CTR_COUNTER_BIG_ENDIAN) {
 1133090:	12140284 	and	w4, w20, #0x1000
 1133094:	36600074 	tbz	w20, #12, 11330a0 <ctr_start+0xb0>
      ctr->ctrlen = cipher_descriptor[cipher]->block_length - ctr->ctrlen;
 1133098:	4b0000a5 	sub	w5, w5, w0
 113309c:	b9001265 	str	w5, [x19, #16]
   if ((err = cipher_descriptor[cipher]->setup(key, keylen, num_rounds, &ctr->key)) != CRYPT_OK) {
 11330a0:	f9401025 	ldr	x5, [x1, #32]
 11330a4:	9104e27c 	add	x28, x19, #0x138
 11330a8:	aa1c03e3 	mov	x3, x28
 11330ac:	2a1b03e2 	mov	w2, w27
 11330b0:	aa1903e0 	mov	x0, x25
 11330b4:	2a1a03e1 	mov	w1, w26
 11330b8:	b9006fe4 	str	w4, [sp, #108]
 11330bc:	d63f00a0 	blr	x5
 11330c0:	35fffa00 	cbnz	w0, 1133000 <ctr_start+0x10>
   ctr->blocklen = cipher_descriptor[cipher]->block_length;
 11330c4:	f941c2e0 	ldr	x0, [x23, #896]
       ctr->ctr[x] = IV[x];
 11330c8:	91005261 	add	x1, x19, #0x14
   ctr->mode     = ctr_mode & 0x1000;
 11330cc:	b9406fe4 	ldr	w4, [sp, #108]
   ctr->blocklen = cipher_descriptor[cipher]->block_length;
 11330d0:	f8787800 	ldr	x0, [x0, x24, lsl #3]
 11330d4:	b9401402 	ldr	w2, [x0, #20]
   for (x = 0; x < ctr->blocklen; x++) {
 11330d8:	d2800000 	mov	x0, #0x0                   	// #0
   ctr->blocklen = cipher_descriptor[cipher]->block_length;
 11330dc:	29000a76 	stp	w22, w2, [x19]
   ctr->mode     = ctr_mode & 0x1000;
 11330e0:	2901127f 	stp	wzr, w4, [x19, #8]
   for (x = 0; x < ctr->blocklen; x++) {
 11330e4:	6b00005f 	cmp	w2, w0
 11330e8:	5400020c 	b.gt	1133128 <ctr_start+0x138>
   if (ctr_mode & LTC_CTR_RFC3686) {
 11330ec:	37680274 	tbnz	w20, #13, 1133138 <ctr_start+0x148>
   return cipher_descriptor[ctr->cipher]->ecb_encrypt(ctr->ctr, ctr->pad, &ctr->key);
 11330f0:	f941c2f7 	ldr	x23, [x23, #896]
 11330f4:	aa1c03e2 	mov	x2, x28
 11330f8:	91029261 	add	x1, x19, #0xa4
}
 11330fc:	a9425bf5 	ldp	x21, x22, [sp, #32]
   return cipher_descriptor[ctr->cipher]->ecb_encrypt(ctr->ctr, ctr->pad, &ctr->key);
 1133100:	f8787ae0 	ldr	x0, [x23, x24, lsl #3]
}
 1133104:	a94363f7 	ldp	x23, x24, [sp, #48]
   return cipher_descriptor[ctr->cipher]->ecb_encrypt(ctr->ctr, ctr->pad, &ctr->key);
 1133108:	f9401403 	ldr	x3, [x0, #40]
 113310c:	91005260 	add	x0, x19, #0x14
}
 1133110:	a94153f3 	ldp	x19, x20, [sp, #16]
   return cipher_descriptor[ctr->cipher]->ecb_encrypt(ctr->ctr, ctr->pad, &ctr->key);
 1133114:	aa0303f0 	mov	x16, x3
}
 1133118:	a9446bf9 	ldp	x25, x26, [sp, #64]
 113311c:	a94573fb 	ldp	x27, x28, [sp, #80]
 1133120:	a8c77bfd 	ldp	x29, x30, [sp], #112
   return cipher_descriptor[ctr->cipher]->ecb_encrypt(ctr->ctr, ctr->pad, &ctr->key);
 1133124:	d61f0200 	br	x16
       ctr->ctr[x] = IV[x];
 1133128:	38606aa3 	ldrb	w3, [x21, x0]
 113312c:	38206823 	strb	w3, [x1, x0]
   for (x = 0; x < ctr->blocklen; x++) {
 1133130:	91000400 	add	x0, x0, #0x1
 1133134:	17ffffec 	b	11330e4 <ctr_start+0xf4>
      if (ctr->mode == CTR_COUNTER_LITTLE_ENDIAN) {
 1133138:	b9401263 	ldr	w3, [x19, #16]
 113313c:	35000184 	cbnz	w4, 113316c <ctr_start+0x17c>
 1133140:	aa1303e1 	mov	x1, x19
         for (x = 0; x < ctr->ctrlen; x++) {
 1133144:	4b130020 	sub	w0, w1, w19
 1133148:	6b03001f 	cmp	w0, w3
 113314c:	54fffd2a 	b.ge	11330f0 <ctr_start+0x100>  // b.tcont
             ctr->ctr[x] = (ctr->ctr[x] + (unsigned char)1) & (unsigned char)255;
 1133150:	39405020 	ldrb	w0, [x1, #20]
 1133154:	91000421 	add	x1, x1, #0x1
 1133158:	11000400 	add	w0, w0, #0x1
 113315c:	12001c00 	and	w0, w0, #0xff
 1133160:	39004c20 	strb	w0, [x1, #19]
             if (ctr->ctr[x] != (unsigned char)0) {
 1133164:	34ffff00 	cbz	w0, 1133144 <ctr_start+0x154>
 1133168:	17ffffe2 	b	11330f0 <ctr_start+0x100>
         for (x = ctr->blocklen-1; x >= ctr->ctrlen; x--) {
 113316c:	51000440 	sub	w0, w2, #0x1
 1133170:	91005262 	add	x2, x19, #0x14
 1133174:	93407c00 	sxtw	x0, w0
 1133178:	6b00007f 	cmp	w3, w0
 113317c:	54fffbac 	b.gt	11330f0 <ctr_start+0x100>
             ctr->ctr[x] = (ctr->ctr[x] + (unsigned char)1) & (unsigned char)255;
 1133180:	38606841 	ldrb	w1, [x2, x0]
 1133184:	11000421 	add	w1, w1, #0x1
 1133188:	12001c21 	and	w1, w1, #0xff
 113318c:	38206841 	strb	w1, [x2, x0]
             if (ctr->ctr[x] != (unsigned char)0) {
 1133190:	d1000400 	sub	x0, x0, #0x1
 1133194:	34ffff21 	cbz	w1, 1133178 <ctr_start+0x188>
 1133198:	17ffffd6 	b	11330f0 <ctr_start+0x100>

000000000113319c <ecb_decrypt>:
  @param len    The number of octets to process (must be multiple of the cipher block size)
  @param ecb    ECB state
  @return CRYPT_OK if successful
*/
int ecb_decrypt(const unsigned char *ct, unsigned char *pt, unsigned long len, symmetric_ECB *ecb)
{
 113319c:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 11331a0:	910003fd 	mov	x29, sp
 11331a4:	a90153f3 	stp	x19, x20, [sp, #16]
 11331a8:	a9025bf5 	stp	x21, x22, [sp, #32]
 11331ac:	a90363f7 	stp	x23, x24, [sp, #48]
 11331b0:	f90023f9 	str	x25, [sp, #64]
   int err;
   LTC_ARGCHK(pt != NULL);
 11331b4:	b5000121 	cbnz	x1, 11331d8 <ecb_decrypt+0x3c>
 11331b8:	52800217 	mov	w23, #0x10                  	// #16
      pt  += cipher_descriptor[ecb->cipher]->block_length;
      ct  += cipher_descriptor[ecb->cipher]->block_length;
      len -= cipher_descriptor[ecb->cipher]->block_length;
   }
   return CRYPT_OK;
}
 11331bc:	2a1703e0 	mov	w0, w23
 11331c0:	a94153f3 	ldp	x19, x20, [sp, #16]
 11331c4:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11331c8:	a94363f7 	ldp	x23, x24, [sp, #48]
 11331cc:	f94023f9 	ldr	x25, [sp, #64]
 11331d0:	a8c57bfd 	ldp	x29, x30, [sp], #80
 11331d4:	d65f03c0 	ret
 11331d8:	aa0003f5 	mov	x21, x0
   LTC_ARGCHK(ct != NULL);
 11331dc:	b4fffee0 	cbz	x0, 11331b8 <ecb_decrypt+0x1c>
 11331e0:	aa0303f3 	mov	x19, x3
   LTC_ARGCHK(ecb != NULL);
 11331e4:	b4fffea3 	cbz	x3, 11331b8 <ecb_decrypt+0x1c>
   if ((err = cipher_is_valid(ecb->cipher)) != CRYPT_OK) {
 11331e8:	b9400060 	ldr	w0, [x3]
 11331ec:	aa0103f6 	mov	x22, x1
 11331f0:	aa0203f4 	mov	x20, x2
 11331f4:	97fffc97 	bl	1132450 <cipher_is_valid>
 11331f8:	2a0003f7 	mov	w23, w0
 11331fc:	35fffe00 	cbnz	w0, 11331bc <ecb_decrypt+0x20>
   if (len % cipher_descriptor[ecb->cipher]->block_length) {
 1133200:	f0000120 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1133204:	f941c018 	ldr	x24, [x0, #896]
 1133208:	b9800260 	ldrsw	x0, [x19]
 113320c:	f8607b01 	ldr	x1, [x24, x0, lsl #3]
 1133210:	b9801420 	ldrsw	x0, [x1, #20]
 1133214:	9ac00a82 	udiv	x2, x20, x0
 1133218:	9b00d040 	msub	x0, x2, x0, x20
 113321c:	b5fffce0 	cbnz	x0, 11331b8 <ecb_decrypt+0x1c>
   if (cipher_descriptor[ecb->cipher]->accel_ecb_decrypt != NULL) {
 1133220:	f9402c24 	ldr	x4, [x1, #88]
 1133224:	b5000244 	cbnz	x4, 113326c <ecb_decrypt+0xd0>
      if ((err = cipher_descriptor[ecb->cipher]->ecb_decrypt(ct, pt, &ecb->key)) != CRYPT_OK) {
 1133228:	91002279 	add	x25, x19, #0x8
   while (len) {
 113322c:	b4fffc94 	cbz	x20, 11331bc <ecb_decrypt+0x20>
      if ((err = cipher_descriptor[ecb->cipher]->ecb_decrypt(ct, pt, &ecb->key)) != CRYPT_OK) {
 1133230:	b9800260 	ldrsw	x0, [x19]
 1133234:	aa1903e2 	mov	x2, x25
 1133238:	aa1603e1 	mov	x1, x22
 113323c:	f8607b00 	ldr	x0, [x24, x0, lsl #3]
 1133240:	f9401803 	ldr	x3, [x0, #48]
 1133244:	aa1503e0 	mov	x0, x21
 1133248:	d63f0060 	blr	x3
 113324c:	35000240 	cbnz	w0, 1133294 <ecb_decrypt+0xf8>
      pt  += cipher_descriptor[ecb->cipher]->block_length;
 1133250:	b9800260 	ldrsw	x0, [x19]
 1133254:	f8607b00 	ldr	x0, [x24, x0, lsl #3]
 1133258:	b9801400 	ldrsw	x0, [x0, #20]
 113325c:	8b0002d6 	add	x22, x22, x0
      ct  += cipher_descriptor[ecb->cipher]->block_length;
 1133260:	8b0002b5 	add	x21, x21, x0
      len -= cipher_descriptor[ecb->cipher]->block_length;
 1133264:	cb000294 	sub	x20, x20, x0
 1133268:	17fffff1 	b	113322c <ecb_decrypt+0x90>
      return cipher_descriptor[ecb->cipher]->accel_ecb_decrypt(ct, pt, len / cipher_descriptor[ecb->cipher]->block_length, &ecb->key);
 113326c:	91002263 	add	x3, x19, #0x8
 1133270:	aa1603e1 	mov	x1, x22
 1133274:	aa1503e0 	mov	x0, x21
 1133278:	aa0403f0 	mov	x16, x4
}
 113327c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1133280:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1133284:	a94363f7 	ldp	x23, x24, [sp, #48]
 1133288:	f94023f9 	ldr	x25, [sp, #64]
 113328c:	a8c57bfd 	ldp	x29, x30, [sp], #80
      return cipher_descriptor[ecb->cipher]->accel_ecb_decrypt(ct, pt, len / cipher_descriptor[ecb->cipher]->block_length, &ecb->key);
 1133290:	d61f0200 	br	x16
      if ((err = cipher_descriptor[ecb->cipher]->ecb_decrypt(ct, pt, &ecb->key)) != CRYPT_OK) {
 1133294:	2a0003f7 	mov	w23, w0
 1133298:	17ffffc9 	b	11331bc <ecb_decrypt+0x20>

000000000113329c <ecb_done>:
/** Terminate the chain
  @param ecb    The ECB chain to terminate
  @return CRYPT_OK on success
*/
int ecb_done(symmetric_ECB *ecb)
{
 113329c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 11332a0:	910003fd 	mov	x29, sp
 11332a4:	a90153f3 	stp	x19, x20, [sp, #16]
   int err;
   LTC_ARGCHK(ecb != NULL);
 11332a8:	b4000220 	cbz	x0, 11332ec <ecb_done+0x50>
 11332ac:	aa0003f3 	mov	x19, x0

   if ((err = cipher_is_valid(ecb->cipher)) != CRYPT_OK) {
 11332b0:	b9400000 	ldr	w0, [x0]
 11332b4:	97fffc67 	bl	1132450 <cipher_is_valid>
 11332b8:	2a0003f4 	mov	w20, w0
 11332bc:	35000100 	cbnz	w0, 11332dc <ecb_done+0x40>
      return err;
   }
   cipher_descriptor[ecb->cipher]->done(&ecb->key);
 11332c0:	aa1303e0 	mov	x0, x19
 11332c4:	f0000121 	adrp	x1, 115a000 <__scattered_array_1phys_mem_map+0x8>
 11332c8:	f941c021 	ldr	x1, [x1, #896]
 11332cc:	b8808402 	ldrsw	x2, [x0], #8
 11332d0:	f8627821 	ldr	x1, [x1, x2, lsl #3]
 11332d4:	f9402021 	ldr	x1, [x1, #64]
 11332d8:	d63f0020 	blr	x1
   return CRYPT_OK;
}
 11332dc:	2a1403e0 	mov	w0, w20
 11332e0:	a94153f3 	ldp	x19, x20, [sp, #16]
 11332e4:	a8c27bfd 	ldp	x29, x30, [sp], #32
 11332e8:	d65f03c0 	ret
   LTC_ARGCHK(ecb != NULL);
 11332ec:	52800214 	mov	w20, #0x10                  	// #16
 11332f0:	17fffffb 	b	11332dc <ecb_done+0x40>

00000000011332f4 <ecb_encrypt>:
  @param len    The number of octets to process (must be multiple of the cipher block size)
  @param ecb    ECB state
  @return CRYPT_OK if successful
*/
int ecb_encrypt(const unsigned char *pt, unsigned char *ct, unsigned long len, symmetric_ECB *ecb)
{
 11332f4:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 11332f8:	910003fd 	mov	x29, sp
 11332fc:	a90153f3 	stp	x19, x20, [sp, #16]
 1133300:	a9025bf5 	stp	x21, x22, [sp, #32]
 1133304:	a90363f7 	stp	x23, x24, [sp, #48]
 1133308:	f90023f9 	str	x25, [sp, #64]
   int err;
   LTC_ARGCHK(pt != NULL);
 113330c:	b5000120 	cbnz	x0, 1133330 <ecb_encrypt+0x3c>
 1133310:	52800217 	mov	w23, #0x10                  	// #16
      pt  += cipher_descriptor[ecb->cipher]->block_length;
      ct  += cipher_descriptor[ecb->cipher]->block_length;
      len -= cipher_descriptor[ecb->cipher]->block_length;
   }
   return CRYPT_OK;
}
 1133314:	2a1703e0 	mov	w0, w23
 1133318:	a94153f3 	ldp	x19, x20, [sp, #16]
 113331c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1133320:	a94363f7 	ldp	x23, x24, [sp, #48]
 1133324:	f94023f9 	ldr	x25, [sp, #64]
 1133328:	a8c57bfd 	ldp	x29, x30, [sp], #80
 113332c:	d65f03c0 	ret
 1133330:	aa0103f6 	mov	x22, x1
   LTC_ARGCHK(ct != NULL);
 1133334:	b4fffee1 	cbz	x1, 1133310 <ecb_encrypt+0x1c>
 1133338:	aa0303f3 	mov	x19, x3
   LTC_ARGCHK(ecb != NULL);
 113333c:	b4fffea3 	cbz	x3, 1133310 <ecb_encrypt+0x1c>
 1133340:	aa0003f5 	mov	x21, x0
   if ((err = cipher_is_valid(ecb->cipher)) != CRYPT_OK) {
 1133344:	b9400060 	ldr	w0, [x3]
 1133348:	aa0203f4 	mov	x20, x2
 113334c:	97fffc41 	bl	1132450 <cipher_is_valid>
 1133350:	2a0003f7 	mov	w23, w0
 1133354:	35fffe00 	cbnz	w0, 1133314 <ecb_encrypt+0x20>
   if (len % cipher_descriptor[ecb->cipher]->block_length) {
 1133358:	f0000120 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 113335c:	f941c018 	ldr	x24, [x0, #896]
 1133360:	b9800260 	ldrsw	x0, [x19]
 1133364:	f8607b01 	ldr	x1, [x24, x0, lsl #3]
 1133368:	b9801420 	ldrsw	x0, [x1, #20]
 113336c:	9ac00a82 	udiv	x2, x20, x0
 1133370:	9b00d040 	msub	x0, x2, x0, x20
 1133374:	b5fffce0 	cbnz	x0, 1133310 <ecb_encrypt+0x1c>
   if (cipher_descriptor[ecb->cipher]->accel_ecb_encrypt != NULL) {
 1133378:	f9402824 	ldr	x4, [x1, #80]
 113337c:	b5000244 	cbnz	x4, 11333c4 <ecb_encrypt+0xd0>
      if ((err = cipher_descriptor[ecb->cipher]->ecb_encrypt(pt, ct, &ecb->key)) != CRYPT_OK) {
 1133380:	91002279 	add	x25, x19, #0x8
   while (len) {
 1133384:	b4fffc94 	cbz	x20, 1133314 <ecb_encrypt+0x20>
      if ((err = cipher_descriptor[ecb->cipher]->ecb_encrypt(pt, ct, &ecb->key)) != CRYPT_OK) {
 1133388:	b9800260 	ldrsw	x0, [x19]
 113338c:	aa1903e2 	mov	x2, x25
 1133390:	aa1603e1 	mov	x1, x22
 1133394:	f8607b00 	ldr	x0, [x24, x0, lsl #3]
 1133398:	f9401403 	ldr	x3, [x0, #40]
 113339c:	aa1503e0 	mov	x0, x21
 11333a0:	d63f0060 	blr	x3
 11333a4:	35000240 	cbnz	w0, 11333ec <ecb_encrypt+0xf8>
      pt  += cipher_descriptor[ecb->cipher]->block_length;
 11333a8:	b9800260 	ldrsw	x0, [x19]
 11333ac:	f8607b00 	ldr	x0, [x24, x0, lsl #3]
 11333b0:	b9801400 	ldrsw	x0, [x0, #20]
 11333b4:	8b0002b5 	add	x21, x21, x0
      ct  += cipher_descriptor[ecb->cipher]->block_length;
 11333b8:	8b0002d6 	add	x22, x22, x0
      len -= cipher_descriptor[ecb->cipher]->block_length;
 11333bc:	cb000294 	sub	x20, x20, x0
 11333c0:	17fffff1 	b	1133384 <ecb_encrypt+0x90>
      return cipher_descriptor[ecb->cipher]->accel_ecb_encrypt(pt, ct, len / cipher_descriptor[ecb->cipher]->block_length, &ecb->key);
 11333c4:	91002263 	add	x3, x19, #0x8
 11333c8:	aa1603e1 	mov	x1, x22
 11333cc:	aa1503e0 	mov	x0, x21
 11333d0:	aa0403f0 	mov	x16, x4
}
 11333d4:	a94153f3 	ldp	x19, x20, [sp, #16]
 11333d8:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11333dc:	a94363f7 	ldp	x23, x24, [sp, #48]
 11333e0:	f94023f9 	ldr	x25, [sp, #64]
 11333e4:	a8c57bfd 	ldp	x29, x30, [sp], #80
      return cipher_descriptor[ecb->cipher]->accel_ecb_encrypt(pt, ct, len / cipher_descriptor[ecb->cipher]->block_length, &ecb->key);
 11333e8:	d61f0200 	br	x16
      if ((err = cipher_descriptor[ecb->cipher]->ecb_encrypt(pt, ct, &ecb->key)) != CRYPT_OK) {
 11333ec:	2a0003f7 	mov	w23, w0
 11333f0:	17ffffc9 	b	1133314 <ecb_encrypt+0x20>

00000000011333f4 <ecb_start>:
   @return CRYPT_OK if successful
*/
int ecb_start(int cipher, const unsigned char *key, int keylen, int num_rounds, symmetric_ECB *ecb)
{
   int err;
   LTC_ARGCHK(key != NULL);
 11333f4:	b40003c1 	cbz	x1, 113346c <ecb_start+0x78>
{
 11333f8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 11333fc:	910003fd 	mov	x29, sp
 1133400:	a90153f3 	stp	x19, x20, [sp, #16]
 1133404:	aa0403f3 	mov	x19, x4
 1133408:	a9025bf5 	stp	x21, x22, [sp, #32]
 113340c:	f9001bf7 	str	x23, [sp, #48]
   LTC_ARGCHK(ecb != NULL);
 1133410:	b4000324 	cbz	x4, 1133474 <ecb_start+0x80>
 1133414:	2a0003f5 	mov	w21, w0
 1133418:	aa0103f4 	mov	x20, x1
 113341c:	2a0203f6 	mov	w22, w2
 1133420:	2a0303f7 	mov	w23, w3

   if ((err = cipher_is_valid(cipher)) != CRYPT_OK) {
 1133424:	97fffc0b 	bl	1132450 <cipher_is_valid>
 1133428:	35000280 	cbnz	w0, 1133478 <ecb_start+0x84>
      return err;
   }
   ecb->cipher = cipher;
   ecb->blocklen = cipher_descriptor[cipher]->block_length;
 113342c:	f0000120 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
   return cipher_descriptor[cipher]->setup(key, keylen, num_rounds, &ecb->key);
 1133430:	2a1703e2 	mov	w2, w23
}
 1133434:	f9401bf7 	ldr	x23, [sp, #48]
   return cipher_descriptor[cipher]->setup(key, keylen, num_rounds, &ecb->key);
 1133438:	91002263 	add	x3, x19, #0x8
   ecb->blocklen = cipher_descriptor[cipher]->block_length;
 113343c:	f941c000 	ldr	x0, [x0, #896]
 1133440:	f875d800 	ldr	x0, [x0, w21, sxtw #3]
 1133444:	b9401401 	ldr	w1, [x0, #20]
   return cipher_descriptor[cipher]->setup(key, keylen, num_rounds, &ecb->key);
 1133448:	f9401004 	ldr	x4, [x0, #32]
   ecb->blocklen = cipher_descriptor[cipher]->block_length;
 113344c:	29000675 	stp	w21, w1, [x19]
   return cipher_descriptor[cipher]->setup(key, keylen, num_rounds, &ecb->key);
 1133450:	aa1403e0 	mov	x0, x20
 1133454:	2a1603e1 	mov	w1, w22
}
 1133458:	a94153f3 	ldp	x19, x20, [sp, #16]
   return cipher_descriptor[cipher]->setup(key, keylen, num_rounds, &ecb->key);
 113345c:	aa0403f0 	mov	x16, x4
}
 1133460:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1133464:	a8c47bfd 	ldp	x29, x30, [sp], #64
   return cipher_descriptor[cipher]->setup(key, keylen, num_rounds, &ecb->key);
 1133468:	d61f0200 	br	x16
   LTC_ARGCHK(key != NULL);
 113346c:	52800200 	mov	w0, #0x10                  	// #16
}
 1133470:	d65f03c0 	ret
   LTC_ARGCHK(key != NULL);
 1133474:	52800200 	mov	w0, #0x10                  	// #16
}
 1133478:	a94153f3 	ldp	x19, x20, [sp, #16]
 113347c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1133480:	f9401bf7 	ldr	x23, [sp, #48]
 1133484:	a8c47bfd 	ldp	x29, x30, [sp], #64
 1133488:	d65f03c0 	ret

000000000113348c <_tweak_uncrypt>:
 */

#ifdef LTC_XTS_MODE

static int _tweak_uncrypt(const unsigned char *C, unsigned char *P, unsigned char *T, const symmetric_xts *xts)
{
 113348c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1133490:	910003fd 	mov	x29, sp
 1133494:	a90153f3 	stp	x19, x20, [sp, #16]
 1133498:	aa0203f4 	mov	x20, x2
 113349c:	aa0303e2 	mov	x2, x3
 11334a0:	aa0103f3 	mov	x19, x1
#ifdef LTC_FAST
   for (x = 0; x < 16; x += sizeof(LTC_FAST_TYPE)) {
      *(LTC_FAST_TYPE_PTR_CAST(&P[x])) = *(LTC_FAST_TYPE_PTR_CAST(&C[x])) ^ *(LTC_FAST_TYPE_PTR_CAST(&T[x]));
   }
#else
   for (x = 0; x < 16; x++) {
 11334a4:	d2800001 	mov	x1, #0x0                   	// #0
{
 11334a8:	f90013f5 	str	x21, [sp, #32]
      P[x] = C[x] ^ T[x];
 11334ac:	38616803 	ldrb	w3, [x0, x1]
 11334b0:	38616a84 	ldrb	w4, [x20, x1]
 11334b4:	4a040063 	eor	w3, w3, w4
 11334b8:	38216a63 	strb	w3, [x19, x1]
   for (x = 0; x < 16; x++) {
 11334bc:	91000421 	add	x1, x1, #0x1
 11334c0:	f100403f 	cmp	x1, #0x10
 11334c4:	54ffff41 	b.ne	11334ac <_tweak_uncrypt+0x20>  // b.any
   }
#endif

   err = cipher_descriptor[xts->cipher]->ecb_decrypt(P, P, &xts->key1);
 11334c8:	f0000120 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 11334cc:	b9860041 	ldrsw	x1, [x2, #1536]
 11334d0:	f941c000 	ldr	x0, [x0, #896]
 11334d4:	f8617800 	ldr	x0, [x0, x1, lsl #3]
 11334d8:	aa1303e1 	mov	x1, x19
 11334dc:	f9401803 	ldr	x3, [x0, #48]
 11334e0:	aa1303e0 	mov	x0, x19
 11334e4:	d63f0060 	blr	x3
 11334e8:	2a0003f5 	mov	w21, w0
#ifdef LTC_FAST
   for (x = 0; x < 16; x += sizeof(LTC_FAST_TYPE)) {
      *(LTC_FAST_TYPE_PTR_CAST(&P[x])) ^= *(LTC_FAST_TYPE_PTR_CAST(&T[x]));
   }
#else
   for (x = 0; x < 16; x++) {
 11334ec:	d2800001 	mov	x1, #0x0                   	// #0
      P[x] = P[x] ^ T[x];
 11334f0:	38616a60 	ldrb	w0, [x19, x1]
 11334f4:	38616a82 	ldrb	w2, [x20, x1]
 11334f8:	4a020000 	eor	w0, w0, w2
 11334fc:	38216a60 	strb	w0, [x19, x1]
   for (x = 0; x < 16; x++) {
 1133500:	91000421 	add	x1, x1, #0x1
 1133504:	f100403f 	cmp	x1, #0x10
 1133508:	54ffff41 	b.ne	11334f0 <_tweak_uncrypt+0x64>  // b.any
   }
#endif

   /* LFSR the tweak */
   xts_mult_x(T);
 113350c:	aa1403e0 	mov	x0, x20
 1133510:	94000162 	bl	1133a98 <xts_mult_x>

   return err;
}
 1133514:	2a1503e0 	mov	w0, w21
 1133518:	a94153f3 	ldp	x19, x20, [sp, #16]
 113351c:	f94013f5 	ldr	x21, [sp, #32]
 1133520:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1133524:	d65f03c0 	ret

0000000001133528 <xts_decrypt>:
   unsigned char PP[16], CC[16], T[16];
   unsigned long i, m, mo, lim;
   int err;

   /* check inputs */
   LTC_ARGCHK(pt != NULL);
 1133528:	b5000162 	cbnz	x2, 1133554 <xts_decrypt+0x2c>
 113352c:	52800200 	mov	w0, #0x10                  	// #16
   if ((err = cipher_descriptor[xts->cipher]->ecb_decrypt(T, tweak, &xts->key2)) != CRYPT_OK) {
      return err;
   }

   return CRYPT_OK;
}
 1133530:	d65f03c0 	ret
   LTC_ARGCHK(pt != NULL);
 1133534:	52800200 	mov	w0, #0x10                  	// #16
}
 1133538:	a94153f3 	ldp	x19, x20, [sp, #16]
 113353c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1133540:	a94363f7 	ldp	x23, x24, [sp, #48]
 1133544:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1133548:	f9402bfb 	ldr	x27, [sp, #80]
 113354c:	a8c97bfd 	ldp	x29, x30, [sp], #144
 1133550:	d65f03c0 	ret
{
 1133554:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
 1133558:	910003fd 	mov	x29, sp
 113355c:	a90153f3 	stp	x19, x20, [sp, #16]
 1133560:	a9025bf5 	stp	x21, x22, [sp, #32]
 1133564:	a90363f7 	stp	x23, x24, [sp, #48]
 1133568:	aa0003f7 	mov	x23, x0
 113356c:	a9046bf9 	stp	x25, x26, [sp, #64]
 1133570:	f9002bfb 	str	x27, [sp, #80]
   LTC_ARGCHK(ct != NULL);
 1133574:	b4fffe00 	cbz	x0, 1133534 <xts_decrypt+0xc>
 1133578:	aa0303f5 	mov	x21, x3
   LTC_ARGCHK(tweak != NULL);
 113357c:	b4fffdc3 	cbz	x3, 1133534 <xts_decrypt+0xc>
 1133580:	aa0403f4 	mov	x20, x4
   LTC_ARGCHK(xts != NULL);
 1133584:	b4fffd84 	cbz	x4, 1133534 <xts_decrypt+0xc>
   if ((err = cipher_is_valid(xts->cipher)) != CRYPT_OK) {
 1133588:	b9460080 	ldr	w0, [x4, #1536]
 113358c:	aa0103f6 	mov	x22, x1
 1133590:	aa0203f3 	mov	x19, x2
 1133594:	97fffbaf 	bl	1132450 <cipher_is_valid>
 1133598:	35fffd00 	cbnz	w0, 1133538 <xts_decrypt+0x10>
   m = ptlen >> 4;
 113359c:	d344feda 	lsr	x26, x22, #4
   mo = ptlen & 15;
 11335a0:	92400ed8 	and	x24, x22, #0xf
   if (m == 0) {
 11335a4:	eb5613ff 	cmp	xzr, x22, lsr #4
 11335a8:	54fffc60 	b.eq	1133534 <xts_decrypt+0xc>  // b.none
      lim = m - 1;
 11335ac:	f100031f 	cmp	x24, #0x0
   if (cipher_descriptor[xts->cipher]->accel_xts_decrypt && lim > 0) {
 11335b0:	b9860281 	ldrsw	x1, [x20, #1536]
      lim = m - 1;
 11335b4:	9a9f07e0 	cset	x0, ne  // ne = any
 11335b8:	910c0296 	add	x22, x20, #0x300
 11335bc:	cb00035a 	sub	x26, x26, x0
   if (cipher_descriptor[xts->cipher]->accel_xts_decrypt && lim > 0) {
 11335c0:	f0000120 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 11335c4:	f941c000 	ldr	x0, [x0, #896]
 11335c8:	f8617800 	ldr	x0, [x0, x1, lsl #3]
 11335cc:	f9405c06 	ldr	x6, [x0, #184]
 11335d0:	b4000366 	cbz	x6, 113363c <xts_decrypt+0x114>
 11335d4:	b400035a 	cbz	x26, 113363c <xts_decrypt+0x114>
      if ((err = cipher_descriptor[xts->cipher]->accel_xts_decrypt(ct, pt, lim, tweak, &xts->key1, &xts->key2)) !=
 11335d8:	aa1603e5 	mov	x5, x22
 11335dc:	aa1403e4 	mov	x4, x20
 11335e0:	aa1503e3 	mov	x3, x21
 11335e4:	aa1a03e2 	mov	x2, x26
 11335e8:	aa1303e1 	mov	x1, x19
 11335ec:	aa1703e0 	mov	x0, x23
 11335f0:	d63f00c0 	blr	x6
 11335f4:	35fffa20 	cbnz	w0, 1133538 <xts_decrypt+0x10>
      ct += lim * 16;
 11335f8:	8b1a12f9 	add	x25, x23, x26, lsl #4
      pt += lim * 16;
 11335fc:	8b1a1273 	add	x19, x19, x26, lsl #4
      XMEMCPY(T, tweak, sizeof(T));
 1133600:	aa1503e1 	mov	x1, x21
 1133604:	910203e0 	add	x0, sp, #0x80
 1133608:	d2800202 	mov	x2, #0x10                  	// #16
 113360c:	97ff3f61 	bl	1103390 <memcpy>
   if (mo > 0) {
 1133610:	b50003d8 	cbnz	x24, 1133688 <xts_decrypt+0x160>
   if ((err = cipher_descriptor[xts->cipher]->ecb_decrypt(T, tweak, &xts->key2)) != CRYPT_OK) {
 1133614:	f0000120 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1133618:	b9860281 	ldrsw	x1, [x20, #1536]
 113361c:	aa1603e2 	mov	x2, x22
 1133620:	f941c000 	ldr	x0, [x0, #896]
 1133624:	f8617800 	ldr	x0, [x0, x1, lsl #3]
 1133628:	aa1503e1 	mov	x1, x21
 113362c:	f9401803 	ldr	x3, [x0, #48]
 1133630:	910203e0 	add	x0, sp, #0x80
 1133634:	d63f0060 	blr	x3
 1133638:	17ffffc0 	b	1133538 <xts_decrypt+0x10>
      if ((err = cipher_descriptor[xts->cipher]->ecb_encrypt(tweak, T, &xts->key2)) != CRYPT_OK) {
 113363c:	f9401403 	ldr	x3, [x0, #40]
 1133640:	910203fb 	add	x27, sp, #0x80
 1133644:	aa1603e2 	mov	x2, x22
 1133648:	aa1b03e1 	mov	x1, x27
 113364c:	aa1503e0 	mov	x0, x21
 1133650:	d63f0060 	blr	x3
 1133654:	35fff720 	cbnz	w0, 1133538 <xts_decrypt+0x10>
 1133658:	8b1a12f9 	add	x25, x23, x26, lsl #4
      for (i = 0; i < lim; i++) {
 113365c:	eb1902ff 	cmp	x23, x25
 1133660:	54fffd80 	b.eq	1133610 <xts_decrypt+0xe8>  // b.none
         if ((err = _tweak_uncrypt(ct, pt, T, xts)) != CRYPT_OK) {
 1133664:	aa1403e3 	mov	x3, x20
 1133668:	aa1b03e2 	mov	x2, x27
 113366c:	aa1303e1 	mov	x1, x19
 1133670:	aa1703e0 	mov	x0, x23
 1133674:	97ffff86 	bl	113348c <_tweak_uncrypt>
 1133678:	35fff600 	cbnz	w0, 1133538 <xts_decrypt+0x10>
         ct += 16;
 113367c:	910042f7 	add	x23, x23, #0x10
         pt += 16;
 1133680:	91004273 	add	x19, x19, #0x10
      for (i = 0; i < lim; i++) {
 1133684:	17fffff6 	b	113365c <xts_decrypt+0x134>
      XMEMCPY(CC, T, 16);
 1133688:	a94807e0 	ldp	x0, x1, [sp, #128]
      xts_mult_x(CC);
 113368c:	9101c3f7 	add	x23, sp, #0x70
      if ((err = _tweak_uncrypt(ct, PP, CC, xts)) != CRYPT_OK) {
 1133690:	910183fa 	add	x26, sp, #0x60
      XMEMCPY(CC, T, 16);
 1133694:	a90707e0 	stp	x0, x1, [sp, #112]
      xts_mult_x(CC);
 1133698:	aa1703e0 	mov	x0, x23
 113369c:	940000ff 	bl	1133a98 <xts_mult_x>
      if ((err = _tweak_uncrypt(ct, PP, CC, xts)) != CRYPT_OK) {
 11336a0:	aa1403e3 	mov	x3, x20
 11336a4:	aa1703e2 	mov	x2, x23
 11336a8:	aa1a03e1 	mov	x1, x26
 11336ac:	aa1903e0 	mov	x0, x25
 11336b0:	97ffff77 	bl	113348c <_tweak_uncrypt>
 11336b4:	35fff420 	cbnz	w0, 1133538 <xts_decrypt+0x10>
         CC[i] = ct[16 + i];
 11336b8:	91004339 	add	x25, x25, #0x10
         pt[16 + i] = PP[i];
 11336bc:	91004261 	add	x1, x19, #0x10
      for (i = 0; i < mo; i++) {
 11336c0:	d2800000 	mov	x0, #0x0                   	// #0
         CC[i] = ct[16 + i];
 11336c4:	38606b22 	ldrb	w2, [x25, x0]
 11336c8:	38206ae2 	strb	w2, [x23, x0]
         pt[16 + i] = PP[i];
 11336cc:	38606b42 	ldrb	w2, [x26, x0]
 11336d0:	38206822 	strb	w2, [x1, x0]
      for (i = 0; i < mo; i++) {
 11336d4:	91000400 	add	x0, x0, #0x1
 11336d8:	eb00031f 	cmp	x24, x0
 11336dc:	54ffff41 	b.ne	11336c4 <xts_decrypt+0x19c>  // b.any
         CC[i] = PP[i];
 11336e0:	38786b40 	ldrb	w0, [x26, x24]
 11336e4:	38386ae0 	strb	w0, [x23, x24]
      for (; i < 16; i++) {
 11336e8:	91000718 	add	x24, x24, #0x1
 11336ec:	f100431f 	cmp	x24, #0x10
 11336f0:	54ffff81 	b.ne	11336e0 <xts_decrypt+0x1b8>  // b.any
      if ((err = _tweak_uncrypt(CC, pt, T, xts)) != CRYPT_OK) {
 11336f4:	aa1403e3 	mov	x3, x20
 11336f8:	910203e2 	add	x2, sp, #0x80
 11336fc:	aa1303e1 	mov	x1, x19
 1133700:	aa1703e0 	mov	x0, x23
 1133704:	97ffff62 	bl	113348c <_tweak_uncrypt>
 1133708:	34fff860 	cbz	w0, 1133614 <xts_decrypt+0xec>
 113370c:	17ffff8b 	b	1133538 <xts_decrypt+0x10>

0000000001133710 <xts_done>:
/** Terminate XTS state
   @param xts    The state to terminate
*/
void xts_done(symmetric_xts *xts)
{
   LTC_ARGCHKVD(xts != NULL);
 1133710:	b4000260 	cbz	x0, 113375c <xts_done+0x4c>
{
 1133714:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1133718:	910003fd 	mov	x29, sp
 113371c:	a90153f3 	stp	x19, x20, [sp, #16]
   cipher_descriptor[xts->cipher]->done(&xts->key1);
 1133720:	f0000134 	adrp	x20, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1133724:	b9860001 	ldrsw	x1, [x0, #1536]
 1133728:	f941c294 	ldr	x20, [x20, #896]
 113372c:	aa0003f3 	mov	x19, x0
 1133730:	f8617a81 	ldr	x1, [x20, x1, lsl #3]
 1133734:	f9402021 	ldr	x1, [x1, #64]
 1133738:	d63f0020 	blr	x1
   cipher_descriptor[xts->cipher]->done(&xts->key2);
 113373c:	b9860260 	ldrsw	x0, [x19, #1536]
 1133740:	f8607a80 	ldr	x0, [x20, x0, lsl #3]
 1133744:	f9402001 	ldr	x1, [x0, #64]
 1133748:	910c0260 	add	x0, x19, #0x300
}
 113374c:	a94153f3 	ldp	x19, x20, [sp, #16]
   cipher_descriptor[xts->cipher]->done(&xts->key2);
 1133750:	aa0103f0 	mov	x16, x1
}
 1133754:	a8c27bfd 	ldp	x29, x30, [sp], #32
   cipher_descriptor[xts->cipher]->done(&xts->key2);
 1133758:	d61f0200 	br	x16
 113375c:	d65f03c0 	ret

0000000001133760 <_tweak_crypt>:
 */

#ifdef LTC_XTS_MODE

static int _tweak_crypt(const unsigned char *P, unsigned char *C, unsigned char *T, const symmetric_xts *xts)
{
 1133760:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1133764:	910003fd 	mov	x29, sp
 1133768:	a90153f3 	stp	x19, x20, [sp, #16]
 113376c:	aa0203f4 	mov	x20, x2
 1133770:	aa0303e2 	mov	x2, x3
 1133774:	aa0103f3 	mov	x19, x1
#ifdef LTC_FAST
   for (x = 0; x < 16; x += sizeof(LTC_FAST_TYPE)) {
      *(LTC_FAST_TYPE_PTR_CAST(&C[x])) = *(LTC_FAST_TYPE_PTR_CAST(&P[x])) ^ *(LTC_FAST_TYPE_PTR_CAST(&T[x]));
   }
#else
   for (x = 0; x < 16; x++) {
 1133778:	d2800001 	mov	x1, #0x0                   	// #0
{
 113377c:	f90013f5 	str	x21, [sp, #32]
      C[x] = P[x] ^ T[x];
 1133780:	38616803 	ldrb	w3, [x0, x1]
 1133784:	38616a84 	ldrb	w4, [x20, x1]
 1133788:	4a040063 	eor	w3, w3, w4
 113378c:	38216a63 	strb	w3, [x19, x1]
   for (x = 0; x < 16; x++) {
 1133790:	91000421 	add	x1, x1, #0x1
 1133794:	f100403f 	cmp	x1, #0x10
 1133798:	54ffff41 	b.ne	1133780 <_tweak_crypt+0x20>  // b.any
   }
#endif

   if ((err = cipher_descriptor[xts->cipher]->ecb_encrypt(C, C, &xts->key1)) != CRYPT_OK) {
 113379c:	f0000120 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 11337a0:	b9860041 	ldrsw	x1, [x2, #1536]
 11337a4:	f941c000 	ldr	x0, [x0, #896]
 11337a8:	f8617800 	ldr	x0, [x0, x1, lsl #3]
 11337ac:	aa1303e1 	mov	x1, x19
 11337b0:	f9401403 	ldr	x3, [x0, #40]
 11337b4:	aa1303e0 	mov	x0, x19
 11337b8:	d63f0060 	blr	x3
 11337bc:	2a0003f5 	mov	w21, w0
 11337c0:	35000160 	cbnz	w0, 11337ec <_tweak_crypt+0x8c>
#ifdef LTC_FAST
   for (x = 0; x < 16; x += sizeof(LTC_FAST_TYPE)) {
      *(LTC_FAST_TYPE_PTR_CAST(&C[x])) ^= *(LTC_FAST_TYPE_PTR_CAST(&T[x]));
   }
#else
   for (x = 0; x < 16; x++) {
 11337c4:	d2800001 	mov	x1, #0x0                   	// #0
      C[x] = C[x] ^ T[x];
 11337c8:	38616a60 	ldrb	w0, [x19, x1]
 11337cc:	38616a82 	ldrb	w2, [x20, x1]
 11337d0:	4a020000 	eor	w0, w0, w2
 11337d4:	38216a60 	strb	w0, [x19, x1]
   for (x = 0; x < 16; x++) {
 11337d8:	91000421 	add	x1, x1, #0x1
 11337dc:	f100403f 	cmp	x1, #0x10
 11337e0:	54ffff41 	b.ne	11337c8 <_tweak_crypt+0x68>  // b.any
   }
#endif

   /* LFSR the tweak */
   xts_mult_x(T);
 11337e4:	aa1403e0 	mov	x0, x20
 11337e8:	940000ac 	bl	1133a98 <xts_mult_x>

   return CRYPT_OK;
}
 11337ec:	2a1503e0 	mov	w0, w21
 11337f0:	a94153f3 	ldp	x19, x20, [sp, #16]
 11337f4:	f94013f5 	ldr	x21, [sp, #32]
 11337f8:	a8c37bfd 	ldp	x29, x30, [sp], #48
 11337fc:	d65f03c0 	ret

0000000001133800 <xts_encrypt>:
   unsigned char PP[16], CC[16], T[16];
   unsigned long i, m, mo, lim;
   int err;

   /* check inputs */
   LTC_ARGCHK(pt != NULL);
 1133800:	b5000140 	cbnz	x0, 1133828 <xts_encrypt+0x28>
 1133804:	52800200 	mov	w0, #0x10                  	// #16
   if ((err = cipher_descriptor[xts->cipher]->ecb_decrypt(T, tweak, &xts->key2)) != CRYPT_OK) {
      return err;
   }

   return err;
}
 1133808:	d65f03c0 	ret
   LTC_ARGCHK(pt != NULL);
 113380c:	52800200 	mov	w0, #0x10                  	// #16
}
 1133810:	a94153f3 	ldp	x19, x20, [sp, #16]
 1133814:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1133818:	a94363f7 	ldp	x23, x24, [sp, #48]
 113381c:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1133820:	a8c87bfd 	ldp	x29, x30, [sp], #128
 1133824:	d65f03c0 	ret
{
 1133828:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
 113382c:	910003fd 	mov	x29, sp
 1133830:	a90153f3 	stp	x19, x20, [sp, #16]
 1133834:	a9025bf5 	stp	x21, x22, [sp, #32]
 1133838:	a90363f7 	stp	x23, x24, [sp, #48]
 113383c:	aa0203f7 	mov	x23, x2
 1133840:	a9046bf9 	stp	x25, x26, [sp, #64]
   LTC_ARGCHK(ct != NULL);
 1133844:	b4fffe42 	cbz	x2, 113380c <xts_encrypt+0xc>
 1133848:	aa0303f5 	mov	x21, x3
   LTC_ARGCHK(tweak != NULL);
 113384c:	b4fffe03 	cbz	x3, 113380c <xts_encrypt+0xc>
 1133850:	aa0403f4 	mov	x20, x4
   LTC_ARGCHK(xts != NULL);
 1133854:	b4fffdc4 	cbz	x4, 113380c <xts_encrypt+0xc>
 1133858:	aa0003f8 	mov	x24, x0
   if ((err = cipher_is_valid(xts->cipher)) != CRYPT_OK) {
 113385c:	b9460080 	ldr	w0, [x4, #1536]
 1133860:	aa0103f6 	mov	x22, x1
 1133864:	97fffafb 	bl	1132450 <cipher_is_valid>
 1133868:	35fffd40 	cbnz	w0, 1133810 <xts_encrypt+0x10>
   m = ptlen >> 4;
 113386c:	d344fed3 	lsr	x19, x22, #4
   mo = ptlen & 15;
 1133870:	92400ed9 	and	x25, x22, #0xf
   if (m == 0) {
 1133874:	eb5613ff 	cmp	xzr, x22, lsr #4
 1133878:	54fffca0 	b.eq	113380c <xts_encrypt+0xc>  // b.none
      lim = m - 1;
 113387c:	f100033f 	cmp	x25, #0x0
   if (cipher_descriptor[xts->cipher]->accel_xts_encrypt && lim > 0) {
 1133880:	b9860281 	ldrsw	x1, [x20, #1536]
      lim = m - 1;
 1133884:	9a9f07e0 	cset	x0, ne  // ne = any
 1133888:	910c0296 	add	x22, x20, #0x300
 113388c:	cb000273 	sub	x19, x19, x0
   if (cipher_descriptor[xts->cipher]->accel_xts_encrypt && lim > 0) {
 1133890:	f0000120 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1133894:	f941c000 	ldr	x0, [x0, #896]
 1133898:	f8617800 	ldr	x0, [x0, x1, lsl #3]
 113389c:	f9405806 	ldr	x6, [x0, #176]
 11338a0:	b4000386 	cbz	x6, 1133910 <xts_encrypt+0x110>
 11338a4:	b4000373 	cbz	x19, 1133910 <xts_encrypt+0x110>
      if ((err = cipher_descriptor[xts->cipher]->accel_xts_encrypt(pt, ct, lim, tweak, &xts->key1, &xts->key2)) !=
 11338a8:	aa1603e5 	mov	x5, x22
 11338ac:	aa1403e4 	mov	x4, x20
 11338b0:	aa1503e3 	mov	x3, x21
 11338b4:	aa1303e2 	mov	x2, x19
 11338b8:	aa1703e1 	mov	x1, x23
 11338bc:	aa1803e0 	mov	x0, x24
 11338c0:	d63f00c0 	blr	x6
 11338c4:	35fffa60 	cbnz	w0, 1133810 <xts_encrypt+0x10>
      ct += lim * 16;
 11338c8:	8b1312f7 	add	x23, x23, x19, lsl #4
      XMEMCPY(T, tweak, sizeof(T));
 11338cc:	aa1503e1 	mov	x1, x21
      pt += lim * 16;
 11338d0:	8b131313 	add	x19, x24, x19, lsl #4
      XMEMCPY(T, tweak, sizeof(T));
 11338d4:	9101c3e0 	add	x0, sp, #0x70
 11338d8:	d2800202 	mov	x2, #0x10                  	// #16
 11338dc:	97ff3ead 	bl	1103390 <memcpy>
   if (mo > 0) {
 11338e0:	9101c3f8 	add	x24, sp, #0x70
 11338e4:	b50003d9 	cbnz	x25, 113395c <xts_encrypt+0x15c>
   if ((err = cipher_descriptor[xts->cipher]->ecb_decrypt(T, tweak, &xts->key2)) != CRYPT_OK) {
 11338e8:	f0000120 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 11338ec:	b9860281 	ldrsw	x1, [x20, #1536]
 11338f0:	aa1603e2 	mov	x2, x22
 11338f4:	f941c000 	ldr	x0, [x0, #896]
 11338f8:	f8617800 	ldr	x0, [x0, x1, lsl #3]
 11338fc:	aa1503e1 	mov	x1, x21
 1133900:	f9401803 	ldr	x3, [x0, #48]
 1133904:	aa1803e0 	mov	x0, x24
 1133908:	d63f0060 	blr	x3
 113390c:	17ffffc1 	b	1133810 <xts_encrypt+0x10>
      if ((err = cipher_descriptor[xts->cipher]->ecb_encrypt(tweak, T, &xts->key2)) != CRYPT_OK) {
 1133910:	f9401403 	ldr	x3, [x0, #40]
 1133914:	9101c3fa 	add	x26, sp, #0x70
 1133918:	aa1603e2 	mov	x2, x22
 113391c:	aa1a03e1 	mov	x1, x26
 1133920:	aa1503e0 	mov	x0, x21
 1133924:	d63f0060 	blr	x3
 1133928:	35fff740 	cbnz	w0, 1133810 <xts_encrypt+0x10>
 113392c:	8b131313 	add	x19, x24, x19, lsl #4
      for (i = 0; i < lim; i++) {
 1133930:	eb13031f 	cmp	x24, x19
 1133934:	54fffd60 	b.eq	11338e0 <xts_encrypt+0xe0>  // b.none
         if ((err = _tweak_crypt(pt, ct, T, xts)) != CRYPT_OK) {
 1133938:	aa1403e3 	mov	x3, x20
 113393c:	aa1a03e2 	mov	x2, x26
 1133940:	aa1703e1 	mov	x1, x23
 1133944:	aa1803e0 	mov	x0, x24
 1133948:	97ffff86 	bl	1133760 <_tweak_crypt>
 113394c:	35fff620 	cbnz	w0, 1133810 <xts_encrypt+0x10>
         ct += 16;
 1133950:	910042f7 	add	x23, x23, #0x10
         pt += 16;
 1133954:	91004318 	add	x24, x24, #0x10
      for (i = 0; i < lim; i++) {
 1133958:	17fffff6 	b	1133930 <xts_encrypt+0x130>
      if ((err = _tweak_crypt(pt, CC, T, xts)) != CRYPT_OK) {
 113395c:	910183fa 	add	x26, sp, #0x60
 1133960:	aa1403e3 	mov	x3, x20
 1133964:	aa1803e2 	mov	x2, x24
 1133968:	aa1a03e1 	mov	x1, x26
 113396c:	aa1303e0 	mov	x0, x19
 1133970:	97ffff7c 	bl	1133760 <_tweak_crypt>
 1133974:	35fff4e0 	cbnz	w0, 1133810 <xts_encrypt+0x10>
         PP[i] = pt[16 + i];
 1133978:	910143e0 	add	x0, sp, #0x50
 113397c:	91004273 	add	x19, x19, #0x10
         ct[16 + i] = CC[i];
 1133980:	910042e1 	add	x1, x23, #0x10
      for (i = 0; i < mo; i++) {
 1133984:	d2800002 	mov	x2, #0x0                   	// #0
         PP[i] = pt[16 + i];
 1133988:	38626a63 	ldrb	w3, [x19, x2]
 113398c:	38206843 	strb	w3, [x2, x0]
         ct[16 + i] = CC[i];
 1133990:	38626b43 	ldrb	w3, [x26, x2]
 1133994:	38226823 	strb	w3, [x1, x2]
      for (i = 0; i < mo; i++) {
 1133998:	91000442 	add	x2, x2, #0x1
 113399c:	eb02033f 	cmp	x25, x2
 11339a0:	54ffff41 	b.ne	1133988 <xts_encrypt+0x188>  // b.any
         PP[i] = CC[i];
 11339a4:	38796b41 	ldrb	w1, [x26, x25]
 11339a8:	38396801 	strb	w1, [x0, x25]
      for (; i < 16; i++) {
 11339ac:	91000739 	add	x25, x25, #0x1
 11339b0:	f100433f 	cmp	x25, #0x10
 11339b4:	54ffff81 	b.ne	11339a4 <xts_encrypt+0x1a4>  // b.any
      if ((err = _tweak_crypt(PP, ct, T, xts)) != CRYPT_OK) {
 11339b8:	aa1403e3 	mov	x3, x20
 11339bc:	aa1803e2 	mov	x2, x24
 11339c0:	aa1703e1 	mov	x1, x23
 11339c4:	97ffff67 	bl	1133760 <_tweak_crypt>
 11339c8:	34fff900 	cbz	w0, 11338e8 <xts_encrypt+0xe8>
 11339cc:	17ffff91 	b	1133810 <xts_encrypt+0x10>

00000000011339d0 <xts_start>:
              symmetric_xts *xts)
{
   int err;

   /* check inputs */
   LTC_ARGCHK(key1 != NULL);
 11339d0:	b5000141 	cbnz	x1, 11339f8 <xts_start+0x28>
 11339d4:	52800200 	mov	w0, #0x10                  	// #16
      return err;
   }
   xts->cipher = cipher;

   return err;
}
 11339d8:	d65f03c0 	ret
   LTC_ARGCHK(key1 != NULL);
 11339dc:	52800200 	mov	w0, #0x10                  	// #16
}
 11339e0:	a94153f3 	ldp	x19, x20, [sp, #16]
 11339e4:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11339e8:	a94363f7 	ldp	x23, x24, [sp, #48]
 11339ec:	a9446bf9 	ldp	x25, x26, [sp, #64]
 11339f0:	a8c57bfd 	ldp	x29, x30, [sp], #80
 11339f4:	d65f03c0 	ret
{
 11339f8:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 11339fc:	910003fd 	mov	x29, sp
 1133a00:	a90153f3 	stp	x19, x20, [sp, #16]
 1133a04:	a9025bf5 	stp	x21, x22, [sp, #32]
 1133a08:	aa0203f5 	mov	x21, x2
 1133a0c:	a90363f7 	stp	x23, x24, [sp, #48]
 1133a10:	a9046bf9 	stp	x25, x26, [sp, #64]
   LTC_ARGCHK(key2 != NULL);
 1133a14:	b4fffe42 	cbz	x2, 11339dc <xts_start+0xc>
 1133a18:	aa0503f3 	mov	x19, x5
   LTC_ARGCHK(xts != NULL);
 1133a1c:	b4fffe05 	cbz	x5, 11339dc <xts_start+0xc>
 1133a20:	2a0003f4 	mov	w20, w0
 1133a24:	aa0103f9 	mov	x25, x1
 1133a28:	aa0303f6 	mov	x22, x3
 1133a2c:	2a0403f7 	mov	w23, w4
   if ((err = cipher_is_valid(cipher)) != CRYPT_OK) {
 1133a30:	97fffa88 	bl	1132450 <cipher_is_valid>
 1133a34:	35fffd60 	cbnz	w0, 11339e0 <xts_start+0x10>
   if (cipher_descriptor[cipher]->block_length != 16) {
 1133a38:	f0000138 	adrp	x24, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1133a3c:	93407e9a 	sxtw	x26, w20
 1133a40:	f941c318 	ldr	x24, [x24, #896]
 1133a44:	f87a7b00 	ldr	x0, [x24, x26, lsl #3]
 1133a48:	b9401401 	ldr	w1, [x0, #20]
 1133a4c:	7100403f 	cmp	w1, #0x10
 1133a50:	54fffc61 	b.ne	11339dc <xts_start+0xc>  // b.any
   if ((err = cipher_descriptor[cipher]->setup(key1, keylen, num_rounds, &xts->key1)) != CRYPT_OK) {
 1133a54:	f9401004 	ldr	x4, [x0, #32]
 1133a58:	aa1303e3 	mov	x3, x19
 1133a5c:	2a1703e2 	mov	w2, w23
 1133a60:	2a1603e1 	mov	w1, w22
 1133a64:	aa1903e0 	mov	x0, x25
 1133a68:	d63f0080 	blr	x4
 1133a6c:	35fffba0 	cbnz	w0, 11339e0 <xts_start+0x10>
   if ((err = cipher_descriptor[cipher]->setup(key2, keylen, num_rounds, &xts->key2)) != CRYPT_OK) {
 1133a70:	f87a7b00 	ldr	x0, [x24, x26, lsl #3]
 1133a74:	910c0263 	add	x3, x19, #0x300
 1133a78:	2a1703e2 	mov	w2, w23
 1133a7c:	2a1603e1 	mov	w1, w22
 1133a80:	f9401004 	ldr	x4, [x0, #32]
 1133a84:	aa1503e0 	mov	x0, x21
 1133a88:	d63f0080 	blr	x4
 1133a8c:	35fffaa0 	cbnz	w0, 11339e0 <xts_start+0x10>
   xts->cipher = cipher;
 1133a90:	b9060274 	str	w20, [x19, #1536]
   return err;
 1133a94:	17ffffd3 	b	11339e0 <xts_start+0x10>

0000000001133a98 <xts_mult_x>:

/** multiply by x
  @param I      The value to multiply by x (LFSR shift)
*/
void xts_mult_x(unsigned char *I)
{
 1133a98:	d2800001 	mov	x1, #0x0                   	// #0
   int x;
   unsigned char t, tt;

   for (x = t = 0; x < 16; x++) {
 1133a9c:	52800003 	mov	w3, #0x0                   	// #0
      tt = I[x] >> 7;
 1133aa0:	38616802 	ldrb	w2, [x0, x1]
 1133aa4:	2a0303e4 	mov	w4, w3
 1133aa8:	53077c43 	lsr	w3, w2, #7
      I[x] = ((I[x] << 1) | t) & 0xFF;
 1133aac:	2a020482 	orr	w2, w4, w2, lsl #1
 1133ab0:	38216802 	strb	w2, [x0, x1]
   for (x = t = 0; x < 16; x++) {
 1133ab4:	91000421 	add	x1, x1, #0x1
 1133ab8:	f100403f 	cmp	x1, #0x10
 1133abc:	54ffff21 	b.ne	1133aa0 <xts_mult_x+0x8>  // b.any
      t = tt;
   }
   if (tt) {
 1133ac0:	34000083 	cbz	w3, 1133ad0 <xts_mult_x+0x38>
      I[0] ^= 0x87;
 1133ac4:	39400001 	ldrb	w1, [x0]
 1133ac8:	52196c21 	eor	w1, w1, #0xffffff87
 1133acc:	39000001 	strb	w1, [x0]
   }
}
 1133ad0:	d65f03c0 	ret

0000000001133ad4 <dsa_free>:
   Free a DSA key
   @param key   The key to free from memory
*/
void dsa_free(dsa_key *key)
{
   LTC_ARGCHKVD(key != NULL);
 1133ad4:	b4000200 	cbz	x0, 1133b14 <dsa_free+0x40>
{
 1133ad8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   mp_cleanup_multi(&key->y, &key->x, &key->q, &key->g, &key->p, NULL);
 1133adc:	91006004 	add	x4, x0, #0x18
 1133ae0:	91002003 	add	x3, x0, #0x8
{
 1133ae4:	910003fd 	mov	x29, sp
 1133ae8:	f9000bf3 	str	x19, [sp, #16]
 1133aec:	aa0003f3 	mov	x19, x0
   mp_cleanup_multi(&key->y, &key->x, &key->q, &key->g, &key->p, NULL);
 1133af0:	91004002 	add	x2, x0, #0x10
 1133af4:	91008001 	add	x1, x0, #0x20
 1133af8:	d2800005 	mov	x5, #0x0                   	// #0
 1133afc:	9100a000 	add	x0, x0, #0x28
 1133b00:	97fff9ac 	bl	11321b0 <ltc_cleanup_multi>
   key->type = key->qord = 0;
 1133b04:	f900027f 	str	xzr, [x19]
}
 1133b08:	f9400bf3 	ldr	x19, [sp, #16]
 1133b0c:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1133b10:	d65f03c0 	ret
 1133b14:	d65f03c0 	ret

0000000001133b18 <dsa_generate_key>:
*/
int dsa_generate_key(prng_state *prng, int wprng, dsa_key *key)
{
  int err;

  LTC_ARGCHK(key         != NULL);
 1133b18:	b4000342 	cbz	x2, 1133b80 <dsa_generate_key+0x68>
{
 1133b1c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1133b20:	2a0103e3 	mov	w3, w1
 1133b24:	910003fd 	mov	x29, sp
 1133b28:	a90153f3 	stp	x19, x20, [sp, #16]
  LTC_ARGCHK(ltc_mp.name != NULL);
 1133b2c:	f0000134 	adrp	x20, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1133b30:	f941d694 	ldr	x20, [x20, #936]
 1133b34:	f9400281 	ldr	x1, [x20]
 1133b38:	b4000281 	cbz	x1, 1133b88 <dsa_generate_key+0x70>
 1133b3c:	aa0203f3 	mov	x19, x2

  /* so now we have our DH structure, generator g, order q, modulus p
     Now we need a random exponent [mod q] and it's power g^x mod p
   */
  /* private key x should be from range: 1 <= x <= q-1 (see FIPS 186-4 B.1.2) */
  if ((err = rand_bn_upto(key->x, key->q, prng, wprng)) != CRYPT_OK)          { return err; }
 1133b40:	aa0003e2 	mov	x2, x0
 1133b44:	f9400a61 	ldr	x1, [x19, #16]
 1133b48:	f9401260 	ldr	x0, [x19, #32]
 1133b4c:	97fffa05 	bl	1132360 <rand_bn_upto>
 1133b50:	35000120 	cbnz	w0, 1133b74 <dsa_generate_key+0x5c>
  if ((err = mp_exptmod(key->g, key->x, key->p, key->y)) != CRYPT_OK)            { return err; }
 1133b54:	a9418662 	ldp	x2, x1, [x19, #24]
 1133b58:	f9400660 	ldr	x0, [x19, #8]
 1133b5c:	f9401663 	ldr	x3, [x19, #40]
 1133b60:	f940aa84 	ldr	x4, [x20, #336]
 1133b64:	d63f0080 	blr	x4
 1133b68:	35000060 	cbnz	w0, 1133b74 <dsa_generate_key+0x5c>
  key->type = PK_PRIVATE;
 1133b6c:	52800021 	mov	w1, #0x1                   	// #1
 1133b70:	b9000261 	str	w1, [x19]

  return CRYPT_OK;
}
 1133b74:	a94153f3 	ldp	x19, x20, [sp, #16]
 1133b78:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1133b7c:	d65f03c0 	ret
  LTC_ARGCHK(key         != NULL);
 1133b80:	52800200 	mov	w0, #0x10                  	// #16
}
 1133b84:	d65f03c0 	ret
  LTC_ARGCHK(key         != NULL);
 1133b88:	52800200 	mov	w0, #0x10                  	// #16
 1133b8c:	17fffffa 	b	1133b74 <dsa_generate_key+0x5c>

0000000001133b90 <dsa_sign_hash_raw>:
  @return CRYPT_OK if successful
*/
int dsa_sign_hash_raw(const unsigned char *in,  unsigned long inlen,
                                   void   *r,   void *s,
                               prng_state *prng, int wprng, const dsa_key *key)
{
 1133b90:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
 1133b94:	910003fd 	mov	x29, sp
 1133b98:	a90153f3 	stp	x19, x20, [sp, #16]
 1133b9c:	a9025bf5 	stp	x21, x22, [sp, #32]
 1133ba0:	a90363f7 	stp	x23, x24, [sp, #48]
 1133ba4:	a9046bf9 	stp	x25, x26, [sp, #64]
 1133ba8:	a90573fb 	stp	x27, x28, [sp, #80]
 1133bac:	f90037e4 	str	x4, [sp, #104]
   void         *k, *kinv, *tmp;
   unsigned char *buf;
   int            err, qbits;

   LTC_ARGCHK(in  != NULL);
 1133bb0:	b5000140 	cbnz	x0, 1133bd8 <dsa_sign_hash_raw+0x48>
 1133bb4:	5280021c 	mov	w28, #0x10                  	// #16
#ifdef LTC_CLEAN_STACK
   zeromem(buf, LTC_MDSA_MAX_GROUP);
#endif
   XFREE(buf);
   return err;
}
 1133bb8:	2a1c03e0 	mov	w0, w28
 1133bbc:	a94153f3 	ldp	x19, x20, [sp, #16]
 1133bc0:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1133bc4:	a94363f7 	ldp	x23, x24, [sp, #48]
 1133bc8:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1133bcc:	a94573fb 	ldp	x27, x28, [sp, #80]
 1133bd0:	a8c97bfd 	ldp	x29, x30, [sp], #144
 1133bd4:	d65f03c0 	ret
 1133bd8:	aa0203f6 	mov	x22, x2
   LTC_ARGCHK(r   != NULL);
 1133bdc:	b4fffec2 	cbz	x2, 1133bb4 <dsa_sign_hash_raw+0x24>
 1133be0:	aa0303f5 	mov	x21, x3
   LTC_ARGCHK(s   != NULL);
 1133be4:	b4fffe83 	cbz	x3, 1133bb4 <dsa_sign_hash_raw+0x24>
 1133be8:	aa0603f3 	mov	x19, x6
   LTC_ARGCHK(key != NULL);
 1133bec:	b4fffe46 	cbz	x6, 1133bb4 <dsa_sign_hash_raw+0x24>
 1133bf0:	aa0003fa 	mov	x26, x0
 1133bf4:	aa0103f7 	mov	x23, x1
 1133bf8:	2a0503fb 	mov	w27, w5
   if ((err = prng_is_valid(wprng)) != CRYPT_OK) {
 1133bfc:	2a0503e0 	mov	w0, w5
 1133c00:	97fffab7 	bl	11326dc <prng_is_valid>
 1133c04:	2a0003fc 	mov	w28, w0
 1133c08:	35fffd80 	cbnz	w0, 1133bb8 <dsa_sign_hash_raw+0x28>
   if (key->type != PK_PRIVATE) {
 1133c0c:	b9400260 	ldr	w0, [x19]
 1133c10:	7100041f 	cmp	w0, #0x1
 1133c14:	54001021 	b.ne	1133e18 <dsa_sign_hash_raw+0x288>  // b.any
   if (key->qord >= LTC_MDSA_MAX_GROUP) {
 1133c18:	b9400660 	ldr	w0, [x19, #4]
 1133c1c:	7107fc1f 	cmp	w0, #0x1ff
 1133c20:	54fffcac 	b.gt	1133bb4 <dsa_sign_hash_raw+0x24>
   buf = XMALLOC(LTC_MDSA_MAX_GROUP);
 1133c24:	d2804000 	mov	x0, #0x200                 	// #512
 1133c28:	94003e0c 	bl	1143458 <malloc>
 1133c2c:	aa0003f8 	mov	x24, x0
   if (buf == NULL) {
 1133c30:	b4000f00 	cbz	x0, 1133e10 <dsa_sign_hash_raw+0x280>
   if ((err = mp_init_multi(&k, &kinv, &tmp, NULL)) != CRYPT_OK)                       { goto ERRBUF; }
 1133c34:	910223e2 	add	x2, sp, #0x88
 1133c38:	910203e1 	add	x1, sp, #0x80
 1133c3c:	9101e3e0 	add	x0, sp, #0x78
 1133c40:	d2800003 	mov	x3, #0x0                   	// #0
 1133c44:	97fff89c 	bl	1131eb4 <ltc_init_multi>
 1133c48:	2a0003fc 	mov	w28, w0
 1133c4c:	35000d60 	cbnz	w0, 1133df8 <dsa_sign_hash_raw+0x268>
   qbits = mp_count_bits(key->q);
 1133c50:	f0000120 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1133c54:	f941d414 	ldr	x20, [x0, #936]
 1133c58:	f9400a60 	ldr	x0, [x19, #16]
   if ((err = mp_mul(key->x, r, s)) != CRYPT_OK)                                       { goto error; }
 1133c5c:	aa1403f9 	mov	x25, x20
   qbits = mp_count_bits(key->q);
 1133c60:	f9403a81 	ldr	x1, [x20, #112]
 1133c64:	d63f0020 	blr	x1
 1133c68:	b90067e0 	str	w0, [sp, #100]
      if ((err = rand_bn_bits(k, qbits, prng, wprng)) != CRYPT_OK)                     { goto error; }
 1133c6c:	b94067e1 	ldr	w1, [sp, #100]
 1133c70:	2a1b03e3 	mov	w3, w27
 1133c74:	f94037e2 	ldr	x2, [sp, #104]
 1133c78:	f9403fe0 	ldr	x0, [sp, #120]
 1133c7c:	97fff976 	bl	1132254 <rand_bn_bits>
 1133c80:	2a0003fc 	mov	w28, w0
 1133c84:	35000b20 	cbnz	w0, 1133de8 <dsa_sign_hash_raw+0x258>
      if (mp_cmp_d(k, 0) != LTC_MP_GT || mp_cmp(k, key->q) != LTC_MP_LT)               { goto retry; }
 1133c88:	f9403682 	ldr	x2, [x20, #104]
 1133c8c:	d2800001 	mov	x1, #0x0                   	// #0
 1133c90:	f9403fe0 	ldr	x0, [sp, #120]
 1133c94:	d63f0040 	blr	x2
 1133c98:	7100041f 	cmp	w0, #0x1
 1133c9c:	54fffe81 	b.ne	1133c6c <dsa_sign_hash_raw+0xdc>  // b.any
 1133ca0:	f9400a61 	ldr	x1, [x19, #16]
 1133ca4:	f9403282 	ldr	x2, [x20, #96]
 1133ca8:	f9403fe0 	ldr	x0, [sp, #120]
 1133cac:	d63f0040 	blr	x2
 1133cb0:	3100041f 	cmn	w0, #0x1
 1133cb4:	54fffdc1 	b.ne	1133c6c <dsa_sign_hash_raw+0xdc>  // b.any
      if ((err = mp_gcd(k, key->q, tmp)) != CRYPT_OK)                                  { goto error; }
 1133cb8:	f9400a61 	ldr	x1, [x19, #16]
 1133cbc:	f9403fe0 	ldr	x0, [sp, #120]
 1133cc0:	f94047e2 	ldr	x2, [sp, #136]
 1133cc4:	f9408683 	ldr	x3, [x20, #264]
 1133cc8:	d63f0060 	blr	x3
 1133ccc:	2a0003fc 	mov	w28, w0
 1133cd0:	350008c0 	cbnz	w0, 1133de8 <dsa_sign_hash_raw+0x258>
   } while (mp_cmp_d(tmp, 1) != LTC_MP_EQ);
 1133cd4:	f9403682 	ldr	x2, [x20, #104]
 1133cd8:	d2800021 	mov	x1, #0x1                   	// #1
 1133cdc:	f94047e0 	ldr	x0, [sp, #136]
 1133ce0:	d63f0040 	blr	x2
 1133ce4:	35fffc40 	cbnz	w0, 1133c6c <dsa_sign_hash_raw+0xdc>
   if ((err = mp_invmod(k, key->q, kinv)) != CRYPT_OK)                                 { goto error; }
 1133ce8:	a9478be0 	ldp	x0, x2, [sp, #120]
 1133cec:	f9400a61 	ldr	x1, [x19, #16]
 1133cf0:	f9409683 	ldr	x3, [x20, #296]
 1133cf4:	d63f0060 	blr	x3
 1133cf8:	2a0003fc 	mov	w28, w0
 1133cfc:	35000760 	cbnz	w0, 1133de8 <dsa_sign_hash_raw+0x258>
   if ((err = mp_exptmod(key->g, k, key->p, r)) != CRYPT_OK)                           { goto error; }
 1133d00:	f9400660 	ldr	x0, [x19, #8]
 1133d04:	aa1603e3 	mov	x3, x22
 1133d08:	f9400e62 	ldr	x2, [x19, #24]
 1133d0c:	f9403fe1 	ldr	x1, [sp, #120]
 1133d10:	f940aa84 	ldr	x4, [x20, #336]
 1133d14:	d63f0080 	blr	x4
 1133d18:	2a0003fc 	mov	w28, w0
 1133d1c:	35000660 	cbnz	w0, 1133de8 <dsa_sign_hash_raw+0x258>
   if ((err = mp_mod(r, key->q, r)) != CRYPT_OK)                                       { goto error; }
 1133d20:	f9400a61 	ldr	x1, [x19, #16]
 1133d24:	aa1603e3 	mov	x3, x22
 1133d28:	f9407a84 	ldr	x4, [x20, #240]
 1133d2c:	aa1603e0 	mov	x0, x22
 1133d30:	d2800002 	mov	x2, #0x0                   	// #0
 1133d34:	d63f0080 	blr	x4
 1133d38:	2a0003fc 	mov	w28, w0
 1133d3c:	35000560 	cbnz	w0, 1133de8 <dsa_sign_hash_raw+0x258>
   if (mp_iszero(r) == LTC_MP_YES)                                                     { goto retry; }
 1133d40:	f9403682 	ldr	x2, [x20, #104]
 1133d44:	aa1603e0 	mov	x0, x22
 1133d48:	d2800001 	mov	x1, #0x0                   	// #0
 1133d4c:	d63f0040 	blr	x2
 1133d50:	34fff8e0 	cbz	w0, 1133c6c <dsa_sign_hash_raw+0xdc>
   inlen = MIN(inlen, (unsigned long)(key->qord));
 1133d54:	b9800660 	ldrsw	x0, [x19, #4]
   if ((err = mp_read_unsigned_bin(tmp, (unsigned char *)in, inlen)) != CRYPT_OK)      { goto error; }
 1133d58:	aa1a03e1 	mov	x1, x26
 1133d5c:	f9405683 	ldr	x3, [x20, #168]
   inlen = MIN(inlen, (unsigned long)(key->qord));
 1133d60:	eb0002ff 	cmp	x23, x0
 1133d64:	9a8092f7 	csel	x23, x23, x0, ls  // ls = plast
   if ((err = mp_read_unsigned_bin(tmp, (unsigned char *)in, inlen)) != CRYPT_OK)      { goto error; }
 1133d68:	f94047e0 	ldr	x0, [sp, #136]
 1133d6c:	aa1703e2 	mov	x2, x23
 1133d70:	d63f0060 	blr	x3
 1133d74:	2a0003fc 	mov	w28, w0
 1133d78:	35000380 	cbnz	w0, 1133de8 <dsa_sign_hash_raw+0x258>
   if ((err = mp_mul(key->x, r, s)) != CRYPT_OK)                                       { goto error; }
 1133d7c:	f9401260 	ldr	x0, [x19, #32]
 1133d80:	aa1503e2 	mov	x2, x21
 1133d84:	f9406b23 	ldr	x3, [x25, #208]
 1133d88:	aa1603e1 	mov	x1, x22
 1133d8c:	d63f0060 	blr	x3
 1133d90:	2a0003fc 	mov	w28, w0
 1133d94:	350002a0 	cbnz	w0, 1133de8 <dsa_sign_hash_raw+0x258>
   if ((err = mp_add(s, tmp, s)) != CRYPT_OK)                                          { goto error; }
 1133d98:	f94047e1 	ldr	x1, [sp, #136]
 1133d9c:	aa1503e2 	mov	x2, x21
 1133da0:	f9405b23 	ldr	x3, [x25, #176]
 1133da4:	aa1503e0 	mov	x0, x21
 1133da8:	d63f0060 	blr	x3
 1133dac:	2a0003fc 	mov	w28, w0
 1133db0:	350001c0 	cbnz	w0, 1133de8 <dsa_sign_hash_raw+0x258>
   if ((err = mp_mulmod(s, kinv, key->q, s)) != CRYPT_OK)                              { goto error; }
 1133db4:	f9400a62 	ldr	x2, [x19, #16]
 1133db8:	aa1503e3 	mov	x3, x21
 1133dbc:	f94043e1 	ldr	x1, [sp, #128]
 1133dc0:	aa1503e0 	mov	x0, x21
 1133dc4:	f9408f24 	ldr	x4, [x25, #280]
 1133dc8:	d63f0080 	blr	x4
 1133dcc:	2a0003fc 	mov	w28, w0
 1133dd0:	350000c0 	cbnz	w0, 1133de8 <dsa_sign_hash_raw+0x258>
   if (mp_iszero(s) == LTC_MP_YES)                                                     { goto retry; }
 1133dd4:	f9403722 	ldr	x2, [x25, #104]
 1133dd8:	aa1503e0 	mov	x0, x21
 1133ddc:	d2800001 	mov	x1, #0x0                   	// #0
 1133de0:	d63f0040 	blr	x2
 1133de4:	34fff440 	cbz	w0, 1133c6c <dsa_sign_hash_raw+0xdc>
   mp_clear_multi(k, kinv, tmp, NULL);
 1133de8:	a94787e0 	ldp	x0, x1, [sp, #120]
 1133dec:	d2800003 	mov	x3, #0x0                   	// #0
 1133df0:	f94047e2 	ldr	x2, [sp, #136]
 1133df4:	97fff8ca 	bl	113211c <ltc_deinit_multi>
   zeromem(buf, LTC_MDSA_MAX_GROUP);
 1133df8:	d2804001 	mov	x1, #0x200                 	// #512
 1133dfc:	aa1803e0 	mov	x0, x24
 1133e00:	97fff991 	bl	1132444 <zeromem>
   XFREE(buf);
 1133e04:	aa1803e0 	mov	x0, x24
 1133e08:	94003df6 	bl	11435e0 <free>
   return err;
 1133e0c:	17ffff6b 	b	1133bb8 <dsa_sign_hash_raw+0x28>
      return CRYPT_MEM;
 1133e10:	528001bc 	mov	w28, #0xd                   	// #13
 1133e14:	17ffff69 	b	1133bb8 <dsa_sign_hash_raw+0x28>
      return CRYPT_PK_NOT_PRIVATE;
 1133e18:	528001fc 	mov	w28, #0xf                   	// #15
 1133e1c:	17ffff67 	b	1133bb8 <dsa_sign_hash_raw+0x28>

0000000001133e20 <dsa_verify_hash_raw>:
  @return CRYPT_OK if successful (even if the signature is invalid)
*/
int dsa_verify_hash_raw(         void   *r,          void   *s,
                    const unsigned char *hash, unsigned long hashlen,
                                    int *stat, const dsa_key *key)
{
 1133e20:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
 1133e24:	910003fd 	mov	x29, sp
 1133e28:	a90153f3 	stp	x19, x20, [sp, #16]
 1133e2c:	a9025bf5 	stp	x21, x22, [sp, #32]
 1133e30:	a90363f7 	stp	x23, x24, [sp, #48]
 1133e34:	a9046bf9 	stp	x25, x26, [sp, #64]
 1133e38:	f9002bfb 	str	x27, [sp, #80]
   void          *w, *v, *u1, *u2;
   int           err;

   LTC_ARGCHK(r    != NULL);
 1133e3c:	b4001080 	cbz	x0, 113404c <dsa_verify_hash_raw+0x22c>
 1133e40:	aa0103fa 	mov	x26, x1
   LTC_ARGCHK(s    != NULL);
 1133e44:	b4001041 	cbz	x1, 113404c <dsa_verify_hash_raw+0x22c>
 1133e48:	aa0403f5 	mov	x21, x4
   LTC_ARGCHK(stat != NULL);
 1133e4c:	b4001004 	cbz	x4, 113404c <dsa_verify_hash_raw+0x22c>
 1133e50:	aa0503f6 	mov	x22, x5
   LTC_ARGCHK(key  != NULL);
 1133e54:	b4000fc5 	cbz	x5, 113404c <dsa_verify_hash_raw+0x22c>

   /* default to invalid signature */
   *stat = 0;
 1133e58:	b90002bf 	str	wzr, [x21]
 1133e5c:	aa0003f4 	mov	x20, x0
 1133e60:	aa0203f9 	mov	x25, x2
 1133e64:	aa0303f8 	mov	x24, x3

   /* init our variables */
   if ((err = mp_init_multi(&w, &v, &u1, &u2, NULL)) != CRYPT_OK) {
 1133e68:	9101c3e2 	add	x2, sp, #0x70
 1133e6c:	9101e3e3 	add	x3, sp, #0x78
 1133e70:	9101a3e1 	add	x1, sp, #0x68
 1133e74:	910183e0 	add	x0, sp, #0x60
 1133e78:	d2800004 	mov	x4, #0x0                   	// #0
 1133e7c:	97fff80e 	bl	1131eb4 <ltc_init_multi>
 1133e80:	2a0003f3 	mov	w19, w0
 1133e84:	350001c0 	cbnz	w0, 1133ebc <dsa_verify_hash_raw+0x9c>
      return err;
   }

   /* neither r or s can be null or >q*/
   if (mp_cmp_d(r, 0) != LTC_MP_GT || mp_cmp_d(s, 0) != LTC_MP_GT || mp_cmp(r, key->q) != LTC_MP_LT || mp_cmp(s, key->q) != LTC_MP_LT) {
 1133e88:	f0000137 	adrp	x23, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1133e8c:	aa1403e0 	mov	x0, x20
 1133e90:	d2800001 	mov	x1, #0x0                   	// #0
 1133e94:	f941d6f7 	ldr	x23, [x23, #936]
 1133e98:	f94036e2 	ldr	x2, [x23, #104]
 1133e9c:	d63f0040 	blr	x2
 1133ea0:	7100041f 	cmp	w0, #0x1
 1133ea4:	540001c0 	b.eq	1133edc <dsa_verify_hash_raw+0xbc>  // b.none
      err = CRYPT_INVALID_PACKET;
 1133ea8:	528000f3 	mov	w19, #0x7                   	// #7
      *stat = 1;
   }

   err = CRYPT_OK;
error:
   mp_clear_multi(w, v, u1, u2, NULL);
 1133eac:	a94607e0 	ldp	x0, x1, [sp, #96]
 1133eb0:	d2800004 	mov	x4, #0x0                   	// #0
 1133eb4:	a9470fe2 	ldp	x2, x3, [sp, #112]
 1133eb8:	97fff899 	bl	113211c <ltc_deinit_multi>
   return err;
}
 1133ebc:	2a1303e0 	mov	w0, w19
 1133ec0:	a94153f3 	ldp	x19, x20, [sp, #16]
 1133ec4:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1133ec8:	a94363f7 	ldp	x23, x24, [sp, #48]
 1133ecc:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1133ed0:	f9402bfb 	ldr	x27, [sp, #80]
 1133ed4:	a8c87bfd 	ldp	x29, x30, [sp], #128
 1133ed8:	d65f03c0 	ret
   if (mp_cmp_d(r, 0) != LTC_MP_GT || mp_cmp_d(s, 0) != LTC_MP_GT || mp_cmp(r, key->q) != LTC_MP_LT || mp_cmp(s, key->q) != LTC_MP_LT) {
 1133edc:	f94036e2 	ldr	x2, [x23, #104]
 1133ee0:	aa1a03e0 	mov	x0, x26
 1133ee4:	d2800001 	mov	x1, #0x0                   	// #0
 1133ee8:	d63f0040 	blr	x2
 1133eec:	7100041f 	cmp	w0, #0x1
 1133ef0:	54fffdc1 	b.ne	1133ea8 <dsa_verify_hash_raw+0x88>  // b.any
 1133ef4:	f9400ac1 	ldr	x1, [x22, #16]
 1133ef8:	aa1403e0 	mov	x0, x20
 1133efc:	f94032e2 	ldr	x2, [x23, #96]
 1133f00:	d63f0040 	blr	x2
 1133f04:	3100041f 	cmn	w0, #0x1
 1133f08:	54fffd01 	b.ne	1133ea8 <dsa_verify_hash_raw+0x88>  // b.any
 1133f0c:	f9400ac1 	ldr	x1, [x22, #16]
 1133f10:	aa1a03e0 	mov	x0, x26
 1133f14:	f94032e2 	ldr	x2, [x23, #96]
 1133f18:	d63f0040 	blr	x2
 1133f1c:	3100041f 	cmn	w0, #0x1
 1133f20:	54fffc41 	b.ne	1133ea8 <dsa_verify_hash_raw+0x88>  // b.any
   if ((err = mp_invmod(s, key->q, w)) != CRYPT_OK)                                       { goto error; }
 1133f24:	f9400ac1 	ldr	x1, [x22, #16]
 1133f28:	aa1a03e0 	mov	x0, x26
 1133f2c:	f94033e2 	ldr	x2, [sp, #96]
 1133f30:	f94096e3 	ldr	x3, [x23, #296]
   hashlen = MIN(hashlen, (unsigned long)(key->qord));
 1133f34:	b94006db 	ldr	w27, [x22, #4]
   if ((err = mp_invmod(s, key->q, w)) != CRYPT_OK)                                       { goto error; }
 1133f38:	d63f0060 	blr	x3
 1133f3c:	2a0003f3 	mov	w19, w0
 1133f40:	35fffb60 	cbnz	w0, 1133eac <dsa_verify_hash_raw+0x8c>
   if ((err = mp_read_unsigned_bin(u1, (unsigned char *)hash, hashlen)) != CRYPT_OK)      { goto error; }
 1133f44:	f0000137 	adrp	x23, 115a000 <__scattered_array_1phys_mem_map+0x8>
   hashlen = MIN(hashlen, (unsigned long)(key->qord));
 1133f48:	eb3bc31f 	cmp	x24, w27, sxtw
   if ((err = mp_read_unsigned_bin(u1, (unsigned char *)hash, hashlen)) != CRYPT_OK)      { goto error; }
 1133f4c:	f9403be0 	ldr	x0, [sp, #112]
   hashlen = MIN(hashlen, (unsigned long)(key->qord));
 1133f50:	93407f62 	sxtw	x2, w27
   if ((err = mp_read_unsigned_bin(u1, (unsigned char *)hash, hashlen)) != CRYPT_OK)      { goto error; }
 1133f54:	f941d6f7 	ldr	x23, [x23, #936]
 1133f58:	9a982042 	csel	x2, x2, x24, cs  // cs = hs, nlast
 1133f5c:	aa1903e1 	mov	x1, x25
 1133f60:	f94056e3 	ldr	x3, [x23, #168]
 1133f64:	d63f0060 	blr	x3
 1133f68:	2a0003f3 	mov	w19, w0
 1133f6c:	35fffa00 	cbnz	w0, 1133eac <dsa_verify_hash_raw+0x8c>
   if ((err = mp_mulmod(u1, w, key->q, u1)) != CRYPT_OK)                                  { goto error; }
 1133f70:	f9400ac2 	ldr	x2, [x22, #16]
 1133f74:	f94033e1 	ldr	x1, [sp, #96]
 1133f78:	f9403be3 	ldr	x3, [sp, #112]
 1133f7c:	f9408ee4 	ldr	x4, [x23, #280]
 1133f80:	aa0303e0 	mov	x0, x3
 1133f84:	d63f0080 	blr	x4
 1133f88:	2a0003f3 	mov	w19, w0
 1133f8c:	35fff900 	cbnz	w0, 1133eac <dsa_verify_hash_raw+0x8c>
   if ((err = mp_mulmod(r, w, key->q, u2)) != CRYPT_OK)                                   { goto error; }
 1133f90:	f9400ac2 	ldr	x2, [x22, #16]
 1133f94:	aa1403e0 	mov	x0, x20
 1133f98:	f94033e1 	ldr	x1, [sp, #96]
 1133f9c:	f9403fe3 	ldr	x3, [sp, #120]
 1133fa0:	f9408ee4 	ldr	x4, [x23, #280]
 1133fa4:	d63f0080 	blr	x4
 1133fa8:	2a0003f3 	mov	w19, w0
 1133fac:	35fff800 	cbnz	w0, 1133eac <dsa_verify_hash_raw+0x8c>
   if ((err = mp_exptmod(key->g, u1, key->p, u1)) != CRYPT_OK)                            { goto error; }
 1133fb0:	f94006c0 	ldr	x0, [x22, #8]
 1133fb4:	f9400ec2 	ldr	x2, [x22, #24]
 1133fb8:	f9403be3 	ldr	x3, [sp, #112]
 1133fbc:	f940aae4 	ldr	x4, [x23, #336]
 1133fc0:	aa0303e1 	mov	x1, x3
 1133fc4:	d63f0080 	blr	x4
 1133fc8:	2a0003f3 	mov	w19, w0
 1133fcc:	35fff700 	cbnz	w0, 1133eac <dsa_verify_hash_raw+0x8c>
   if ((err = mp_exptmod(key->y, u2, key->p, u2)) != CRYPT_OK)                            { goto error; }
 1133fd0:	f9400ec2 	ldr	x2, [x22, #24]
 1133fd4:	f94016c0 	ldr	x0, [x22, #40]
 1133fd8:	f9403fe3 	ldr	x3, [sp, #120]
 1133fdc:	f940aae4 	ldr	x4, [x23, #336]
 1133fe0:	aa0303e1 	mov	x1, x3
 1133fe4:	d63f0080 	blr	x4
 1133fe8:	2a0003f3 	mov	w19, w0
 1133fec:	35fff600 	cbnz	w0, 1133eac <dsa_verify_hash_raw+0x8c>
   if ((err = mp_mulmod(u1, u2, key->p, v)) != CRYPT_OK)                                  { goto error; }
 1133ff0:	a94683e3 	ldp	x3, x0, [sp, #104]
 1133ff4:	f9400ec2 	ldr	x2, [x22, #24]
 1133ff8:	f9403fe1 	ldr	x1, [sp, #120]
 1133ffc:	f9408ee4 	ldr	x4, [x23, #280]
 1134000:	d63f0080 	blr	x4
 1134004:	2a0003f3 	mov	w19, w0
 1134008:	35fff520 	cbnz	w0, 1133eac <dsa_verify_hash_raw+0x8c>
   if ((err = mp_mod(v, key->q, v)) != CRYPT_OK)                                          { goto error; }
 113400c:	f9400ac1 	ldr	x1, [x22, #16]
 1134010:	d2800002 	mov	x2, #0x0                   	// #0
 1134014:	f94037e3 	ldr	x3, [sp, #104]
 1134018:	f9407ae4 	ldr	x4, [x23, #240]
 113401c:	aa0303e0 	mov	x0, x3
 1134020:	d63f0080 	blr	x4
 1134024:	2a0003f3 	mov	w19, w0
 1134028:	35fff420 	cbnz	w0, 1133eac <dsa_verify_hash_raw+0x8c>
   if (mp_cmp(r, v) == LTC_MP_EQ) {
 113402c:	f94032e2 	ldr	x2, [x23, #96]
 1134030:	aa1403e0 	mov	x0, x20
 1134034:	f94037e1 	ldr	x1, [sp, #104]
 1134038:	d63f0040 	blr	x2
 113403c:	35fff380 	cbnz	w0, 1133eac <dsa_verify_hash_raw+0x8c>
      *stat = 1;
 1134040:	52800020 	mov	w0, #0x1                   	// #1
 1134044:	b90002a0 	str	w0, [x21]
 1134048:	17ffff99 	b	1133eac <dsa_verify_hash_raw+0x8c>
   LTC_ARGCHK(r    != NULL);
 113404c:	52800213 	mov	w19, #0x10                  	// #16
 1134050:	17ffff9b 	b	1133ebc <dsa_verify_hash_raw+0x9c>

0000000001134054 <rsa_decrypt_key_ex>:
int rsa_decrypt_key_ex(const unsigned char *in,             unsigned long  inlen,
                             unsigned char *out,            unsigned long *outlen,
                       const unsigned char *lparam,         unsigned long  lparamlen,
                             int            hash_idx,       int            padding,
                             int           *stat,     const rsa_key       *key)
{
 1134054:	d10283ff 	sub	sp, sp, #0xa0
 1134058:	a9017bfd 	stp	x29, x30, [sp, #16]
 113405c:	910043fd 	add	x29, sp, #0x10
 1134060:	a90253f3 	stp	x19, x20, [sp, #32]
 1134064:	a9035bf5 	stp	x21, x22, [sp, #48]
 1134068:	a90463f7 	stp	x23, x24, [sp, #64]
 113406c:	a9056bf9 	stp	x25, x26, [sp, #80]
 1134070:	a90673fb 	stp	x27, x28, [sp, #96]
 1134074:	a90817e4 	stp	x4, x5, [sp, #128]
 1134078:	a94a67f7 	ldp	x23, x25, [sp, #160]
  unsigned long modulus_bitlen, modulus_bytelen, x;
  int           err;
  unsigned char *tmp;

  LTC_ARGCHK(out    != NULL);
 113407c:	b40009c2 	cbz	x2, 11341b4 <rsa_decrypt_key_ex+0x160>
 1134080:	aa0303f4 	mov	x20, x3
  LTC_ARGCHK(outlen != NULL);
 1134084:	b4000983 	cbz	x3, 11341b4 <rsa_decrypt_key_ex+0x160>
  LTC_ARGCHK(key    != NULL);
 1134088:	b4000979 	cbz	x25, 11341b4 <rsa_decrypt_key_ex+0x160>
  LTC_ARGCHK(stat   != NULL);
 113408c:	b4000957 	cbz	x23, 11341b4 <rsa_decrypt_key_ex+0x160>

  /* default to invalid */
  *stat = 0;
 1134090:	b90002ff 	str	wzr, [x23]
 1134094:	aa0003fc 	mov	x28, x0

  /* valid padding? */

  if ((padding != LTC_PKCS_1_V1_5) &&
 1134098:	510004e0 	sub	w0, w7, #0x1
 113409c:	2a0703f5 	mov	w21, w7
 11340a0:	7100041f 	cmp	w0, #0x1
 11340a4:	540008c8 	b.hi	11341bc <rsa_decrypt_key_ex+0x168>  // b.pmore
 11340a8:	aa0103f6 	mov	x22, x1
 11340ac:	aa0203f3 	mov	x19, x2
 11340b0:	2a0603f8 	mov	w24, w6
      (padding != LTC_PKCS_1_OAEP)) {
    return CRYPT_PK_INVALID_PADDING;
  }

  if (padding == LTC_PKCS_1_OAEP) {
 11340b4:	710008ff 	cmp	w7, #0x2
 11340b8:	540003a0 	b.eq	113412c <rsa_decrypt_key_ex+0xd8>  // b.none
       return err;
    }
  }

  /* get modulus len in bits */
  modulus_bitlen = mp_count_bits( (key->N));
 11340bc:	d0000121 	adrp	x1, 115a000 <__scattered_array_1phys_mem_map+0x8>
 11340c0:	f9400f20 	ldr	x0, [x25, #24]
 11340c4:	f941d43a 	ldr	x26, [x1, #936]
 11340c8:	f9403b42 	ldr	x2, [x26, #112]
 11340cc:	d63f0040 	blr	x2
 11340d0:	b9007fe0 	str	w0, [sp, #124]

  /* outlen must be at least the size of the modulus */
  modulus_bytelen = mp_unsigned_bin_size( (key->N));
 11340d4:	f9400f20 	ldr	x0, [x25, #24]
 11340d8:	f9404f42 	ldr	x2, [x26, #152]
 11340dc:	d63f0040 	blr	x2
  if (modulus_bytelen != inlen) {
 11340e0:	eb16001f 	cmp	x0, x22
 11340e4:	54000701 	b.ne	11341c4 <rsa_decrypt_key_ex+0x170>  // b.any
     return CRYPT_INVALID_PACKET;
  }

  /* allocate ram */
  tmp = XMALLOC(inlen);
 11340e8:	94003cdc 	bl	1143458 <malloc>
 11340ec:	aa0003fb 	mov	x27, x0
  if (tmp == NULL) {
 11340f0:	b40006e0 	cbz	x0, 11341cc <rsa_decrypt_key_ex+0x178>
     return CRYPT_MEM;
  }

  /* rsa decode the packet */
  x = inlen;
  if ((err = ltc_mp.rsa_me(in, inlen, tmp, &x, PK_PRIVATE, key)) != CRYPT_OK) {
 11340f4:	f940cb46 	ldr	x6, [x26, #400]
  x = inlen;
 11340f8:	f9004ff6 	str	x22, [sp, #152]
  if ((err = ltc_mp.rsa_me(in, inlen, tmp, &x, PK_PRIVATE, key)) != CRYPT_OK) {
 11340fc:	aa0003e2 	mov	x2, x0
 1134100:	aa1903e5 	mov	x5, x25
 1134104:	910263e3 	add	x3, sp, #0x98
 1134108:	aa1603e1 	mov	x1, x22
 113410c:	aa1c03e0 	mov	x0, x28
 1134110:	52800024 	mov	w4, #0x1                   	// #1
 1134114:	d63f00c0 	blr	x6
 1134118:	2a0003fa 	mov	w26, w0
 113411c:	34000220 	cbz	w0, 1134160 <rsa_decrypt_key_ex+0x10c>
  } else {
    /* now PKCS #1 v1.5 depad the packet */
    err = pkcs_1_v1_5_decode(tmp, x, LTC_PKCS_1_EME, modulus_bitlen, out, outlen, stat);
  }

  XFREE(tmp);
 1134120:	aa1b03e0 	mov	x0, x27
 1134124:	94003d2f 	bl	11435e0 <free>
  return err;
 1134128:	14000005 	b	113413c <rsa_decrypt_key_ex+0xe8>
    if ((err = hash_is_valid(hash_idx)) != CRYPT_OK) {
 113412c:	2a0603e0 	mov	w0, w6
 1134130:	97fff951 	bl	1132674 <hash_is_valid>
 1134134:	2a0003fa 	mov	w26, w0
 1134138:	34fffc20 	cbz	w0, 11340bc <rsa_decrypt_key_ex+0x68>
}
 113413c:	2a1a03e0 	mov	w0, w26
 1134140:	a9417bfd 	ldp	x29, x30, [sp, #16]
 1134144:	a94253f3 	ldp	x19, x20, [sp, #32]
 1134148:	a9435bf5 	ldp	x21, x22, [sp, #48]
 113414c:	a94463f7 	ldp	x23, x24, [sp, #64]
 1134150:	a9456bf9 	ldp	x25, x26, [sp, #80]
 1134154:	a94673fb 	ldp	x27, x28, [sp, #96]
 1134158:	910283ff 	add	sp, sp, #0xa0
 113415c:	d65f03c0 	ret
  modulus_bitlen = mp_count_bits( (key->N));
 1134160:	b9807fe3 	ldrsw	x3, [sp, #124]
  if (padding == LTC_PKCS_1_OAEP) {
 1134164:	71000abf 	cmp	w21, #0x2
 1134168:	f9404fe1 	ldr	x1, [sp, #152]
 113416c:	54000161 	b.ne	1134198 <rsa_decrypt_key_ex+0x144>  // b.any
    err = pkcs_1_oaep_decode(tmp, x, lparam, lparamlen, modulus_bitlen, hash_idx,
 1134170:	aa0303e4 	mov	x4, x3
 1134174:	f90003f7 	str	x23, [sp]
 1134178:	a9480fe2 	ldp	x2, x3, [sp, #128]
 113417c:	aa1403e7 	mov	x7, x20
 1134180:	aa1303e6 	mov	x6, x19
 1134184:	2a1803e5 	mov	w5, w24
 1134188:	aa1b03e0 	mov	x0, x27
 113418c:	94001ad5 	bl	113ace0 <pkcs_1_oaep_decode>
    err = pkcs_1_v1_5_decode(tmp, x, LTC_PKCS_1_EME, modulus_bitlen, out, outlen, stat);
 1134190:	2a0003fa 	mov	w26, w0
 1134194:	17ffffe3 	b	1134120 <rsa_decrypt_key_ex+0xcc>
 1134198:	aa1703e6 	mov	x6, x23
 113419c:	aa1403e5 	mov	x5, x20
 11341a0:	aa1303e4 	mov	x4, x19
 11341a4:	aa1b03e0 	mov	x0, x27
 11341a8:	52800042 	mov	w2, #0x2                   	// #2
 11341ac:	94001e18 	bl	113ba0c <pkcs_1_v1_5_decode>
 11341b0:	17fffff8 	b	1134190 <rsa_decrypt_key_ex+0x13c>
  LTC_ARGCHK(out    != NULL);
 11341b4:	5280021a 	mov	w26, #0x10                  	// #16
 11341b8:	17ffffe1 	b	113413c <rsa_decrypt_key_ex+0xe8>
    return CRYPT_PK_INVALID_PADDING;
 11341bc:	5280031a 	mov	w26, #0x18                  	// #24
 11341c0:	17ffffdf 	b	113413c <rsa_decrypt_key_ex+0xe8>
     return CRYPT_INVALID_PACKET;
 11341c4:	528000fa 	mov	w26, #0x7                   	// #7
 11341c8:	17ffffdd 	b	113413c <rsa_decrypt_key_ex+0xe8>
     return CRYPT_MEM;
 11341cc:	528001ba 	mov	w26, #0xd                   	// #13
 11341d0:	17ffffdb 	b	113413c <rsa_decrypt_key_ex+0xe8>

00000000011341d4 <rsa_encrypt_key_ex>:
                             unsigned char *out,      unsigned long *outlen,
                       const unsigned char *lparam,   unsigned long  lparamlen,
                             prng_state    *prng,     int            prng_idx,
                             int            hash_idx, int            padding,
                       const rsa_key       *key)
{
 11341d4:	d10243ff 	sub	sp, sp, #0x90
 11341d8:	a9017bfd 	stp	x29, x30, [sp, #16]
 11341dc:	910043fd 	add	x29, sp, #0x10
 11341e0:	a90253f3 	stp	x19, x20, [sp, #32]
 11341e4:	a9035bf5 	stp	x21, x22, [sp, #48]
 11341e8:	a90463f7 	stp	x23, x24, [sp, #64]
 11341ec:	a9056bf9 	stp	x25, x26, [sp, #80]
 11341f0:	a90673fb 	stp	x27, x28, [sp, #96]
 11341f4:	b94093fc 	ldr	w28, [sp, #144]
 11341f8:	f94053f8 	ldr	x24, [sp, #160]
  unsigned long modulus_bitlen, modulus_bytelen, x;
  int           err;

  LTC_ARGCHK(in     != NULL);
 11341fc:	b4000ae0 	cbz	x0, 1134358 <rsa_encrypt_key_ex+0x184>
 1134200:	aa0203f3 	mov	x19, x2
  LTC_ARGCHK(out    != NULL);
 1134204:	b4000aa2 	cbz	x2, 1134358 <rsa_encrypt_key_ex+0x184>
 1134208:	aa0303f4 	mov	x20, x3
  LTC_ARGCHK(outlen != NULL);
 113420c:	b4000a63 	cbz	x3, 1134358 <rsa_encrypt_key_ex+0x184>
  LTC_ARGCHK(key    != NULL);
 1134210:	b4000a58 	cbz	x24, 1134358 <rsa_encrypt_key_ex+0x184>
 1134214:	aa0003f5 	mov	x21, x0

  /* valid padding? */
  if ((padding != LTC_PKCS_1_V1_5) &&
 1134218:	b9409be0 	ldr	w0, [sp, #152]
 113421c:	51000400 	sub	w0, w0, #0x1
 1134220:	7100041f 	cmp	w0, #0x1
 1134224:	540009e8 	b.hi	1134360 <rsa_encrypt_key_ex+0x18c>  // b.pmore
 1134228:	aa0103f6 	mov	x22, x1
 113422c:	aa0403f9 	mov	x25, x4
 1134230:	aa0503fa 	mov	x26, x5
 1134234:	aa0603f7 	mov	x23, x6
 1134238:	2a0703fb 	mov	w27, w7
      (padding != LTC_PKCS_1_OAEP)) {
    return CRYPT_PK_INVALID_PADDING;
  }

  /* valid prng? */
  if ((err = prng_is_valid(prng_idx)) != CRYPT_OK) {
 113423c:	2a0703e0 	mov	w0, w7
 1134240:	97fff927 	bl	11326dc <prng_is_valid>
 1134244:	35000340 	cbnz	w0, 11342ac <rsa_encrypt_key_ex+0xd8>
     return err;
  }

  if (padding == LTC_PKCS_1_OAEP) {
 1134248:	b9409be0 	ldr	w0, [sp, #152]
 113424c:	7100081f 	cmp	w0, #0x2
 1134250:	54000280 	b.eq	11342a0 <rsa_encrypt_key_ex+0xcc>  // b.none
       return err;
    }
  }

  /* get modulus len in bits */
  modulus_bitlen = mp_count_bits( (key->N));
 1134254:	d0000120 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1134258:	f941d401 	ldr	x1, [x0, #936]
 113425c:	f9003fe1 	str	x1, [sp, #120]
 1134260:	f9400f00 	ldr	x0, [x24, #24]
 1134264:	f9403822 	ldr	x2, [x1, #112]
 1134268:	d63f0040 	blr	x2
 113426c:	93407c03 	sxtw	x3, w0

  /* outlen must be at least the size of the modulus */
  modulus_bytelen = mp_unsigned_bin_size( (key->N));
 1134270:	f9403fe1 	ldr	x1, [sp, #120]
  modulus_bitlen = mp_count_bits( (key->N));
 1134274:	f9003be3 	str	x3, [sp, #112]
  modulus_bytelen = mp_unsigned_bin_size( (key->N));
 1134278:	f9400f00 	ldr	x0, [x24, #24]
 113427c:	f9404c21 	ldr	x1, [x1, #152]
 1134280:	d63f0020 	blr	x1
  if (modulus_bytelen > *outlen) {
 1134284:	f9400281 	ldr	x1, [x20]
 1134288:	f9403be3 	ldr	x3, [sp, #112]
 113428c:	eb00003f 	cmp	x1, x0
 1134290:	540001e2 	b.cs	11342cc <rsa_encrypt_key_ex+0xf8>  // b.hs, b.nlast
     *outlen = modulus_bytelen;
 1134294:	f9000280 	str	x0, [x20]
     return CRYPT_BUFFER_OVERFLOW;
 1134298:	528000c0 	mov	w0, #0x6                   	// #6
 113429c:	14000004 	b	11342ac <rsa_encrypt_key_ex+0xd8>
    if ((err = hash_is_valid(hash_idx)) != CRYPT_OK) {
 11342a0:	2a1c03e0 	mov	w0, w28
 11342a4:	97fff8f4 	bl	1132674 <hash_is_valid>
 11342a8:	34fffd60 	cbz	w0, 1134254 <rsa_encrypt_key_ex+0x80>
    }
  }

  /* rsa exptmod the OAEP or PKCS #1 v1.5 pad */
  return ltc_mp.rsa_me(out, x, out, outlen, PK_PUBLIC, key);
}
 11342ac:	a9417bfd 	ldp	x29, x30, [sp, #16]
 11342b0:	a94253f3 	ldp	x19, x20, [sp, #32]
 11342b4:	a9435bf5 	ldp	x21, x22, [sp, #48]
 11342b8:	a94463f7 	ldp	x23, x24, [sp, #64]
 11342bc:	a9456bf9 	ldp	x25, x26, [sp, #80]
 11342c0:	a94673fb 	ldp	x27, x28, [sp, #96]
 11342c4:	910243ff 	add	sp, sp, #0x90
 11342c8:	d65f03c0 	ret
  if (padding == LTC_PKCS_1_OAEP) {
 11342cc:	b9409be0 	ldr	w0, [sp, #152]
 11342d0:	910223e7 	add	x7, sp, #0x88
    x = *outlen;
 11342d4:	f90047e1 	str	x1, [sp, #136]
  if (padding == LTC_PKCS_1_OAEP) {
 11342d8:	7100081f 	cmp	w0, #0x2
 11342dc:	540002e1 	b.ne	1134338 <rsa_encrypt_key_ex+0x164>  // b.any
    if ((err = pkcs_1_oaep_encode(in, inlen, lparam,
 11342e0:	a9001ff3 	stp	x19, x7, [sp]
 11342e4:	aa0303e4 	mov	x4, x3
 11342e8:	2a1b03e6 	mov	w6, w27
 11342ec:	aa1703e5 	mov	x5, x23
 11342f0:	aa1a03e3 	mov	x3, x26
 11342f4:	aa1903e2 	mov	x2, x25
 11342f8:	aa1603e1 	mov	x1, x22
 11342fc:	aa1503e0 	mov	x0, x21
 1134300:	2a1c03e7 	mov	w7, w28
 1134304:	94001b38 	bl	113afe4 <pkcs_1_oaep_encode>
 1134308:	35fffd20 	cbnz	w0, 11342ac <rsa_encrypt_key_ex+0xd8>
  return ltc_mp.rsa_me(out, x, out, outlen, PK_PUBLIC, key);
 113430c:	d0000120 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1134310:	aa1803e5 	mov	x5, x24
 1134314:	f94047e1 	ldr	x1, [sp, #136]
 1134318:	aa1403e3 	mov	x3, x20
 113431c:	f941d400 	ldr	x0, [x0, #936]
 1134320:	aa1303e2 	mov	x2, x19
 1134324:	52800004 	mov	w4, #0x0                   	// #0
 1134328:	f940c806 	ldr	x6, [x0, #400]
 113432c:	aa1303e0 	mov	x0, x19
 1134330:	d63f00c0 	blr	x6
 1134334:	17ffffde 	b	11342ac <rsa_encrypt_key_ex+0xd8>
    if ((err = pkcs_1_v1_5_encode(in, inlen, LTC_PKCS_1_EME,
 1134338:	aa1303e6 	mov	x6, x19
 113433c:	2a1b03e5 	mov	w5, w27
 1134340:	aa1703e4 	mov	x4, x23
 1134344:	aa1603e1 	mov	x1, x22
 1134348:	aa1503e0 	mov	x0, x21
 113434c:	52800042 	mov	w2, #0x2                   	// #2
 1134350:	94001df8 	bl	113bb30 <pkcs_1_v1_5_encode>
 1134354:	17ffffed 	b	1134308 <rsa_encrypt_key_ex+0x134>
  LTC_ARGCHK(in     != NULL);
 1134358:	52800200 	mov	w0, #0x10                  	// #16
 113435c:	17ffffd4 	b	11342ac <rsa_encrypt_key_ex+0xd8>
    return CRYPT_PK_INVALID_PADDING;
 1134360:	52800300 	mov	w0, #0x18                  	// #24
 1134364:	17ffffd2 	b	11342ac <rsa_encrypt_key_ex+0xd8>

0000000001134368 <rsa_exptmod>:
   @return CRYPT_OK if successful
*/
int rsa_exptmod(const unsigned char *in,   unsigned long inlen,
                      unsigned char *out,  unsigned long *outlen, int which,
                const rsa_key *key)
{
 1134368:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
 113436c:	910003fd 	mov	x29, sp
 1134370:	a90153f3 	stp	x19, x20, [sp, #16]
 1134374:	a9025bf5 	stp	x21, x22, [sp, #32]
 1134378:	a90363f7 	stp	x23, x24, [sp, #48]
 113437c:	a9046bf9 	stp	x25, x26, [sp, #64]
 1134380:	a90573fb 	stp	x27, x28, [sp, #80]
   void        *rnd, *rndi /* inverse of rnd */;
   #endif
   unsigned long x;
   int           err, has_crt_parameters;

   LTC_ARGCHK(in     != NULL);
 1134384:	b4001ea0 	cbz	x0, 1134758 <rsa_exptmod+0x3f0>
 1134388:	aa0203f7 	mov	x23, x2
   LTC_ARGCHK(out    != NULL);
 113438c:	b4001e62 	cbz	x2, 1134758 <rsa_exptmod+0x3f0>
 1134390:	aa0303f6 	mov	x22, x3
   LTC_ARGCHK(outlen != NULL);
 1134394:	b4001e23 	cbz	x3, 1134758 <rsa_exptmod+0x3f0>
 1134398:	aa0503f4 	mov	x20, x5
   LTC_ARGCHK(key    != NULL);
 113439c:	b4001de5 	cbz	x5, 1134758 <rsa_exptmod+0x3f0>
 11343a0:	aa0003f9 	mov	x25, x0
 11343a4:	aa0103f8 	mov	x24, x1
 11343a8:	2a0403fa 	mov	w26, w4

   /* is the key of the right type for the operation? */
   if (which == PK_PRIVATE && (key->type != PK_PRIVATE)) {
 11343ac:	7100049f 	cmp	w4, #0x1
 11343b0:	540000c1 	b.ne	11343c8 <rsa_exptmod+0x60>  // b.any
 11343b4:	b94000a0 	ldr	w0, [x5]
 11343b8:	7100041f 	cmp	w0, #0x1
 11343bc:	54000080 	b.eq	11343cc <rsa_exptmod+0x64>  // b.none
      return CRYPT_PK_NOT_PRIVATE;
 11343c0:	528001f3 	mov	w19, #0xf                   	// #15
 11343c4:	14000064 	b	1134554 <rsa_exptmod+0x1ec>
   }

   /* must be a private or public operation */
   if (which != PK_PRIVATE && which != PK_PUBLIC) {
 11343c8:	54001cc8 	b.hi	1134760 <rsa_exptmod+0x3f8>  // b.pmore
      return CRYPT_PK_INVALID_TYPE;
   }

   /* init and copy into tmp */
   if ((err = mp_init_multi(&tmp, &tmpa, &tmpb,
 11343cc:	910223e4 	add	x4, sp, #0x88
 11343d0:	910203e3 	add	x3, sp, #0x80
 11343d4:	9101e3e2 	add	x2, sp, #0x78
 11343d8:	9101c3e1 	add	x1, sp, #0x70
 11343dc:	9101a3e0 	add	x0, sp, #0x68
 11343e0:	d2800005 	mov	x5, #0x0                   	// #0
 11343e4:	97fff6b4 	bl	1131eb4 <ltc_init_multi>
 11343e8:	2a0003f3 	mov	w19, w0
 11343ec:	35000b40 	cbnz	w0, 1134554 <rsa_exptmod+0x1ec>
#ifdef LTC_RSA_BLINDING
                                               &rnd, &rndi,
#endif /* LTC_RSA_BLINDING */
                                                           NULL)) != CRYPT_OK)
        { return err; }
   if ((err = mp_read_unsigned_bin(tmp, (unsigned char *)in, (int)inlen)) != CRYPT_OK)
 11343f0:	d000013c 	adrp	x28, 115a000 <__scattered_array_1phys_mem_map+0x8>
 11343f4:	93407f18 	sxtw	x24, w24
 11343f8:	f94037e0 	ldr	x0, [sp, #104]
 11343fc:	aa1803e2 	mov	x2, x24
 1134400:	f941d79b 	ldr	x27, [x28, #936]
 1134404:	aa1903e1 	mov	x1, x25
 1134408:	aa1c03f5 	mov	x21, x28
 113440c:	f9405763 	ldr	x3, [x27, #168]
 1134410:	d63f0060 	blr	x3
 1134414:	2a0003f3 	mov	w19, w0
 1134418:	35000940 	cbnz	w0, 1134540 <rsa_exptmod+0x1d8>
        { goto error; }


   /* sanity check on the input */
   if (mp_cmp(key->N, tmp) == LTC_MP_LT) {
 113441c:	f9400e80 	ldr	x0, [x20, #24]
 1134420:	f9403362 	ldr	x2, [x27, #96]
 1134424:	f94037e1 	ldr	x1, [sp, #104]
 1134428:	d63f0040 	blr	x2
 113442c:	3100041f 	cmn	w0, #0x1
 1134430:	54001900 	b.eq	1134750 <rsa_exptmod+0x3e8>  // b.none
      err = CRYPT_PK_INVALID_SIZE;
      goto error;
   }

   /* are we using the private exponent and is the key optimized? */
   if (which == PK_PRIVATE) {
 1134434:	7100075f 	cmp	w26, #0x1
 1134438:	f9400e80 	ldr	x0, [x20, #24]
 113443c:	540014a1 	b.ne	11346d0 <rsa_exptmod+0x368>  // b.any
      #ifdef LTC_RSA_BLINDING
      /* do blinding */
      err = mp_rand(rnd, mp_get_digit_count(key->N));
 1134440:	f9402f61 	ldr	x1, [x27, #88]
 1134444:	f940d773 	ldr	x19, [x27, #424]
 1134448:	f94043fa 	ldr	x26, [sp, #128]
 113444c:	d63f0020 	blr	x1
 1134450:	2a0003e1 	mov	w1, w0
 1134454:	aa1a03e0 	mov	x0, x26
 1134458:	d63f0260 	blr	x19
 113445c:	2a0003f3 	mov	w19, w0
      if (err != CRYPT_OK) {
 1134460:	35000700 	cbnz	w0, 1134540 <rsa_exptmod+0x1d8>
             goto error;
      }

      /* rndi = 1/rnd mod N */
      err = mp_invmod(rnd, key->N, rndi);
 1134464:	a9480be0 	ldp	x0, x2, [sp, #128]
 1134468:	f9400e81 	ldr	x1, [x20, #24]
 113446c:	f9409763 	ldr	x3, [x27, #296]
 1134470:	d63f0060 	blr	x3
 1134474:	2a0003f3 	mov	w19, w0
      if (err != CRYPT_OK) {
 1134478:	35000640 	cbnz	w0, 1134540 <rsa_exptmod+0x1d8>
             goto error;
      }

      /* rnd = rnd^e */
      err = mp_exptmod( rnd, key->e, key->N, rnd);
 113447c:	f9400681 	ldr	x1, [x20, #8]
 1134480:	f9400e82 	ldr	x2, [x20, #24]
 1134484:	f94043e3 	ldr	x3, [sp, #128]
 1134488:	f940ab64 	ldr	x4, [x27, #336]
 113448c:	aa0303e0 	mov	x0, x3
 1134490:	d63f0080 	blr	x4
 1134494:	2a0003f3 	mov	w19, w0
      if (err != CRYPT_OK) {
 1134498:	35000540 	cbnz	w0, 1134540 <rsa_exptmod+0x1d8>
             goto error;
      }

      /* tmp = tmp*rnd mod N */
      err = mp_mulmod( tmp, rnd, key->N, tmp);
 113449c:	f9400e82 	ldr	x2, [x20, #24]
 11344a0:	f94037e3 	ldr	x3, [sp, #104]
 11344a4:	f94043e1 	ldr	x1, [sp, #128]
 11344a8:	aa0303e0 	mov	x0, x3
 11344ac:	f9408f64 	ldr	x4, [x27, #280]
 11344b0:	d63f0080 	blr	x4
 11344b4:	2a0003f3 	mov	w19, w0
      if (err != CRYPT_OK) {
 11344b8:	35000440 	cbnz	w0, 1134540 <rsa_exptmod+0x1d8>
             goto error;
      }
      #endif /* LTC_RSA_BLINDING */

      has_crt_parameters = (key->p != NULL) && (mp_get_digit_count(key->p) != 0) &&
 11344bc:	f9401280 	ldr	x0, [x20, #32]
                              (key->q != NULL) && (mp_get_digit_count(key->q) != 0) &&
                                 (key->dP != NULL) && (mp_get_digit_count(key->dP) != 0) &&
                                    (key->dQ != NULL) && (mp_get_digit_count(key->dQ) != 0) &&
                                       (key->qP != NULL) && (mp_get_digit_count(key->qP) != 0);
 11344c0:	b40005a0 	cbz	x0, 1134574 <rsa_exptmod+0x20c>
      has_crt_parameters = (key->p != NULL) && (mp_get_digit_count(key->p) != 0) &&
 11344c4:	f9402f61 	ldr	x1, [x27, #88]
 11344c8:	d63f0020 	blr	x1
 11344cc:	34000540 	cbz	w0, 1134574 <rsa_exptmod+0x20c>
                              (key->q != NULL) && (mp_get_digit_count(key->q) != 0) &&
 11344d0:	f9401680 	ldr	x0, [x20, #40]
      has_crt_parameters = (key->p != NULL) && (mp_get_digit_count(key->p) != 0) &&
 11344d4:	b4000500 	cbz	x0, 1134574 <rsa_exptmod+0x20c>
                              (key->q != NULL) && (mp_get_digit_count(key->q) != 0) &&
 11344d8:	f941d79a 	ldr	x26, [x28, #936]
 11344dc:	f9402f41 	ldr	x1, [x26, #88]
 11344e0:	d63f0020 	blr	x1
 11344e4:	34000480 	cbz	w0, 1134574 <rsa_exptmod+0x20c>
                                 (key->dP != NULL) && (mp_get_digit_count(key->dP) != 0) &&
 11344e8:	f9401e80 	ldr	x0, [x20, #56]
                              (key->q != NULL) && (mp_get_digit_count(key->q) != 0) &&
 11344ec:	b4000440 	cbz	x0, 1134574 <rsa_exptmod+0x20c>
                                 (key->dP != NULL) && (mp_get_digit_count(key->dP) != 0) &&
 11344f0:	f9402f41 	ldr	x1, [x26, #88]
 11344f4:	d63f0020 	blr	x1
 11344f8:	340003e0 	cbz	w0, 1134574 <rsa_exptmod+0x20c>
                                    (key->dQ != NULL) && (mp_get_digit_count(key->dQ) != 0) &&
 11344fc:	f9402280 	ldr	x0, [x20, #64]
                                 (key->dP != NULL) && (mp_get_digit_count(key->dP) != 0) &&
 1134500:	b40003a0 	cbz	x0, 1134574 <rsa_exptmod+0x20c>
                                    (key->dQ != NULL) && (mp_get_digit_count(key->dQ) != 0) &&
 1134504:	f9402f41 	ldr	x1, [x26, #88]
 1134508:	d63f0020 	blr	x1
 113450c:	34000340 	cbz	w0, 1134574 <rsa_exptmod+0x20c>
                                       (key->qP != NULL) && (mp_get_digit_count(key->qP) != 0);
 1134510:	f9401a80 	ldr	x0, [x20, #48]
                                    (key->dQ != NULL) && (mp_get_digit_count(key->dQ) != 0) &&
 1134514:	b4000300 	cbz	x0, 1134574 <rsa_exptmod+0x20c>
                                       (key->qP != NULL) && (mp_get_digit_count(key->qP) != 0);
 1134518:	f9402f41 	ldr	x1, [x26, #88]
 113451c:	d63f0020 	blr	x1
 1134520:	340002a0 	cbz	w0, 1134574 <rsa_exptmod+0x20c>
          * the private key is directly used to exptmod it
          */
         if ((err = mp_exptmod(tmp, key->d, key->N, tmp)) != CRYPT_OK)                              { goto error; }
      } else {
         /* tmpa = tmp^dP mod p */
         if ((err = mp_exptmod(tmp, key->dP, key->p, tmpa)) != CRYPT_OK)                            { goto error; }
 1134524:	a9468fe0 	ldp	x0, x3, [sp, #104]
 1134528:	f9401282 	ldr	x2, [x20, #32]
 113452c:	f9401e81 	ldr	x1, [x20, #56]
 1134530:	f940ab44 	ldr	x4, [x26, #336]
 1134534:	d63f0080 	blr	x4
 1134538:	2a0003f3 	mov	w19, w0
 113453c:	34000540 	cbz	w0, 11345e4 <rsa_exptmod+0x27c>
   if ((err = mp_to_unsigned_bin(tmp, out+(x-mp_unsigned_bin_size(tmp)))) != CRYPT_OK)               { goto error; }

   /* clean up and return */
   err = CRYPT_OK;
error:
   mp_clear_multi(
 1134540:	a9468fe4 	ldp	x4, x3, [sp, #104]
 1134544:	d2800005 	mov	x5, #0x0                   	// #0
 1134548:	a94787e2 	ldp	x2, x1, [sp, #120]
 113454c:	f94047e0 	ldr	x0, [sp, #136]
 1134550:	97fff6f3 	bl	113211c <ltc_deinit_multi>
#ifdef LTC_RSA_BLINDING
                  rndi, rnd,
#endif /* LTC_RSA_BLINDING */
                             tmpb, tmpa, tmp, NULL);
   return err;
}
 1134554:	2a1303e0 	mov	w0, w19
 1134558:	a94153f3 	ldp	x19, x20, [sp, #16]
 113455c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1134560:	a94363f7 	ldp	x23, x24, [sp, #48]
 1134564:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1134568:	a94573fb 	ldp	x27, x28, [sp, #80]
 113456c:	a8c97bfd 	ldp	x29, x30, [sp], #144
 1134570:	d65f03c0 	ret
         if ((err = mp_exptmod(tmp, key->d, key->N, tmp)) != CRYPT_OK)                              { goto error; }
 1134574:	f941d6a0 	ldr	x0, [x21, #936]
 1134578:	a9410a81 	ldp	x1, x2, [x20, #16]
 113457c:	f94037e3 	ldr	x3, [sp, #104]
 1134580:	f940a804 	ldr	x4, [x0, #336]
 1134584:	aa0303e0 	mov	x0, x3
 1134588:	d63f0080 	blr	x4
 113458c:	2a0003f3 	mov	w19, w0
 1134590:	35fffd80 	cbnz	w0, 1134540 <rsa_exptmod+0x1d8>
      err = mp_mulmod( tmp, rndi, key->N, tmp);
 1134594:	f941d6ba 	ldr	x26, [x21, #936]
 1134598:	f9400e82 	ldr	x2, [x20, #24]
 113459c:	f94037e3 	ldr	x3, [sp, #104]
 11345a0:	f94047e1 	ldr	x1, [sp, #136]
 11345a4:	aa0303e0 	mov	x0, x3
 11345a8:	f9408f44 	ldr	x4, [x26, #280]
 11345ac:	d63f0080 	blr	x4
      if (err != CRYPT_OK) {
 11345b0:	35000cc0 	cbnz	w0, 1134748 <rsa_exptmod+0x3e0>
      if (has_crt_parameters) {
 11345b4:	35000673 	cbnz	w19, 1134680 <rsa_exptmod+0x318>
   x = (unsigned long)mp_unsigned_bin_size(key->N);
 11345b8:	f941d6b5 	ldr	x21, [x21, #936]
 11345bc:	f9400e80 	ldr	x0, [x20, #24]
 11345c0:	f9404ea1 	ldr	x1, [x21, #152]
 11345c4:	d63f0020 	blr	x1
 11345c8:	aa0003f3 	mov	x19, x0
   if (x > *outlen) {
 11345cc:	f94002c0 	ldr	x0, [x22]
 11345d0:	eb13001f 	cmp	x0, x19
 11345d4:	54000902 	b.cs	11346f4 <rsa_exptmod+0x38c>  // b.hs, b.nlast
      *outlen = x;
 11345d8:	f90002d3 	str	x19, [x22]
      err = CRYPT_BUFFER_OVERFLOW;
 11345dc:	528000d3 	mov	w19, #0x6                   	// #6
      goto error;
 11345e0:	17ffffd8 	b	1134540 <rsa_exptmod+0x1d8>
         if ((err = mp_exptmod(tmp, key->dQ, key->q, tmpb)) != CRYPT_OK)                            { goto error; }
 11345e4:	f9401682 	ldr	x2, [x20, #40]
 11345e8:	f9402281 	ldr	x1, [x20, #64]
 11345ec:	f94037e0 	ldr	x0, [sp, #104]
 11345f0:	f9403fe3 	ldr	x3, [sp, #120]
 11345f4:	f940ab44 	ldr	x4, [x26, #336]
 11345f8:	d63f0080 	blr	x4
 11345fc:	2a0003f3 	mov	w19, w0
 1134600:	35fffa00 	cbnz	w0, 1134540 <rsa_exptmod+0x1d8>
         if ((err = mp_sub(tmpa, tmpb, tmp)) != CRYPT_OK)                                           { goto error; }
 1134604:	f941d79a 	ldr	x26, [x28, #936]
 1134608:	a94683e2 	ldp	x2, x0, [sp, #104]
 113460c:	f9403fe1 	ldr	x1, [sp, #120]
 1134610:	f9406343 	ldr	x3, [x26, #192]
 1134614:	d63f0060 	blr	x3
 1134618:	2a0003f3 	mov	w19, w0
 113461c:	35fff920 	cbnz	w0, 1134540 <rsa_exptmod+0x1d8>
         if ((err = mp_mulmod(tmp, key->qP, key->p, tmp)) != CRYPT_OK)                              { goto error; }
 1134620:	f9401282 	ldr	x2, [x20, #32]
 1134624:	f9401a81 	ldr	x1, [x20, #48]
 1134628:	f94037e3 	ldr	x3, [sp, #104]
 113462c:	f9408f44 	ldr	x4, [x26, #280]
 1134630:	aa0303e0 	mov	x0, x3
 1134634:	d63f0080 	blr	x4
 1134638:	2a0003f3 	mov	w19, w0
 113463c:	35fff820 	cbnz	w0, 1134540 <rsa_exptmod+0x1d8>
         if ((err = mp_mul(tmp, key->q, tmp)) != CRYPT_OK)                                          { goto error; }
 1134640:	f9401681 	ldr	x1, [x20, #40]
 1134644:	f94037e2 	ldr	x2, [sp, #104]
 1134648:	f9406b43 	ldr	x3, [x26, #208]
 113464c:	aa0203e0 	mov	x0, x2
 1134650:	d63f0060 	blr	x3
 1134654:	2a0003f3 	mov	w19, w0
 1134658:	35fff740 	cbnz	w0, 1134540 <rsa_exptmod+0x1d8>
         if ((err = mp_add(tmp, tmpb, tmp)) != CRYPT_OK)                                            { goto error; }
 113465c:	f94037e2 	ldr	x2, [sp, #104]
 1134660:	f9403fe1 	ldr	x1, [sp, #120]
 1134664:	aa0203e0 	mov	x0, x2
 1134668:	f9405b43 	ldr	x3, [x26, #176]
 113466c:	d63f0060 	blr	x3
 1134670:	2a0003f3 	mov	w19, w0
 1134674:	35fff660 	cbnz	w0, 1134540 <rsa_exptmod+0x1d8>
                                       (key->qP != NULL) && (mp_get_digit_count(key->qP) != 0);
 1134678:	52800033 	mov	w19, #0x1                   	// #1
 113467c:	17ffffc6 	b	1134594 <rsa_exptmod+0x22c>
         if ((err = mp_exptmod(tmp, key->e, key->N, tmpa)) != CRYPT_OK)                              { goto error; }
 1134680:	a9468fe0 	ldp	x0, x3, [sp, #104]
 1134684:	f9400681 	ldr	x1, [x20, #8]
 1134688:	f9400e82 	ldr	x2, [x20, #24]
 113468c:	f940ab44 	ldr	x4, [x26, #336]
 1134690:	d63f0080 	blr	x4
 1134694:	2a0003f3 	mov	w19, w0
 1134698:	35fff540 	cbnz	w0, 1134540 <rsa_exptmod+0x1d8>
         if ((err = mp_read_unsigned_bin(tmpb, (unsigned char *)in, (int)inlen)) != CRYPT_OK)        { goto error; }
 113469c:	f9403fe0 	ldr	x0, [sp, #120]
 11346a0:	aa1803e2 	mov	x2, x24
 11346a4:	f9405743 	ldr	x3, [x26, #168]
 11346a8:	aa1903e1 	mov	x1, x25
 11346ac:	d63f0060 	blr	x3
 11346b0:	2a0003f3 	mov	w19, w0
 11346b4:	35fff460 	cbnz	w0, 1134540 <rsa_exptmod+0x1d8>
         if (mp_cmp(tmpa, tmpb) != LTC_MP_EQ)                                     { err = CRYPT_ERROR; goto error; }
 11346b8:	a94707e0 	ldp	x0, x1, [sp, #112]
 11346bc:	f9403342 	ldr	x2, [x26, #96]
 11346c0:	d63f0040 	blr	x2
 11346c4:	34fff7a0 	cbz	w0, 11345b8 <rsa_exptmod+0x250>
 11346c8:	52800033 	mov	w19, #0x1                   	// #1
 11346cc:	17ffff9d 	b	1134540 <rsa_exptmod+0x1d8>
      if ((err = mp_exptmod(tmp, key->e, key->N, tmp)) != CRYPT_OK)                                { goto error; }
 11346d0:	f9400681 	ldr	x1, [x20, #8]
 11346d4:	aa0003e2 	mov	x2, x0
 11346d8:	f94037e3 	ldr	x3, [sp, #104]
 11346dc:	f940ab64 	ldr	x4, [x27, #336]
 11346e0:	aa0303e0 	mov	x0, x3
 11346e4:	d63f0080 	blr	x4
 11346e8:	2a0003f3 	mov	w19, w0
 11346ec:	34fff660 	cbz	w0, 11345b8 <rsa_exptmod+0x250>
 11346f0:	17ffff94 	b	1134540 <rsa_exptmod+0x1d8>
   if (mp_unsigned_bin_size(tmp) > mp_unsigned_bin_size(key->N)) {
 11346f4:	f94037e0 	ldr	x0, [sp, #104]
 11346f8:	f9404ea1 	ldr	x1, [x21, #152]
 11346fc:	d63f0020 	blr	x1
 1134700:	aa0003f8 	mov	x24, x0
 1134704:	f9400e80 	ldr	x0, [x20, #24]
 1134708:	f9404ea1 	ldr	x1, [x21, #152]
 113470c:	d63f0020 	blr	x1
 1134710:	eb00031f 	cmp	x24, x0
 1134714:	54fffda8 	b.hi	11346c8 <rsa_exptmod+0x360>  // b.pmore
   *outlen = x;
 1134718:	f90002d3 	str	x19, [x22]
   zeromem(out, x);
 113471c:	aa1303e1 	mov	x1, x19
 1134720:	aa1703e0 	mov	x0, x23
 1134724:	97fff748 	bl	1132444 <zeromem>
   if ((err = mp_to_unsigned_bin(tmp, out+(x-mp_unsigned_bin_size(tmp)))) != CRYPT_OK)               { goto error; }
 1134728:	a949daa1 	ldp	x1, x22, [x21, #152]
 113472c:	f94037f4 	ldr	x20, [sp, #104]
 1134730:	aa1403e0 	mov	x0, x20
 1134734:	d63f0020 	blr	x1
 1134738:	cb000261 	sub	x1, x19, x0
 113473c:	8b0102e1 	add	x1, x23, x1
 1134740:	aa1403e0 	mov	x0, x20
 1134744:	d63f02c0 	blr	x22
 1134748:	2a0003f3 	mov	w19, w0
 113474c:	17ffff7d 	b	1134540 <rsa_exptmod+0x1d8>
      err = CRYPT_PK_INVALID_SIZE;
 1134750:	528002d3 	mov	w19, #0x16                  	// #22
 1134754:	17ffff7b 	b	1134540 <rsa_exptmod+0x1d8>
   LTC_ARGCHK(in     != NULL);
 1134758:	52800213 	mov	w19, #0x10                  	// #16
 113475c:	17ffff7e 	b	1134554 <rsa_exptmod+0x1ec>
      return CRYPT_PK_INVALID_TYPE;
 1134760:	52800253 	mov	w19, #0x12                  	// #18
 1134764:	17ffff7c 	b	1134554 <rsa_exptmod+0x1ec>

0000000001134768 <rsa_free>:
  Free an RSA key from memory
  @param key   The RSA key to free
*/
void rsa_free(rsa_key *key)
{
   LTC_ARGCHKVD(key != NULL);
 1134768:	b4000220 	cbz	x0, 11347ac <rsa_free+0x44>
{
 113476c:	d10083ff 	sub	sp, sp, #0x20
   mp_cleanup_multi(&key->q, &key->p, &key->qP, &key->dP, &key->dQ, &key->N, &key->d, &key->e, NULL);
 1134770:	91002007 	add	x7, x0, #0x8
 1134774:	91004006 	add	x6, x0, #0x10
 1134778:	91006005 	add	x5, x0, #0x18
 113477c:	91010004 	add	x4, x0, #0x40
 1134780:	9100e003 	add	x3, x0, #0x38
{
 1134784:	a9017bfd 	stp	x29, x30, [sp, #16]
 1134788:	910043fd 	add	x29, sp, #0x10
   mp_cleanup_multi(&key->q, &key->p, &key->qP, &key->dP, &key->dQ, &key->N, &key->d, &key->e, NULL);
 113478c:	9100c002 	add	x2, x0, #0x30
 1134790:	91008001 	add	x1, x0, #0x20
 1134794:	f90003ff 	str	xzr, [sp]
 1134798:	9100a000 	add	x0, x0, #0x28
 113479c:	97fff685 	bl	11321b0 <ltc_cleanup_multi>
}
 11347a0:	a9417bfd 	ldp	x29, x30, [sp, #16]
 11347a4:	910083ff 	add	sp, sp, #0x20
 11347a8:	d65f03c0 	ret
 11347ac:	d65f03c0 	ret

00000000011347b0 <rsa_make_key>:
   @param e        The "e" value (public key).  e==65537 is a good choice
   @param key      [out] Destination of a newly created private key pair
   @return CRYPT_OK if successful, upon error all allocated ram is freed
*/
int rsa_make_key(prng_state *prng, int wprng, int size, long e, rsa_key *key)
{
 11347b0:	d10243ff 	sub	sp, sp, #0x90
 11347b4:	a9017bfd 	stp	x29, x30, [sp, #16]
 11347b8:	910043fd 	add	x29, sp, #0x10
 11347bc:	a9056bf9 	stp	x25, x26, [sp, #80]
 11347c0:	aa0003fa 	mov	x26, x0
   void *p, *q, *tmp1, *tmp2, *tmp3;
   int    err;

   LTC_ARGCHK(ltc_mp.name != NULL);
 11347c4:	d0000120 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
{
 11347c8:	a9035bf5 	stp	x21, x22, [sp, #48]
 11347cc:	2a0103f9 	mov	w25, w1
   LTC_ARGCHK(ltc_mp.name != NULL);
 11347d0:	f941d416 	ldr	x22, [x0, #936]
{
 11347d4:	a90253f3 	stp	x19, x20, [sp, #32]
 11347d8:	a90463f7 	stp	x23, x24, [sp, #64]
   LTC_ARGCHK(ltc_mp.name != NULL);
 11347dc:	f94002c1 	ldr	x1, [x22]
 11347e0:	b4001801 	cbz	x1, 1134ae0 <rsa_make_key+0x330>
 11347e4:	aa0403f4 	mov	x20, x4
   LTC_ARGCHK(key         != NULL);
 11347e8:	b40017c4 	cbz	x4, 1134ae0 <rsa_make_key+0x330>
 11347ec:	2a0203f8 	mov	w24, w2
   LTC_ARGCHK(size        > 0);
 11347f0:	7100005f 	cmp	w2, #0x0
 11347f4:	5400176d 	b.le	1134ae0 <rsa_make_key+0x330>
 11347f8:	aa0303f7 	mov	x23, x3

   if ((e < 3) || ((e & 1) == 0)) {
 11347fc:	f100087f 	cmp	x3, #0x2
 1134800:	5400170d 	b.le	1134ae0 <rsa_make_key+0x330>
 1134804:	360016e3 	tbz	w3, #0, 1134ae0 <rsa_make_key+0x330>
 1134808:	aa0003f5 	mov	x21, x0
      return CRYPT_INVALID_ARG;
   }

   if ((err = prng_is_valid(wprng)) != CRYPT_OK) {
 113480c:	2a1903e0 	mov	w0, w25
 1134810:	97fff7b3 	bl	11326dc <prng_is_valid>
 1134814:	2a0003f3 	mov	w19, w0
 1134818:	350014e0 	cbnz	w0, 1134ab4 <rsa_make_key+0x304>
      return err;
   }

   if ((err = mp_init_multi(&p, &q, &tmp1, &tmp2, &tmp3, NULL)) != CRYPT_OK) {
 113481c:	910223e4 	add	x4, sp, #0x88
 1134820:	910203e3 	add	x3, sp, #0x80
 1134824:	9101e3e2 	add	x2, sp, #0x78
 1134828:	9101c3e1 	add	x1, sp, #0x70
 113482c:	9101a3e0 	add	x0, sp, #0x68
 1134830:	d2800005 	mov	x5, #0x0                   	// #0
 1134834:	97fff5a0 	bl	1131eb4 <ltc_init_multi>
 1134838:	2a0003f3 	mov	w19, w0
 113483c:	350013c0 	cbnz	w0, 1134ab4 <rsa_make_key+0x304>
      return err;
   }

   /* make primes p and q (optimization provided by Wayne Scott) */
   if ((err = mp_set_int(tmp3, e)) != CRYPT_OK)                      { goto cleanup; }  /* tmp3 = e */
 1134840:	f94022c2 	ldr	x2, [x22, #64]
 1134844:	aa1703e1 	mov	x1, x23
 1134848:	f94047e0 	ldr	x0, [sp, #136]
 113484c:	d63f0040 	blr	x2
 1134850:	2a0003f3 	mov	w19, w0
 1134854:	35001260 	cbnz	w0, 1134aa0 <rsa_make_key+0x2f0>

   /* make prime "p" */
   do {
       if ((err = rand_prime( p, size/2, prng, wprng)) != CRYPT_OK)  { goto cleanup; }
 1134858:	13017f18 	asr	w24, w24, #1
 113485c:	93407f18 	sxtw	x24, w24
 1134860:	f94037e0 	ldr	x0, [sp, #104]
 1134864:	2a1903e3 	mov	w3, w25
 1134868:	aa1a03e2 	mov	x2, x26
 113486c:	aa1803e1 	mov	x1, x24
 1134870:	94001053 	bl	11389bc <rand_prime>
 1134874:	2a0003f3 	mov	w19, w0
 1134878:	35001140 	cbnz	w0, 1134aa0 <rsa_make_key+0x2f0>
       if ((err = mp_sub_d( p, 1,  tmp1)) != CRYPT_OK)               { goto cleanup; }  /* tmp1 = p-1 */
 113487c:	f94037e0 	ldr	x0, [sp, #104]
 1134880:	d2800021 	mov	x1, #0x1                   	// #1
 1134884:	f9403fe2 	ldr	x2, [sp, #120]
 1134888:	f94066c3 	ldr	x3, [x22, #200]
 113488c:	d63f0060 	blr	x3
 1134890:	2a0003f3 	mov	w19, w0
 1134894:	35001060 	cbnz	w0, 1134aa0 <rsa_make_key+0x2f0>
       if ((err = mp_gcd( tmp1,  tmp3,  tmp2)) != CRYPT_OK)          { goto cleanup; }  /* tmp2 = gcd(p-1, e) */
 1134898:	a9478be0 	ldp	x0, x2, [sp, #120]
 113489c:	f94047e1 	ldr	x1, [sp, #136]
 11348a0:	f94086c3 	ldr	x3, [x22, #264]
 11348a4:	d63f0060 	blr	x3
 11348a8:	2a0003f3 	mov	w19, w0
 11348ac:	35000fa0 	cbnz	w0, 1134aa0 <rsa_make_key+0x2f0>
   } while (mp_cmp_d( tmp2, 1) != 0);                                                  /* while e divides p-1 */
 11348b0:	f94036c2 	ldr	x2, [x22, #104]
 11348b4:	d2800021 	mov	x1, #0x1                   	// #1
 11348b8:	f94043e0 	ldr	x0, [sp, #128]
 11348bc:	d63f0040 	blr	x2
 11348c0:	35fffd00 	cbnz	w0, 1134860 <rsa_make_key+0xb0>

   /* make prime "q" */
   do {
       if ((err = rand_prime( q, size/2, prng, wprng)) != CRYPT_OK)  { goto cleanup; }
       if ((err = mp_sub_d( q, 1,  tmp1)) != CRYPT_OK)               { goto cleanup; } /* tmp1 = q-1 */
 11348c4:	f941d6b6 	ldr	x22, [x21, #936]
       if ((err = rand_prime( q, size/2, prng, wprng)) != CRYPT_OK)  { goto cleanup; }
 11348c8:	2a1903e3 	mov	w3, w25
 11348cc:	f9403be0 	ldr	x0, [sp, #112]
 11348d0:	aa1a03e2 	mov	x2, x26
 11348d4:	aa1803e1 	mov	x1, x24
 11348d8:	94001039 	bl	11389bc <rand_prime>
 11348dc:	2a0003f3 	mov	w19, w0
 11348e0:	35000e00 	cbnz	w0, 1134aa0 <rsa_make_key+0x2f0>
       if ((err = mp_sub_d( q, 1,  tmp1)) != CRYPT_OK)               { goto cleanup; } /* tmp1 = q-1 */
 11348e4:	a9470be0 	ldp	x0, x2, [sp, #112]
 11348e8:	d2800021 	mov	x1, #0x1                   	// #1
 11348ec:	f94066c3 	ldr	x3, [x22, #200]
 11348f0:	d63f0060 	blr	x3
 11348f4:	2a0003f3 	mov	w19, w0
 11348f8:	35000d40 	cbnz	w0, 1134aa0 <rsa_make_key+0x2f0>
       if ((err = mp_gcd( tmp1,  tmp3,  tmp2)) != CRYPT_OK)          { goto cleanup; } /* tmp2 = gcd(q-1, e) */
 11348fc:	a9478be0 	ldp	x0, x2, [sp, #120]
 1134900:	f94047e1 	ldr	x1, [sp, #136]
 1134904:	f94086c3 	ldr	x3, [x22, #264]
 1134908:	d63f0060 	blr	x3
 113490c:	2a0003f3 	mov	w19, w0
 1134910:	35000c80 	cbnz	w0, 1134aa0 <rsa_make_key+0x2f0>
   } while (mp_cmp_d( tmp2, 1) != 0);                                                 /* while e divides q-1 */
 1134914:	f94036c2 	ldr	x2, [x22, #104]
 1134918:	d2800021 	mov	x1, #0x1                   	// #1
 113491c:	f94043e0 	ldr	x0, [sp, #128]
 1134920:	d63f0040 	blr	x2
 1134924:	35fffd20 	cbnz	w0, 11348c8 <rsa_make_key+0x118>

   /* tmp1 = lcm(p-1, q-1) */
   if ((err = mp_sub_d( p, 1,  tmp2)) != CRYPT_OK)                   { goto cleanup; } /* tmp2 = p-1 */
 1134928:	f94037e0 	ldr	x0, [sp, #104]
 113492c:	d2800021 	mov	x1, #0x1                   	// #1
 1134930:	f94043e2 	ldr	x2, [sp, #128]
 1134934:	f94066c3 	ldr	x3, [x22, #200]
 1134938:	d63f0060 	blr	x3
 113493c:	2a0003f3 	mov	w19, w0
 1134940:	35000b00 	cbnz	w0, 1134aa0 <rsa_make_key+0x2f0>
                                                                                      /* tmp1 = q-1 (previous do/while loop) */
   if ((err = mp_lcm( tmp1,  tmp2,  tmp1)) != CRYPT_OK)              { goto cleanup; } /* tmp1 = lcm(p-1, q-1) */
 1134944:	a94787e2 	ldp	x2, x1, [sp, #120]
 1134948:	f9408ac3 	ldr	x3, [x22, #272]
 113494c:	aa0203e0 	mov	x0, x2
 1134950:	d63f0060 	blr	x3
 1134954:	2a0003f3 	mov	w19, w0
 1134958:	35000a40 	cbnz	w0, 1134aa0 <rsa_make_key+0x2f0>

   /* make key */
   if ((err = mp_init_multi(&key->e, &key->d, &key->N, &key->dQ, &key->dP, &key->qP, &key->p, &key->q, NULL)) != CRYPT_OK) {
 113495c:	f90003ff 	str	xzr, [sp]
 1134960:	9100a287 	add	x7, x20, #0x28
 1134964:	91008286 	add	x6, x20, #0x20
 1134968:	9100c285 	add	x5, x20, #0x30
 113496c:	9100e284 	add	x4, x20, #0x38
 1134970:	91010283 	add	x3, x20, #0x40
 1134974:	91006282 	add	x2, x20, #0x18
 1134978:	91004281 	add	x1, x20, #0x10
 113497c:	91002280 	add	x0, x20, #0x8
 1134980:	97fff54d 	bl	1131eb4 <ltc_init_multi>
 1134984:	2a0003f3 	mov	w19, w0
 1134988:	35000a60 	cbnz	w0, 1134ad4 <rsa_make_key+0x324>
      goto errkey;
   }

   if ((err = mp_set_int( key->e, e)) != CRYPT_OK)                     { goto errkey; } /* key->e =  e */
 113498c:	f9400680 	ldr	x0, [x20, #8]
 1134990:	aa1703e1 	mov	x1, x23
 1134994:	f94022c2 	ldr	x2, [x22, #64]
 1134998:	d63f0040 	blr	x2
 113499c:	2a0003f3 	mov	w19, w0
 11349a0:	350009a0 	cbnz	w0, 1134ad4 <rsa_make_key+0x324>
   if ((err = mp_invmod( key->e,  tmp1,  key->d)) != CRYPT_OK)         { goto errkey; } /* key->d = 1/e mod lcm(p-1,q-1) */
 11349a4:	a9408a80 	ldp	x0, x2, [x20, #8]
 11349a8:	f9403fe1 	ldr	x1, [sp, #120]
 11349ac:	f94096c3 	ldr	x3, [x22, #296]
 11349b0:	d63f0060 	blr	x3
 11349b4:	2a0003f3 	mov	w19, w0
 11349b8:	350008e0 	cbnz	w0, 1134ad4 <rsa_make_key+0x324>
   if ((err = mp_mul( p,  q,  key->N)) != CRYPT_OK)                    { goto errkey; } /* key->N = pq */
 11349bc:	a94687e0 	ldp	x0, x1, [sp, #104]
 11349c0:	f9400e82 	ldr	x2, [x20, #24]
 11349c4:	f9406ac3 	ldr	x3, [x22, #208]
 11349c8:	d63f0060 	blr	x3
 11349cc:	2a0003f3 	mov	w19, w0
 11349d0:	35000820 	cbnz	w0, 1134ad4 <rsa_make_key+0x324>

   /* optimize for CRT now */
   /* find d mod q-1 and d mod p-1 */
   if ((err = mp_sub_d( p, 1,  tmp1)) != CRYPT_OK)                     { goto errkey; } /* tmp1 = q-1 */
 11349d4:	f941d6b5 	ldr	x21, [x21, #936]
 11349d8:	d2800021 	mov	x1, #0x1                   	// #1
 11349dc:	f94037e0 	ldr	x0, [sp, #104]
 11349e0:	f9403fe2 	ldr	x2, [sp, #120]
 11349e4:	f94066a3 	ldr	x3, [x21, #200]
 11349e8:	d63f0060 	blr	x3
 11349ec:	2a0003f3 	mov	w19, w0
 11349f0:	35000720 	cbnz	w0, 1134ad4 <rsa_make_key+0x324>
   if ((err = mp_sub_d( q, 1,  tmp2)) != CRYPT_OK)                     { goto errkey; } /* tmp2 = p-1 */
 11349f4:	f9403be0 	ldr	x0, [sp, #112]
 11349f8:	d2800021 	mov	x1, #0x1                   	// #1
 11349fc:	f94043e2 	ldr	x2, [sp, #128]
 1134a00:	f94066a3 	ldr	x3, [x21, #200]
 1134a04:	d63f0060 	blr	x3
 1134a08:	2a0003f3 	mov	w19, w0
 1134a0c:	35000640 	cbnz	w0, 1134ad4 <rsa_make_key+0x324>
   if ((err = mp_mod( key->d,  tmp1,  key->dP)) != CRYPT_OK)           { goto errkey; } /* dP = d mod p-1 */
 1134a10:	f9400a80 	ldr	x0, [x20, #16]
 1134a14:	d2800002 	mov	x2, #0x0                   	// #0
 1134a18:	f9401e83 	ldr	x3, [x20, #56]
 1134a1c:	f9403fe1 	ldr	x1, [sp, #120]
 1134a20:	f9407aa4 	ldr	x4, [x21, #240]
 1134a24:	d63f0080 	blr	x4
 1134a28:	2a0003f3 	mov	w19, w0
 1134a2c:	35000540 	cbnz	w0, 1134ad4 <rsa_make_key+0x324>
   if ((err = mp_mod( key->d,  tmp2,  key->dQ)) != CRYPT_OK)           { goto errkey; } /* dQ = d mod q-1 */
 1134a30:	f9400a80 	ldr	x0, [x20, #16]
 1134a34:	d2800002 	mov	x2, #0x0                   	// #0
 1134a38:	f9402283 	ldr	x3, [x20, #64]
 1134a3c:	f94043e1 	ldr	x1, [sp, #128]
 1134a40:	f9407aa4 	ldr	x4, [x21, #240]
 1134a44:	d63f0080 	blr	x4
 1134a48:	2a0003f3 	mov	w19, w0
 1134a4c:	35000440 	cbnz	w0, 1134ad4 <rsa_make_key+0x324>
   if ((err = mp_invmod( q,  p,  key->qP)) != CRYPT_OK)                { goto errkey; } /* qP = 1/q mod p */
 1134a50:	a94683e1 	ldp	x1, x0, [sp, #104]
 1134a54:	f9401a82 	ldr	x2, [x20, #48]
 1134a58:	f94096a3 	ldr	x3, [x21, #296]
 1134a5c:	d63f0060 	blr	x3
 1134a60:	2a0003f3 	mov	w19, w0
 1134a64:	35000380 	cbnz	w0, 1134ad4 <rsa_make_key+0x324>

   if ((err = mp_copy( p,  key->p)) != CRYPT_OK)                       { goto errkey; }
 1134a68:	f9401281 	ldr	x1, [x20, #32]
 1134a6c:	f9401ea2 	ldr	x2, [x21, #56]
 1134a70:	f94037e0 	ldr	x0, [sp, #104]
 1134a74:	d63f0040 	blr	x2
 1134a78:	2a0003f3 	mov	w19, w0
 1134a7c:	350002c0 	cbnz	w0, 1134ad4 <rsa_make_key+0x324>
   if ((err = mp_copy( q,  key->q)) != CRYPT_OK)                       { goto errkey; }
 1134a80:	f9401681 	ldr	x1, [x20, #40]
 1134a84:	f9401ea2 	ldr	x2, [x21, #56]
 1134a88:	f9403be0 	ldr	x0, [sp, #112]
 1134a8c:	d63f0040 	blr	x2
 1134a90:	2a0003f3 	mov	w19, w0
 1134a94:	35000200 	cbnz	w0, 1134ad4 <rsa_make_key+0x324>

   /* set key type (in this case it's CRT optimized) */
   key->type = PK_PRIVATE;
 1134a98:	52800020 	mov	w0, #0x1                   	// #1
 1134a9c:	b9000280 	str	w0, [x20]
   err       = CRYPT_OK;
   goto cleanup;
errkey:
   rsa_free(key);
cleanup:
   mp_clear_multi(tmp3, tmp2, tmp1, q, p, NULL);
 1134aa0:	a9468fe4 	ldp	x4, x3, [sp, #104]
 1134aa4:	d2800005 	mov	x5, #0x0                   	// #0
 1134aa8:	a94787e2 	ldp	x2, x1, [sp, #120]
 1134aac:	f94047e0 	ldr	x0, [sp, #136]
 1134ab0:	97fff59b 	bl	113211c <ltc_deinit_multi>
   return err;
}
 1134ab4:	2a1303e0 	mov	w0, w19
 1134ab8:	a9417bfd 	ldp	x29, x30, [sp, #16]
 1134abc:	a94253f3 	ldp	x19, x20, [sp, #32]
 1134ac0:	a9435bf5 	ldp	x21, x22, [sp, #48]
 1134ac4:	a94463f7 	ldp	x23, x24, [sp, #64]
 1134ac8:	a9456bf9 	ldp	x25, x26, [sp, #80]
 1134acc:	910243ff 	add	sp, sp, #0x90
 1134ad0:	d65f03c0 	ret
   rsa_free(key);
 1134ad4:	aa1403e0 	mov	x0, x20
 1134ad8:	97ffff24 	bl	1134768 <rsa_free>
 1134adc:	17fffff1 	b	1134aa0 <rsa_make_key+0x2f0>
   LTC_ARGCHK(ltc_mp.name != NULL);
 1134ae0:	52800213 	mov	w19, #0x10                  	// #16
 1134ae4:	17fffff4 	b	1134ab4 <rsa_make_key+0x304>

0000000001134ae8 <rsa_sign_hash_ex>:
                           unsigned char *out,      unsigned long *outlen,
                           int            padding,
                           prng_state    *prng,     int            prng_idx,
                           int            hash_idx, unsigned long  saltlen,
                     const rsa_key *key)
{
 1134ae8:	d10743ff 	sub	sp, sp, #0x1d0
 1134aec:	a9017bfd 	stp	x29, x30, [sp, #16]
 1134af0:	910043fd 	add	x29, sp, #0x10
 1134af4:	a90253f3 	stp	x19, x20, [sp, #32]
 1134af8:	a9035bf5 	stp	x21, x22, [sp, #48]
 1134afc:	a90463f7 	stp	x23, x24, [sp, #64]
 1134b00:	a9056bf9 	stp	x25, x26, [sp, #80]
 1134b04:	a90673fb 	stp	x27, x28, [sp, #96]
 1134b08:	f9003be5 	str	x5, [sp, #112]
 1134b0c:	f940eff7 	ldr	x23, [sp, #472]
   unsigned long modulus_bitlen, modulus_bytelen, x, y;
   int           err;

   LTC_ARGCHK(in       != NULL);
 1134b10:	b4001240 	cbz	x0, 1134d58 <rsa_sign_hash_ex+0x270>
 1134b14:	aa0203f6 	mov	x22, x2
   LTC_ARGCHK(out      != NULL);
 1134b18:	b4001202 	cbz	x2, 1134d58 <rsa_sign_hash_ex+0x270>
 1134b1c:	aa0303f5 	mov	x21, x3
   LTC_ARGCHK(outlen   != NULL);
 1134b20:	b40011c3 	cbz	x3, 1134d58 <rsa_sign_hash_ex+0x270>
   LTC_ARGCHK(key      != NULL);
 1134b24:	b40011b7 	cbz	x23, 1134d58 <rsa_sign_hash_ex+0x270>
 1134b28:	aa0003fb 	mov	x27, x0

   /* valid padding? */
   if ((padding != LTC_PKCS_1_V1_5) &&
 1134b2c:	121e7880 	and	w0, w4, #0xfffffffd
 1134b30:	aa0103f8 	mov	x24, x1
 1134b34:	2a0403f4 	mov	w20, w4
 1134b38:	2a0603fa 	mov	w26, w6
 1134b3c:	2a0703fc 	mov	w28, w7
 1134b40:	7100041f 	cmp	w0, #0x1
 1134b44:	540002a0 	b.eq	1134b98 <rsa_sign_hash_ex+0xb0>  // b.none
       (padding != LTC_PKCS_1_PSS) &&
 1134b48:	7100109f 	cmp	w4, #0x4
 1134b4c:	540010a1 	b.ne	1134d60 <rsa_sign_hash_ex+0x278>  // b.any
        return err;
     }
   }

   /* get modulus len in bits */
   modulus_bitlen = mp_count_bits((key->N));
 1134b50:	d0000133 	adrp	x19, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1134b54:	f9400ee0 	ldr	x0, [x23, #24]
 1134b58:	f941d662 	ldr	x2, [x19, #936]
 1134b5c:	f9003fe2 	str	x2, [sp, #120]
 1134b60:	f9403841 	ldr	x1, [x2, #112]
 1134b64:	d63f0020 	blr	x1
 1134b68:	93407c19 	sxtw	x25, w0

  /* outlen must be at least the size of the modulus */
  modulus_bytelen = mp_unsigned_bin_size((key->N));
 1134b6c:	f9403fe2 	ldr	x2, [sp, #120]
 1134b70:	f9400ee0 	ldr	x0, [x23, #24]
 1134b74:	f9404c41 	ldr	x1, [x2, #152]
 1134b78:	d63f0020 	blr	x1
  if (modulus_bytelen > *outlen) {
 1134b7c:	f94002a1 	ldr	x1, [x21]
 1134b80:	f9403fe2 	ldr	x2, [sp, #120]
 1134b84:	eb00003f 	cmp	x1, x0
 1134b88:	540002e2 	b.cs	1134be4 <rsa_sign_hash_ex+0xfc>  // b.hs, b.nlast
     *outlen = modulus_bytelen;
     return CRYPT_BUFFER_OVERFLOW;
 1134b8c:	528000d3 	mov	w19, #0x6                   	// #6
     *outlen = modulus_bytelen;
 1134b90:	f90002a0 	str	x0, [x21]
     return CRYPT_BUFFER_OVERFLOW;
 1134b94:	1400000b 	b	1134bc0 <rsa_sign_hash_ex+0xd8>
   if (padding == LTC_PKCS_1_PSS) {
 1134b98:	71000c9f 	cmp	w4, #0x3
 1134b9c:	540000a1 	b.ne	1134bb0 <rsa_sign_hash_ex+0xc8>  // b.any
     if ((err = prng_is_valid(prng_idx)) != CRYPT_OK) {
 1134ba0:	2a0603e0 	mov	w0, w6
 1134ba4:	97fff6ce 	bl	11326dc <prng_is_valid>
 1134ba8:	2a0003f3 	mov	w19, w0
 1134bac:	350000a0 	cbnz	w0, 1134bc0 <rsa_sign_hash_ex+0xd8>
     if ((err = hash_is_valid(hash_idx)) != CRYPT_OK) {
 1134bb0:	2a1c03e0 	mov	w0, w28
 1134bb4:	97fff6b0 	bl	1132674 <hash_is_valid>
 1134bb8:	2a0003f3 	mov	w19, w0
 1134bbc:	34fffca0 	cbz	w0, 1134b50 <rsa_sign_hash_ex+0x68>
    }
  }

  /* RSA encode it */
  return ltc_mp.rsa_me(out, x, out, outlen, PK_PRIVATE, key);
}
 1134bc0:	2a1303e0 	mov	w0, w19
 1134bc4:	a9417bfd 	ldp	x29, x30, [sp, #16]
 1134bc8:	a94253f3 	ldp	x19, x20, [sp, #32]
 1134bcc:	a9435bf5 	ldp	x21, x22, [sp, #48]
 1134bd0:	a94463f7 	ldp	x23, x24, [sp, #64]
 1134bd4:	a9456bf9 	ldp	x25, x26, [sp, #80]
 1134bd8:	a94673fb 	ldp	x27, x28, [sp, #96]
 1134bdc:	910743ff 	add	sp, sp, #0x1d0
 1134be0:	d65f03c0 	ret
  if (padding == LTC_PKCS_1_PSS) {
 1134be4:	71000e9f 	cmp	w20, #0x3
 1134be8:	54000361 	b.ne	1134c54 <rsa_sign_hash_ex+0x16c>  // b.any
    if ((err = pkcs_1_pss_encode(in, inlen, saltlen, prng, prng_idx,
 1134bec:	f9403be3 	ldr	x3, [sp, #112]
 1134bf0:	9104c3e0 	add	x0, sp, #0x130
 1134bf4:	f940ebe2 	ldr	x2, [sp, #464]
 1134bf8:	f90003e0 	str	x0, [sp]
 1134bfc:	aa1603e7 	mov	x7, x22
 1134c00:	aa1903e6 	mov	x6, x25
 1134c04:	2a1c03e5 	mov	w5, w28
 1134c08:	2a1a03e4 	mov	w4, w26
 1134c0c:	aa1b03e0 	mov	x0, x27
    x = *outlen;
 1134c10:	f9009be1 	str	x1, [sp, #304]
    if ((err = pkcs_1_pss_encode(in, inlen, saltlen, prng, prng_idx,
 1134c14:	aa1803e1 	mov	x1, x24
 1134c18:	94001a97 	bl	113b674 <pkcs_1_pss_encode>
 1134c1c:	2a0003f3 	mov	w19, w0
 1134c20:	35fffd13 	cbnz	w19, 1134bc0 <rsa_sign_hash_ex+0xd8>
  return ltc_mp.rsa_me(out, x, out, outlen, PK_PRIVATE, key);
 1134c24:	d0000133 	adrp	x19, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1134c28:	aa1703e5 	mov	x5, x23
 1134c2c:	f9409be1 	ldr	x1, [sp, #304]
 1134c30:	aa1503e3 	mov	x3, x21
 1134c34:	f941d673 	ldr	x19, [x19, #936]
 1134c38:	aa1603e2 	mov	x2, x22
 1134c3c:	aa1603e0 	mov	x0, x22
 1134c40:	52800024 	mov	w4, #0x1                   	// #1
 1134c44:	f940ca66 	ldr	x6, [x19, #400]
 1134c48:	d63f00c0 	blr	x6
 1134c4c:	2a0003f3 	mov	w19, w0
 1134c50:	17ffffdc 	b	1134bc0 <rsa_sign_hash_ex+0xd8>
    if (padding == LTC_PKCS_1_V1_5) {
 1134c54:	7100069f 	cmp	w20, #0x1
 1134c58:	540005c1 	b.ne	1134d10 <rsa_sign_hash_ex+0x228>  // b.any
      if (hash_descriptor[hash_idx]->OIDlen == 0) {
 1134c5c:	f941a273 	ldr	x19, [x19, #832]
 1134c60:	f87cda60 	ldr	x0, [x19, w28, sxtw #3]
 1134c64:	f9405001 	ldr	x1, [x0, #160]
 1134c68:	b4000781 	cbz	x1, 1134d58 <rsa_sign_hash_ex+0x270>
      LTC_SET_ASN1(digestinfo, 0, LTC_ASN1_OBJECT_IDENTIFIER, hash_descriptor[hash_idx]->OID, hash_descriptor[hash_idx]->OIDlen);
 1134c6c:	91008000 	add	x0, x0, #0x20
 1134c70:	a90987e0 	stp	x0, x1, [sp, #152]
      LTC_SET_ASN1(digestinfo, 1, LTC_ASN1_NULL,              NULL,                          0);
 1134c74:	528000c0 	mov	w0, #0x6                   	// #6
 1134c78:	b900e3e0 	str	w0, [sp, #224]
      LTC_SET_ASN1(siginfo,    0, LTC_ASN1_SEQUENCE,          digestinfo,                    2);
 1134c7c:	910243e0 	add	x0, sp, #0x90
 1134c80:	f9009fe0 	str	x0, [sp, #312]
      LTC_SET_ASN1(siginfo,    1, LTC_ASN1_OCTET_STRING,      in,                            inlen);
 1134c84:	528000a0 	mov	w0, #0x5                   	// #5
 1134c88:	b90183e0 	str	w0, [sp, #384]
      LTC_SET_ASN1(digestinfo, 0, LTC_ASN1_OBJECT_IDENTIFIER, hash_descriptor[hash_idx]->OID, hash_descriptor[hash_idx]->OIDlen);
 1134c8c:	528000e3 	mov	w3, #0x7                   	// #7
      y = mp_unsigned_bin_size(key->N);
 1134c90:	f9400ee0 	ldr	x0, [x23, #24]
      LTC_SET_ASN1(siginfo,    0, LTC_ASN1_SEQUENCE,          digestinfo,                    2);
 1134c94:	528001b3 	mov	w19, #0xd                   	// #13
      y = mp_unsigned_bin_size(key->N);
 1134c98:	f9404c41 	ldr	x1, [x2, #152]
      LTC_SET_ASN1(siginfo,    0, LTC_ASN1_SEQUENCE,          digestinfo,                    2);
 1134c9c:	d280005a 	mov	x26, #0x2                   	// #2
      LTC_SET_ASN1(digestinfo, 0, LTC_ASN1_OBJECT_IDENTIFIER, hash_descriptor[hash_idx]->OID, hash_descriptor[hash_idx]->OIDlen);
 1134ca0:	b90093e3 	str	w3, [sp, #144]
 1134ca4:	a90affff 	stp	xzr, xzr, [sp, #168]
 1134ca8:	f9005fff 	str	xzr, [sp, #184]
      LTC_SET_ASN1(digestinfo, 1, LTC_ASN1_NULL,              NULL,                          0);
 1134cac:	a90effff 	stp	xzr, xzr, [sp, #232]
 1134cb0:	a90fffff 	stp	xzr, xzr, [sp, #248]
 1134cb4:	f90087ff 	str	xzr, [sp, #264]
      LTC_SET_ASN1(siginfo,    0, LTC_ASN1_SEQUENCE,          digestinfo,                    2);
 1134cb8:	b90133f3 	str	w19, [sp, #304]
 1134cbc:	a9147ffa 	stp	x26, xzr, [sp, #320]
 1134cc0:	a9157fff 	stp	xzr, xzr, [sp, #336]
      LTC_SET_ASN1(siginfo,    1, LTC_ASN1_OCTET_STRING,      in,                            inlen);
 1134cc4:	a918e3fb 	stp	x27, x24, [sp, #392]
 1134cc8:	a919ffff 	stp	xzr, xzr, [sp, #408]
 1134ccc:	f900d7ff 	str	xzr, [sp, #424]
      y = mp_unsigned_bin_size(key->N);
 1134cd0:	d63f0020 	blr	x1
 1134cd4:	f90047e0 	str	x0, [sp, #136]
      tmpin = XMALLOC(y);
 1134cd8:	940039e0 	bl	1143458 <malloc>
 1134cdc:	aa0003fb 	mov	x27, x0
      if (tmpin == NULL) {
 1134ce0:	b4fff700 	cbz	x0, 1134bc0 <rsa_sign_hash_ex+0xd8>
      if ((err = der_encode_sequence(siginfo, 2, tmpin, &y)) != CRYPT_OK) {
 1134ce4:	2a1303e4 	mov	w4, w19
 1134ce8:	aa0003e2 	mov	x2, x0
 1134cec:	910223e3 	add	x3, sp, #0x88
 1134cf0:	aa1a03e1 	mov	x1, x26
 1134cf4:	9104c3e0 	add	x0, sp, #0x130
 1134cf8:	94001276 	bl	11396d0 <der_encode_sequence_ex>
 1134cfc:	2a0003f3 	mov	w19, w0
 1134d00:	340000a0 	cbz	w0, 1134d14 <rsa_sign_hash_ex+0x22c>
         XFREE(tmpin);
 1134d04:	aa1b03e0 	mov	x0, x27
 1134d08:	94003a36 	bl	11435e0 <free>
         return err;
 1134d0c:	17ffffad 	b	1134bc0 <rsa_sign_hash_ex+0xd8>
      y = inlen;
 1134d10:	f90047f8 	str	x24, [sp, #136]
    err = pkcs_1_v1_5_encode(tmpin, y, LTC_PKCS_1_EMSA, modulus_bitlen, NULL, 0, out, &x);
 1134d14:	f94047e1 	ldr	x1, [sp, #136]
 1134d18:	9104c3e7 	add	x7, sp, #0x130
    x = *outlen;
 1134d1c:	f94002a0 	ldr	x0, [x21]
    err = pkcs_1_v1_5_encode(tmpin, y, LTC_PKCS_1_EMSA, modulus_bitlen, NULL, 0, out, &x);
 1134d20:	aa1603e6 	mov	x6, x22
 1134d24:	aa1903e3 	mov	x3, x25
 1134d28:	52800005 	mov	w5, #0x0                   	// #0
 1134d2c:	d2800004 	mov	x4, #0x0                   	// #0
 1134d30:	52800022 	mov	w2, #0x1                   	// #1
    x = *outlen;
 1134d34:	f9009be0 	str	x0, [sp, #304]
    err = pkcs_1_v1_5_encode(tmpin, y, LTC_PKCS_1_EMSA, modulus_bitlen, NULL, 0, out, &x);
 1134d38:	aa1b03e0 	mov	x0, x27
 1134d3c:	94001b7d 	bl	113bb30 <pkcs_1_v1_5_encode>
 1134d40:	2a0003f3 	mov	w19, w0
    if (padding == LTC_PKCS_1_V1_5) {
 1134d44:	7100069f 	cmp	w20, #0x1
 1134d48:	54fff6c1 	b.ne	1134c20 <rsa_sign_hash_ex+0x138>  // b.any
      XFREE(tmpin);
 1134d4c:	aa1b03e0 	mov	x0, x27
 1134d50:	94003a24 	bl	11435e0 <free>
    if (err != CRYPT_OK) {
 1134d54:	17ffffb3 	b	1134c20 <rsa_sign_hash_ex+0x138>
   LTC_ARGCHK(in       != NULL);
 1134d58:	52800213 	mov	w19, #0x10                  	// #16
 1134d5c:	17ffff99 	b	1134bc0 <rsa_sign_hash_ex+0xd8>
     return CRYPT_PK_INVALID_PADDING;
 1134d60:	52800313 	mov	w19, #0x18                  	// #24
 1134d64:	17ffff97 	b	1134bc0 <rsa_sign_hash_ex+0xd8>

0000000001134d68 <rsa_verify_hash_ex>:
int rsa_verify_hash_ex(const unsigned char *sig,            unsigned long  siglen,
                       const unsigned char *hash,           unsigned long  hashlen,
                             int            padding,
                             int            hash_idx,       unsigned long  saltlen,
                             int           *stat,     const rsa_key       *key)
{
 1134d68:	d10943ff 	sub	sp, sp, #0x250
 1134d6c:	a9007bfd 	stp	x29, x30, [sp]
 1134d70:	910003fd 	mov	x29, sp
 1134d74:	a90153f3 	stp	x19, x20, [sp, #16]
 1134d78:	a9025bf5 	stp	x21, x22, [sp, #32]
 1134d7c:	a90363f7 	stp	x23, x24, [sp, #48]
 1134d80:	a9046bf9 	stp	x25, x26, [sp, #64]
 1134d84:	a90573fb 	stp	x27, x28, [sp, #80]
  unsigned long modulus_bitlen, modulus_bytelen, x;
  int           err;
  unsigned char *tmpbuf;

  LTC_ARGCHK(hash  != NULL);
 1134d88:	b4001b82 	cbz	x2, 11350f8 <rsa_verify_hash_ex+0x390>
 1134d8c:	aa0003fc 	mov	x28, x0
  LTC_ARGCHK(sig   != NULL);
 1134d90:	b4001b40 	cbz	x0, 11350f8 <rsa_verify_hash_ex+0x390>
 1134d94:	aa0703f7 	mov	x23, x7
  LTC_ARGCHK(stat  != NULL);
 1134d98:	b4001b07 	cbz	x7, 11350f8 <rsa_verify_hash_ex+0x390>
  LTC_ARGCHK(key   != NULL);
 1134d9c:	f9412be0 	ldr	x0, [sp, #592]
 1134da0:	b4001ac0 	cbz	x0, 11350f8 <rsa_verify_hash_ex+0x390>

  /* default to invalid */
  *stat = 0;
 1134da4:	b90000ff 	str	wzr, [x7]

  /* valid padding? */

  if ((padding != LTC_PKCS_1_V1_5) &&
 1134da8:	121e7880 	and	w0, w4, #0xfffffffd
 1134dac:	aa0103f5 	mov	x21, x1
 1134db0:	aa0203f9 	mov	x25, x2
 1134db4:	aa0303f8 	mov	x24, x3
 1134db8:	2a0403fa 	mov	w26, w4
 1134dbc:	93407cb6 	sxtw	x22, w5
 1134dc0:	aa0603fb 	mov	x27, x6
 1134dc4:	7100041f 	cmp	w0, #0x1
 1134dc8:	54000440 	b.eq	1134e50 <rsa_verify_hash_ex+0xe8>  // b.none
      (padding != LTC_PKCS_1_PSS) &&
 1134dcc:	7100109f 	cmp	w4, #0x4
 1134dd0:	54001981 	b.ne	1135100 <rsa_verify_hash_ex+0x398>  // b.any
       return err;
    }
  }

  /* get modulus len in bits */
  modulus_bitlen = mp_count_bits( (key->N));
 1134dd4:	d0000121 	adrp	x1, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1134dd8:	f90037e1 	str	x1, [sp, #104]
 1134ddc:	f9412be0 	ldr	x0, [sp, #592]
 1134de0:	f941d433 	ldr	x19, [x1, #936]
 1134de4:	f9400c00 	ldr	x0, [x0, #24]
 1134de8:	f9403a62 	ldr	x2, [x19, #112]
 1134dec:	d63f0040 	blr	x2
 1134df0:	b90063e0 	str	w0, [sp, #96]

  /* outlen must be at least the size of the modulus */
  modulus_bytelen = mp_unsigned_bin_size( (key->N));
 1134df4:	f9412be0 	ldr	x0, [sp, #592]
 1134df8:	f9404e62 	ldr	x2, [x19, #152]
 1134dfc:	f9400c00 	ldr	x0, [x0, #24]
 1134e00:	d63f0040 	blr	x2
  if (modulus_bytelen != siglen) {
 1134e04:	eb15001f 	cmp	x0, x21
 1134e08:	54000481 	b.ne	1134e98 <rsa_verify_hash_ex+0x130>  // b.any
     return CRYPT_INVALID_PACKET;
  }

  /* allocate temp buffer for decoded sig */
  tmpbuf = XMALLOC(siglen);
 1134e0c:	94003993 	bl	1143458 <malloc>
 1134e10:	aa0003f4 	mov	x20, x0
  if (tmpbuf == NULL) {
 1134e14:	b40017a0 	cbz	x0, 1135108 <rsa_verify_hash_ex+0x3a0>
     return CRYPT_MEM;
  }

  /* RSA decode it  */
  x = siglen;
  if ((err = ltc_mp.rsa_me(sig, siglen, tmpbuf, &x, PK_PUBLIC, key)) != CRYPT_OK) {
 1134e18:	f940ca66 	ldr	x6, [x19, #400]
  x = siglen;
 1134e1c:	f9003ff5 	str	x21, [sp, #120]
  if ((err = ltc_mp.rsa_me(sig, siglen, tmpbuf, &x, PK_PUBLIC, key)) != CRYPT_OK) {
 1134e20:	f9412be5 	ldr	x5, [sp, #592]
 1134e24:	aa0003e2 	mov	x2, x0
 1134e28:	9101e3e3 	add	x3, sp, #0x78
 1134e2c:	aa1503e1 	mov	x1, x21
 1134e30:	aa1c03e0 	mov	x0, x28
 1134e34:	52800004 	mov	w4, #0x0                   	// #0
 1134e38:	d63f00c0 	blr	x6
 1134e3c:	2a0003f3 	mov	w19, w0
 1134e40:	34000220 	cbz	w0, 1134e84 <rsa_verify_hash_ex+0x11c>

bail_2:
#ifdef LTC_CLEAN_STACK
  zeromem(tmpbuf, siglen);
#endif
  XFREE(tmpbuf);
 1134e44:	aa1403e0 	mov	x0, x20
 1134e48:	940039e6 	bl	11435e0 <free>
  return err;
 1134e4c:	14000005 	b	1134e60 <rsa_verify_hash_ex+0xf8>
    if ((err = hash_is_valid(hash_idx)) != CRYPT_OK) {
 1134e50:	2a1603e0 	mov	w0, w22
 1134e54:	97fff608 	bl	1132674 <hash_is_valid>
 1134e58:	2a0003f3 	mov	w19, w0
 1134e5c:	34fffbc0 	cbz	w0, 1134dd4 <rsa_verify_hash_ex+0x6c>
}
 1134e60:	2a1303e0 	mov	w0, w19
 1134e64:	a9407bfd 	ldp	x29, x30, [sp]
 1134e68:	a94153f3 	ldp	x19, x20, [sp, #16]
 1134e6c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1134e70:	a94363f7 	ldp	x23, x24, [sp, #48]
 1134e74:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1134e78:	a94573fb 	ldp	x27, x28, [sp, #80]
 1134e7c:	910943ff 	add	sp, sp, #0x250
 1134e80:	d65f03c0 	ret
  if (x != siglen) {
 1134e84:	f9403fe0 	ldr	x0, [sp, #120]
 1134e88:	eb15001f 	cmp	x0, x21
 1134e8c:	540000a0 	b.eq	1134ea0 <rsa_verify_hash_ex+0x138>  // b.none
     XFREE(tmpbuf);
 1134e90:	aa1403e0 	mov	x0, x20
 1134e94:	940039d3 	bl	11435e0 <free>
     return CRYPT_INVALID_PACKET;
 1134e98:	528000f3 	mov	w19, #0x7                   	// #7
 1134e9c:	17fffff1 	b	1134e60 <rsa_verify_hash_ex+0xf8>
 1134ea0:	b94063e0 	ldr	w0, [sp, #96]
  if (padding == LTC_PKCS_1_PSS) {
 1134ea4:	71000f5f 	cmp	w26, #0x3
  modulus_bitlen = mp_count_bits( (key->N));
 1134ea8:	b98063f3 	ldrsw	x19, [sp, #96]
  if (padding == LTC_PKCS_1_PSS) {
 1134eac:	12000801 	and	w1, w0, #0x7
 1134eb0:	54000281 	b.ne	1134f00 <rsa_verify_hash_ex+0x198>  // b.any
      err = pkcs_1_pss_decode(hash, hashlen, tmpbuf+1, x-1, saltlen, hash_idx, modulus_bitlen, stat);
 1134eb4:	aa1703e7 	mov	x7, x23
 1134eb8:	aa1303e6 	mov	x6, x19
 1134ebc:	2a1603e5 	mov	w5, w22
 1134ec0:	aa1b03e4 	mov	x4, x27
    if(modulus_bitlen%8 == 1){
 1134ec4:	7100043f 	cmp	w1, #0x1
 1134ec8:	54000161 	b.ne	1134ef4 <rsa_verify_hash_ex+0x18c>  // b.any
      err = pkcs_1_pss_decode(hash, hashlen, tmpbuf+1, x-1, saltlen, hash_idx, modulus_bitlen, stat);
 1134ecc:	d10006a3 	sub	x3, x21, #0x1
 1134ed0:	91000682 	add	x2, x20, #0x1
      err = pkcs_1_pss_decode(hash, hashlen, tmpbuf, x, saltlen, hash_idx, modulus_bitlen, stat);
 1134ed4:	aa1803e1 	mov	x1, x24
 1134ed8:	aa1903e0 	mov	x0, x25
 1134edc:	94001907 	bl	113b2f8 <pkcs_1_pss_decode>
 1134ee0:	2a0003f3 	mov	w19, w0
  zeromem(tmpbuf, siglen);
 1134ee4:	aa1503e1 	mov	x1, x21
 1134ee8:	aa1403e0 	mov	x0, x20
 1134eec:	97fff556 	bl	1132444 <zeromem>
 1134ef0:	17ffffd5 	b	1134e44 <rsa_verify_hash_ex+0xdc>
      err = pkcs_1_pss_decode(hash, hashlen, tmpbuf, x, saltlen, hash_idx, modulus_bitlen, stat);
 1134ef4:	aa1503e3 	mov	x3, x21
 1134ef8:	aa1403e2 	mov	x2, x20
 1134efc:	17fffff6 	b	1134ed4 <rsa_verify_hash_ex+0x16c>
    outlen = ((modulus_bitlen >> 3) + (modulus_bitlen & 7 ? 1 : 0)) - 3;
 1134f00:	7100003f 	cmp	w1, #0x0
 1134f04:	d343fe60 	lsr	x0, x19, #3
 1134f08:	d1000c00 	sub	x0, x0, #0x3
 1134f0c:	9a800400 	cinc	x0, x0, ne  // ne = any
 1134f10:	f90043e0 	str	x0, [sp, #128]
    out    = XMALLOC(outlen);
 1134f14:	94003951 	bl	1143458 <malloc>
 1134f18:	aa0003fb 	mov	x27, x0
    if (out == NULL) {
 1134f1c:	b4000ea0 	cbz	x0, 11350f0 <rsa_verify_hash_ex+0x388>
    if ((err = pkcs_1_v1_5_decode(tmpbuf, x, LTC_PKCS_1_EMSA, modulus_bitlen, out, &outlen, &decoded)) != CRYPT_OK) {
 1134f20:	aa0003e4 	mov	x4, x0
 1134f24:	aa1303e3 	mov	x3, x19
 1134f28:	9101d3e6 	add	x6, sp, #0x74
 1134f2c:	910203e5 	add	x5, sp, #0x80
 1134f30:	aa1503e1 	mov	x1, x21
 1134f34:	aa1403e0 	mov	x0, x20
 1134f38:	52800022 	mov	w2, #0x1                   	// #1
 1134f3c:	94001ab4 	bl	113ba0c <pkcs_1_v1_5_decode>
 1134f40:	2a0003f3 	mov	w19, w0
 1134f44:	34000080 	cbz	w0, 1134f54 <rsa_verify_hash_ex+0x1ec>
    XFREE(out);
 1134f48:	aa1b03e0 	mov	x0, x27
 1134f4c:	940039a5 	bl	11435e0 <free>
 1134f50:	17ffffe5 	b	1134ee4 <rsa_verify_hash_ex+0x17c>
    if (padding == LTC_PKCS_1_V1_5) {
 1134f54:	7100075f 	cmp	w26, #0x1
 1134f58:	54000be1 	b.ne	11350d4 <rsa_verify_hash_ex+0x36c>  // b.any
      if (hash_descriptor[hash_idx]->OIDlen == 0) {
 1134f5c:	f94037e0 	ldr	x0, [sp, #104]
 1134f60:	f941a000 	ldr	x0, [x0, #832]
 1134f64:	f8767800 	ldr	x0, [x0, x22, lsl #3]
 1134f68:	f9405000 	ldr	x0, [x0, #160]
 1134f6c:	b4000b00 	cbz	x0, 11350cc <rsa_verify_hash_ex+0x364>
      LTC_SET_ASN1(digestinfo, 0, LTC_ASN1_OBJECT_IDENTIFIER, loid, sizeof(loid)/sizeof(loid[0]));
 1134f70:	528000e0 	mov	w0, #0x7                   	// #7
 1134f74:	b90113e0 	str	w0, [sp, #272]
      LTC_SET_ASN1(siginfo,    1, LTC_ASN1_OCTET_STRING,      tmpbuf,                        siglen);
 1134f78:	910823e0 	add	x0, sp, #0x208
      LTC_SET_ASN1(siginfo,    0, LTC_ASN1_SEQUENCE,          digestinfo,                    2);
 1134f7c:	910443e5 	add	x5, sp, #0x110
      if ((err = der_decode_sequence_strict(out, outlen, siginfo, 2)) != CRYPT_OK) {
 1134f80:	f94043e1 	ldr	x1, [sp, #128]
 1134f84:	9106c3fc 	add	x28, sp, #0x1b0
      LTC_SET_ASN1(siginfo,    1, LTC_ASN1_OCTET_STRING,      tmpbuf,                        siglen);
 1134f88:	a9005414 	stp	x20, x21, [x0]
      LTC_SET_ASN1(siginfo,    0, LTC_ASN1_SEQUENCE,          digestinfo,                    2);
 1134f8c:	528001ba 	mov	w26, #0xd                   	// #13
 1134f90:	d2800043 	mov	x3, #0x2                   	// #2
      LTC_SET_ASN1(siginfo,    1, LTC_ASN1_OCTET_STRING,      tmpbuf,                        siglen);
 1134f94:	a9017c1f 	stp	xzr, xzr, [x0, #16]
      LTC_SET_ASN1(digestinfo, 0, LTC_ASN1_OBJECT_IDENTIFIER, loid, sizeof(loid)/sizeof(loid[0]));
 1134f98:	910243e0 	add	x0, sp, #0x90
      if ((err = der_decode_sequence_strict(out, outlen, siginfo, 2)) != CRYPT_OK) {
 1134f9c:	aa1c03e2 	mov	x2, x28
      LTC_SET_ASN1(digestinfo, 0, LTC_ASN1_OBJECT_IDENTIFIER, loid, sizeof(loid)/sizeof(loid[0]));
 1134fa0:	f9008fe0 	str	x0, [sp, #280]
 1134fa4:	d2800200 	mov	x0, #0x10                  	// #16
 1134fa8:	f90093e0 	str	x0, [sp, #288]
      LTC_SET_ASN1(digestinfo, 1, LTC_ASN1_NULL,              NULL,                          0);
 1134fac:	528000c0 	mov	w0, #0x6                   	// #6
 1134fb0:	b90163e0 	str	w0, [sp, #352]
      LTC_SET_ASN1(siginfo,    1, LTC_ASN1_OCTET_STRING,      tmpbuf,                        siglen);
 1134fb4:	528000a0 	mov	w0, #0x5                   	// #5
      if ((err = der_decode_sequence_strict(out, outlen, siginfo, 2)) != CRYPT_OK) {
 1134fb8:	52800064 	mov	w4, #0x3                   	// #3
      LTC_SET_ASN1(siginfo,    0, LTC_ASN1_SEQUENCE,          digestinfo,                    2);
 1134fbc:	f90033e5 	str	x5, [sp, #96]
      LTC_SET_ASN1(digestinfo, 0, LTC_ASN1_OBJECT_IDENTIFIER, loid, sizeof(loid)/sizeof(loid[0]));
 1134fc0:	a912ffff 	stp	xzr, xzr, [sp, #296]
 1134fc4:	f9009fff 	str	xzr, [sp, #312]
      LTC_SET_ASN1(digestinfo, 1, LTC_ASN1_NULL,              NULL,                          0);
 1134fc8:	a916ffff 	stp	xzr, xzr, [sp, #360]
 1134fcc:	a917ffff 	stp	xzr, xzr, [sp, #376]
 1134fd0:	f900c7ff 	str	xzr, [sp, #392]
      LTC_SET_ASN1(siginfo,    0, LTC_ASN1_SEQUENCE,          digestinfo,                    2);
 1134fd4:	b901b3fa 	str	w26, [sp, #432]
 1134fd8:	a91b8fe5 	stp	x5, x3, [sp, #440]
 1134fdc:	a91cffff 	stp	xzr, xzr, [sp, #456]
 1134fe0:	f900efff 	str	xzr, [sp, #472]
      LTC_SET_ASN1(siginfo,    1, LTC_ASN1_OCTET_STRING,      tmpbuf,                        siglen);
 1134fe4:	b90203e0 	str	w0, [sp, #512]
      if ((err = der_decode_sequence_strict(out, outlen, siginfo, 2)) != CRYPT_OK) {
 1134fe8:	aa1b03e0 	mov	x0, x27
      LTC_SET_ASN1(siginfo,    1, LTC_ASN1_OCTET_STRING,      tmpbuf,                        siglen);
 1134fec:	f90117ff 	str	xzr, [sp, #552]
      if ((err = der_decode_sequence_strict(out, outlen, siginfo, 2)) != CRYPT_OK) {
 1134ff0:	94001106 	bl	1139408 <der_decode_sequence_ex>
 1134ff4:	34000260 	cbz	w0, 1135040 <rsa_verify_hash_ex+0x2d8>
         LTC_SET_ASN1(siginfo, 0, LTC_ASN1_SEQUENCE,          digestinfo,                    1);
 1134ff8:	f94033e5 	ldr	x5, [sp, #96]
 1134ffc:	d2800020 	mov	x0, #0x1                   	// #1
         if ((err = der_decode_sequence_strict(out, outlen, siginfo, 2)) != CRYPT_OK) {
 1135000:	f94043e1 	ldr	x1, [sp, #128]
 1135004:	aa1c03e2 	mov	x2, x28
 1135008:	52800064 	mov	w4, #0x3                   	// #3
 113500c:	d2800043 	mov	x3, #0x2                   	// #2
         LTC_SET_ASN1(siginfo, 0, LTC_ASN1_SEQUENCE,          digestinfo,                    1);
 1135010:	b901b3fa 	str	w26, [sp, #432]
 1135014:	a91b83e5 	stp	x5, x0, [sp, #440]
         if ((err = der_decode_sequence_strict(out, outlen, siginfo, 2)) != CRYPT_OK) {
 1135018:	aa1b03e0 	mov	x0, x27
         LTC_SET_ASN1(siginfo, 0, LTC_ASN1_SEQUENCE,          digestinfo,                    1);
 113501c:	a91cffff 	stp	xzr, xzr, [sp, #456]
 1135020:	f900efff 	str	xzr, [sp, #472]
         if ((err = der_decode_sequence_strict(out, outlen, siginfo, 2)) != CRYPT_OK) {
 1135024:	940010f9 	bl	1139408 <der_decode_sequence_ex>
 1135028:	2a0003fa 	mov	w26, w0
 113502c:	340000a0 	cbz	w0, 1135040 <rsa_verify_hash_ex+0x2d8>
         XFREE(out);
 1135030:	aa1b03e0 	mov	x0, x27
 1135034:	9400396b 	bl	11435e0 <free>
         goto bail_2;
 1135038:	2a1a03f3 	mov	w19, w26
 113503c:	17ffffaa 	b	1134ee4 <rsa_verify_hash_ex+0x17c>
      if ((err = der_length_sequence(siginfo, 2, &reallen)) != CRYPT_OK) {
 1135040:	910223e2 	add	x2, sp, #0x88
 1135044:	aa1c03e0 	mov	x0, x28
 1135048:	d2800041 	mov	x1, #0x2                   	// #2
 113504c:	9400136d 	bl	1139e00 <der_length_sequence>
 1135050:	2a0003fa 	mov	w26, w0
 1135054:	35fffee0 	cbnz	w0, 1135030 <rsa_verify_hash_ex+0x2c8>
      if ((reallen == outlen) &&
 1135058:	a94807e0 	ldp	x0, x1, [sp, #128]
 113505c:	eb00003f 	cmp	x1, x0
 1135060:	540002e1 	b.ne	11350bc <rsa_verify_hash_ex+0x354>  // b.any
          (digestinfo[0].size == hash_descriptor[hash_idx]->OIDlen) &&
 1135064:	f94037e0 	ldr	x0, [sp, #104]
      if ((reallen == outlen) &&
 1135068:	f94093e2 	ldr	x2, [sp, #288]
          (digestinfo[0].size == hash_descriptor[hash_idx]->OIDlen) &&
 113506c:	f941a000 	ldr	x0, [x0, #832]
 1135070:	f8767801 	ldr	x1, [x0, x22, lsl #3]
 1135074:	f9405020 	ldr	x0, [x1, #160]
      if ((reallen == outlen) &&
 1135078:	eb00005f 	cmp	x2, x0
 113507c:	54000201 	b.ne	11350bc <rsa_verify_hash_ex+0x354>  // b.any
        (XMEMCMP(digestinfo[0].data, hash_descriptor[hash_idx]->OID, sizeof(unsigned long) * hash_descriptor[hash_idx]->OIDlen) == 0) &&
 1135080:	f9408fe0 	ldr	x0, [sp, #280]
 1135084:	d37df042 	lsl	x2, x2, #3
 1135088:	91008021 	add	x1, x1, #0x20
 113508c:	94003af1 	bl	1143c50 <memcmp>
          (digestinfo[0].size == hash_descriptor[hash_idx]->OIDlen) &&
 1135090:	35000160 	cbnz	w0, 11350bc <rsa_verify_hash_ex+0x354>
        (XMEMCMP(digestinfo[0].data, hash_descriptor[hash_idx]->OID, sizeof(unsigned long) * hash_descriptor[hash_idx]->OIDlen) == 0) &&
 1135094:	f9410be0 	ldr	x0, [sp, #528]
 1135098:	eb18001f 	cmp	x0, x24
 113509c:	54000101 	b.ne	11350bc <rsa_verify_hash_ex+0x354>  // b.any
        (XMEMCMP(siginfo[1].data, hash, hashlen) == 0)) {
 11350a0:	f94107e0 	ldr	x0, [sp, #520]
 11350a4:	aa1803e2 	mov	x2, x24
 11350a8:	aa1903e1 	mov	x1, x25
          (XMEMCMP(out, hash, hashlen) == 0)) {
 11350ac:	94003ae9 	bl	1143c50 <memcmp>
      if ((hashlen == outlen) &&
 11350b0:	35000060 	cbnz	w0, 11350bc <rsa_verify_hash_ex+0x354>
        *stat = 1;
 11350b4:	52800020 	mov	w0, #0x1                   	// #1
 11350b8:	b90002e0 	str	w0, [x23]
    zeromem(out, outlen);
 11350bc:	f94043e1 	ldr	x1, [sp, #128]
 11350c0:	aa1b03e0 	mov	x0, x27
 11350c4:	97fff4e0 	bl	1132444 <zeromem>
 11350c8:	17ffffa0 	b	1134f48 <rsa_verify_hash_ex+0x1e0>
         err = CRYPT_INVALID_ARG;
 11350cc:	5280021a 	mov	w26, #0x10                  	// #16
 11350d0:	17ffffda 	b	1135038 <rsa_verify_hash_ex+0x2d0>
      if ((hashlen == outlen) &&
 11350d4:	f94043e0 	ldr	x0, [sp, #128]
 11350d8:	eb18001f 	cmp	x0, x24
 11350dc:	54ffff01 	b.ne	11350bc <rsa_verify_hash_ex+0x354>  // b.any
          (XMEMCMP(out, hash, hashlen) == 0)) {
 11350e0:	aa1803e2 	mov	x2, x24
 11350e4:	aa1903e1 	mov	x1, x25
 11350e8:	aa1b03e0 	mov	x0, x27
 11350ec:	17fffff0 	b	11350ac <rsa_verify_hash_ex+0x344>
      err = CRYPT_MEM;
 11350f0:	528001b3 	mov	w19, #0xd                   	// #13
 11350f4:	17ffff7c 	b	1134ee4 <rsa_verify_hash_ex+0x17c>
  LTC_ARGCHK(hash  != NULL);
 11350f8:	52800213 	mov	w19, #0x10                  	// #16
 11350fc:	17ffff59 	b	1134e60 <rsa_verify_hash_ex+0xf8>
    return CRYPT_PK_INVALID_PADDING;
 1135100:	52800313 	mov	w19, #0x18                  	// #24
 1135104:	17ffff57 	b	1134e60 <rsa_verify_hash_ex+0xf8>
     return CRYPT_MEM;
 1135108:	528001b3 	mov	w19, #0xd                   	// #13
 113510c:	17ffff55 	b	1134e60 <rsa_verify_hash_ex+0xf8>

0000000001135110 <dh_free>:
  Free the allocated ram for a DH key
  @param key   The key which you wish to free
*/
void dh_free(dh_key *key)
{
   LTC_ARGCHKVD(key != NULL);
 1135110:	b40000e0 	cbz	x0, 113512c <dh_free+0x1c>
   mp_cleanup_multi(&key->prime, &key->base, &key->y, &key->x, NULL);
 1135114:	91002003 	add	x3, x0, #0x8
 1135118:	91004002 	add	x2, x0, #0x10
 113511c:	91006001 	add	x1, x0, #0x18
 1135120:	d2800004 	mov	x4, #0x0                   	// #0
 1135124:	91008000 	add	x0, x0, #0x20
 1135128:	17fff422 	b	11321b0 <ltc_cleanup_multi>
}
 113512c:	d65f03c0 	ret

0000000001135130 <dh_make_key>:
 * @return CRYPT_OK if successful, note: on error all allocated memory will be
 *         freed automatically.
*/

int dh_make_key(prng_state *prng, int wprng, void *q, int xbits, dh_key *key)
{
 1135130:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
 1135134:	910003fd 	mov	x29, sp
 1135138:	a90153f3 	stp	x19, x20, [sp, #16]
 113513c:	a9025bf5 	stp	x21, x22, [sp, #32]
 1135140:	a90363f7 	stp	x23, x24, [sp, #48]
 1135144:	a9046bf9 	stp	x25, x26, [sp, #64]
 1135148:	a90573fb 	stp	x27, x28, [sp, #80]
	uint8_t *buf = 0;	/* intermediate buffer to have a raw random  */

	/*
	 * Check the arguments
	 */
	LTC_ARGCHK(key != NULL);
 113514c:	b5000144 	cbnz	x4, 1135174 <dh_make_key+0x44>
 1135150:	52800213 	mov	w19, #0x10                  	// #16
		mp_clear_multi(key->x, key->y, NULL);
	if (buf)
		XFREE(buf);

	return err;
}
 1135154:	2a1303e0 	mov	w0, w19
 1135158:	a94153f3 	ldp	x19, x20, [sp, #16]
 113515c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1135160:	a94363f7 	ldp	x23, x24, [sp, #48]
 1135164:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1135168:	a94573fb 	ldp	x27, x28, [sp, #80]
 113516c:	a8c67bfd 	ldp	x29, x30, [sp], #96
 1135170:	d65f03c0 	ret
 1135174:	aa0003f8 	mov	x24, x0
 1135178:	aa0403f5 	mov	x21, x4
	LTC_ARGCHK(key->base != NULL);
 113517c:	f9400c80 	ldr	x0, [x4, #24]
 1135180:	b4fffe80 	cbz	x0, 1135150 <dh_make_key+0x20>
	LTC_ARGCHK(key->prime != NULL);
 1135184:	f9401080 	ldr	x0, [x4, #32]
 1135188:	b4fffe40 	cbz	x0, 1135150 <dh_make_key+0x20>
 113518c:	2a0103f7 	mov	w23, w1
 1135190:	aa0203f6 	mov	x22, x2
 1135194:	2a0303f4 	mov	w20, w3
	err = prng_is_valid(wprng);
 1135198:	2a0103e0 	mov	w0, w1
 113519c:	97fff550 	bl	11326dc <prng_is_valid>
 11351a0:	2a0003f3 	mov	w19, w0
	if (err != CRYPT_OK)
 11351a4:	35fffd80 	cbnz	w0, 1135154 <dh_make_key+0x24>
	if (xbits) {
 11351a8:	340000b4 	cbz	w20, 11351bc <dh_make_key+0x8c>
		LTC_ARGCHK((xbits % 8) == 0);
 11351ac:	f2400a9f 	tst	x20, #0x7
 11351b0:	54fffd01 	b.ne	1135150 <dh_make_key+0x20>  // b.any
		key_size = xbits / 8;
 11351b4:	52800100 	mov	w0, #0x8                   	// #8
 11351b8:	1ac00e94 	sdiv	w20, w20, w0
	key_size_p = mp_unsigned_bin_size(key->prime);
 11351bc:	b000013b 	adrp	x27, 115a000 <__scattered_array_1phys_mem_map+0x8>
 11351c0:	aa1b03fa 	mov	x26, x27
 11351c4:	f94012a0 	ldr	x0, [x21, #32]
 11351c8:	f941d77c 	ldr	x28, [x27, #936]
 11351cc:	f9404f81 	ldr	x1, [x28, #152]
 11351d0:	d63f0020 	blr	x1
 11351d4:	aa0003f9 	mov	x25, x0
	if (q)
 11351d8:	b4000976 	cbz	x22, 1135304 <dh_make_key+0x1d4>
		key_size_q = mp_unsigned_bin_size(q);
 11351dc:	f9404f81 	ldr	x1, [x28, #152]
 11351e0:	aa1603e0 	mov	x0, x22
 11351e4:	d63f0020 	blr	x1
 11351e8:	2a0003f3 	mov	w19, w0
	if (key_size) {
 11351ec:	340000d4 	cbz	w20, 1135204 <dh_make_key+0xd4>
		LTC_ARGCHK(key_size <= key_size_p);
 11351f0:	6b19029f 	cmp	w20, w25
 11351f4:	54fffaec 	b.gt	1135150 <dh_make_key+0x20>
		LTC_ARGCHK((q == NULL) || (key_size <= key_size_q));
 11351f8:	6b00029f 	cmp	w20, w0
		LTC_ARGCHK(key_size <= key_size_p);
 11351fc:	5400008d 	b.le	113520c <dh_make_key+0xdc>
 1135200:	17ffffd4 	b	1135150 <dh_make_key+0x20>
			key_size = MIN(key_size_p, key_size_q);
 1135204:	6b00033f 	cmp	w25, w0
 1135208:	1a80d334 	csel	w20, w25, w0, le
	if ((q != NULL) && (key_size_q < key_size_p))
 113520c:	f10002df 	cmp	x22, #0x0
 1135210:	7a531324 	ccmp	w25, w19, #0x4, ne  // ne = any
 1135214:	5400004c 	b.gt	113521c <dh_make_key+0xec>
		arg_mod = key->prime;
 1135218:	f94012b6 	ldr	x22, [x21, #32]
	key->y = NULL;
 113521c:	aa1503e1 	mov	x1, x21
	key->x = NULL;
 1135220:	f90006bf 	str	xzr, [x21, #8]
	err = mp_init_multi(&key->x, &key->y, NULL);
 1135224:	910022a0 	add	x0, x21, #0x8
 1135228:	d2800002 	mov	x2, #0x0                   	// #0
	key->y = NULL;
 113522c:	f8010c3f 	str	xzr, [x1, #16]!
	err = mp_init_multi(&key->x, &key->y, NULL);
 1135230:	97fff321 	bl	1131eb4 <ltc_init_multi>
 1135234:	2a0003f3 	mov	w19, w0
	if (err != CRYPT_OK)
 1135238:	350005a0 	cbnz	w0, 11352ec <dh_make_key+0x1bc>
	buf = XMALLOC(key_size);
 113523c:	93407e94 	sxtw	x20, w20
 1135240:	aa1403e0 	mov	x0, x20
 1135244:	94003885 	bl	1143458 <malloc>
 1135248:	aa0003f9 	mov	x25, x0
	if (buf == NULL) {
 113524c:	b4000540 	cbz	x0, 11352f4 <dh_make_key+0x1c4>
	if (prng_descriptor[wprng]->read(buf, key_size, prng) !=
 1135250:	f9422f41 	ldr	x1, [x26, #1112]
 1135254:	aa1803e2 	mov	x2, x24
 1135258:	f877d821 	ldr	x1, [x1, w23, sxtw #3]
 113525c:	f9401423 	ldr	x3, [x1, #40]
 1135260:	aa1403e1 	mov	x1, x20
 1135264:	d63f0060 	blr	x3
 1135268:	eb00029f 	cmp	x20, x0
 113526c:	54000481 	b.ne	11352fc <dh_make_key+0x1cc>  // b.any
	err = mp_read_unsigned_bin(key->y, buf, key_size);
 1135270:	f941d75a 	ldr	x26, [x26, #936]
 1135274:	aa1403e2 	mov	x2, x20
 1135278:	f9400aa0 	ldr	x0, [x21, #16]
 113527c:	aa1903e1 	mov	x1, x25
 1135280:	f9405743 	ldr	x3, [x26, #168]
 1135284:	d63f0060 	blr	x3
 1135288:	2a0003f3 	mov	w19, w0
	if (err != CRYPT_OK)
 113528c:	350001c0 	cbnz	w0, 11352c4 <dh_make_key+0x194>
	err = mp_mod(key->y, arg_mod, key->x);
 1135290:	a94082a3 	ldp	x3, x0, [x21, #8]
 1135294:	aa1603e1 	mov	x1, x22
 1135298:	f9407b44 	ldr	x4, [x26, #240]
 113529c:	d2800002 	mov	x2, #0x0                   	// #0
 11352a0:	d63f0080 	blr	x4
 11352a4:	2a0003f3 	mov	w19, w0
	if (err != CRYPT_OK)
 11352a8:	350000e0 	cbnz	w0, 11352c4 <dh_make_key+0x194>
	err = mp_exptmod(key->base, key->x, key->prime, key->y);
 11352ac:	a9408ea1 	ldp	x1, x3, [x21, #8]
 11352b0:	a9418aa0 	ldp	x0, x2, [x21, #24]
 11352b4:	f940ab44 	ldr	x4, [x26, #336]
 11352b8:	d63f0080 	blr	x4
 11352bc:	2a0003f3 	mov	w19, w0
	if (err != CRYPT_OK)
 11352c0:	340000a0 	cbz	w0, 11352d4 <dh_make_key+0x1a4>
		mp_clear_multi(key->x, key->y, NULL);
 11352c4:	a94086a0 	ldp	x0, x1, [x21, #8]
 11352c8:	d2800002 	mov	x2, #0x0                   	// #0
 11352cc:	97fff394 	bl	113211c <ltc_deinit_multi>
	if (buf)
 11352d0:	b4fff439 	cbz	x25, 1135154 <dh_make_key+0x24>
		XFREE(buf);
 11352d4:	aa1903e0 	mov	x0, x25
 11352d8:	940038c2 	bl	11435e0 <free>
 11352dc:	17ffff9e 	b	1135154 <dh_make_key+0x24>
	key_size_p = mp_unsigned_bin_size(key->prime);
 11352e0:	2a1903f4 	mov	w20, w25
	int key_size_q = 0;	/* key size of p */
 11352e4:	52800013 	mov	w19, #0x0                   	// #0
 11352e8:	17ffffc9 	b	113520c <dh_make_key+0xdc>
	uint8_t *buf = 0;	/* intermediate buffer to have a raw random  */
 11352ec:	d2800019 	mov	x25, #0x0                   	// #0
 11352f0:	17fffff5 	b	11352c4 <dh_make_key+0x194>
		err = CRYPT_MEM;
 11352f4:	528001b3 	mov	w19, #0xd                   	// #13
 11352f8:	17fffff3 	b	11352c4 <dh_make_key+0x194>
		err = CRYPT_ERROR_READPRNG;
 11352fc:	52800133 	mov	w19, #0x9                   	// #9
 1135300:	17fffff1 	b	11352c4 <dh_make_key+0x194>
	if (key_size) {
 1135304:	34fffef4 	cbz	w20, 11352e0 <dh_make_key+0x1b0>
		LTC_ARGCHK(key_size <= key_size_p);
 1135308:	6b00029f 	cmp	w20, w0
 113530c:	17ffffbc 	b	11351fc <dh_make_key+0xcc>

0000000001135310 <ecc_find_curve>:
int ecc_find_curve(const char *name_or_oid, const ltc_ecc_curve **cu)
{
   int i, j;
   const char *OID = NULL;

   LTC_ARGCHK(cu != NULL);
 1135310:	b5000061 	cbnz	x1, 113531c <ecc_find_curve+0xc>
 1135314:	52800200 	mov	w0, #0x10                  	// #16
         }
      }
   }

   return CRYPT_INVALID_ARG; /* not found */
}
 1135318:	d65f03c0 	ret
{
 113531c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 1135320:	910003fd 	mov	x29, sp
 1135324:	a90153f3 	stp	x19, x20, [sp, #16]
 1135328:	aa0003f4 	mov	x20, x0
 113532c:	a9025bf5 	stp	x21, x22, [sp, #32]
 1135330:	a90363f7 	stp	x23, x24, [sp, #48]
   LTC_ARGCHK(name_or_oid != NULL);
 1135334:	b4000b40 	cbz	x0, 113549c <ecc_find_curve+0x18c>
 1135338:	f0000133 	adrp	x19, 115c000 <ltc_ctr_ops+0x20>
      while ((*left  == ' ') || (*left  == '-') || (*left  == '_')) left++;
 113533c:	d2840038 	mov	x24, #0x2001                	// #8193
 1135340:	aa0103f6 	mov	x22, x1
   *cu = NULL;
 1135344:	9129c273 	add	x19, x19, #0xa70
   const char *OID = NULL;
 1135348:	d2800015 	mov	x21, #0x0                   	// #0
      while ((*left  == ' ') || (*left  == '-') || (*left  == '_')) left++;
 113534c:	f2f00018 	movk	x24, #0x8000, lsl #48
   *cu = NULL;
 1135350:	f900003f 	str	xzr, [x1]
   for (i = 0; _curve_names[i].OID != NULL && !OID; i++) {
 1135354:	f9400277 	ldr	x23, [x19]
 1135358:	b4000a17 	cbz	x23, 1135498 <ecc_find_curve+0x188>
 113535c:	b4000235 	cbz	x21, 11353a0 <ecc_find_curve+0x90>
 1135360:	b0000133 	adrp	x19, 115a000 <__scattered_array_1phys_mem_map+0x8>
   const char *OID = NULL;
 1135364:	52800014 	mov	w20, #0x0                   	// #0
 1135368:	f9421a73 	ldr	x19, [x19, #1072]
      for (i = 0; ltc_ecc_curves[i].prime != NULL; i++) {
 113536c:	f9400260 	ldr	x0, [x19]
 1135370:	b4000960 	cbz	x0, 113549c <ecc_find_curve+0x18c>
         if (XSTRCMP(ltc_ecc_curves[i].OID, OID) == 0) {
 1135374:	f9401e60 	ldr	x0, [x19, #56]
 1135378:	aa1503e1 	mov	x1, x21
 113537c:	91010273 	add	x19, x19, #0x40
 1135380:	94003a5f 	bl	1143cfc <strcmp>
 1135384:	35000980 	cbnz	w0, 11354b4 <ecc_find_curve+0x1a4>
            *cu = &ltc_ecc_curves[i];
 1135388:	b0000133 	adrp	x19, 115a000 <__scattered_array_1phys_mem_map+0x8>
 113538c:	937a7e94 	sbfiz	x20, x20, #6, #32
 1135390:	f9421a73 	ldr	x19, [x19, #1072]
 1135394:	8b130293 	add	x19, x20, x19
 1135398:	f90002d3 	str	x19, [x22]
            return CRYPT_OK;
 113539c:	14000041 	b	11354a0 <ecc_find_curve+0x190>
      if (XSTRCMP(_curve_names[i].OID, name_or_oid) == 0) {
 11353a0:	aa1403e1 	mov	x1, x20
 11353a4:	aa1703e0 	mov	x0, x23
 11353a8:	94003a55 	bl	1143cfc <strcmp>
 11353ac:	7100001f 	cmp	w0, #0x0
 11353b0:	9a9713f5 	csel	x21, xzr, x23, ne  // ne = any
   if ((*left == '\0') && (*right == '\0')) return 1;
 11353b4:	aa1303e0 	mov	x0, x19
      for (j = 0; _curve_names[i].names[j] != NULL && !OID; j++) {
 11353b8:	f9400403 	ldr	x3, [x0, #8]
 11353bc:	b4000043 	cbz	x3, 11353c4 <ecc_find_curve+0xb4>
 11353c0:	b4000695 	cbz	x21, 1135490 <ecc_find_curve+0x180>
   for (i = 0; _curve_names[i].OID != NULL && !OID; i++) {
 11353c4:	9100e273 	add	x19, x19, #0x38
 11353c8:	17ffffe3 	b	1135354 <ecc_find_curve+0x44>
      while ((*left  == ' ') || (*left  == '-') || (*left  == '_')) left++;
 11353cc:	91000463 	add	x3, x3, #0x1
 11353d0:	39400062 	ldrb	w2, [x3]
 11353d4:	51008044 	sub	w4, w2, #0x20
 11353d8:	12001c84 	and	w4, w4, #0xff
 11353dc:	7100fc9f 	cmp	w4, #0x3f
 11353e0:	54000068 	b.hi	11353ec <ecc_find_curve+0xdc>  // b.pmore
 11353e4:	9ac42704 	lsr	x4, x24, x4
 11353e8:	3707ff24 	tbnz	w4, #0, 11353cc <ecc_find_curve+0xbc>
      while ((*right == ' ') || (*right == '-') || (*right == '_')) right++;
 11353ec:	394000a4 	ldrb	w4, [x5]
 11353f0:	51008086 	sub	w6, w4, #0x20
 11353f4:	12001cc6 	and	w6, w6, #0xff
 11353f8:	7100fcdf 	cmp	w6, #0x3f
 11353fc:	54000169 	b.ls	1135428 <ecc_find_curve+0x118>  // b.plast
      if (*left == '\0' || *right == '\0') break;
 1135400:	350001c2 	cbnz	w2, 1135438 <ecc_find_curve+0x128>
   if ((*left == '\0') && (*right == '\0')) return 1;
 1135404:	39400061 	ldrb	w1, [x3]
 1135408:	35000081 	cbnz	w1, 1135418 <ecc_find_curve+0x108>
 113540c:	394000a1 	ldrb	w1, [x5]
 1135410:	7100003f 	cmp	w1, #0x0
 1135414:	9a9713f5 	csel	x21, xzr, x23, ne  // ne = any
      for (j = 0; _curve_names[i].names[j] != NULL && !OID; j++) {
 1135418:	91002000 	add	x0, x0, #0x8
 113541c:	17ffffe7 	b	11353b8 <ecc_find_curve+0xa8>
      while ((*right == ' ') || (*right == '-') || (*right == '_')) right++;
 1135420:	910004a5 	add	x5, x5, #0x1
 1135424:	17fffff2 	b	11353ec <ecc_find_curve+0xdc>
 1135428:	9ac62706 	lsr	x6, x24, x6
 113542c:	3707ffa6 	tbnz	w6, #0, 1135420 <ecc_find_curve+0x110>
      if (*left == '\0' || *right == '\0') break;
 1135430:	35000062 	cbnz	w2, 113543c <ecc_find_curve+0x12c>
 1135434:	17fffff4 	b	1135404 <ecc_find_curve+0xf4>
 1135438:	34fffe64 	cbz	w4, 1135404 <ecc_find_curve+0xf4>
      if ((lc_r >= 'A') && (lc_r <= 'Z')) lc_r += 32;
 113543c:	51010481 	sub	w1, w4, #0x41
 1135440:	12001c21 	and	w1, w1, #0xff
 1135444:	7100643f 	cmp	w1, #0x19
 1135448:	54000068 	b.hi	1135454 <ecc_find_curve+0x144>  // b.pmore
 113544c:	11008084 	add	w4, w4, #0x20
 1135450:	12001c84 	and	w4, w4, #0xff
      if ((lc_l >= 'A') && (lc_l <= 'Z')) lc_l += 32;
 1135454:	51010441 	sub	w1, w2, #0x41
 1135458:	12001c21 	and	w1, w1, #0xff
 113545c:	7100643f 	cmp	w1, #0x19
 1135460:	54000068 	b.hi	113546c <ecc_find_curve+0x15c>  // b.pmore
 1135464:	11008042 	add	w2, w2, #0x20
 1135468:	12001c42 	and	w2, w2, #0xff
      if (lc_l != lc_r) return 0;
 113546c:	6b02009f 	cmp	w4, w2
 1135470:	54fffd41 	b.ne	1135418 <ecc_find_curve+0x108>  // b.any
      left++;
 1135474:	91000463 	add	x3, x3, #0x1
      right++;
 1135478:	910004a5 	add	x5, x5, #0x1
   while ((*left != '\0') && (*right != '\0')) {
 113547c:	39400061 	ldrb	w1, [x3]
 1135480:	34fffc21 	cbz	w1, 1135404 <ecc_find_curve+0xf4>
 1135484:	394000a1 	ldrb	w1, [x5]
 1135488:	35fffa41 	cbnz	w1, 11353d0 <ecc_find_curve+0xc0>
 113548c:	17ffffde 	b	1135404 <ecc_find_curve+0xf4>
 1135490:	aa1403e5 	mov	x5, x20
 1135494:	17fffffa 	b	113547c <ecc_find_curve+0x16c>
   if (OID != NULL) {
 1135498:	b5fff655 	cbnz	x21, 1135360 <ecc_find_curve+0x50>
   LTC_ARGCHK(cu != NULL);
 113549c:	52800200 	mov	w0, #0x10                  	// #16
}
 11354a0:	a94153f3 	ldp	x19, x20, [sp, #16]
 11354a4:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11354a8:	a94363f7 	ldp	x23, x24, [sp, #48]
 11354ac:	a8c47bfd 	ldp	x29, x30, [sp], #64
 11354b0:	d65f03c0 	ret
      for (i = 0; ltc_ecc_curves[i].prime != NULL; i++) {
 11354b4:	11000694 	add	w20, w20, #0x1
 11354b8:	17ffffad 	b	113536c <ecc_find_curve+0x5c>

00000000011354bc <ecc_free>:
  Free an ECC key from memory
  @param key   The key you wish to free
*/
void ecc_free(ecc_key *key)
{
   LTC_ARGCHKVD(key != NULL);
 11354bc:	b40002c0 	cbz	x0, 1135514 <ecc_free+0x58>
{
 11354c0:	d100c3ff 	sub	sp, sp, #0x30

   mp_cleanup_multi(&key->dp.prime, &key->dp.order,
 11354c4:	9103c001 	add	x1, x0, #0xf0
 11354c8:	91036007 	add	x7, x0, #0xd8
 11354cc:	91010006 	add	x6, x0, #0x40
 11354d0:	9100e005 	add	x5, x0, #0x38
 11354d4:	9100c004 	add	x4, x0, #0x30
{
 11354d8:	a9027bfd 	stp	x29, x30, [sp, #32]
 11354dc:	910083fd 	add	x29, sp, #0x20
   mp_cleanup_multi(&key->dp.prime, &key->dp.order,
 11354e0:	91008003 	add	x3, x0, #0x20
 11354e4:	91006002 	add	x2, x0, #0x18
 11354e8:	a9017fe1 	stp	x1, xzr, [sp, #16]
 11354ec:	9103a001 	add	x1, x0, #0xe8
 11354f0:	f90007e1 	str	x1, [sp, #8]
 11354f4:	91038001 	add	x1, x0, #0xe0
 11354f8:	f90003e1 	str	x1, [sp]
 11354fc:	9100a001 	add	x1, x0, #0x28
 1135500:	91004000 	add	x0, x0, #0x10
 1135504:	97fff32b 	bl	11321b0 <ltc_cleanup_multi>
                    &key->dp.A, &key->dp.B,
                    &key->dp.base.x, &key->dp.base.y, &key->dp.base.z,
                    &key->pubkey.x, &key->pubkey.y, &key->pubkey.z,
                    &key->k, NULL);
}
 1135508:	a9427bfd 	ldp	x29, x30, [sp, #32]
 113550c:	9100c3ff 	add	sp, sp, #0x30
 1135510:	d65f03c0 	ret
 1135514:	d65f03c0 	ret

0000000001135518 <ecc_generate_key>:
   if ((err = ecc_generate_key(prng, wprng, key)) != CRYPT_OK) { return err; }
   return CRYPT_OK;
}

int ecc_generate_key(prng_state *prng, int wprng, ecc_key *key)
{
 1135518:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 113551c:	2a0103e3 	mov	w3, w1
 1135520:	910003fd 	mov	x29, sp
 1135524:	f90013f5 	str	x21, [sp, #32]
   int            err;

   LTC_ARGCHK(ltc_mp.name != NULL);
 1135528:	b0000135 	adrp	x21, 115a000 <__scattered_array_1phys_mem_map+0x8>
{
 113552c:	a90153f3 	stp	x19, x20, [sp, #16]
   LTC_ARGCHK(ltc_mp.name != NULL);
 1135530:	f941d6b5 	ldr	x21, [x21, #936]
 1135534:	f94002a1 	ldr	x1, [x21]
 1135538:	b40003e1 	cbz	x1, 11355b4 <ecc_generate_key+0x9c>
 113553c:	aa0203f3 	mov	x19, x2
   LTC_ARGCHK(key         != NULL);
 1135540:	b40003a2 	cbz	x2, 11355b4 <ecc_generate_key+0x9c>
   LTC_ARGCHK(key->dp.size > 0);
 1135544:	b9400841 	ldr	w1, [x2, #8]
 1135548:	7100003f 	cmp	w1, #0x0
 113554c:	5400034d 	b.le	11355b4 <ecc_generate_key+0x9c>
    *  a/ N = bitlen(order)
    *  b/ generate N random bits and convert them into big integer k
    *  c/ if k not in [1, order-1] go to b/
    *  e/ Q = k*G
    */
   if ((err = rand_bn_upto(key->k, key->dp.order, prng, wprng)) != CRYPT_OK) {
 1135550:	aa0003e2 	mov	x2, x0
 1135554:	f9401661 	ldr	x1, [x19, #40]
 1135558:	f9407a60 	ldr	x0, [x19, #240]
 113555c:	97fff381 	bl	1132360 <rand_bn_upto>
 1135560:	2a0003f4 	mov	w20, w0
 1135564:	35000220 	cbnz	w0, 11355a8 <ecc_generate_key+0x90>
      goto error;
   }

   /* make the public key */
   if ((err = ltc_mp.ecc_ptmul(key->k, &key->dp.base, &key->pubkey, key->dp.A, key->dp.prime, 1)) != CRYPT_OK) {
 1135568:	a9410e64 	ldp	x4, x3, [x19, #16]
 113556c:	91036262 	add	x2, x19, #0xd8
 1135570:	f9407a60 	ldr	x0, [x19, #240]
 1135574:	9100c261 	add	x1, x19, #0x30
 1135578:	f940b2a6 	ldr	x6, [x21, #352]
 113557c:	52800025 	mov	w5, #0x1                   	// #1
 1135580:	d63f00c0 	blr	x6
 1135584:	2a0003f4 	mov	w20, w0
 1135588:	35000100 	cbnz	w0, 11355a8 <ecc_generate_key+0x90>
      goto error;
   }
   key->type = PK_PRIVATE;
 113558c:	52800020 	mov	w0, #0x1                   	// #1
 1135590:	b9000260 	str	w0, [x19]

error:
   ecc_free(key);
cleanup:
   return err;
}
 1135594:	2a1403e0 	mov	w0, w20
 1135598:	a94153f3 	ldp	x19, x20, [sp, #16]
 113559c:	f94013f5 	ldr	x21, [sp, #32]
 11355a0:	a8c37bfd 	ldp	x29, x30, [sp], #48
 11355a4:	d65f03c0 	ret
   ecc_free(key);
 11355a8:	aa1303e0 	mov	x0, x19
 11355ac:	97ffffc4 	bl	11354bc <ecc_free>
 11355b0:	17fffff9 	b	1135594 <ecc_generate_key+0x7c>
   LTC_ARGCHK(ltc_mp.name != NULL);
 11355b4:	52800214 	mov	w20, #0x10                  	// #16
 11355b8:	17fffff7 	b	1135594 <ecc_generate_key+0x7c>

00000000011355bc <ecc_make_key>:
{
 11355bc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 11355c0:	910003fd 	mov	x29, sp
 11355c4:	a90153f3 	stp	x19, x20, [sp, #16]
 11355c8:	aa0003f4 	mov	x20, x0
 11355cc:	aa0303f3 	mov	x19, x3
 11355d0:	2a0203e0 	mov	w0, w2
 11355d4:	f90013f5 	str	x21, [sp, #32]
 11355d8:	2a0103f5 	mov	w21, w1
   if ((err = ecc_set_curve_by_size(keysize, key)) != CRYPT_OK) { return err; }
 11355dc:	aa0303e1 	mov	x1, x3
 11355e0:	94000073 	bl	11357ac <ecc_set_curve_by_size>
 11355e4:	35000100 	cbnz	w0, 1135604 <ecc_make_key+0x48>
   if ((err = ecc_generate_key(prng, wprng, key)) != CRYPT_OK)  { return err; }
 11355e8:	aa1303e2 	mov	x2, x19
 11355ec:	2a1503e1 	mov	w1, w21
 11355f0:	aa1403e0 	mov	x0, x20
}
 11355f4:	a94153f3 	ldp	x19, x20, [sp, #16]
 11355f8:	f94013f5 	ldr	x21, [sp, #32]
 11355fc:	a8c37bfd 	ldp	x29, x30, [sp], #48
   if ((err = ecc_generate_key(prng, wprng, key)) != CRYPT_OK)  { return err; }
 1135600:	17ffffc6 	b	1135518 <ecc_generate_key>
}
 1135604:	a94153f3 	ldp	x19, x20, [sp, #16]
 1135608:	f94013f5 	ldr	x21, [sp, #32]
 113560c:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1135610:	d65f03c0 	ret

0000000001135614 <ecc_set_curve>:
#include "tomcrypt_private.h"

#ifdef LTC_MECC

int ecc_set_curve(const ltc_ecc_curve *cu, ecc_key *key)
{
 1135614:	d10143ff 	sub	sp, sp, #0x50
 1135618:	a9027bfd 	stp	x29, x30, [sp, #32]
 113561c:	910083fd 	add	x29, sp, #0x20
 1135620:	a90353f3 	stp	x19, x20, [sp, #48]
 1135624:	a9045bf5 	stp	x21, x22, [sp, #64]
   int err;

   LTC_ARGCHK(key != NULL);
 1135628:	b4000be1 	cbz	x1, 11357a4 <ecc_set_curve+0x190>
 113562c:	aa0003f4 	mov	x20, x0
   LTC_ARGCHK(cu != NULL);
 1135630:	b4000ba0 	cbz	x0, 11357a4 <ecc_set_curve+0x190>
 1135634:	aa0103f5 	mov	x21, x1

   if ((err = mp_init_multi(&key->dp.prime, &key->dp.order, &key->dp.A, &key->dp.B,
 1135638:	9103c020 	add	x0, x1, #0xf0
 113563c:	a9017fe0 	stp	x0, xzr, [sp, #16]
 1135640:	9103a2a0 	add	x0, x21, #0xe8
 1135644:	91036027 	add	x7, x1, #0xd8
 1135648:	f90007e0 	str	x0, [sp, #8]
 113564c:	910382a0 	add	x0, x21, #0xe0
 1135650:	f90003e0 	str	x0, [sp]
 1135654:	91010026 	add	x6, x1, #0x40
 1135658:	9100e025 	add	x5, x1, #0x38
 113565c:	9100c024 	add	x4, x1, #0x30
 1135660:	91008023 	add	x3, x1, #0x20
 1135664:	91006022 	add	x2, x1, #0x18
 1135668:	910042a0 	add	x0, x21, #0x10
 113566c:	9100a021 	add	x1, x1, #0x28
 1135670:	97fff211 	bl	1131eb4 <ltc_init_multi>
 1135674:	2a0003f3 	mov	w19, w0
 1135678:	350008a0 	cbnz	w0, 113578c <ecc_set_curve+0x178>
                            NULL)) != CRYPT_OK) {
      return err;
   }

   /* A, B, order, prime, Gx, Gy */
   if ((err = mp_read_radix(key->dp.prime, cu->prime, 16)) != CRYPT_OK) { goto error; }
 113567c:	b0000136 	adrp	x22, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1135680:	52800202 	mov	w2, #0x10                  	// #16
 1135684:	f9400281 	ldr	x1, [x20]
 1135688:	f941d6d6 	ldr	x22, [x22, #936]
 113568c:	f9400aa0 	ldr	x0, [x21, #16]
 1135690:	f94046c3 	ldr	x3, [x22, #136]
 1135694:	d63f0060 	blr	x3
 1135698:	2a0003f3 	mov	w19, w0
 113569c:	35000740 	cbnz	w0, 1135784 <ecc_set_curve+0x170>
   if ((err = mp_read_radix(key->dp.order, cu->order, 16)) != CRYPT_OK) { goto error; }
 11356a0:	f9400e81 	ldr	x1, [x20, #24]
 11356a4:	52800202 	mov	w2, #0x10                  	// #16
 11356a8:	f94016a0 	ldr	x0, [x21, #40]
 11356ac:	f94046c3 	ldr	x3, [x22, #136]
 11356b0:	d63f0060 	blr	x3
 11356b4:	2a0003f3 	mov	w19, w0
 11356b8:	35000660 	cbnz	w0, 1135784 <ecc_set_curve+0x170>
   if ((err = mp_read_radix(key->dp.A, cu->A, 16)) != CRYPT_OK)         { goto error; }
 11356bc:	f9400681 	ldr	x1, [x20, #8]
 11356c0:	52800202 	mov	w2, #0x10                  	// #16
 11356c4:	f9400ea0 	ldr	x0, [x21, #24]
 11356c8:	f94046c3 	ldr	x3, [x22, #136]
 11356cc:	d63f0060 	blr	x3
 11356d0:	2a0003f3 	mov	w19, w0
 11356d4:	35000580 	cbnz	w0, 1135784 <ecc_set_curve+0x170>
   if ((err = mp_read_radix(key->dp.B, cu->B, 16)) != CRYPT_OK)         { goto error; }
 11356d8:	f9400a81 	ldr	x1, [x20, #16]
 11356dc:	52800202 	mov	w2, #0x10                  	// #16
 11356e0:	f94012a0 	ldr	x0, [x21, #32]
 11356e4:	f94046c3 	ldr	x3, [x22, #136]
 11356e8:	d63f0060 	blr	x3
 11356ec:	2a0003f3 	mov	w19, w0
 11356f0:	350004a0 	cbnz	w0, 1135784 <ecc_set_curve+0x170>
   if ((err = mp_read_radix(key->dp.base.x, cu->Gx, 16)) != CRYPT_OK)   { goto error; }
 11356f4:	f9401281 	ldr	x1, [x20, #32]
 11356f8:	52800202 	mov	w2, #0x10                  	// #16
 11356fc:	f9401aa0 	ldr	x0, [x21, #48]
 1135700:	f94046c3 	ldr	x3, [x22, #136]
 1135704:	d63f0060 	blr	x3
 1135708:	2a0003f3 	mov	w19, w0
 113570c:	350003c0 	cbnz	w0, 1135784 <ecc_set_curve+0x170>
   if ((err = mp_read_radix(key->dp.base.y, cu->Gy, 16)) != CRYPT_OK)   { goto error; }
 1135710:	f9401681 	ldr	x1, [x20, #40]
 1135714:	52800202 	mov	w2, #0x10                  	// #16
 1135718:	f9401ea0 	ldr	x0, [x21, #56]
 113571c:	f94046c3 	ldr	x3, [x22, #136]
 1135720:	d63f0060 	blr	x3
 1135724:	2a0003f3 	mov	w19, w0
 1135728:	350002e0 	cbnz	w0, 1135784 <ecc_set_curve+0x170>
   if ((err = mp_set(key->dp.base.z, 1)) != CRYPT_OK)                   { goto error; }
 113572c:	f94022a0 	ldr	x0, [x21, #64]
 1135730:	d2800021 	mov	x1, #0x1                   	// #1
 1135734:	f94022c2 	ldr	x2, [x22, #64]
 1135738:	d63f0040 	blr	x2
 113573c:	2a0003f3 	mov	w19, w0
 1135740:	35000220 	cbnz	w0, 1135784 <ecc_set_curve+0x170>
   /* cofactor & size */
   key->dp.cofactor = cu->cofactor;
   key->dp.size = mp_unsigned_bin_size(key->dp.prime);
 1135744:	b0000136 	adrp	x22, 115a000 <__scattered_array_1phys_mem_map+0x8>
   key->dp.cofactor = cu->cofactor;
 1135748:	f9401a80 	ldr	x0, [x20, #48]
   key->dp.size = mp_unsigned_bin_size(key->dp.prime);
 113574c:	f941d6d6 	ldr	x22, [x22, #936]
 1135750:	f9404ec1 	ldr	x1, [x22, #152]
   key->dp.cofactor = cu->cofactor;
 1135754:	f90026a0 	str	x0, [x21, #72]
   key->dp.size = mp_unsigned_bin_size(key->dp.prime);
 1135758:	f9400aa0 	ldr	x0, [x21, #16]
 113575c:	d63f0020 	blr	x1
 1135760:	b9000aa0 	str	w0, [x21, #8]
   /* OID string >> unsigned long oid[16] + oidlen */
   key->dp.oidlen = 16;
 1135764:	aa1503e2 	mov	x2, x21
 1135768:	d2800200 	mov	x0, #0x10                  	// #16
   if ((err = pk_oid_str_to_num(cu->OID, key->dp.oid, &key->dp.oidlen)) != CRYPT_OK) { goto error; }
 113576c:	910142a1 	add	x1, x21, #0x50
   key->dp.oidlen = 16;
 1135770:	f80d0c40 	str	x0, [x2, #208]!
   if ((err = pk_oid_str_to_num(cu->OID, key->dp.oid, &key->dp.oidlen)) != CRYPT_OK) { goto error; }
 1135774:	f9401e80 	ldr	x0, [x20, #56]
 1135778:	940014cd 	bl	113aaac <pk_oid_str_to_num>
 113577c:	2a0003f3 	mov	w19, w0
 1135780:	34000060 	cbz	w0, 113578c <ecc_set_curve+0x178>
   /* success */
   return CRYPT_OK;

error:
   ecc_free(key);
 1135784:	aa1503e0 	mov	x0, x21
 1135788:	97ffff4d 	bl	11354bc <ecc_free>
   return err;
}
 113578c:	2a1303e0 	mov	w0, w19
 1135790:	a9427bfd 	ldp	x29, x30, [sp, #32]
 1135794:	a94353f3 	ldp	x19, x20, [sp, #48]
 1135798:	a9445bf5 	ldp	x21, x22, [sp, #64]
 113579c:	910143ff 	add	sp, sp, #0x50
 11357a0:	d65f03c0 	ret
   LTC_ARGCHK(key != NULL);
 11357a4:	52800213 	mov	w19, #0x10                  	// #16
 11357a8:	17fffff9 	b	113578c <ecc_set_curve+0x178>

00000000011357ac <ecc_set_curve_by_size>:

int ecc_set_curve_by_size(int size, ecc_key *key)
{
 11357ac:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
   const ltc_ecc_curve *cu = NULL;
   int err = CRYPT_ERROR;

   /* for compatibility with libtomcrypt-1.17 the sizes below must match the specific curves */
   if (size <= 14) {
 11357b0:	7100381f 	cmp	w0, #0xe
{
 11357b4:	910003fd 	mov	x29, sp
 11357b8:	f9000bf3 	str	x19, [sp, #16]
 11357bc:	aa0103f3 	mov	x19, x1
   const ltc_ecc_curve *cu = NULL;
 11357c0:	f90017ff 	str	xzr, [sp, #40]
   if (size <= 14) {
 11357c4:	5400016c 	b.gt	11357f0 <ecc_set_curve_by_size+0x44>
      err = ecc_find_curve("SECP112R1", &cu);
 11357c8:	b0000100 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 11357cc:	9100a3e1 	add	x1, sp, #0x28
 11357d0:	911fe000 	add	x0, x0, #0x7f8
   }
   else if (size <= 48) {
      err = ecc_find_curve("SECP384R1", &cu);
   }
   else if (size <= 66) {
      err = ecc_find_curve("SECP521R1", &cu);
 11357d4:	97fffecf 	bl	1135310 <ecc_find_curve>
   }

   if (err == CRYPT_OK && cu != NULL) return ecc_set_curve(cu, key);
 11357d8:	35000580 	cbnz	w0, 1135888 <ecc_set_curve_by_size+0xdc>
 11357dc:	f94017e0 	ldr	x0, [sp, #40]
 11357e0:	b4000540 	cbz	x0, 1135888 <ecc_set_curve_by_size+0xdc>
 11357e4:	aa1303e1 	mov	x1, x19
 11357e8:	97ffff8b 	bl	1135614 <ecc_set_curve>
 11357ec:	14000028 	b	113588c <ecc_set_curve_by_size+0xe0>
   else if (size <= 16) {
 11357f0:	7100401f 	cmp	w0, #0x10
 11357f4:	540000ac 	b.gt	1135808 <ecc_set_curve_by_size+0x5c>
      err = ecc_find_curve("SECP128R1", &cu);
 11357f8:	b0000100 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 11357fc:	9100a3e1 	add	x1, sp, #0x28
 1135800:	9120b400 	add	x0, x0, #0x82d
 1135804:	17fffff4 	b	11357d4 <ecc_set_curve_by_size+0x28>
   else if (size <= 20) {
 1135808:	7100501f 	cmp	w0, #0x14
 113580c:	540000ac 	b.gt	1135820 <ecc_set_curve_by_size+0x74>
      err = ecc_find_curve("SECP160R1", &cu);
 1135810:	b0000100 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 1135814:	9100a3e1 	add	x1, sp, #0x28
 1135818:	91218800 	add	x0, x0, #0x862
 113581c:	17ffffee 	b	11357d4 <ecc_set_curve_by_size+0x28>
   else if (size <= 24) {
 1135820:	7100601f 	cmp	w0, #0x18
 1135824:	540000ac 	b.gt	1135838 <ecc_set_curve_by_size+0x8c>
      err = ecc_find_curve("SECP192R1", &cu);
 1135828:	b0000100 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 113582c:	9100a3e1 	add	x1, sp, #0x28
 1135830:	9122d400 	add	x0, x0, #0x8b5
 1135834:	17ffffe8 	b	11357d4 <ecc_set_curve_by_size+0x28>
   else if (size <= 28) {
 1135838:	7100701f 	cmp	w0, #0x1c
 113583c:	540000ac 	b.gt	1135850 <ecc_set_curve_by_size+0xa4>
      err = ecc_find_curve("SECP224R1", &cu);
 1135840:	b0000100 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 1135844:	9100a3e1 	add	x1, sp, #0x28
 1135848:	9124e800 	add	x0, x0, #0x93a
 113584c:	17ffffe2 	b	11357d4 <ecc_set_curve_by_size+0x28>
   else if (size <= 32) {
 1135850:	7100801f 	cmp	w0, #0x20
 1135854:	540000ac 	b.gt	1135868 <ecc_set_curve_by_size+0xbc>
      err = ecc_find_curve("SECP256R1", &cu);
 1135858:	b0000100 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 113585c:	9100a3e1 	add	x1, sp, #0x28
 1135860:	9125f400 	add	x0, x0, #0x97d
 1135864:	17ffffdc 	b	11357d4 <ecc_set_curve_by_size+0x28>
   else if (size <= 48) {
 1135868:	7100c01f 	cmp	w0, #0x30
 113586c:	540000ac 	b.gt	1135880 <ecc_set_curve_by_size+0xd4>
      err = ecc_find_curve("SECP384R1", &cu);
 1135870:	b0000100 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 1135874:	9100a3e1 	add	x1, sp, #0x28
 1135878:	91271000 	add	x0, x0, #0x9c4
 113587c:	17ffffd6 	b	11357d4 <ecc_set_curve_by_size+0x28>
   else if (size <= 66) {
 1135880:	7101081f 	cmp	w0, #0x42
 1135884:	540000ad 	b.le	1135898 <ecc_set_curve_by_size+0xec>

   return CRYPT_INVALID_ARG;
 1135888:	52800200 	mov	w0, #0x10                  	// #16
}
 113588c:	f9400bf3 	ldr	x19, [sp, #16]
 1135890:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1135894:	d65f03c0 	ret
      err = ecc_find_curve("SECP521R1", &cu);
 1135898:	b0000100 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 113589c:	9100a3e1 	add	x1, sp, #0x28
 11358a0:	9127a400 	add	x0, x0, #0x9e9
 11358a4:	17ffffcc 	b	11357d4 <ecc_set_curve_by_size+0x28>

00000000011358a8 <ecc_shared_secret>:
  @param outlen           [in/out] The max size and resulting size of the shared secret
  @return CRYPT_OK if successful
*/
int ecc_shared_secret(const ecc_key *private_key, const ecc_key *public_key,
                      unsigned char *out, unsigned long *outlen)
{
 11358a8:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 11358ac:	910003fd 	mov	x29, sp
 11358b0:	a90153f3 	stp	x19, x20, [sp, #16]
 11358b4:	a9025bf5 	stp	x21, x22, [sp, #32]
 11358b8:	a90363f7 	stp	x23, x24, [sp, #48]
 11358bc:	a9046bf9 	stp	x25, x26, [sp, #64]
   unsigned long  x;
   ecc_point     *result;
   void          *prime, *a;
   int            err;

   LTC_ARGCHK(private_key != NULL);
 11358c0:	b4000760 	cbz	x0, 11359ac <ecc_shared_secret+0x104>
 11358c4:	aa0103f4 	mov	x20, x1
   LTC_ARGCHK(public_key  != NULL);
 11358c8:	b4000721 	cbz	x1, 11359ac <ecc_shared_secret+0x104>
 11358cc:	aa0203f8 	mov	x24, x2
   LTC_ARGCHK(out         != NULL);
 11358d0:	b40006e2 	cbz	x2, 11359ac <ecc_shared_secret+0x104>
 11358d4:	aa0303f6 	mov	x22, x3
   LTC_ARGCHK(outlen      != NULL);
 11358d8:	b40006a3 	cbz	x3, 11359ac <ecc_shared_secret+0x104>

   /* type valid? */
   if (private_key->type != PK_PRIVATE) {
 11358dc:	b940001a 	ldr	w26, [x0]
 11358e0:	aa0003f3 	mov	x19, x0
 11358e4:	7100075f 	cmp	w26, #0x1
 11358e8:	54000661 	b.ne	11359b4 <ecc_shared_secret+0x10c>  // b.any
      return CRYPT_PK_NOT_PRIVATE;
   }

   /* make new point */
   result = ltc_ecc_new_point();
 11358ec:	94000752 	bl	1137634 <ltc_ecc_new_point>
 11358f0:	aa0003f5 	mov	x21, x0
   if (result == NULL) {
 11358f4:	b4000640 	cbz	x0, 11359bc <ecc_shared_secret+0x114>
   }

   prime = private_key->dp.prime;
   a     = private_key->dp.A;

   if ((err = ltc_mp.ecc_ptmul(private_key->k, &public_key->pubkey, result, a, prime, 1)) != CRYPT_OK)   { goto done; }
 11358f8:	b0000137 	adrp	x23, 115a000 <__scattered_array_1phys_mem_map+0x8>
 11358fc:	aa0003e2 	mov	x2, x0
 1135900:	a9410e79 	ldp	x25, x3, [x19, #16]
 1135904:	2a1a03e5 	mov	w5, w26
 1135908:	f941d6f7 	ldr	x23, [x23, #936]
 113590c:	91036281 	add	x1, x20, #0xd8
 1135910:	f9407a60 	ldr	x0, [x19, #240]
 1135914:	f940b2e6 	ldr	x6, [x23, #352]
 1135918:	aa1903e4 	mov	x4, x25
 113591c:	d63f00c0 	blr	x6
 1135920:	2a0003f3 	mov	w19, w0
 1135924:	35000140 	cbnz	w0, 113594c <ecc_shared_secret+0xa4>

   x = (unsigned long)mp_unsigned_bin_size(prime);
 1135928:	f9404ee1 	ldr	x1, [x23, #152]
 113592c:	aa1903e0 	mov	x0, x25
 1135930:	d63f0020 	blr	x1
 1135934:	aa0003f4 	mov	x20, x0
   if (*outlen < x) {
 1135938:	f94002c0 	ldr	x0, [x22]
 113593c:	eb14001f 	cmp	x0, x20
 1135940:	54000182 	b.cs	1135970 <ecc_shared_secret+0xc8>  // b.hs, b.nlast
      *outlen = x;
      err = CRYPT_BUFFER_OVERFLOW;
 1135944:	528000d3 	mov	w19, #0x6                   	// #6
      *outlen = x;
 1135948:	f90002d4 	str	x20, [x22]
   if ((err = mp_to_unsigned_bin(result->x, out + (x - mp_unsigned_bin_size(result->x))))   != CRYPT_OK) { goto done; }

   err     = CRYPT_OK;
   *outlen = x;
done:
   ltc_ecc_del_point(result);
 113594c:	aa1503e0 	mov	x0, x21
 1135950:	9400074f 	bl	113768c <ltc_ecc_del_point>
   return err;
}
 1135954:	2a1303e0 	mov	w0, w19
 1135958:	a94153f3 	ldp	x19, x20, [sp, #16]
 113595c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1135960:	a94363f7 	ldp	x23, x24, [sp, #48]
 1135964:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1135968:	a8c57bfd 	ldp	x29, x30, [sp], #80
 113596c:	d65f03c0 	ret
   zeromem(out, x);
 1135970:	aa1403e1 	mov	x1, x20
 1135974:	aa1803e0 	mov	x0, x24
 1135978:	97fff2b3 	bl	1132444 <zeromem>
   if ((err = mp_to_unsigned_bin(result->x, out + (x - mp_unsigned_bin_size(result->x))))   != CRYPT_OK) { goto done; }
 113597c:	a949e6e1 	ldp	x1, x25, [x23, #152]
 1135980:	f94002b3 	ldr	x19, [x21]
 1135984:	aa1303e0 	mov	x0, x19
 1135988:	d63f0020 	blr	x1
 113598c:	cb000281 	sub	x1, x20, x0
 1135990:	8b010301 	add	x1, x24, x1
 1135994:	aa1303e0 	mov	x0, x19
 1135998:	d63f0320 	blr	x25
 113599c:	2a0003f3 	mov	w19, w0
 11359a0:	35fffd60 	cbnz	w0, 113594c <ecc_shared_secret+0xa4>
   *outlen = x;
 11359a4:	f90002d4 	str	x20, [x22]
 11359a8:	17ffffe9 	b	113594c <ecc_shared_secret+0xa4>
   LTC_ARGCHK(private_key != NULL);
 11359ac:	52800213 	mov	w19, #0x10                  	// #16
 11359b0:	17ffffe9 	b	1135954 <ecc_shared_secret+0xac>
      return CRYPT_PK_NOT_PRIVATE;
 11359b4:	528001f3 	mov	w19, #0xf                   	// #15
 11359b8:	17ffffe7 	b	1135954 <ecc_shared_secret+0xac>
      return CRYPT_MEM;
 11359bc:	528001b3 	mov	w19, #0xd                   	// #13
 11359c0:	17ffffe5 	b	1135954 <ecc_shared_secret+0xac>

00000000011359c4 <ecc_sign_hash_ex>:
*/
int ecc_sign_hash_ex(const unsigned char *in,  unsigned long inlen,
                     unsigned char *out, unsigned long *outlen,
                     prng_state *prng, int wprng, ecc_signature_type sigformat,
                     int *recid, const ecc_key *key)
{
 11359c4:	d10a83ff 	sub	sp, sp, #0x2a0
 11359c8:	a9027bfd 	stp	x29, x30, [sp, #32]
 11359cc:	910083fd 	add	x29, sp, #0x20
 11359d0:	a90353f3 	stp	x19, x20, [sp, #48]
 11359d4:	a9045bf5 	stp	x21, x22, [sp, #64]
 11359d8:	a90563f7 	stp	x23, x24, [sp, #80]
 11359dc:	a9066bf9 	stp	x25, x26, [sp, #96]
 11359e0:	a90773fb 	stp	x27, x28, [sp, #112]
 11359e4:	b90087e6 	str	w6, [sp, #132]
 11359e8:	f9004be7 	str	x7, [sp, #144]
 11359ec:	f90053e4 	str	x4, [sp, #160]
 11359f0:	b900afe5 	str	w5, [sp, #172]
 11359f4:	f94153fa 	ldr	x26, [sp, #672]
   int           v = 0;
   int           err, max_iterations = LTC_PK_MAX_RETRIES;
   unsigned long pbits, pbytes, i, shift_right;
   unsigned char ch, buf[MAXBLOCKSIZE];

   LTC_ARGCHK(in     != NULL);
 11359f8:	b4002ba0 	cbz	x0, 1135f6c <ecc_sign_hash_ex+0x5a8>
 11359fc:	aa0203f5 	mov	x21, x2
   LTC_ARGCHK(out    != NULL);
 1135a00:	b4002b62 	cbz	x2, 1135f6c <ecc_sign_hash_ex+0x5a8>
 1135a04:	aa0303f7 	mov	x23, x3
   LTC_ARGCHK(outlen != NULL);
 1135a08:	b4002b23 	cbz	x3, 1135f6c <ecc_sign_hash_ex+0x5a8>
   LTC_ARGCHK(key    != NULL);
 1135a0c:	b4002b1a 	cbz	x26, 1135f6c <ecc_sign_hash_ex+0x5a8>
 1135a10:	aa0003fb 	mov	x27, x0

   /* is this a private key? */
   if (key->type != PK_PRIVATE) {
 1135a14:	b9400340 	ldr	w0, [x26]
 1135a18:	7100041f 	cmp	w0, #0x1
 1135a1c:	54002ac1 	b.ne	1135f74 <ecc_sign_hash_ex+0x5b0>  // b.any
 1135a20:	aa0103f3 	mov	x19, x1
      return CRYPT_PK_NOT_PRIVATE;
   }

   /* init the bignums */
   if ((err = mp_init_multi(&r, &s, &e, &b, NULL)) != CRYPT_OK) {
 1135a24:	910323e3 	add	x3, sp, #0xc8
 1135a28:	910303e2 	add	x2, sp, #0xc0
 1135a2c:	9102e3e1 	add	x1, sp, #0xb8
 1135a30:	9102c3e0 	add	x0, sp, #0xb0
 1135a34:	d2800004 	mov	x4, #0x0                   	// #0
 1135a38:	97fff11f 	bl	1131eb4 <ltc_init_multi>
 1135a3c:	2a0003f4 	mov	w20, w0
 1135a40:	35001060 	cbnz	w0, 1135c4c <ecc_sign_hash_ex+0x288>
      return err;
   }

   /* get the hash and load it as a bignum into 'e' */
   p = key->dp.order;
   pbits = mp_count_bits(p);
 1135a44:	b0000138 	adrp	x24, 115a000 <__scattered_array_1phys_mem_map+0x8>
   p = key->dp.order;
 1135a48:	f9401756 	ldr	x22, [x26, #40]
   pbits = mp_count_bits(p);
 1135a4c:	f941d71c 	ldr	x28, [x24, #936]
 1135a50:	aa1603e0 	mov	x0, x22
 1135a54:	f9403b81 	ldr	x1, [x28, #112]
 1135a58:	d63f0020 	blr	x1
 1135a5c:	93407c03 	sxtw	x3, w0
   pbytes = (pbits+7) >> 3;
 1135a60:	91001c79 	add	x25, x3, #0x7
 1135a64:	f90047f8 	str	x24, [sp, #136]
   if (pbits > inlen*8) {
 1135a68:	eb130c7f 	cmp	x3, x19, lsl #3
   pbytes = (pbits+7) >> 3;
 1135a6c:	d343ff39 	lsr	x25, x25, #3
   if (pbits > inlen*8) {
 1135a70:	54000649 	b.ls	1135b38 <ecc_sign_hash_ex+0x174>  // b.plast
      if ((err = mp_read_unsigned_bin(e, (unsigned char *)in, inlen)) != CRYPT_OK)    { goto errnokey; }
 1135a74:	f9405783 	ldr	x3, [x28, #168]
 1135a78:	aa1303e2 	mov	x2, x19
 1135a7c:	f94063e0 	ldr	x0, [sp, #192]
 1135a80:	aa1b03e1 	mov	x1, x27
 1135a84:	d63f0060 	blr	x3
 1135a88:	2a0003f3 	mov	w19, w0
 1135a8c:	35000d60 	cbnz	w0, 1135c38 <ecc_sign_hash_ex+0x274>
   }
   else {
      shift_right = 8 - pbits % 8;
      for (i=0, ch=0; i<pbytes; i++) {
        buf[i] = ch;
        ch = (in[i] << (8-shift_right));
 1135a90:	52800280 	mov	w0, #0x14                  	// #20
 1135a94:	b900abe0 	str	w0, [sp, #168]
   do {
      if ((err = ecc_copy_curve(key, &pubkey)) != CRYPT_OK)                { goto errnokey; }
      if ((err = ecc_generate_key(prng, wprng, &pubkey)) != CRYPT_OK)      { goto errnokey; }

      /* find r = x1 mod n */
      if ((err = mp_mod(pubkey.pubkey.x, p, r)) != CRYPT_OK)               { goto error; }
 1135a98:	f94047e0 	ldr	x0, [sp, #136]
      if ((err = ecc_copy_curve(key, &pubkey)) != CRYPT_OK)                { goto errnokey; }
 1135a9c:	9106a3fb 	add	x27, sp, #0x1a8
      if ((err = mp_mod(pubkey.pubkey.x, p, r)) != CRYPT_OK)               { goto error; }
 1135aa0:	f941d400 	ldr	x0, [x0, #936]
 1135aa4:	f9004fe0 	str	x0, [sp, #152]

      if (recid || sigformat==LTC_ECCSIG_ETH27) {
         /* find recovery ID (if needed) */
         v = 0;
         if (mp_copy(pubkey.pubkey.x, s) != CRYPT_OK)                      { goto error; }
         while (mp_cmp_d(s, 0) == LTC_MP_GT && mp_cmp(s, p) != LTC_MP_LT) {
 1135aa8:	aa0003fc 	mov	x28, x0
      if ((err = ecc_copy_curve(key, &pubkey)) != CRYPT_OK)                { goto errnokey; }
 1135aac:	aa1b03e1 	mov	x1, x27
 1135ab0:	aa1a03e0 	mov	x0, x26
 1135ab4:	940018f0 	bl	113be74 <ecc_copy_curve>
 1135ab8:	2a0003f3 	mov	w19, w0
 1135abc:	35000be0 	cbnz	w0, 1135c38 <ecc_sign_hash_ex+0x274>
      if ((err = ecc_generate_key(prng, wprng, &pubkey)) != CRYPT_OK)      { goto errnokey; }
 1135ac0:	b940afe1 	ldr	w1, [sp, #172]
 1135ac4:	aa1b03e2 	mov	x2, x27
 1135ac8:	f94053e0 	ldr	x0, [sp, #160]
 1135acc:	97fffe93 	bl	1135518 <ecc_generate_key>
 1135ad0:	2a0003f3 	mov	w19, w0
 1135ad4:	35000b20 	cbnz	w0, 1135c38 <ecc_sign_hash_ex+0x274>
      if ((err = mp_mod(pubkey.pubkey.x, p, r)) != CRYPT_OK)               { goto error; }
 1135ad8:	f9404fe0 	ldr	x0, [sp, #152]
 1135adc:	aa1603e1 	mov	x1, x22
 1135ae0:	f9405be3 	ldr	x3, [sp, #176]
 1135ae4:	d2800002 	mov	x2, #0x0                   	// #0
 1135ae8:	f9407804 	ldr	x4, [x0, #240]
 1135aec:	f94143e0 	ldr	x0, [sp, #640]
 1135af0:	d63f0080 	blr	x4
 1135af4:	2a0003f3 	mov	w19, w0
 1135af8:	350001a0 	cbnz	w0, 1135b2c <ecc_sign_hash_ex+0x168>
      if (recid || sigformat==LTC_ECCSIG_ETH27) {
 1135afc:	f9404be0 	ldr	x0, [sp, #144]
 1135b00:	f100001f 	cmp	x0, #0x0
 1135b04:	b94087e0 	ldr	w0, [sp, #132]
 1135b08:	7a420804 	ccmp	w0, #0x2, #0x4, eq  // eq = none
 1135b0c:	540007c1 	b.ne	1135c04 <ecc_sign_hash_ex+0x240>  // b.any
         if (mp_copy(pubkey.pubkey.x, s) != CRYPT_OK)                      { goto error; }
 1135b10:	f9404fe0 	ldr	x0, [sp, #152]
 1135b14:	f9405fe1 	ldr	x1, [sp, #184]
 1135b18:	f9401c02 	ldr	x2, [x0, #56]
 1135b1c:	f94143e0 	ldr	x0, [sp, #640]
 1135b20:	d63f0040 	blr	x2
 1135b24:	2a0003f4 	mov	w20, w0
 1135b28:	34000540 	cbz	w0, 1135bd0 <ecc_sign_hash_ex+0x20c>
      goto error;
   }

   goto errnokey;
error:
   ecc_free(&pubkey);
 1135b2c:	aa1b03e0 	mov	x0, x27
 1135b30:	97fffe63 	bl	11354bc <ecc_free>
 1135b34:	14000041 	b	1135c38 <ecc_sign_hash_ex+0x274>
   else if (pbits % 8 == 0) {
 1135b38:	72000862 	ands	w2, w3, #0x7
 1135b3c:	f9405786 	ldr	x6, [x28, #168]
 1135b40:	f94063e0 	ldr	x0, [sp, #192]
 1135b44:	540000a1 	b.ne	1135b58 <ecc_sign_hash_ex+0x194>  // b.any
      if ((err = mp_read_unsigned_bin(e, (unsigned char *)in, pbytes)) != CRYPT_OK)   { goto errnokey; }
 1135b48:	aa1903e2 	mov	x2, x25
 1135b4c:	aa1b03e1 	mov	x1, x27
      if ((err = mp_read_unsigned_bin(e, (unsigned char *)buf, pbytes)) != CRYPT_OK)  { goto errnokey; }
 1135b50:	d63f00c0 	blr	x6
 1135b54:	17ffffcd 	b	1135a88 <ecc_sign_hash_ex+0xc4>
      shift_right = 8 - pbits % 8;
 1135b58:	d2800105 	mov	x5, #0x8                   	// #8
 1135b5c:	910463e1 	add	x1, sp, #0x118
 1135b60:	cb22c0a5 	sub	x5, x5, w2, sxtw
      for (i=0, ch=0; i<pbytes; i++) {
 1135b64:	52800007 	mov	w7, #0x0                   	// #0
 1135b68:	d2800004 	mov	x4, #0x0                   	// #0
 1135b6c:	eb19009f 	cmp	x4, x25
 1135b70:	54000061 	b.ne	1135b7c <ecc_sign_hash_ex+0x1b8>  // b.any
      if ((err = mp_read_unsigned_bin(e, (unsigned char *)buf, pbytes)) != CRYPT_OK)  { goto errnokey; }
 1135b74:	aa1903e2 	mov	x2, x25
 1135b78:	17fffff6 	b	1135b50 <ecc_sign_hash_ex+0x18c>
        ch = (in[i] << (8-shift_right));
 1135b7c:	38646b63 	ldrb	w3, [x27, x4]
 1135b80:	1ac22068 	lsl	w8, w3, w2
        buf[i] = buf[i] ^ (in[i] >> shift_right);
 1135b84:	1ac52863 	asr	w3, w3, w5
 1135b88:	4a070063 	eor	w3, w3, w7
        ch = (in[i] << (8-shift_right));
 1135b8c:	12001d07 	and	w7, w8, #0xff
        buf[i] = buf[i] ^ (in[i] >> shift_right);
 1135b90:	38246823 	strb	w3, [x1, x4]
      for (i=0, ch=0; i<pbytes; i++) {
 1135b94:	91000484 	add	x4, x4, #0x1
 1135b98:	17fffff5 	b	1135b6c <ecc_sign_hash_ex+0x1a8>
         while (mp_cmp_d(s, 0) == LTC_MP_GT && mp_cmp(s, p) != LTC_MP_LT) {
 1135b9c:	f9403382 	ldr	x2, [x28, #96]
 1135ba0:	aa1603e1 	mov	x1, x22
 1135ba4:	f9405fe0 	ldr	x0, [sp, #184]
 1135ba8:	d63f0040 	blr	x2
 1135bac:	3100041f 	cmn	w0, #0x1
 1135bb0:	540001c0 	b.eq	1135be8 <ecc_sign_hash_ex+0x224>  // b.none
            if ((err = mp_sub(s, p, s)) != CRYPT_OK)                       { goto error; }
 1135bb4:	f9405fe2 	ldr	x2, [sp, #184]
            v += 2;
 1135bb8:	11000a94 	add	w20, w20, #0x2
            if ((err = mp_sub(s, p, s)) != CRYPT_OK)                       { goto error; }
 1135bbc:	f9406383 	ldr	x3, [x28, #192]
 1135bc0:	aa1603e1 	mov	x1, x22
 1135bc4:	aa0203e0 	mov	x0, x2
 1135bc8:	d63f0060 	blr	x3
 1135bcc:	35001c40 	cbnz	w0, 1135f54 <ecc_sign_hash_ex+0x590>
         while (mp_cmp_d(s, 0) == LTC_MP_GT && mp_cmp(s, p) != LTC_MP_LT) {
 1135bd0:	f9403782 	ldr	x2, [x28, #104]
 1135bd4:	d2800001 	mov	x1, #0x0                   	// #0
 1135bd8:	f9405fe0 	ldr	x0, [sp, #184]
 1135bdc:	d63f0040 	blr	x2
 1135be0:	7100041f 	cmp	w0, #0x1
 1135be4:	54fffdc0 	b.eq	1135b9c <ecc_sign_hash_ex+0x1d8>  // b.none
         if (mp_isodd(pubkey.pubkey.y)) v += 1;
 1135be8:	f94047e0 	ldr	x0, [sp, #136]
 1135bec:	f941d418 	ldr	x24, [x0, #936]
 1135bf0:	f94147e0 	ldr	x0, [sp, #648]
 1135bf4:	f9402f01 	ldr	x1, [x24, #88]
 1135bf8:	d63f0020 	blr	x1
 1135bfc:	7100001f 	cmp	w0, #0x0
 1135c00:	5400038c 	b.gt	1135c70 <ecc_sign_hash_ex+0x2ac>
      if (mp_iszero(r) == LTC_MP_YES) {
 1135c04:	f94047e0 	ldr	x0, [sp, #136]
 1135c08:	d2800001 	mov	x1, #0x0                   	// #0
 1135c0c:	f941d418 	ldr	x24, [x0, #936]
 1135c10:	f9405be0 	ldr	x0, [sp, #176]
 1135c14:	f9403702 	ldr	x2, [x24, #104]
 1135c18:	d63f0040 	blr	x2
 1135c1c:	35000380 	cbnz	w0, 1135c8c <ecc_sign_hash_ex+0x2c8>
         ecc_free(&pubkey);
 1135c20:	aa1b03e0 	mov	x0, x27
 1135c24:	97fffe26 	bl	11354bc <ecc_free>
   } while (--max_iterations > 0);
 1135c28:	b940abe0 	ldr	w0, [sp, #168]
 1135c2c:	71000400 	subs	w0, w0, #0x1
 1135c30:	b900abe0 	str	w0, [sp, #168]
 1135c34:	54fff3c1 	b.ne	1135aac <ecc_sign_hash_ex+0xe8>  // b.any
errnokey:
   mp_clear_multi(r, s, e, b, NULL);
 1135c38:	a94b07e0 	ldp	x0, x1, [sp, #176]
   return err;
 1135c3c:	2a1303f4 	mov	w20, w19
   mp_clear_multi(r, s, e, b, NULL);
 1135c40:	a94c0fe2 	ldp	x2, x3, [sp, #192]
 1135c44:	d2800004 	mov	x4, #0x0                   	// #0
 1135c48:	97fff135 	bl	113211c <ltc_deinit_multi>
}
 1135c4c:	2a1403e0 	mov	w0, w20
 1135c50:	a9427bfd 	ldp	x29, x30, [sp, #32]
 1135c54:	a94353f3 	ldp	x19, x20, [sp, #48]
 1135c58:	a9445bf5 	ldp	x21, x22, [sp, #64]
 1135c5c:	a94563f7 	ldp	x23, x24, [sp, #80]
 1135c60:	a9466bf9 	ldp	x25, x26, [sp, #96]
 1135c64:	a94773fb 	ldp	x27, x28, [sp, #112]
 1135c68:	910a83ff 	add	sp, sp, #0x2a0
 1135c6c:	d65f03c0 	ret
         if (mp_isodd(pubkey.pubkey.y)) v += 1;
 1135c70:	f9402b02 	ldr	x2, [x24, #80]
 1135c74:	52800001 	mov	w1, #0x0                   	// #0
 1135c78:	f94147e0 	ldr	x0, [sp, #648]
 1135c7c:	d63f0040 	blr	x2
 1135c80:	12000000 	and	w0, w0, #0x1
 1135c84:	0b000294 	add	w20, w20, w0
 1135c88:	17ffffdf 	b	1135c04 <ecc_sign_hash_ex+0x240>
         if ((err = rand_bn_upto(b, p, prng, wprng)) != CRYPT_OK)          { goto error; } /* b = blinding value */
 1135c8c:	b940afe3 	ldr	w3, [sp, #172]
 1135c90:	aa1603e1 	mov	x1, x22
 1135c94:	f94053e2 	ldr	x2, [sp, #160]
 1135c98:	f94067e0 	ldr	x0, [sp, #200]
 1135c9c:	97fff1b1 	bl	1132360 <rand_bn_upto>
 1135ca0:	350015a0 	cbnz	w0, 1135f54 <ecc_sign_hash_ex+0x590>
         if ((err = mp_mulmod(pubkey.k, b, p, pubkey.k)) != CRYPT_OK)      { goto error; } /* k = kb */
 1135ca4:	f94067e1 	ldr	x1, [sp, #200]
 1135ca8:	aa1603e2 	mov	x2, x22
 1135cac:	f9408f04 	ldr	x4, [x24, #280]
 1135cb0:	f9414fe3 	ldr	x3, [sp, #664]
 1135cb4:	aa0303e0 	mov	x0, x3
 1135cb8:	d63f0080 	blr	x4
 1135cbc:	350014c0 	cbnz	w0, 1135f54 <ecc_sign_hash_ex+0x590>
         if ((err = mp_invmod(pubkey.k, p, pubkey.k)) != CRYPT_OK)         { goto error; } /* k = 1/kb */
 1135cc0:	f9409703 	ldr	x3, [x24, #296]
 1135cc4:	aa1603e1 	mov	x1, x22
 1135cc8:	f9414fe2 	ldr	x2, [sp, #664]
 1135ccc:	aa0203e0 	mov	x0, x2
 1135cd0:	d63f0060 	blr	x3
 1135cd4:	35001400 	cbnz	w0, 1135f54 <ecc_sign_hash_ex+0x590>
         if ((err = mp_mulmod(key->k, r, p, s)) != CRYPT_OK)               { goto error; } /* s = xr */
 1135cd8:	a94b0fe1 	ldp	x1, x3, [sp, #176]
 1135cdc:	aa1603e2 	mov	x2, x22
 1135ce0:	f9407b40 	ldr	x0, [x26, #240]
 1135ce4:	f9408f04 	ldr	x4, [x24, #280]
 1135ce8:	d63f0080 	blr	x4
 1135cec:	35001340 	cbnz	w0, 1135f54 <ecc_sign_hash_ex+0x590>
         if ((err = mp_mulmod(pubkey.k, s, p, s)) != CRYPT_OK)             { goto error; } /* s = xr/kb */
 1135cf0:	f9405fe3 	ldr	x3, [sp, #184]
 1135cf4:	aa1603e2 	mov	x2, x22
 1135cf8:	f9408f04 	ldr	x4, [x24, #280]
 1135cfc:	aa0303e1 	mov	x1, x3
 1135d00:	f9414fe0 	ldr	x0, [sp, #664]
 1135d04:	d63f0080 	blr	x4
 1135d08:	35001260 	cbnz	w0, 1135f54 <ecc_sign_hash_ex+0x590>
         if ((err = mp_mulmod(pubkey.k, e, p, e)) != CRYPT_OK)             { goto error; } /* e = e/kb */
 1135d0c:	f94063e3 	ldr	x3, [sp, #192]
 1135d10:	aa1603e2 	mov	x2, x22
 1135d14:	f9408f04 	ldr	x4, [x24, #280]
 1135d18:	aa0303e1 	mov	x1, x3
 1135d1c:	f9414fe0 	ldr	x0, [sp, #664]
 1135d20:	d63f0080 	blr	x4
 1135d24:	35001180 	cbnz	w0, 1135f54 <ecc_sign_hash_ex+0x590>
         if ((err = mp_add(e, s, s)) != CRYPT_OK)                          { goto error; } /* s = e/kb + xr/kb */
 1135d28:	a94b83e2 	ldp	x2, x0, [sp, #184]
 1135d2c:	f9405b03 	ldr	x3, [x24, #176]
 1135d30:	aa0203e1 	mov	x1, x2
 1135d34:	d63f0060 	blr	x3
 1135d38:	350010e0 	cbnz	w0, 1135f54 <ecc_sign_hash_ex+0x590>
         if ((err = mp_mulmod(s, b, p, s)) != CRYPT_OK)                    { goto error; } /* s = b(e/kb + xr/kb) = (e + xr)/k */
 1135d3c:	f9405fe3 	ldr	x3, [sp, #184]
 1135d40:	aa1603e2 	mov	x2, x22
 1135d44:	f94067e1 	ldr	x1, [sp, #200]
 1135d48:	aa0303e0 	mov	x0, x3
 1135d4c:	f9408f04 	ldr	x4, [x24, #280]
 1135d50:	d63f0080 	blr	x4
 1135d54:	35001000 	cbnz	w0, 1135f54 <ecc_sign_hash_ex+0x590>
         ecc_free(&pubkey);
 1135d58:	aa1b03e0 	mov	x0, x27
 1135d5c:	97fffdd8 	bl	11354bc <ecc_free>
         if (mp_iszero(s) == LTC_MP_NO) {
 1135d60:	f9403702 	ldr	x2, [x24, #104]
 1135d64:	d2800001 	mov	x1, #0x0                   	// #0
 1135d68:	f9405fe0 	ldr	x0, [sp, #184]
 1135d6c:	d63f0040 	blr	x2
 1135d70:	34fff5c0 	cbz	w0, 1135c28 <ecc_sign_hash_ex+0x264>
   if (recid) *recid = v;
 1135d74:	f9404be0 	ldr	x0, [sp, #144]
 1135d78:	b4000060 	cbz	x0, 1135d84 <ecc_sign_hash_ex+0x3c0>
 1135d7c:	f9404be0 	ldr	x0, [sp, #144]
 1135d80:	b9000014 	str	w20, [x0]
   if (sigformat == LTC_ECCSIG_ANSIX962) {
 1135d84:	b94087e0 	ldr	w0, [sp, #132]
 1135d88:	350001a0 	cbnz	w0, 1135dbc <ecc_sign_hash_ex+0x3f8>
      err = der_encode_sequence_multi(out, outlen,
 1135d8c:	a94b1fe4 	ldp	x4, x7, [sp, #176]
 1135d90:	b90003ff 	str	wzr, [sp]
 1135d94:	a900ffff 	stp	xzr, xzr, [sp, #8]
 1135d98:	d2800026 	mov	x6, #0x1                   	// #1
 1135d9c:	52800045 	mov	w5, #0x2                   	// #2
 1135da0:	aa0603e3 	mov	x3, x6
 1135da4:	2a0503e2 	mov	w2, w5
 1135da8:	aa1703e1 	mov	x1, x23
 1135dac:	aa1503e0 	mov	x0, x21
 1135db0:	94000f06 	bl	11399c8 <der_encode_sequence_multi>
      err = ssh_encode_sequence_multi(out, outlen,
 1135db4:	2a0003f3 	mov	w19, w0
 1135db8:	17ffffa0 	b	1135c38 <ecc_sign_hash_ex+0x274>
   else if (sigformat == LTC_ECCSIG_RFC7518) {
 1135dbc:	b94087e0 	ldr	w0, [sp, #132]
 1135dc0:	7100041f 	cmp	w0, #0x1
 1135dc4:	54000441 	b.ne	1135e4c <ecc_sign_hash_ex+0x488>  // b.any
      if (*outlen < 2*pbytes) { err = CRYPT_MEM; goto errnokey; }
 1135dc8:	f94002e0 	ldr	x0, [x23]
 1135dcc:	d37ffb36 	lsl	x22, x25, #1
 1135dd0:	eb19041f 	cmp	x0, x25, lsl #1
 1135dd4:	54000062 	b.cs	1135de0 <ecc_sign_hash_ex+0x41c>  // b.hs, b.nlast
 1135dd8:	528001b3 	mov	w19, #0xd                   	// #13
 1135ddc:	17ffff97 	b	1135c38 <ecc_sign_hash_ex+0x274>
      zeromem(out, 2*pbytes);
 1135de0:	aa1603e1 	mov	x1, x22
 1135de4:	aa1503e0 	mov	x0, x21
 1135de8:	97fff197 	bl	1132444 <zeromem>
      i = mp_unsigned_bin_size(r);
 1135dec:	f94047e0 	ldr	x0, [sp, #136]
 1135df0:	f941d414 	ldr	x20, [x0, #936]
 1135df4:	f9405be0 	ldr	x0, [sp, #176]
 1135df8:	f9404e81 	ldr	x1, [x20, #152]
 1135dfc:	d63f0020 	blr	x1
      if ((err = mp_to_unsigned_bin(r, out + (pbytes - i)))   != CRYPT_OK) { goto errnokey; }
 1135e00:	cb000321 	sub	x1, x25, x0
 1135e04:	f9405282 	ldr	x2, [x20, #160]
 1135e08:	8b0102a1 	add	x1, x21, x1
 1135e0c:	f9405be0 	ldr	x0, [sp, #176]
 1135e10:	d63f0040 	blr	x2
 1135e14:	2a0003f3 	mov	w19, w0
 1135e18:	35fff100 	cbnz	w0, 1135c38 <ecc_sign_hash_ex+0x274>
      i = mp_unsigned_bin_size(s);
 1135e1c:	f9404e81 	ldr	x1, [x20, #152]
 1135e20:	f9405fe0 	ldr	x0, [sp, #184]
 1135e24:	d63f0020 	blr	x1
      if ((err = mp_to_unsigned_bin(s, out + (2*pbytes - i))) != CRYPT_OK) { goto errnokey; }
 1135e28:	cb0002c1 	sub	x1, x22, x0
 1135e2c:	f9405282 	ldr	x2, [x20, #160]
 1135e30:	8b0102a1 	add	x1, x21, x1
 1135e34:	f9405fe0 	ldr	x0, [sp, #184]
 1135e38:	d63f0040 	blr	x2
 1135e3c:	2a0003f3 	mov	w19, w0
 1135e40:	35ffefc0 	cbnz	w0, 1135c38 <ecc_sign_hash_ex+0x274>
      *outlen = 2*pbytes;
 1135e44:	f90002f6 	str	x22, [x23]
      err = CRYPT_OK;
 1135e48:	17ffff7c 	b	1135c38 <ecc_sign_hash_ex+0x274>
   else if (sigformat == LTC_ECCSIG_ETH27) {
 1135e4c:	b94087e0 	ldr	w0, [sp, #132]
 1135e50:	7100081f 	cmp	w0, #0x2
 1135e54:	54000501 	b.ne	1135ef4 <ecc_sign_hash_ex+0x530>  // b.any
      if (pk_oid_cmp_with_ulong("1.3.132.0.10", key->dp.oid, key->dp.oidlen) != CRYPT_OK) {
 1135e58:	f9406b42 	ldr	x2, [x26, #208]
 1135e5c:	b0000100 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 1135e60:	91014341 	add	x1, x26, #0x50
 1135e64:	91268000 	add	x0, x0, #0x9a0
 1135e68:	940012ed 	bl	113aa1c <pk_oid_cmp_with_ulong>
 1135e6c:	350007c0 	cbnz	w0, 1135f64 <ecc_sign_hash_ex+0x5a0>
      if (*outlen < 65) { err = CRYPT_MEM; goto errnokey; }
 1135e70:	f94002e0 	ldr	x0, [x23]
 1135e74:	f101001f 	cmp	x0, #0x40
 1135e78:	54fffb09 	b.ls	1135dd8 <ecc_sign_hash_ex+0x414>  // b.plast
      zeromem(out, 65);
 1135e7c:	aa1503e0 	mov	x0, x21
 1135e80:	d2800821 	mov	x1, #0x41                  	// #65
 1135e84:	97fff170 	bl	1132444 <zeromem>
      i = mp_unsigned_bin_size(r);
 1135e88:	f94047e0 	ldr	x0, [sp, #136]
 1135e8c:	f941d416 	ldr	x22, [x0, #936]
 1135e90:	f9405be0 	ldr	x0, [sp, #176]
 1135e94:	f9404ec1 	ldr	x1, [x22, #152]
 1135e98:	d63f0020 	blr	x1
      if ((err = mp_to_unsigned_bin(r, out + 32 - i)) != CRYPT_OK) { goto errnokey; }
 1135e9c:	cb0002a1 	sub	x1, x21, x0
 1135ea0:	f94052c2 	ldr	x2, [x22, #160]
 1135ea4:	91008021 	add	x1, x1, #0x20
 1135ea8:	f9405be0 	ldr	x0, [sp, #176]
 1135eac:	d63f0040 	blr	x2
 1135eb0:	2a0003f3 	mov	w19, w0
 1135eb4:	35ffec20 	cbnz	w0, 1135c38 <ecc_sign_hash_ex+0x274>
      i = mp_unsigned_bin_size(s);
 1135eb8:	f9404ec1 	ldr	x1, [x22, #152]
 1135ebc:	f9405fe0 	ldr	x0, [sp, #184]
 1135ec0:	d63f0020 	blr	x1
      if ((err = mp_to_unsigned_bin(s, out + 64 - i)) != CRYPT_OK) { goto errnokey; }
 1135ec4:	cb0002a1 	sub	x1, x21, x0
 1135ec8:	f94052c2 	ldr	x2, [x22, #160]
 1135ecc:	91010021 	add	x1, x1, #0x40
 1135ed0:	f9405fe0 	ldr	x0, [sp, #184]
 1135ed4:	d63f0040 	blr	x2
 1135ed8:	2a0003f3 	mov	w19, w0
 1135edc:	35ffeae0 	cbnz	w0, 1135c38 <ecc_sign_hash_ex+0x274>
      out[64] = (unsigned char)(v + 27); /* Recovery ID is 27/28 for Ethereum */
 1135ee0:	11006e94 	add	w20, w20, #0x1b
 1135ee4:	390102b4 	strb	w20, [x21, #64]
      *outlen = 65;
 1135ee8:	d2800820 	mov	x0, #0x41                  	// #65
 1135eec:	f90002e0 	str	x0, [x23]
      err = CRYPT_OK;
 1135ef0:	17ffff52 	b	1135c38 <ecc_sign_hash_ex+0x274>
   else if (sigformat == LTC_ECCSIG_RFC5656) {
 1135ef4:	b94087e0 	ldr	w0, [sp, #132]
 1135ef8:	71000c1f 	cmp	w0, #0x3
 1135efc:	54000301 	b.ne	1135f5c <ecc_sign_hash_ex+0x598>  // b.any
      unsigned long namelen = sizeof(name);
 1135f00:	d2800800 	mov	x0, #0x40                  	// #64
      if ((err = ecc_ssh_ecdsa_encode_name(name, &namelen, key)) != CRYPT_OK) { goto errnokey; }
 1135f04:	910363f4 	add	x20, sp, #0xd8
 1135f08:	aa1a03e2 	mov	x2, x26
 1135f0c:	910343e1 	add	x1, sp, #0xd0
      unsigned long namelen = sizeof(name);
 1135f10:	f9006be0 	str	x0, [sp, #208]
      if ((err = ecc_ssh_ecdsa_encode_name(name, &namelen, key)) != CRYPT_OK) { goto errnokey; }
 1135f14:	aa1403e0 	mov	x0, x20
 1135f18:	94000019 	bl	1135f7c <ecc_ssh_ecdsa_encode_name>
 1135f1c:	2a0003f3 	mov	w19, w0
 1135f20:	35ffe8c0 	cbnz	w0, 1135c38 <ecc_sign_hash_ex+0x274>
      err = ssh_encode_sequence_multi(out, outlen,
 1135f24:	a94b1fe5 	ldp	x5, x7, [sp, #176]
 1135f28:	528000e0 	mov	w0, #0x7                   	// #7
 1135f2c:	b90003e0 	str	w0, [sp]
 1135f30:	528000a6 	mov	w6, #0x5                   	// #5
 1135f34:	f90007ff 	str	xzr, [sp, #8]
 1135f38:	2a0603e4 	mov	w4, w6
 1135f3c:	aa1403e3 	mov	x3, x20
 1135f40:	aa1703e1 	mov	x1, x23
 1135f44:	aa1503e0 	mov	x0, x21
 1135f48:	52800082 	mov	w2, #0x4                   	// #4
 1135f4c:	94000be5 	bl	1138ee0 <ssh_encode_sequence_multi>
 1135f50:	17ffff99 	b	1135db4 <ecc_sign_hash_ex+0x3f0>
         if ((err = mp_mulmod(s, b, p, s)) != CRYPT_OK)                    { goto error; } /* s = b(e/kb + xr/kb) = (e + xr)/k */
 1135f54:	2a0003f3 	mov	w19, w0
 1135f58:	17fffef5 	b	1135b2c <ecc_sign_hash_ex+0x168>
      err = CRYPT_ERROR;
 1135f5c:	52800033 	mov	w19, #0x1                   	// #1
 1135f60:	17fffef3 	b	1135b2c <ecc_sign_hash_ex+0x168>
         err = CRYPT_ERROR; goto errnokey;
 1135f64:	52800033 	mov	w19, #0x1                   	// #1
 1135f68:	17ffff34 	b	1135c38 <ecc_sign_hash_ex+0x274>
   LTC_ARGCHK(in     != NULL);
 1135f6c:	52800214 	mov	w20, #0x10                  	// #16
 1135f70:	17ffff37 	b	1135c4c <ecc_sign_hash_ex+0x288>
      return CRYPT_PK_NOT_PRIVATE;
 1135f74:	528001f4 	mov	w20, #0xf                   	// #15
 1135f78:	17ffff35 	b	1135c4c <ecc_sign_hash_ex+0x288>

0000000001135f7c <ecc_ssh_ecdsa_encode_name>:
  @param buflen    [in/out] The max size and resulting size (including terminator) of the name
  @param key       A public or private ECC key
  @return CRYPT_OK if successful
*/
int ecc_ssh_ecdsa_encode_name(char *buffer, unsigned long *buflen, const ecc_key *key)
{
 1135f7c:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
 1135f80:	910003fd 	mov	x29, sp
 1135f84:	a90153f3 	stp	x19, x20, [sp, #16]
 1135f88:	aa0103f3 	mov	x19, x1
   char oidstr[64];
   unsigned long oidlen = sizeof(oidstr);
 1135f8c:	d2800801 	mov	x1, #0x40                  	// #64
{
 1135f90:	a9025bf5 	stp	x21, x22, [sp, #32]
 1135f94:	aa0003f4 	mov	x20, x0
   unsigned long oidlen = sizeof(oidstr);
 1135f98:	f9001fe1 	str	x1, [sp, #56]
   unsigned long size = 0;
   int err;

   LTC_ARGCHK(buffer != NULL);
 1135f9c:	b40006a0 	cbz	x0, 1136070 <ecc_ssh_ecdsa_encode_name+0xf4>
   LTC_ARGCHK(buflen != NULL);
 1135fa0:	b4000693 	cbz	x19, 1136070 <ecc_ssh_ecdsa_encode_name+0xf4>
   LTC_ARGCHK(key != NULL);
 1135fa4:	b4000662 	cbz	x2, 1136070 <ecc_ssh_ecdsa_encode_name+0xf4>

   /* Get the OID of the curve */
   if ((err = ecc_get_oid_str(oidstr, &oidlen, key)) != CRYPT_OK) goto error;
 1135fa8:	8b2163f5 	add	x21, sp, x1
 1135fac:	9100e3e1 	add	x1, sp, #0x38
 1135fb0:	aa1503e0 	mov	x0, x21
 1135fb4:	94001741 	bl	113bcb8 <ecc_get_oid_str>
 1135fb8:	35000260 	cbnz	w0, 1136004 <ecc_ssh_ecdsa_encode_name+0x88>

   /* Check for three named curves: nistp256, nistp384, nistp521 */
   if (XSTRCMP("1.2.840.10045.3.1.7", oidstr) == 0) {
 1135fbc:	aa1503e1 	mov	x1, x21
 1135fc0:	b0000100 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 1135fc4:	9125a400 	add	x0, x0, #0x969
 1135fc8:	9400374d 	bl	1143cfc <strcmp>
 1135fcc:	f9400276 	ldr	x22, [x19]
 1135fd0:	35000220 	cbnz	w0, 1136014 <ecc_ssh_ecdsa_encode_name+0x98>
      /* nistp256 - secp256r1 - OID 1.2.840.10045.3.1.7 */
      size = snprintf(buffer, *buflen, "ecdsa-sha2-nistp256");
 1135fd4:	b0000102 	adrp	x2, 1156000 <ta_pub_key_modulus+0x7>
 1135fd8:	9131f442 	add	x2, x2, #0xc7d
      /* nistp384 - secp384r1 - OID 1.3.132.0.34 */
      size = snprintf(buffer, *buflen, "ecdsa-sha2-nistp384");
   }
   else if (XSTRCMP("1.3.132.0.35", oidstr) == 0) {
      /* nistp521 - secp521r1 - OID 1.3.132.0.35 */
      size = snprintf(buffer, *buflen, "ecdsa-sha2-nistp521");
 1135fdc:	aa1603e1 	mov	x1, x22
 1135fe0:	aa1403e0 	mov	x0, x20
 1135fe4:	94003706 	bl	1143bfc <snprintf>
   } else {
      /* Otherwise we use the OID... */
      size = snprintf(buffer, *buflen, "ecdsa-sha2-%s", oidstr);
 1135fe8:	93407c02 	sxtw	x2, w0
   }

   /* snprintf returns size that would have been written, but limits to buflen-1 chars plus terminator */
   if (size >= *buflen) {
 1135fec:	f9400260 	ldr	x0, [x19]
      err = CRYPT_BUFFER_OVERFLOW;
 1135ff0:	eb02001f 	cmp	x0, x2
 1135ff4:	528000c0 	mov	w0, #0x6                   	// #6
 1135ff8:	1a8083e0 	csel	w0, wzr, w0, hi  // hi = pmore
   } else {
      err = CRYPT_OK;
   }
   *buflen = size + 1; /* the string length + NUL byte */
 1135ffc:	91000442 	add	x2, x2, #0x1
 1136000:	f9000262 	str	x2, [x19]

error:
   return err;
}
 1136004:	a94153f3 	ldp	x19, x20, [sp, #16]
 1136008:	a9425bf5 	ldp	x21, x22, [sp, #32]
 113600c:	a8c87bfd 	ldp	x29, x30, [sp], #128
 1136010:	d65f03c0 	ret
   else if (XSTRCMP("1.3.132.0.34", oidstr) == 0) {
 1136014:	90000100 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 1136018:	aa1503e1 	mov	x1, x21
 113601c:	9126dc00 	add	x0, x0, #0x9b7
 1136020:	94003737 	bl	1143cfc <strcmp>
 1136024:	35000080 	cbnz	w0, 1136034 <ecc_ssh_ecdsa_encode_name+0xb8>
      size = snprintf(buffer, *buflen, "ecdsa-sha2-nistp384");
 1136028:	90000102 	adrp	x2, 1156000 <ta_pub_key_modulus+0x7>
 113602c:	91324442 	add	x2, x2, #0xc91
 1136030:	17ffffeb 	b	1135fdc <ecc_ssh_ecdsa_encode_name+0x60>
   else if (XSTRCMP("1.3.132.0.35", oidstr) == 0) {
 1136034:	90000100 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 1136038:	aa1503e1 	mov	x1, x21
 113603c:	91277000 	add	x0, x0, #0x9dc
 1136040:	9400372f 	bl	1143cfc <strcmp>
 1136044:	35000080 	cbnz	w0, 1136054 <ecc_ssh_ecdsa_encode_name+0xd8>
      size = snprintf(buffer, *buflen, "ecdsa-sha2-nistp521");
 1136048:	90000102 	adrp	x2, 1156000 <ta_pub_key_modulus+0x7>
 113604c:	91329442 	add	x2, x2, #0xca5
 1136050:	17ffffe3 	b	1135fdc <ecc_ssh_ecdsa_encode_name+0x60>
      size = snprintf(buffer, *buflen, "ecdsa-sha2-%s", oidstr);
 1136054:	aa1503e3 	mov	x3, x21
 1136058:	aa1603e1 	mov	x1, x22
 113605c:	aa1403e0 	mov	x0, x20
 1136060:	90000102 	adrp	x2, 1156000 <ta_pub_key_modulus+0x7>
 1136064:	9132e442 	add	x2, x2, #0xcb9
 1136068:	940036e5 	bl	1143bfc <snprintf>
 113606c:	17ffffdf 	b	1135fe8 <ecc_ssh_ecdsa_encode_name+0x6c>
   LTC_ARGCHK(buffer != NULL);
 1136070:	52800200 	mov	w0, #0x10                  	// #16
 1136074:	17ffffe4 	b	1136004 <ecc_ssh_ecdsa_encode_name+0x88>

0000000001136078 <ecc_verify_hash_ex>:
   @return CRYPT_OK if successful (even if the signature is not valid)
*/
int ecc_verify_hash_ex(const unsigned char *sig,  unsigned long siglen,
                       const unsigned char *hash, unsigned long hashlen,
                       ecc_signature_type sigformat, int *stat, const ecc_key *key)
{
 1136078:	d10783ff 	sub	sp, sp, #0x1e0
 113607c:	a9027bfd 	stp	x29, x30, [sp, #32]
 1136080:	910083fd 	add	x29, sp, #0x20
 1136084:	a90353f3 	stp	x19, x20, [sp, #48]
 1136088:	a9045bf5 	stp	x21, x22, [sp, #64]
 113608c:	a90563f7 	stp	x23, x24, [sp, #80]
 1136090:	a9066bf9 	stp	x25, x26, [sp, #96]
 1136094:	a90773fb 	stp	x27, x28, [sp, #112]
 1136098:	f90043e2 	str	x2, [sp, #128]
 113609c:	b9008be4 	str	w4, [sp, #136]
 11360a0:	a9090fe5 	stp	x5, x3, [sp, #144]
   ecc_point     *mG = NULL, *mQ = NULL;
   void          *r, *s, *v, *w, *u1, *u2, *e, *p, *m, *a, *a_plus3;
   void          *mu = NULL, *ma = NULL;
 11360a4:	a90f7fff 	stp	xzr, xzr, [sp, #240]
   void          *mp = NULL;
 11360a8:	f90083ff 	str	xzr, [sp, #256]
   int           err;
   unsigned long pbits, pbytes, i, shift_right;
   unsigned char ch, buf[MAXBLOCKSIZE];

   LTC_ARGCHK(sig  != NULL);
 11360ac:	b4002f20 	cbz	x0, 1136690 <ecc_verify_hash_ex+0x618>
 11360b0:	aa0003f8 	mov	x24, x0
   LTC_ARGCHK(hash != NULL);
 11360b4:	b4002ee2 	cbz	x2, 1136690 <ecc_verify_hash_ex+0x618>
   LTC_ARGCHK(stat != NULL);
 11360b8:	aa0503e0 	mov	x0, x5
 11360bc:	b4002ea5 	cbz	x5, 1136690 <ecc_verify_hash_ex+0x618>
 11360c0:	aa0603f4 	mov	x20, x6
   LTC_ARGCHK(key  != NULL);
 11360c4:	b4002e66 	cbz	x6, 1136690 <ecc_verify_hash_ex+0x618>

   /* default to invalid signature */
   *stat = 0;
 11360c8:	b900001f 	str	wzr, [x0]
 11360cc:	aa0103fb 	mov	x27, x1

   /* allocate ints */
   if ((err = mp_init_multi(&r, &s, &v, &w, &u1, &u2, &e, &a_plus3, NULL)) != CRYPT_OK) {
 11360d0:	f90003ff 	str	xzr, [sp]
 11360d4:	9103a3e7 	add	x7, sp, #0xe8
 11360d8:	910383e6 	add	x6, sp, #0xe0
 11360dc:	910363e5 	add	x5, sp, #0xd8
 11360e0:	910343e4 	add	x4, sp, #0xd0
 11360e4:	910323e3 	add	x3, sp, #0xc8
 11360e8:	910303e2 	add	x2, sp, #0xc0
 11360ec:	9102e3e1 	add	x1, sp, #0xb8
 11360f0:	9102c3e0 	add	x0, sp, #0xb0
 11360f4:	97ffef70 	bl	1131eb4 <ltc_init_multi>
 11360f8:	2a0003fa 	mov	w26, w0
 11360fc:	35002b80 	cbnz	w0, 113666c <ecc_verify_hash_ex+0x5f4>
   }

   p = key->dp.order;
   m = key->dp.prime;
   a = key->dp.A;
   if ((err = mp_add_d(a, 3, a_plus3)) != CRYPT_OK) {
 1136100:	90000123 	adrp	x3, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1136104:	d2800061 	mov	x1, #0x3                   	// #3
   a = key->dp.A;
 1136108:	a9417297 	ldp	x23, x28, [x20, #16]
   if ((err = mp_add_d(a, 3, a_plus3)) != CRYPT_OK) {
 113610c:	f941d464 	ldr	x4, [x3, #936]
 1136110:	a90a0fe4 	stp	x4, x3, [sp, #160]
 1136114:	f94077e2 	ldr	x2, [sp, #232]
 1136118:	aa1c03e0 	mov	x0, x28
 113611c:	f9405c85 	ldr	x5, [x4, #184]
   p = key->dp.order;
 1136120:	f9401699 	ldr	x25, [x20, #40]
   if ((err = mp_add_d(a, 3, a_plus3)) != CRYPT_OK) {
 1136124:	d63f00a0 	blr	x5
 1136128:	2a0003fa 	mov	w26, w0
 113612c:	f94057e3 	ldr	x3, [sp, #168]
 1136130:	aa0303f5 	mov	x21, x3
 1136134:	35002720 	cbnz	w0, 1136618 <ecc_verify_hash_ex+0x5a0>
      goto error;
   }

   /* allocate points */
   mG = ltc_ecc_new_point();
 1136138:	9400053f 	bl	1137634 <ltc_ecc_new_point>
 113613c:	aa0003f3 	mov	x19, x0
   mQ = ltc_ecc_new_point();
 1136140:	9400053d 	bl	1137634 <ltc_ecc_new_point>
   if (mQ  == NULL || mG == NULL) {
 1136144:	f100001f 	cmp	x0, #0x0
   mQ = ltc_ecc_new_point();
 1136148:	aa0003f6 	mov	x22, x0
   if (mQ  == NULL || mG == NULL) {
 113614c:	fa401a64 	ccmp	x19, #0x0, #0x4, ne  // ne = any
 1136150:	540025a0 	b.eq	1136604 <ecc_verify_hash_ex+0x58c>  // b.none
      err = CRYPT_MEM;
      goto error;
   }

   if (sigformat == LTC_ECCSIG_ANSIX962) {
 1136154:	b9408be0 	ldr	w0, [sp, #136]
 1136158:	f94053e4 	ldr	x4, [sp, #160]
 113615c:	350013a0 	cbnz	w0, 11363d0 <ecc_verify_hash_ex+0x358>
      /* ANSI X9.62 format - ASN.1 encoded SEQUENCE{ INTEGER(r), INTEGER(s) }  */
      if ((err = der_decode_sequence_multi_ex(sig, siglen, LTC_DER_SEQ_SEQUENCE | LTC_DER_SEQ_STRICT,
 1136160:	a94b03e5 	ldp	x5, x0, [sp, #176]
 1136164:	f90003e0 	str	x0, [sp]
 1136168:	b9000bff 	str	wzr, [sp, #8]
 113616c:	d2800027 	mov	x7, #0x1                   	// #1
 1136170:	a9017fff 	stp	xzr, xzr, [sp, #16]
 1136174:	52800046 	mov	w6, #0x2                   	// #2
 1136178:	aa0703e4 	mov	x4, x7
 113617c:	2a0603e3 	mov	w3, w6
 1136180:	aa1b03e1 	mov	x1, x27
 1136184:	aa1803e0 	mov	x0, x24
 1136188:	52800062 	mov	w2, #0x3                   	// #3
 113618c:	94000d2f 	bl	1139648 <der_decode_sequence_multi_ex>
      if (siglen != (2 * i)) {
         err = CRYPT_INVALID_PACKET;
         goto error;
      }
      if ((err = mp_read_unsigned_bin(r, (unsigned char *)sig,   i)) != CRYPT_OK)                       { goto error; }
      if ((err = mp_read_unsigned_bin(s, (unsigned char *)sig+i, i)) != CRYPT_OK)                       { goto error; }
 1136190:	2a0003fa 	mov	w26, w0
 1136194:	35001320 	cbnz	w0, 11363f8 <ecc_verify_hash_ex+0x380>
      err = CRYPT_ERROR;
      goto error;
   }

   /* check for zero */
   if (mp_cmp_d(r, 0) != LTC_MP_GT || mp_cmp_d(s, 0) != LTC_MP_GT ||
 1136198:	f941d6b8 	ldr	x24, [x21, #936]
 113619c:	d2800001 	mov	x1, #0x0                   	// #0
 11361a0:	f9405be0 	ldr	x0, [sp, #176]
 11361a4:	f9403702 	ldr	x2, [x24, #104]
 11361a8:	d63f0040 	blr	x2
 11361ac:	7100041f 	cmp	w0, #0x1
 11361b0:	54001221 	b.ne	11363f4 <ecc_verify_hash_ex+0x37c>  // b.any
 11361b4:	f9403702 	ldr	x2, [x24, #104]
 11361b8:	d2800001 	mov	x1, #0x0                   	// #0
 11361bc:	f9405fe0 	ldr	x0, [sp, #184]
 11361c0:	d63f0040 	blr	x2
 11361c4:	7100041f 	cmp	w0, #0x1
 11361c8:	54001161 	b.ne	11363f4 <ecc_verify_hash_ex+0x37c>  // b.any
       mp_cmp(r, p) != LTC_MP_LT || mp_cmp(s, p) != LTC_MP_LT) {
 11361cc:	f9403302 	ldr	x2, [x24, #96]
 11361d0:	aa1903e1 	mov	x1, x25
 11361d4:	f9405be0 	ldr	x0, [sp, #176]
 11361d8:	d63f0040 	blr	x2
   if (mp_cmp_d(r, 0) != LTC_MP_GT || mp_cmp_d(s, 0) != LTC_MP_GT ||
 11361dc:	3100041f 	cmn	w0, #0x1
 11361e0:	540010a1 	b.ne	11363f4 <ecc_verify_hash_ex+0x37c>  // b.any
       mp_cmp(r, p) != LTC_MP_LT || mp_cmp(s, p) != LTC_MP_LT) {
 11361e4:	f9403302 	ldr	x2, [x24, #96]
 11361e8:	aa1903e1 	mov	x1, x25
 11361ec:	f9405fe0 	ldr	x0, [sp, #184]
 11361f0:	d63f0040 	blr	x2
 11361f4:	3100041f 	cmn	w0, #0x1
 11361f8:	54000fe1 	b.ne	11363f4 <ecc_verify_hash_ex+0x37c>  // b.any
      err = CRYPT_INVALID_PACKET;
      goto error;
   }

   /* read hash - truncate if needed */
   pbits = mp_count_bits(p);
 11361fc:	f9403b01 	ldr	x1, [x24, #112]
 1136200:	aa1903e0 	mov	x0, x25
 1136204:	d63f0020 	blr	x1
 1136208:	93407c04 	sxtw	x4, w0
   pbytes = (pbits+7) >> 3;
   if (pbits > hashlen*8) {
 113620c:	f9404fe0 	ldr	x0, [sp, #152]
   pbits = mp_count_bits(p);
 1136210:	aa0403e1 	mov	x1, x4
   if (pbits > hashlen*8) {
 1136214:	d37df000 	lsl	x0, x0, #3
 1136218:	eb24c01f 	cmp	x0, w4, sxtw
 113621c:	54001862 	b.cs	1136528 <ecc_verify_hash_ex+0x4b0>  // b.hs, b.nlast
      if ((err = mp_read_unsigned_bin(e, (unsigned char *)hash, hashlen)) != CRYPT_OK)                  { goto error; }
 1136220:	f94043e1 	ldr	x1, [sp, #128]
 1136224:	f9404fe2 	ldr	x2, [sp, #152]
 1136228:	f9405703 	ldr	x3, [x24, #168]
 113622c:	f94073e0 	ldr	x0, [sp, #224]
 1136230:	d63f0060 	blr	x3
 1136234:	2a0003fa 	mov	w26, w0
 1136238:	35000e00 	cbnz	w0, 11363f8 <ecc_verify_hash_ex+0x380>
      }
      if ((err = mp_read_unsigned_bin(e, (unsigned char *)buf, pbytes)) != CRYPT_OK)                    { goto error; }
   }

   /*  w  = s^-1 mod n */
   if ((err = mp_invmod(s, p, w)) != CRYPT_OK)                                                          { goto error; }
 113623c:	f941d6b8 	ldr	x24, [x21, #936]
 1136240:	aa1903e1 	mov	x1, x25
 1136244:	f9405fe0 	ldr	x0, [sp, #184]
 1136248:	f94067e2 	ldr	x2, [sp, #200]
 113624c:	f9409703 	ldr	x3, [x24, #296]
 1136250:	d63f0060 	blr	x3
 1136254:	2a0003fa 	mov	w26, w0
 1136258:	35000d00 	cbnz	w0, 11363f8 <ecc_verify_hash_ex+0x380>

   /* u1 = ew */
   if ((err = mp_mulmod(e, w, p, u1)) != CRYPT_OK)                                                      { goto error; }
 113625c:	a94c8fe1 	ldp	x1, x3, [sp, #200]
 1136260:	aa1903e2 	mov	x2, x25
 1136264:	f94073e0 	ldr	x0, [sp, #224]
 1136268:	f9408f04 	ldr	x4, [x24, #280]
 113626c:	d63f0080 	blr	x4
 1136270:	2a0003fa 	mov	w26, w0
 1136274:	35000c20 	cbnz	w0, 11363f8 <ecc_verify_hash_ex+0x380>

   /* u2 = rw */
   if ((err = mp_mulmod(r, w, p, u2)) != CRYPT_OK)                                                      { goto error; }
 1136278:	f9405be0 	ldr	x0, [sp, #176]
 113627c:	aa1903e2 	mov	x2, x25
 1136280:	f94067e1 	ldr	x1, [sp, #200]
 1136284:	f9406fe3 	ldr	x3, [sp, #216]
 1136288:	f9408f04 	ldr	x4, [x24, #280]
 113628c:	d63f0080 	blr	x4
 1136290:	2a0003fa 	mov	w26, w0
 1136294:	35000b20 	cbnz	w0, 11363f8 <ecc_verify_hash_ex+0x380>

   /* find mG and mQ */
   if ((err = ltc_ecc_copy_point(&key->dp.base, mG)) != CRYPT_OK)                                       { goto error; }
 1136298:	aa1303e1 	mov	x1, x19
 113629c:	9100c280 	add	x0, x20, #0x30
 11362a0:	94000528 	bl	1137740 <ltc_ecc_copy_point>
 11362a4:	2a0003fa 	mov	w26, w0
 11362a8:	35000a80 	cbnz	w0, 11363f8 <ecc_verify_hash_ex+0x380>
   if ((err = ltc_ecc_copy_point(&key->pubkey, mQ)) != CRYPT_OK)                                        { goto error; }
 11362ac:	aa1603e1 	mov	x1, x22
 11362b0:	91036280 	add	x0, x20, #0xd8
 11362b4:	94000523 	bl	1137740 <ltc_ecc_copy_point>
 11362b8:	2a0003fa 	mov	w26, w0
 11362bc:	350009e0 	cbnz	w0, 11363f8 <ecc_verify_hash_ex+0x380>

   /* find the montgomery mp */
   if ((err = mp_montgomery_setup(m, &mp)) != CRYPT_OK)                                                 { goto error; }
 11362c0:	f9409b02 	ldr	x2, [x24, #304]
 11362c4:	910403e1 	add	x1, sp, #0x100
 11362c8:	aa1703e0 	mov	x0, x23
 11362cc:	d63f0040 	blr	x2
 11362d0:	2a0003fa 	mov	w26, w0
 11362d4:	35000920 	cbnz	w0, 11363f8 <ecc_verify_hash_ex+0x380>

   /* for curves with a == -3 keep ma == NULL */
   if (mp_cmp(a_plus3, m) != LTC_MP_EQ) {
 11362d8:	f9403302 	ldr	x2, [x24, #96]
 11362dc:	aa1703e1 	mov	x1, x23
 11362e0:	f94077e0 	ldr	x0, [sp, #232]
 11362e4:	d63f0040 	blr	x2
 11362e8:	35001540 	cbnz	w0, 1136590 <ecc_verify_hash_ex+0x518>
      if ((err = mp_montgomery_normalization(mu, m)) != CRYPT_OK)                                       { goto error; }
      if ((err = mp_mulmod(a, mu, m, ma)) != CRYPT_OK)                                                  { goto error; }
   }

   /* compute u1*mG + u2*mQ = mG */
   if (ltc_mp.ecc_mul2add == NULL) {
 11362ec:	f941d6b4 	ldr	x20, [x21, #936]
 11362f0:	f9406be0 	ldr	x0, [sp, #208]
 11362f4:	f940c287 	ldr	x7, [x20, #384]
 11362f8:	b5001747 	cbnz	x7, 11365e0 <ecc_verify_hash_ex+0x568>
      if ((err = ltc_mp.ecc_ptmul(u1, mG, mG, a, m, 0)) != CRYPT_OK)                                    { goto error; }
 11362fc:	f940b286 	ldr	x6, [x20, #352]
 1136300:	aa1703e4 	mov	x4, x23
 1136304:	aa1c03e3 	mov	x3, x28
 1136308:	aa1303e2 	mov	x2, x19
 113630c:	aa1303e1 	mov	x1, x19
 1136310:	52800005 	mov	w5, #0x0                   	// #0
 1136314:	d63f00c0 	blr	x6
 1136318:	2a0003fa 	mov	w26, w0
 113631c:	350006e0 	cbnz	w0, 11363f8 <ecc_verify_hash_ex+0x380>
      if ((err = ltc_mp.ecc_ptmul(u2, mQ, mQ, a, m, 0)) != CRYPT_OK)                                    { goto error; }
 1136320:	f9406fe0 	ldr	x0, [sp, #216]
 1136324:	aa1703e4 	mov	x4, x23
 1136328:	f940b286 	ldr	x6, [x20, #352]
 113632c:	aa1c03e3 	mov	x3, x28
 1136330:	aa1603e2 	mov	x2, x22
 1136334:	aa1603e1 	mov	x1, x22
 1136338:	52800005 	mov	w5, #0x0                   	// #0
 113633c:	d63f00c0 	blr	x6
 1136340:	2a0003fa 	mov	w26, w0
 1136344:	350005a0 	cbnz	w0, 11363f8 <ecc_verify_hash_ex+0x380>

      /* add them */
      if ((err = ltc_mp.ecc_ptadd(mQ, mG, mG, ma, m, mp)) != CRYPT_OK)                                  { goto error; }
 1136348:	a94f97e3 	ldp	x3, x5, [sp, #248]
 113634c:	aa1703e4 	mov	x4, x23
 1136350:	f940b686 	ldr	x6, [x20, #360]
 1136354:	aa1303e2 	mov	x2, x19
 1136358:	aa1303e1 	mov	x1, x19
 113635c:	aa1603e0 	mov	x0, x22
 1136360:	d63f00c0 	blr	x6
 1136364:	2a0003fa 	mov	w26, w0
 1136368:	35000480 	cbnz	w0, 11363f8 <ecc_verify_hash_ex+0x380>

      /* reduce */
      if ((err = ltc_mp.ecc_map(mG, m, mp)) != CRYPT_OK)                                                { goto error; }
 113636c:	f94083e2 	ldr	x2, [sp, #256]
 1136370:	aa1703e1 	mov	x1, x23
 1136374:	f940be83 	ldr	x3, [x20, #376]
 1136378:	aa1303e0 	mov	x0, x19
 113637c:	d63f0060 	blr	x3
 1136380:	2a0003fa 	mov	w26, w0
 1136384:	350003a0 	cbnz	w0, 11363f8 <ecc_verify_hash_ex+0x380>
      /* use Shamir's trick to compute u1*mG + u2*mQ using half of the doubles */
      if ((err = ltc_mp.ecc_mul2add(mG, u1, mQ, u2, mG, ma, m)) != CRYPT_OK)                            { goto error; }
   }

   /* v = X_x1 mod n */
   if ((err = mp_mod(mG->x, p, v)) != CRYPT_OK)                                                         { goto error; }
 1136388:	f941d6b4 	ldr	x20, [x21, #936]
 113638c:	aa1903e1 	mov	x1, x25
 1136390:	f9400260 	ldr	x0, [x19]
 1136394:	d2800002 	mov	x2, #0x0                   	// #0
 1136398:	f94063e3 	ldr	x3, [sp, #192]
 113639c:	f9407a84 	ldr	x4, [x20, #240]
 11363a0:	d63f0080 	blr	x4
 11363a4:	2a0003fa 	mov	w26, w0
 11363a8:	35000280 	cbnz	w0, 11363f8 <ecc_verify_hash_ex+0x380>

   /* does v == r */
   if (mp_cmp(v, r) == LTC_MP_EQ) {
 11363ac:	f9403282 	ldr	x2, [x20, #96]
 11363b0:	f9405be1 	ldr	x1, [sp, #176]
 11363b4:	f94063e0 	ldr	x0, [sp, #192]
 11363b8:	d63f0040 	blr	x2
 11363bc:	350001e0 	cbnz	w0, 11363f8 <ecc_verify_hash_ex+0x380>
      *stat = 1;
 11363c0:	f9404be1 	ldr	x1, [sp, #144]
 11363c4:	52800020 	mov	w0, #0x1                   	// #1
 11363c8:	b9000020 	str	w0, [x1]
 11363cc:	1400000b 	b	11363f8 <ecc_verify_hash_ex+0x380>
   else if (sigformat == LTC_ECCSIG_RFC7518) {
 11363d0:	b9408be0 	ldr	w0, [sp, #136]
 11363d4:	7100041f 	cmp	w0, #0x1
 11363d8:	54000321 	b.ne	113643c <ecc_verify_hash_ex+0x3c4>  // b.any
      i = mp_unsigned_bin_size(key->dp.order);
 11363dc:	f9401680 	ldr	x0, [x20, #40]
 11363e0:	f9404c81 	ldr	x1, [x4, #152]
 11363e4:	d63f0020 	blr	x1
 11363e8:	aa0003e2 	mov	x2, x0
      if (siglen != (2 * i)) {
 11363ec:	eb00077f 	cmp	x27, x0, lsl #1
 11363f0:	540000a0 	b.eq	1136404 <ecc_verify_hash_ex+0x38c>  // b.none
         err = CRYPT_INVALID_PACKET;
 11363f4:	528000fa 	mov	w26, #0x7                   	// #7
   }

   /* clear up and return */
   err = CRYPT_OK;
error:
   if (mG != NULL) ltc_ecc_del_point(mG);
 11363f8:	aa1303e0 	mov	x0, x19
 11363fc:	940004a4 	bl	113768c <ltc_ecc_del_point>
 1136400:	14000083 	b	113660c <ecc_verify_hash_ex+0x594>
      if ((err = mp_read_unsigned_bin(r, (unsigned char *)sig,   i)) != CRYPT_OK)                       { goto error; }
 1136404:	f941d6bb 	ldr	x27, [x21, #936]
 1136408:	aa1803e1 	mov	x1, x24
 113640c:	f9405be0 	ldr	x0, [sp, #176]
 1136410:	f90047e2 	str	x2, [sp, #136]
 1136414:	f9405763 	ldr	x3, [x27, #168]
 1136418:	d63f0060 	blr	x3
 113641c:	2a0003fa 	mov	w26, w0
 1136420:	35fffec0 	cbnz	w0, 11363f8 <ecc_verify_hash_ex+0x380>
      if ((err = mp_read_unsigned_bin(s, (unsigned char *)sig+i, i)) != CRYPT_OK)                       { goto error; }
 1136424:	f94047e2 	ldr	x2, [sp, #136]
 1136428:	f9405763 	ldr	x3, [x27, #168]
 113642c:	8b020301 	add	x1, x24, x2
 1136430:	f9405fe0 	ldr	x0, [sp, #184]
 1136434:	d63f0060 	blr	x3
 1136438:	17ffff56 	b	1136190 <ecc_verify_hash_ex+0x118>
   else if (sigformat == LTC_ECCSIG_ETH27) {
 113643c:	b9408be0 	ldr	w0, [sp, #136]
 1136440:	7100081f 	cmp	w0, #0x2
 1136444:	540002c1 	b.ne	113649c <ecc_verify_hash_ex+0x424>  // b.any
      if (pk_oid_cmp_with_ulong("1.3.132.0.10", key->dp.oid, key->dp.oidlen) != CRYPT_OK) {
 1136448:	f9406a82 	ldr	x2, [x20, #208]
 113644c:	90000100 	adrp	x0, 1156000 <ta_pub_key_modulus+0x7>
 1136450:	91014281 	add	x1, x20, #0x50
 1136454:	91268000 	add	x0, x0, #0x9a0
 1136458:	94001171 	bl	113aa1c <pk_oid_cmp_with_ulong>
 113645c:	34000060 	cbz	w0, 1136468 <ecc_verify_hash_ex+0x3f0>
         err = CRYPT_ERROR; goto error;
 1136460:	5280003a 	mov	w26, #0x1                   	// #1
 1136464:	17ffffe5 	b	11363f8 <ecc_verify_hash_ex+0x380>
      if (siglen != 65) { /* Only secp256k1 curves use this format, so must be 65 bytes long */
 1136468:	f101077f 	cmp	x27, #0x41
 113646c:	54fffc41 	b.ne	11363f4 <ecc_verify_hash_ex+0x37c>  // b.any
      if ((err = mp_read_unsigned_bin(r, (unsigned char *)sig,  32)) != CRYPT_OK)                       { goto error; }
 1136470:	f941d6bb 	ldr	x27, [x21, #936]
 1136474:	aa1803e1 	mov	x1, x24
 1136478:	f9405be0 	ldr	x0, [sp, #176]
 113647c:	d2800402 	mov	x2, #0x20                  	// #32
 1136480:	f9405763 	ldr	x3, [x27, #168]
 1136484:	d63f0060 	blr	x3
 1136488:	2a0003fa 	mov	w26, w0
 113648c:	35fffb60 	cbnz	w0, 11363f8 <ecc_verify_hash_ex+0x380>
      if ((err = mp_read_unsigned_bin(s, (unsigned char *)sig+32, 32)) != CRYPT_OK)                     { goto error; }
 1136490:	d2800402 	mov	x2, #0x20                  	// #32
 1136494:	f9405763 	ldr	x3, [x27, #168]
 1136498:	17ffffe5 	b	113642c <ecc_verify_hash_ex+0x3b4>
   else if (sigformat == LTC_ECCSIG_RFC5656) {
 113649c:	b9408be0 	ldr	w0, [sp, #136]
 11364a0:	71000c1f 	cmp	w0, #0x3
 11364a4:	54fffde1 	b.ne	1136460 <ecc_verify_hash_ex+0x3e8>  // b.any
      if ((err = ssh_decode_sequence_multi(sig, siglen,
 11364a8:	528000e0 	mov	w0, #0x7                   	// #7
 11364ac:	b9000be0 	str	w0, [sp, #8]
 11364b0:	f9405be6 	ldr	x6, [sp, #176]
 11364b4:	f9000bff 	str	xzr, [sp, #16]
 11364b8:	f9405fe0 	ldr	x0, [sp, #184]
 11364bc:	f90003e0 	str	x0, [sp]
 11364c0:	910443e3 	add	x3, sp, #0x110
      unsigned long namelen = sizeof(name2);
 11364c4:	d2800804 	mov	x4, #0x40                  	// #64
      if ((err = ssh_decode_sequence_multi(sig, siglen,
 11364c8:	528000a7 	mov	w7, #0x5                   	// #5
 11364cc:	aa1b03e1 	mov	x1, x27
 11364d0:	2a0703e5 	mov	w5, w7
 11364d4:	aa1803e0 	mov	x0, x24
 11364d8:	52800082 	mov	w2, #0x4                   	// #4
 11364dc:	f90047e3 	str	x3, [sp, #136]
      unsigned long namelen = sizeof(name2);
 11364e0:	f90087e4 	str	x4, [sp, #264]
      if ((err = ssh_decode_sequence_multi(sig, siglen,
 11364e4:	94000992 	bl	1138b2c <ssh_decode_sequence_multi>
 11364e8:	2a0003fa 	mov	w26, w0
 11364ec:	35fff860 	cbnz	w0, 11363f8 <ecc_verify_hash_ex+0x380>
      if ((err = ecc_ssh_ecdsa_encode_name(name2, &namelen, key)) != CRYPT_OK)                                { goto error; }
 11364f0:	910543f8 	add	x24, sp, #0x150
 11364f4:	aa1403e2 	mov	x2, x20
 11364f8:	910423e1 	add	x1, sp, #0x108
 11364fc:	aa1803e0 	mov	x0, x24
 1136500:	97fffe9f 	bl	1135f7c <ecc_ssh_ecdsa_encode_name>
 1136504:	2a0003fa 	mov	w26, w0
 1136508:	35fff780 	cbnz	w0, 11363f8 <ecc_verify_hash_ex+0x380>
      if (XSTRCMP(name,name2) != 0) {
 113650c:	f94047e3 	ldr	x3, [sp, #136]
 1136510:	aa1803e1 	mov	x1, x24
 1136514:	aa0303e0 	mov	x0, x3
 1136518:	940035f9 	bl	1143cfc <strcmp>
 113651c:	34ffe3e0 	cbz	w0, 1136198 <ecc_verify_hash_ex+0x120>
         err = CRYPT_INVALID_ARG;
 1136520:	5280021a 	mov	w26, #0x10                  	// #16
 1136524:	17ffffb5 	b	11363f8 <ecc_verify_hash_ex+0x380>
   pbytes = (pbits+7) >> 3;
 1136528:	91001c84 	add	x4, x4, #0x7
   else if (pbits % 8 == 0) {
 113652c:	72000823 	ands	w3, w1, #0x7
 1136530:	f9405707 	ldr	x7, [x24, #168]
   pbytes = (pbits+7) >> 3;
 1136534:	d343fc84 	lsr	x4, x4, #3
   else if (pbits % 8 == 0) {
 1136538:	f94073e0 	ldr	x0, [sp, #224]
 113653c:	540000a1 	b.ne	1136550 <ecc_verify_hash_ex+0x4d8>  // b.any
      if ((err = mp_read_unsigned_bin(e, (unsigned char *)hash, pbytes)) != CRYPT_OK)                   { goto error; }
 1136540:	f94043e1 	ldr	x1, [sp, #128]
 1136544:	aa0403e2 	mov	x2, x4
      if ((err = mp_read_unsigned_bin(e, (unsigned char *)buf, pbytes)) != CRYPT_OK)                    { goto error; }
 1136548:	d63f00e0 	blr	x7
 113654c:	17ffff3a 	b	1136234 <ecc_verify_hash_ex+0x1bc>
      shift_right = 8 - pbits % 8;
 1136550:	d2800106 	mov	x6, #0x8                   	// #8
 1136554:	910543e1 	add	x1, sp, #0x150
 1136558:	cb23c0c6 	sub	x6, x6, w3, sxtw
      for (i=0, ch=0; i<pbytes; i++) {
 113655c:	52800008 	mov	w8, #0x0                   	// #0
 1136560:	d2800002 	mov	x2, #0x0                   	// #0
 1136564:	eb04005f 	cmp	x2, x4
 1136568:	54ffff00 	b.eq	1136548 <ecc_verify_hash_ex+0x4d0>  // b.none
        ch = (hash[i] << (8-shift_right));
 113656c:	f94043e5 	ldr	x5, [sp, #128]
 1136570:	386268a5 	ldrb	w5, [x5, x2]
 1136574:	1ac320a9 	lsl	w9, w5, w3
        buf[i] = buf[i] ^ (hash[i] >> shift_right);
 1136578:	1ac628a5 	asr	w5, w5, w6
 113657c:	4a0800a5 	eor	w5, w5, w8
        ch = (hash[i] << (8-shift_right));
 1136580:	12001d28 	and	w8, w9, #0xff
        buf[i] = buf[i] ^ (hash[i] >> shift_right);
 1136584:	38226825 	strb	w5, [x1, x2]
      for (i=0, ch=0; i<pbytes; i++) {
 1136588:	91000442 	add	x2, x2, #0x1
 113658c:	17fffff6 	b	1136564 <ecc_verify_hash_ex+0x4ec>
      if ((err = mp_init_multi(&mu, &ma, NULL)) != CRYPT_OK)                                            { goto error; }
 1136590:	9103e3e1 	add	x1, sp, #0xf8
 1136594:	9103c3e0 	add	x0, sp, #0xf0
 1136598:	d2800002 	mov	x2, #0x0                   	// #0
 113659c:	97ffee46 	bl	1131eb4 <ltc_init_multi>
 11365a0:	2a0003fa 	mov	w26, w0
 11365a4:	35fff2a0 	cbnz	w0, 11363f8 <ecc_verify_hash_ex+0x380>
      if ((err = mp_montgomery_normalization(mu, m)) != CRYPT_OK)                                       { goto error; }
 11365a8:	f9407be0 	ldr	x0, [sp, #240]
 11365ac:	aa1703e1 	mov	x1, x23
 11365b0:	f9409f02 	ldr	x2, [x24, #312]
 11365b4:	d63f0040 	blr	x2
 11365b8:	2a0003fa 	mov	w26, w0
 11365bc:	35fff1e0 	cbnz	w0, 11363f8 <ecc_verify_hash_ex+0x380>
      if ((err = mp_mulmod(a, mu, m, ma)) != CRYPT_OK)                                                  { goto error; }
 11365c0:	a94f0fe1 	ldp	x1, x3, [sp, #240]
 11365c4:	aa1703e2 	mov	x2, x23
 11365c8:	f9408f04 	ldr	x4, [x24, #280]
 11365cc:	aa1c03e0 	mov	x0, x28
 11365d0:	d63f0080 	blr	x4
 11365d4:	2a0003fa 	mov	w26, w0
 11365d8:	34ffe8a0 	cbz	w0, 11362ec <ecc_verify_hash_ex+0x274>
 11365dc:	17ffff87 	b	11363f8 <ecc_verify_hash_ex+0x380>
      if ((err = ltc_mp.ecc_mul2add(mG, u1, mQ, u2, mG, ma, m)) != CRYPT_OK)                            { goto error; }
 11365e0:	f9406fe3 	ldr	x3, [sp, #216]
 11365e4:	aa0003e1 	mov	x1, x0
 11365e8:	f9407fe5 	ldr	x5, [sp, #248]
 11365ec:	aa1703e6 	mov	x6, x23
 11365f0:	aa1303e4 	mov	x4, x19
 11365f4:	aa1603e2 	mov	x2, x22
 11365f8:	aa1303e0 	mov	x0, x19
 11365fc:	d63f00e0 	blr	x7
 1136600:	17ffff60 	b	1136380 <ecc_verify_hash_ex+0x308>
      err = CRYPT_MEM;
 1136604:	528001ba 	mov	w26, #0xd                   	// #13
   if (mG != NULL) ltc_ecc_del_point(mG);
 1136608:	b5ffef93 	cbnz	x19, 11363f8 <ecc_verify_hash_ex+0x380>
   if (mQ != NULL) ltc_ecc_del_point(mQ);
 113660c:	b4000076 	cbz	x22, 1136618 <ecc_verify_hash_ex+0x5a0>
 1136610:	aa1603e0 	mov	x0, x22
 1136614:	9400041e 	bl	113768c <ltc_ecc_del_point>
   if (mu != NULL) mp_clear(mu);
 1136618:	f9407be0 	ldr	x0, [sp, #240]
 113661c:	b4000080 	cbz	x0, 113662c <ecc_verify_hash_ex+0x5b4>
 1136620:	f941d6a1 	ldr	x1, [x21, #936]
 1136624:	f9401421 	ldr	x1, [x1, #40]
 1136628:	d63f0020 	blr	x1
   if (ma != NULL) mp_clear(ma);
 113662c:	f9407fe0 	ldr	x0, [sp, #248]
 1136630:	b4000080 	cbz	x0, 1136640 <ecc_verify_hash_ex+0x5c8>
 1136634:	f941d6a1 	ldr	x1, [x21, #936]
 1136638:	f9401421 	ldr	x1, [x1, #40]
 113663c:	d63f0020 	blr	x1
   mp_clear_multi(r, s, v, w, u1, u2, e, a_plus3, NULL);
 1136640:	a94b07e0 	ldp	x0, x1, [sp, #176]
 1136644:	f90003ff 	str	xzr, [sp]
 1136648:	a94c0fe2 	ldp	x2, x3, [sp, #192]
 113664c:	a94d17e4 	ldp	x4, x5, [sp, #208]
 1136650:	a94e1fe6 	ldp	x6, x7, [sp, #224]
 1136654:	97ffeeb2 	bl	113211c <ltc_deinit_multi>
   if (mp != NULL) mp_montgomery_free(mp);
 1136658:	f94083e0 	ldr	x0, [sp, #256]
 113665c:	b4000080 	cbz	x0, 113666c <ecc_verify_hash_ex+0x5f4>
 1136660:	f941d6b5 	ldr	x21, [x21, #936]
 1136664:	f940a6a1 	ldr	x1, [x21, #328]
 1136668:	d63f0020 	blr	x1
   return err;
}
 113666c:	2a1a03e0 	mov	w0, w26
 1136670:	a9427bfd 	ldp	x29, x30, [sp, #32]
 1136674:	a94353f3 	ldp	x19, x20, [sp, #48]
 1136678:	a9445bf5 	ldp	x21, x22, [sp, #64]
 113667c:	a94563f7 	ldp	x23, x24, [sp, #80]
 1136680:	a9466bf9 	ldp	x25, x26, [sp, #96]
 1136684:	a94773fb 	ldp	x27, x28, [sp, #112]
 1136688:	910783ff 	add	sp, sp, #0x1e0
 113668c:	d65f03c0 	ret
   LTC_ARGCHK(sig  != NULL);
 1136690:	5280021a 	mov	w26, #0x10                  	// #16
 1136694:	17fffff6 	b	113666c <ecc_verify_hash_ex+0x5f4>

0000000001136698 <ltc_ecc_is_point>:
  @param y      y point coordinate
  @return CRYPT_OK if valid
*/

int ltc_ecc_is_point(const ltc_ecc_dp *dp, void *x, void *y)
{
 1136698:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
 113669c:	910003fd 	mov	x29, sp
 11366a0:	a90153f3 	stp	x19, x20, [sp, #16]
 11366a4:	a9025bf5 	stp	x21, x22, [sp, #32]
 11366a8:	aa0103f6 	mov	x22, x1

  prime = dp->prime;
  b     = dp->B;
  a     = dp->A;

  if ((err = mp_init_multi(&t1, &t2, NULL)) != CRYPT_OK)  return err;
 11366ac:	910163e1 	add	x1, sp, #0x58
{
 11366b0:	a90363f7 	stp	x23, x24, [sp, #48]
  a     = dp->A;
 11366b4:	a940dc14 	ldp	x20, x23, [x0, #8]
  b     = dp->B;
 11366b8:	f9400c15 	ldr	x21, [x0, #24]
  if ((err = mp_init_multi(&t1, &t2, NULL)) != CRYPT_OK)  return err;
 11366bc:	910143e0 	add	x0, sp, #0x50
{
 11366c0:	f90023f9 	str	x25, [sp, #64]
 11366c4:	aa0203f9 	mov	x25, x2
  if ((err = mp_init_multi(&t1, &t2, NULL)) != CRYPT_OK)  return err;
 11366c8:	d2800002 	mov	x2, #0x0                   	// #0
 11366cc:	97ffedfa 	bl	1131eb4 <ltc_init_multi>
 11366d0:	35000d20 	cbnz	w0, 1136874 <ltc_ecc_is_point+0x1dc>

  /* compute y^2 */
  if ((err = mp_sqr(y, t1)) != CRYPT_OK)                  goto cleanup;
 11366d4:	90000133 	adrp	x19, 115a000 <__scattered_array_1phys_mem_map+0x8>
 11366d8:	aa1903e0 	mov	x0, x25
 11366dc:	f9402be1 	ldr	x1, [sp, #80]
 11366e0:	f941d678 	ldr	x24, [x19, #936]
 11366e4:	f9407302 	ldr	x2, [x24, #224]
 11366e8:	d63f0040 	blr	x2
 11366ec:	2a0003f3 	mov	w19, w0
 11366f0:	35000ae0 	cbnz	w0, 113684c <ltc_ecc_is_point+0x1b4>

  /* compute x^3 */
  if ((err = mp_sqr(x, t2)) != CRYPT_OK)                  goto cleanup;
 11366f4:	f9402fe1 	ldr	x1, [sp, #88]
 11366f8:	aa1603e0 	mov	x0, x22
 11366fc:	f9407302 	ldr	x2, [x24, #224]
 1136700:	d63f0040 	blr	x2
 1136704:	2a0003f3 	mov	w19, w0
 1136708:	35000a20 	cbnz	w0, 113684c <ltc_ecc_is_point+0x1b4>
  if ((err = mp_mod(t2, prime, t2)) != CRYPT_OK)          goto cleanup;
 113670c:	f9402fe3 	ldr	x3, [sp, #88]
 1136710:	aa1403e1 	mov	x1, x20
 1136714:	f9407b04 	ldr	x4, [x24, #240]
 1136718:	aa0303e0 	mov	x0, x3
 113671c:	d2800002 	mov	x2, #0x0                   	// #0
 1136720:	d63f0080 	blr	x4
 1136724:	2a0003f3 	mov	w19, w0
 1136728:	35000920 	cbnz	w0, 113684c <ltc_ecc_is_point+0x1b4>
  if ((err = mp_mul(x, t2, t2)) != CRYPT_OK)              goto cleanup;
 113672c:	f9402fe2 	ldr	x2, [sp, #88]
 1136730:	aa1603e0 	mov	x0, x22
 1136734:	f9406b03 	ldr	x3, [x24, #208]
 1136738:	aa0203e1 	mov	x1, x2
 113673c:	d63f0060 	blr	x3
 1136740:	2a0003f3 	mov	w19, w0
 1136744:	35000840 	cbnz	w0, 113684c <ltc_ecc_is_point+0x1b4>

  /* compute y^2 - x^3 */
  if ((err = mp_sub(t1, t2, t1)) != CRYPT_OK)             goto cleanup;
 1136748:	a94507e2 	ldp	x2, x1, [sp, #80]
 113674c:	f9406303 	ldr	x3, [x24, #192]
 1136750:	aa0203e0 	mov	x0, x2
 1136754:	d63f0060 	blr	x3
 1136758:	2a0003f3 	mov	w19, w0
 113675c:	35000780 	cbnz	w0, 113684c <ltc_ecc_is_point+0x1b4>

  /* compute y^2 - x^3 - a*x */
  if ((err = mp_submod(prime, a, prime, t2)) != CRYPT_OK) goto cleanup;
 1136760:	f9402fe3 	ldr	x3, [sp, #88]
 1136764:	aa1403e2 	mov	x2, x20
 1136768:	f940d304 	ldr	x4, [x24, #416]
 113676c:	aa1703e1 	mov	x1, x23
 1136770:	aa1403e0 	mov	x0, x20
 1136774:	d63f0080 	blr	x4
 1136778:	2a0003f3 	mov	w19, w0
 113677c:	35000680 	cbnz	w0, 113684c <ltc_ecc_is_point+0x1b4>
  if ((err = mp_mulmod(t2, x, prime, t2)) != CRYPT_OK)    goto cleanup;
 1136780:	f9402fe3 	ldr	x3, [sp, #88]
 1136784:	aa1403e2 	mov	x2, x20
 1136788:	f9408f04 	ldr	x4, [x24, #280]
 113678c:	aa1603e1 	mov	x1, x22
 1136790:	aa0303e0 	mov	x0, x3
 1136794:	d63f0080 	blr	x4
 1136798:	2a0003f3 	mov	w19, w0
 113679c:	35000580 	cbnz	w0, 113684c <ltc_ecc_is_point+0x1b4>
  if ((err = mp_addmod(t1, t2, prime, t1)) != CRYPT_OK)   goto cleanup;
 11367a0:	a94507e3 	ldp	x3, x1, [sp, #80]
 11367a4:	aa1403e2 	mov	x2, x20
 11367a8:	f940cf04 	ldr	x4, [x24, #408]
 11367ac:	aa0303e0 	mov	x0, x3
 11367b0:	d63f0080 	blr	x4

  /* adjust range (0, prime) */
  while (mp_cmp_d(t1, 0) == LTC_MP_LT) {
     if ((err = mp_add(t1, prime, t1)) != CRYPT_OK)       goto cleanup;
 11367b4:	2a0003f3 	mov	w19, w0
 11367b8:	350004a0 	cbnz	w0, 113684c <ltc_ecc_is_point+0x1b4>
  while (mp_cmp_d(t1, 0) == LTC_MP_LT) {
 11367bc:	f9402be0 	ldr	x0, [sp, #80]
 11367c0:	d2800001 	mov	x1, #0x0                   	// #0
 11367c4:	f9403702 	ldr	x2, [x24, #104]
 11367c8:	90000133 	adrp	x19, 115a000 <__scattered_array_1phys_mem_map+0x8>
 11367cc:	d63f0040 	blr	x2
 11367d0:	3100041f 	cmn	w0, #0x1
 11367d4:	54000220 	b.eq	1136818 <ltc_ecc_is_point+0x180>  // b.none
  }
  while (mp_cmp(t1, prime) != LTC_MP_LT) {
 11367d8:	f941d676 	ldr	x22, [x19, #936]
 11367dc:	aa1403e1 	mov	x1, x20
 11367e0:	f9402be0 	ldr	x0, [sp, #80]
 11367e4:	f94032c2 	ldr	x2, [x22, #96]
 11367e8:	d63f0040 	blr	x2
 11367ec:	3100041f 	cmn	w0, #0x1
 11367f0:	54000201 	b.ne	1136830 <ltc_ecc_is_point+0x198>  // b.any
     if ((err = mp_sub(t1, prime, t1)) != CRYPT_OK)       goto cleanup;
  }

  /* compare to b */
  if (mp_cmp(t1, b) != LTC_MP_EQ) {
 11367f4:	f9402be0 	ldr	x0, [sp, #80]
 11367f8:	aa1503e1 	mov	x1, x21
 11367fc:	f94032c2 	ldr	x2, [x22, #96]
 1136800:	d63f0040 	blr	x2
 1136804:	2a0003f3 	mov	w19, w0
     err = CRYPT_INVALID_PACKET;
 1136808:	7100001f 	cmp	w0, #0x0
 113680c:	528000e0 	mov	w0, #0x7                   	// #7
 1136810:	1a800273 	csel	w19, w19, w0, eq  // eq = none
 1136814:	1400000e 	b	113684c <ltc_ecc_is_point+0x1b4>
     if ((err = mp_add(t1, prime, t1)) != CRYPT_OK)       goto cleanup;
 1136818:	f9402be2 	ldr	x2, [sp, #80]
 113681c:	aa1403e1 	mov	x1, x20
 1136820:	f9405b03 	ldr	x3, [x24, #176]
 1136824:	aa0203e0 	mov	x0, x2
 1136828:	d63f0060 	blr	x3
 113682c:	17ffffe2 	b	11367b4 <ltc_ecc_is_point+0x11c>
     if ((err = mp_sub(t1, prime, t1)) != CRYPT_OK)       goto cleanup;
 1136830:	f9402be2 	ldr	x2, [sp, #80]
 1136834:	aa1403e1 	mov	x1, x20
 1136838:	f94062c3 	ldr	x3, [x22, #192]
 113683c:	aa0203e0 	mov	x0, x2
 1136840:	d63f0060 	blr	x3
 1136844:	2a0003f3 	mov	w19, w0
 1136848:	34fffca0 	cbz	w0, 11367dc <ltc_ecc_is_point+0x144>
  } else {
     err = CRYPT_OK;
  }

cleanup:
  mp_clear_multi(t1, t2, NULL);
 113684c:	a94507e0 	ldp	x0, x1, [sp, #80]
 1136850:	d2800002 	mov	x2, #0x0                   	// #0
 1136854:	97ffee32 	bl	113211c <ltc_deinit_multi>
  return err;
}
 1136858:	2a1303e0 	mov	w0, w19
 113685c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1136860:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1136864:	a94363f7 	ldp	x23, x24, [sp, #48]
 1136868:	f94023f9 	ldr	x25, [sp, #64]
 113686c:	a8c67bfd 	ldp	x29, x30, [sp], #96
 1136870:	d65f03c0 	ret
 1136874:	2a0003f3 	mov	w19, w0
 1136878:	17fffff8 	b	1136858 <ltc_ecc_is_point+0x1c0>

000000000113687c <ltc_ecc_is_point_at_infinity>:
/* http://crypto.stackexchange.com/questions/41468/point-at-infinity-for-jacobian-coordinates
 * a point at infinity is any point (x,y,0) such that y^2 == x^3, except (0,0,0)
 */

int ltc_ecc_is_point_at_infinity(const ecc_point *P, void *modulus, int *retval)
{
 113687c:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 1136880:	910003fd 	mov	x29, sp
 1136884:	a90153f3 	stp	x19, x20, [sp, #16]
   int err;
   void  *x3, *y2;

   /* trivial case */
   if (!mp_iszero(P->z)) {
 1136888:	90000134 	adrp	x20, 115a000 <__scattered_array_1phys_mem_map+0x8>
 113688c:	f941d694 	ldr	x20, [x20, #936]
{
 1136890:	a9025bf5 	stp	x21, x22, [sp, #32]
 1136894:	aa0003f5 	mov	x21, x0
 1136898:	aa0203f6 	mov	x22, x2
   if (!mp_iszero(P->z)) {
 113689c:	f9400800 	ldr	x0, [x0, #16]
 11368a0:	f9403682 	ldr	x2, [x20, #104]
{
 11368a4:	f9001bf7 	str	x23, [sp, #48]
 11368a8:	aa0103f7 	mov	x23, x1
   if (!mp_iszero(P->z)) {
 11368ac:	d2800001 	mov	x1, #0x0                   	// #0
 11368b0:	d63f0040 	blr	x2
 11368b4:	34000120 	cbz	w0, 11368d8 <ltc_ecc_is_point_at_infinity+0x5c>
      *retval = 0;
      return CRYPT_OK;
 11368b8:	52800013 	mov	w19, #0x0                   	// #0
      *retval = 0;
 11368bc:	b90002df 	str	wzr, [x22]

cleanup:
   mp_clear_multi(x3, y2, NULL);
done:
   return err;
}
 11368c0:	2a1303e0 	mov	w0, w19
 11368c4:	a94153f3 	ldp	x19, x20, [sp, #16]
 11368c8:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11368cc:	f9401bf7 	ldr	x23, [sp, #48]
 11368d0:	a8c57bfd 	ldp	x29, x30, [sp], #80
 11368d4:	d65f03c0 	ret
   if (mp_iszero(P->x) && mp_iszero(P->y)) {
 11368d8:	f94002a0 	ldr	x0, [x21]
 11368dc:	d2800001 	mov	x1, #0x0                   	// #0
 11368e0:	f9403682 	ldr	x2, [x20, #104]
 11368e4:	d63f0040 	blr	x2
 11368e8:	350000c0 	cbnz	w0, 1136900 <ltc_ecc_is_point_at_infinity+0x84>
 11368ec:	f94006a0 	ldr	x0, [x21, #8]
 11368f0:	d2800001 	mov	x1, #0x0                   	// #0
 11368f4:	f9403682 	ldr	x2, [x20, #104]
 11368f8:	d63f0040 	blr	x2
 11368fc:	34fffde0 	cbz	w0, 11368b8 <ltc_ecc_is_point_at_infinity+0x3c>
   if ((err = mp_init_multi(&x3, &y2, NULL))      != CRYPT_OK)   goto done;
 1136900:	910123e1 	add	x1, sp, #0x48
 1136904:	910103e0 	add	x0, sp, #0x40
 1136908:	d2800002 	mov	x2, #0x0                   	// #0
 113690c:	97ffed6a 	bl	1131eb4 <ltc_init_multi>
 1136910:	2a0003f3 	mov	w19, w0
 1136914:	35fffd60 	cbnz	w0, 11368c0 <ltc_ecc_is_point_at_infinity+0x44>
   if ((err = mp_mulmod(P->y, P->y, modulus, y2)) != CRYPT_OK)   goto cleanup;
 1136918:	90000134 	adrp	x20, 115a000 <__scattered_array_1phys_mem_map+0x8>
 113691c:	aa1703e2 	mov	x2, x23
 1136920:	f94006a1 	ldr	x1, [x21, #8]
 1136924:	f941d694 	ldr	x20, [x20, #936]
 1136928:	aa0103e0 	mov	x0, x1
 113692c:	f94027e3 	ldr	x3, [sp, #72]
 1136930:	f9408e84 	ldr	x4, [x20, #280]
 1136934:	d63f0080 	blr	x4
 1136938:	2a0003f3 	mov	w19, w0
 113693c:	35000380 	cbnz	w0, 11369ac <ltc_ecc_is_point_at_infinity+0x130>
   if ((err = mp_mulmod(P->x, P->x, modulus, x3)) != CRYPT_OK)   goto cleanup;
 1136940:	f94002a1 	ldr	x1, [x21]
 1136944:	aa1703e2 	mov	x2, x23
 1136948:	f94023e3 	ldr	x3, [sp, #64]
 113694c:	aa0103e0 	mov	x0, x1
 1136950:	f9408e84 	ldr	x4, [x20, #280]
 1136954:	d63f0080 	blr	x4
 1136958:	2a0003f3 	mov	w19, w0
 113695c:	35000280 	cbnz	w0, 11369ac <ltc_ecc_is_point_at_infinity+0x130>
   if ((err = mp_mulmod(P->x, x3, modulus, x3))   != CRYPT_OK)   goto cleanup;
 1136960:	f94002a0 	ldr	x0, [x21]
 1136964:	aa1703e2 	mov	x2, x23
 1136968:	f94023e3 	ldr	x3, [sp, #64]
 113696c:	f9408e84 	ldr	x4, [x20, #280]
 1136970:	aa0303e1 	mov	x1, x3
 1136974:	d63f0080 	blr	x4
 1136978:	2a0003f3 	mov	w19, w0
 113697c:	35000180 	cbnz	w0, 11369ac <ltc_ecc_is_point_at_infinity+0x130>
   if ((mp_cmp(x3, y2) == LTC_MP_EQ) && !mp_iszero(y2)) {
 1136980:	a94407e0 	ldp	x0, x1, [sp, #64]
 1136984:	f9403282 	ldr	x2, [x20, #96]
 1136988:	d63f0040 	blr	x2
 113698c:	35000180 	cbnz	w0, 11369bc <ltc_ecc_is_point_at_infinity+0x140>
 1136990:	f94027e0 	ldr	x0, [sp, #72]
 1136994:	d2800001 	mov	x1, #0x0                   	// #0
 1136998:	f9403682 	ldr	x2, [x20, #104]
 113699c:	d63f0040 	blr	x2
 11369a0:	340000e0 	cbz	w0, 11369bc <ltc_ecc_is_point_at_infinity+0x140>
      *retval = 1;
 11369a4:	52800020 	mov	w0, #0x1                   	// #1
 11369a8:	b90002c0 	str	w0, [x22]
   mp_clear_multi(x3, y2, NULL);
 11369ac:	a94407e0 	ldp	x0, x1, [sp, #64]
 11369b0:	d2800002 	mov	x2, #0x0                   	// #0
 11369b4:	97ffedda 	bl	113211c <ltc_deinit_multi>
 11369b8:	17ffffc2 	b	11368c0 <ltc_ecc_is_point_at_infinity+0x44>
      *retval = 0;
 11369bc:	b90002df 	str	wzr, [x22]
 11369c0:	17fffffb 	b	11369ac <ltc_ecc_is_point_at_infinity+0x130>

00000000011369c4 <ltc_ecc_map>:
  @param modulus  The modulus of the field the ECC curve is in
  @param mp       The "b" value from montgomery_setup()
  @return CRYPT_OK on success
*/
int ltc_ecc_map(ecc_point *P, void *modulus, void *mp)
{
 11369c4:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 11369c8:	910003fd 	mov	x29, sp
 11369cc:	a90153f3 	stp	x19, x20, [sp, #16]
 11369d0:	a9025bf5 	stp	x21, x22, [sp, #32]
 11369d4:	f9001bf7 	str	x23, [sp, #48]
   void *t1, *t2;
   int   err;

   LTC_ARGCHK(P       != NULL);
 11369d8:	b4000de0 	cbz	x0, 1136b94 <ltc_ecc_map+0x1d0>
 11369dc:	aa0103f5 	mov	x21, x1
   LTC_ARGCHK(modulus != NULL);
 11369e0:	b4000da1 	cbz	x1, 1136b94 <ltc_ecc_map+0x1d0>
 11369e4:	aa0203f6 	mov	x22, x2
   LTC_ARGCHK(mp      != NULL);
 11369e8:	b4000d62 	cbz	x2, 1136b94 <ltc_ecc_map+0x1d0>

   if (mp_iszero(P->z)) {
 11369ec:	90000137 	adrp	x23, 115a000 <__scattered_array_1phys_mem_map+0x8>
 11369f0:	aa0003f4 	mov	x20, x0
 11369f4:	f9400800 	ldr	x0, [x0, #16]
 11369f8:	d2800001 	mov	x1, #0x0                   	// #0
 11369fc:	f941d6f7 	ldr	x23, [x23, #936]
 1136a00:	f94036e2 	ldr	x2, [x23, #104]
 1136a04:	d63f0040 	blr	x2
 1136a08:	350001a0 	cbnz	w0, 1136a3c <ltc_ecc_map+0x78>
      return ltc_ecc_set_point_xyz(0, 0, 1, P);
 1136a0c:	aa1403e3 	mov	x3, x20
 1136a10:	d2800022 	mov	x2, #0x1                   	// #1
 1136a14:	d2800001 	mov	x1, #0x0                   	// #0
 1136a18:	d2800000 	mov	x0, #0x0                   	// #0
 1136a1c:	9400032a 	bl	11376c4 <ltc_ecc_set_point_xyz>
 1136a20:	2a0003f3 	mov	w19, w0

   err = CRYPT_OK;
done:
   mp_clear_multi(t1, t2, NULL);
   return err;
}
 1136a24:	2a1303e0 	mov	w0, w19
 1136a28:	a94153f3 	ldp	x19, x20, [sp, #16]
 1136a2c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1136a30:	f9401bf7 	ldr	x23, [sp, #48]
 1136a34:	a8c57bfd 	ldp	x29, x30, [sp], #80
 1136a38:	d65f03c0 	ret
   if ((err = mp_init_multi(&t1, &t2, NULL)) != CRYPT_OK) {
 1136a3c:	910123e1 	add	x1, sp, #0x48
 1136a40:	910103e0 	add	x0, sp, #0x40
 1136a44:	d2800002 	mov	x2, #0x0                   	// #0
 1136a48:	97ffed1b 	bl	1131eb4 <ltc_init_multi>
 1136a4c:	2a0003f3 	mov	w19, w0
 1136a50:	35fffea0 	cbnz	w0, 1136a24 <ltc_ecc_map+0x60>
   if ((err = mp_montgomery_reduce(P->z, modulus, mp)) != CRYPT_OK)           { goto done; }
 1136a54:	f9400a80 	ldr	x0, [x20, #16]
 1136a58:	aa1603e2 	mov	x2, x22
 1136a5c:	f940a2e3 	ldr	x3, [x23, #320]
 1136a60:	aa1503e1 	mov	x1, x21
 1136a64:	d63f0060 	blr	x3
 1136a68:	2a0003f3 	mov	w19, w0
 1136a6c:	350008c0 	cbnz	w0, 1136b84 <ltc_ecc_map+0x1c0>
   if ((err = mp_invmod(P->z, modulus, t1)) != CRYPT_OK)                      { goto done; }
 1136a70:	f9400a80 	ldr	x0, [x20, #16]
 1136a74:	aa1503e1 	mov	x1, x21
 1136a78:	f94023e2 	ldr	x2, [sp, #64]
 1136a7c:	f94096e3 	ldr	x3, [x23, #296]
 1136a80:	d63f0060 	blr	x3
 1136a84:	2a0003f3 	mov	w19, w0
 1136a88:	350007e0 	cbnz	w0, 1136b84 <ltc_ecc_map+0x1c0>
   if ((err = mp_sqr(t1, t2)) != CRYPT_OK)                                    { goto done; }
 1136a8c:	a94407e0 	ldp	x0, x1, [sp, #64]
 1136a90:	f94072e2 	ldr	x2, [x23, #224]
 1136a94:	d63f0040 	blr	x2
 1136a98:	2a0003f3 	mov	w19, w0
 1136a9c:	35000740 	cbnz	w0, 1136b84 <ltc_ecc_map+0x1c0>
   if ((err = mp_mod(t2, modulus, t2)) != CRYPT_OK)                           { goto done; }
 1136aa0:	f94027e3 	ldr	x3, [sp, #72]
 1136aa4:	aa1503e1 	mov	x1, x21
 1136aa8:	f9407ae4 	ldr	x4, [x23, #240]
 1136aac:	aa0303e0 	mov	x0, x3
 1136ab0:	d2800002 	mov	x2, #0x0                   	// #0
 1136ab4:	d63f0080 	blr	x4
 1136ab8:	2a0003f3 	mov	w19, w0
 1136abc:	35000640 	cbnz	w0, 1136b84 <ltc_ecc_map+0x1c0>
   if ((err = mp_mul(t1, t2, t1)) != CRYPT_OK)                                { goto done; }
 1136ac0:	a94407e2 	ldp	x2, x1, [sp, #64]
 1136ac4:	f9406ae3 	ldr	x3, [x23, #208]
 1136ac8:	aa0203e0 	mov	x0, x2
 1136acc:	d63f0060 	blr	x3
 1136ad0:	2a0003f3 	mov	w19, w0
 1136ad4:	35000580 	cbnz	w0, 1136b84 <ltc_ecc_map+0x1c0>
   if ((err = mp_mod(t1, modulus, t1)) != CRYPT_OK)                           { goto done; }
 1136ad8:	90000137 	adrp	x23, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1136adc:	aa1503e1 	mov	x1, x21
 1136ae0:	f94023e3 	ldr	x3, [sp, #64]
 1136ae4:	d2800002 	mov	x2, #0x0                   	// #0
 1136ae8:	f941d6f7 	ldr	x23, [x23, #936]
 1136aec:	aa0303e0 	mov	x0, x3
 1136af0:	f9407ae4 	ldr	x4, [x23, #240]
 1136af4:	d63f0080 	blr	x4
 1136af8:	2a0003f3 	mov	w19, w0
 1136afc:	35000440 	cbnz	w0, 1136b84 <ltc_ecc_map+0x1c0>
   if ((err = mp_mul(P->x, t2, P->x)) != CRYPT_OK)                            { goto done; }
 1136b00:	f9400282 	ldr	x2, [x20]
 1136b04:	f94027e1 	ldr	x1, [sp, #72]
 1136b08:	aa0203e0 	mov	x0, x2
 1136b0c:	f9406ae3 	ldr	x3, [x23, #208]
 1136b10:	d63f0060 	blr	x3
 1136b14:	2a0003f3 	mov	w19, w0
 1136b18:	35000360 	cbnz	w0, 1136b84 <ltc_ecc_map+0x1c0>
   if ((err = mp_montgomery_reduce(P->x, modulus, mp)) != CRYPT_OK)           { goto done; }
 1136b1c:	f9400280 	ldr	x0, [x20]
 1136b20:	aa1603e2 	mov	x2, x22
 1136b24:	f940a2e3 	ldr	x3, [x23, #320]
 1136b28:	aa1503e1 	mov	x1, x21
 1136b2c:	d63f0060 	blr	x3
 1136b30:	2a0003f3 	mov	w19, w0
 1136b34:	35000280 	cbnz	w0, 1136b84 <ltc_ecc_map+0x1c0>
   if ((err = mp_mul(P->y, t1, P->y)) != CRYPT_OK)                            { goto done; }
 1136b38:	f9400682 	ldr	x2, [x20, #8]
 1136b3c:	f94023e1 	ldr	x1, [sp, #64]
 1136b40:	aa0203e0 	mov	x0, x2
 1136b44:	f9406ae3 	ldr	x3, [x23, #208]
 1136b48:	d63f0060 	blr	x3
 1136b4c:	2a0003f3 	mov	w19, w0
 1136b50:	350001a0 	cbnz	w0, 1136b84 <ltc_ecc_map+0x1c0>
   if ((err = mp_montgomery_reduce(P->y, modulus, mp)) != CRYPT_OK)           { goto done; }
 1136b54:	f9400680 	ldr	x0, [x20, #8]
 1136b58:	aa1603e2 	mov	x2, x22
 1136b5c:	f940a2e3 	ldr	x3, [x23, #320]
 1136b60:	aa1503e1 	mov	x1, x21
 1136b64:	d63f0060 	blr	x3
 1136b68:	2a0003f3 	mov	w19, w0
 1136b6c:	350000c0 	cbnz	w0, 1136b84 <ltc_ecc_map+0x1c0>
   if ((err = mp_set(P->z, 1)) != CRYPT_OK)                                   { goto done; }
 1136b70:	f9400a80 	ldr	x0, [x20, #16]
 1136b74:	d2800021 	mov	x1, #0x1                   	// #1
 1136b78:	f94022e2 	ldr	x2, [x23, #64]
 1136b7c:	d63f0040 	blr	x2
 1136b80:	2a0003f3 	mov	w19, w0
   mp_clear_multi(t1, t2, NULL);
 1136b84:	a94407e0 	ldp	x0, x1, [sp, #64]
 1136b88:	d2800002 	mov	x2, #0x0                   	// #0
 1136b8c:	97ffed64 	bl	113211c <ltc_deinit_multi>
   return err;
 1136b90:	17ffffa5 	b	1136a24 <ltc_ecc_map+0x60>
   LTC_ARGCHK(P       != NULL);
 1136b94:	52800213 	mov	w19, #0x10                  	// #16
 1136b98:	17ffffa3 	b	1136a24 <ltc_ecc_map+0x60>

0000000001136b9c <ltc_ecc_mulmod>:
   @param modulus  The modulus of the field the ECC curve is in
   @param map      Boolean whether to map back to affine or not (1==map, 0 == leave in projective)
   @return CRYPT_OK on success
*/
int ltc_ecc_mulmod(void *k, const ecc_point *G, ecc_point *R, void *a, void *modulus, int map)
{
 1136b9c:	a9b37bfd 	stp	x29, x30, [sp, #-208]!
 1136ba0:	910003fd 	mov	x29, sp
 1136ba4:	a90153f3 	stp	x19, x20, [sp, #16]
 1136ba8:	a9025bf5 	stp	x21, x22, [sp, #32]
 1136bac:	a90363f7 	stp	x23, x24, [sp, #48]
 1136bb0:	a9046bf9 	stp	x25, x26, [sp, #64]
 1136bb4:	a90573fb 	stp	x27, x28, [sp, #80]
 1136bb8:	f90043e0 	str	x0, [sp, #128]
 1136bbc:	b9008fe5 	str	w5, [sp, #140]
   ecc_point *tG, *M[3];
   int        i, j, err, inf;
   void       *mp = NULL, *mu = NULL, *ma = NULL, *a_plus3 = NULL;
 1136bc0:	a909ffff 	stp	xzr, xzr, [sp, #152]
 1136bc4:	a90affff 	stp	xzr, xzr, [sp, #168]
   ltc_mp_digit buf;
   int        bitcnt, mode, digidx;

   LTC_ARGCHK(k       != NULL);
 1136bc8:	b40026a0 	cbz	x0, 113709c <ltc_ecc_mulmod+0x500>
 1136bcc:	aa0103fa 	mov	x26, x1
   LTC_ARGCHK(G       != NULL);
 1136bd0:	b4002661 	cbz	x1, 113709c <ltc_ecc_mulmod+0x500>
 1136bd4:	aa0203f9 	mov	x25, x2
   LTC_ARGCHK(R       != NULL);
 1136bd8:	b4002622 	cbz	x2, 113709c <ltc_ecc_mulmod+0x500>
 1136bdc:	aa0403f3 	mov	x19, x4
   LTC_ARGCHK(modulus != NULL);
 1136be0:	b40025e4 	cbz	x4, 113709c <ltc_ecc_mulmod+0x500>
 1136be4:	aa0303f5 	mov	x21, x3

   if ((err = ltc_ecc_is_point_at_infinity(G, modulus, &inf)) != CRYPT_OK) return err;
 1136be8:	910253e2 	add	x2, sp, #0x94
 1136bec:	aa0403e1 	mov	x1, x4
 1136bf0:	aa1a03e0 	mov	x0, x26
 1136bf4:	97ffff22 	bl	113687c <ltc_ecc_is_point_at_infinity>
 1136bf8:	2a0003fb 	mov	w27, w0
 1136bfc:	35000120 	cbnz	w0, 1136c20 <ltc_ecc_mulmod+0x84>
   if (inf) {
 1136c00:	b94097e0 	ldr	w0, [sp, #148]
 1136c04:	340001e0 	cbz	w0, 1136c40 <ltc_ecc_mulmod+0xa4>
      /* return the point at infinity */
      return ltc_ecc_set_point_xyz(1, 1, 0, R);
 1136c08:	d2800021 	mov	x1, #0x1                   	// #1
 1136c0c:	aa1903e3 	mov	x3, x25
 1136c10:	aa0103e0 	mov	x0, x1
 1136c14:	d2800002 	mov	x2, #0x0                   	// #0
 1136c18:	940002ab 	bl	11376c4 <ltc_ecc_set_point_xyz>
 1136c1c:	2a0003fb 	mov	w27, w0
   if (ma != NULL) mp_clear(ma);
   if (a_plus3 != NULL) mp_clear(a_plus3);
   if (mu != NULL) mp_clear(mu);
   if (mp != NULL) mp_montgomery_free(mp);
   return err;
}
 1136c20:	2a1b03e0 	mov	w0, w27
 1136c24:	a94153f3 	ldp	x19, x20, [sp, #16]
 1136c28:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1136c2c:	a94363f7 	ldp	x23, x24, [sp, #48]
 1136c30:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1136c34:	a94573fb 	ldp	x27, x28, [sp, #80]
 1136c38:	a8cd7bfd 	ldp	x29, x30, [sp], #208
 1136c3c:	d65f03c0 	ret
   if ((err = mp_montgomery_setup(modulus, &mp)) != CRYPT_OK)        { goto error; }
 1136c40:	90000122 	adrp	x2, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1136c44:	910263e1 	add	x1, sp, #0x98
 1136c48:	aa1303e0 	mov	x0, x19
 1136c4c:	f90033e2 	str	x2, [sp, #96]
 1136c50:	f941d456 	ldr	x22, [x2, #936]
 1136c54:	f9409ac3 	ldr	x3, [x22, #304]
 1136c58:	d63f0060 	blr	x3
 1136c5c:	2a0003fb 	mov	w27, w0
 1136c60:	f94033e2 	ldr	x2, [sp, #96]
 1136c64:	aa0203f4 	mov	x20, x2
 1136c68:	35000680 	cbnz	w0, 1136d38 <ltc_ecc_mulmod+0x19c>
   if ((err = mp_init(&mu)) != CRYPT_OK)                             { goto error; }
 1136c6c:	f9400ac1 	ldr	x1, [x22, #16]
 1136c70:	910283e0 	add	x0, sp, #0xa0
 1136c74:	d63f0020 	blr	x1
 1136c78:	2a0003fb 	mov	w27, w0
 1136c7c:	350005e0 	cbnz	w0, 1136d38 <ltc_ecc_mulmod+0x19c>
   if ((err = mp_montgomery_normalization(mu, modulus)) != CRYPT_OK) { goto error; }
 1136c80:	f94053e0 	ldr	x0, [sp, #160]
 1136c84:	aa1303e1 	mov	x1, x19
 1136c88:	f9409ec2 	ldr	x2, [x22, #312]
 1136c8c:	d63f0040 	blr	x2
 1136c90:	2a0003fb 	mov	w27, w0
 1136c94:	35000520 	cbnz	w0, 1136d38 <ltc_ecc_mulmod+0x19c>
   if ((err = mp_init(&a_plus3)) != CRYPT_OK)                        { goto error; }
 1136c98:	f9400ac1 	ldr	x1, [x22, #16]
 1136c9c:	9102c3e0 	add	x0, sp, #0xb0
 1136ca0:	d63f0020 	blr	x1
 1136ca4:	2a0003fb 	mov	w27, w0
 1136ca8:	35000480 	cbnz	w0, 1136d38 <ltc_ecc_mulmod+0x19c>
   if ((err = mp_add_d(a, 3, a_plus3)) != CRYPT_OK)                  { goto error; }
 1136cac:	f941d696 	ldr	x22, [x20, #936]
 1136cb0:	aa1503e0 	mov	x0, x21
 1136cb4:	f9405be2 	ldr	x2, [sp, #176]
 1136cb8:	d2800061 	mov	x1, #0x3                   	// #3
 1136cbc:	f9405ec3 	ldr	x3, [x22, #184]
 1136cc0:	d63f0060 	blr	x3
 1136cc4:	2a0003fb 	mov	w27, w0
 1136cc8:	35000380 	cbnz	w0, 1136d38 <ltc_ecc_mulmod+0x19c>
   if (mp_cmp(a_plus3, modulus) != LTC_MP_EQ) {
 1136ccc:	f94032c2 	ldr	x2, [x22, #96]
 1136cd0:	aa1303e1 	mov	x1, x19
 1136cd4:	f9405be0 	ldr	x0, [sp, #176]
 1136cd8:	d63f0040 	blr	x2
 1136cdc:	35000160 	cbnz	w0, 1136d08 <ltc_ecc_mulmod+0x16c>
      M[i] = ltc_ecc_new_point();
 1136ce0:	9102e3e0 	add	x0, sp, #0xb8
{
 1136ce4:	d2800015 	mov	x21, #0x0                   	// #0
      M[i] = ltc_ecc_new_point();
 1136ce8:	f9003be0 	str	x0, [sp, #112]
 1136cec:	94000252 	bl	1137634 <ltc_ecc_new_point>
 1136cf0:	2a1503f6 	mov	w22, w21
 1136cf4:	f9403be1 	ldr	x1, [sp, #112]
 1136cf8:	f8357820 	str	x0, [x1, x21, lsl #3]
      if (M[i] == NULL) {
 1136cfc:	b5000660 	cbnz	x0, 1136dc8 <ltc_ecc_mulmod+0x22c>
 1136d00:	d2800013 	mov	x19, #0x0                   	// #0
 1136d04:	14000026 	b	1136d9c <ltc_ecc_mulmod+0x200>
      if ((err = mp_init(&ma)) != CRYPT_OK)                          { goto error; }
 1136d08:	f9400ac1 	ldr	x1, [x22, #16]
 1136d0c:	9102a3e0 	add	x0, sp, #0xa8
 1136d10:	d63f0020 	blr	x1
 1136d14:	2a0003fb 	mov	w27, w0
 1136d18:	35000100 	cbnz	w0, 1136d38 <ltc_ecc_mulmod+0x19c>
      if ((err = mp_mulmod(a, mu, modulus, ma)) != CRYPT_OK)         { goto error; }
 1136d1c:	a94a0fe1 	ldp	x1, x3, [sp, #160]
 1136d20:	aa1303e2 	mov	x2, x19
 1136d24:	f9408ec4 	ldr	x4, [x22, #280]
 1136d28:	aa1503e0 	mov	x0, x21
 1136d2c:	d63f0080 	blr	x4
 1136d30:	2a0003fb 	mov	w27, w0
 1136d34:	34fffd60 	cbz	w0, 1136ce0 <ltc_ecc_mulmod+0x144>
   if (ma != NULL) mp_clear(ma);
 1136d38:	f94057e0 	ldr	x0, [sp, #168]
 1136d3c:	b4000080 	cbz	x0, 1136d4c <ltc_ecc_mulmod+0x1b0>
 1136d40:	f941d682 	ldr	x2, [x20, #936]
 1136d44:	f9401442 	ldr	x2, [x2, #40]
 1136d48:	d63f0040 	blr	x2
   if (a_plus3 != NULL) mp_clear(a_plus3);
 1136d4c:	f9405be0 	ldr	x0, [sp, #176]
 1136d50:	b4000080 	cbz	x0, 1136d60 <ltc_ecc_mulmod+0x1c4>
 1136d54:	f941d682 	ldr	x2, [x20, #936]
 1136d58:	f9401442 	ldr	x2, [x2, #40]
 1136d5c:	d63f0040 	blr	x2
   if (mu != NULL) mp_clear(mu);
 1136d60:	f94053e0 	ldr	x0, [sp, #160]
 1136d64:	b4000080 	cbz	x0, 1136d74 <ltc_ecc_mulmod+0x1d8>
 1136d68:	f941d682 	ldr	x2, [x20, #936]
 1136d6c:	f9401442 	ldr	x2, [x2, #40]
 1136d70:	d63f0040 	blr	x2
   if (mp != NULL) mp_montgomery_free(mp);
 1136d74:	f9404fe0 	ldr	x0, [sp, #152]
 1136d78:	b4fff540 	cbz	x0, 1136c20 <ltc_ecc_mulmod+0x84>
 1136d7c:	f941d694 	ldr	x20, [x20, #936]
 1136d80:	f940a682 	ldr	x2, [x20, #328]
 1136d84:	d63f0040 	blr	x2
 1136d88:	17ffffa6 	b	1136c20 <ltc_ecc_mulmod+0x84>
             ltc_ecc_del_point(M[j]);
 1136d8c:	f9403be0 	ldr	x0, [sp, #112]
 1136d90:	f8737800 	ldr	x0, [x0, x19, lsl #3]
 1136d94:	91000673 	add	x19, x19, #0x1
 1136d98:	9400023d 	bl	113768c <ltc_ecc_del_point>
         for (j = 0; j < i; j++) {
 1136d9c:	6b1302df 	cmp	w22, w19
 1136da0:	54ffff6c 	b.gt	1136d8c <ltc_ecc_mulmod+0x1f0>
         mp_clear(mu);
 1136da4:	f941d694 	ldr	x20, [x20, #936]
         return CRYPT_MEM;
 1136da8:	528001bb 	mov	w27, #0xd                   	// #13
         mp_clear(mu);
 1136dac:	f94053e0 	ldr	x0, [sp, #160]
 1136db0:	f9401681 	ldr	x1, [x20, #40]
 1136db4:	d63f0020 	blr	x1
         mp_montgomery_free(mp);
 1136db8:	f9404fe0 	ldr	x0, [sp, #152]
 1136dbc:	f940a681 	ldr	x1, [x20, #328]
 1136dc0:	d63f0020 	blr	x1
         return CRYPT_MEM;
 1136dc4:	17ffff97 	b	1136c20 <ltc_ecc_mulmod+0x84>
   for (i = 0; i < 3; i++) {
 1136dc8:	910006b5 	add	x21, x21, #0x1
 1136dcc:	f1000ebf 	cmp	x21, #0x3
 1136dd0:	54fff8e1 	b.ne	1136cec <ltc_ecc_mulmod+0x150>  // b.any
   tG = ltc_ecc_new_point();
 1136dd4:	94000218 	bl	1137634 <ltc_ecc_new_point>
 1136dd8:	aa0003f6 	mov	x22, x0
   if (tG == NULL)                                                                   { err = CRYPT_MEM; goto done; }
 1136ddc:	a94bdff8 	ldp	x24, x23, [sp, #184]
 1136de0:	b40015a0 	cbz	x0, 1137094 <ltc_ecc_mulmod+0x4f8>
   if ((err = mp_mulmod(G->x, mu, modulus, tG->x)) != CRYPT_OK)                      { goto done; }
 1136de4:	f941d695 	ldr	x21, [x20, #936]
 1136de8:	aa1303e2 	mov	x2, x19
 1136dec:	f9400003 	ldr	x3, [x0]
 1136df0:	f9400340 	ldr	x0, [x26]
 1136df4:	f94053e1 	ldr	x1, [sp, #160]
 1136df8:	f9408ea4 	ldr	x4, [x21, #280]
 1136dfc:	d63f0080 	blr	x4
 1136e00:	2a0003fb 	mov	w27, w0
 1136e04:	35001360 	cbnz	w0, 1137070 <ltc_ecc_mulmod+0x4d4>
   if ((err = mp_mulmod(G->y, mu, modulus, tG->y)) != CRYPT_OK)                      { goto done; }
 1136e08:	f94006c3 	ldr	x3, [x22, #8]
 1136e0c:	aa1303e2 	mov	x2, x19
 1136e10:	f9400740 	ldr	x0, [x26, #8]
 1136e14:	f94053e1 	ldr	x1, [sp, #160]
 1136e18:	f9408ea4 	ldr	x4, [x21, #280]
 1136e1c:	d63f0080 	blr	x4
 1136e20:	2a0003fb 	mov	w27, w0
 1136e24:	35001260 	cbnz	w0, 1137070 <ltc_ecc_mulmod+0x4d4>
   if ((err = mp_mulmod(G->z, mu, modulus, tG->z)) != CRYPT_OK)                      { goto done; }
 1136e28:	f9400ac3 	ldr	x3, [x22, #16]
 1136e2c:	aa1303e2 	mov	x2, x19
 1136e30:	f9400b40 	ldr	x0, [x26, #16]
 1136e34:	f94053e1 	ldr	x1, [sp, #160]
 1136e38:	f9408ea4 	ldr	x4, [x21, #280]
 1136e3c:	d63f0080 	blr	x4
 1136e40:	2a0003fb 	mov	w27, w0
 1136e44:	35001160 	cbnz	w0, 1137070 <ltc_ecc_mulmod+0x4d4>
   mp_clear(mu);
 1136e48:	f94016a1 	ldr	x1, [x21, #40]
 1136e4c:	f94053e0 	ldr	x0, [sp, #160]
 1136e50:	d63f0020 	blr	x1
   mu = NULL;
 1136e54:	f90053ff 	str	xzr, [sp, #160]
   if ((err = ltc_ecc_copy_point(tG, M[0])) != CRYPT_OK)                             { goto done; }
 1136e58:	aa1803e1 	mov	x1, x24
 1136e5c:	aa1603e0 	mov	x0, x22
 1136e60:	94000238 	bl	1137740 <ltc_ecc_copy_point>
 1136e64:	2a0003fb 	mov	w27, w0
 1136e68:	35001040 	cbnz	w0, 1137070 <ltc_ecc_mulmod+0x4d4>
   if ((err = ltc_mp.ecc_ptdbl(tG, M[1], ma, modulus, mp)) != CRYPT_OK)              { goto done; }
 1136e6c:	f9404fe4 	ldr	x4, [sp, #152]
 1136e70:	aa1303e3 	mov	x3, x19
 1136e74:	f94057e2 	ldr	x2, [sp, #168]
 1136e78:	aa1703e1 	mov	x1, x23
 1136e7c:	f940baa5 	ldr	x5, [x21, #368]
 1136e80:	aa1603e0 	mov	x0, x22
 1136e84:	d63f00a0 	blr	x5
 1136e88:	2a0003fb 	mov	w27, w0
 1136e8c:	35000f20 	cbnz	w0, 1137070 <ltc_ecc_mulmod+0x4d4>
   digidx = mp_get_digit_count(k) - 1;
 1136e90:	f9402ea1 	ldr	x1, [x21, #88]
      i = (int)((buf >> (MP_DIGIT_BIT - 1)) & 1);
 1136e94:	aa1503fc 	mov	x28, x21
   digidx = mp_get_digit_count(k) - 1;
 1136e98:	f94043e0 	ldr	x0, [sp, #128]
 1136e9c:	d63f0020 	blr	x1
 1136ea0:	5100041a 	sub	w26, w0, #0x1
   bitcnt = 1;
 1136ea4:	52800020 	mov	w0, #0x1                   	// #1
   buf    = 0;
 1136ea8:	f90033ff 	str	xzr, [sp, #96]
   mode   = 0;
 1136eac:	b9006bff 	str	wzr, [sp, #104]
   bitcnt = 1;
 1136eb0:	b9007fe0 	str	w0, [sp, #124]
      if (--bitcnt == 0) {
 1136eb4:	b9407fe0 	ldr	w0, [sp, #124]
 1136eb8:	71000400 	subs	w0, w0, #0x1
 1136ebc:	b9007fe0 	str	w0, [sp, #124]
 1136ec0:	54000161 	b.ne	1136eec <ltc_ecc_mulmod+0x350>  // b.any
         if (digidx == -1) {
 1136ec4:	3100075f 	cmn	w26, #0x1
 1136ec8:	54000bc0 	b.eq	1137040 <ltc_ecc_mulmod+0x4a4>  // b.none
         buf    = mp_get_digit(k, digidx);
 1136ecc:	f9402aa2 	ldr	x2, [x21, #80]
 1136ed0:	2a1a03e1 	mov	w1, w26
 1136ed4:	f94043e0 	ldr	x0, [sp, #128]
         --digidx;
 1136ed8:	5100075a 	sub	w26, w26, #0x1
         buf    = mp_get_digit(k, digidx);
 1136edc:	d63f0040 	blr	x2
 1136ee0:	f90033e0 	str	x0, [sp, #96]
         bitcnt = (int) MP_DIGIT_BIT;
 1136ee4:	b9400aa0 	ldr	w0, [x21, #8]
 1136ee8:	b9007fe0 	str	w0, [sp, #124]
      i = (int)((buf >> (MP_DIGIT_BIT - 1)) & 1);
 1136eec:	b9400b86 	ldr	w6, [x28, #8]
 1136ef0:	f94033e0 	ldr	x0, [sp, #96]
 1136ef4:	510004c6 	sub	w6, w6, #0x1
 1136ef8:	f9404fe5 	ldr	x5, [sp, #152]
 1136efc:	9ac62406 	lsr	x6, x0, x6
      if (mode == 0 && i == 0) {
 1136f00:	b9406be0 	ldr	w0, [sp, #104]
      i = (int)((buf >> (MP_DIGIT_BIT - 1)) & 1);
 1136f04:	120000c6 	and	w6, w6, #0x1
      if (mode == 0 && i == 0) {
 1136f08:	2a060000 	orr	w0, w0, w6
 1136f0c:	b9008be0 	str	w0, [sp, #136]
 1136f10:	f94057e3 	ldr	x3, [sp, #168]
 1136f14:	f94067e7 	ldr	x7, [sp, #200]
 1136f18:	f940b788 	ldr	x8, [x28, #360]
 1136f1c:	35000300 	cbnz	w0, 1136f7c <ltc_ecc_mulmod+0x3e0>
         if ((err = ltc_mp.ecc_ptadd(M[0], M[1], M[2], ma, modulus, mp)) != CRYPT_OK) { goto done; }
 1136f20:	aa1303e4 	mov	x4, x19
 1136f24:	aa0703e2 	mov	x2, x7
 1136f28:	aa1703e1 	mov	x1, x23
 1136f2c:	aa1803e0 	mov	x0, x24
 1136f30:	f90037e7 	str	x7, [sp, #104]
 1136f34:	d63f0100 	blr	x8
 1136f38:	2a0003fb 	mov	w27, w0
 1136f3c:	350009a0 	cbnz	w0, 1137070 <ltc_ecc_mulmod+0x4d4>
         if ((err = ltc_mp.ecc_ptdbl(M[1], M[2], ma, modulus, mp)) != CRYPT_OK)       { goto done; }
 1136f40:	f94037e7 	ldr	x7, [sp, #104]
 1136f44:	aa1303e3 	mov	x3, x19
 1136f48:	f9404fe4 	ldr	x4, [sp, #152]
 1136f4c:	aa1703e0 	mov	x0, x23
 1136f50:	f94057e2 	ldr	x2, [sp, #168]
 1136f54:	aa0703e1 	mov	x1, x7
 1136f58:	f940bb85 	ldr	x5, [x28, #368]
 1136f5c:	d63f00a0 	blr	x5
 1136f60:	2a0003fb 	mov	w27, w0
 1136f64:	35000860 	cbnz	w0, 1137070 <ltc_ecc_mulmod+0x4d4>
      buf <<= 1;
 1136f68:	f94033e0 	ldr	x0, [sp, #96]
 1136f6c:	b9006bfb 	str	w27, [sp, #104]
 1136f70:	d37ff800 	lsl	x0, x0, #1
 1136f74:	f90033e0 	str	x0, [sp, #96]
 1136f78:	17ffffcf 	b	1136eb4 <ltc_ecc_mulmod+0x318>
      if (mode == 0 && i == 1) {
 1136f7c:	b9406be0 	ldr	w0, [sp, #104]
 1136f80:	52000000 	eor	w0, w0, #0x1
 1136f84:	6a06001f 	tst	w0, w6
 1136f88:	540002a0 	b.eq	1136fdc <ltc_ecc_mulmod+0x440>  // b.none
         if ((err = ltc_mp.ecc_ptadd(M[0], M[1], M[2], ma, modulus, mp)) != CRYPT_OK) { goto done; }
 1136f8c:	aa1303e4 	mov	x4, x19
 1136f90:	aa0703e2 	mov	x2, x7
 1136f94:	aa1703e1 	mov	x1, x23
 1136f98:	aa1803e0 	mov	x0, x24
 1136f9c:	f90037e7 	str	x7, [sp, #104]
 1136fa0:	d63f0100 	blr	x8
 1136fa4:	2a0003fb 	mov	w27, w0
 1136fa8:	35000640 	cbnz	w0, 1137070 <ltc_ecc_mulmod+0x4d4>
         if ((err = ltc_mp.ecc_ptdbl(M[1], M[2], ma, modulus, mp)) != CRYPT_OK)       { goto done; }
 1136fac:	f94037e7 	ldr	x7, [sp, #104]
 1136fb0:	aa1303e3 	mov	x3, x19
 1136fb4:	f9404fe4 	ldr	x4, [sp, #152]
 1136fb8:	aa1703e0 	mov	x0, x23
 1136fbc:	f94057e2 	ldr	x2, [sp, #168]
 1136fc0:	aa0703e1 	mov	x1, x7
 1136fc4:	f940bb85 	ldr	x5, [x28, #368]
 1136fc8:	d63f00a0 	blr	x5
 1136fcc:	2a0003fb 	mov	w27, w0
 1136fd0:	35000500 	cbnz	w0, 1137070 <ltc_ecc_mulmod+0x4d4>
         mode = 1;
 1136fd4:	b9408bfb 	ldr	w27, [sp, #136]
 1136fd8:	17ffffe4 	b	1136f68 <ltc_ecc_mulmod+0x3cc>
      if ((err = ltc_mp.ecc_ptadd(M[0], M[1], M[i^1], ma, modulus, mp)) != CRYPT_OK)  { goto done; }
 1136fdc:	520000c0 	eor	w0, w6, #0x1
 1136fe0:	aa1303e4 	mov	x4, x19
 1136fe4:	f9403be1 	ldr	x1, [sp, #112]
 1136fe8:	93407c00 	sxtw	x0, w0
 1136fec:	b9008be6 	str	w6, [sp, #136]
 1136ff0:	f8607822 	ldr	x2, [x1, x0, lsl #3]
 1136ff4:	aa1703e1 	mov	x1, x23
 1136ff8:	aa1803e0 	mov	x0, x24
 1136ffc:	d63f0100 	blr	x8
 1137000:	2a0003fb 	mov	w27, w0
 1137004:	35000360 	cbnz	w0, 1137070 <ltc_ecc_mulmod+0x4d4>
      if ((err = ltc_mp.ecc_ptdbl(M[i], M[i], ma, modulus, mp)) != CRYPT_OK)          { goto done; }
 1137008:	b9408be6 	ldr	w6, [sp, #136]
 113700c:	aa1303e3 	mov	x3, x19
 1137010:	f9403be0 	ldr	x0, [sp, #112]
 1137014:	93407cc6 	sxtw	x6, w6
 1137018:	f9404fe4 	ldr	x4, [sp, #152]
 113701c:	f8667801 	ldr	x1, [x0, x6, lsl #3]
 1137020:	f94057e2 	ldr	x2, [sp, #168]
 1137024:	aa0103e0 	mov	x0, x1
 1137028:	f940bb85 	ldr	x5, [x28, #368]
 113702c:	d63f00a0 	blr	x5
 1137030:	2a0003fb 	mov	w27, w0
 1137034:	350001e0 	cbnz	w0, 1137070 <ltc_ecc_mulmod+0x4d4>
 1137038:	b9406bfb 	ldr	w27, [sp, #104]
 113703c:	17ffffcb 	b	1136f68 <ltc_ecc_mulmod+0x3cc>
   if ((err = ltc_ecc_copy_point(M[0], R)) != CRYPT_OK)                              { goto done; }
 1137040:	aa1903e1 	mov	x1, x25
 1137044:	aa1803e0 	mov	x0, x24
 1137048:	940001be 	bl	1137740 <ltc_ecc_copy_point>
 113704c:	2a0003fb 	mov	w27, w0
 1137050:	35000100 	cbnz	w0, 1137070 <ltc_ecc_mulmod+0x4d4>
   if (map) {
 1137054:	b9408fe0 	ldr	w0, [sp, #140]
 1137058:	340000c0 	cbz	w0, 1137070 <ltc_ecc_mulmod+0x4d4>
      err = ltc_ecc_map(R, modulus, mp);
 113705c:	f9404fe2 	ldr	x2, [sp, #152]
 1137060:	aa1303e1 	mov	x1, x19
 1137064:	aa1903e0 	mov	x0, x25
 1137068:	97fffe57 	bl	11369c4 <ltc_ecc_map>
 113706c:	2a0003fb 	mov	w27, w0
   ltc_ecc_del_point(tG);
 1137070:	aa1603e0 	mov	x0, x22
 1137074:	94000186 	bl	113768c <ltc_ecc_del_point>
       ltc_ecc_del_point(M[i]);
 1137078:	aa1803e0 	mov	x0, x24
 113707c:	94000184 	bl	113768c <ltc_ecc_del_point>
 1137080:	aa1703e0 	mov	x0, x23
 1137084:	94000182 	bl	113768c <ltc_ecc_del_point>
 1137088:	f94067e0 	ldr	x0, [sp, #200]
 113708c:	94000180 	bl	113768c <ltc_ecc_del_point>
error:
 1137090:	17ffff2a 	b	1136d38 <ltc_ecc_mulmod+0x19c>
   if (tG == NULL)                                                                   { err = CRYPT_MEM; goto done; }
 1137094:	528001bb 	mov	w27, #0xd                   	// #13
 1137098:	17fffff6 	b	1137070 <ltc_ecc_mulmod+0x4d4>
   LTC_ARGCHK(k       != NULL);
 113709c:	5280021b 	mov	w27, #0x10                  	// #16
 11370a0:	17fffee0 	b	1136c20 <ltc_ecc_mulmod+0x84>

00000000011370a4 <ltc_ecc_mul2add>:
  unsigned char *tA, *tB;
  int            err, first;
  void          *mp, *mu;

  /* argchks */
  LTC_ARGCHK(A       != NULL);
 11370a4:	b4002be0 	cbz	x0, 1137620 <ltc_ecc_mul2add+0x57c>
{
 11370a8:	a9ae7bfd 	stp	x29, x30, [sp, #-288]!
 11370ac:	910003fd 	mov	x29, sp
 11370b0:	a90153f3 	stp	x19, x20, [sp, #16]
 11370b4:	a9025bf5 	stp	x21, x22, [sp, #32]
 11370b8:	a90363f7 	stp	x23, x24, [sp, #48]
 11370bc:	a9046bf9 	stp	x25, x26, [sp, #64]
 11370c0:	aa0203fa 	mov	x26, x2
 11370c4:	a90573fb 	stp	x27, x28, [sp, #80]
  LTC_ARGCHK(B       != NULL);
 11370c8:	b4002b22 	cbz	x2, 113762c <ltc_ecc_mul2add+0x588>
 11370cc:	aa0403f4 	mov	x20, x4
  LTC_ARGCHK(C       != NULL);
 11370d0:	b4002ae4 	cbz	x4, 113762c <ltc_ecc_mul2add+0x588>
 11370d4:	aa0103fc 	mov	x28, x1
  LTC_ARGCHK(kA      != NULL);
 11370d8:	b4002aa1 	cbz	x1, 113762c <ltc_ecc_mul2add+0x588>
 11370dc:	aa0303f8 	mov	x24, x3
  LTC_ARGCHK(kB      != NULL);
 11370e0:	b4002a63 	cbz	x3, 113762c <ltc_ecc_mul2add+0x588>
 11370e4:	aa0603f3 	mov	x19, x6
  LTC_ARGCHK(modulus != NULL);
 11370e8:	b4002a26 	cbz	x6, 113762c <ltc_ecc_mul2add+0x588>
 11370ec:	aa0003fb 	mov	x27, x0
 11370f0:	aa0503f5 	mov	x21, x5

  /* allocate memory */
  tA = XCALLOC(1, ECC_BUF_SIZE);
 11370f4:	d2802001 	mov	x1, #0x100                 	// #256
 11370f8:	d2800020 	mov	x0, #0x1                   	// #1
 11370fc:	940030f5 	bl	11434d0 <calloc>
 1137100:	aa0003f6 	mov	x22, x0
  if (tA == NULL) {
 1137104:	b4000100 	cbz	x0, 1137124 <ltc_ecc_mul2add+0x80>
     return CRYPT_MEM;
  }
  tB = XCALLOC(1, ECC_BUF_SIZE);
 1137108:	d2802001 	mov	x1, #0x100                 	// #256
 113710c:	d2800020 	mov	x0, #0x1                   	// #1
 1137110:	940030f0 	bl	11434d0 <calloc>
 1137114:	aa0003f7 	mov	x23, x0
  if (tB == NULL) {
 1137118:	b50000a0 	cbnz	x0, 113712c <ltc_ecc_mul2add+0x88>
     XFREE(tA);
 113711c:	aa1603e0 	mov	x0, x22
 1137120:	94003130 	bl	11435e0 <free>
     return CRYPT_MEM;
 1137124:	528001a2 	mov	w2, #0xd                   	// #13
 1137128:	1400003d 	b	113721c <ltc_ecc_mul2add+0x178>
     return CRYPT_MEM;
  }

  /* get sizes */
  lenA = mp_unsigned_bin_size(kA);
 113712c:	f0000103 	adrp	x3, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1137130:	aa1c03e0 	mov	x0, x28
 1137134:	f9003be3 	str	x3, [sp, #112]
 1137138:	f941d479 	ldr	x25, [x3, #936]
 113713c:	f9404f21 	ldr	x1, [x25, #152]
 1137140:	d63f0020 	blr	x1
 1137144:	aa0003e1 	mov	x1, x0
  lenB = mp_unsigned_bin_size(kB);
 1137148:	f9404f22 	ldr	x2, [x25, #152]
 113714c:	aa1803e0 	mov	x0, x24
  lenA = mp_unsigned_bin_size(kA);
 1137150:	f90037e1 	str	x1, [sp, #104]
  lenB = mp_unsigned_bin_size(kB);
 1137154:	d63f0040 	blr	x2
 1137158:	aa0003e2 	mov	x2, x0
  len  = MAX(lenA, lenB);

  /* sanity check */
  if ((lenA > ECC_BUF_SIZE) || (lenB > ECC_BUF_SIZE)) {
 113715c:	a9468fe1 	ldp	x1, x3, [sp, #104]
 1137160:	f90037e3 	str	x3, [sp, #104]
 1137164:	52802000 	mov	w0, #0x100                 	// #256
 1137168:	7104003f 	cmp	w1, #0x100
 113716c:	7a409042 	ccmp	w2, w0, #0x2, ls  // ls = plast
 1137170:	54002548 	b.hi	1137618 <ltc_ecc_mul2add+0x574>  // b.pmore
     err = CRYPT_INVALID_ARG;
     goto ERR_T;
  }

  /* extract and justify kA */
  mp_to_unsigned_bin(kA, (len - lenA) + tA);
 1137174:	f9405323 	ldr	x3, [x25, #160]
  len  = MAX(lenA, lenB);
 1137178:	6b02003f 	cmp	w1, w2
 113717c:	1a822020 	csel	w0, w1, w2, cs  // cs = hs, nlast
 1137180:	f9003be2 	str	x2, [sp, #112]
  mp_to_unsigned_bin(kA, (len - lenA) + tA);
 1137184:	4b010001 	sub	w1, w0, w1
  len  = MAX(lenA, lenB);
 1137188:	b90083e0 	str	w0, [sp, #128]
  mp_to_unsigned_bin(kA, (len - lenA) + tA);
 113718c:	8b0102c1 	add	x1, x22, x1
 1137190:	aa1c03e0 	mov	x0, x28
 1137194:	d63f0060 	blr	x3

  /* extract and justify kB */
  mp_to_unsigned_bin(kB, (len - lenB) + tB);
 1137198:	f9403be2 	ldr	x2, [sp, #112]
 113719c:	b94083e0 	ldr	w0, [sp, #128]
 11371a0:	4b020001 	sub	w1, w0, w2
 11371a4:	aa1803e0 	mov	x0, x24
 11371a8:	f9405322 	ldr	x2, [x25, #160]

  /* allocate the table */
  for (x = 0; x < 16; x++) {
     precomp[x] = ltc_ecc_new_point();
 11371ac:	910283f8 	add	x24, sp, #0xa0
  mp_to_unsigned_bin(kB, (len - lenB) + tB);
 11371b0:	d2800019 	mov	x25, #0x0                   	// #0
 11371b4:	8b0102e1 	add	x1, x23, x1
 11371b8:	d63f0040 	blr	x2
     precomp[x] = ltc_ecc_new_point();
 11371bc:	9400011e 	bl	1137634 <ltc_ecc_new_point>
 11371c0:	f8397b00 	str	x0, [x24, x25, lsl #3]
 11371c4:	2a1903fc 	mov	w28, w25
     if (precomp[x] == NULL) {
 11371c8:	b50003a0 	cbnz	x0, 113723c <ltc_ecc_mul2add+0x198>
 11371cc:	d2800013 	mov	x19, #0x0                   	// #0
 11371d0:	14000004 	b	11371e0 <ltc_ecc_mul2add+0x13c>
         for (y = 0; y < x; ++y) {
            ltc_ecc_del_point(precomp[y]);
 11371d4:	f8737b00 	ldr	x0, [x24, x19, lsl #3]
 11371d8:	91000673 	add	x19, x19, #0x1
 11371dc:	9400012c 	bl	113768c <ltc_ecc_del_point>
         for (y = 0; y < x; ++y) {
 11371e0:	6b13039f 	cmp	w28, w19
 11371e4:	54ffff88 	b.hi	11371d4 <ltc_ecc_mul2add+0x130>  // b.pmore
         }
         err = CRYPT_MEM;
 11371e8:	528001a2 	mov	w2, #0xd                   	// #13
   for (x = 0; x < 16; x++) {
       ltc_ecc_del_point(precomp[x]);
   }
ERR_T:
#ifdef LTC_CLEAN_STACK
   zeromem(tA, ECC_BUF_SIZE);
 11371ec:	aa1603e0 	mov	x0, x22
 11371f0:	d2802001 	mov	x1, #0x100                 	// #256
 11371f4:	b9006be2 	str	w2, [sp, #104]
 11371f8:	97ffec93 	bl	1132444 <zeromem>
   zeromem(tB, ECC_BUF_SIZE);
 11371fc:	d2802001 	mov	x1, #0x100                 	// #256
 1137200:	aa1703e0 	mov	x0, x23
 1137204:	97ffec90 	bl	1132444 <zeromem>
#endif
   XFREE(tA);
 1137208:	aa1603e0 	mov	x0, x22
 113720c:	940030f5 	bl	11435e0 <free>
   XFREE(tB);
 1137210:	aa1703e0 	mov	x0, x23
 1137214:	940030f3 	bl	11435e0 <free>

   return err;
 1137218:	b9406be2 	ldr	w2, [sp, #104]
}
 113721c:	2a0203e0 	mov	w0, w2
 1137220:	a94153f3 	ldp	x19, x20, [sp, #16]
 1137224:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1137228:	a94363f7 	ldp	x23, x24, [sp, #48]
 113722c:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1137230:	a94573fb 	ldp	x27, x28, [sp, #80]
 1137234:	a8d27bfd 	ldp	x29, x30, [sp], #288
 1137238:	d65f03c0 	ret
  for (x = 0; x < 16; x++) {
 113723c:	91000739 	add	x25, x25, #0x1
 1137240:	f100433f 	cmp	x25, #0x10
 1137244:	54fffbc1 	b.ne	11371bc <ltc_ecc_mul2add+0x118>  // b.any
  if ((err = mp_montgomery_setup(modulus, &mp)) != CRYPT_OK) {
 1137248:	f94037e0 	ldr	x0, [sp, #104]
 113724c:	910243e1 	add	x1, sp, #0x90
 1137250:	f941d419 	ldr	x25, [x0, #936]
 1137254:	aa1303e0 	mov	x0, x19
 1137258:	f9409b22 	ldr	x2, [x25, #304]
 113725c:	d63f0040 	blr	x2
 1137260:	2a0003e2 	mov	w2, w0
 1137264:	35001b80 	cbnz	w0, 11375d4 <ltc_ecc_mul2add+0x530>
  if ((err = mp_init(&mu)) != CRYPT_OK) {
 1137268:	f9400b21 	ldr	x1, [x25, #16]
 113726c:	910263e0 	add	x0, sp, #0x98
 1137270:	d63f0020 	blr	x1
 1137274:	2a0003e2 	mov	w2, w0
 1137278:	35001a00 	cbnz	w0, 11375b8 <ltc_ecc_mul2add+0x514>
  if ((err = mp_montgomery_normalization(mu, modulus)) != CRYPT_OK) {
 113727c:	f9404fe0 	ldr	x0, [sp, #152]
 1137280:	aa1303e1 	mov	x1, x19
 1137284:	f9409f22 	ldr	x2, [x25, #312]
 1137288:	d63f0040 	blr	x2
 113728c:	2a0003e2 	mov	w2, w0
 1137290:	35001860 	cbnz	w0, 113759c <ltc_ecc_mul2add+0x4f8>
  if ((err = mp_mulmod(A->x, mu, modulus, precomp[1]->x)) != CRYPT_OK)                                         { goto ERR_MU; }
 1137294:	f94057fc 	ldr	x28, [sp, #168]
 1137298:	aa1303e2 	mov	x2, x19
 113729c:	f9400360 	ldr	x0, [x27]
 11372a0:	f9400383 	ldr	x3, [x28]
 11372a4:	f9404fe1 	ldr	x1, [sp, #152]
 11372a8:	f9408f25 	ldr	x5, [x25, #280]
 11372ac:	d63f00a0 	blr	x5
 11372b0:	2a0003e2 	mov	w2, w0
 11372b4:	35001740 	cbnz	w0, 113759c <ltc_ecc_mul2add+0x4f8>
  if ((err = mp_mulmod(A->y, mu, modulus, precomp[1]->y)) != CRYPT_OK)                                         { goto ERR_MU; }
 11372b8:	f9400760 	ldr	x0, [x27, #8]
 11372bc:	aa1303e2 	mov	x2, x19
 11372c0:	f9400783 	ldr	x3, [x28, #8]
 11372c4:	f9404fe1 	ldr	x1, [sp, #152]
 11372c8:	f9408f25 	ldr	x5, [x25, #280]
 11372cc:	d63f00a0 	blr	x5
 11372d0:	2a0003e2 	mov	w2, w0
 11372d4:	35001640 	cbnz	w0, 113759c <ltc_ecc_mul2add+0x4f8>
  if ((err = mp_mulmod(A->z, mu, modulus, precomp[1]->z)) != CRYPT_OK)                                         { goto ERR_MU; }
 11372d8:	f9400b60 	ldr	x0, [x27, #16]
 11372dc:	aa1303e2 	mov	x2, x19
 11372e0:	f9400b83 	ldr	x3, [x28, #16]
 11372e4:	f9404fe1 	ldr	x1, [sp, #152]
 11372e8:	f9408f25 	ldr	x5, [x25, #280]
 11372ec:	d63f00a0 	blr	x5
 11372f0:	2a0003e2 	mov	w2, w0
 11372f4:	35001540 	cbnz	w0, 113759c <ltc_ecc_mul2add+0x4f8>
  if ((err = mp_mulmod(B->x, mu, modulus, precomp[1<<2]->x)) != CRYPT_OK)                                      { goto ERR_MU; }
 11372f8:	f94063fb 	ldr	x27, [sp, #192]
 11372fc:	aa1303e2 	mov	x2, x19
 1137300:	f9400340 	ldr	x0, [x26]
 1137304:	f9400363 	ldr	x3, [x27]
 1137308:	f9404fe1 	ldr	x1, [sp, #152]
 113730c:	f9408f25 	ldr	x5, [x25, #280]
 1137310:	d63f00a0 	blr	x5
 1137314:	2a0003e2 	mov	w2, w0
 1137318:	35001420 	cbnz	w0, 113759c <ltc_ecc_mul2add+0x4f8>
  if ((err = mp_mulmod(B->y, mu, modulus, precomp[1<<2]->y)) != CRYPT_OK)                                      { goto ERR_MU; }
 113731c:	f9400740 	ldr	x0, [x26, #8]
 1137320:	aa1303e2 	mov	x2, x19
 1137324:	f9400763 	ldr	x3, [x27, #8]
 1137328:	f9404fe1 	ldr	x1, [sp, #152]
 113732c:	f9408f24 	ldr	x4, [x25, #280]
 1137330:	d63f0080 	blr	x4
 1137334:	2a0003e2 	mov	w2, w0
 1137338:	35001320 	cbnz	w0, 113759c <ltc_ecc_mul2add+0x4f8>
  if ((err = mp_mulmod(B->z, mu, modulus, precomp[1<<2]->z)) != CRYPT_OK)                                      { goto ERR_MU; }
 113733c:	f94037e0 	ldr	x0, [sp, #104]
 1137340:	aa1303e2 	mov	x2, x19
 1137344:	f9400b63 	ldr	x3, [x27, #16]
 1137348:	f941d419 	ldr	x25, [x0, #936]
 113734c:	f9400b40 	ldr	x0, [x26, #16]
 1137350:	f9404fe1 	ldr	x1, [sp, #152]
 1137354:	f9408f24 	ldr	x4, [x25, #280]
 1137358:	d63f0080 	blr	x4
 113735c:	2a0003e2 	mov	w2, w0
 1137360:	350011e0 	cbnz	w0, 113759c <ltc_ecc_mul2add+0x4f8>
  if ((err = ltc_mp.ecc_ptdbl(precomp[1], precomp[2], ma, modulus, mp)) != CRYPT_OK)                           { goto ERR_MU; }
 1137364:	f9404be4 	ldr	x4, [sp, #144]
 1137368:	aa1503e2 	mov	x2, x21
 113736c:	f940bb25 	ldr	x5, [x25, #368]
 1137370:	aa1303e3 	mov	x3, x19
 1137374:	f9405bfa 	ldr	x26, [sp, #176]
 1137378:	aa1c03e0 	mov	x0, x28
 113737c:	aa1a03e1 	mov	x1, x26
 1137380:	d63f00a0 	blr	x5
 1137384:	2a0003e2 	mov	w2, w0
 1137388:	350010a0 	cbnz	w0, 113759c <ltc_ecc_mul2add+0x4f8>
  if ((err = ltc_mp.ecc_ptadd(precomp[1], precomp[2], precomp[3], ma, modulus, mp)) != CRYPT_OK)               { goto ERR_MU; }
 113738c:	f9404be5 	ldr	x5, [sp, #144]
 1137390:	aa1303e4 	mov	x4, x19
 1137394:	f9405fe2 	ldr	x2, [sp, #184]
 1137398:	aa1503e3 	mov	x3, x21
 113739c:	f940b727 	ldr	x7, [x25, #360]
 11373a0:	aa1a03e1 	mov	x1, x26
 11373a4:	aa1c03e0 	mov	x0, x28
 11373a8:	d63f00e0 	blr	x7
 11373ac:	2a0003e2 	mov	w2, w0
 11373b0:	35000f60 	cbnz	w0, 113759c <ltc_ecc_mul2add+0x4f8>
  if ((err = ltc_mp.ecc_ptdbl(precomp[1<<2], precomp[2<<2], ma, modulus, mp)) != CRYPT_OK)                     { goto ERR_MU; }
 11373b4:	f9404be4 	ldr	x4, [sp, #144]
 11373b8:	aa1503e2 	mov	x2, x21
 11373bc:	f940bb25 	ldr	x5, [x25, #368]
 11373c0:	aa1303e3 	mov	x3, x19
 11373c4:	f94073fa 	ldr	x26, [sp, #224]
 11373c8:	aa1b03e0 	mov	x0, x27
 11373cc:	aa1a03e1 	mov	x1, x26
 11373d0:	d63f00a0 	blr	x5
 11373d4:	2a0003e2 	mov	w2, w0
 11373d8:	35000e20 	cbnz	w0, 113759c <ltc_ecc_mul2add+0x4f8>
  if ((err = ltc_mp.ecc_ptadd(precomp[1<<2], precomp[2<<2], precomp[3<<2], ma, modulus, mp)) != CRYPT_OK)      { goto ERR_MU; }
 11373dc:	f9404be5 	ldr	x5, [sp, #144]
 11373e0:	aa1303e4 	mov	x4, x19
 11373e4:	f94083e2 	ldr	x2, [sp, #256]
 11373e8:	aa1503e3 	mov	x3, x21
 11373ec:	f940b727 	ldr	x7, [x25, #360]
 11373f0:	aa1a03e1 	mov	x1, x26
 11373f4:	aa1b03e0 	mov	x0, x27
 11373f8:	d63f00e0 	blr	x7
 11373fc:	2a0003e2 	mov	w2, w0
 1137400:	35000ce0 	cbnz	w0, 113759c <ltc_ecc_mul2add+0x4f8>
 1137404:	aa1803e7 	mov	x7, x24
        if ((err = ltc_mp.ecc_ptadd(precomp[x], precomp[(y<<2)], precomp[x+(y<<2)], ma, modulus, mp)) != CRYPT_OK) { goto ERR_MU; }
 1137408:	aa1903fa 	mov	x26, x25
  if ((err = ltc_mp.ecc_ptadd(precomp[1<<2], precomp[2<<2], precomp[3<<2], ma, modulus, mp)) != CRYPT_OK)      { goto ERR_MU; }
 113740c:	5280023b 	mov	w27, #0x11                  	// #17
     for (y = 1; y < 4; y++) {
 1137410:	5100337c 	sub	w28, w27, #0xc
 1137414:	aa1803e6 	mov	x6, x24
        if ((err = ltc_mp.ecc_ptadd(precomp[x], precomp[(y<<2)], precomp[x+(y<<2)], ma, modulus, mp)) != CRYPT_OK) { goto ERR_MU; }
 1137418:	f87c5b02 	ldr	x2, [x24, w28, uxtw #3]
 113741c:	aa1303e4 	mov	x4, x19
 1137420:	f94004e0 	ldr	x0, [x7, #8]
 1137424:	aa1503e3 	mov	x3, x21
 1137428:	f94010c1 	ldr	x1, [x6, #32]
 113742c:	a9071be7 	stp	x7, x6, [sp, #112]
 1137430:	f9404be5 	ldr	x5, [sp, #144]
 1137434:	f940b748 	ldr	x8, [x26, #360]
 1137438:	d63f0100 	blr	x8
 113743c:	35000ea0 	cbnz	w0, 1137610 <ltc_ecc_mul2add+0x56c>
     for (y = 1; y < 4; y++) {
 1137440:	a9471be7 	ldp	x7, x6, [sp, #112]
 1137444:	1100139c 	add	w28, w28, #0x4
 1137448:	6b1c037f 	cmp	w27, w28
 113744c:	910080c6 	add	x6, x6, #0x20
 1137450:	54fffe41 	b.ne	1137418 <ltc_ecc_mul2add+0x374>  // b.any
  for (x = 1; x < 4; x++) {
 1137454:	1100077b 	add	w27, w27, #0x1
 1137458:	910020e7 	add	x7, x7, #0x8
 113745c:	7100537f 	cmp	w27, #0x14
 1137460:	54fffd81 	b.ne	1137410 <ltc_ecc_mul2add+0x36c>  // b.any
  bitbufA = tA[0];
 1137464:	394002c0 	ldrb	w0, [x22]
  first   = 1;
 1137468:	52800027 	mov	w7, #0x1                   	// #1
  for (x = 0;; ) {
 113746c:	5280001a 	mov	w26, #0x0                   	// #0
  nibble  = 3;
 1137470:	5280007b 	mov	w27, #0x3                   	// #3
  bitbufA = tA[0];
 1137474:	2a0003f9 	mov	w25, w0
  bitbufB = tB[0];
 1137478:	394002e0 	ldrb	w0, [x23]
 113747c:	b90073e0 	str	w0, [sp, #112]
        if ((err = ltc_mp.ecc_ptdbl(C, C, ma, modulus, mp)) != CRYPT_OK)              { goto ERR_MU; }
 1137480:	f94037e0 	ldr	x0, [sp, #104]
 1137484:	f941d41c 	ldr	x28, [x0, #936]
     if (++nibble == 4) {
 1137488:	1100077b 	add	w27, w27, #0x1
 113748c:	7100137f 	cmp	w27, #0x4
 1137490:	54000141 	b.ne	11374b8 <ltc_ecc_mul2add+0x414>  // b.any
        if (x == len) break;
 1137494:	b94083e0 	ldr	w0, [sp, #128]
 1137498:	6b00035f 	cmp	w26, w0
 113749c:	54000b20 	b.eq	1137600 <ltc_ecc_mul2add+0x55c>  // b.none
        bitbufA = tA[x];
 11374a0:	387a4ac0 	ldrb	w0, [x22, w26, uxtw]
        nibble  = 0;
 11374a4:	5280001b 	mov	w27, #0x0                   	// #0
        bitbufA = tA[x];
 11374a8:	2a0003f9 	mov	w25, w0
        bitbufB = tB[x];
 11374ac:	387a4ae0 	ldrb	w0, [x23, w26, uxtw]
        ++x;
 11374b0:	1100075a 	add	w26, w26, #0x1
        bitbufB = tB[x];
 11374b4:	b90073e0 	str	w0, [sp, #112]
     nB = (bitbufB >> 6) & 0x03;
 11374b8:	b94073e0 	ldr	w0, [sp, #112]
     nA = (bitbufA >> 6) & 0x03;
 11374bc:	53067f25 	lsr	w5, w25, #6
     nB = (bitbufB >> 6) & 0x03;
 11374c0:	53067c06 	lsr	w6, w0, #6
     bitbufA = (bitbufA << 2) & 0xFF;
 11374c4:	531e1720 	ubfiz	w0, w25, #2, #6
 11374c8:	2a0003f9 	mov	w25, w0
     bitbufB = (bitbufB << 2) & 0xFF;
 11374cc:	b94073e0 	ldr	w0, [sp, #112]
 11374d0:	531e1400 	ubfiz	w0, w0, #2, #6
 11374d4:	b90073e0 	str	w0, [sp, #112]
     if ((nA == 0) && (nB == 0) && (first == 1)) {
 11374d8:	2a0600a0 	orr	w0, w5, w6
 11374dc:	b9007be0 	str	w0, [sp, #120]
 11374e0:	350004e0 	cbnz	w0, 113757c <ltc_ecc_mul2add+0x4d8>
 11374e4:	35fffd27 	cbnz	w7, 1137488 <ltc_ecc_mul2add+0x3e4>
        if ((err = ltc_mp.ecc_ptdbl(C, C, ma, modulus, mp)) != CRYPT_OK)              { goto ERR_MU; }
 11374e8:	f9404be4 	ldr	x4, [sp, #144]
 11374ec:	aa1503e2 	mov	x2, x21
 11374f0:	f940bb88 	ldr	x8, [x28, #368]
 11374f4:	aa1303e3 	mov	x3, x19
 11374f8:	aa1403e1 	mov	x1, x20
 11374fc:	aa1403e0 	mov	x0, x20
 1137500:	291097e7 	stp	w7, w5, [sp, #132]
 1137504:	b9008fe6 	str	w6, [sp, #140]
 1137508:	d63f0100 	blr	x8
 113750c:	2a0003e2 	mov	w2, w0
 1137510:	35000460 	cbnz	w0, 113759c <ltc_ecc_mul2add+0x4f8>
        if ((err = ltc_mp.ecc_ptdbl(C, C, ma, modulus, mp)) != CRYPT_OK)              { goto ERR_MU; }
 1137514:	f9404be4 	ldr	x4, [sp, #144]
 1137518:	aa1503e2 	mov	x2, x21
 113751c:	f940bb88 	ldr	x8, [x28, #368]
 1137520:	aa1303e3 	mov	x3, x19
 1137524:	aa1403e1 	mov	x1, x20
 1137528:	aa1403e0 	mov	x0, x20
 113752c:	d63f0100 	blr	x8
 1137530:	2a0003e2 	mov	w2, w0
 1137534:	35000340 	cbnz	w0, 113759c <ltc_ecc_mul2add+0x4f8>
     if ((nA != 0) || (nB != 0)) {
 1137538:	b9407be0 	ldr	w0, [sp, #120]
 113753c:	b94087e7 	ldr	w7, [sp, #132]
 1137540:	34fffa40 	cbz	w0, 1137488 <ltc_ecc_mul2add+0x3e4>
        if (first == 1) {
 1137544:	29511be5 	ldp	w5, w6, [sp, #136]
 1137548:	531e74c0 	lsl	w0, w6, #2
 113754c:	350001a7 	cbnz	w7, 1137580 <ltc_ecc_mul2add+0x4dc>
           if ((err = ltc_mp.ecc_ptadd(C, precomp[nA + (nB<<2)], C, ma, modulus, mp)) != CRYPT_OK) { goto ERR_MU; }
 1137550:	0b0000a5 	add	w5, w5, w0
 1137554:	aa1303e4 	mov	x4, x19
 1137558:	f940b786 	ldr	x6, [x28, #360]
 113755c:	d37d10a0 	ubfiz	x0, x5, #3, #5
 1137560:	f9404be5 	ldr	x5, [sp, #144]
 1137564:	aa1503e3 	mov	x3, x21
 1137568:	f8606b01 	ldr	x1, [x24, x0]
 113756c:	aa1403e2 	mov	x2, x20
 1137570:	aa1403e0 	mov	x0, x20
 1137574:	d63f00c0 	blr	x6
 1137578:	14000007 	b	1137594 <ltc_ecc_mul2add+0x4f0>
     if (first == 0) {
 113757c:	34fffb67 	cbz	w7, 11374e8 <ltc_ecc_mul2add+0x444>
           if ((err = ltc_ecc_copy_point(precomp[nA + (nB<<2)], C)) != CRYPT_OK)      { goto ERR_MU; }
 1137580:	0b0608a5 	add	w5, w5, w6, lsl #2
 1137584:	aa1403e1 	mov	x1, x20
 1137588:	d37d10a5 	ubfiz	x5, x5, #3, #5
 113758c:	f8656b00 	ldr	x0, [x24, x5]
 1137590:	9400006c 	bl	1137740 <ltc_ecc_copy_point>
           if ((err = ltc_mp.ecc_ptadd(C, precomp[nA + (nB<<2)], C, ma, modulus, mp)) != CRYPT_OK) { goto ERR_MU; }
 1137594:	2a0003e2 	mov	w2, w0
 1137598:	34000300 	cbz	w0, 11375f8 <ltc_ecc_mul2add+0x554>
   mp_clear(mu);
 113759c:	f94037e0 	ldr	x0, [sp, #104]
 11375a0:	b90073e2 	str	w2, [sp, #112]
 11375a4:	f941d400 	ldr	x0, [x0, #936]
 11375a8:	f9401401 	ldr	x1, [x0, #40]
 11375ac:	f9404fe0 	ldr	x0, [sp, #152]
 11375b0:	d63f0020 	blr	x1
 11375b4:	b94073e2 	ldr	w2, [sp, #112]
   mp_montgomery_free(mp);
 11375b8:	f94037e0 	ldr	x0, [sp, #104]
 11375bc:	b90073e2 	str	w2, [sp, #112]
 11375c0:	f941d419 	ldr	x25, [x0, #936]
 11375c4:	f9404be0 	ldr	x0, [sp, #144]
 11375c8:	f940a721 	ldr	x1, [x25, #328]
 11375cc:	d63f0020 	blr	x1
 11375d0:	b94073e2 	ldr	w2, [sp, #112]
ERR_P:
 11375d4:	d2800013 	mov	x19, #0x0                   	// #0
       ltc_ecc_del_point(precomp[x]);
 11375d8:	f8737b00 	ldr	x0, [x24, x19, lsl #3]
 11375dc:	91000673 	add	x19, x19, #0x1
 11375e0:	b9006be2 	str	w2, [sp, #104]
 11375e4:	9400002a 	bl	113768c <ltc_ecc_del_point>
   for (x = 0; x < 16; x++) {
 11375e8:	b9406be2 	ldr	w2, [sp, #104]
 11375ec:	f100427f 	cmp	x19, #0x10
 11375f0:	54ffff41 	b.ne	11375d8 <ltc_ecc_mul2add+0x534>  // b.any
 11375f4:	17fffefe 	b	11371ec <ltc_ecc_mul2add+0x148>
           first = 0;
 11375f8:	52800007 	mov	w7, #0x0                   	// #0
 11375fc:	17ffffa3 	b	1137488 <ltc_ecc_mul2add+0x3e4>
  err = ltc_ecc_map(C, modulus, mp);
 1137600:	f9404be2 	ldr	x2, [sp, #144]
 1137604:	aa1303e1 	mov	x1, x19
 1137608:	aa1403e0 	mov	x0, x20
 113760c:	97fffcee 	bl	11369c4 <ltc_ecc_map>
        if ((err = ltc_mp.ecc_ptadd(precomp[x], precomp[(y<<2)], precomp[x+(y<<2)], ma, modulus, mp)) != CRYPT_OK) { goto ERR_MU; }
 1137610:	2a0003e2 	mov	w2, w0
 1137614:	17ffffe2 	b	113759c <ltc_ecc_mul2add+0x4f8>
     err = CRYPT_INVALID_ARG;
 1137618:	52800202 	mov	w2, #0x10                  	// #16
 113761c:	17fffef4 	b	11371ec <ltc_ecc_mul2add+0x148>
  LTC_ARGCHK(A       != NULL);
 1137620:	52800202 	mov	w2, #0x10                  	// #16
}
 1137624:	2a0203e0 	mov	w0, w2
 1137628:	d65f03c0 	ret
  LTC_ARGCHK(A       != NULL);
 113762c:	52800202 	mov	w2, #0x10                  	// #16
 1137630:	17fffefb 	b	113721c <ltc_ecc_mul2add+0x178>

0000000001137634 <ltc_ecc_new_point>:
/**
   Allocate a new ECC point
   @return A newly allocated point or NULL on error
*/
ecc_point *ltc_ecc_new_point(void)
{
 1137634:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   ecc_point *p;
   p = XCALLOC(1, sizeof(*p));
 1137638:	d2800301 	mov	x1, #0x18                  	// #24
 113763c:	d2800020 	mov	x0, #0x1                   	// #1
{
 1137640:	910003fd 	mov	x29, sp
 1137644:	f9000bf3 	str	x19, [sp, #16]
   p = XCALLOC(1, sizeof(*p));
 1137648:	94002fa2 	bl	11434d0 <calloc>
 113764c:	aa0003f3 	mov	x19, x0
   if (p == NULL) {
 1137650:	b4000160 	cbz	x0, 113767c <ltc_ecc_new_point+0x48>
      return NULL;
   }
   if (mp_init_multi_size(LTC_MAX_ECC * 2,
 1137654:	91004003 	add	x3, x0, #0x10
 1137658:	91002002 	add	x2, x0, #0x8
 113765c:	aa0003e1 	mov	x1, x0
 1137660:	d2800004 	mov	x4, #0x0                   	// #0
 1137664:	52808240 	mov	w0, #0x412                 	// #1042
 1137668:	97ffea5f 	bl	1131fe4 <ltc_init_multi_size>
 113766c:	34000080 	cbz	w0, 113767c <ltc_ecc_new_point+0x48>
			  &p->x, &p->y, &p->z, NULL) != CRYPT_OK) {
      XFREE(p);
 1137670:	aa1303e0 	mov	x0, x19
      return NULL;
 1137674:	d2800013 	mov	x19, #0x0                   	// #0
      XFREE(p);
 1137678:	94002fda 	bl	11435e0 <free>
   }
   return p;
}
 113767c:	aa1303e0 	mov	x0, x19
 1137680:	f9400bf3 	ldr	x19, [sp, #16]
 1137684:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1137688:	d65f03c0 	ret

000000000113768c <ltc_ecc_del_point>:
  @param p   The point to free
*/
void ltc_ecc_del_point(ecc_point *p)
{
   /* prevents free'ing null arguments */
   if (p != NULL) {
 113768c:	b40001a0 	cbz	x0, 11376c0 <ltc_ecc_del_point+0x34>
{
 1137690:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
      mp_clear_multi(p->x, p->y, p->z, NULL); /* note: p->z may be NULL but that's ok with this function anyways */
 1137694:	d2800003 	mov	x3, #0x0                   	// #0
{
 1137698:	910003fd 	mov	x29, sp
 113769c:	f9000bf3 	str	x19, [sp, #16]
 11376a0:	aa0003f3 	mov	x19, x0
      mp_clear_multi(p->x, p->y, p->z, NULL); /* note: p->z may be NULL but that's ok with this function anyways */
 11376a4:	a9400400 	ldp	x0, x1, [x0]
 11376a8:	f9400a62 	ldr	x2, [x19, #16]
 11376ac:	97ffea9c 	bl	113211c <ltc_deinit_multi>
      XFREE(p);
 11376b0:	aa1303e0 	mov	x0, x19
   }
}
 11376b4:	f9400bf3 	ldr	x19, [sp, #16]
 11376b8:	a8c27bfd 	ldp	x29, x30, [sp], #32
      XFREE(p);
 11376bc:	14002fc9 	b	11435e0 <free>
 11376c0:	d65f03c0 	ret

00000000011376c4 <ltc_ecc_set_point_xyz>:

int ltc_ecc_set_point_xyz(ltc_mp_digit x, ltc_mp_digit y, ltc_mp_digit z, ecc_point *p)
{
 11376c4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 11376c8:	910003fd 	mov	x29, sp
 11376cc:	a90153f3 	stp	x19, x20, [sp, #16]
   int err;
   if ((err = ltc_mp.set_int(p->x, x)) != CRYPT_OK) return err;
 11376d0:	f0000114 	adrp	x20, 115a000 <__scattered_array_1phys_mem_map+0x8>
{
 11376d4:	aa0303f3 	mov	x19, x3
   if ((err = ltc_mp.set_int(p->x, x)) != CRYPT_OK) return err;
 11376d8:	f941d694 	ldr	x20, [x20, #936]
{
 11376dc:	a9025bf5 	stp	x21, x22, [sp, #32]
 11376e0:	aa0103f6 	mov	x22, x1
 11376e4:	aa0203f5 	mov	x21, x2
   if ((err = ltc_mp.set_int(p->x, x)) != CRYPT_OK) return err;
 11376e8:	aa0003e1 	mov	x1, x0
 11376ec:	f9400060 	ldr	x0, [x3]
 11376f0:	f9402282 	ldr	x2, [x20, #64]
 11376f4:	d63f0040 	blr	x2
 11376f8:	350001c0 	cbnz	w0, 1137730 <ltc_ecc_set_point_xyz+0x6c>
   if ((err = ltc_mp.set_int(p->y, y)) != CRYPT_OK) return err;
 11376fc:	f9400660 	ldr	x0, [x19, #8]
 1137700:	aa1603e1 	mov	x1, x22
 1137704:	f9402282 	ldr	x2, [x20, #64]
 1137708:	d63f0040 	blr	x2
 113770c:	35000120 	cbnz	w0, 1137730 <ltc_ecc_set_point_xyz+0x6c>
   if ((err = ltc_mp.set_int(p->z, z)) != CRYPT_OK) return err;
 1137710:	aa1503e1 	mov	x1, x21
 1137714:	f9400a60 	ldr	x0, [x19, #16]
   return CRYPT_OK;
}
 1137718:	a9425bf5 	ldp	x21, x22, [sp, #32]
   if ((err = ltc_mp.set_int(p->z, z)) != CRYPT_OK) return err;
 113771c:	f9402282 	ldr	x2, [x20, #64]
}
 1137720:	a94153f3 	ldp	x19, x20, [sp, #16]
   if ((err = ltc_mp.set_int(p->z, z)) != CRYPT_OK) return err;
 1137724:	aa0203f0 	mov	x16, x2
}
 1137728:	a8c37bfd 	ldp	x29, x30, [sp], #48
   if ((err = ltc_mp.set_int(p->z, z)) != CRYPT_OK) return err;
 113772c:	d61f0200 	br	x16
}
 1137730:	a94153f3 	ldp	x19, x20, [sp, #16]
 1137734:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1137738:	a8c37bfd 	ldp	x29, x30, [sp], #48
 113773c:	d65f03c0 	ret

0000000001137740 <ltc_ecc_copy_point>:

int ltc_ecc_copy_point(const ecc_point *src, ecc_point *dst)
{
 1137740:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1137744:	910003fd 	mov	x29, sp
 1137748:	a90153f3 	stp	x19, x20, [sp, #16]
 113774c:	aa0003f3 	mov	x19, x0
 1137750:	aa0103f4 	mov	x20, x1
   int err;
   if ((err = ltc_mp.copy(src->x, dst->x)) != CRYPT_OK) return err;
 1137754:	f9400000 	ldr	x0, [x0]
 1137758:	f9400021 	ldr	x1, [x1]
{
 113775c:	f90013f5 	str	x21, [sp, #32]
   if ((err = ltc_mp.copy(src->x, dst->x)) != CRYPT_OK) return err;
 1137760:	f0000115 	adrp	x21, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1137764:	f941d6b5 	ldr	x21, [x21, #936]
 1137768:	f9401ea2 	ldr	x2, [x21, #56]
 113776c:	d63f0040 	blr	x2
 1137770:	350001c0 	cbnz	w0, 11377a8 <ltc_ecc_copy_point+0x68>
   if ((err = ltc_mp.copy(src->y, dst->y)) != CRYPT_OK) return err;
 1137774:	f9400660 	ldr	x0, [x19, #8]
 1137778:	f9400681 	ldr	x1, [x20, #8]
 113777c:	f9401ea2 	ldr	x2, [x21, #56]
 1137780:	d63f0040 	blr	x2
 1137784:	35000120 	cbnz	w0, 11377a8 <ltc_ecc_copy_point+0x68>
   if ((err = ltc_mp.copy(src->z, dst->z)) != CRYPT_OK) return err;
 1137788:	f9400a60 	ldr	x0, [x19, #16]
 113778c:	f9400a81 	ldr	x1, [x20, #16]
   return CRYPT_OK;
}
 1137790:	a94153f3 	ldp	x19, x20, [sp, #16]
   if ((err = ltc_mp.copy(src->z, dst->z)) != CRYPT_OK) return err;
 1137794:	f9401ea2 	ldr	x2, [x21, #56]
}
 1137798:	f94013f5 	ldr	x21, [sp, #32]
   if ((err = ltc_mp.copy(src->z, dst->z)) != CRYPT_OK) return err;
 113779c:	aa0203f0 	mov	x16, x2
}
 11377a0:	a8c37bfd 	ldp	x29, x30, [sp], #48
   if ((err = ltc_mp.copy(src->z, dst->z)) != CRYPT_OK) return err;
 11377a4:	d61f0200 	br	x16
}
 11377a8:	a94153f3 	ldp	x19, x20, [sp, #16]
 11377ac:	f94013f5 	ldr	x21, [sp, #32]
 11377b0:	a8c37bfd 	ldp	x29, x30, [sp], #48
 11377b4:	d65f03c0 	ret

00000000011377b8 <ltc_ecc_projective_add_point>:
   @param modulus  The modulus of the field the ECC curve is in
   @param mp       The "b" value from montgomery_setup()
   @return CRYPT_OK on success
*/
int ltc_ecc_projective_add_point(const ecc_point *P, const ecc_point *Q, ecc_point *R, void *ma, void *modulus, void *mp)
{
 11377b8:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
 11377bc:	910003fd 	mov	x29, sp
 11377c0:	a90153f3 	stp	x19, x20, [sp, #16]
 11377c4:	a9025bf5 	stp	x21, x22, [sp, #32]
 11377c8:	a90363f7 	stp	x23, x24, [sp, #48]
 11377cc:	a9046bf9 	stp	x25, x26, [sp, #64]
 11377d0:	a90573fb 	stp	x27, x28, [sp, #80]
   void  *t1, *t2, *x, *y, *z;
   int    err, inf;

   LTC_ARGCHK(P       != NULL);
 11377d4:	b4004c40 	cbz	x0, 113815c <ltc_ecc_projective_add_point+0x9a4>
 11377d8:	aa0103f8 	mov	x24, x1
   LTC_ARGCHK(Q       != NULL);
 11377dc:	b4004c01 	cbz	x1, 113815c <ltc_ecc_projective_add_point+0x9a4>
 11377e0:	aa0203fa 	mov	x26, x2
   LTC_ARGCHK(R       != NULL);
 11377e4:	b4004bc2 	cbz	x2, 113815c <ltc_ecc_projective_add_point+0x9a4>
 11377e8:	aa0403f4 	mov	x20, x4
   LTC_ARGCHK(modulus != NULL);
 11377ec:	b4004b84 	cbz	x4, 113815c <ltc_ecc_projective_add_point+0x9a4>
 11377f0:	aa0503f7 	mov	x23, x5
   LTC_ARGCHK(mp      != NULL);
 11377f4:	b4004b45 	cbz	x5, 113815c <ltc_ecc_projective_add_point+0x9a4>
 11377f8:	aa0003f9 	mov	x25, x0
 11377fc:	aa0303fc 	mov	x28, x3

   if ((err = mp_init_multi(&t1, &t2, &x, &y, &z, NULL)) != CRYPT_OK) {
 1137800:	910223e4 	add	x4, sp, #0x88
 1137804:	910203e3 	add	x3, sp, #0x80
 1137808:	9101e3e2 	add	x2, sp, #0x78
 113780c:	9101c3e1 	add	x1, sp, #0x70
 1137810:	9101a3e0 	add	x0, sp, #0x68
 1137814:	d2800005 	mov	x5, #0x0                   	// #0
 1137818:	97ffe9a7 	bl	1131eb4 <ltc_init_multi>
 113781c:	2a0003f3 	mov	w19, w0
 1137820:	35000700 	cbnz	w0, 1137900 <ltc_ecc_projective_add_point+0x148>
      return err;
   }

   if ((err = ltc_ecc_is_point_at_infinity(P, modulus, &inf)) != CRYPT_OK) return err;
 1137824:	910193f5 	add	x21, sp, #0x64
 1137828:	aa1403e1 	mov	x1, x20
 113782c:	aa1503e2 	mov	x2, x21
 1137830:	aa1903e0 	mov	x0, x25
 1137834:	97fffc12 	bl	113687c <ltc_ecc_is_point_at_infinity>
 1137838:	2a0003f3 	mov	w19, w0
 113783c:	35000620 	cbnz	w0, 1137900 <ltc_ecc_projective_add_point+0x148>
   if (inf) {
 1137840:	b94067e0 	ldr	w0, [sp, #100]
 1137844:	340000c0 	cbz	w0, 113785c <ltc_ecc_projective_add_point+0xa4>
      /* P is point at infinity >> Result = Q */
      err = ltc_ecc_copy_point(Q, R);
 1137848:	aa1a03e1 	mov	x1, x26
 113784c:	aa1803e0 	mov	x0, x24
   }

   if ((err = ltc_ecc_is_point_at_infinity(Q, modulus, &inf)) != CRYPT_OK) return err;
   if (inf) {
      /* Q is point at infinity >> Result = P */
      err = ltc_ecc_copy_point(P, R);
 1137850:	97ffffbc 	bl	1137740 <ltc_ecc_copy_point>
   }
   if ((err = mp_div_2(y, y)) != CRYPT_OK)                                     { goto done; }

   if ((err = mp_copy(x, R->x)) != CRYPT_OK)                                   { goto done; }
   if ((err = mp_copy(y, R->y)) != CRYPT_OK)                                   { goto done; }
   if ((err = mp_copy(z, R->z)) != CRYPT_OK)                                   { goto done; }
 1137854:	2a0003f3 	mov	w19, w0
 1137858:	14000060 	b	11379d8 <ltc_ecc_projective_add_point+0x220>
   if ((err = ltc_ecc_is_point_at_infinity(Q, modulus, &inf)) != CRYPT_OK) return err;
 113785c:	aa1503e2 	mov	x2, x21
 1137860:	aa1403e1 	mov	x1, x20
 1137864:	aa1803e0 	mov	x0, x24
 1137868:	97fffc05 	bl	113687c <ltc_ecc_is_point_at_infinity>
 113786c:	2a0003f3 	mov	w19, w0
 1137870:	35000480 	cbnz	w0, 1137900 <ltc_ecc_projective_add_point+0x148>
   if (inf) {
 1137874:	b94067e0 	ldr	w0, [sp, #100]
 1137878:	34000080 	cbz	w0, 1137888 <ltc_ecc_projective_add_point+0xd0>
      err = ltc_ecc_copy_point(P, R);
 113787c:	aa1a03e1 	mov	x1, x26
 1137880:	aa1903e0 	mov	x0, x25
 1137884:	17fffff3 	b	1137850 <ltc_ecc_projective_add_point+0x98>
   if ((mp_cmp(P->x, Q->x) == LTC_MP_EQ) && (mp_cmp(P->z, Q->z) == LTC_MP_EQ)) {
 1137888:	f0000116 	adrp	x22, 115a000 <__scattered_array_1phys_mem_map+0x8>
 113788c:	aa1603f5 	mov	x21, x22
 1137890:	f9400301 	ldr	x1, [x24]
 1137894:	f941d6db 	ldr	x27, [x22, #936]
 1137898:	f9400320 	ldr	x0, [x25]
 113789c:	f9403362 	ldr	x2, [x27, #96]
 11378a0:	d63f0040 	blr	x2
 11378a4:	35000620 	cbnz	w0, 1137968 <ltc_ecc_projective_add_point+0x1b0>
 11378a8:	f9400b01 	ldr	x1, [x24, #16]
 11378ac:	f9400b20 	ldr	x0, [x25, #16]
 11378b0:	f9403362 	ldr	x2, [x27, #96]
 11378b4:	d63f0040 	blr	x2
 11378b8:	35000580 	cbnz	w0, 1137968 <ltc_ecc_projective_add_point+0x1b0>
      if (mp_cmp(P->y, Q->y) == LTC_MP_EQ) {
 11378bc:	f9400701 	ldr	x1, [x24, #8]
 11378c0:	f9400720 	ldr	x0, [x25, #8]
 11378c4:	f9403362 	ldr	x2, [x27, #96]
 11378c8:	d63f0040 	blr	x2
 11378cc:	350002a0 	cbnz	w0, 1137920 <ltc_ecc_projective_add_point+0x168>
         mp_clear_multi(t1, t2, x, y, z, NULL);
 11378d0:	a94687e0 	ldp	x0, x1, [sp, #104]
 11378d4:	d2800005 	mov	x5, #0x0                   	// #0
 11378d8:	a9478fe2 	ldp	x2, x3, [sp, #120]
 11378dc:	f94047e4 	ldr	x4, [sp, #136]
 11378e0:	97ffea0f 	bl	113211c <ltc_deinit_multi>
         return ltc_ecc_projective_dbl_point(P, R, ma, modulus, mp);
 11378e4:	aa1703e4 	mov	x4, x23
 11378e8:	aa1403e3 	mov	x3, x20
 11378ec:	aa1c03e2 	mov	x2, x28
 11378f0:	aa1a03e1 	mov	x1, x26
 11378f4:	aa1903e0 	mov	x0, x25
 11378f8:	9400021b 	bl	1138164 <ltc_ecc_projective_dbl_point>
 11378fc:	2a0003f3 	mov	w19, w0

   err = CRYPT_OK;
done:
   mp_clear_multi(t1, t2, x, y, z, NULL);
   return err;
}
 1137900:	2a1303e0 	mov	w0, w19
 1137904:	a94153f3 	ldp	x19, x20, [sp, #16]
 1137908:	a9425bf5 	ldp	x21, x22, [sp, #32]
 113790c:	a94363f7 	ldp	x23, x24, [sp, #48]
 1137910:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1137914:	a94573fb 	ldp	x27, x28, [sp, #80]
 1137918:	a8c97bfd 	ldp	x29, x30, [sp], #144
 113791c:	d65f03c0 	ret
      if ((err = mp_sub(modulus, Q->y, t1)) != CRYPT_OK)                       { goto done; }
 1137920:	f9400701 	ldr	x1, [x24, #8]
 1137924:	aa1403e0 	mov	x0, x20
 1137928:	f94037e2 	ldr	x2, [sp, #104]
 113792c:	f9406363 	ldr	x3, [x27, #192]
 1137930:	d63f0060 	blr	x3
 1137934:	2a0003f3 	mov	w19, w0
 1137938:	35000500 	cbnz	w0, 11379d8 <ltc_ecc_projective_add_point+0x220>
      if (mp_cmp(P->y, t1) == LTC_MP_EQ) {
 113793c:	f9400720 	ldr	x0, [x25, #8]
 1137940:	f9403362 	ldr	x2, [x27, #96]
 1137944:	f94037e1 	ldr	x1, [sp, #104]
 1137948:	d63f0040 	blr	x2
 113794c:	350000e0 	cbnz	w0, 1137968 <ltc_ecc_projective_add_point+0x1b0>
         err = ltc_ecc_set_point_xyz(1, 1, 0, R);
 1137950:	d2800021 	mov	x1, #0x1                   	// #1
 1137954:	aa1a03e3 	mov	x3, x26
 1137958:	aa0103e0 	mov	x0, x1
 113795c:	d2800002 	mov	x2, #0x0                   	// #0
 1137960:	97ffff59 	bl	11376c4 <ltc_ecc_set_point_xyz>
 1137964:	17ffffbc 	b	1137854 <ltc_ecc_projective_add_point+0x9c>
   if ((err = mp_copy(P->x, x)) != CRYPT_OK)                                   { goto done; }
 1137968:	f941d6b6 	ldr	x22, [x21, #936]
 113796c:	f9400320 	ldr	x0, [x25]
 1137970:	f9401ec2 	ldr	x2, [x22, #56]
 1137974:	f9403fe1 	ldr	x1, [sp, #120]
 1137978:	d63f0040 	blr	x2
 113797c:	2a0003f3 	mov	w19, w0
 1137980:	350002c0 	cbnz	w0, 11379d8 <ltc_ecc_projective_add_point+0x220>
   if ((err = mp_copy(P->y, y)) != CRYPT_OK)                                   { goto done; }
 1137984:	f9400720 	ldr	x0, [x25, #8]
 1137988:	f9401ec2 	ldr	x2, [x22, #56]
 113798c:	f94043e1 	ldr	x1, [sp, #128]
 1137990:	d63f0040 	blr	x2
 1137994:	2a0003f3 	mov	w19, w0
 1137998:	35000200 	cbnz	w0, 11379d8 <ltc_ecc_projective_add_point+0x220>
   if ((err = mp_copy(P->z, z)) != CRYPT_OK)                                   { goto done; }
 113799c:	f9400b20 	ldr	x0, [x25, #16]
 11379a0:	f9401ec2 	ldr	x2, [x22, #56]
 11379a4:	f94047e1 	ldr	x1, [sp, #136]
 11379a8:	d63f0040 	blr	x2
 11379ac:	2a0003f3 	mov	w19, w0
 11379b0:	35000140 	cbnz	w0, 11379d8 <ltc_ecc_projective_add_point+0x220>
   if (Q->z != NULL) {
 11379b4:	f9400b00 	ldr	x0, [x24, #16]
 11379b8:	b50001c0 	cbnz	x0, 11379f0 <ltc_ecc_projective_add_point+0x238>
   if ((err = mp_sqr(z, t1)) != CRYPT_OK)                                      { goto done; }
 11379bc:	f941d6b6 	ldr	x22, [x21, #936]
 11379c0:	f94037e1 	ldr	x1, [sp, #104]
 11379c4:	f94047e0 	ldr	x0, [sp, #136]
 11379c8:	f94072c2 	ldr	x2, [x22, #224]
 11379cc:	d63f0040 	blr	x2
 11379d0:	2a0003f3 	mov	w19, w0
 11379d4:	340007e0 	cbz	w0, 1137ad0 <ltc_ecc_projective_add_point+0x318>
   mp_clear_multi(t1, t2, x, y, z, NULL);
 11379d8:	a94687e0 	ldp	x0, x1, [sp, #104]
 11379dc:	d2800005 	mov	x5, #0x0                   	// #0
 11379e0:	a9478fe2 	ldp	x2, x3, [sp, #120]
 11379e4:	f94047e4 	ldr	x4, [sp, #136]
 11379e8:	97ffe9cd 	bl	113211c <ltc_deinit_multi>
   return err;
 11379ec:	17ffffc5 	b	1137900 <ltc_ecc_projective_add_point+0x148>
      if ((err = mp_sqr(Q->z, t1)) != CRYPT_OK)                                { goto done; }
 11379f0:	f94037e1 	ldr	x1, [sp, #104]
 11379f4:	f94072c2 	ldr	x2, [x22, #224]
 11379f8:	d63f0040 	blr	x2
 11379fc:	2a0003f3 	mov	w19, w0
 1137a00:	35fffec0 	cbnz	w0, 11379d8 <ltc_ecc_projective_add_point+0x220>
      if ((err = mp_montgomery_reduce(t1, modulus, mp)) != CRYPT_OK)           { goto done; }
 1137a04:	f94037e0 	ldr	x0, [sp, #104]
 1137a08:	aa1703e2 	mov	x2, x23
 1137a0c:	f940a2c3 	ldr	x3, [x22, #320]
 1137a10:	aa1403e1 	mov	x1, x20
 1137a14:	d63f0060 	blr	x3
 1137a18:	2a0003f3 	mov	w19, w0
 1137a1c:	35fffde0 	cbnz	w0, 11379d8 <ltc_ecc_projective_add_point+0x220>
      if ((err = mp_mul(t1, x, x)) != CRYPT_OK)                                { goto done; }
 1137a20:	f94037e0 	ldr	x0, [sp, #104]
 1137a24:	f9403fe2 	ldr	x2, [sp, #120]
 1137a28:	f9406ac3 	ldr	x3, [x22, #208]
 1137a2c:	aa0203e1 	mov	x1, x2
 1137a30:	d63f0060 	blr	x3
 1137a34:	2a0003f3 	mov	w19, w0
 1137a38:	35fffd00 	cbnz	w0, 11379d8 <ltc_ecc_projective_add_point+0x220>
      if ((err = mp_montgomery_reduce(x, modulus, mp)) != CRYPT_OK)            { goto done; }
 1137a3c:	f9403fe0 	ldr	x0, [sp, #120]
 1137a40:	aa1703e2 	mov	x2, x23
 1137a44:	f940a2c3 	ldr	x3, [x22, #320]
 1137a48:	aa1403e1 	mov	x1, x20
 1137a4c:	d63f0060 	blr	x3
 1137a50:	2a0003f3 	mov	w19, w0
 1137a54:	35fffc20 	cbnz	w0, 11379d8 <ltc_ecc_projective_add_point+0x220>
      if ((err = mp_mul(Q->z, t1, t1)) != CRYPT_OK)                            { goto done; }
 1137a58:	f9400b00 	ldr	x0, [x24, #16]
 1137a5c:	f94037e2 	ldr	x2, [sp, #104]
 1137a60:	f9406ac3 	ldr	x3, [x22, #208]
 1137a64:	aa0203e1 	mov	x1, x2
 1137a68:	d63f0060 	blr	x3
 1137a6c:	2a0003f3 	mov	w19, w0
 1137a70:	35fffb40 	cbnz	w0, 11379d8 <ltc_ecc_projective_add_point+0x220>
      if ((err = mp_montgomery_reduce(t1, modulus, mp)) != CRYPT_OK)           { goto done; }
 1137a74:	f94037e0 	ldr	x0, [sp, #104]
 1137a78:	aa1703e2 	mov	x2, x23
 1137a7c:	f940a2c3 	ldr	x3, [x22, #320]
 1137a80:	aa1403e1 	mov	x1, x20
 1137a84:	d63f0060 	blr	x3
 1137a88:	2a0003f3 	mov	w19, w0
 1137a8c:	35fffa60 	cbnz	w0, 11379d8 <ltc_ecc_projective_add_point+0x220>
      if ((err = mp_mul(t1, y, y)) != CRYPT_OK)                                { goto done; }
 1137a90:	f941d6b6 	ldr	x22, [x21, #936]
 1137a94:	f94037e0 	ldr	x0, [sp, #104]
 1137a98:	f94043e2 	ldr	x2, [sp, #128]
 1137a9c:	f9406ac3 	ldr	x3, [x22, #208]
 1137aa0:	aa0203e1 	mov	x1, x2
 1137aa4:	d63f0060 	blr	x3
 1137aa8:	2a0003f3 	mov	w19, w0
 1137aac:	35fff960 	cbnz	w0, 11379d8 <ltc_ecc_projective_add_point+0x220>
      if ((err = mp_montgomery_reduce(y, modulus, mp)) != CRYPT_OK)            { goto done; }
 1137ab0:	f94043e0 	ldr	x0, [sp, #128]
 1137ab4:	aa1703e2 	mov	x2, x23
 1137ab8:	f940a2c3 	ldr	x3, [x22, #320]
 1137abc:	aa1403e1 	mov	x1, x20
 1137ac0:	d63f0060 	blr	x3
 1137ac4:	2a0003f3 	mov	w19, w0
 1137ac8:	34fff7a0 	cbz	w0, 11379bc <ltc_ecc_projective_add_point+0x204>
 1137acc:	17ffffc3 	b	11379d8 <ltc_ecc_projective_add_point+0x220>
   if ((err = mp_montgomery_reduce(t1, modulus, mp)) != CRYPT_OK)              { goto done; }
 1137ad0:	f94037e0 	ldr	x0, [sp, #104]
 1137ad4:	aa1703e2 	mov	x2, x23
 1137ad8:	f940a2c3 	ldr	x3, [x22, #320]
 1137adc:	aa1403e1 	mov	x1, x20
 1137ae0:	d63f0060 	blr	x3
 1137ae4:	2a0003f3 	mov	w19, w0
 1137ae8:	35fff780 	cbnz	w0, 11379d8 <ltc_ecc_projective_add_point+0x220>
   if ((err = mp_mul(Q->x, t1, t2)) != CRYPT_OK)                               { goto done; }
 1137aec:	a9468be1 	ldp	x1, x2, [sp, #104]
 1137af0:	f9400300 	ldr	x0, [x24]
 1137af4:	f9406ac3 	ldr	x3, [x22, #208]
 1137af8:	d63f0060 	blr	x3
 1137afc:	2a0003f3 	mov	w19, w0
 1137b00:	35fff6c0 	cbnz	w0, 11379d8 <ltc_ecc_projective_add_point+0x220>
   if ((err = mp_montgomery_reduce(t2, modulus, mp)) != CRYPT_OK)              { goto done; }
 1137b04:	f9403be0 	ldr	x0, [sp, #112]
 1137b08:	aa1703e2 	mov	x2, x23
 1137b0c:	f940a2c3 	ldr	x3, [x22, #320]
 1137b10:	aa1403e1 	mov	x1, x20
 1137b14:	d63f0060 	blr	x3
 1137b18:	2a0003f3 	mov	w19, w0
 1137b1c:	35fff5e0 	cbnz	w0, 11379d8 <ltc_ecc_projective_add_point+0x220>
   if ((err = mp_mul(z, t1, t1)) != CRYPT_OK)                                  { goto done; }
 1137b20:	f94037e2 	ldr	x2, [sp, #104]
 1137b24:	f94047e0 	ldr	x0, [sp, #136]
 1137b28:	aa0203e1 	mov	x1, x2
 1137b2c:	f9406ac3 	ldr	x3, [x22, #208]
 1137b30:	d63f0060 	blr	x3
 1137b34:	2a0003f3 	mov	w19, w0
 1137b38:	35fff500 	cbnz	w0, 11379d8 <ltc_ecc_projective_add_point+0x220>
   if ((err = mp_montgomery_reduce(t1, modulus, mp)) != CRYPT_OK)              { goto done; }
 1137b3c:	f94037e0 	ldr	x0, [sp, #104]
 1137b40:	aa1703e2 	mov	x2, x23
 1137b44:	f940a2c3 	ldr	x3, [x22, #320]
 1137b48:	aa1403e1 	mov	x1, x20
 1137b4c:	d63f0060 	blr	x3
 1137b50:	2a0003f3 	mov	w19, w0
 1137b54:	35fff420 	cbnz	w0, 11379d8 <ltc_ecc_projective_add_point+0x220>
   if ((err = mp_mul(Q->y, t1, t1)) != CRYPT_OK)                               { goto done; }
 1137b58:	f9400700 	ldr	x0, [x24, #8]
 1137b5c:	f94037e2 	ldr	x2, [sp, #104]
 1137b60:	f9406ac3 	ldr	x3, [x22, #208]
 1137b64:	aa0203e1 	mov	x1, x2
 1137b68:	d63f0060 	blr	x3
 1137b6c:	2a0003f3 	mov	w19, w0
 1137b70:	35fff340 	cbnz	w0, 11379d8 <ltc_ecc_projective_add_point+0x220>
   if ((err = mp_montgomery_reduce(t1, modulus, mp)) != CRYPT_OK)              { goto done; }
 1137b74:	f94037e0 	ldr	x0, [sp, #104]
 1137b78:	aa1703e2 	mov	x2, x23
 1137b7c:	f940a2c3 	ldr	x3, [x22, #320]
 1137b80:	aa1403e1 	mov	x1, x20
 1137b84:	d63f0060 	blr	x3
 1137b88:	2a0003f3 	mov	w19, w0
 1137b8c:	35fff260 	cbnz	w0, 11379d8 <ltc_ecc_projective_add_point+0x220>
   if ((err = mp_sub(y, t1, y)) != CRYPT_OK)                                   { goto done; }
 1137b90:	f94037e1 	ldr	x1, [sp, #104]
 1137b94:	f94043e2 	ldr	x2, [sp, #128]
 1137b98:	f94062c3 	ldr	x3, [x22, #192]
 1137b9c:	aa0203e0 	mov	x0, x2
 1137ba0:	d63f0060 	blr	x3
 1137ba4:	2a0003f3 	mov	w19, w0
 1137ba8:	35fff180 	cbnz	w0, 11379d8 <ltc_ecc_projective_add_point+0x220>
   if (mp_cmp_d(y, 0) == LTC_MP_LT) {
 1137bac:	f94036c2 	ldr	x2, [x22, #104]
 1137bb0:	d2800001 	mov	x1, #0x0                   	// #0
 1137bb4:	f94043e0 	ldr	x0, [sp, #128]
 1137bb8:	d63f0040 	blr	x2
 1137bbc:	3100041f 	cmn	w0, #0x1
 1137bc0:	54001f40 	b.eq	1137fa8 <ltc_ecc_projective_add_point+0x7f0>  // b.none
   if ((err = mp_add(t1, t1, t1)) != CRYPT_OK)                                 { goto done; }
 1137bc4:	f941d6b6 	ldr	x22, [x21, #936]
 1137bc8:	f94037e2 	ldr	x2, [sp, #104]
 1137bcc:	f9405ac3 	ldr	x3, [x22, #176]
 1137bd0:	aa0203e1 	mov	x1, x2
 1137bd4:	aa0203e0 	mov	x0, x2
 1137bd8:	d63f0060 	blr	x3
 1137bdc:	2a0003f3 	mov	w19, w0
 1137be0:	35ffefc0 	cbnz	w0, 11379d8 <ltc_ecc_projective_add_point+0x220>
   if (mp_cmp(t1, modulus) != LTC_MP_LT) {
 1137be4:	f94032c2 	ldr	x2, [x22, #96]
 1137be8:	aa1403e1 	mov	x1, x20
 1137bec:	f94037e0 	ldr	x0, [sp, #104]
 1137bf0:	d63f0040 	blr	x2
 1137bf4:	3100041f 	cmn	w0, #0x1
 1137bf8:	54001ea1 	b.ne	1137fcc <ltc_ecc_projective_add_point+0x814>  // b.any
   if ((err = mp_add(t1, y, t1)) != CRYPT_OK)                                  { goto done; }
 1137bfc:	f941d6b6 	ldr	x22, [x21, #936]
 1137c00:	f94037e2 	ldr	x2, [sp, #104]
 1137c04:	f94043e1 	ldr	x1, [sp, #128]
 1137c08:	aa0203e0 	mov	x0, x2
 1137c0c:	f9405ac3 	ldr	x3, [x22, #176]
 1137c10:	d63f0060 	blr	x3
 1137c14:	2a0003f3 	mov	w19, w0
 1137c18:	35ffee00 	cbnz	w0, 11379d8 <ltc_ecc_projective_add_point+0x220>
   if (mp_cmp(t1, modulus) != LTC_MP_LT) {
 1137c1c:	f94032c2 	ldr	x2, [x22, #96]
 1137c20:	aa1403e1 	mov	x1, x20
 1137c24:	f94037e0 	ldr	x0, [sp, #104]
 1137c28:	d63f0040 	blr	x2
 1137c2c:	3100041f 	cmn	w0, #0x1
 1137c30:	54001de1 	b.ne	1137fec <ltc_ecc_projective_add_point+0x834>  // b.any
   if ((err = mp_sub(x, t2, x)) != CRYPT_OK)                                   { goto done; }
 1137c34:	f941d6b6 	ldr	x22, [x21, #936]
 1137c38:	a9470be1 	ldp	x1, x2, [sp, #112]
 1137c3c:	f94062c3 	ldr	x3, [x22, #192]
 1137c40:	aa0203e0 	mov	x0, x2
 1137c44:	d63f0060 	blr	x3
 1137c48:	2a0003f3 	mov	w19, w0
 1137c4c:	35ffec60 	cbnz	w0, 11379d8 <ltc_ecc_projective_add_point+0x220>
   if (mp_cmp_d(x, 0) == LTC_MP_LT) {
 1137c50:	f94036c2 	ldr	x2, [x22, #104]
 1137c54:	d2800001 	mov	x1, #0x0                   	// #0
 1137c58:	f9403fe0 	ldr	x0, [sp, #120]
 1137c5c:	d63f0040 	blr	x2
 1137c60:	3100041f 	cmn	w0, #0x1
 1137c64:	54001d40 	b.eq	113800c <ltc_ecc_projective_add_point+0x854>  // b.none
   if ((err = mp_add(t2, t2, t2)) != CRYPT_OK)                                 { goto done; }
 1137c68:	f941d6b6 	ldr	x22, [x21, #936]
 1137c6c:	f9403be2 	ldr	x2, [sp, #112]
 1137c70:	f9405ac3 	ldr	x3, [x22, #176]
 1137c74:	aa0203e1 	mov	x1, x2
 1137c78:	aa0203e0 	mov	x0, x2
 1137c7c:	d63f0060 	blr	x3
 1137c80:	2a0003f3 	mov	w19, w0
 1137c84:	35ffeaa0 	cbnz	w0, 11379d8 <ltc_ecc_projective_add_point+0x220>
   if (mp_cmp(t2, modulus) != LTC_MP_LT) {
 1137c88:	f94032c2 	ldr	x2, [x22, #96]
 1137c8c:	aa1403e1 	mov	x1, x20
 1137c90:	f9403be0 	ldr	x0, [sp, #112]
 1137c94:	d63f0040 	blr	x2
 1137c98:	3100041f 	cmn	w0, #0x1
 1137c9c:	54001c81 	b.ne	113802c <ltc_ecc_projective_add_point+0x874>  // b.any
   if ((err = mp_add(t2, x, t2)) != CRYPT_OK)                                  { goto done; }
 1137ca0:	f941d6b6 	ldr	x22, [x21, #936]
 1137ca4:	a94707e2 	ldp	x2, x1, [sp, #112]
 1137ca8:	f9405ac3 	ldr	x3, [x22, #176]
 1137cac:	aa0203e0 	mov	x0, x2
 1137cb0:	d63f0060 	blr	x3
 1137cb4:	2a0003f3 	mov	w19, w0
 1137cb8:	35ffe900 	cbnz	w0, 11379d8 <ltc_ecc_projective_add_point+0x220>
   if (mp_cmp(t2, modulus) != LTC_MP_LT) {
 1137cbc:	f94032c2 	ldr	x2, [x22, #96]
 1137cc0:	aa1403e1 	mov	x1, x20
 1137cc4:	f9403be0 	ldr	x0, [sp, #112]
 1137cc8:	d63f0040 	blr	x2
 1137ccc:	3100041f 	cmn	w0, #0x1
 1137cd0:	54001be1 	b.ne	113804c <ltc_ecc_projective_add_point+0x894>  // b.any
   if (Q->z != NULL) {
 1137cd4:	f9400b01 	ldr	x1, [x24, #16]
 1137cd8:	b5001ca1 	cbnz	x1, 113806c <ltc_ecc_projective_add_point+0x8b4>
   if ((err = mp_mul(z, x, z)) != CRYPT_OK)                                    { goto done; }
 1137cdc:	f941d6b5 	ldr	x21, [x21, #936]
 1137ce0:	f9403fe1 	ldr	x1, [sp, #120]
 1137ce4:	f94047e2 	ldr	x2, [sp, #136]
 1137ce8:	f9406aa3 	ldr	x3, [x21, #208]
 1137cec:	aa0203e0 	mov	x0, x2
 1137cf0:	d63f0060 	blr	x3
 1137cf4:	2a0003f3 	mov	w19, w0
 1137cf8:	35ffe700 	cbnz	w0, 11379d8 <ltc_ecc_projective_add_point+0x220>
   if ((err = mp_montgomery_reduce(z, modulus, mp)) != CRYPT_OK)               { goto done; }
 1137cfc:	f94047e0 	ldr	x0, [sp, #136]
 1137d00:	aa1703e2 	mov	x2, x23
 1137d04:	f940a2a3 	ldr	x3, [x21, #320]
 1137d08:	aa1403e1 	mov	x1, x20
 1137d0c:	d63f0060 	blr	x3
 1137d10:	2a0003f3 	mov	w19, w0
 1137d14:	35ffe620 	cbnz	w0, 11379d8 <ltc_ecc_projective_add_point+0x220>
   if ((err = mp_mul(t1, x, t1)) != CRYPT_OK)                                  { goto done; }
 1137d18:	f94037e2 	ldr	x2, [sp, #104]
 1137d1c:	f9403fe1 	ldr	x1, [sp, #120]
 1137d20:	aa0203e0 	mov	x0, x2
 1137d24:	f9406aa3 	ldr	x3, [x21, #208]
 1137d28:	d63f0060 	blr	x3
 1137d2c:	2a0003f3 	mov	w19, w0
 1137d30:	35ffe540 	cbnz	w0, 11379d8 <ltc_ecc_projective_add_point+0x220>
   if ((err = mp_montgomery_reduce(t1, modulus, mp)) != CRYPT_OK)              { goto done; }
 1137d34:	f94037e0 	ldr	x0, [sp, #104]
 1137d38:	aa1703e2 	mov	x2, x23
 1137d3c:	f940a2a3 	ldr	x3, [x21, #320]
 1137d40:	aa1403e1 	mov	x1, x20
 1137d44:	d63f0060 	blr	x3
 1137d48:	2a0003f3 	mov	w19, w0
 1137d4c:	35ffe460 	cbnz	w0, 11379d8 <ltc_ecc_projective_add_point+0x220>
   if ((err = mp_sqr(x, x)) != CRYPT_OK)                                       { goto done; }
 1137d50:	f9403fe1 	ldr	x1, [sp, #120]
 1137d54:	f94072a2 	ldr	x2, [x21, #224]
 1137d58:	aa0103e0 	mov	x0, x1
 1137d5c:	d63f0040 	blr	x2
 1137d60:	2a0003f3 	mov	w19, w0
 1137d64:	35ffe3a0 	cbnz	w0, 11379d8 <ltc_ecc_projective_add_point+0x220>
   if ((err = mp_montgomery_reduce(x, modulus, mp)) != CRYPT_OK)               { goto done; }
 1137d68:	f9403fe0 	ldr	x0, [sp, #120]
 1137d6c:	aa1703e2 	mov	x2, x23
 1137d70:	f940a2a3 	ldr	x3, [x21, #320]
 1137d74:	aa1403e1 	mov	x1, x20
 1137d78:	d63f0060 	blr	x3
 1137d7c:	2a0003f3 	mov	w19, w0
 1137d80:	35ffe2c0 	cbnz	w0, 11379d8 <ltc_ecc_projective_add_point+0x220>
   if ((err = mp_mul(t2, x, t2)) != CRYPT_OK)                                  { goto done; }
 1137d84:	a94707e2 	ldp	x2, x1, [sp, #112]
 1137d88:	f9406aa3 	ldr	x3, [x21, #208]
 1137d8c:	aa0203e0 	mov	x0, x2
 1137d90:	d63f0060 	blr	x3
 1137d94:	2a0003f3 	mov	w19, w0
 1137d98:	35ffe200 	cbnz	w0, 11379d8 <ltc_ecc_projective_add_point+0x220>
   if ((err = mp_montgomery_reduce(t2, modulus, mp)) != CRYPT_OK)              { goto done; }
 1137d9c:	f9403be0 	ldr	x0, [sp, #112]
 1137da0:	aa1703e2 	mov	x2, x23
 1137da4:	f940a2a3 	ldr	x3, [x21, #320]
 1137da8:	aa1403e1 	mov	x1, x20
 1137dac:	d63f0060 	blr	x3
 1137db0:	2a0003f3 	mov	w19, w0
 1137db4:	35ffe120 	cbnz	w0, 11379d8 <ltc_ecc_projective_add_point+0x220>
   if ((err = mp_mul(t1, x, t1)) != CRYPT_OK)                                  { goto done; }
 1137db8:	f94037e2 	ldr	x2, [sp, #104]
 1137dbc:	f9403fe1 	ldr	x1, [sp, #120]
 1137dc0:	aa0203e0 	mov	x0, x2
 1137dc4:	f9406aa3 	ldr	x3, [x21, #208]
 1137dc8:	d63f0060 	blr	x3
 1137dcc:	2a0003f3 	mov	w19, w0
 1137dd0:	35ffe040 	cbnz	w0, 11379d8 <ltc_ecc_projective_add_point+0x220>
   if ((err = mp_montgomery_reduce(t1, modulus, mp)) != CRYPT_OK)              { goto done; }
 1137dd4:	f94037e0 	ldr	x0, [sp, #104]
 1137dd8:	aa1703e2 	mov	x2, x23
 1137ddc:	f940a2a3 	ldr	x3, [x21, #320]
 1137de0:	aa1403e1 	mov	x1, x20
 1137de4:	d63f0060 	blr	x3
 1137de8:	2a0003f3 	mov	w19, w0
 1137dec:	35ffdf60 	cbnz	w0, 11379d8 <ltc_ecc_projective_add_point+0x220>
   if ((err = mp_sqr(y, x)) != CRYPT_OK)                                       { goto done; }
 1137df0:	f0000116 	adrp	x22, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1137df4:	aa1603f5 	mov	x21, x22
 1137df8:	a94783e1 	ldp	x1, x0, [sp, #120]
 1137dfc:	f941d6d8 	ldr	x24, [x22, #936]
 1137e00:	f9407302 	ldr	x2, [x24, #224]
 1137e04:	d63f0040 	blr	x2
 1137e08:	2a0003f3 	mov	w19, w0
 1137e0c:	35ffde60 	cbnz	w0, 11379d8 <ltc_ecc_projective_add_point+0x220>
   if ((err = mp_montgomery_reduce(x, modulus, mp)) != CRYPT_OK)               { goto done; }
 1137e10:	f9403fe0 	ldr	x0, [sp, #120]
 1137e14:	aa1703e2 	mov	x2, x23
 1137e18:	f940a303 	ldr	x3, [x24, #320]
 1137e1c:	aa1403e1 	mov	x1, x20
 1137e20:	d63f0060 	blr	x3
 1137e24:	2a0003f3 	mov	w19, w0
 1137e28:	35ffdd80 	cbnz	w0, 11379d8 <ltc_ecc_projective_add_point+0x220>
   if ((err = mp_sub(x, t2, x)) != CRYPT_OK)                                   { goto done; }
 1137e2c:	a9470be1 	ldp	x1, x2, [sp, #112]
 1137e30:	f9406303 	ldr	x3, [x24, #192]
 1137e34:	aa0203e0 	mov	x0, x2
 1137e38:	d63f0060 	blr	x3
 1137e3c:	2a0003f3 	mov	w19, w0
 1137e40:	35ffdcc0 	cbnz	w0, 11379d8 <ltc_ecc_projective_add_point+0x220>
   if (mp_cmp_d(x, 0) == LTC_MP_LT) {
 1137e44:	f9403702 	ldr	x2, [x24, #104]
 1137e48:	d2800001 	mov	x1, #0x0                   	// #0
 1137e4c:	f9403fe0 	ldr	x0, [sp, #120]
 1137e50:	d63f0040 	blr	x2
 1137e54:	3100041f 	cmn	w0, #0x1
 1137e58:	54001280 	b.eq	11380a8 <ltc_ecc_projective_add_point+0x8f0>  // b.none
   if ((err = mp_sub(t2, x, t2)) != CRYPT_OK)                                  { goto done; }
 1137e5c:	f941d6b6 	ldr	x22, [x21, #936]
 1137e60:	a94707e2 	ldp	x2, x1, [sp, #112]
 1137e64:	f94062c3 	ldr	x3, [x22, #192]
 1137e68:	aa0203e0 	mov	x0, x2
 1137e6c:	d63f0060 	blr	x3
 1137e70:	2a0003f3 	mov	w19, w0
 1137e74:	35ffdb20 	cbnz	w0, 11379d8 <ltc_ecc_projective_add_point+0x220>
   if (mp_cmp_d(t2, 0) == LTC_MP_LT) {
 1137e78:	f94036c2 	ldr	x2, [x22, #104]
 1137e7c:	d2800001 	mov	x1, #0x0                   	// #0
 1137e80:	f9403be0 	ldr	x0, [sp, #112]
 1137e84:	d63f0040 	blr	x2
 1137e88:	3100041f 	cmn	w0, #0x1
 1137e8c:	540011e0 	b.eq	11380c8 <ltc_ecc_projective_add_point+0x910>  // b.none
   if ((err = mp_sub(t2, x, t2)) != CRYPT_OK)                                  { goto done; }
 1137e90:	f941d6b6 	ldr	x22, [x21, #936]
 1137e94:	a94707e2 	ldp	x2, x1, [sp, #112]
 1137e98:	f94062c3 	ldr	x3, [x22, #192]
 1137e9c:	aa0203e0 	mov	x0, x2
 1137ea0:	d63f0060 	blr	x3
 1137ea4:	2a0003f3 	mov	w19, w0
 1137ea8:	35ffd980 	cbnz	w0, 11379d8 <ltc_ecc_projective_add_point+0x220>
   if (mp_cmp_d(t2, 0) == LTC_MP_LT) {
 1137eac:	f94036c2 	ldr	x2, [x22, #104]
 1137eb0:	d2800001 	mov	x1, #0x0                   	// #0
 1137eb4:	f9403be0 	ldr	x0, [sp, #112]
 1137eb8:	d63f0040 	blr	x2
 1137ebc:	3100041f 	cmn	w0, #0x1
 1137ec0:	54001140 	b.eq	11380e8 <ltc_ecc_projective_add_point+0x930>  // b.none
   if ((err = mp_mul(t2, y, t2)) != CRYPT_OK)                                  { goto done; }
 1137ec4:	f941d6b6 	ldr	x22, [x21, #936]
 1137ec8:	f9403be2 	ldr	x2, [sp, #112]
 1137ecc:	f94043e1 	ldr	x1, [sp, #128]
 1137ed0:	aa0203e0 	mov	x0, x2
 1137ed4:	f9406ac3 	ldr	x3, [x22, #208]
 1137ed8:	d63f0060 	blr	x3
 1137edc:	2a0003f3 	mov	w19, w0
 1137ee0:	35ffd7c0 	cbnz	w0, 11379d8 <ltc_ecc_projective_add_point+0x220>
   if ((err = mp_montgomery_reduce(t2, modulus, mp)) != CRYPT_OK)              { goto done; }
 1137ee4:	f9403be0 	ldr	x0, [sp, #112]
 1137ee8:	aa1703e2 	mov	x2, x23
 1137eec:	f940a2c3 	ldr	x3, [x22, #320]
 1137ef0:	aa1403e1 	mov	x1, x20
 1137ef4:	d63f0060 	blr	x3
 1137ef8:	2a0003f3 	mov	w19, w0
 1137efc:	35ffd6e0 	cbnz	w0, 11379d8 <ltc_ecc_projective_add_point+0x220>
   if ((err = mp_sub(t2, t1, y)) != CRYPT_OK)                                  { goto done; }
 1137f00:	a94683e1 	ldp	x1, x0, [sp, #104]
 1137f04:	f94043e2 	ldr	x2, [sp, #128]
 1137f08:	f94062c3 	ldr	x3, [x22, #192]
 1137f0c:	d63f0060 	blr	x3
 1137f10:	2a0003f3 	mov	w19, w0
 1137f14:	35ffd620 	cbnz	w0, 11379d8 <ltc_ecc_projective_add_point+0x220>
   if (mp_cmp_d(y, 0) == LTC_MP_LT) {
 1137f18:	f94036c2 	ldr	x2, [x22, #104]
 1137f1c:	d2800001 	mov	x1, #0x0                   	// #0
 1137f20:	f94043e0 	ldr	x0, [sp, #128]
 1137f24:	d63f0040 	blr	x2
 1137f28:	3100041f 	cmn	w0, #0x1
 1137f2c:	54000ee0 	b.eq	1138108 <ltc_ecc_projective_add_point+0x950>  // b.none
   if (mp_isodd(y)) {
 1137f30:	f941d6b3 	ldr	x19, [x21, #936]
 1137f34:	f94043e0 	ldr	x0, [sp, #128]
 1137f38:	f9402e61 	ldr	x1, [x19, #88]
 1137f3c:	d63f0020 	blr	x1
 1137f40:	7100001f 	cmp	w0, #0x0
 1137f44:	54000f2c 	b.gt	1138128 <ltc_ecc_projective_add_point+0x970>
   if ((err = mp_div_2(y, y)) != CRYPT_OK)                                     { goto done; }
 1137f48:	f941d6b5 	ldr	x21, [x21, #936]
 1137f4c:	f94043e1 	ldr	x1, [sp, #128]
 1137f50:	f9407ea2 	ldr	x2, [x21, #248]
 1137f54:	aa0103e0 	mov	x0, x1
 1137f58:	d63f0040 	blr	x2
 1137f5c:	2a0003f3 	mov	w19, w0
 1137f60:	35ffd3c0 	cbnz	w0, 11379d8 <ltc_ecc_projective_add_point+0x220>
   if ((err = mp_copy(x, R->x)) != CRYPT_OK)                                   { goto done; }
 1137f64:	f9400341 	ldr	x1, [x26]
 1137f68:	f9401ea2 	ldr	x2, [x21, #56]
 1137f6c:	f9403fe0 	ldr	x0, [sp, #120]
 1137f70:	d63f0040 	blr	x2
 1137f74:	2a0003f3 	mov	w19, w0
 1137f78:	35ffd300 	cbnz	w0, 11379d8 <ltc_ecc_projective_add_point+0x220>
   if ((err = mp_copy(y, R->y)) != CRYPT_OK)                                   { goto done; }
 1137f7c:	f9400741 	ldr	x1, [x26, #8]
 1137f80:	f9401ea2 	ldr	x2, [x21, #56]
 1137f84:	f94043e0 	ldr	x0, [sp, #128]
 1137f88:	d63f0040 	blr	x2
 1137f8c:	2a0003f3 	mov	w19, w0
 1137f90:	35ffd240 	cbnz	w0, 11379d8 <ltc_ecc_projective_add_point+0x220>
   if ((err = mp_copy(z, R->z)) != CRYPT_OK)                                   { goto done; }
 1137f94:	f9400b41 	ldr	x1, [x26, #16]
 1137f98:	f9401ea2 	ldr	x2, [x21, #56]
 1137f9c:	f94047e0 	ldr	x0, [sp, #136]
 1137fa0:	d63f0040 	blr	x2
 1137fa4:	17fffe2c 	b	1137854 <ltc_ecc_projective_add_point+0x9c>
      if ((err = mp_add(y, modulus, y)) != CRYPT_OK)                           { goto done; }
 1137fa8:	f941d6a0 	ldr	x0, [x21, #936]
 1137fac:	aa1403e1 	mov	x1, x20
 1137fb0:	f94043e2 	ldr	x2, [sp, #128]
 1137fb4:	f9405803 	ldr	x3, [x0, #176]
 1137fb8:	aa0203e0 	mov	x0, x2
 1137fbc:	d63f0060 	blr	x3
 1137fc0:	2a0003f3 	mov	w19, w0
 1137fc4:	34ffe000 	cbz	w0, 1137bc4 <ltc_ecc_projective_add_point+0x40c>
 1137fc8:	17fffe84 	b	11379d8 <ltc_ecc_projective_add_point+0x220>
      if ((err = mp_sub(t1, modulus, t1)) != CRYPT_OK)                         { goto done; }
 1137fcc:	f94037e2 	ldr	x2, [sp, #104]
 1137fd0:	aa1403e1 	mov	x1, x20
 1137fd4:	f94062c3 	ldr	x3, [x22, #192]
 1137fd8:	aa0203e0 	mov	x0, x2
 1137fdc:	d63f0060 	blr	x3
 1137fe0:	2a0003f3 	mov	w19, w0
 1137fe4:	34ffe0c0 	cbz	w0, 1137bfc <ltc_ecc_projective_add_point+0x444>
 1137fe8:	17fffe7c 	b	11379d8 <ltc_ecc_projective_add_point+0x220>
      if ((err = mp_sub(t1, modulus, t1)) != CRYPT_OK)                         { goto done; }
 1137fec:	f94037e2 	ldr	x2, [sp, #104]
 1137ff0:	aa1403e1 	mov	x1, x20
 1137ff4:	f94062c3 	ldr	x3, [x22, #192]
 1137ff8:	aa0203e0 	mov	x0, x2
 1137ffc:	d63f0060 	blr	x3
 1138000:	2a0003f3 	mov	w19, w0
 1138004:	34ffe180 	cbz	w0, 1137c34 <ltc_ecc_projective_add_point+0x47c>
 1138008:	17fffe74 	b	11379d8 <ltc_ecc_projective_add_point+0x220>
      if ((err = mp_add(x, modulus, x)) != CRYPT_OK)                           { goto done; }
 113800c:	f9403fe2 	ldr	x2, [sp, #120]
 1138010:	aa1403e1 	mov	x1, x20
 1138014:	f9405ac3 	ldr	x3, [x22, #176]
 1138018:	aa0203e0 	mov	x0, x2
 113801c:	d63f0060 	blr	x3
 1138020:	2a0003f3 	mov	w19, w0
 1138024:	34ffe220 	cbz	w0, 1137c68 <ltc_ecc_projective_add_point+0x4b0>
 1138028:	17fffe6c 	b	11379d8 <ltc_ecc_projective_add_point+0x220>
      if ((err = mp_sub(t2, modulus, t2)) != CRYPT_OK)                         { goto done; }
 113802c:	f9403be2 	ldr	x2, [sp, #112]
 1138030:	aa1403e1 	mov	x1, x20
 1138034:	f94062c3 	ldr	x3, [x22, #192]
 1138038:	aa0203e0 	mov	x0, x2
 113803c:	d63f0060 	blr	x3
 1138040:	2a0003f3 	mov	w19, w0
 1138044:	34ffe2e0 	cbz	w0, 1137ca0 <ltc_ecc_projective_add_point+0x4e8>
 1138048:	17fffe64 	b	11379d8 <ltc_ecc_projective_add_point+0x220>
      if ((err = mp_sub(t2, modulus, t2)) != CRYPT_OK)                         { goto done; }
 113804c:	f9403be2 	ldr	x2, [sp, #112]
 1138050:	aa1403e1 	mov	x1, x20
 1138054:	f94062c3 	ldr	x3, [x22, #192]
 1138058:	aa0203e0 	mov	x0, x2
 113805c:	d63f0060 	blr	x3
 1138060:	2a0003f3 	mov	w19, w0
 1138064:	34ffe380 	cbz	w0, 1137cd4 <ltc_ecc_projective_add_point+0x51c>
 1138068:	17fffe5c 	b	11379d8 <ltc_ecc_projective_add_point+0x220>
      if ((err = mp_mul(z, Q->z, z)) != CRYPT_OK)                              { goto done; }
 113806c:	f941d6b6 	ldr	x22, [x21, #936]
 1138070:	f94047e2 	ldr	x2, [sp, #136]
 1138074:	f9406ac3 	ldr	x3, [x22, #208]
 1138078:	aa0203e0 	mov	x0, x2
 113807c:	d63f0060 	blr	x3
 1138080:	2a0003f3 	mov	w19, w0
 1138084:	35ffcaa0 	cbnz	w0, 11379d8 <ltc_ecc_projective_add_point+0x220>
      if ((err = mp_montgomery_reduce(z, modulus, mp)) != CRYPT_OK)            { goto done; }
 1138088:	f94047e0 	ldr	x0, [sp, #136]
 113808c:	aa1703e2 	mov	x2, x23
 1138090:	f940a2c3 	ldr	x3, [x22, #320]
 1138094:	aa1403e1 	mov	x1, x20
 1138098:	d63f0060 	blr	x3
 113809c:	2a0003f3 	mov	w19, w0
 11380a0:	34ffe1e0 	cbz	w0, 1137cdc <ltc_ecc_projective_add_point+0x524>
 11380a4:	17fffe4d 	b	11379d8 <ltc_ecc_projective_add_point+0x220>
      if ((err = mp_add(x, modulus, x)) != CRYPT_OK)                           { goto done; }
 11380a8:	f9403fe2 	ldr	x2, [sp, #120]
 11380ac:	aa1403e1 	mov	x1, x20
 11380b0:	f9405b03 	ldr	x3, [x24, #176]
 11380b4:	aa0203e0 	mov	x0, x2
 11380b8:	d63f0060 	blr	x3
 11380bc:	2a0003f3 	mov	w19, w0
 11380c0:	34ffece0 	cbz	w0, 1137e5c <ltc_ecc_projective_add_point+0x6a4>
 11380c4:	17fffe45 	b	11379d8 <ltc_ecc_projective_add_point+0x220>
      if ((err = mp_add(t2, modulus, t2)) != CRYPT_OK)                         { goto done; }
 11380c8:	f9403be2 	ldr	x2, [sp, #112]
 11380cc:	aa1403e1 	mov	x1, x20
 11380d0:	f9405ac3 	ldr	x3, [x22, #176]
 11380d4:	aa0203e0 	mov	x0, x2
 11380d8:	d63f0060 	blr	x3
 11380dc:	2a0003f3 	mov	w19, w0
 11380e0:	34ffed80 	cbz	w0, 1137e90 <ltc_ecc_projective_add_point+0x6d8>
 11380e4:	17fffe3d 	b	11379d8 <ltc_ecc_projective_add_point+0x220>
      if ((err = mp_add(t2, modulus, t2)) != CRYPT_OK)                         { goto done; }
 11380e8:	f9403be2 	ldr	x2, [sp, #112]
 11380ec:	aa1403e1 	mov	x1, x20
 11380f0:	f9405ac3 	ldr	x3, [x22, #176]
 11380f4:	aa0203e0 	mov	x0, x2
 11380f8:	d63f0060 	blr	x3
 11380fc:	2a0003f3 	mov	w19, w0
 1138100:	34ffee20 	cbz	w0, 1137ec4 <ltc_ecc_projective_add_point+0x70c>
 1138104:	17fffe35 	b	11379d8 <ltc_ecc_projective_add_point+0x220>
      if ((err = mp_add(y, modulus, y)) != CRYPT_OK)                           { goto done; }
 1138108:	f94043e2 	ldr	x2, [sp, #128]
 113810c:	aa1403e1 	mov	x1, x20
 1138110:	f9405ac3 	ldr	x3, [x22, #176]
 1138114:	aa0203e0 	mov	x0, x2
 1138118:	d63f0060 	blr	x3
 113811c:	2a0003f3 	mov	w19, w0
 1138120:	34fff080 	cbz	w0, 1137f30 <ltc_ecc_projective_add_point+0x778>
 1138124:	17fffe2d 	b	11379d8 <ltc_ecc_projective_add_point+0x220>
   if (mp_isodd(y)) {
 1138128:	f9402a62 	ldr	x2, [x19, #80]
 113812c:	52800001 	mov	w1, #0x0                   	// #0
 1138130:	f94043e0 	ldr	x0, [sp, #128]
 1138134:	d63f0040 	blr	x2
 1138138:	3607f080 	tbz	w0, #0, 1137f48 <ltc_ecc_projective_add_point+0x790>
      if ((err = mp_add(y, modulus, y)) != CRYPT_OK)                           { goto done; }
 113813c:	f94043e2 	ldr	x2, [sp, #128]
 1138140:	aa1403e1 	mov	x1, x20
 1138144:	f9405a63 	ldr	x3, [x19, #176]
 1138148:	aa0203e0 	mov	x0, x2
 113814c:	d63f0060 	blr	x3
 1138150:	2a0003f3 	mov	w19, w0
 1138154:	34ffefa0 	cbz	w0, 1137f48 <ltc_ecc_projective_add_point+0x790>
 1138158:	17fffe20 	b	11379d8 <ltc_ecc_projective_add_point+0x220>
   LTC_ARGCHK(P       != NULL);
 113815c:	52800213 	mov	w19, #0x10                  	// #16
 1138160:	17fffde8 	b	1137900 <ltc_ecc_projective_add_point+0x148>

0000000001138164 <ltc_ecc_projective_dbl_point>:
   @param modulus  The modulus of the field the ECC curve is in
   @param mp       The "b" value from montgomery_setup()
   @return CRYPT_OK on success
*/
int ltc_ecc_projective_dbl_point(const ecc_point *P, ecc_point *R, void *ma, void *modulus, void *mp)
{
 1138164:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
 1138168:	910003fd 	mov	x29, sp
 113816c:	a90153f3 	stp	x19, x20, [sp, #16]
 1138170:	a9025bf5 	stp	x21, x22, [sp, #32]
 1138174:	a90363f7 	stp	x23, x24, [sp, #48]
 1138178:	a9046bf9 	stp	x25, x26, [sp, #64]
   void *t1, *t2;
   int   err, inf;

   LTC_ARGCHK(P       != NULL);
 113817c:	b4003940 	cbz	x0, 11388a4 <ltc_ecc_projective_dbl_point+0x740>
 1138180:	aa0103f4 	mov	x20, x1
   LTC_ARGCHK(R       != NULL);
 1138184:	b4003901 	cbz	x1, 11388a4 <ltc_ecc_projective_dbl_point+0x740>
 1138188:	aa0303f5 	mov	x21, x3
   LTC_ARGCHK(modulus != NULL);
 113818c:	b40038c3 	cbz	x3, 11388a4 <ltc_ecc_projective_dbl_point+0x740>
 1138190:	aa0403f6 	mov	x22, x4
   LTC_ARGCHK(mp      != NULL);
 1138194:	b4003884 	cbz	x4, 11388a4 <ltc_ecc_projective_dbl_point+0x740>
 1138198:	aa0003f7 	mov	x23, x0
 113819c:	aa0203f8 	mov	x24, x2

   if ((err = mp_init_multi(&t1, &t2, NULL)) != CRYPT_OK) {
 11381a0:	9101a3e1 	add	x1, sp, #0x68
 11381a4:	910183e0 	add	x0, sp, #0x60
 11381a8:	d2800002 	mov	x2, #0x0                   	// #0
 11381ac:	97ffe742 	bl	1131eb4 <ltc_init_multi>
 11381b0:	2a0003f3 	mov	w19, w0
 11381b4:	35000120 	cbnz	w0, 11381d8 <ltc_ecc_projective_dbl_point+0x74>
      return err;
   }

   if (P != R) {
 11381b8:	eb1402ff 	cmp	x23, x20
 11381bc:	540001c1 	b.ne	11381f4 <ltc_ecc_projective_dbl_point+0x90>  // b.any
      if ((err = ltc_ecc_copy_point(P, R)) != CRYPT_OK)                           { goto done; }
   }

   if ((err = ltc_ecc_is_point_at_infinity(P, modulus, &inf)) != CRYPT_OK) return err;
 11381c0:	910173e2 	add	x2, sp, #0x5c
 11381c4:	aa1503e1 	mov	x1, x21
 11381c8:	aa1703e0 	mov	x0, x23
 11381cc:	97fff9ac 	bl	113687c <ltc_ecc_is_point_at_infinity>
 11381d0:	2a0003f3 	mov	w19, w0
 11381d4:	34000220 	cbz	w0, 1138218 <ltc_ecc_projective_dbl_point+0xb4>

   err = CRYPT_OK;
done:
   mp_clear_multi(t2, t1, NULL);
   return err;
}
 11381d8:	2a1303e0 	mov	w0, w19
 11381dc:	a94153f3 	ldp	x19, x20, [sp, #16]
 11381e0:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11381e4:	a94363f7 	ldp	x23, x24, [sp, #48]
 11381e8:	a9446bf9 	ldp	x25, x26, [sp, #64]
 11381ec:	a8c77bfd 	ldp	x29, x30, [sp], #112
 11381f0:	d65f03c0 	ret
      if ((err = ltc_ecc_copy_point(P, R)) != CRYPT_OK)                           { goto done; }
 11381f4:	aa1403e1 	mov	x1, x20
 11381f8:	aa1703e0 	mov	x0, x23
 11381fc:	97fffd51 	bl	1137740 <ltc_ecc_copy_point>
 1138200:	2a0003f3 	mov	w19, w0
 1138204:	34fffde0 	cbz	w0, 11381c0 <ltc_ecc_projective_dbl_point+0x5c>
   mp_clear_multi(t2, t1, NULL);
 1138208:	a94603e1 	ldp	x1, x0, [sp, #96]
 113820c:	d2800002 	mov	x2, #0x0                   	// #0
 1138210:	97ffe7c3 	bl	113211c <ltc_deinit_multi>
   return err;
 1138214:	17fffff1 	b	11381d8 <ltc_ecc_projective_dbl_point+0x74>
   if (inf) {
 1138218:	b9405fe0 	ldr	w0, [sp, #92]
 113821c:	34000100 	cbz	w0, 113823c <ltc_ecc_projective_dbl_point+0xd8>
      err = ltc_ecc_set_point_xyz(1, 1, 0, R);
 1138220:	d2800021 	mov	x1, #0x1                   	// #1
 1138224:	aa1403e3 	mov	x3, x20
 1138228:	aa0103e0 	mov	x0, x1
 113822c:	d2800002 	mov	x2, #0x0                   	// #0
 1138230:	97fffd25 	bl	11376c4 <ltc_ecc_set_point_xyz>
      if ((err = mp_add(R->y, modulus, R->y)) != CRYPT_OK)                        { goto done; }
 1138234:	2a0003f3 	mov	w19, w0
 1138238:	17fffff4 	b	1138208 <ltc_ecc_projective_dbl_point+0xa4>
   if ((err = mp_sqr(R->z, t1)) != CRYPT_OK)                                      { goto done; }
 113823c:	d0000119 	adrp	x25, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1138240:	aa1903f7 	mov	x23, x25
 1138244:	f9400a80 	ldr	x0, [x20, #16]
 1138248:	f941d73a 	ldr	x26, [x25, #936]
 113824c:	f94033e1 	ldr	x1, [sp, #96]
 1138250:	f9407342 	ldr	x2, [x26, #224]
 1138254:	d63f0040 	blr	x2
 1138258:	2a0003f3 	mov	w19, w0
 113825c:	35fffd60 	cbnz	w0, 1138208 <ltc_ecc_projective_dbl_point+0xa4>
   if ((err = mp_montgomery_reduce(t1, modulus, mp)) != CRYPT_OK)                 { goto done; }
 1138260:	f94033e0 	ldr	x0, [sp, #96]
 1138264:	aa1603e2 	mov	x2, x22
 1138268:	f940a343 	ldr	x3, [x26, #320]
 113826c:	aa1503e1 	mov	x1, x21
 1138270:	d63f0060 	blr	x3
 1138274:	2a0003f3 	mov	w19, w0
 1138278:	35fffc80 	cbnz	w0, 1138208 <ltc_ecc_projective_dbl_point+0xa4>
   if ((err = mp_mul(R->z, R->y, R->z)) != CRYPT_OK)                              { goto done; }
 113827c:	a9408a81 	ldp	x1, x2, [x20, #8]
 1138280:	f9406b43 	ldr	x3, [x26, #208]
 1138284:	aa0203e0 	mov	x0, x2
 1138288:	d63f0060 	blr	x3
 113828c:	2a0003f3 	mov	w19, w0
 1138290:	35fffbc0 	cbnz	w0, 1138208 <ltc_ecc_projective_dbl_point+0xa4>
   if ((err = mp_montgomery_reduce(R->z, modulus, mp)) != CRYPT_OK)               { goto done; }
 1138294:	f9400a80 	ldr	x0, [x20, #16]
 1138298:	aa1603e2 	mov	x2, x22
 113829c:	f940a343 	ldr	x3, [x26, #320]
 11382a0:	aa1503e1 	mov	x1, x21
 11382a4:	d63f0060 	blr	x3
 11382a8:	2a0003f3 	mov	w19, w0
 11382ac:	35fffae0 	cbnz	w0, 1138208 <ltc_ecc_projective_dbl_point+0xa4>
   if ((err = mp_add(R->z, R->z, R->z)) != CRYPT_OK)                              { goto done; }
 11382b0:	f9400a82 	ldr	x2, [x20, #16]
 11382b4:	f9405b43 	ldr	x3, [x26, #176]
 11382b8:	aa0203e1 	mov	x1, x2
 11382bc:	aa0203e0 	mov	x0, x2
 11382c0:	d63f0060 	blr	x3
 11382c4:	2a0003f3 	mov	w19, w0
 11382c8:	35fffa00 	cbnz	w0, 1138208 <ltc_ecc_projective_dbl_point+0xa4>
   if (mp_cmp(R->z, modulus) != LTC_MP_LT) {
 11382cc:	f9400a80 	ldr	x0, [x20, #16]
 11382d0:	aa1503e1 	mov	x1, x21
 11382d4:	f9403342 	ldr	x2, [x26, #96]
 11382d8:	d63f0040 	blr	x2
 11382dc:	3100041f 	cmn	w0, #0x1
 11382e0:	54001ba1 	b.ne	1138654 <ltc_ecc_projective_dbl_point+0x4f0>  // b.any
   if (ma == NULL) { /* special case for curves with a == -3 (10% faster than general case) */
 11382e4:	a94607e0 	ldp	x0, x1, [sp, #96]
 11382e8:	b5001e78 	cbnz	x24, 11386b4 <ltc_ecc_projective_dbl_point+0x550>
      if ((err = mp_sub(R->x, t1, t2)) != CRYPT_OK)                               { goto done; }
 11382ec:	f941d6f8 	ldr	x24, [x23, #936]
 11382f0:	aa0103e2 	mov	x2, x1
 11382f4:	aa0003e1 	mov	x1, x0
 11382f8:	f9400280 	ldr	x0, [x20]
 11382fc:	f9406303 	ldr	x3, [x24, #192]
 1138300:	d63f0060 	blr	x3
 1138304:	2a0003f3 	mov	w19, w0
 1138308:	35fff800 	cbnz	w0, 1138208 <ltc_ecc_projective_dbl_point+0xa4>
      if (mp_cmp_d(t2, 0) == LTC_MP_LT) {
 113830c:	f9403702 	ldr	x2, [x24, #104]
 1138310:	d2800001 	mov	x1, #0x0                   	// #0
 1138314:	f94037e0 	ldr	x0, [sp, #104]
 1138318:	d63f0040 	blr	x2
 113831c:	3100041f 	cmn	w0, #0x1
 1138320:	54001aa0 	b.eq	1138674 <ltc_ecc_projective_dbl_point+0x510>  // b.none
      if ((err = mp_add(t1, R->x, t1)) != CRYPT_OK)                               { goto done; }
 1138324:	f941d6f8 	ldr	x24, [x23, #936]
 1138328:	f9400281 	ldr	x1, [x20]
 113832c:	f94033e2 	ldr	x2, [sp, #96]
 1138330:	f9405b03 	ldr	x3, [x24, #176]
 1138334:	aa0203e0 	mov	x0, x2
 1138338:	d63f0060 	blr	x3
 113833c:	2a0003f3 	mov	w19, w0
 1138340:	35fff640 	cbnz	w0, 1138208 <ltc_ecc_projective_dbl_point+0xa4>
      if (mp_cmp(t1, modulus) != LTC_MP_LT) {
 1138344:	f9403302 	ldr	x2, [x24, #96]
 1138348:	aa1503e1 	mov	x1, x21
 113834c:	f94033e0 	ldr	x0, [sp, #96]
 1138350:	d63f0040 	blr	x2
 1138354:	3100041f 	cmn	w0, #0x1
 1138358:	540019e1 	b.ne	1138694 <ltc_ecc_projective_dbl_point+0x530>  // b.any
      if ((err = mp_mul(t1, t2, t2)) != CRYPT_OK)                                 { goto done; }
 113835c:	f941d6f8 	ldr	x24, [x23, #936]
 1138360:	a9460be0 	ldp	x0, x2, [sp, #96]
 1138364:	f9406b03 	ldr	x3, [x24, #208]
 1138368:	aa0203e1 	mov	x1, x2
 113836c:	d63f0060 	blr	x3
 1138370:	2a0003f3 	mov	w19, w0
 1138374:	35fff4a0 	cbnz	w0, 1138208 <ltc_ecc_projective_dbl_point+0xa4>
      if ((err = mp_montgomery_reduce(t2, modulus, mp)) != CRYPT_OK)              { goto done; }
 1138378:	f94037e0 	ldr	x0, [sp, #104]
 113837c:	aa1603e2 	mov	x2, x22
 1138380:	f940a303 	ldr	x3, [x24, #320]
 1138384:	aa1503e1 	mov	x1, x21
 1138388:	d63f0060 	blr	x3
 113838c:	2a0003f3 	mov	w19, w0
 1138390:	35fff3c0 	cbnz	w0, 1138208 <ltc_ecc_projective_dbl_point+0xa4>
      if ((err = mp_add(t2, t2, t1)) != CRYPT_OK)                                 { goto done; }
 1138394:	a94607e2 	ldp	x2, x1, [sp, #96]
 1138398:	f9405b03 	ldr	x3, [x24, #176]
 113839c:	aa0103e0 	mov	x0, x1
      if ((err = mp_add(t1, t2, t1)) != CRYPT_OK)                                 { goto done; }
 11383a0:	d63f0060 	blr	x3
 11383a4:	2a0003f3 	mov	w19, w0
 11383a8:	35fff300 	cbnz	w0, 1138208 <ltc_ecc_projective_dbl_point+0xa4>
      if (mp_cmp(t1, modulus) != LTC_MP_LT) {
 11383ac:	f9403302 	ldr	x2, [x24, #96]
 11383b0:	aa1503e1 	mov	x1, x21
 11383b4:	f94033e0 	ldr	x0, [sp, #96]
 11383b8:	d63f0040 	blr	x2
 11383bc:	3100041f 	cmn	w0, #0x1
 11383c0:	54001f81 	b.ne	11387b0 <ltc_ecc_projective_dbl_point+0x64c>  // b.any
      if ((err = mp_add(t1, t2, t1)) != CRYPT_OK)                                 { goto done; }
 11383c4:	f941d6f8 	ldr	x24, [x23, #936]
 11383c8:	a94607e2 	ldp	x2, x1, [sp, #96]
 11383cc:	f9405b03 	ldr	x3, [x24, #176]
 11383d0:	aa0203e0 	mov	x0, x2
 11383d4:	d63f0060 	blr	x3
 11383d8:	2a0003f3 	mov	w19, w0
 11383dc:	35fff160 	cbnz	w0, 1138208 <ltc_ecc_projective_dbl_point+0xa4>
      if (mp_cmp(t1, modulus) != LTC_MP_LT) {
 11383e0:	f9403302 	ldr	x2, [x24, #96]
 11383e4:	aa1503e1 	mov	x1, x21
 11383e8:	f94033e0 	ldr	x0, [sp, #96]
 11383ec:	d63f0040 	blr	x2
 11383f0:	3100041f 	cmn	w0, #0x1
 11383f4:	54001ee1 	b.ne	11387d0 <ltc_ecc_projective_dbl_point+0x66c>  // b.any
   if ((err = mp_add(R->y, R->y, R->y)) != CRYPT_OK)                              { goto done; }
 11383f8:	f941d6f8 	ldr	x24, [x23, #936]
 11383fc:	f9400682 	ldr	x2, [x20, #8]
 1138400:	f9405b03 	ldr	x3, [x24, #176]
 1138404:	aa0203e1 	mov	x1, x2
 1138408:	aa0203e0 	mov	x0, x2
 113840c:	d63f0060 	blr	x3
 1138410:	2a0003f3 	mov	w19, w0
 1138414:	35ffefa0 	cbnz	w0, 1138208 <ltc_ecc_projective_dbl_point+0xa4>
   if (mp_cmp(R->y, modulus) != LTC_MP_LT) {
 1138418:	f9400680 	ldr	x0, [x20, #8]
 113841c:	aa1503e1 	mov	x1, x21
 1138420:	f9403302 	ldr	x2, [x24, #96]
 1138424:	d63f0040 	blr	x2
 1138428:	3100041f 	cmn	w0, #0x1
 113842c:	54001e21 	b.ne	11387f0 <ltc_ecc_projective_dbl_point+0x68c>  // b.any
   if ((err = mp_sqr(R->y, R->y)) != CRYPT_OK)                                    { goto done; }
 1138430:	f941d6f8 	ldr	x24, [x23, #936]
 1138434:	f9400681 	ldr	x1, [x20, #8]
 1138438:	f9407302 	ldr	x2, [x24, #224]
 113843c:	aa0103e0 	mov	x0, x1
 1138440:	d63f0040 	blr	x2
 1138444:	2a0003f3 	mov	w19, w0
 1138448:	35ffee00 	cbnz	w0, 1138208 <ltc_ecc_projective_dbl_point+0xa4>
   if ((err = mp_montgomery_reduce(R->y, modulus, mp)) != CRYPT_OK)               { goto done; }
 113844c:	f9400680 	ldr	x0, [x20, #8]
 1138450:	aa1603e2 	mov	x2, x22
 1138454:	f940a303 	ldr	x3, [x24, #320]
 1138458:	aa1503e1 	mov	x1, x21
 113845c:	d63f0060 	blr	x3
 1138460:	2a0003f3 	mov	w19, w0
 1138464:	35ffed20 	cbnz	w0, 1138208 <ltc_ecc_projective_dbl_point+0xa4>
   if ((err = mp_sqr(R->y, t2)) != CRYPT_OK)                                      { goto done; }
 1138468:	f9400680 	ldr	x0, [x20, #8]
 113846c:	f94037e1 	ldr	x1, [sp, #104]
 1138470:	f9407302 	ldr	x2, [x24, #224]
 1138474:	d63f0040 	blr	x2
 1138478:	2a0003f3 	mov	w19, w0
 113847c:	35ffec60 	cbnz	w0, 1138208 <ltc_ecc_projective_dbl_point+0xa4>
   if ((err = mp_montgomery_reduce(t2, modulus, mp)) != CRYPT_OK)                 { goto done; }
 1138480:	f94037e0 	ldr	x0, [sp, #104]
 1138484:	aa1603e2 	mov	x2, x22
 1138488:	f940a303 	ldr	x3, [x24, #320]
 113848c:	aa1503e1 	mov	x1, x21
 1138490:	d63f0060 	blr	x3
 1138494:	2a0003f3 	mov	w19, w0
 1138498:	35ffeb80 	cbnz	w0, 1138208 <ltc_ecc_projective_dbl_point+0xa4>
   if (mp_isodd(t2)) {
 113849c:	f9402f01 	ldr	x1, [x24, #88]
 11384a0:	f94037e0 	ldr	x0, [sp, #104]
 11384a4:	d63f0020 	blr	x1
 11384a8:	7100001f 	cmp	w0, #0x0
 11384ac:	54001b2c 	b.gt	1138810 <ltc_ecc_projective_dbl_point+0x6ac>
   if ((err = mp_div_2(t2, t2)) != CRYPT_OK)                                      { goto done; }
 11384b0:	f941d6f8 	ldr	x24, [x23, #936]
 11384b4:	f94037e1 	ldr	x1, [sp, #104]
 11384b8:	f9407f02 	ldr	x2, [x24, #248]
 11384bc:	aa0103e0 	mov	x0, x1
 11384c0:	d63f0040 	blr	x2
 11384c4:	2a0003f3 	mov	w19, w0
 11384c8:	35ffea00 	cbnz	w0, 1138208 <ltc_ecc_projective_dbl_point+0xa4>
   if ((err = mp_mul(R->y, R->x, R->y)) != CRYPT_OK)                              { goto done; }
 11384cc:	a9400a81 	ldp	x1, x2, [x20]
 11384d0:	f9406b03 	ldr	x3, [x24, #208]
 11384d4:	aa0203e0 	mov	x0, x2
 11384d8:	d63f0060 	blr	x3
 11384dc:	2a0003f3 	mov	w19, w0
 11384e0:	35ffe940 	cbnz	w0, 1138208 <ltc_ecc_projective_dbl_point+0xa4>
   if ((err = mp_montgomery_reduce(R->y, modulus, mp)) != CRYPT_OK)               { goto done; }
 11384e4:	f9400680 	ldr	x0, [x20, #8]
 11384e8:	aa1603e2 	mov	x2, x22
 11384ec:	f940a303 	ldr	x3, [x24, #320]
 11384f0:	aa1503e1 	mov	x1, x21
 11384f4:	d63f0060 	blr	x3
 11384f8:	2a0003f3 	mov	w19, w0
 11384fc:	35ffe860 	cbnz	w0, 1138208 <ltc_ecc_projective_dbl_point+0xa4>
   if ((err = mp_sqr(t1, R->x)) != CRYPT_OK)                                      { goto done; }
 1138500:	f9400281 	ldr	x1, [x20]
 1138504:	f94033e0 	ldr	x0, [sp, #96]
 1138508:	f9407302 	ldr	x2, [x24, #224]
 113850c:	d63f0040 	blr	x2
 1138510:	2a0003f3 	mov	w19, w0
 1138514:	35ffe7a0 	cbnz	w0, 1138208 <ltc_ecc_projective_dbl_point+0xa4>
   if ((err = mp_montgomery_reduce(R->x, modulus, mp)) != CRYPT_OK)               { goto done; }
 1138518:	f9400280 	ldr	x0, [x20]
 113851c:	aa1603e2 	mov	x2, x22
 1138520:	f940a303 	ldr	x3, [x24, #320]
 1138524:	aa1503e1 	mov	x1, x21
 1138528:	d63f0060 	blr	x3
 113852c:	2a0003f3 	mov	w19, w0
 1138530:	35ffe6c0 	cbnz	w0, 1138208 <ltc_ecc_projective_dbl_point+0xa4>
   if ((err = mp_sub(R->x, R->y, R->x)) != CRYPT_OK)                              { goto done; }
 1138534:	a9400682 	ldp	x2, x1, [x20]
 1138538:	f9406303 	ldr	x3, [x24, #192]
 113853c:	aa0203e0 	mov	x0, x2
 1138540:	d63f0060 	blr	x3
 1138544:	2a0003f3 	mov	w19, w0
 1138548:	35ffe600 	cbnz	w0, 1138208 <ltc_ecc_projective_dbl_point+0xa4>
   if (mp_cmp_d(R->x, 0) == LTC_MP_LT) {
 113854c:	f9400280 	ldr	x0, [x20]
 1138550:	d2800001 	mov	x1, #0x0                   	// #0
 1138554:	f9403702 	ldr	x2, [x24, #104]
 1138558:	d63f0040 	blr	x2
 113855c:	3100041f 	cmn	w0, #0x1
 1138560:	54001720 	b.eq	1138844 <ltc_ecc_projective_dbl_point+0x6e0>  // b.none
   if ((err = mp_sub(R->x, R->y, R->x)) != CRYPT_OK)                              { goto done; }
 1138564:	f941d6f8 	ldr	x24, [x23, #936]
 1138568:	a9400682 	ldp	x2, x1, [x20]
 113856c:	f9406303 	ldr	x3, [x24, #192]
 1138570:	aa0203e0 	mov	x0, x2
 1138574:	d63f0060 	blr	x3
 1138578:	2a0003f3 	mov	w19, w0
 113857c:	35ffe460 	cbnz	w0, 1138208 <ltc_ecc_projective_dbl_point+0xa4>
   if (mp_cmp_d(R->x, 0) == LTC_MP_LT) {
 1138580:	f9400280 	ldr	x0, [x20]
 1138584:	d2800001 	mov	x1, #0x0                   	// #0
 1138588:	f9403702 	ldr	x2, [x24, #104]
 113858c:	d63f0040 	blr	x2
 1138590:	3100041f 	cmn	w0, #0x1
 1138594:	54001680 	b.eq	1138864 <ltc_ecc_projective_dbl_point+0x700>  // b.none
   if ((err = mp_sub(R->y, R->x, R->y)) != CRYPT_OK)                              { goto done; }
 1138598:	f941d6f8 	ldr	x24, [x23, #936]
 113859c:	a9400a81 	ldp	x1, x2, [x20]
 11385a0:	f9406303 	ldr	x3, [x24, #192]
 11385a4:	aa0203e0 	mov	x0, x2
 11385a8:	d63f0060 	blr	x3
 11385ac:	2a0003f3 	mov	w19, w0
 11385b0:	35ffe2c0 	cbnz	w0, 1138208 <ltc_ecc_projective_dbl_point+0xa4>
   if (mp_cmp_d(R->y, 0) == LTC_MP_LT) {
 11385b4:	f9400680 	ldr	x0, [x20, #8]
 11385b8:	d2800001 	mov	x1, #0x0                   	// #0
 11385bc:	f9403702 	ldr	x2, [x24, #104]
 11385c0:	d63f0040 	blr	x2
 11385c4:	3100041f 	cmn	w0, #0x1
 11385c8:	540015e0 	b.eq	1138884 <ltc_ecc_projective_dbl_point+0x720>  // b.none
   if ((err = mp_mul(R->y, t1, R->y)) != CRYPT_OK)                                { goto done; }
 11385cc:	f941d6f7 	ldr	x23, [x23, #936]
 11385d0:	f9400682 	ldr	x2, [x20, #8]
 11385d4:	f94033e1 	ldr	x1, [sp, #96]
 11385d8:	aa0203e0 	mov	x0, x2
 11385dc:	f9406ae3 	ldr	x3, [x23, #208]
 11385e0:	d63f0060 	blr	x3
 11385e4:	2a0003f3 	mov	w19, w0
 11385e8:	35ffe100 	cbnz	w0, 1138208 <ltc_ecc_projective_dbl_point+0xa4>
   if ((err = mp_montgomery_reduce(R->y, modulus, mp)) != CRYPT_OK)               { goto done; }
 11385ec:	f9400680 	ldr	x0, [x20, #8]
 11385f0:	aa1603e2 	mov	x2, x22
 11385f4:	f940a2e3 	ldr	x3, [x23, #320]
 11385f8:	aa1503e1 	mov	x1, x21
 11385fc:	d63f0060 	blr	x3
 1138600:	2a0003f3 	mov	w19, w0
 1138604:	35ffe020 	cbnz	w0, 1138208 <ltc_ecc_projective_dbl_point+0xa4>
   if ((err = mp_sub(R->y, t2, R->y)) != CRYPT_OK)                                { goto done; }
 1138608:	f9400682 	ldr	x2, [x20, #8]
 113860c:	f94037e1 	ldr	x1, [sp, #104]
 1138610:	aa0203e0 	mov	x0, x2
 1138614:	f94062e3 	ldr	x3, [x23, #192]
 1138618:	d63f0060 	blr	x3
 113861c:	2a0003f3 	mov	w19, w0
 1138620:	35ffdf40 	cbnz	w0, 1138208 <ltc_ecc_projective_dbl_point+0xa4>
   if (mp_cmp_d(R->y, 0) == LTC_MP_LT) {
 1138624:	f9400680 	ldr	x0, [x20, #8]
 1138628:	d2800001 	mov	x1, #0x0                   	// #0
 113862c:	f94036e2 	ldr	x2, [x23, #104]
 1138630:	d63f0040 	blr	x2
 1138634:	3100041f 	cmn	w0, #0x1
 1138638:	54ffde81 	b.ne	1138208 <ltc_ecc_projective_dbl_point+0xa4>  // b.any
      if ((err = mp_add(R->y, modulus, R->y)) != CRYPT_OK)                        { goto done; }
 113863c:	f9400682 	ldr	x2, [x20, #8]
 1138640:	aa1503e1 	mov	x1, x21
 1138644:	f9405ae3 	ldr	x3, [x23, #176]
 1138648:	aa0203e0 	mov	x0, x2
 113864c:	d63f0060 	blr	x3
 1138650:	17fffef9 	b	1138234 <ltc_ecc_projective_dbl_point+0xd0>
      if ((err = mp_sub(R->z, modulus, R->z)) != CRYPT_OK)                        { goto done; }
 1138654:	f9400a82 	ldr	x2, [x20, #16]
 1138658:	aa1503e1 	mov	x1, x21
 113865c:	f9406343 	ldr	x3, [x26, #192]
 1138660:	aa0203e0 	mov	x0, x2
 1138664:	d63f0060 	blr	x3
 1138668:	2a0003f3 	mov	w19, w0
 113866c:	34ffe3c0 	cbz	w0, 11382e4 <ltc_ecc_projective_dbl_point+0x180>
 1138670:	17fffee6 	b	1138208 <ltc_ecc_projective_dbl_point+0xa4>
         if ((err = mp_add(t2, modulus, t2)) != CRYPT_OK)                         { goto done; }
 1138674:	f94037e2 	ldr	x2, [sp, #104]
 1138678:	aa1503e1 	mov	x1, x21
 113867c:	f9405b03 	ldr	x3, [x24, #176]
 1138680:	aa0203e0 	mov	x0, x2
 1138684:	d63f0060 	blr	x3
 1138688:	2a0003f3 	mov	w19, w0
 113868c:	34ffe4c0 	cbz	w0, 1138324 <ltc_ecc_projective_dbl_point+0x1c0>
 1138690:	17fffede 	b	1138208 <ltc_ecc_projective_dbl_point+0xa4>
         if ((err = mp_sub(t1, modulus, t1)) != CRYPT_OK)                         { goto done; }
 1138694:	f94033e2 	ldr	x2, [sp, #96]
 1138698:	aa1503e1 	mov	x1, x21
 113869c:	f9406303 	ldr	x3, [x24, #192]
 11386a0:	aa0203e0 	mov	x0, x2
 11386a4:	d63f0060 	blr	x3
 11386a8:	2a0003f3 	mov	w19, w0
 11386ac:	34ffe580 	cbz	w0, 113835c <ltc_ecc_projective_dbl_point+0x1f8>
 11386b0:	17fffed6 	b	1138208 <ltc_ecc_projective_dbl_point+0xa4>
      if ((err = mp_sqr(t1, t2)) != CRYPT_OK)                                     { goto done; }
 11386b4:	f941d6f9 	ldr	x25, [x23, #936]
 11386b8:	f9407322 	ldr	x2, [x25, #224]
 11386bc:	d63f0040 	blr	x2
 11386c0:	2a0003f3 	mov	w19, w0
 11386c4:	35ffda20 	cbnz	w0, 1138208 <ltc_ecc_projective_dbl_point+0xa4>
      if ((err = mp_montgomery_reduce(t2, modulus, mp)) != CRYPT_OK)              { goto done; }
 11386c8:	f94037e0 	ldr	x0, [sp, #104]
 11386cc:	aa1603e2 	mov	x2, x22
 11386d0:	f940a323 	ldr	x3, [x25, #320]
 11386d4:	aa1503e1 	mov	x1, x21
 11386d8:	d63f0060 	blr	x3
 11386dc:	2a0003f3 	mov	w19, w0
 11386e0:	35ffd940 	cbnz	w0, 1138208 <ltc_ecc_projective_dbl_point+0xa4>
      if ((err = mp_mul(t2, ma, t1)) != CRYPT_OK)                                 { goto done; }
 11386e4:	a94603e2 	ldp	x2, x0, [sp, #96]
 11386e8:	aa1803e1 	mov	x1, x24
 11386ec:	f9406b23 	ldr	x3, [x25, #208]
 11386f0:	d63f0060 	blr	x3
 11386f4:	2a0003f3 	mov	w19, w0
 11386f8:	35ffd880 	cbnz	w0, 1138208 <ltc_ecc_projective_dbl_point+0xa4>
      if ((err = mp_montgomery_reduce(t1, modulus, mp)) != CRYPT_OK)              { goto done; }
 11386fc:	f94033e0 	ldr	x0, [sp, #96]
 1138700:	aa1603e2 	mov	x2, x22
 1138704:	f940a323 	ldr	x3, [x25, #320]
 1138708:	aa1503e1 	mov	x1, x21
 113870c:	d63f0060 	blr	x3
 1138710:	2a0003f3 	mov	w19, w0
 1138714:	35ffd7a0 	cbnz	w0, 1138208 <ltc_ecc_projective_dbl_point+0xa4>
      if ((err = mp_sqr(R->x, t2)) != CRYPT_OK)                                   { goto done; }
 1138718:	f9400280 	ldr	x0, [x20]
 113871c:	f94037e1 	ldr	x1, [sp, #104]
 1138720:	f9407322 	ldr	x2, [x25, #224]
 1138724:	d63f0040 	blr	x2
 1138728:	2a0003f3 	mov	w19, w0
 113872c:	35ffd6e0 	cbnz	w0, 1138208 <ltc_ecc_projective_dbl_point+0xa4>
      if ((err = mp_montgomery_reduce(t2, modulus, mp)) != CRYPT_OK)              { goto done; }
 1138730:	f94037e0 	ldr	x0, [sp, #104]
 1138734:	aa1603e2 	mov	x2, x22
 1138738:	f940a323 	ldr	x3, [x25, #320]
 113873c:	aa1503e1 	mov	x1, x21
 1138740:	d63f0060 	blr	x3
 1138744:	2a0003f3 	mov	w19, w0
 1138748:	35ffd600 	cbnz	w0, 1138208 <ltc_ecc_projective_dbl_point+0xa4>
      if ((err = mp_add(t1, t2, t1)) != CRYPT_OK)                                 { goto done; }
 113874c:	a94607e2 	ldp	x2, x1, [sp, #96]
 1138750:	f9405b23 	ldr	x3, [x25, #176]
 1138754:	aa0203e0 	mov	x0, x2
 1138758:	d63f0060 	blr	x3
 113875c:	2a0003f3 	mov	w19, w0
 1138760:	35ffd540 	cbnz	w0, 1138208 <ltc_ecc_projective_dbl_point+0xa4>
      if (mp_cmp(t1, modulus) != LTC_MP_LT) {
 1138764:	f9403322 	ldr	x2, [x25, #96]
 1138768:	aa1503e1 	mov	x1, x21
 113876c:	f94033e0 	ldr	x0, [sp, #96]
 1138770:	d63f0040 	blr	x2
 1138774:	3100041f 	cmn	w0, #0x1
 1138778:	540000c1 	b.ne	1138790 <ltc_ecc_projective_dbl_point+0x62c>  // b.any
      if ((err = mp_add(t1, t2, t1)) != CRYPT_OK)                                 { goto done; }
 113877c:	a94607e2 	ldp	x2, x1, [sp, #96]
 1138780:	f941d6f8 	ldr	x24, [x23, #936]
 1138784:	aa0203e0 	mov	x0, x2
 1138788:	f9405b03 	ldr	x3, [x24, #176]
 113878c:	17ffff05 	b	11383a0 <ltc_ecc_projective_dbl_point+0x23c>
         if ((err = mp_sub(t1, modulus, t1)) != CRYPT_OK)                         { goto done; }
 1138790:	f94033e2 	ldr	x2, [sp, #96]
 1138794:	aa1503e1 	mov	x1, x21
 1138798:	f9406323 	ldr	x3, [x25, #192]
 113879c:	aa0203e0 	mov	x0, x2
 11387a0:	d63f0060 	blr	x3
 11387a4:	2a0003f3 	mov	w19, w0
 11387a8:	34fffea0 	cbz	w0, 113877c <ltc_ecc_projective_dbl_point+0x618>
 11387ac:	17fffe97 	b	1138208 <ltc_ecc_projective_dbl_point+0xa4>
         if ((err = mp_sub(t1, modulus, t1)) != CRYPT_OK)                         { goto done; }
 11387b0:	f94033e2 	ldr	x2, [sp, #96]
 11387b4:	aa1503e1 	mov	x1, x21
 11387b8:	f9406303 	ldr	x3, [x24, #192]
 11387bc:	aa0203e0 	mov	x0, x2
 11387c0:	d63f0060 	blr	x3
 11387c4:	2a0003f3 	mov	w19, w0
 11387c8:	34ffdfe0 	cbz	w0, 11383c4 <ltc_ecc_projective_dbl_point+0x260>
 11387cc:	17fffe8f 	b	1138208 <ltc_ecc_projective_dbl_point+0xa4>
         if ((err = mp_sub(t1, modulus, t1)) != CRYPT_OK)                         { goto done; }
 11387d0:	f94033e2 	ldr	x2, [sp, #96]
 11387d4:	aa1503e1 	mov	x1, x21
 11387d8:	f9406303 	ldr	x3, [x24, #192]
 11387dc:	aa0203e0 	mov	x0, x2
 11387e0:	d63f0060 	blr	x3
 11387e4:	2a0003f3 	mov	w19, w0
 11387e8:	34ffe080 	cbz	w0, 11383f8 <ltc_ecc_projective_dbl_point+0x294>
 11387ec:	17fffe87 	b	1138208 <ltc_ecc_projective_dbl_point+0xa4>
      if ((err = mp_sub(R->y, modulus, R->y)) != CRYPT_OK)                        { goto done; }
 11387f0:	f9400682 	ldr	x2, [x20, #8]
 11387f4:	aa1503e1 	mov	x1, x21
 11387f8:	f9406303 	ldr	x3, [x24, #192]
 11387fc:	aa0203e0 	mov	x0, x2
 1138800:	d63f0060 	blr	x3
 1138804:	2a0003f3 	mov	w19, w0
 1138808:	34ffe140 	cbz	w0, 1138430 <ltc_ecc_projective_dbl_point+0x2cc>
 113880c:	17fffe7f 	b	1138208 <ltc_ecc_projective_dbl_point+0xa4>
   if (mp_isodd(t2)) {
 1138810:	f9402b02 	ldr	x2, [x24, #80]
 1138814:	52800001 	mov	w1, #0x0                   	// #0
 1138818:	f94037e0 	ldr	x0, [sp, #104]
 113881c:	d63f0040 	blr	x2
 1138820:	3607e480 	tbz	w0, #0, 11384b0 <ltc_ecc_projective_dbl_point+0x34c>
      if ((err = mp_add(t2, modulus, t2)) != CRYPT_OK)                            { goto done; }
 1138824:	f94037e2 	ldr	x2, [sp, #104]
 1138828:	aa1503e1 	mov	x1, x21
 113882c:	f9405b03 	ldr	x3, [x24, #176]
 1138830:	aa0203e0 	mov	x0, x2
 1138834:	d63f0060 	blr	x3
 1138838:	2a0003f3 	mov	w19, w0
 113883c:	34ffe3a0 	cbz	w0, 11384b0 <ltc_ecc_projective_dbl_point+0x34c>
 1138840:	17fffe72 	b	1138208 <ltc_ecc_projective_dbl_point+0xa4>
      if ((err = mp_add(R->x, modulus, R->x)) != CRYPT_OK)                        { goto done; }
 1138844:	f9400282 	ldr	x2, [x20]
 1138848:	aa1503e1 	mov	x1, x21
 113884c:	f9405b03 	ldr	x3, [x24, #176]
 1138850:	aa0203e0 	mov	x0, x2
 1138854:	d63f0060 	blr	x3
 1138858:	2a0003f3 	mov	w19, w0
 113885c:	34ffe840 	cbz	w0, 1138564 <ltc_ecc_projective_dbl_point+0x400>
 1138860:	17fffe6a 	b	1138208 <ltc_ecc_projective_dbl_point+0xa4>
      if ((err = mp_add(R->x, modulus, R->x)) != CRYPT_OK)                        { goto done; }
 1138864:	f9400282 	ldr	x2, [x20]
 1138868:	aa1503e1 	mov	x1, x21
 113886c:	f9405b03 	ldr	x3, [x24, #176]
 1138870:	aa0203e0 	mov	x0, x2
 1138874:	d63f0060 	blr	x3
 1138878:	2a0003f3 	mov	w19, w0
 113887c:	34ffe8e0 	cbz	w0, 1138598 <ltc_ecc_projective_dbl_point+0x434>
 1138880:	17fffe62 	b	1138208 <ltc_ecc_projective_dbl_point+0xa4>
      if ((err = mp_add(R->y, modulus, R->y)) != CRYPT_OK)                        { goto done; }
 1138884:	f9400682 	ldr	x2, [x20, #8]
 1138888:	aa1503e1 	mov	x1, x21
 113888c:	f9405b03 	ldr	x3, [x24, #176]
 1138890:	aa0203e0 	mov	x0, x2
 1138894:	d63f0060 	blr	x3
 1138898:	2a0003f3 	mov	w19, w0
 113889c:	34ffe980 	cbz	w0, 11385cc <ltc_ecc_projective_dbl_point+0x468>
 11388a0:	17fffe5a 	b	1138208 <ltc_ecc_projective_dbl_point+0xa4>
   LTC_ARGCHK(P       != NULL);
 11388a4:	52800213 	mov	w19, #0x10                  	// #16
 11388a8:	17fffe4c 	b	11381d8 <ltc_ecc_projective_dbl_point+0x74>

00000000011388ac <hash_memory>:
  @param out    [out] Where to store the digest
  @param outlen [in/out] Max size and resulting size of the digest
  @return CRYPT_OK if successful
*/
int hash_memory(int hash, const unsigned char *in, unsigned long inlen, unsigned char *out, unsigned long *outlen)
{
 11388ac:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 11388b0:	910003fd 	mov	x29, sp
 11388b4:	a90153f3 	stp	x19, x20, [sp, #16]
 11388b8:	a9025bf5 	stp	x21, x22, [sp, #32]
 11388bc:	a90363f7 	stp	x23, x24, [sp, #48]
 11388c0:	a9046bf9 	stp	x25, x26, [sp, #64]
    hash_state *md;
    int err;

    LTC_ARGCHK(in     != NULL);
 11388c4:	b4000741 	cbz	x1, 11389ac <hash_memory+0x100>
 11388c8:	aa0303f8 	mov	x24, x3
    LTC_ARGCHK(out    != NULL);
 11388cc:	b4000703 	cbz	x3, 11389ac <hash_memory+0x100>
 11388d0:	aa0403f6 	mov	x22, x4
    LTC_ARGCHK(outlen != NULL);
 11388d4:	b40006c4 	cbz	x4, 11389ac <hash_memory+0x100>
 11388d8:	93407c14 	sxtw	x20, w0
 11388dc:	aa0103f9 	mov	x25, x1
 11388e0:	aa0203fa 	mov	x26, x2

    if ((err = hash_is_valid(hash)) != CRYPT_OK) {
 11388e4:	97ffe764 	bl	1132674 <hash_is_valid>
 11388e8:	2a0003f3 	mov	w19, w0
 11388ec:	35000140 	cbnz	w0, 1138914 <hash_memory+0x68>
        return err;
    }

    if (*outlen < hash_descriptor[hash]->hashsize) {
 11388f0:	d0000117 	adrp	x23, 115a000 <__scattered_array_1phys_mem_map+0x8>
 11388f4:	f94002c1 	ldr	x1, [x22]
 11388f8:	f941a2f7 	ldr	x23, [x23, #832]
 11388fc:	f8747af3 	ldr	x19, [x23, x20, lsl #3]
 1138900:	f9400a60 	ldr	x0, [x19, #16]
 1138904:	eb00003f 	cmp	x1, x0
 1138908:	54000142 	b.cs	1138930 <hash_memory+0x84>  // b.hs, b.nlast
       *outlen = hash_descriptor[hash]->hashsize;
       return CRYPT_BUFFER_OVERFLOW;
 113890c:	528000d3 	mov	w19, #0x6                   	// #6
       *outlen = hash_descriptor[hash]->hashsize;
 1138910:	f90002c0 	str	x0, [x22]
    zeromem(md, sizeof(hash_state));
#endif
    XFREE(md);

    return err;
}
 1138914:	2a1303e0 	mov	w0, w19
 1138918:	a94153f3 	ldp	x19, x20, [sp, #16]
 113891c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1138920:	a94363f7 	ldp	x23, x24, [sp, #48]
 1138924:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1138928:	a8c57bfd 	ldp	x29, x30, [sp], #80
 113892c:	d65f03c0 	ret
    md = XMALLOC(sizeof(hash_state));
 1138930:	d2801a00 	mov	x0, #0xd0                  	// #208
 1138934:	94002ac9 	bl	1143458 <malloc>
 1138938:	aa0003f5 	mov	x21, x0
    if (md == NULL) {
 113893c:	b40003c0 	cbz	x0, 11389b4 <hash_memory+0x108>
    if ((err = hash_descriptor[hash]->init(md)) != CRYPT_OK) {
 1138940:	f9405661 	ldr	x1, [x19, #168]
 1138944:	d63f0020 	blr	x1
 1138948:	2a0003f3 	mov	w19, w0
 113894c:	35000240 	cbnz	w0, 1138994 <hash_memory+0xe8>
    if ((err = hash_descriptor[hash]->process(md, in, inlen)) != CRYPT_OK) {
 1138950:	f8747ae0 	ldr	x0, [x23, x20, lsl #3]
 1138954:	aa1a03e2 	mov	x2, x26
 1138958:	aa1903e1 	mov	x1, x25
 113895c:	f9405803 	ldr	x3, [x0, #176]
 1138960:	aa1503e0 	mov	x0, x21
 1138964:	d63f0060 	blr	x3
 1138968:	2a0003f3 	mov	w19, w0
 113896c:	35000140 	cbnz	w0, 1138994 <hash_memory+0xe8>
    err = hash_descriptor[hash]->done(md, out);
 1138970:	f8747ae0 	ldr	x0, [x23, x20, lsl #3]
 1138974:	aa1803e1 	mov	x1, x24
 1138978:	f9405c02 	ldr	x2, [x0, #184]
 113897c:	aa1503e0 	mov	x0, x21
 1138980:	d63f0040 	blr	x2
 1138984:	2a0003f3 	mov	w19, w0
    *outlen = hash_descriptor[hash]->hashsize;
 1138988:	f8747ae0 	ldr	x0, [x23, x20, lsl #3]
 113898c:	f9400800 	ldr	x0, [x0, #16]
 1138990:	f90002c0 	str	x0, [x22]
    zeromem(md, sizeof(hash_state));
 1138994:	d2801a01 	mov	x1, #0xd0                  	// #208
 1138998:	aa1503e0 	mov	x0, x21
 113899c:	97ffe6aa 	bl	1132444 <zeromem>
    XFREE(md);
 11389a0:	aa1503e0 	mov	x0, x21
 11389a4:	94002b0f 	bl	11435e0 <free>
    return err;
 11389a8:	17ffffdb 	b	1138914 <hash_memory+0x68>
    LTC_ARGCHK(in     != NULL);
 11389ac:	52800213 	mov	w19, #0x10                  	// #16
 11389b0:	17ffffd9 	b	1138914 <hash_memory+0x68>
       return CRYPT_MEM;
 11389b4:	528001b3 	mov	w19, #0xd                   	// #13
 11389b8:	17ffffd7 	b	1138914 <hash_memory+0x68>

00000000011389bc <rand_prime>:
*/

#define USE_BBS 1

int rand_prime(void *N, long len, prng_state *prng, int wprng)
{
 11389bc:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
 11389c0:	910003fd 	mov	x29, sp
 11389c4:	a90153f3 	stp	x19, x20, [sp, #16]
 11389c8:	a9025bf5 	stp	x21, x22, [sp, #32]
 11389cc:	a90363f7 	stp	x23, x24, [sp, #48]
 11389d0:	a9046bf9 	stp	x25, x26, [sp, #64]
 11389d4:	a90573fb 	stp	x27, x28, [sp, #80]
 11389d8:	f90033e2 	str	x2, [sp, #96]
   int            err, res, type;
   unsigned char *buf;

   LTC_ARGCHK(N != NULL);
 11389dc:	b40009c0 	cbz	x0, 1138b14 <rand_prime+0x158>
 11389e0:	aa0003f5 	mov	x21, x0
 11389e4:	aa0103f7 	mov	x23, x1
 11389e8:	93407c74 	sxtw	x20, w3

   /* get type */
   if (len < 0) {
 11389ec:	b6f804e1 	tbz	x1, #63, 1138a88 <rand_prime+0xcc>
      type = USE_BBS;
      len = -len;
 11389f0:	cb0103f7 	neg	x23, x1
      type = USE_BBS;
 11389f4:	52800036 	mov	w22, #0x1                   	// #1
   } else {
      type = 0;
   }

   /* allow sizes between 2 and 512 bytes for a prime size */
   if (len < 2 || len > 512) {
 11389f8:	d1000ae0 	sub	x0, x23, #0x2
 11389fc:	f107f81f 	cmp	x0, #0x1fe
 1138a00:	540008e8 	b.hi	1138b1c <rand_prime+0x160>  // b.pmore
      return CRYPT_INVALID_PRIME_SIZE;
   }

   /* valid PRNG? Better be! */
   if ((err = prng_is_valid(wprng)) != CRYPT_OK) {
 1138a04:	2a1403e0 	mov	w0, w20
 1138a08:	97ffe735 	bl	11326dc <prng_is_valid>
 1138a0c:	2a0003f3 	mov	w19, w0
 1138a10:	350002c0 	cbnz	w0, 1138a68 <rand_prime+0xac>
      return err;
   }

   /* allocate buffer to work with */
   buf = XCALLOC(1, len);
 1138a14:	aa1703e1 	mov	x1, x23
 1138a18:	d2800020 	mov	x0, #0x1                   	// #1
 1138a1c:	94002aad 	bl	11434d0 <calloc>
 1138a20:	aa0003fc 	mov	x28, x0
   if (buf == NULL) {
 1138a24:	b4000800 	cbz	x0, 1138b24 <rand_prime+0x168>
       return CRYPT_MEM;
   }

   do {
      /* generate value */
      if (prng_descriptor[wprng]->read(buf, len, prng) != (unsigned long)len) {
 1138a28:	d0000118 	adrp	x24, 115a000 <__scattered_array_1phys_mem_map+0x8>
         return CRYPT_ERROR_READPRNG;
      }

      /* munge bits */
      buf[0]     |= 0x80 | 0x40;
      buf[len-1] |= 0x01 | ((type & USE_BBS) ? 0x02 : 0x00);
 1138a2c:	531f7ad6 	lsl	w22, w22, #1
 1138a30:	d10006f9 	sub	x25, x23, #0x1
         XFREE(buf);
         return err;
      }

      /* test */
      if ((err = mp_prime_is_prime(N, LTC_MILLER_RABIN_REPS, &res)) != CRYPT_OK) {
 1138a34:	9101f3fb 	add	x27, sp, #0x7c
      if (prng_descriptor[wprng]->read(buf, len, prng) != (unsigned long)len) {
 1138a38:	f9422f1a 	ldr	x26, [x24, #1112]
 1138a3c:	aa1703e1 	mov	x1, x23
 1138a40:	f8747b40 	ldr	x0, [x26, x20, lsl #3]
 1138a44:	f94033e2 	ldr	x2, [sp, #96]
 1138a48:	f9401403 	ldr	x3, [x0, #40]
 1138a4c:	aa1c03e0 	mov	x0, x28
 1138a50:	d63f0060 	blr	x3
 1138a54:	eb0002ff 	cmp	x23, x0
 1138a58:	540001c0 	b.eq	1138a90 <rand_prime+0xd4>  // b.none
         return CRYPT_ERROR_READPRNG;
 1138a5c:	52800133 	mov	w19, #0x9                   	// #9
         XFREE(buf);
 1138a60:	aa1c03e0 	mov	x0, x28
 1138a64:	94002adf 	bl	11435e0 <free>
   zeromem(buf, len);
#endif

   XFREE(buf);
   return CRYPT_OK;
}
 1138a68:	2a1303e0 	mov	w0, w19
 1138a6c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1138a70:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1138a74:	a94363f7 	ldp	x23, x24, [sp, #48]
 1138a78:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1138a7c:	a94573fb 	ldp	x27, x28, [sp, #80]
 1138a80:	a8c87bfd 	ldp	x29, x30, [sp], #128
 1138a84:	d65f03c0 	ret
      type = 0;
 1138a88:	52800016 	mov	w22, #0x0                   	// #0
 1138a8c:	17ffffdb 	b	11389f8 <rand_prime+0x3c>
      buf[0]     |= 0x80 | 0x40;
 1138a90:	39400380 	ldrb	w0, [x28]
      if ((err = mp_read_unsigned_bin(N, buf, len)) != CRYPT_OK) {
 1138a94:	aa1703e2 	mov	x2, x23
 1138a98:	f941d703 	ldr	x3, [x24, #936]
      buf[0]     |= 0x80 | 0x40;
 1138a9c:	321a6400 	orr	w0, w0, #0xffffffc0
 1138aa0:	39000380 	strb	w0, [x28]
      if ((err = mp_read_unsigned_bin(N, buf, len)) != CRYPT_OK) {
 1138aa4:	aa1c03e1 	mov	x1, x28
 1138aa8:	f90037e3 	str	x3, [sp, #104]
      buf[len-1] |= 0x01 | ((type & USE_BBS) ? 0x02 : 0x00);
 1138aac:	38796b80 	ldrb	w0, [x28, x25]
      if ((err = mp_read_unsigned_bin(N, buf, len)) != CRYPT_OK) {
 1138ab0:	f9405465 	ldr	x5, [x3, #168]
      buf[len-1] |= 0x01 | ((type & USE_BBS) ? 0x02 : 0x00);
 1138ab4:	2a0002c0 	orr	w0, w22, w0
 1138ab8:	32000000 	orr	w0, w0, #0x1
 1138abc:	38396b80 	strb	w0, [x28, x25]
      if ((err = mp_read_unsigned_bin(N, buf, len)) != CRYPT_OK) {
 1138ac0:	aa1503e0 	mov	x0, x21
 1138ac4:	d63f00a0 	blr	x5
 1138ac8:	2a0003f3 	mov	w19, w0
 1138acc:	f94037e3 	ldr	x3, [sp, #104]
 1138ad0:	34000080 	cbz	w0, 1138ae0 <rand_prime+0x124>
   XFREE(buf);
 1138ad4:	aa1c03e0 	mov	x0, x28
 1138ad8:	94002ac2 	bl	11435e0 <free>
   return CRYPT_OK;
 1138adc:	17ffffe3 	b	1138a68 <rand_prime+0xac>
      if ((err = mp_prime_is_prime(N, LTC_MILLER_RABIN_REPS, &res)) != CRYPT_OK) {
 1138ae0:	f940ac63 	ldr	x3, [x3, #344]
 1138ae4:	aa1b03e2 	mov	x2, x27
 1138ae8:	aa1503e0 	mov	x0, x21
 1138aec:	52800501 	mov	w1, #0x28                  	// #40
 1138af0:	d63f0060 	blr	x3
 1138af4:	2a0003f3 	mov	w19, w0
 1138af8:	35fffee0 	cbnz	w0, 1138ad4 <rand_prime+0x118>
   } while (res == LTC_MP_NO);
 1138afc:	b9407fe0 	ldr	w0, [sp, #124]
 1138b00:	34fff9e0 	cbz	w0, 1138a3c <rand_prime+0x80>
   zeromem(buf, len);
 1138b04:	aa1703e1 	mov	x1, x23
 1138b08:	aa1c03e0 	mov	x0, x28
 1138b0c:	97ffe64e 	bl	1132444 <zeromem>
 1138b10:	17fffff1 	b	1138ad4 <rand_prime+0x118>
   LTC_ARGCHK(N != NULL);
 1138b14:	52800213 	mov	w19, #0x10                  	// #16
 1138b18:	17ffffd4 	b	1138a68 <rand_prime+0xac>
      return CRYPT_INVALID_PRIME_SIZE;
 1138b1c:	528002f3 	mov	w19, #0x17                  	// #23
 1138b20:	17ffffd2 	b	1138a68 <rand_prime+0xac>
       return CRYPT_MEM;
 1138b24:	528001b3 	mov	w19, #0xd                   	// #13
 1138b28:	17ffffd0 	b	1138a68 <rand_prime+0xac>

0000000001138b2c <ssh_decode_sequence_multi>:
  @param inlen  Length of buffer to decode
  @remark <...> is of the form <type, data> (int, void*) except for string <type, data, size>
  @return CRYPT_OK on success
*/
int ssh_decode_sequence_multi(const unsigned char *in, unsigned long inlen, ...)
{
 1138b2c:	a9b57bfd 	stp	x29, x30, [sp, #-176]!
 1138b30:	910003fd 	mov	x29, sp
 1138b34:	a90153f3 	stp	x19, x20, [sp, #16]
 1138b38:	a9025bf5 	stp	x21, x22, [sp, #32]
 1138b3c:	a90363f7 	stp	x23, x24, [sp, #48]
 1138b40:	f90023f9 	str	x25, [sp, #64]
 1138b44:	a9080fe2 	stp	x2, x3, [sp, #128]
 1138b48:	a90917e4 	stp	x4, x5, [sp, #144]
 1138b4c:	a90a1fe6 	stp	x6, x7, [sp, #160]
   ulong32       *u32data;
   ulong64       *u64data;
   unsigned long bufsize;
   ulong32       size;

   LTC_ARGCHK(in    != NULL);
 1138b50:	b4001c40 	cbz	x0, 1138ed8 <ssh_decode_sequence_multi+0x3ac>
 1138b54:	aa0003f7 	mov	x23, x0

   /* Decode values from buffer */
   va_start(args, inlen);
 1138b58:	9102c3e0 	add	x0, sp, #0xb0
 1138b5c:	900000d4 	adrp	x20, 1150000 <Te4+0x258>
 1138b60:	900000d5 	adrp	x21, 1150000 <Te4+0x258>
 1138b64:	aa0103f3 	mov	x19, x1
            size = 8;
            break;
         case LTC_SSHDATA_STRING:
         case LTC_SSHDATA_NAMELIST:
         case LTC_SSHDATA_MPINT:
            LOAD32H(size, in);
 1138b68:	910173f6 	add	x22, sp, #0x5c
 1138b6c:	910f4294 	add	x20, x20, #0x3d0
 1138b70:	910f62b5 	add	x21, x21, #0x3d8
   va_start(args, inlen);
 1138b74:	a90603e0 	stp	x0, x0, [sp, #96]
 1138b78:	910203e0 	add	x0, sp, #0x80
 1138b7c:	f9003be0 	str	x0, [sp, #112]
 1138b80:	128005e0 	mov	w0, #0xffffffd0            	// #-48
 1138b84:	b9007be0 	str	w0, [sp, #120]
 1138b88:	b9007fff 	str	wzr, [sp, #124]
   while ((type = (ssh_data_type)va_arg(args, int)) != LTC_SSHDATA_EOL) {
 1138b8c:	b9407be1 	ldr	w1, [sp, #120]
 1138b90:	f94033e0 	ldr	x0, [sp, #96]
 1138b94:	37f81901 	tbnz	w1, #31, 1138eb4 <ssh_decode_sequence_multi+0x388>
 1138b98:	91002c01 	add	x1, x0, #0xb
 1138b9c:	927df021 	and	x1, x1, #0xfffffffffffffff8
 1138ba0:	f90033e1 	str	x1, [sp, #96]
 1138ba4:	b9400018 	ldr	w24, [x0]
 1138ba8:	71001f1f 	cmp	w24, #0x7
 1138bac:	54000061 	b.ne	1138bb8 <ssh_decode_sequence_multi+0x8c>  // b.any
            /* Should never get here */
            err = CRYPT_INVALID_ARG;
            goto error;
      }
   }
   err = CRYPT_OK;
 1138bb0:	52800000 	mov	w0, #0x0                   	// #0
 1138bb4:	14000009 	b	1138bd8 <ssh_decode_sequence_multi+0xac>
      if (type == LTC_SSHDATA_STRING ||
 1138bb8:	121e7b00 	and	w0, w24, #0xfffffffd
 1138bbc:	7100101f 	cmp	w0, #0x4
 1138bc0:	54000060 	b.eq	1138bcc <ssh_decode_sequence_multi+0xa0>  // b.none
          type == LTC_SSHDATA_NAMELIST ||
 1138bc4:	7100171f 	cmp	w24, #0x5
 1138bc8:	54000141 	b.ne	1138bf0 <ssh_decode_sequence_multi+0xc4>  // b.any
         if (inlen < 4) {
 1138bcc:	f1000e7f 	cmp	x19, #0x3
 1138bd0:	54000428 	b.hi	1138c54 <ssh_decode_sequence_multi+0x128>  // b.pmore
            err = CRYPT_BUFFER_OVERFLOW;
 1138bd4:	528000c0 	mov	w0, #0x6                   	// #6

error:
   va_end(args);
   return err;
}
 1138bd8:	a94153f3 	ldp	x19, x20, [sp, #16]
 1138bdc:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1138be0:	a94363f7 	ldp	x23, x24, [sp, #48]
 1138be4:	f94023f9 	ldr	x25, [sp, #64]
 1138be8:	a8cb7bfd 	ldp	x29, x30, [sp], #176
 1138bec:	d65f03c0 	ret
      switch (type) {
 1138bf0:	71001b1f 	cmp	w24, #0x6
 1138bf4:	54001728 	b.hi	1138ed8 <ssh_decode_sequence_multi+0x3ac>  // b.pmore
 1138bf8:	38784a80 	ldrb	w0, [x20, w24, uxtw]
 1138bfc:	10000061 	adr	x1, 1138c08 <ssh_decode_sequence_multi+0xdc>
 1138c00:	8b208820 	add	x0, x1, w0, sxtb #2
 1138c04:	d61f0000 	br	x0
            size = 1;
 1138c08:	52800020 	mov	w0, #0x1                   	// #1
            size = 4;
 1138c0c:	b9005fe0 	str	w0, [sp, #92]
      if (inlen < size) {
 1138c10:	b9405fe1 	ldr	w1, [sp, #92]
 1138c14:	2a0103f9 	mov	w25, w1
 1138c18:	eb21427f 	cmp	x19, w1, uxtw
 1138c1c:	54fffdc3 	b.cc	1138bd4 <ssh_decode_sequence_multi+0xa8>  // b.lo, b.ul, b.last
         inlen -= size;
 1138c20:	cb190273 	sub	x19, x19, x25
      switch (type) {
 1138c24:	71001b1f 	cmp	w24, #0x6
 1138c28:	54001588 	b.hi	1138ed8 <ssh_decode_sequence_multi+0x3ac>  // b.pmore
 1138c2c:	b9407be0 	ldr	w0, [sp, #120]
 1138c30:	f94033e3 	ldr	x3, [sp, #96]
 1138c34:	78785aa2 	ldrh	w2, [x21, w24, uxtw #1]
 1138c38:	10000064 	adr	x4, 1138c44 <ssh_decode_sequence_multi+0x118>
 1138c3c:	8b22a882 	add	x2, x4, w2, sxth #2
 1138c40:	d61f0040 	br	x2
            size = 4;
 1138c44:	52800080 	mov	w0, #0x4                   	// #4
 1138c48:	17fffff1 	b	1138c0c <ssh_decode_sequence_multi+0xe0>
            size = 8;
 1138c4c:	52800100 	mov	w0, #0x8                   	// #8
 1138c50:	17ffffef 	b	1138c0c <ssh_decode_sequence_multi+0xe0>
            LOAD32H(size, in);
 1138c54:	aa1703e1 	mov	x1, x23
 1138c58:	aa1603e0 	mov	x0, x22
 1138c5c:	d2800082 	mov	x2, #0x4                   	// #4
 1138c60:	97ff29cc 	bl	1103390 <memcpy>
 1138c64:	b9405fe0 	ldr	w0, [sp, #92]
            in += 4;
 1138c68:	910012f7 	add	x23, x23, #0x4
            inlen -= 4;
 1138c6c:	d1001273 	sub	x19, x19, #0x4
            LOAD32H(size, in);
 1138c70:	5ac00800 	rev	w0, w0
 1138c74:	b9005fe0 	str	w0, [sp, #92]
            break;
 1138c78:	17ffffe6 	b	1138c10 <ssh_decode_sequence_multi+0xe4>
            cdata = va_arg(args, unsigned char*);
 1138c7c:	37f80100 	tbnz	w0, #31, 1138c9c <ssh_decode_sequence_multi+0x170>
 1138c80:	91003c60 	add	x0, x3, #0xf
 1138c84:	927df000 	and	x0, x0, #0xfffffffffffffff8
 1138c88:	f90033e0 	str	x0, [sp, #96]
            *cdata = *in++;
 1138c8c:	384016e1 	ldrb	w1, [x23], #1
            cdata = va_arg(args, unsigned char*);
 1138c90:	f9400060 	ldr	x0, [x3]
            *cdata = (*in++)?1:0;
 1138c94:	39000001 	strb	w1, [x0]
            break;
 1138c98:	17ffffbd 	b	1138b8c <ssh_decode_sequence_multi+0x60>
            cdata = va_arg(args, unsigned char*);
 1138c9c:	11002001 	add	w1, w0, #0x8
 1138ca0:	b9007be1 	str	w1, [sp, #120]
 1138ca4:	7100003f 	cmp	w1, #0x0
 1138ca8:	54fffecc 	b.gt	1138c80 <ssh_decode_sequence_multi+0x154>
 1138cac:	f94037e3 	ldr	x3, [sp, #104]
 1138cb0:	8b20c063 	add	x3, x3, w0, sxtw
 1138cb4:	17fffff6 	b	1138c8c <ssh_decode_sequence_multi+0x160>
            cdata = va_arg(args, unsigned char*);
 1138cb8:	37f80120 	tbnz	w0, #31, 1138cdc <ssh_decode_sequence_multi+0x1b0>
 1138cbc:	91003c60 	add	x0, x3, #0xf
 1138cc0:	927df000 	and	x0, x0, #0xfffffffffffffff8
 1138cc4:	f90033e0 	str	x0, [sp, #96]
            *cdata = (*in++)?1:0;
 1138cc8:	384016e1 	ldrb	w1, [x23], #1
            cdata = va_arg(args, unsigned char*);
 1138ccc:	f9400060 	ldr	x0, [x3]
            *cdata = (*in++)?1:0;
 1138cd0:	7100003f 	cmp	w1, #0x0
 1138cd4:	1a9f07e1 	cset	w1, ne  // ne = any
 1138cd8:	17ffffef 	b	1138c94 <ssh_decode_sequence_multi+0x168>
            cdata = va_arg(args, unsigned char*);
 1138cdc:	11002001 	add	w1, w0, #0x8
 1138ce0:	b9007be1 	str	w1, [sp, #120]
 1138ce4:	7100003f 	cmp	w1, #0x0
 1138ce8:	54fffeac 	b.gt	1138cbc <ssh_decode_sequence_multi+0x190>
 1138cec:	f94037e3 	ldr	x3, [sp, #104]
 1138cf0:	8b20c063 	add	x3, x3, w0, sxtw
 1138cf4:	17fffff5 	b	1138cc8 <ssh_decode_sequence_multi+0x19c>
            u32data = va_arg(args, ulong32*);
 1138cf8:	37f801e0 	tbnz	w0, #31, 1138d34 <ssh_decode_sequence_multi+0x208>
 1138cfc:	91003c60 	add	x0, x3, #0xf
 1138d00:	927df000 	and	x0, x0, #0xfffffffffffffff8
 1138d04:	f90033e0 	str	x0, [sp, #96]
 1138d08:	f9400063 	ldr	x3, [x3]
            LOAD32H(*u32data, in);
 1138d0c:	aa1703e1 	mov	x1, x23
 1138d10:	d2800082 	mov	x2, #0x4                   	// #4
            in += 4;
 1138d14:	910012f7 	add	x23, x23, #0x4
            LOAD32H(*u32data, in);
 1138d18:	aa0303e0 	mov	x0, x3
 1138d1c:	97ff299d 	bl	1103390 <memcpy>
 1138d20:	aa0003e3 	mov	x3, x0
 1138d24:	b9400000 	ldr	w0, [x0]
 1138d28:	5ac00800 	rev	w0, w0
 1138d2c:	b9000060 	str	w0, [x3]
            break;
 1138d30:	17ffff97 	b	1138b8c <ssh_decode_sequence_multi+0x60>
            u32data = va_arg(args, ulong32*);
 1138d34:	11002001 	add	w1, w0, #0x8
 1138d38:	b9007be1 	str	w1, [sp, #120]
 1138d3c:	7100003f 	cmp	w1, #0x0
 1138d40:	54fffdec 	b.gt	1138cfc <ssh_decode_sequence_multi+0x1d0>
 1138d44:	f94037e3 	ldr	x3, [sp, #104]
 1138d48:	8b20c063 	add	x3, x3, w0, sxtw
 1138d4c:	17ffffef 	b	1138d08 <ssh_decode_sequence_multi+0x1dc>
            u64data = va_arg(args, ulong64*);
 1138d50:	37f801e0 	tbnz	w0, #31, 1138d8c <ssh_decode_sequence_multi+0x260>
 1138d54:	91003c60 	add	x0, x3, #0xf
 1138d58:	927df000 	and	x0, x0, #0xfffffffffffffff8
 1138d5c:	f90033e0 	str	x0, [sp, #96]
 1138d60:	f9400063 	ldr	x3, [x3]
            LOAD64H(*u64data, in);
 1138d64:	aa1703e1 	mov	x1, x23
 1138d68:	d2800102 	mov	x2, #0x8                   	// #8
            in += 8;
 1138d6c:	910022f7 	add	x23, x23, #0x8
            LOAD64H(*u64data, in);
 1138d70:	aa0303e0 	mov	x0, x3
 1138d74:	97ff2987 	bl	1103390 <memcpy>
 1138d78:	aa0003e3 	mov	x3, x0
 1138d7c:	f9400000 	ldr	x0, [x0]
 1138d80:	dac00c00 	rev	x0, x0
 1138d84:	f9000060 	str	x0, [x3]
            break;
 1138d88:	17ffff81 	b	1138b8c <ssh_decode_sequence_multi+0x60>
            u64data = va_arg(args, ulong64*);
 1138d8c:	11002001 	add	w1, w0, #0x8
 1138d90:	b9007be1 	str	w1, [sp, #120]
 1138d94:	7100003f 	cmp	w1, #0x0
 1138d98:	54fffdec 	b.gt	1138d54 <ssh_decode_sequence_multi+0x228>
 1138d9c:	f94037e3 	ldr	x3, [sp, #104]
 1138da0:	8b20c063 	add	x3, x3, w0, sxtw
 1138da4:	17ffffef 	b	1138d60 <ssh_decode_sequence_multi+0x234>
            sdata = va_arg(args, char*);
 1138da8:	37f802c0 	tbnz	w0, #31, 1138e00 <ssh_decode_sequence_multi+0x2d4>
 1138dac:	91003c60 	add	x0, x3, #0xf
 1138db0:	927df000 	and	x0, x0, #0xfffffffffffffff8
 1138db4:	f90033e0 	str	x0, [sp, #96]
            bufsize = va_arg(args, unsigned long);
 1138db8:	b9407be2 	ldr	w2, [sp, #120]
            sdata = va_arg(args, char*);
 1138dbc:	f9400063 	ldr	x3, [x3]
            bufsize = va_arg(args, unsigned long);
 1138dc0:	f94033e0 	ldr	x0, [sp, #96]
 1138dc4:	37f802c2 	tbnz	w2, #31, 1138e1c <ssh_decode_sequence_multi+0x2f0>
 1138dc8:	91003c02 	add	x2, x0, #0xf
 1138dcc:	927df042 	and	x2, x2, #0xfffffffffffffff8
 1138dd0:	f90033e2 	str	x2, [sp, #96]
            if (size >= bufsize) {
 1138dd4:	f9400000 	ldr	x0, [x0]
 1138dd8:	eb00033f 	cmp	x25, x0
 1138ddc:	54ffefc2 	b.cs	1138bd4 <ssh_decode_sequence_multi+0xa8>  // b.hs, b.nlast
            if (size > 0) {
 1138de0:	340002c1 	cbz	w1, 1138e38 <ssh_decode_sequence_multi+0x30c>
               XSTRNCPY(sdata, (const char *)in, size);
 1138de4:	aa1903e2 	mov	x2, x25
 1138de8:	aa1703e1 	mov	x1, x23
 1138dec:	aa0303e0 	mov	x0, x3
 1138df0:	94002bd3 	bl	1143d3c <strncpy>
               sdata[size] = '\0'; /* strncpy doesn't NUL-terminate */
 1138df4:	3839681f 	strb	wzr, [x0, x25]
            in += size;
 1138df8:	8b1902f7 	add	x23, x23, x25
            break;
 1138dfc:	17ffff64 	b	1138b8c <ssh_decode_sequence_multi+0x60>
            sdata = va_arg(args, char*);
 1138e00:	11002002 	add	w2, w0, #0x8
 1138e04:	b9007be2 	str	w2, [sp, #120]
 1138e08:	7100005f 	cmp	w2, #0x0
 1138e0c:	54fffd0c 	b.gt	1138dac <ssh_decode_sequence_multi+0x280>
 1138e10:	f94037e3 	ldr	x3, [sp, #104]
 1138e14:	8b20c063 	add	x3, x3, w0, sxtw
 1138e18:	17ffffe8 	b	1138db8 <ssh_decode_sequence_multi+0x28c>
            bufsize = va_arg(args, unsigned long);
 1138e1c:	11002044 	add	w4, w2, #0x8
 1138e20:	b9007be4 	str	w4, [sp, #120]
 1138e24:	7100009f 	cmp	w4, #0x0
 1138e28:	54fffd0c 	b.gt	1138dc8 <ssh_decode_sequence_multi+0x29c>
 1138e2c:	f94037e0 	ldr	x0, [sp, #104]
 1138e30:	8b22c000 	add	x0, x0, w2, sxtw
 1138e34:	17ffffe8 	b	1138dd4 <ssh_decode_sequence_multi+0x2a8>
               *sdata = '\0';
 1138e38:	3900007f 	strb	wzr, [x3]
            in += size;
 1138e3c:	17ffffef 	b	1138df8 <ssh_decode_sequence_multi+0x2cc>
            vdata = va_arg(args, void*);
 1138e40:	37f801a0 	tbnz	w0, #31, 1138e74 <ssh_decode_sequence_multi+0x348>
 1138e44:	91003c60 	add	x0, x3, #0xf
 1138e48:	927df000 	and	x0, x0, #0xfffffffffffffff8
 1138e4c:	f90033e0 	str	x0, [sp, #96]
 1138e50:	f9400060 	ldr	x0, [x3]
            if (size == 0) {
 1138e54:	350001e1 	cbnz	w1, 1138e90 <ssh_decode_sequence_multi+0x364>
               if ((err = mp_set(vdata, 0)) != CRYPT_OK)                                                { goto error; }
 1138e58:	d0000101 	adrp	x1, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1138e5c:	f941d421 	ldr	x1, [x1, #936]
 1138e60:	f9402022 	ldr	x2, [x1, #64]
 1138e64:	d2800001 	mov	x1, #0x0                   	// #0
 1138e68:	d63f0040 	blr	x2
 1138e6c:	34fffc60 	cbz	w0, 1138df8 <ssh_decode_sequence_multi+0x2cc>
 1138e70:	17ffff5a 	b	1138bd8 <ssh_decode_sequence_multi+0xac>
            vdata = va_arg(args, void*);
 1138e74:	11002002 	add	w2, w0, #0x8
 1138e78:	b9007be2 	str	w2, [sp, #120]
 1138e7c:	7100005f 	cmp	w2, #0x0
 1138e80:	54fffe2c 	b.gt	1138e44 <ssh_decode_sequence_multi+0x318>
 1138e84:	f94037e3 	ldr	x3, [sp, #104]
 1138e88:	8b20c063 	add	x3, x3, w0, sxtw
 1138e8c:	17fffff1 	b	1138e50 <ssh_decode_sequence_multi+0x324>
            } else if ((in[0] & 0x80) != 0) {
 1138e90:	39c002e1 	ldrsb	w1, [x23]
 1138e94:	37f801e1 	tbnz	w1, #31, 1138ed0 <ssh_decode_sequence_multi+0x3a4>
               if ((err = mp_read_unsigned_bin(vdata, (unsigned char *)in, size)) != CRYPT_OK)          { goto error; }
 1138e98:	d0000101 	adrp	x1, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1138e9c:	aa1903e2 	mov	x2, x25
 1138ea0:	f941d421 	ldr	x1, [x1, #936]
 1138ea4:	f9405423 	ldr	x3, [x1, #168]
 1138ea8:	aa1703e1 	mov	x1, x23
 1138eac:	d63f0060 	blr	x3
 1138eb0:	17ffffef 	b	1138e6c <ssh_decode_sequence_multi+0x340>
   while ((type = (ssh_data_type)va_arg(args, int)) != LTC_SSHDATA_EOL) {
 1138eb4:	11002022 	add	w2, w1, #0x8
 1138eb8:	b9007be2 	str	w2, [sp, #120]
 1138ebc:	7100005f 	cmp	w2, #0x0
 1138ec0:	54ffe6cc 	b.gt	1138b98 <ssh_decode_sequence_multi+0x6c>
 1138ec4:	f94037e0 	ldr	x0, [sp, #104]
 1138ec8:	8b21c000 	add	x0, x0, w1, sxtw
 1138ecc:	17ffff36 	b	1138ba4 <ssh_decode_sequence_multi+0x78>
               err = CRYPT_INVALID_PACKET;
 1138ed0:	528000e0 	mov	w0, #0x7                   	// #7
   return err;
 1138ed4:	17ffff41 	b	1138bd8 <ssh_decode_sequence_multi+0xac>
   LTC_ARGCHK(in    != NULL);
 1138ed8:	52800200 	mov	w0, #0x10                  	// #16
 1138edc:	17ffff3f 	b	1138bd8 <ssh_decode_sequence_multi+0xac>

0000000001138ee0 <ssh_encode_sequence_multi>:
  @param outlen [in/out] Length of buffer and resulting length of output
  @remark <...> is of the form <type, data> (int, void*)
  @return CRYPT_OK on success
*/
int ssh_encode_sequence_multi(unsigned char *out, unsigned long *outlen, ...)
{
 1138ee0:	a9b57bfd 	stp	x29, x30, [sp, #-176]!
 1138ee4:	910003fd 	mov	x29, sp
 1138ee8:	a90153f3 	stp	x19, x20, [sp, #16]
 1138eec:	a9025bf5 	stp	x21, x22, [sp, #32]
 1138ef0:	a90363f7 	stp	x23, x24, [sp, #48]
 1138ef4:	a9046bf9 	stp	x25, x26, [sp, #64]
 1138ef8:	a9080fe2 	stp	x2, x3, [sp, #128]
 1138efc:	a90917e4 	stp	x4, x5, [sp, #144]
 1138f00:	a90a1fe6 	stp	x6, x7, [sp, #160]
   const char   *sdata;
   int           idata;
   ulong32       u32data;
   ulong64       u64data;

   LTC_ARGCHK(out    != NULL);
 1138f04:	b40027e0 	cbz	x0, 1139400 <ssh_encode_sequence_multi+0x520>
 1138f08:	aa0103f6 	mov	x22, x1
   LTC_ARGCHK(outlen != NULL);
 1138f0c:	b40027a1 	cbz	x1, 1139400 <ssh_encode_sequence_multi+0x520>
            break;
         case LTC_SSHDATA_MPINT:
            vdata = va_arg(args, void*);
            /* Calculate size */
            size += 4;
            if (mp_iszero(vdata) != LTC_MP_YES) {
 1138f10:	d0000113 	adrp	x19, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1138f14:	aa0003f7 	mov	x23, x0
   va_start(args, outlen);
 1138f18:	900000d4 	adrp	x20, 1150000 <Te4+0x258>
 1138f1c:	9102c3e0 	add	x0, sp, #0xb0
            if (mp_iszero(vdata) != LTC_MP_YES) {
 1138f20:	f941d673 	ldr	x19, [x19, #936]
 1138f24:	910fa294 	add	x20, x20, #0x3e8
   va_start(args, outlen);
 1138f28:	910203f5 	add	x21, sp, #0x80
   size = 0;
 1138f2c:	52800018 	mov	w24, #0x0                   	// #0
   va_start(args, outlen);
 1138f30:	a90603e0 	stp	x0, x0, [sp, #96]
 1138f34:	128005e0 	mov	w0, #0xffffffd0            	// #-48
 1138f38:	f9003bf5 	str	x21, [sp, #112]
 1138f3c:	b9007be0 	str	w0, [sp, #120]
 1138f40:	b9007fff 	str	wzr, [sp, #124]
   while ((type = (ssh_data_type)va_arg(args, int)) != LTC_SSHDATA_EOL) {
 1138f44:	b9407be1 	ldr	w1, [sp, #120]
 1138f48:	f94033e0 	ldr	x0, [sp, #96]
 1138f4c:	37f80d01 	tbnz	w1, #31, 11390ec <ssh_encode_sequence_multi+0x20c>
 1138f50:	91002c01 	add	x1, x0, #0xb
 1138f54:	927df021 	and	x1, x1, #0xfffffffffffffff8
 1138f58:	f90033e1 	str	x1, [sp, #96]
 1138f5c:	b9400000 	ldr	w0, [x0]
 1138f60:	71001c1f 	cmp	w0, #0x7
 1138f64:	540001a1 	b.ne	1138f98 <ssh_encode_sequence_multi+0xb8>  // b.any
      }
   }
   va_end(args);

   /* Check we have sufficient space */
   if (*outlen < size) {
 1138f68:	f94002c1 	ldr	x1, [x22]
 1138f6c:	2a1803e0 	mov	w0, w24
      *outlen = size;
 1138f70:	f90002c0 	str	x0, [x22]
   if (*outlen < size) {
 1138f74:	eb38403f 	cmp	x1, w24, uxtw
 1138f78:	54000c82 	b.cs	1139108 <ssh_encode_sequence_multi+0x228>  // b.hs, b.nlast
      err = CRYPT_BUFFER_OVERFLOW;
 1138f7c:	528000c0 	mov	w0, #0x6                   	// #6

error:
   va_end(args);
errornoargs:
   return err;
}
 1138f80:	a94153f3 	ldp	x19, x20, [sp, #16]
 1138f84:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1138f88:	a94363f7 	ldp	x23, x24, [sp, #48]
 1138f8c:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1138f90:	a8cb7bfd 	ldp	x29, x30, [sp], #176
 1138f94:	d65f03c0 	ret
      switch (type) {
 1138f98:	7100181f 	cmp	w0, #0x6
 1138f9c:	54002328 	b.hi	1139400 <ssh_encode_sequence_multi+0x520>  // b.pmore
 1138fa0:	b9407be1 	ldr	w1, [sp, #120]
 1138fa4:	f94033e3 	ldr	x3, [sp, #96]
 1138fa8:	38604a80 	ldrb	w0, [x20, w0, uxtw]
 1138fac:	10000062 	adr	x2, 1138fb8 <ssh_encode_sequence_multi+0xd8>
 1138fb0:	8b208840 	add	x0, x2, w0, sxtb #2
 1138fb4:	d61f0000 	br	x0
            LTC_UNUSED_PARAM( va_arg(args, int) );
 1138fb8:	37f800a1 	tbnz	w1, #31, 1138fcc <ssh_encode_sequence_multi+0xec>
 1138fbc:	91002c63 	add	x3, x3, #0xb
 1138fc0:	927df063 	and	x3, x3, #0xfffffffffffffff8
 1138fc4:	f90033e3 	str	x3, [sp, #96]
 1138fc8:	14000005 	b	1138fdc <ssh_encode_sequence_multi+0xfc>
 1138fcc:	11002021 	add	w1, w1, #0x8
 1138fd0:	b9007be1 	str	w1, [sp, #120]
 1138fd4:	7100003f 	cmp	w1, #0x0
 1138fd8:	54ffff2c 	b.gt	1138fbc <ssh_encode_sequence_multi+0xdc>
            size++;
 1138fdc:	11000718 	add	w24, w24, #0x1
            break;
 1138fe0:	17ffffd9 	b	1138f44 <ssh_encode_sequence_multi+0x64>
            LTC_UNUSED_PARAM( va_arg(args, ulong32) );
 1138fe4:	37f800a1 	tbnz	w1, #31, 1138ff8 <ssh_encode_sequence_multi+0x118>
 1138fe8:	91002c63 	add	x3, x3, #0xb
 1138fec:	927df063 	and	x3, x3, #0xfffffffffffffff8
 1138ff0:	f90033e3 	str	x3, [sp, #96]
 1138ff4:	14000005 	b	1139008 <ssh_encode_sequence_multi+0x128>
 1138ff8:	11002021 	add	w1, w1, #0x8
 1138ffc:	b9007be1 	str	w1, [sp, #120]
 1139000:	7100003f 	cmp	w1, #0x0
 1139004:	54ffff2c 	b.gt	1138fe8 <ssh_encode_sequence_multi+0x108>
            size += 4;
 1139008:	11001318 	add	w24, w24, #0x4
            break;
 113900c:	17ffffce 	b	1138f44 <ssh_encode_sequence_multi+0x64>
            LTC_UNUSED_PARAM( va_arg(args, ulong64) );
 1139010:	37f800a1 	tbnz	w1, #31, 1139024 <ssh_encode_sequence_multi+0x144>
 1139014:	91003c63 	add	x3, x3, #0xf
 1139018:	927df063 	and	x3, x3, #0xfffffffffffffff8
 113901c:	f90033e3 	str	x3, [sp, #96]
 1139020:	14000005 	b	1139034 <ssh_encode_sequence_multi+0x154>
 1139024:	11002021 	add	w1, w1, #0x8
 1139028:	b9007be1 	str	w1, [sp, #120]
 113902c:	7100003f 	cmp	w1, #0x0
 1139030:	54ffff2c 	b.gt	1139014 <ssh_encode_sequence_multi+0x134>
            size += 8;
 1139034:	11002318 	add	w24, w24, #0x8
            break;
 1139038:	17ffffc3 	b	1138f44 <ssh_encode_sequence_multi+0x64>
            sdata = va_arg(args, char*);
 113903c:	37f80121 	tbnz	w1, #31, 1139060 <ssh_encode_sequence_multi+0x180>
 1139040:	91003c60 	add	x0, x3, #0xf
 1139044:	927df000 	and	x0, x0, #0xfffffffffffffff8
 1139048:	f90033e0 	str	x0, [sp, #96]
            size += strlen(sdata);
 113904c:	f9400060 	ldr	x0, [x3]
            size += 4;
 1139050:	11001318 	add	w24, w24, #0x4
            size += strlen(sdata);
 1139054:	94002b33 	bl	1143d20 <strlen>
 1139058:	0b000318 	add	w24, w24, w0
            break;
 113905c:	17ffffba 	b	1138f44 <ssh_encode_sequence_multi+0x64>
            sdata = va_arg(args, char*);
 1139060:	11002020 	add	w0, w1, #0x8
 1139064:	b9007be0 	str	w0, [sp, #120]
 1139068:	7100001f 	cmp	w0, #0x0
 113906c:	54fffeac 	b.gt	1139040 <ssh_encode_sequence_multi+0x160>
 1139070:	f94037e3 	ldr	x3, [sp, #104]
 1139074:	8b21c063 	add	x3, x3, w1, sxtw
 1139078:	17fffff5 	b	113904c <ssh_encode_sequence_multi+0x16c>
            vdata = va_arg(args, void*);
 113907c:	37f802a1 	tbnz	w1, #31, 11390d0 <ssh_encode_sequence_multi+0x1f0>
 1139080:	91003c60 	add	x0, x3, #0xf
 1139084:	927df000 	and	x0, x0, #0xfffffffffffffff8
 1139088:	f90033e0 	str	x0, [sp, #96]
            if (mp_iszero(vdata) != LTC_MP_YES) {
 113908c:	f9403662 	ldr	x2, [x19, #104]
            size += 4;
 1139090:	11001318 	add	w24, w24, #0x4
            vdata = va_arg(args, void*);
 1139094:	f9400079 	ldr	x25, [x3]
            if (mp_iszero(vdata) != LTC_MP_YES) {
 1139098:	d2800001 	mov	x1, #0x0                   	// #0
 113909c:	aa1903e0 	mov	x0, x25
 11390a0:	d63f0040 	blr	x2
 11390a4:	34fff500 	cbz	w0, 1138f44 <ssh_encode_sequence_multi+0x64>
               size += mp_unsigned_bin_size(vdata);
 11390a8:	f9404e61 	ldr	x1, [x19, #152]
 11390ac:	aa1903e0 	mov	x0, x25
 11390b0:	d63f0020 	blr	x1
 11390b4:	0b000318 	add	w24, w24, w0
               if ((mp_count_bits(vdata) & 7) == 0) size++; /* Zero padding if high bit set */
 11390b8:	f9403a61 	ldr	x1, [x19, #112]
 11390bc:	aa1903e0 	mov	x0, x25
 11390c0:	d63f0020 	blr	x1
 11390c4:	f240081f 	tst	x0, #0x7
 11390c8:	1a981718 	cinc	w24, w24, eq  // eq = none
 11390cc:	17ffff9e 	b	1138f44 <ssh_encode_sequence_multi+0x64>
            vdata = va_arg(args, void*);
 11390d0:	11002020 	add	w0, w1, #0x8
 11390d4:	b9007be0 	str	w0, [sp, #120]
 11390d8:	7100001f 	cmp	w0, #0x0
 11390dc:	54fffd2c 	b.gt	1139080 <ssh_encode_sequence_multi+0x1a0>
 11390e0:	f94037e3 	ldr	x3, [sp, #104]
 11390e4:	8b21c063 	add	x3, x3, w1, sxtw
 11390e8:	17ffffe9 	b	113908c <ssh_encode_sequence_multi+0x1ac>
   while ((type = (ssh_data_type)va_arg(args, int)) != LTC_SSHDATA_EOL) {
 11390ec:	11002022 	add	w2, w1, #0x8
 11390f0:	b9007be2 	str	w2, [sp, #120]
 11390f4:	7100005f 	cmp	w2, #0x0
 11390f8:	54fff2cc 	b.gt	1138f50 <ssh_encode_sequence_multi+0x70>
 11390fc:	f94037e0 	ldr	x0, [sp, #104]
 1139100:	8b21c000 	add	x0, x0, w1, sxtw
 1139104:	17ffff96 	b	1138f5c <ssh_encode_sequence_multi+0x7c>
            if (mp_iszero(vdata) == LTC_MP_YES) {
 1139108:	b0000116 	adrp	x22, 115a000 <__scattered_array_1phys_mem_map+0x8>
   va_start(args, outlen);
 113910c:	f9003bf5 	str	x21, [sp, #112]
 1139110:	9102c3e0 	add	x0, sp, #0xb0
 1139114:	f00000b4 	adrp	x20, 1150000 <Te4+0x258>
            if (mp_iszero(vdata) == LTC_MP_YES) {
 1139118:	f941d6d5 	ldr	x21, [x22, #936]
 113911c:	910fc294 	add	x20, x20, #0x3f0
 1139120:	910163f3 	add	x19, sp, #0x58
   va_start(args, outlen);
 1139124:	a90603e0 	stp	x0, x0, [sp, #96]
 1139128:	128005e0 	mov	w0, #0xffffffd0            	// #-48
 113912c:	b9007be0 	str	w0, [sp, #120]
 1139130:	b9007fff 	str	wzr, [sp, #124]
   while ((type = (ssh_data_type)va_arg(args, int)) != LTC_SSHDATA_EOL) {
 1139134:	b9407be1 	ldr	w1, [sp, #120]
 1139138:	f94033e0 	ldr	x0, [sp, #96]
 113913c:	37f81501 	tbnz	w1, #31, 11393dc <ssh_encode_sequence_multi+0x4fc>
 1139140:	91002c01 	add	x1, x0, #0xb
 1139144:	927df021 	and	x1, x1, #0xfffffffffffffff8
 1139148:	f90033e1 	str	x1, [sp, #96]
 113914c:	b9400002 	ldr	w2, [x0]
 1139150:	71001c5f 	cmp	w2, #0x7
 1139154:	54000061 	b.ne	1139160 <ssh_encode_sequence_multi+0x280>  // b.any
   err = CRYPT_OK;
 1139158:	52800000 	mov	w0, #0x0                   	// #0
 113915c:	17ffff89 	b	1138f80 <ssh_encode_sequence_multi+0xa0>
      switch (type) {
 1139160:	7100185f 	cmp	w2, #0x6
 1139164:	540014e8 	b.hi	1139400 <ssh_encode_sequence_multi+0x520>  // b.pmore
 1139168:	b9407be0 	ldr	w0, [sp, #120]
 113916c:	f94033e1 	ldr	x1, [sp, #96]
 1139170:	38624a82 	ldrb	w2, [x20, w2, uxtw]
 1139174:	10000063 	adr	x3, 1139180 <ssh_encode_sequence_multi+0x2a0>
 1139178:	8b228862 	add	x2, x3, w2, sxtb #2
 113917c:	d61f0040 	br	x2
            idata = va_arg(args, int);
 1139180:	37f800e0 	tbnz	w0, #31, 113919c <ssh_encode_sequence_multi+0x2bc>
 1139184:	91002c20 	add	x0, x1, #0xb
 1139188:	927df000 	and	x0, x0, #0xfffffffffffffff8
 113918c:	f90033e0 	str	x0, [sp, #96]
            *out++ = (unsigned char)(idata & 255);
 1139190:	b9400020 	ldr	w0, [x1]
            *out++ = (idata)?1:0;
 1139194:	380016e0 	strb	w0, [x23], #1
            break;
 1139198:	17ffffe7 	b	1139134 <ssh_encode_sequence_multi+0x254>
            idata = va_arg(args, int);
 113919c:	11002002 	add	w2, w0, #0x8
 11391a0:	b9007be2 	str	w2, [sp, #120]
 11391a4:	7100005f 	cmp	w2, #0x0
 11391a8:	54fffeec 	b.gt	1139184 <ssh_encode_sequence_multi+0x2a4>
 11391ac:	f94037e1 	ldr	x1, [sp, #104]
 11391b0:	8b20c021 	add	x1, x1, w0, sxtw
 11391b4:	17fffff7 	b	1139190 <ssh_encode_sequence_multi+0x2b0>
            idata = va_arg(args, int);
 11391b8:	37f80100 	tbnz	w0, #31, 11391d8 <ssh_encode_sequence_multi+0x2f8>
 11391bc:	91002c20 	add	x0, x1, #0xb
 11391c0:	927df000 	and	x0, x0, #0xfffffffffffffff8
 11391c4:	f90033e0 	str	x0, [sp, #96]
            *out++ = (idata)?1:0;
 11391c8:	b9400020 	ldr	w0, [x1]
 11391cc:	7100001f 	cmp	w0, #0x0
 11391d0:	1a9f07e0 	cset	w0, ne  // ne = any
 11391d4:	17fffff0 	b	1139194 <ssh_encode_sequence_multi+0x2b4>
            idata = va_arg(args, int);
 11391d8:	11002002 	add	w2, w0, #0x8
 11391dc:	b9007be2 	str	w2, [sp, #120]
 11391e0:	7100005f 	cmp	w2, #0x0
 11391e4:	54fffecc 	b.gt	11391bc <ssh_encode_sequence_multi+0x2dc>
 11391e8:	f94037e1 	ldr	x1, [sp, #104]
 11391ec:	8b20c021 	add	x1, x1, w0, sxtw
 11391f0:	17fffff6 	b	11391c8 <ssh_encode_sequence_multi+0x2e8>
            u32data = va_arg(args, ulong32);
 11391f4:	37f801a0 	tbnz	w0, #31, 1139228 <ssh_encode_sequence_multi+0x348>
 11391f8:	91002c20 	add	x0, x1, #0xb
 11391fc:	927df000 	and	x0, x0, #0xfffffffffffffff8
 1139200:	f90033e0 	str	x0, [sp, #96]
            STORE32H(u32data, out);
 1139204:	b9400020 	ldr	w0, [x1]
 1139208:	5ac00800 	rev	w0, w0
 113920c:	b9005be0 	str	w0, [sp, #88]
               STORE32H(0, out);
 1139210:	aa1703e0 	mov	x0, x23
 1139214:	aa1303e1 	mov	x1, x19
 1139218:	d2800082 	mov	x2, #0x4                   	// #4
               out += 4;
 113921c:	910012f7 	add	x23, x23, #0x4
               STORE32H(0, out);
 1139220:	97ff285c 	bl	1103390 <memcpy>
               out += 4;
 1139224:	17ffffc4 	b	1139134 <ssh_encode_sequence_multi+0x254>
            u32data = va_arg(args, ulong32);
 1139228:	11002002 	add	w2, w0, #0x8
 113922c:	b9007be2 	str	w2, [sp, #120]
 1139230:	7100005f 	cmp	w2, #0x0
 1139234:	54fffe2c 	b.gt	11391f8 <ssh_encode_sequence_multi+0x318>
 1139238:	f94037e1 	ldr	x1, [sp, #104]
 113923c:	8b20c021 	add	x1, x1, w0, sxtw
 1139240:	17fffff1 	b	1139204 <ssh_encode_sequence_multi+0x324>
            u64data = va_arg(args, ulong64);
 1139244:	37f801a0 	tbnz	w0, #31, 1139278 <ssh_encode_sequence_multi+0x398>
 1139248:	91003c20 	add	x0, x1, #0xf
 113924c:	927df000 	and	x0, x0, #0xfffffffffffffff8
 1139250:	f90033e0 	str	x0, [sp, #96]
            STORE64H(u64data, out);
 1139254:	f9400020 	ldr	x0, [x1]
 1139258:	d2800102 	mov	x2, #0x8                   	// #8
 113925c:	aa1303e1 	mov	x1, x19
 1139260:	dac00c00 	rev	x0, x0
 1139264:	f9002fe0 	str	x0, [sp, #88]
 1139268:	aa1703e0 	mov	x0, x23
            out += 8;
 113926c:	910022f7 	add	x23, x23, #0x8
            STORE64H(u64data, out);
 1139270:	97ff2848 	bl	1103390 <memcpy>
            break;
 1139274:	17ffffb0 	b	1139134 <ssh_encode_sequence_multi+0x254>
            u64data = va_arg(args, ulong64);
 1139278:	11002002 	add	w2, w0, #0x8
 113927c:	b9007be2 	str	w2, [sp, #120]
 1139280:	7100005f 	cmp	w2, #0x0
 1139284:	54fffe2c 	b.gt	1139248 <ssh_encode_sequence_multi+0x368>
 1139288:	f94037e1 	ldr	x1, [sp, #104]
 113928c:	8b20c021 	add	x1, x1, w0, sxtw
 1139290:	17fffff1 	b	1139254 <ssh_encode_sequence_multi+0x374>
            sdata = va_arg(args, char*);
 1139294:	37f802c0 	tbnz	w0, #31, 11392ec <ssh_encode_sequence_multi+0x40c>
 1139298:	91003c20 	add	x0, x1, #0xf
 113929c:	927df000 	and	x0, x0, #0xfffffffffffffff8
 11392a0:	f90033e0 	str	x0, [sp, #96]
 11392a4:	f9400039 	ldr	x25, [x1]
            size = strlen(sdata);
 11392a8:	aa1903e0 	mov	x0, x25
 11392ac:	94002a9d 	bl	1143d20 <strlen>
 11392b0:	aa0003f8 	mov	x24, x0
            STORE32H(size, out);
 11392b4:	5ac00800 	rev	w0, w0
 11392b8:	aa1303e1 	mov	x1, x19
 11392bc:	92407f18 	and	x24, x24, #0xffffffff
 11392c0:	d2800082 	mov	x2, #0x4                   	// #4
 11392c4:	b9005be0 	str	w0, [sp, #88]
 11392c8:	aa1703e0 	mov	x0, x23
            out += 4;
 11392cc:	910012f7 	add	x23, x23, #0x4
            STORE32H(size, out);
 11392d0:	97ff2830 	bl	1103390 <memcpy>
            XMEMCPY(out, sdata, size);
 11392d4:	aa1703e0 	mov	x0, x23
 11392d8:	aa1803e2 	mov	x2, x24
 11392dc:	aa1903e1 	mov	x1, x25
            out += size;
 11392e0:	8b1802f7 	add	x23, x23, x24
            XMEMCPY(out, sdata, size);
 11392e4:	97ff282b 	bl	1103390 <memcpy>
            break;
 11392e8:	17ffff93 	b	1139134 <ssh_encode_sequence_multi+0x254>
            sdata = va_arg(args, char*);
 11392ec:	11002002 	add	w2, w0, #0x8
 11392f0:	b9007be2 	str	w2, [sp, #120]
 11392f4:	7100005f 	cmp	w2, #0x0
 11392f8:	54fffd0c 	b.gt	1139298 <ssh_encode_sequence_multi+0x3b8>
 11392fc:	f94037e1 	ldr	x1, [sp, #104]
 1139300:	8b20c021 	add	x1, x1, w0, sxtw
 1139304:	17ffffe8 	b	11392a4 <ssh_encode_sequence_multi+0x3c4>
            vdata = va_arg(args, void*);
 1139308:	37f80180 	tbnz	w0, #31, 1139338 <ssh_encode_sequence_multi+0x458>
 113930c:	91003c20 	add	x0, x1, #0xf
 1139310:	927df000 	and	x0, x0, #0xfffffffffffffff8
 1139314:	f90033e0 	str	x0, [sp, #96]
            if (mp_iszero(vdata) == LTC_MP_YES) {
 1139318:	f94036a2 	ldr	x2, [x21, #104]
            vdata = va_arg(args, void*);
 113931c:	f9400039 	ldr	x25, [x1]
            if (mp_iszero(vdata) == LTC_MP_YES) {
 1139320:	d2800001 	mov	x1, #0x0                   	// #0
 1139324:	aa1903e0 	mov	x0, x25
 1139328:	d63f0040 	blr	x2
 113932c:	35000140 	cbnz	w0, 1139354 <ssh_encode_sequence_multi+0x474>
               STORE32H(0, out);
 1139330:	b9005bff 	str	wzr, [sp, #88]
 1139334:	17ffffb7 	b	1139210 <ssh_encode_sequence_multi+0x330>
            vdata = va_arg(args, void*);
 1139338:	11002002 	add	w2, w0, #0x8
 113933c:	b9007be2 	str	w2, [sp, #120]
 1139340:	7100005f 	cmp	w2, #0x0
 1139344:	54fffe4c 	b.gt	113930c <ssh_encode_sequence_multi+0x42c>
 1139348:	f94037e1 	ldr	x1, [sp, #104]
 113934c:	8b20c021 	add	x1, x1, w0, sxtw
 1139350:	17fffff2 	b	1139318 <ssh_encode_sequence_multi+0x438>
               size = mp_unsigned_bin_size(vdata);
 1139354:	f9404ea1 	ldr	x1, [x21, #152]
 1139358:	aa1903e0 	mov	x0, x25
 113935c:	d63f0020 	blr	x1
 1139360:	aa0003f8 	mov	x24, x0
               if ((mp_count_bits(vdata) & 7) == 0) {
 1139364:	f9403aa1 	ldr	x1, [x21, #112]
 1139368:	aa1903e0 	mov	x0, x25
 113936c:	d63f0020 	blr	x1
 1139370:	f240081f 	tst	x0, #0x7
 1139374:	54000241 	b.ne	11393bc <ssh_encode_sequence_multi+0x4dc>  // b.any
                  STORE32H(size+1, out);
 1139378:	11000700 	add	w0, w24, #0x1
                  *out++ = 0;
 113937c:	910016fa 	add	x26, x23, #0x5
                  STORE32H(size+1, out);
 1139380:	5ac00800 	rev	w0, w0
 1139384:	aa1303e1 	mov	x1, x19
 1139388:	d2800082 	mov	x2, #0x4                   	// #4
 113938c:	b9005be0 	str	w0, [sp, #88]
 1139390:	aa1703e0 	mov	x0, x23
 1139394:	97ff27ff 	bl	1103390 <memcpy>
                  *out++ = 0;
 1139398:	390012ff 	strb	wzr, [x23, #4]
               if ((err = mp_to_unsigned_bin(vdata, out)) != CRYPT_OK) {
 113939c:	f941d6c0 	ldr	x0, [x22, #936]
 11393a0:	aa1a03e1 	mov	x1, x26
 11393a4:	f9405002 	ldr	x2, [x0, #160]
 11393a8:	aa1903e0 	mov	x0, x25
 11393ac:	d63f0040 	blr	x2
 11393b0:	35000240 	cbnz	w0, 11393f8 <ssh_encode_sequence_multi+0x518>
               out += size;
 11393b4:	8b384357 	add	x23, x26, w24, uxtw
 11393b8:	17ffff5f 	b	1139134 <ssh_encode_sequence_multi+0x254>
                  STORE32H(size, out);
 11393bc:	5ac00b00 	rev	w0, w24
 11393c0:	aa1303e1 	mov	x1, x19
                  out += 4;
 11393c4:	910012fa 	add	x26, x23, #0x4
                  STORE32H(size, out);
 11393c8:	d2800082 	mov	x2, #0x4                   	// #4
 11393cc:	b9005be0 	str	w0, [sp, #88]
 11393d0:	aa1703e0 	mov	x0, x23
 11393d4:	97ff27ef 	bl	1103390 <memcpy>
                  out += 4;
 11393d8:	17fffff1 	b	113939c <ssh_encode_sequence_multi+0x4bc>
   while ((type = (ssh_data_type)va_arg(args, int)) != LTC_SSHDATA_EOL) {
 11393dc:	11002022 	add	w2, w1, #0x8
 11393e0:	b9007be2 	str	w2, [sp, #120]
 11393e4:	7100005f 	cmp	w2, #0x0
 11393e8:	54ffeacc 	b.gt	1139140 <ssh_encode_sequence_multi+0x260>
 11393ec:	f94037e0 	ldr	x0, [sp, #104]
 11393f0:	8b21c000 	add	x0, x0, w1, sxtw
 11393f4:	17ffff56 	b	113914c <ssh_encode_sequence_multi+0x26c>
                  err = CRYPT_ERROR;
 11393f8:	52800020 	mov	w0, #0x1                   	// #1
 11393fc:	17fffee1 	b	1138f80 <ssh_encode_sequence_multi+0xa0>
   LTC_ARGCHK(out    != NULL);
 1139400:	52800200 	mov	w0, #0x10                  	// #16
 1139404:	17fffedf 	b	1138f80 <ssh_encode_sequence_multi+0xa0>

0000000001139408 <der_decode_sequence_ex>:
   @return CRYPT_OK on success
*/
int der_decode_sequence_ex(const unsigned char *in, unsigned long  inlen,
                           ltc_asn1_list *list,     unsigned long  outlen, unsigned int flags)
{
   return der_decode_custom_type_ex(in, inlen, NULL, list, outlen, flags);
 1139408:	2a0403e5 	mov	w5, w4
 113940c:	aa0303e4 	mov	x4, x3
 1139410:	aa0203e3 	mov	x3, x2
 1139414:	d2800002 	mov	x2, #0x0                   	// #0
 1139418:	14000bbb 	b	113c304 <der_decode_custom_type_ex>

000000000113941c <_der_decode_sequence_va>:
  @param a2    Initialized argument list #2 (copy of #1)
  @param flags    c.f. enum ltc_der_seq
  @return CRYPT_OK on success
*/
static int _der_decode_sequence_va(const unsigned char *in, unsigned long inlen, va_list a1, va_list a2, unsigned int flags)
{
 113941c:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 1139420:	910003fd 	mov	x29, sp
 1139424:	b9401845 	ldr	w5, [x2, #24]
 1139428:	a90153f3 	stp	x19, x20, [sp, #16]
 113942c:	a9025bf5 	stp	x21, x22, [sp, #32]
 1139430:	b9401875 	ldr	w21, [x3, #24]
 1139434:	a90363f7 	stp	x23, x24, [sp, #48]
 1139438:	f9400046 	ldr	x6, [x2]
 113943c:	a9406073 	ldp	x19, x24, [x3]
 1139440:	f90023f9 	str	x25, [sp, #64]
 1139444:	2a0403f9 	mov	w25, w4
 1139448:	f9400444 	ldr	x4, [x2, #8]
   ltc_asn1_type type;
   unsigned long size, x;
   void          *data;
   ltc_asn1_list *list;

   LTC_ARGCHK(in    != NULL);
 113944c:	b4000f20 	cbz	x0, 1139630 <_der_decode_sequence_va+0x214>
 1139450:	aa0003f6 	mov	x22, x0
 1139454:	aa0103f7 	mov	x23, x1

   /* get size of output that will be required */
   x = 0;
 1139458:	d2800001 	mov	x1, #0x0                   	// #0
   for (;;) {
       type = (ltc_asn1_type)va_arg(a1, int);
 113945c:	37f80185 	tbnz	w5, #31, 113948c <_der_decode_sequence_va+0x70>
 1139460:	91002cc2 	add	x2, x6, #0xb
 1139464:	2a0503e3 	mov	w3, w5
 1139468:	927df042 	and	x2, x2, #0xfffffffffffffff8
 113946c:	b94000c0 	ldr	w0, [x6]
       size = va_arg(a1, unsigned long);
 1139470:	37f80203 	tbnz	w3, #31, 11394b0 <_der_decode_sequence_va+0x94>
 1139474:	91003c42 	add	x2, x2, #0xf
 1139478:	2a0303e5 	mov	w5, w3
 113947c:	927df042 	and	x2, x2, #0xfffffffffffffff8
       data = va_arg(a1, void*);
 1139480:	91003c42 	add	x2, x2, #0xf
 1139484:	927df042 	and	x2, x2, #0xfffffffffffffff8
 1139488:	14000014 	b	11394d8 <_der_decode_sequence_va+0xbc>
       type = (ltc_asn1_type)va_arg(a1, int);
 113948c:	110020a3 	add	w3, w5, #0x8
 1139490:	7100007f 	cmp	w3, #0x0
 1139494:	5400008d 	b.le	11394a4 <_der_decode_sequence_va+0x88>
 1139498:	91002cc2 	add	x2, x6, #0xb
 113949c:	927df042 	and	x2, x2, #0xfffffffffffffff8
 11394a0:	17fffff3 	b	113946c <_der_decode_sequence_va+0x50>
 11394a4:	aa0603e2 	mov	x2, x6
 11394a8:	8b25c086 	add	x6, x4, w5, sxtw
 11394ac:	17fffff0 	b	113946c <_der_decode_sequence_va+0x50>
       size = va_arg(a1, unsigned long);
 11394b0:	11002065 	add	w5, w3, #0x8
 11394b4:	710000bf 	cmp	w5, #0x0
 11394b8:	5400008d 	b.le	11394c8 <_der_decode_sequence_va+0xac>
 11394bc:	91003c42 	add	x2, x2, #0xf
 11394c0:	927df042 	and	x2, x2, #0xfffffffffffffff8
 11394c4:	17ffffef 	b	1139480 <_der_decode_sequence_va+0x64>
       data = va_arg(a1, void*);
 11394c8:	54fffdc0 	b.eq	1139480 <_der_decode_sequence_va+0x64>  // b.none
 11394cc:	11004065 	add	w5, w3, #0x10
 11394d0:	710000bf 	cmp	w5, #0x0
 11394d4:	54fffd6c 	b.gt	1139480 <_der_decode_sequence_va+0x64>
       LTC_UNUSED_PARAM(size);
       LTC_UNUSED_PARAM(data);

       if (type == LTC_ASN1_EOL) {
 11394d8:	340000e0 	cbz	w0, 11394f4 <_der_decode_sequence_va+0xd8>
          break;
       }

       switch (type) {
 11394dc:	51000400 	sub	w0, w0, #0x1
 11394e0:	7100441f 	cmp	w0, #0x11
 11394e4:	54000a68 	b.hi	1139630 <_der_decode_sequence_va+0x214>  // b.pmore
           case LTC_ASN1_SEQUENCE:
           case LTC_ASN1_CHOICE:
           case LTC_ASN1_RAW_BIT_STRING:
           case LTC_ASN1_TELETEX_STRING:
           case LTC_ASN1_GENERALIZEDTIME:
                ++x;
 11394e8:	91000421 	add	x1, x1, #0x1
       type = (ltc_asn1_type)va_arg(a1, int);
 11394ec:	aa0203e6 	mov	x6, x2
 11394f0:	17ffffdb 	b	113945c <_der_decode_sequence_va+0x40>
               return CRYPT_INVALID_ARG;
       }
   }

   /* allocate structure for x elements */
   if (x == 0) {
 11394f4:	b4000a21 	cbz	x1, 1139638 <_der_decode_sequence_va+0x21c>
      return CRYPT_NOP;
   }

   list = XCALLOC(sizeof(*list), x);
 11394f8:	d2800a00 	mov	x0, #0x50                  	// #80
 11394fc:	940027f5 	bl	11434d0 <calloc>
 1139500:	aa0003f4 	mov	x20, x0
   if (list == NULL) {
 1139504:	b40009e0 	cbz	x0, 1139640 <_der_decode_sequence_va+0x224>
      return CRYPT_MEM;
   }

   /* fill in the structure */
   x = 0;
 1139508:	d2800003 	mov	x3, #0x0                   	// #0
           case LTC_ASN1_SETOF:
           case LTC_ASN1_CHOICE:
           case LTC_ASN1_RAW_BIT_STRING:
           case LTC_ASN1_TELETEX_STRING:
           case LTC_ASN1_GENERALIZEDTIME:
                LTC_SET_ASN1(list, x++, type, data, size);
 113950c:	52800a07 	mov	w7, #0x50                  	// #80
       type = (ltc_asn1_type)va_arg(a2, int);
 1139510:	37f80195 	tbnz	w21, #31, 1139540 <_der_decode_sequence_va+0x124>
 1139514:	91002e65 	add	x5, x19, #0xb
 1139518:	2a1503e6 	mov	w6, w21
 113951c:	927df0a5 	and	x5, x5, #0xfffffffffffffff8
 1139520:	b9400264 	ldr	w4, [x19]
       size = va_arg(a2, unsigned long);
 1139524:	37f80206 	tbnz	w6, #31, 1139564 <_der_decode_sequence_va+0x148>
 1139528:	91003ca2 	add	x2, x5, #0xf
 113952c:	927df042 	and	x2, x2, #0xfffffffffffffff8
       type = (ltc_asn1_type)va_arg(a2, int);
 1139530:	aa0503e1 	mov	x1, x5
 1139534:	2a0603e0 	mov	w0, w6
 1139538:	aa0203e5 	mov	x5, x2
 113953c:	14000013 	b	1139588 <_der_decode_sequence_va+0x16c>
 1139540:	110022a6 	add	w6, w21, #0x8
 1139544:	710000df 	cmp	w6, #0x0
 1139548:	5400008d 	b.le	1139558 <_der_decode_sequence_va+0x13c>
 113954c:	91002e65 	add	x5, x19, #0xb
 1139550:	927df0a5 	and	x5, x5, #0xfffffffffffffff8
 1139554:	17fffff3 	b	1139520 <_der_decode_sequence_va+0x104>
 1139558:	aa1303e5 	mov	x5, x19
 113955c:	8b35c313 	add	x19, x24, w21, sxtw
 1139560:	17fffff0 	b	1139520 <_der_decode_sequence_va+0x104>
       size = va_arg(a2, unsigned long);
 1139564:	110020c0 	add	w0, w6, #0x8
 1139568:	7100001f 	cmp	w0, #0x0
 113956c:	540000ad 	b.le	1139580 <_der_decode_sequence_va+0x164>
 1139570:	91003ca2 	add	x2, x5, #0xf
 1139574:	2a0003e6 	mov	w6, w0
 1139578:	927df042 	and	x2, x2, #0xfffffffffffffff8
 113957c:	17ffffed 	b	1139530 <_der_decode_sequence_va+0x114>
 1139580:	8b26c301 	add	x1, x24, w6, sxtw
       data = va_arg(a2, void*);
 1139584:	54000261 	b.ne	11395d0 <_der_decode_sequence_va+0x1b4>  // b.any
 1139588:	91003cb3 	add	x19, x5, #0xf
 113958c:	2a0003f5 	mov	w21, w0
 1139590:	927df273 	and	x19, x19, #0xfffffffffffffff8
       if (type == LTC_ASN1_EOL) {
 1139594:	34000304 	cbz	w4, 11395f4 <_der_decode_sequence_va+0x1d8>
       switch (type) {
 1139598:	51000480 	sub	w0, w4, #0x1
 113959c:	7100441f 	cmp	w0, #0x11
 11395a0:	54fffb88 	b.hi	1139510 <_der_decode_sequence_va+0xf4>  // b.pmore
                LTC_SET_ASN1(list, x++, type, data, size);
 11395a4:	91000463 	add	x3, x3, #0x1
       size = va_arg(a2, unsigned long);
 11395a8:	f9400022 	ldr	x2, [x1]
                LTC_SET_ASN1(list, x++, type, data, size);
 11395ac:	51000461 	sub	w1, w3, #0x1
       data = va_arg(a2, void*);
 11395b0:	f94000a5 	ldr	x5, [x5]
                LTC_SET_ASN1(list, x++, type, data, size);
 11395b4:	9b277c21 	smull	x1, w1, w7
 11395b8:	8b010280 	add	x0, x20, x1
 11395bc:	b8216a84 	str	w4, [x20, x1]
 11395c0:	a9008805 	stp	x5, x2, [x0, #8]
 11395c4:	a901fc1f 	stp	xzr, xzr, [x0, #24]
 11395c8:	f900141f 	str	xzr, [x0, #40]
                break;
 11395cc:	17ffffd1 	b	1139510 <_der_decode_sequence_va+0xf4>
       data = va_arg(a2, void*);
 11395d0:	110040d5 	add	w21, w6, #0x10
 11395d4:	710002bf 	cmp	w21, #0x0
 11395d8:	5400008d 	b.le	11395e8 <_der_decode_sequence_va+0x1cc>
 11395dc:	91003cb3 	add	x19, x5, #0xf
 11395e0:	927df273 	and	x19, x19, #0xfffffffffffffff8
 11395e4:	17ffffec 	b	1139594 <_der_decode_sequence_va+0x178>
 11395e8:	aa0503f3 	mov	x19, x5
 11395ec:	8b20c305 	add	x5, x24, w0, sxtw
 11395f0:	17ffffe9 	b	1139594 <_der_decode_sequence_va+0x178>
           default:
                break;
       }
   }

   err = der_decode_sequence_ex(in, inlen, list, x, flags);
 11395f4:	2a1903e4 	mov	w4, w25
 11395f8:	aa1403e2 	mov	x2, x20
 11395fc:	aa1703e1 	mov	x1, x23
 1139600:	aa1603e0 	mov	x0, x22
 1139604:	97ffff81 	bl	1139408 <der_decode_sequence_ex>
 1139608:	2a0003f3 	mov	w19, w0
   XFREE(list);
 113960c:	aa1403e0 	mov	x0, x20
 1139610:	940027f4 	bl	11435e0 <free>
   return err;
}
 1139614:	2a1303e0 	mov	w0, w19
 1139618:	a94153f3 	ldp	x19, x20, [sp, #16]
 113961c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1139620:	a94363f7 	ldp	x23, x24, [sp, #48]
 1139624:	f94023f9 	ldr	x25, [sp, #64]
 1139628:	a8c57bfd 	ldp	x29, x30, [sp], #80
 113962c:	d65f03c0 	ret
   LTC_ARGCHK(in    != NULL);
 1139630:	52800213 	mov	w19, #0x10                  	// #16
 1139634:	17fffff8 	b	1139614 <_der_decode_sequence_va+0x1f8>
      return CRYPT_NOP;
 1139638:	52800053 	mov	w19, #0x2                   	// #2
 113963c:	17fffff6 	b	1139614 <_der_decode_sequence_va+0x1f8>
      return CRYPT_MEM;
 1139640:	528001b3 	mov	w19, #0xd                   	// #13
 1139644:	17fffff4 	b	1139614 <_der_decode_sequence_va+0x1f8>

0000000001139648 <der_decode_sequence_multi_ex>:
  @param flags c.f. enum ltc_der_seq
  @remark <...> is of the form <type, size, data> (int, unsigned long, void*)
  @return CRYPT_OK on success
*/
int der_decode_sequence_multi_ex(const unsigned char *in, unsigned long inlen, unsigned int flags, ...)
{
 1139648:	a9b47bfd 	stp	x29, x30, [sp, #-192]!
 113964c:	910003fd 	mov	x29, sp
 1139650:	a90993e3 	stp	x3, x4, [sp, #152]
 1139654:	a90a9be5 	stp	x5, x6, [sp, #168]
 1139658:	f9005fe7 	str	x7, [sp, #184]
   va_list       a1, a2;
   int err;

   LTC_ARGCHK(in    != NULL);
 113965c:	b4000360 	cbz	x0, 11396c8 <der_decode_sequence_multi_ex+0x80>

   va_start(a1, flags);
 1139660:	910303e3 	add	x3, sp, #0xc0
 1139664:	a9050fe3 	stp	x3, x3, [sp, #80]
 1139668:	910243e4 	add	x4, sp, #0x90
 113966c:	128004e3 	mov	w3, #0xffffffd8            	// #-40
   va_start(a2, flags);
 1139670:	910303e5 	add	x5, sp, #0xc0
   va_start(a1, flags);
 1139674:	f90033e4 	str	x4, [sp, #96]
 1139678:	b9006be3 	str	w3, [sp, #104]
 113967c:	b9006fff 	str	wzr, [sp, #108]
   va_start(a2, flags);
 1139680:	a90717e5 	stp	x5, x5, [sp, #112]
 1139684:	f90043e4 	str	x4, [sp, #128]

   err = _der_decode_sequence_va(in, inlen, a1, a2, flags);
 1139688:	a94517e4 	ldp	x4, x5, [sp, #80]
 113968c:	a90317e4 	stp	x4, x5, [sp, #48]
   va_start(a2, flags);
 1139690:	b9008be3 	str	w3, [sp, #136]
   err = _der_decode_sequence_va(in, inlen, a1, a2, flags);
 1139694:	910043e3 	add	x3, sp, #0x10
   va_start(a2, flags);
 1139698:	b9008fff 	str	wzr, [sp, #140]
   err = _der_decode_sequence_va(in, inlen, a1, a2, flags);
 113969c:	a94617e4 	ldp	x4, x5, [sp, #96]
 11396a0:	a90417e4 	stp	x4, x5, [sp, #64]
 11396a4:	a94717e4 	ldp	x4, x5, [sp, #112]
 11396a8:	a90117e4 	stp	x4, x5, [sp, #16]
 11396ac:	a94817e4 	ldp	x4, x5, [sp, #128]
 11396b0:	a90217e4 	stp	x4, x5, [sp, #32]
 11396b4:	2a0203e4 	mov	w4, w2
 11396b8:	9100c3e2 	add	x2, sp, #0x30
 11396bc:	97ffff58 	bl	113941c <_der_decode_sequence_va>

   va_end(a2);
   va_end(a1);

   return err;
}
 11396c0:	a8cc7bfd 	ldp	x29, x30, [sp], #192
 11396c4:	d65f03c0 	ret
   LTC_ARGCHK(in    != NULL);
 11396c8:	52800200 	mov	w0, #0x10                  	// #16
 11396cc:	17fffffd 	b	11396c0 <der_decode_sequence_multi_ex+0x78>

00000000011396d0 <der_encode_sequence_ex>:
   @param type_of   LTC_ASN1_SEQUENCE or LTC_ASN1_SET/LTC_ASN1_SETOF
   @return CRYPT_OK on success
*/
int der_encode_sequence_ex(const ltc_asn1_list *list, unsigned long inlen,
                           unsigned char *out,        unsigned long *outlen, int type_of)
{
 11396d0:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
 11396d4:	910003fd 	mov	x29, sp
 11396d8:	a90153f3 	stp	x19, x20, [sp, #16]
 11396dc:	a9025bf5 	stp	x21, x22, [sp, #32]
 11396e0:	a90363f7 	stp	x23, x24, [sp, #48]
 11396e4:	a9046bf9 	stp	x25, x26, [sp, #64]
 11396e8:	a90573fb 	stp	x27, x28, [sp, #80]
 11396ec:	f90037e1 	str	x1, [sp, #104]
   int           err;
   ltc_asn1_type type;
   unsigned long size, x, y, z, i;
   void          *data;

   LTC_ARGCHK(list    != NULL);
 11396f0:	b5000060 	cbnz	x0, 11396fc <der_encode_sequence_ex+0x2c>
   for (i = 0; i < inlen; i++) {
       type = list[i].type;
       size = list[i].size;
       data = list[i].data;

       if (type == LTC_ASN1_EOL) {
 11396f4:	52800214 	mov	w20, #0x10                  	// #16
 11396f8:	14000014 	b	1139748 <der_encode_sequence_ex+0x78>
 11396fc:	aa0203f5 	mov	x21, x2
   LTC_ARGCHK(out     != NULL);
 1139700:	b4ffffa2 	cbz	x2, 11396f4 <der_encode_sequence_ex+0x24>
 1139704:	aa0303f8 	mov	x24, x3
   LTC_ARGCHK(outlen  != NULL);
 1139708:	b4ffff63 	cbz	x3, 11396f4 <der_encode_sequence_ex+0x24>
   if ((err = der_length_sequence_ex(list, inlen, &y, &z)) != CRYPT_OK) return CRYPT_INVALID_ARG;
 113970c:	9101e3f6 	add	x22, sp, #0x78
 1139710:	9101c3f4 	add	x20, sp, #0x70
 1139714:	aa0003f7 	mov	x23, x0
 1139718:	2a0403f3 	mov	w19, w4
 113971c:	aa1603e3 	mov	x3, x22
 1139720:	aa1403e2 	mov	x2, x20
   y = 0; z = 0;
 1139724:	a9077fff 	stp	xzr, xzr, [sp, #112]
   if ((err = der_length_sequence_ex(list, inlen, &y, &z)) != CRYPT_OK) return CRYPT_INVALID_ARG;
 1139728:	94000144 	bl	1139c38 <der_length_sequence_ex>
 113972c:	35fffe40 	cbnz	w0, 11396f4 <der_encode_sequence_ex+0x24>
   if (*outlen < y) {
 1139730:	f9400301 	ldr	x1, [x24]
 1139734:	f9403be0 	ldr	x0, [sp, #112]
 1139738:	eb00003f 	cmp	x1, x0
 113973c:	54000162 	b.cs	1139768 <der_encode_sequence_ex+0x98>  // b.hs, b.nlast
      err = CRYPT_BUFFER_OVERFLOW;
 1139740:	528000d4 	mov	w20, #0x6                   	// #6
      *outlen = y;
 1139744:	f9000300 	str	x0, [x24]
   *outlen = x;
   err = CRYPT_OK;

LBL_ERR:
   return err;
}
 1139748:	2a1403e0 	mov	w0, w20
 113974c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1139750:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1139754:	a94363f7 	ldp	x23, x24, [sp, #48]
 1139758:	a9446bf9 	ldp	x25, x26, [sp, #64]
 113975c:	a94573fb 	ldp	x27, x28, [sp, #80]
 1139760:	a8c87bfd 	ldp	x29, x30, [sp], #128
 1139764:	d65f03c0 	ret
   out[x++] = (type_of == LTC_ASN1_SEQUENCE) ? 0x30 : 0x31;
 1139768:	aa1503e1 	mov	x1, x21
 113976c:	7100367f 	cmp	w19, #0xd
 1139770:	1a9f07e0 	cset	w0, ne  // ne = any
   if ((err = der_encode_asn1_length(z, &out[x], &y)) != CRYPT_OK) {
 1139774:	aa1403e2 	mov	x2, x20
   out[x++] = (type_of == LTC_ASN1_SEQUENCE) ? 0x30 : 0x31;
 1139778:	1100c000 	add	w0, w0, #0x30
 113977c:	38001420 	strb	w0, [x1], #1
   y = *outlen - x;
 1139780:	f9400300 	ldr	x0, [x24]
 1139784:	d1000400 	sub	x0, x0, #0x1
 1139788:	f9003be0 	str	x0, [sp, #112]
   if ((err = der_encode_asn1_length(z, &out[x], &y)) != CRYPT_OK) {
 113978c:	f9403fe0 	ldr	x0, [sp, #120]
 1139790:	94000ebc 	bl	113d280 <der_encode_asn1_length>
 1139794:	2a0003f4 	mov	w20, w0
 1139798:	35fffd80 	cbnz	w0, 1139748 <der_encode_sequence_ex+0x78>
   x += y;
 113979c:	f9403bf3 	ldr	x19, [sp, #112]
 11397a0:	f00000ba 	adrp	x26, 1150000 <Te4+0x258>
   *outlen -= x;
 11397a4:	f9400300 	ldr	x0, [x24]
   x += y;
 11397a8:	91000673 	add	x19, x19, #0x1
   *outlen -= x;
 11397ac:	910fe35a 	add	x26, x26, #0x3f8
   for (i = 0; i < inlen; i++) {
 11397b0:	d2800019 	mov	x25, #0x0                   	// #0
   *outlen -= x;
 11397b4:	cb130000 	sub	x0, x0, x19
               out[x] = 0x05;
 11397b8:	528000bb 	mov	w27, #0x5                   	// #5
               z = 2;
 11397bc:	d280005c 	mov	x28, #0x2                   	// #2
   *outlen -= x;
 11397c0:	f9000300 	str	x0, [x24]
   for (i = 0; i < inlen; i++) {
 11397c4:	f94037e0 	ldr	x0, [sp, #104]
 11397c8:	eb00033f 	cmp	x25, x0
 11397cc:	54000080 	b.eq	11397dc <der_encode_sequence_ex+0x10c>  // b.none
       type = list[i].type;
 11397d0:	b94002e2 	ldr	w2, [x23]
       size = list[i].size;
 11397d4:	a94086e0 	ldp	x0, x1, [x23, #8]
       if (type == LTC_ASN1_EOL) {
 11397d8:	35000062 	cbnz	w2, 11397e4 <der_encode_sequence_ex+0x114>
   *outlen = x;
 11397dc:	f9000313 	str	x19, [x24]
   err = CRYPT_OK;
 11397e0:	17ffffda 	b	1139748 <der_encode_sequence_ex+0x78>
       switch (type) {
 11397e4:	51000442 	sub	w2, w2, #0x1
 11397e8:	7100485f 	cmp	w2, #0x12
 11397ec:	54fff848 	b.hi	11396f4 <der_encode_sequence_ex+0x24>  // b.pmore
 11397f0:	38624b42 	ldrb	w2, [x26, w2, uxtw]
 11397f4:	10000063 	adr	x3, 1139800 <der_encode_sequence_ex+0x130>
 11397f8:	8b228862 	add	x2, x3, w2, sxtb #2
 11397fc:	d61f0040 	br	x2
               if ((err = der_encode_boolean(*((int *)data), out + x, &z)) != CRYPT_OK) {
 1139800:	b9400000 	ldr	w0, [x0]
 1139804:	aa1603e2 	mov	x2, x22
               z = *outlen;
 1139808:	f9400301 	ldr	x1, [x24]
 113980c:	f9003fe1 	str	x1, [sp, #120]
               if ((err = der_encode_boolean(*((int *)data), out + x, &z)) != CRYPT_OK) {
 1139810:	8b1302a1 	add	x1, x21, x19
 1139814:	94000aa2 	bl	113c29c <der_encode_boolean>
               if ((err = der_encode_custom_type(&list[i], out + x, &z)) != CRYPT_OK) {
 1139818:	340004c0 	cbz	w0, 11398b0 <der_encode_sequence_ex+0x1e0>
 113981c:	2a0003f4 	mov	w20, w0
 1139820:	17ffffca 	b	1139748 <der_encode_sequence_ex+0x78>
               z = *outlen;
 1139824:	f9400301 	ldr	x1, [x24]
               if ((err = der_encode_integer(data, out + x, &z)) != CRYPT_OK) {
 1139828:	aa1603e2 	mov	x2, x22
               z = *outlen;
 113982c:	f9003fe1 	str	x1, [sp, #120]
               if ((err = der_encode_integer(data, out + x, &z)) != CRYPT_OK) {
 1139830:	8b1302a1 	add	x1, x21, x19
 1139834:	940011e2 	bl	113dfbc <der_encode_integer>
 1139838:	17fffff8 	b	1139818 <der_encode_sequence_ex+0x148>
               z = *outlen;
 113983c:	f9400301 	ldr	x1, [x24]
 1139840:	f9003fe1 	str	x1, [sp, #120]
               if ((err = der_encode_short_integer(*((unsigned long*)data), out + x, &z)) != CRYPT_OK) {
 1139844:	aa1603e2 	mov	x2, x22
 1139848:	8b1302a1 	add	x1, x21, x19
 113984c:	f9400000 	ldr	x0, [x0]
 1139850:	94000249 	bl	113a174 <der_encode_short_integer>
 1139854:	17fffff1 	b	1139818 <der_encode_sequence_ex+0x148>
               z = *outlen;
 1139858:	f9400302 	ldr	x2, [x24]
               if ((err = der_encode_bit_string(data, size, out + x, &z)) != CRYPT_OK) {
 113985c:	aa1603e3 	mov	x3, x22
               z = *outlen;
 1139860:	f9003fe2 	str	x2, [sp, #120]
               if ((err = der_encode_bit_string(data, size, out + x, &z)) != CRYPT_OK) {
 1139864:	8b1302a2 	add	x2, x21, x19
 1139868:	940009dc 	bl	113bfd8 <der_encode_bit_string>
 113986c:	17ffffeb 	b	1139818 <der_encode_sequence_ex+0x148>
               z = *outlen;
 1139870:	f9400302 	ldr	x2, [x24]
               if ((err = der_encode_raw_bit_string(data, size, out + x, &z)) != CRYPT_OK) {
 1139874:	aa1603e3 	mov	x3, x22
               z = *outlen;
 1139878:	f9003fe2 	str	x2, [sp, #120]
               if ((err = der_encode_raw_bit_string(data, size, out + x, &z)) != CRYPT_OK) {
 113987c:	8b1302a2 	add	x2, x21, x19
 1139880:	94000a37 	bl	113c15c <der_encode_raw_bit_string>
 1139884:	17ffffe5 	b	1139818 <der_encode_sequence_ex+0x148>
               z = *outlen;
 1139888:	f9400302 	ldr	x2, [x24]
               if ((err = der_encode_octet_string(data, size, out + x, &z)) != CRYPT_OK) {
 113988c:	aa1603e3 	mov	x3, x22
               z = *outlen;
 1139890:	f9003fe2 	str	x2, [sp, #120]
               if ((err = der_encode_octet_string(data, size, out + x, &z)) != CRYPT_OK) {
 1139894:	8b1302a2 	add	x2, x21, x19
 1139898:	94001410 	bl	113e8d8 <der_encode_octet_string>
 113989c:	17ffffdf 	b	1139818 <der_encode_sequence_ex+0x148>
               out[x+1] = 0x00;
 11398a0:	8b1302a0 	add	x0, x21, x19
               out[x] = 0x05;
 11398a4:	38336abb 	strb	w27, [x21, x19]
               z = 2;
 11398a8:	f9003ffc 	str	x28, [sp, #120]
               out[x+1] = 0x00;
 11398ac:	3900041f 	strb	wzr, [x0, #1]
       *outlen -= z;
 11398b0:	f9400300 	ldr	x0, [x24]
   for (i = 0; i < inlen; i++) {
 11398b4:	91000739 	add	x25, x25, #0x1
       x       += z;
 11398b8:	f9403fe1 	ldr	x1, [sp, #120]
 11398bc:	910142f7 	add	x23, x23, #0x50
       *outlen -= z;
 11398c0:	cb010000 	sub	x0, x0, x1
       x       += z;
 11398c4:	8b010273 	add	x19, x19, x1
       *outlen -= z;
 11398c8:	f9000300 	str	x0, [x24]
   for (i = 0; i < inlen; i++) {
 11398cc:	17ffffbe 	b	11397c4 <der_encode_sequence_ex+0xf4>
               z = *outlen;
 11398d0:	f9400302 	ldr	x2, [x24]
               if ((err = der_encode_object_identifier(data, size, out + x, &z)) != CRYPT_OK) {
 11398d4:	aa1603e3 	mov	x3, x22
               z = *outlen;
 11398d8:	f9003fe2 	str	x2, [sp, #120]
               if ((err = der_encode_object_identifier(data, size, out + x, &z)) != CRYPT_OK) {
 11398dc:	8b1302a2 	add	x2, x21, x19
 11398e0:	94001310 	bl	113e520 <der_encode_object_identifier>
 11398e4:	17ffffcd 	b	1139818 <der_encode_sequence_ex+0x148>
               z = *outlen;
 11398e8:	f9400302 	ldr	x2, [x24]
               if ((err = der_encode_ia5_string(data, size, out + x, &z)) != CRYPT_OK) {
 11398ec:	aa1603e3 	mov	x3, x22
               z = *outlen;
 11398f0:	f9003fe2 	str	x2, [sp, #120]
               if ((err = der_encode_ia5_string(data, size, out + x, &z)) != CRYPT_OK) {
 11398f4:	8b1302a2 	add	x2, x21, x19
 11398f8:	940010e8 	bl	113dc98 <der_encode_ia5_string>
 11398fc:	17ffffc7 	b	1139818 <der_encode_sequence_ex+0x148>
               z = *outlen;
 1139900:	f9400302 	ldr	x2, [x24]
               if ((err = der_encode_printable_string(data, size, out + x, &z)) != CRYPT_OK) {
 1139904:	aa1603e3 	mov	x3, x22
               z = *outlen;
 1139908:	f9003fe2 	str	x2, [sp, #120]
               if ((err = der_encode_printable_string(data, size, out + x, &z)) != CRYPT_OK) {
 113990c:	8b1302a2 	add	x2, x21, x19
 1139910:	94001479 	bl	113eaf4 <der_encode_printable_string>
 1139914:	17ffffc1 	b	1139818 <der_encode_sequence_ex+0x148>
               z = *outlen;
 1139918:	f9400302 	ldr	x2, [x24]
               if ((err = der_encode_utf8_string(data, size, out + x, &z)) != CRYPT_OK) {
 113991c:	aa1603e3 	mov	x3, x22
               z = *outlen;
 1139920:	f9003fe2 	str	x2, [sp, #120]
               if ((err = der_encode_utf8_string(data, size, out + x, &z)) != CRYPT_OK) {
 1139924:	8b1302a2 	add	x2, x21, x19
 1139928:	94000331 	bl	113a5ec <der_encode_utf8_string>
 113992c:	17ffffbb 	b	1139818 <der_encode_sequence_ex+0x148>
               z = *outlen;
 1139930:	f9400301 	ldr	x1, [x24]
               if ((err = der_encode_utctime(data, out + x, &z)) != CRYPT_OK) {
 1139934:	aa1603e2 	mov	x2, x22
               z = *outlen;
 1139938:	f9003fe1 	str	x1, [sp, #120]
               if ((err = der_encode_utctime(data, out + x, &z)) != CRYPT_OK) {
 113993c:	8b1302a1 	add	x1, x21, x19
 1139940:	9400027a 	bl	113a328 <der_encode_utctime>
 1139944:	17ffffb5 	b	1139818 <der_encode_sequence_ex+0x148>
               z = *outlen;
 1139948:	f9400301 	ldr	x1, [x24]
               if ((err = der_encode_generalizedtime(data, out + x, &z)) != CRYPT_OK) {
 113994c:	aa1603e2 	mov	x2, x22
               z = *outlen;
 1139950:	f9003fe1 	str	x1, [sp, #120]
               if ((err = der_encode_generalizedtime(data, out + x, &z)) != CRYPT_OK) {
 1139954:	8b1302a1 	add	x1, x21, x19
 1139958:	94000ecd 	bl	113d48c <der_encode_generalizedtime>
 113995c:	17ffffaf 	b	1139818 <der_encode_sequence_ex+0x148>
               z = *outlen;
 1139960:	f9400302 	ldr	x2, [x24]
               if ((err = der_encode_set(data, size, out + x, &z)) != CRYPT_OK) {
 1139964:	aa1603e3 	mov	x3, x22
               z = *outlen;
 1139968:	f9003fe2 	str	x2, [sp, #120]
               if ((err = der_encode_set(data, size, out + x, &z)) != CRYPT_OK) {
 113996c:	8b1302a2 	add	x2, x21, x19
 1139970:	94000133 	bl	1139e3c <der_encode_set>
 1139974:	17ffffa9 	b	1139818 <der_encode_sequence_ex+0x148>
               z = *outlen;
 1139978:	f9400302 	ldr	x2, [x24]
               if ((err = der_encode_setof(data, size, out + x, &z)) != CRYPT_OK) {
 113997c:	aa1603e3 	mov	x3, x22
               z = *outlen;
 1139980:	f9003fe2 	str	x2, [sp, #120]
               if ((err = der_encode_setof(data, size, out + x, &z)) != CRYPT_OK) {
 1139984:	8b1302a2 	add	x2, x21, x19
 1139988:	94000183 	bl	1139f94 <der_encode_setof>
 113998c:	17ffffa3 	b	1139818 <der_encode_sequence_ex+0x148>
               z = *outlen;
 1139990:	f9400302 	ldr	x2, [x24]
               if ((err = der_encode_sequence_ex(data, size, out + x, &z, type)) != CRYPT_OK) {
 1139994:	aa1603e3 	mov	x3, x22
 1139998:	528001a4 	mov	w4, #0xd                   	// #13
               z = *outlen;
 113999c:	f9003fe2 	str	x2, [sp, #120]
               if ((err = der_encode_sequence_ex(data, size, out + x, &z, type)) != CRYPT_OK) {
 11399a0:	8b1302a2 	add	x2, x21, x19
 11399a4:	97ffff4b 	bl	11396d0 <der_encode_sequence_ex>
 11399a8:	17ffff9c 	b	1139818 <der_encode_sequence_ex+0x148>
               z = *outlen;
 11399ac:	f9400300 	ldr	x0, [x24]
               if ((err = der_encode_custom_type(&list[i], out + x, &z)) != CRYPT_OK) {
 11399b0:	aa1603e2 	mov	x2, x22
 11399b4:	8b1302a1 	add	x1, x21, x19
               z = *outlen;
 11399b8:	f9003fe0 	str	x0, [sp, #120]
               if ((err = der_encode_custom_type(&list[i], out + x, &z)) != CRYPT_OK) {
 11399bc:	aa1703e0 	mov	x0, x23
 11399c0:	94000c18 	bl	113ca20 <der_encode_custom_type>
 11399c4:	17ffff95 	b	1139818 <der_encode_sequence_ex+0x148>

00000000011399c8 <der_encode_sequence_multi>:
  @param outlen [in/out] Length of buffer and resulting length of output
  @remark <...> is of the form <type, size, data> (int, unsigned long, void*)
  @return CRYPT_OK on success
*/
int der_encode_sequence_multi(unsigned char *out, unsigned long *outlen, ...)
{
 11399c8:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
 11399cc:	910003fd 	mov	x29, sp
 11399d0:	a90153f3 	stp	x19, x20, [sp, #16]
 11399d4:	a9025bf5 	stp	x21, x22, [sp, #32]
 11399d8:	a9050fe2 	stp	x2, x3, [sp, #80]
 11399dc:	a90617e4 	stp	x4, x5, [sp, #96]
 11399e0:	a9071fe6 	stp	x6, x7, [sp, #112]
   unsigned long size, x;
   void          *data;
   va_list       args;
   ltc_asn1_list *list;

   LTC_ARGCHK(out    != NULL);
 11399e4:	b40011e0 	cbz	x0, 1139c20 <der_encode_sequence_multi+0x258>
 11399e8:	aa0103f4 	mov	x20, x1
   LTC_ARGCHK(outlen != NULL);
 11399ec:	b40011a1 	cbz	x1, 1139c20 <der_encode_sequence_multi+0x258>
 11399f0:	910203e4 	add	x4, sp, #0x80
 11399f4:	aa0003f3 	mov	x19, x0

   /* get size of output that will be required */
   va_start(args, outlen);
 11399f8:	d29dffc7 	mov	x7, #0xeffe                	// #61438
 11399fc:	910203e0 	add	x0, sp, #0x80
   x = 0;
   for (;;) {
       type = (ltc_asn1_type)va_arg(args, int);
 1139a00:	aa0403e5 	mov	x5, x4
   va_start(args, outlen);
 1139a04:	910143f6 	add	x22, sp, #0x50
   x = 0;
 1139a08:	d2800001 	mov	x1, #0x0                   	// #0
 1139a0c:	d2800026 	mov	x6, #0x1                   	// #1
 1139a10:	f2a000a7 	movk	x7, #0x5, lsl #16
   va_start(args, outlen);
 1139a14:	a90303e0 	stp	x0, x0, [sp, #48]
 1139a18:	128005e0 	mov	w0, #0xffffffd0            	// #-48
 1139a1c:	f90023f6 	str	x22, [sp, #64]
 1139a20:	b9004be0 	str	w0, [sp, #72]
 1139a24:	b9004fff 	str	wzr, [sp, #76]
       type = (ltc_asn1_type)va_arg(args, int);
 1139a28:	37f80120 	tbnz	w0, #31, 1139a4c <der_encode_sequence_multi+0x84>
 1139a2c:	91002c82 	add	x2, x4, #0xb
 1139a30:	2a0003e3 	mov	w3, w0
 1139a34:	927df042 	and	x2, x2, #0xfffffffffffffff8
 1139a38:	b9400080 	ldr	w0, [x4]
       size = va_arg(args, unsigned long);
 1139a3c:	37f801a3 	tbnz	w3, #31, 1139a70 <der_encode_sequence_multi+0xa8>
 1139a40:	91003c42 	add	x2, x2, #0xf
 1139a44:	927df042 	and	x2, x2, #0xfffffffffffffff8
 1139a48:	1400000d 	b	1139a7c <der_encode_sequence_multi+0xb4>
       type = (ltc_asn1_type)va_arg(args, int);
 1139a4c:	11002003 	add	w3, w0, #0x8
 1139a50:	7100007f 	cmp	w3, #0x0
 1139a54:	5400008d 	b.le	1139a64 <der_encode_sequence_multi+0x9c>
 1139a58:	91002c82 	add	x2, x4, #0xb
 1139a5c:	927df042 	and	x2, x2, #0xfffffffffffffff8
 1139a60:	17fffff6 	b	1139a38 <der_encode_sequence_multi+0x70>
 1139a64:	aa0403e2 	mov	x2, x4
 1139a68:	8b20c0a4 	add	x4, x5, w0, sxtw
 1139a6c:	17fffff3 	b	1139a38 <der_encode_sequence_multi+0x70>
       size = va_arg(args, unsigned long);
 1139a70:	11002063 	add	w3, w3, #0x8
 1139a74:	7100007f 	cmp	w3, #0x0
 1139a78:	54fffe4c 	b.gt	1139a40 <der_encode_sequence_multi+0x78>
       data = va_arg(args, void*);
 1139a7c:	37f80083 	tbnz	w3, #31, 1139a8c <der_encode_sequence_multi+0xc4>
 1139a80:	91003c42 	add	x2, x2, #0xf
 1139a84:	927df042 	and	x2, x2, #0xfffffffffffffff8
 1139a88:	14000004 	b	1139a98 <der_encode_sequence_multi+0xd0>
 1139a8c:	11002063 	add	w3, w3, #0x8
 1139a90:	7100007f 	cmp	w3, #0x0
 1139a94:	54ffff6c 	b.gt	1139a80 <der_encode_sequence_multi+0xb8>
       LTC_UNUSED_PARAM(size);
       LTC_UNUSED_PARAM(data);

       if (type == LTC_ASN1_EOL) {
 1139a98:	34000140 	cbz	w0, 1139ac0 <der_encode_sequence_multi+0xf8>
          break;
       }

       switch (type) {
 1139a9c:	7100481f 	cmp	w0, #0x12
 1139aa0:	54000c08 	b.hi	1139c20 <der_encode_sequence_multi+0x258>  // b.pmore
 1139aa4:	9ac020c0 	lsl	x0, x6, x0
 1139aa8:	ea07001f 	tst	x0, x7
 1139aac:	54000ba0 	b.eq	1139c20 <der_encode_sequence_multi+0x258>  // b.none
           case LTC_ASN1_SEQUENCE:
           case LTC_ASN1_SET:
           case LTC_ASN1_SETOF:
           case LTC_ASN1_RAW_BIT_STRING:
           case LTC_ASN1_GENERALIZEDTIME:
                ++x;
 1139ab0:	91000421 	add	x1, x1, #0x1
       type = (ltc_asn1_type)va_arg(args, int);
 1139ab4:	2a0303e0 	mov	w0, w3
 1139ab8:	aa0203e4 	mov	x4, x2
 1139abc:	17ffffdb 	b	1139a28 <der_encode_sequence_multi+0x60>
       }
   }
   va_end(args);

   /* allocate structure for x elements */
   if (x == 0) {
 1139ac0:	b4000b41 	cbz	x1, 1139c28 <der_encode_sequence_multi+0x260>
      return CRYPT_NOP;
   }

   list = XCALLOC(sizeof(*list), x);
 1139ac4:	d2800a00 	mov	x0, #0x50                  	// #80
 1139ac8:	94002682 	bl	11434d0 <calloc>
 1139acc:	aa0003f5 	mov	x21, x0
   if (list == NULL) {
 1139ad0:	b4000b00 	cbz	x0, 1139c30 <der_encode_sequence_multi+0x268>
      return CRYPT_MEM;
   }

   /* fill in the structure */
   va_start(args, outlen);
 1139ad4:	910203e0 	add	x0, sp, #0x80
 1139ad8:	d29dffcb 	mov	x11, #0xeffe                	// #61438
   x = 0;
   for (;;) {
       type = (ltc_asn1_type)va_arg(args, int);
 1139adc:	aa0003e8 	mov	x8, x0
 1139ae0:	aa0003e2 	mov	x2, x0
   va_start(args, outlen);
 1139ae4:	128005e5 	mov	w5, #0xffffffd0            	// #-48
       type = (ltc_asn1_type)va_arg(args, int);
 1139ae8:	d2800001 	mov	x1, #0x0                   	// #0
 1139aec:	d280002a 	mov	x10, #0x1                   	// #1
 1139af0:	f2a000ab 	movk	x11, #0x5, lsl #16
           case LTC_ASN1_SEQUENCE:
           case LTC_ASN1_SET:
           case LTC_ASN1_SETOF:
           case LTC_ASN1_RAW_BIT_STRING:
           case LTC_ASN1_GENERALIZEDTIME:
                LTC_SET_ASN1(list, x++, type, data, size);
 1139af4:	52800a09 	mov	w9, #0x50                  	// #80
   va_start(args, outlen);
 1139af8:	a90303e0 	stp	x0, x0, [sp, #48]
 1139afc:	f90023f6 	str	x22, [sp, #64]
 1139b00:	29097fe5 	stp	w5, wzr, [sp, #72]
       type = (ltc_asn1_type)va_arg(args, int);
 1139b04:	37f803a5 	tbnz	w5, #31, 1139b78 <der_encode_sequence_multi+0x1b0>
 1139b08:	91002c44 	add	x4, x2, #0xb
 1139b0c:	2a0503e6 	mov	w6, w5
 1139b10:	927df084 	and	x4, x4, #0xfffffffffffffff8
 1139b14:	b9400047 	ldr	w7, [x2]
       size = va_arg(args, unsigned long);
 1139b18:	37f80426 	tbnz	w6, #31, 1139b9c <der_encode_sequence_multi+0x1d4>
 1139b1c:	91003c83 	add	x3, x4, #0xf
 1139b20:	2a0603e0 	mov	w0, w6
 1139b24:	927df063 	and	x3, x3, #0xfffffffffffffff8
 1139b28:	f9400084 	ldr	x4, [x4]
       data = va_arg(args, void*);
 1139b2c:	37f804a0 	tbnz	w0, #31, 1139bc0 <der_encode_sequence_multi+0x1f8>
 1139b30:	91003c62 	add	x2, x3, #0xf
 1139b34:	2a0003e5 	mov	w5, w0
 1139b38:	927df042 	and	x2, x2, #0xfffffffffffffff8
 1139b3c:	f9400066 	ldr	x6, [x3]
       if (type == LTC_ASN1_EOL) {
 1139b40:	34000527 	cbz	w7, 1139be4 <der_encode_sequence_multi+0x21c>
       switch (type) {
 1139b44:	710048ff 	cmp	w7, #0x12
 1139b48:	54000688 	b.hi	1139c18 <der_encode_sequence_multi+0x250>  // b.pmore
 1139b4c:	9ac72140 	lsl	x0, x10, x7
 1139b50:	ea0b001f 	tst	x0, x11
 1139b54:	54000620 	b.eq	1139c18 <der_encode_sequence_multi+0x250>  // b.none
                LTC_SET_ASN1(list, x++, type, data, size);
 1139b58:	9b297c23 	smull	x3, w1, w9
 1139b5c:	91000421 	add	x1, x1, #0x1
 1139b60:	8b0302a0 	add	x0, x21, x3
 1139b64:	b8236aa7 	str	w7, [x21, x3]
 1139b68:	a9009006 	stp	x6, x4, [x0, #8]
 1139b6c:	a901fc1f 	stp	xzr, xzr, [x0, #24]
 1139b70:	f900141f 	str	xzr, [x0, #40]
       type = (ltc_asn1_type)va_arg(args, int);
 1139b74:	17ffffe4 	b	1139b04 <der_encode_sequence_multi+0x13c>
 1139b78:	110020a6 	add	w6, w5, #0x8
 1139b7c:	710000df 	cmp	w6, #0x0
 1139b80:	5400008d 	b.le	1139b90 <der_encode_sequence_multi+0x1c8>
 1139b84:	91002c44 	add	x4, x2, #0xb
 1139b88:	927df084 	and	x4, x4, #0xfffffffffffffff8
 1139b8c:	17ffffe2 	b	1139b14 <der_encode_sequence_multi+0x14c>
 1139b90:	aa0203e4 	mov	x4, x2
 1139b94:	8b25c102 	add	x2, x8, w5, sxtw
 1139b98:	17ffffdf 	b	1139b14 <der_encode_sequence_multi+0x14c>
       size = va_arg(args, unsigned long);
 1139b9c:	110020c0 	add	w0, w6, #0x8
 1139ba0:	7100001f 	cmp	w0, #0x0
 1139ba4:	5400008d 	b.le	1139bb4 <der_encode_sequence_multi+0x1ec>
 1139ba8:	91003c83 	add	x3, x4, #0xf
 1139bac:	927df063 	and	x3, x3, #0xfffffffffffffff8
 1139bb0:	17ffffde 	b	1139b28 <der_encode_sequence_multi+0x160>
 1139bb4:	aa0403e3 	mov	x3, x4
 1139bb8:	8b26c104 	add	x4, x8, w6, sxtw
 1139bbc:	17ffffdb 	b	1139b28 <der_encode_sequence_multi+0x160>
       data = va_arg(args, void*);
 1139bc0:	11002005 	add	w5, w0, #0x8
 1139bc4:	710000bf 	cmp	w5, #0x0
 1139bc8:	5400008d 	b.le	1139bd8 <der_encode_sequence_multi+0x210>
 1139bcc:	91003c62 	add	x2, x3, #0xf
 1139bd0:	927df042 	and	x2, x2, #0xfffffffffffffff8
 1139bd4:	17ffffda 	b	1139b3c <der_encode_sequence_multi+0x174>
 1139bd8:	aa0303e2 	mov	x2, x3
 1139bdc:	8b20c103 	add	x3, x8, w0, sxtw
 1139be0:	17ffffd7 	b	1139b3c <der_encode_sequence_multi+0x174>
               goto LBL_ERR;
       }
   }
   va_end(args);

   err = der_encode_sequence(list, x, out, outlen);
 1139be4:	aa1303e2 	mov	x2, x19
 1139be8:	aa1403e3 	mov	x3, x20
 1139bec:	aa1503e0 	mov	x0, x21
 1139bf0:	528001a4 	mov	w4, #0xd                   	// #13
 1139bf4:	97fffeb7 	bl	11396d0 <der_encode_sequence_ex>
 1139bf8:	2a0003f3 	mov	w19, w0
LBL_ERR:
   XFREE(list);
 1139bfc:	aa1503e0 	mov	x0, x21
 1139c00:	94002678 	bl	11435e0 <free>
   return err;
}
 1139c04:	2a1303e0 	mov	w0, w19
 1139c08:	a94153f3 	ldp	x19, x20, [sp, #16]
 1139c0c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1139c10:	a8c87bfd 	ldp	x29, x30, [sp], #128
 1139c14:	d65f03c0 	ret
               err = CRYPT_INVALID_ARG;
 1139c18:	52800213 	mov	w19, #0x10                  	// #16
 1139c1c:	17fffff8 	b	1139bfc <der_encode_sequence_multi+0x234>
               return CRYPT_INVALID_ARG;
 1139c20:	52800213 	mov	w19, #0x10                  	// #16
 1139c24:	17fffff8 	b	1139c04 <der_encode_sequence_multi+0x23c>
      return CRYPT_NOP;
 1139c28:	52800053 	mov	w19, #0x2                   	// #2
 1139c2c:	17fffff6 	b	1139c04 <der_encode_sequence_multi+0x23c>
      return CRYPT_MEM;
 1139c30:	528001b3 	mov	w19, #0xd                   	// #13
 1139c34:	17fffff4 	b	1139c04 <der_encode_sequence_multi+0x23c>

0000000001139c38 <der_length_sequence_ex>:
   int           err;
   ltc_asn1_type type;
   unsigned long size, x, y, i;
   void          *data;

   LTC_ARGCHK(list    != NULL);
 1139c38:	b4000dc0 	cbz	x0, 1139df0 <der_length_sequence_ex+0x1b8>
{
 1139c3c:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
 1139c40:	910003fd 	mov	x29, sp
 1139c44:	a90153f3 	stp	x19, x20, [sp, #16]
 1139c48:	a9025bf5 	stp	x21, x22, [sp, #32]
 1139c4c:	aa0203f5 	mov	x21, x2
 1139c50:	a90363f7 	stp	x23, x24, [sp, #48]
 1139c54:	a9046bf9 	stp	x25, x26, [sp, #64]
   LTC_ARGCHK(outlen  != NULL);
 1139c58:	b4000d02 	cbz	x2, 1139df8 <der_length_sequence_ex+0x1c0>
 1139c5c:	f00000b9 	adrp	x25, 1150000 <Te4+0x258>
 1139c60:	aa0003f4 	mov	x20, x0
 1139c64:	aa0103f8 	mov	x24, x1
 1139c68:	aa0303f6 	mov	x22, x3
 1139c6c:	91103339 	add	x25, x25, #0x40c
               break;

           case LTC_ASN1_SET:
           case LTC_ASN1_SETOF:
           case LTC_ASN1_SEQUENCE:
               if ((err = der_length_sequence(data, size, &x)) != CRYPT_OK) {
 1139c70:	910163f3 	add	x19, sp, #0x58
   for (i = 0; i < inlen; i++) {
 1139c74:	d2800017 	mov	x23, #0x0                   	// #0
   y = 0;
 1139c78:	d280001a 	mov	x26, #0x0                   	// #0
   for (i = 0; i < inlen; i++) {
 1139c7c:	eb17031f 	cmp	x24, x23
 1139c80:	54000060 	b.eq	1139c8c <der_length_sequence_ex+0x54>  // b.none
       type = list[i].type;
 1139c84:	b9400281 	ldr	w1, [x20]
       if (type == LTC_ASN1_EOL) {
 1139c88:	35000161 	cbnz	w1, 1139cb4 <der_length_sequence_ex+0x7c>
               err = CRYPT_INVALID_ARG;
               goto LBL_ERR;
       }
   }

   if ((err = der_length_asn1_length(y, &x)) != CRYPT_OK) {
 1139c8c:	910163e1 	add	x1, sp, #0x58
 1139c90:	aa1a03e0 	mov	x0, x26
 1139c94:	94000dfb 	bl	113d480 <der_length_asn1_length>
 1139c98:	340009e0 	cbz	w0, 1139dd4 <der_length_sequence_ex+0x19c>
   *outlen = y + x + 1;
   err     = CRYPT_OK;

LBL_ERR:
   return err;
}
 1139c9c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1139ca0:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1139ca4:	a94363f7 	ldp	x23, x24, [sp, #48]
 1139ca8:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1139cac:	a8c67bfd 	ldp	x29, x30, [sp], #96
 1139cb0:	d65f03c0 	ret
       if (!list[i].used && list[i].optional) continue;
 1139cb4:	b9401a80 	ldr	w0, [x20, #24]
 1139cb8:	35000060 	cbnz	w0, 1139cc4 <der_length_sequence_ex+0x8c>
 1139cbc:	b9401e80 	ldr	w0, [x20, #28]
 1139cc0:	350003e0 	cbnz	w0, 1139d3c <der_length_sequence_ex+0x104>
 1139cc4:	51000421 	sub	w1, w1, #0x1
 1139cc8:	7100483f 	cmp	w1, #0x12
       size = list[i].size;
 1139ccc:	a9408e80 	ldp	x0, x3, [x20, #8]
 1139cd0:	54000948 	b.hi	1139df8 <der_length_sequence_ex+0x1c0>  // b.pmore
 1139cd4:	38614b21 	ldrb	w1, [x25, w1, uxtw]
 1139cd8:	10000062 	adr	x2, 1139ce4 <der_length_sequence_ex+0xac>
 1139cdc:	8b218841 	add	x1, x2, w1, sxtb #2
 1139ce0:	d61f0020 	br	x1
              if ((err = der_length_boolean(&x)) != CRYPT_OK) {
 1139ce4:	aa1303e0 	mov	x0, x19
 1139ce8:	94000980 	bl	113c2e8 <der_length_boolean>
               if ((err = der_length_integer(data, &x)) != CRYPT_OK) {
 1139cec:	35fffd80 	cbnz	w0, 1139c9c <der_length_sequence_ex+0x64>
               y += x;
 1139cf0:	f9402fe0 	ldr	x0, [sp, #88]
 1139cf4:	8b00035a 	add	x26, x26, x0
               break;
 1139cf8:	14000011 	b	1139d3c <der_length_sequence_ex+0x104>
               if ((err = der_length_integer(data, &x)) != CRYPT_OK) {
 1139cfc:	aa1303e1 	mov	x1, x19
 1139d00:	94001160 	bl	113e280 <der_length_integer>
 1139d04:	17fffffa 	b	1139cec <der_length_sequence_ex+0xb4>
               if ((err = der_length_short_integer(*((unsigned long *)data), &x)) != CRYPT_OK) {
 1139d08:	f9400000 	ldr	x0, [x0]
 1139d0c:	aa1303e1 	mov	x1, x19
 1139d10:	94000160 	bl	113a290 <der_length_short_integer>
 1139d14:	17fffff6 	b	1139cec <der_length_sequence_ex+0xb4>
               if ((err = der_length_bit_string(size, &x)) != CRYPT_OK) {
 1139d18:	aa1303e1 	mov	x1, x19
 1139d1c:	aa0303e0 	mov	x0, x3
 1139d20:	940008f9 	bl	113c104 <der_length_bit_string>
 1139d24:	17fffff2 	b	1139cec <der_length_sequence_ex+0xb4>
               if ((err = der_length_octet_string(size, &x)) != CRYPT_OK) {
 1139d28:	aa1303e1 	mov	x1, x19
 1139d2c:	aa0303e0 	mov	x0, x3
 1139d30:	94001321 	bl	113e9b4 <der_length_octet_string>
 1139d34:	17ffffee 	b	1139cec <der_length_sequence_ex+0xb4>
               y += 2;
 1139d38:	91000b5a 	add	x26, x26, #0x2
   for (i = 0; i < inlen; i++) {
 1139d3c:	910006f7 	add	x23, x23, #0x1
 1139d40:	91014294 	add	x20, x20, #0x50
 1139d44:	17ffffce 	b	1139c7c <der_length_sequence_ex+0x44>
               if ((err = der_length_object_identifier(data, size, &x)) != CRYPT_OK) {
 1139d48:	aa1303e2 	mov	x2, x19
 1139d4c:	aa0303e1 	mov	x1, x3
 1139d50:	94001273 	bl	113e71c <der_length_object_identifier>
 1139d54:	17ffffe6 	b	1139cec <der_length_sequence_ex+0xb4>
               if ((err = der_length_ia5_string(data, size, &x)) != CRYPT_OK) {
 1139d58:	aa1303e2 	mov	x2, x19
 1139d5c:	aa0303e1 	mov	x1, x3
 1139d60:	94001027 	bl	113ddfc <der_length_ia5_string>
 1139d64:	17ffffe2 	b	1139cec <der_length_sequence_ex+0xb4>
               if ((err = der_length_teletex_string(data, size, &x)) != CRYPT_OK) {
 1139d68:	aa1303e2 	mov	x2, x19
 1139d6c:	aa0303e1 	mov	x1, x3
 1139d70:	94000307 	bl	113a98c <der_length_teletex_string>
 1139d74:	17ffffde 	b	1139cec <der_length_sequence_ex+0xb4>
               if ((err = der_length_printable_string(data, size, &x)) != CRYPT_OK) {
 1139d78:	aa1303e2 	mov	x2, x19
 1139d7c:	aa0303e1 	mov	x1, x3
 1139d80:	940013b6 	bl	113ec58 <der_length_printable_string>
 1139d84:	17ffffda 	b	1139cec <der_length_sequence_ex+0xb4>
               if ((err = der_length_utctime(data, &x)) != CRYPT_OK) {
 1139d88:	aa1303e1 	mov	x1, x19
 1139d8c:	9400020a 	bl	113a5b4 <der_length_utctime>
 1139d90:	17ffffd7 	b	1139cec <der_length_sequence_ex+0xb4>
               if ((err = der_length_generalizedtime(data, &x)) != CRYPT_OK) {
 1139d94:	aa1303e1 	mov	x1, x19
 1139d98:	94000f68 	bl	113db38 <der_length_generalizedtime>
 1139d9c:	17ffffd4 	b	1139cec <der_length_sequence_ex+0xb4>
               if ((err = der_length_utf8_string(data, size, &x)) != CRYPT_OK) {
 1139da0:	aa1303e2 	mov	x2, x19
 1139da4:	aa0303e1 	mov	x1, x3
 1139da8:	940002b2 	bl	113a870 <der_length_utf8_string>
 1139dac:	17ffffd0 	b	1139cec <der_length_sequence_ex+0xb4>
               if ((err = der_length_custom_type(&list[i], &x, NULL)) != CRYPT_OK) {
 1139db0:	aa1303e1 	mov	x1, x19
 1139db4:	aa1403e0 	mov	x0, x20
 1139db8:	d2800002 	mov	x2, #0x0                   	// #0
 1139dbc:	94000be7 	bl	113cd58 <der_length_custom_type>
 1139dc0:	17ffffcb 	b	1139cec <der_length_sequence_ex+0xb4>
               if ((err = der_length_sequence(data, size, &x)) != CRYPT_OK) {
 1139dc4:	aa1303e2 	mov	x2, x19
 1139dc8:	aa0303e1 	mov	x1, x3
 1139dcc:	9400000d 	bl	1139e00 <der_length_sequence>
 1139dd0:	17ffffc7 	b	1139cec <der_length_sequence_ex+0xb4>
   if (payloadlen != NULL) {
 1139dd4:	b4000056 	cbz	x22, 1139ddc <der_length_sequence_ex+0x1a4>
      *payloadlen = y;
 1139dd8:	f90002da 	str	x26, [x22]
   *outlen = y + x + 1;
 1139ddc:	f9402fe1 	ldr	x1, [sp, #88]
 1139de0:	91000421 	add	x1, x1, #0x1
 1139de4:	8b1a003a 	add	x26, x1, x26
 1139de8:	f90002ba 	str	x26, [x21]
   err     = CRYPT_OK;
 1139dec:	17ffffac 	b	1139c9c <der_length_sequence_ex+0x64>
   LTC_ARGCHK(list    != NULL);
 1139df0:	52800200 	mov	w0, #0x10                  	// #16
}
 1139df4:	d65f03c0 	ret
   LTC_ARGCHK(list    != NULL);
 1139df8:	52800200 	mov	w0, #0x10                  	// #16
 1139dfc:	17ffffa8 	b	1139c9c <der_length_sequence_ex+0x64>

0000000001139e00 <der_length_sequence>:
   return der_length_sequence_ex(list, inlen, outlen, NULL);
 1139e00:	d2800003 	mov	x3, #0x0                   	// #0
 1139e04:	17ffff8d 	b	1139c38 <der_length_sequence_ex>

0000000001139e08 <_qsort_helper>:
   return der_asn1_type_to_identifier_map[v];
}


static int _qsort_helper(const void *a, const void *b)
{
 1139e08:	aa0003e3 	mov	x3, x0
   return der_asn1_type_to_identifier_map[v];
 1139e0c:	b0000100 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1139e10:	b9400024 	ldr	w4, [x1]
 1139e14:	f9415400 	ldr	x0, [x0, #680]
 1139e18:	b9400062 	ldr	w2, [x3]
   ltc_asn1_list *A = (ltc_asn1_list *)a, *B = (ltc_asn1_list *)b;
   int            r;

   r = _ltc_to_asn1(A->type) - _ltc_to_asn1(B->type);
 1139e1c:	b8627802 	ldr	w2, [x0, x2, lsl #2]
 1139e20:	b8647800 	ldr	w0, [x0, x4, lsl #2]

   /* for QSORT the order is UNDEFINED if they are "equal" which means it is NOT DETERMINISTIC.  So we force it to be :-) */
   if (r == 0) {
 1139e24:	6b000040 	subs	w0, w2, w0
 1139e28:	54000081 	b.ne	1139e38 <_qsort_helper+0x30>  // b.any
      /* their order in the original list now determines the position */
      return A->used - B->used;
 1139e2c:	b9401821 	ldr	w1, [x1, #24]
 1139e30:	b9401860 	ldr	w0, [x3, #24]
 1139e34:	4b010000 	sub	w0, w0, w1
   }
   return r;
}
 1139e38:	d65f03c0 	ret

0000000001139e3c <der_encode_set>:
   @param outlen    [in/out] The size of the output
   @return CRYPT_OK on success
*/
int der_encode_set(const ltc_asn1_list *list, unsigned long inlen,
                   unsigned char *out,        unsigned long *outlen)
{
 1139e3c:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 1139e40:	910003fd 	mov	x29, sp
 1139e44:	a9025bf5 	stp	x21, x22, [sp, #32]
 1139e48:	aa0103f5 	mov	x21, x1
 1139e4c:	aa0203f6 	mov	x22, x2
   ltc_asn1_list  *copy;
   unsigned long   x;
   int             err;

   /* make copy of list */
   copy = XCALLOC(inlen, sizeof(*copy));
 1139e50:	d2800a01 	mov	x1, #0x50                  	// #80
{
 1139e54:	a90153f3 	stp	x19, x20, [sp, #16]
 1139e58:	a90363f7 	stp	x23, x24, [sp, #48]
 1139e5c:	aa0003f8 	mov	x24, x0
 1139e60:	aa0303f7 	mov	x23, x3
   copy = XCALLOC(inlen, sizeof(*copy));
 1139e64:	aa1503e0 	mov	x0, x21
{
 1139e68:	f90023f9 	str	x25, [sp, #64]
   copy = XCALLOC(inlen, sizeof(*copy));
 1139e6c:	94002599 	bl	11434d0 <calloc>
   if (copy == NULL) {
 1139e70:	b40004a0 	cbz	x0, 1139f04 <der_encode_set+0xc8>
 1139e74:	aa0003f3 	mov	x19, x0
 1139e78:	aa0003e4 	mov	x4, x0
      return CRYPT_MEM;
   }

   /* fill in used member with index so we can fully sort it */
   for (x = 0; x < inlen; x++) {
 1139e7c:	d2800014 	mov	x20, #0x0                   	// #0
       copy[x]      = list[x];
 1139e80:	d2800a19 	mov	x25, #0x50                  	// #80
   for (x = 0; x < inlen; x++) {
 1139e84:	eb15029f 	cmp	x20, x21
 1139e88:	540002e1 	b.ne	1139ee4 <der_encode_set+0xa8>  // b.any
       copy[x].used = x;
   }

   /* sort it by the "type" field */
   XQSORT(copy, inlen, sizeof(*copy), &_qsort_helper);
 1139e8c:	aa1403e1 	mov	x1, x20
 1139e90:	aa1303e0 	mov	x0, x19
 1139e94:	d2800a02 	mov	x2, #0x50                  	// #80
 1139e98:	90000003 	adrp	x3, 1139000 <ssh_encode_sequence_multi+0x120>
 1139e9c:	91382063 	add	x3, x3, #0xe08
 1139ea0:	94002668 	bl	1143840 <qsort>

   /* call der_encode_sequence_ex() */
   err = der_encode_sequence_ex(copy, inlen, out, outlen, LTC_ASN1_SET);
 1139ea4:	aa1403e1 	mov	x1, x20
 1139ea8:	aa1703e3 	mov	x3, x23
 1139eac:	aa1603e2 	mov	x2, x22
 1139eb0:	528001c4 	mov	w4, #0xe                   	// #14
 1139eb4:	aa1303e0 	mov	x0, x19
 1139eb8:	97fffe06 	bl	11396d0 <der_encode_sequence_ex>
 1139ebc:	2a0003f4 	mov	w20, w0

   /* free list */
   XFREE(copy);
 1139ec0:	aa1303e0 	mov	x0, x19
 1139ec4:	940025c7 	bl	11435e0 <free>

   return err;
}
 1139ec8:	2a1403e0 	mov	w0, w20
 1139ecc:	a94153f3 	ldp	x19, x20, [sp, #16]
 1139ed0:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1139ed4:	a94363f7 	ldp	x23, x24, [sp, #48]
 1139ed8:	f94023f9 	ldr	x25, [sp, #64]
 1139edc:	a8c57bfd 	ldp	x29, x30, [sp], #80
 1139ee0:	d65f03c0 	ret
       copy[x]      = list[x];
 1139ee4:	9b196281 	madd	x1, x20, x25, x24
 1139ee8:	aa0403e0 	mov	x0, x4
 1139eec:	d2800a02 	mov	x2, #0x50                  	// #80
 1139ef0:	97ff2528 	bl	1103390 <memcpy>
       copy[x].used = x;
 1139ef4:	91014004 	add	x4, x0, #0x50
 1139ef8:	b9001814 	str	w20, [x0, #24]
   for (x = 0; x < inlen; x++) {
 1139efc:	91000694 	add	x20, x20, #0x1
 1139f00:	17ffffe1 	b	1139e84 <der_encode_set+0x48>
      return CRYPT_MEM;
 1139f04:	528001b4 	mov	w20, #0xd                   	// #13
 1139f08:	17fffff0 	b	1139ec8 <der_encode_set+0x8c>

0000000001139f0c <_qsort_helper>:
   unsigned char *start;
   unsigned long  size;
};

static int _qsort_helper(const void *a, const void *b)
{
 1139f0c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1139f10:	910003fd 	mov	x29, sp
 1139f14:	a90153f3 	stp	x19, x20, [sp, #16]
 1139f18:	a9025bf5 	stp	x21, x22, [sp, #32]
   struct edge   *A = (struct edge *)a, *B = (struct edge *)b;
   int            r;
   unsigned long  x;

   /* compare min length */
   r = XMEMCMP(A->start, B->start, MIN(A->size, B->size));
 1139f1c:	a9404c16 	ldp	x22, x19, [x0]
 1139f20:	a9405035 	ldp	x21, x20, [x1]
 1139f24:	aa1603e0 	mov	x0, x22
 1139f28:	eb13029f 	cmp	x20, x19
 1139f2c:	aa1503e1 	mov	x1, x21
 1139f30:	9a939282 	csel	x2, x20, x19, ls  // ls = plast
 1139f34:	94002747 	bl	1143c50 <memcmp>

   if (r == 0 && A->size != B->size) {
 1139f38:	35000120 	cbnz	w0, 1139f5c <_qsort_helper+0x50>
 1139f3c:	eb13029f 	cmp	x20, x19
 1139f40:	540000e0 	b.eq	1139f5c <_qsort_helper+0x50>  // b.none
      if (A->size > B->size) {
 1139f44:	54000142 	b.cs	1139f6c <_qsort_helper+0x60>  // b.hs, b.nlast
         for (x = B->size; x < A->size; x++) {
            if (A->start[x]) {
 1139f48:	38746ac1 	ldrb	w1, [x22, x20]
 1139f4c:	350001c1 	cbnz	w1, 1139f84 <_qsort_helper+0x78>
         for (x = B->size; x < A->size; x++) {
 1139f50:	91000694 	add	x20, x20, #0x1
 1139f54:	eb14027f 	cmp	x19, x20
 1139f58:	54ffff81 	b.ne	1139f48 <_qsort_helper+0x3c>  // b.any
         }
      }
   }

   return r;
}
 1139f5c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1139f60:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1139f64:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1139f68:	d65f03c0 	ret
            if (B->start[x]) {
 1139f6c:	38736aa1 	ldrb	w1, [x21, x19]
 1139f70:	350000e1 	cbnz	w1, 1139f8c <_qsort_helper+0x80>
         for (x = A->size; x < B->size; x++) {
 1139f74:	91000673 	add	x19, x19, #0x1
 1139f78:	eb13029f 	cmp	x20, x19
 1139f7c:	54ffff81 	b.ne	1139f6c <_qsort_helper+0x60>  // b.any
 1139f80:	17fffff7 	b	1139f5c <_qsort_helper+0x50>
               return 1;
 1139f84:	52800020 	mov	w0, #0x1                   	// #1
 1139f88:	17fffff5 	b	1139f5c <_qsort_helper+0x50>
               return -1;
 1139f8c:	12800000 	mov	w0, #0xffffffff            	// #-1
 1139f90:	17fffff3 	b	1139f5c <_qsort_helper+0x50>

0000000001139f94 <der_encode_setof>:
   @param outlen    [in/out] The size of the output
   @return CRYPT_OK on success
*/
int der_encode_setof(const ltc_asn1_list *list, unsigned long inlen,
                     unsigned char *out,        unsigned long *outlen)
{
 1139f94:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
 1139f98:	910003fd 	mov	x29, sp
 1139f9c:	a9025bf5 	stp	x21, x22, [sp, #32]
 1139fa0:	aa0303f6 	mov	x22, x3
 1139fa4:	aa0003f5 	mov	x21, x0
 1139fa8:	a90363f7 	stp	x23, x24, [sp, #48]
 1139fac:	aa0203f7 	mov	x23, x2
 1139fb0:	a90153f3 	stp	x19, x20, [sp, #16]
 1139fb4:	aa0103f4 	mov	x20, x1
 1139fb8:	aa0003e1 	mov	x1, x0
   int            err;
   struct edge   *edges;
   unsigned char *ptr, *buf;

   /* check that they're all the same type */
   for (x = 1; x < inlen; x++) {
 1139fbc:	d2800020 	mov	x0, #0x1                   	// #1
{
 1139fc0:	a9046bf9 	stp	x25, x26, [sp, #64]
 1139fc4:	f9002bfb 	str	x27, [sp, #80]
   for (x = 1; x < inlen; x++) {
 1139fc8:	eb14001f 	cmp	x0, x20
 1139fcc:	54000303 	b.cc	113a02c <der_encode_setof+0x98>  // b.lo, b.ul, b.last
         return CRYPT_INVALID_ARG;
      }
   }

   /* alloc buffer to store copy of output */
   buf = XCALLOC(1, *outlen);
 1139fd0:	f94002c1 	ldr	x1, [x22]
 1139fd4:	d2800020 	mov	x0, #0x1                   	// #1
 1139fd8:	9400253e 	bl	11434d0 <calloc>
 1139fdc:	aa0003f3 	mov	x19, x0
   if (buf == NULL) {
 1139fe0:	b4000400 	cbz	x0, 113a060 <der_encode_setof+0xcc>
      return CRYPT_MEM;
   }

   /* encode list */
   if ((err = der_encode_sequence_ex(list, inlen, buf, outlen, LTC_ASN1_SETOF)) != CRYPT_OK) {
 1139fe4:	aa0003e2 	mov	x2, x0
 1139fe8:	aa1603e3 	mov	x3, x22
 1139fec:	aa1503e0 	mov	x0, x21
 1139ff0:	aa1403e1 	mov	x1, x20
 1139ff4:	528001e4 	mov	w4, #0xf                   	// #15
 1139ff8:	97fffdb6 	bl	11396d0 <der_encode_sequence_ex>
 1139ffc:	2a0003f5 	mov	w21, w0
 113a000:	34000220 	cbz	w0, 113a044 <der_encode_setof+0xb0>
   zeromem(buf, *outlen);
#endif

   /* free buffers */
   XFREE(edges);
   XFREE(buf);
 113a004:	aa1303e0 	mov	x0, x19
 113a008:	94002576 	bl	11435e0 <free>

   return CRYPT_OK;
}
 113a00c:	2a1503e0 	mov	w0, w21
 113a010:	a94153f3 	ldp	x19, x20, [sp, #16]
 113a014:	a9425bf5 	ldp	x21, x22, [sp, #32]
 113a018:	a94363f7 	ldp	x23, x24, [sp, #48]
 113a01c:	a9446bf9 	ldp	x25, x26, [sp, #64]
 113a020:	f9402bfb 	ldr	x27, [sp, #80]
 113a024:	a8c67bfd 	ldp	x29, x30, [sp], #96
 113a028:	d65f03c0 	ret
      if (list[x].type != list[x-1].type) {
 113a02c:	b9405023 	ldr	w3, [x1, #80]
 113a030:	b8450422 	ldr	w2, [x1], #80
 113a034:	6b02007f 	cmp	w3, w2
 113a038:	540009a1 	b.ne	113a16c <der_encode_setof+0x1d8>  // b.any
   for (x = 1; x < inlen; x++) {
 113a03c:	91000400 	add	x0, x0, #0x1
 113a040:	17ffffe2 	b	1139fc8 <der_encode_setof+0x34>
   edges = XCALLOC(inlen, sizeof(*edges));
 113a044:	aa1403e0 	mov	x0, x20
 113a048:	d2800201 	mov	x1, #0x10                  	// #16
 113a04c:	94002521 	bl	11434d0 <calloc>
 113a050:	aa0003f8 	mov	x24, x0
   if (edges == NULL) {
 113a054:	b50000a0 	cbnz	x0, 113a068 <der_encode_setof+0xd4>
      XFREE(buf);
 113a058:	aa1303e0 	mov	x0, x19
 113a05c:	94002561 	bl	11435e0 <free>
      return CRYPT_MEM;
 113a060:	528001b5 	mov	w21, #0xd                   	// #13
 113a064:	17ffffea 	b	113a00c <der_encode_setof+0x78>
   if (x >= 0x80) {
 113a068:	39c00661 	ldrsb	w1, [x19, #1]
   x = *ptr++;
 113a06c:	91000a64 	add	x4, x19, #0x2
 113a070:	39400660 	ldrb	w0, [x19, #1]
   if (x >= 0x80) {
 113a074:	36f80061 	tbz	w1, #31, 113a080 <der_encode_setof+0xec>
      ptr += (x & 0x7F);
 113a078:	92401800 	and	x0, x0, #0x7f
 113a07c:	8b000084 	add	x4, x4, x0
   while (ptr < (buf + *outlen)) {
 113a080:	f94002c1 	ldr	x1, [x22]
   hdrlen = ptr - buf;
 113a084:	cb130099 	sub	x25, x4, x19
   while (ptr < (buf + *outlen)) {
 113a088:	91002300 	add	x0, x24, #0x8
 113a08c:	8b010261 	add	x1, x19, x1
 113a090:	eb04003f 	cmp	x1, x4
 113a094:	540002a8 	b.hi	113a0e8 <der_encode_setof+0x154>  // b.pmore
   XQSORT(edges, inlen, sizeof(*edges), &_qsort_helper);
 113a098:	aa1403e1 	mov	x1, x20
 113a09c:	f0ffffe3 	adrp	x3, 1139000 <ssh_encode_sequence_multi+0x120>
 113a0a0:	aa1803fa 	mov	x26, x24
 113a0a4:	913c3063 	add	x3, x3, #0xf0c
 113a0a8:	8b141314 	add	x20, x24, x20, lsl #4
 113a0ac:	aa1803e0 	mov	x0, x24
 113a0b0:	d2800202 	mov	x2, #0x10                  	// #16
 113a0b4:	940025e3 	bl	1143840 <qsort>
   XMEMCPY(out, buf, hdrlen);
 113a0b8:	aa1903e2 	mov	x2, x25
 113a0bc:	aa1303e1 	mov	x1, x19
 113a0c0:	aa1703e0 	mov	x0, x23
 113a0c4:	97ff24b3 	bl	1103390 <memcpy>
   for (y = (unsigned long)hdrlen, x = 0; x < inlen; x++) {
 113a0c8:	eb14035f 	cmp	x26, x20
 113a0cc:	54000421 	b.ne	113a150 <der_encode_setof+0x1bc>  // b.any
   zeromem(buf, *outlen);
 113a0d0:	f94002c1 	ldr	x1, [x22]
 113a0d4:	aa1303e0 	mov	x0, x19
 113a0d8:	97ffe0db 	bl	1132444 <zeromem>
   XFREE(edges);
 113a0dc:	aa1803e0 	mov	x0, x24
 113a0e0:	94002540 	bl	11435e0 <free>
 113a0e4:	17ffffc8 	b	113a004 <der_encode_setof+0x70>
      y = ptr[z++];
 113a0e8:	39400482 	ldrb	w2, [x4, #1]
      edges[x].start = ptr;
 113a0ec:	f81f8004 	stur	x4, [x0, #-8]
      y = ptr[z++];
 113a0f0:	39400485 	ldrb	w5, [x4, #1]
      if (y < 128) {
 113a0f4:	f101fc5f 	cmp	x2, #0x7f
 113a0f8:	54000108 	b.hi	113a118 <der_encode_setof+0x184>  // b.pmore
      y = ptr[z++];
 113a0fc:	d2800045 	mov	x5, #0x2                   	// #2
         edges[x].size = y;
 113a100:	f9000002 	str	x2, [x0]
      edges[x].size += z;
 113a104:	f9400002 	ldr	x2, [x0]
 113a108:	8b0200a5 	add	x5, x5, x2
 113a10c:	f8010405 	str	x5, [x0], #16
      ptr           += edges[x].size;
 113a110:	8b050084 	add	x4, x4, x5
      ++x;
 113a114:	17ffffdf 	b	113a090 <der_encode_setof+0xfc>
         y &= 0x7F;
 113a118:	924018a5 	and	x5, x5, #0x7f
         edges[x].size = 0;
 113a11c:	91000886 	add	x6, x4, #0x2
         y &= 0x7F;
 113a120:	aa0503e2 	mov	x2, x5
         edges[x].size = 0;
 113a124:	f900001f 	str	xzr, [x0]
         while (y--) {
 113a128:	d1000442 	sub	x2, x2, #0x1
 113a12c:	b100045f 	cmn	x2, #0x1
 113a130:	f9400003 	ldr	x3, [x0]
 113a134:	54000061 	b.ne	113a140 <der_encode_setof+0x1ac>  // b.any
 113a138:	910008a5 	add	x5, x5, #0x2
 113a13c:	17fffff2 	b	113a104 <der_encode_setof+0x170>
            edges[x].size = (edges[x].size << 8) | ((unsigned long)ptr[z++]);
 113a140:	384014c7 	ldrb	w7, [x6], #1
 113a144:	aa0320e3 	orr	x3, x7, x3, lsl #8
 113a148:	f9000003 	str	x3, [x0]
 113a14c:	17fffff7 	b	113a128 <der_encode_setof+0x194>
      XMEMCPY(out+y, edges[x].start, edges[x].size);
 113a150:	f940075b 	ldr	x27, [x26, #8]
 113a154:	8b1902e0 	add	x0, x23, x25
 113a158:	f8410741 	ldr	x1, [x26], #16
 113a15c:	aa1b03e2 	mov	x2, x27
      y += edges[x].size;
 113a160:	8b1b0339 	add	x25, x25, x27
      XMEMCPY(out+y, edges[x].start, edges[x].size);
 113a164:	97ff248b 	bl	1103390 <memcpy>
   for (y = (unsigned long)hdrlen, x = 0; x < inlen; x++) {
 113a168:	17ffffd8 	b	113a0c8 <der_encode_setof+0x134>
         return CRYPT_INVALID_ARG;
 113a16c:	52800215 	mov	w21, #0x10                  	// #16
 113a170:	17ffffa7 	b	113a00c <der_encode_setof+0x78>

000000000113a174 <der_encode_short_integer>:
int der_encode_short_integer(unsigned long num, unsigned char *out, unsigned long *outlen)
{
   unsigned long len, x, y, z;
   int           err;

   LTC_ARGCHK(out    != NULL);
 113a174:	b4000861 	cbz	x1, 113a280 <der_encode_short_integer+0x10c>
{
 113a178:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 113a17c:	910003fd 	mov	x29, sp
 113a180:	a90153f3 	stp	x19, x20, [sp, #16]
 113a184:	f90013f5 	str	x21, [sp, #32]
 113a188:	aa0203f5 	mov	x21, x2
   LTC_ARGCHK(outlen != NULL);
 113a18c:	b40007e2 	cbz	x2, 113a288 <der_encode_short_integer+0x114>

   /* force to 32 bits */
   num &= 0xFFFFFFFFUL;
 113a190:	92407c13 	and	x19, x0, #0xffffffff
 113a194:	aa0103f4 	mov	x20, x1

   /* find out how big this will be */
   if ((err = der_length_short_integer(num, &len)) != CRYPT_OK) {
 113a198:	aa1303e0 	mov	x0, x19
 113a19c:	9100e3e1 	add	x1, sp, #0x38
 113a1a0:	9400003c 	bl	113a290 <der_length_short_integer>
 113a1a4:	350000e0 	cbnz	w0, 113a1c0 <der_encode_short_integer+0x4c>
      return err;
   }

   if (*outlen < len) {
 113a1a8:	f94002a2 	ldr	x2, [x21]
 113a1ac:	f9401fe1 	ldr	x1, [sp, #56]
 113a1b0:	eb01005f 	cmp	x2, x1
 113a1b4:	54000442 	b.cs	113a23c <der_encode_short_integer+0xc8>  // b.hs, b.nlast
      *outlen = len;
      return CRYPT_BUFFER_OVERFLOW;
 113a1b8:	528000c0 	mov	w0, #0x6                   	// #6
      *outlen = len;
 113a1bc:	f90002a1 	str	x1, [x21]

   /* we good */
   *outlen = x;

   return CRYPT_OK;
}
 113a1c0:	a94153f3 	ldp	x19, x20, [sp, #16]
 113a1c4:	f94013f5 	ldr	x21, [sp, #32]
 113a1c8:	a8c47bfd 	ldp	x29, x30, [sp], #64
 113a1cc:	d65f03c0 	ret
     ++z;
 113a1d0:	91000463 	add	x3, x3, #0x1
     y >>= 8;
 113a1d4:	d348fc21 	lsr	x1, x1, #8
   while (y) {
 113a1d8:	b5ffffc1 	cbnz	x1, 113a1d0 <der_encode_short_integer+0x5c>
   if (z == 0) {
 113a1dc:	f100007f 	cmp	x3, #0x0
   for (x = 0; (z <= 4) && (x < (4 - z)); x++) {
 113a1e0:	d2800002 	mov	x2, #0x0                   	// #0
 113a1e4:	9a9f1464 	csinc	x4, x3, xzr, ne  // ne = any
   z += (num&(1UL<<((z<<3) - 1))) ? 1 : 0;
 113a1e8:	531d7083 	lsl	w3, w4, #3
 113a1ec:	51000463 	sub	w3, w3, #0x1
 113a1f0:	9ac32663 	lsr	x3, x19, x3
 113a1f4:	92400063 	and	x3, x3, #0x1
 113a1f8:	8b040063 	add	x3, x3, x4
   for (x = 0; (z <= 4) && (x < (4 - z)); x++) {
 113a1fc:	d2800084 	mov	x4, #0x4                   	// #4
 113a200:	cb030084 	sub	x4, x4, x3
 113a204:	f100107f 	cmp	x3, #0x4
 113a208:	54000209 	b.ls	113a248 <der_encode_short_integer+0xd4>  // b.plast
   out[x++] = 0x02;
 113a20c:	52800042 	mov	w2, #0x2                   	// #2
 113a210:	39000282 	strb	w2, [x20]
   out[x++] = (unsigned char)z;
 113a214:	39000683 	strb	w3, [x20, #1]
   if (z == 5) {
 113a218:	f100147f 	cmp	x3, #0x5
 113a21c:	54000200 	b.eq	113a25c <der_encode_short_integer+0xe8>  // b.none
   out[x++] = (unsigned char)z;
 113a220:	d2800042 	mov	x2, #0x2                   	// #2
      out[x++] = (unsigned char)((num >> 24) & 0xFF);
 113a224:	8b020294 	add	x20, x20, x2
   for (y = 0; y < z; y++) {
 113a228:	eb03003f 	cmp	x1, x3
 113a22c:	54000201 	b.ne	113a26c <der_encode_short_integer+0xf8>  // b.any
   *outlen = x;
 113a230:	8b010041 	add	x1, x2, x1
 113a234:	f90002a1 	str	x1, [x21]
   return CRYPT_OK;
 113a238:	17ffffe2 	b	113a1c0 <der_encode_short_integer+0x4c>
   y = num;
 113a23c:	aa1303e1 	mov	x1, x19
   z = 0;
 113a240:	d2800003 	mov	x3, #0x0                   	// #0
 113a244:	17ffffe5 	b	113a1d8 <der_encode_short_integer+0x64>
   for (x = 0; (z <= 4) && (x < (4 - z)); x++) {
 113a248:	eb02009f 	cmp	x4, x2
 113a24c:	54fffe09 	b.ls	113a20c <der_encode_short_integer+0x98>  // b.plast
      num <<= 8;
 113a250:	d378de73 	lsl	x19, x19, #8
   for (x = 0; (z <= 4) && (x < (4 - z)); x++) {
 113a254:	91000442 	add	x2, x2, #0x1
 113a258:	17ffffeb 	b	113a204 <der_encode_short_integer+0x90>
      --z;
 113a25c:	d2800083 	mov	x3, #0x4                   	// #4
      out[x++] = 0;
 113a260:	d2800062 	mov	x2, #0x3                   	// #3
 113a264:	39000a9f 	strb	wzr, [x20, #2]
      --z;
 113a268:	17ffffef 	b	113a224 <der_encode_short_integer+0xb0>
      out[x++] = (unsigned char)((num >> 24) & 0xFF);
 113a26c:	d358fe64 	lsr	x4, x19, #24
      num    <<= 8;
 113a270:	d378de73 	lsl	x19, x19, #8
      out[x++] = (unsigned char)((num >> 24) & 0xFF);
 113a274:	38216a84 	strb	w4, [x20, x1]
   for (y = 0; y < z; y++) {
 113a278:	91000421 	add	x1, x1, #0x1
 113a27c:	17ffffeb 	b	113a228 <der_encode_short_integer+0xb4>
   LTC_ARGCHK(out    != NULL);
 113a280:	52800200 	mov	w0, #0x10                  	// #16
}
 113a284:	d65f03c0 	ret
   LTC_ARGCHK(out    != NULL);
 113a288:	52800200 	mov	w0, #0x10                  	// #16
 113a28c:	17ffffcd 	b	113a1c0 <der_encode_short_integer+0x4c>

000000000113a290 <der_length_short_integer>:
int der_length_short_integer(unsigned long num, unsigned long *outlen)
{
   unsigned long z, y;
   int err;

   LTC_ARGCHK(outlen  != NULL);
 113a290:	b4000481 	cbz	x1, 113a320 <der_length_short_integer+0x90>
{
 113a294:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!

   /* force to 32 bits */
   num &= 0xFFFFFFFFUL;
 113a298:	92407c00 	and	x0, x0, #0xffffffff

   /* get the number of bytes */
   z = 0;
   y = num;
   while (y) {
 113a29c:	52800002 	mov	w2, #0x0                   	// #0
{
 113a2a0:	910003fd 	mov	x29, sp
 113a2a4:	a90153f3 	stp	x19, x20, [sp, #16]
 113a2a8:	aa0103f4 	mov	x20, x1
   while (y) {
 113a2ac:	aa0003e1 	mov	x1, x0
   z = 0;
 113a2b0:	d2800013 	mov	x19, #0x0                   	// #0
   y = num;
 113a2b4:	f90017e0 	str	x0, [sp, #40]
   while (y) {
 113a2b8:	b5000281 	cbnz	x1, 113a308 <der_length_short_integer+0x78>
 113a2bc:	34000042 	cbz	w2, 113a2c4 <der_length_short_integer+0x34>
 113a2c0:	f90017ff 	str	xzr, [sp, #40]
     ++z;
     y >>= 8;
   }

   /* handle zero */
   if (z == 0) {
 113a2c4:	b40002b3 	cbz	x19, 113a318 <der_length_short_integer+0x88>
      z = 1;
   } else if ((num&(1UL<<((z<<3) - 1))) != 0) {
 113a2c8:	531d7261 	lsl	w1, w19, #3
 113a2cc:	51000421 	sub	w1, w1, #0x1
 113a2d0:	9ac12400 	lsr	x0, x0, x1
 113a2d4:	36000040 	tbz	w0, #0, 113a2dc <der_length_short_integer+0x4c>
      /* in case msb is set */
      ++z;
 113a2d8:	91000673 	add	x19, x19, #0x1
   }

   if ((err = der_length_asn1_length(z, &y)) != CRYPT_OK) {
 113a2dc:	9100a3e1 	add	x1, sp, #0x28
 113a2e0:	aa1303e0 	mov	x0, x19
 113a2e4:	94000c67 	bl	113d480 <der_length_asn1_length>
 113a2e8:	350000a0 	cbnz	w0, 113a2fc <der_length_short_integer+0x6c>
      return err;
   }
   *outlen = 1 + y + z;
 113a2ec:	f94017e2 	ldr	x2, [sp, #40]
 113a2f0:	91000442 	add	x2, x2, #0x1
 113a2f4:	8b130053 	add	x19, x2, x19
 113a2f8:	f9000293 	str	x19, [x20]

   return CRYPT_OK;
}
 113a2fc:	a94153f3 	ldp	x19, x20, [sp, #16]
 113a300:	a8c37bfd 	ldp	x29, x30, [sp], #48
 113a304:	d65f03c0 	ret
     ++z;
 113a308:	91000673 	add	x19, x19, #0x1
     y >>= 8;
 113a30c:	d348fc21 	lsr	x1, x1, #8
 113a310:	52800022 	mov	w2, #0x1                   	// #1
 113a314:	17ffffe9 	b	113a2b8 <der_length_short_integer+0x28>
      z = 1;
 113a318:	d2800033 	mov	x19, #0x1                   	// #1
 113a31c:	17fffff0 	b	113a2dc <der_length_short_integer+0x4c>
   LTC_ARGCHK(outlen  != NULL);
 113a320:	52800200 	mov	w0, #0x10                  	// #16
}
 113a324:	d65f03c0 	ret

000000000113a328 <der_encode_utctime>:
  @param outlen       [in/out] The length of the DER encoding
  @return CRYPT_OK if successful
*/
int der_encode_utctime(const ltc_utctime   *utctime,
                             unsigned char *out,   unsigned long *outlen)
{
 113a328:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
 113a32c:	910003fd 	mov	x29, sp
 113a330:	a90153f3 	stp	x19, x20, [sp, #16]
 113a334:	a9025bf5 	stp	x21, x22, [sp, #32]
 113a338:	a90363f7 	stp	x23, x24, [sp, #48]
 113a33c:	f90023f9 	str	x25, [sp, #64]
    unsigned long x, tmplen;
    int           err;

    LTC_ARGCHK(utctime != NULL);
 113a340:	b4001360 	cbz	x0, 113a5ac <der_encode_utctime+0x284>
 113a344:	aa0103f4 	mov	x20, x1
    LTC_ARGCHK(out     != NULL);
 113a348:	b4001321 	cbz	x1, 113a5ac <der_encode_utctime+0x284>
 113a34c:	aa0203f8 	mov	x24, x2
    LTC_ARGCHK(outlen  != NULL);
 113a350:	b40012e2 	cbz	x2, 113a5ac <der_encode_utctime+0x284>
 113a354:	aa0003f5 	mov	x21, x0

    if ((err = der_length_utctime(utctime, &tmplen)) != CRYPT_OK) {
 113a358:	910163e1 	add	x1, sp, #0x58
 113a35c:	94000096 	bl	113a5b4 <der_length_utctime>
 113a360:	2a0003f9 	mov	w25, w0
 113a364:	350000e0 	cbnz	w0, 113a380 <der_encode_utctime+0x58>
       return err;
    }
    if (tmplen > *outlen) {
 113a368:	f9400301 	ldr	x1, [x24]
 113a36c:	f9402fe0 	ldr	x0, [sp, #88]
 113a370:	eb00003f 	cmp	x1, x0
 113a374:	54000142 	b.cs	113a39c <der_encode_utctime+0x74>  // b.hs, b.nlast
        *outlen = tmplen;
        return CRYPT_BUFFER_OVERFLOW;
 113a378:	528000d9 	mov	w25, #0x6                   	// #6
        *outlen = tmplen;
 113a37c:	f9000300 	str	x0, [x24]
    out[1] = (unsigned char)(x - 2);

    /* all good let's return */
    *outlen = x;
    return CRYPT_OK;
}
 113a380:	2a1903e0 	mov	w0, w25
 113a384:	a94153f3 	ldp	x19, x20, [sp, #16]
 113a388:	a9425bf5 	ldp	x21, x22, [sp, #32]
 113a38c:	a94363f7 	ldp	x23, x24, [sp, #48]
 113a390:	f94023f9 	ldr	x25, [sp, #64]
 113a394:	a8c67bfd 	ldp	x29, x30, [sp], #96
 113a398:	d65f03c0 	ret
    out[0] = 0x17;
 113a39c:	528002e0 	mov	w0, #0x17                  	// #23
 113a3a0:	39000280 	strb	w0, [x20]
    STORE_V(utctime->YY);
 113a3a4:	52800153 	mov	w19, #0xa                   	// #10
 113a3a8:	900000f7 	adrp	x23, 1156000 <ta_pub_key_modulus+0x7>
 113a3ac:	b94002a0 	ldr	w0, [x21]
 113a3b0:	91331ef6 	add	x22, x23, #0xcc7
 113a3b4:	1ad30800 	udiv	w0, w0, w19
 113a3b8:	1ad30801 	udiv	w1, w0, w19
 113a3bc:	1b138020 	msub	w0, w1, w19, w0
 113a3c0:	38606ac0 	ldrb	w0, [x22, x0]
 113a3c4:	94000e6f 	bl	113dd80 <der_ia5_char_encode>
 113a3c8:	39000a80 	strb	w0, [x20, #2]
 113a3cc:	b94002a1 	ldr	w1, [x21]
 113a3d0:	1ad30820 	udiv	w0, w1, w19
 113a3d4:	1b138400 	msub	w0, w0, w19, w1
 113a3d8:	38606ac0 	ldrb	w0, [x22, x0]
 113a3dc:	94000e69 	bl	113dd80 <der_ia5_char_encode>
 113a3e0:	39000e80 	strb	w0, [x20, #3]
    STORE_V(utctime->MM);
 113a3e4:	b94006a0 	ldr	w0, [x21, #4]
 113a3e8:	1ad30800 	udiv	w0, w0, w19
 113a3ec:	1ad30801 	udiv	w1, w0, w19
 113a3f0:	1b138020 	msub	w0, w1, w19, w0
 113a3f4:	38606ac0 	ldrb	w0, [x22, x0]
 113a3f8:	94000e62 	bl	113dd80 <der_ia5_char_encode>
 113a3fc:	39001280 	strb	w0, [x20, #4]
 113a400:	b94006a1 	ldr	w1, [x21, #4]
 113a404:	1ad30820 	udiv	w0, w1, w19
 113a408:	1b138400 	msub	w0, w0, w19, w1
 113a40c:	38606ac0 	ldrb	w0, [x22, x0]
 113a410:	94000e5c 	bl	113dd80 <der_ia5_char_encode>
 113a414:	39001680 	strb	w0, [x20, #5]
    STORE_V(utctime->DD);
 113a418:	b9400aa0 	ldr	w0, [x21, #8]
 113a41c:	1ad30800 	udiv	w0, w0, w19
 113a420:	1ad30801 	udiv	w1, w0, w19
 113a424:	1b138020 	msub	w0, w1, w19, w0
 113a428:	38606ac0 	ldrb	w0, [x22, x0]
 113a42c:	94000e55 	bl	113dd80 <der_ia5_char_encode>
 113a430:	39001a80 	strb	w0, [x20, #6]
 113a434:	b9400aa1 	ldr	w1, [x21, #8]
 113a438:	1ad30820 	udiv	w0, w1, w19
 113a43c:	1b138400 	msub	w0, w0, w19, w1
 113a440:	38606ac0 	ldrb	w0, [x22, x0]
 113a444:	94000e4f 	bl	113dd80 <der_ia5_char_encode>
 113a448:	39001e80 	strb	w0, [x20, #7]
    STORE_V(utctime->hh);
 113a44c:	b9400ea0 	ldr	w0, [x21, #12]
 113a450:	1ad30800 	udiv	w0, w0, w19
 113a454:	1ad30801 	udiv	w1, w0, w19
 113a458:	1b138020 	msub	w0, w1, w19, w0
 113a45c:	38606ac0 	ldrb	w0, [x22, x0]
 113a460:	94000e48 	bl	113dd80 <der_ia5_char_encode>
 113a464:	39002280 	strb	w0, [x20, #8]
 113a468:	b9400ea1 	ldr	w1, [x21, #12]
 113a46c:	1ad30820 	udiv	w0, w1, w19
 113a470:	1b138400 	msub	w0, w0, w19, w1
 113a474:	38606ac0 	ldrb	w0, [x22, x0]
 113a478:	94000e42 	bl	113dd80 <der_ia5_char_encode>
 113a47c:	39002680 	strb	w0, [x20, #9]
    STORE_V(utctime->mm);
 113a480:	b94012a0 	ldr	w0, [x21, #16]
 113a484:	1ad30800 	udiv	w0, w0, w19
 113a488:	1ad30801 	udiv	w1, w0, w19
 113a48c:	1b138020 	msub	w0, w1, w19, w0
 113a490:	38606ac0 	ldrb	w0, [x22, x0]
 113a494:	94000e3b 	bl	113dd80 <der_ia5_char_encode>
 113a498:	39002a80 	strb	w0, [x20, #10]
 113a49c:	b94012a1 	ldr	w1, [x21, #16]
 113a4a0:	1ad30820 	udiv	w0, w1, w19
 113a4a4:	1b138400 	msub	w0, w0, w19, w1
 113a4a8:	38606ac0 	ldrb	w0, [x22, x0]
 113a4ac:	94000e35 	bl	113dd80 <der_ia5_char_encode>
 113a4b0:	39002e80 	strb	w0, [x20, #11]
    STORE_V(utctime->ss);
 113a4b4:	b94016a0 	ldr	w0, [x21, #20]
 113a4b8:	1ad30800 	udiv	w0, w0, w19
 113a4bc:	1ad30801 	udiv	w1, w0, w19
 113a4c0:	1b138020 	msub	w0, w1, w19, w0
 113a4c4:	38606ac0 	ldrb	w0, [x22, x0]
 113a4c8:	94000e2e 	bl	113dd80 <der_ia5_char_encode>
 113a4cc:	39003280 	strb	w0, [x20, #12]
 113a4d0:	b94016a1 	ldr	w1, [x21, #20]
 113a4d4:	1ad30820 	udiv	w0, w1, w19
 113a4d8:	1b138413 	msub	w19, w0, w19, w1
 113a4dc:	38736ac0 	ldrb	w0, [x22, x19]
 113a4e0:	94000e28 	bl	113dd80 <der_ia5_char_encode>
 113a4e4:	39003680 	strb	w0, [x20, #13]
    if (utctime->off_mm || utctime->off_hh) {
 113a4e8:	b94022a0 	ldr	w0, [x21, #32]
 113a4ec:	35000060 	cbnz	w0, 113a4f8 <der_encode_utctime+0x1d0>
 113a4f0:	b9401ea0 	ldr	w0, [x21, #28]
 113a4f4:	34000520 	cbz	w0, 113a598 <der_encode_utctime+0x270>
       out[x++] = der_ia5_char_encode(utctime->off_dir ? '-' : '+');
 113a4f8:	b9401aa0 	ldr	w0, [x21, #24]
 113a4fc:	528005a1 	mov	w1, #0x2d                  	// #45
       STORE_V(utctime->off_hh);
 113a500:	52800153 	mov	w19, #0xa                   	// #10
 113a504:	91331ef7 	add	x23, x23, #0xcc7
       out[x++] = der_ia5_char_encode(utctime->off_dir ? '-' : '+');
 113a508:	7100001f 	cmp	w0, #0x0
 113a50c:	52800560 	mov	w0, #0x2b                  	// #43
 113a510:	1a801020 	csel	w0, w1, w0, ne  // ne = any
 113a514:	94000e1b 	bl	113dd80 <der_ia5_char_encode>
 113a518:	39003a80 	strb	w0, [x20, #14]
       STORE_V(utctime->off_hh);
 113a51c:	b9401ea0 	ldr	w0, [x21, #28]
 113a520:	1ad30800 	udiv	w0, w0, w19
 113a524:	1ad30801 	udiv	w1, w0, w19
 113a528:	1b138020 	msub	w0, w1, w19, w0
 113a52c:	38606ae0 	ldrb	w0, [x23, x0]
 113a530:	94000e14 	bl	113dd80 <der_ia5_char_encode>
 113a534:	39003e80 	strb	w0, [x20, #15]
 113a538:	b9401ea1 	ldr	w1, [x21, #28]
 113a53c:	1ad30820 	udiv	w0, w1, w19
 113a540:	1b138400 	msub	w0, w0, w19, w1
 113a544:	38606ae0 	ldrb	w0, [x23, x0]
 113a548:	94000e0e 	bl	113dd80 <der_ia5_char_encode>
 113a54c:	39004280 	strb	w0, [x20, #16]
       STORE_V(utctime->off_mm);
 113a550:	b94022a1 	ldr	w1, [x21, #32]
 113a554:	1ad30821 	udiv	w1, w1, w19
 113a558:	1ad30820 	udiv	w0, w1, w19
 113a55c:	1b138401 	msub	w1, w0, w19, w1
 113a560:	38616ae0 	ldrb	w0, [x23, x1]
 113a564:	94000e07 	bl	113dd80 <der_ia5_char_encode>
 113a568:	39004680 	strb	w0, [x20, #17]
 113a56c:	b94022a1 	ldr	w1, [x21, #32]
 113a570:	1ad30820 	udiv	w0, w1, w19
 113a574:	1b138413 	msub	w19, w0, w19, w1
 113a578:	38736ae0 	ldrb	w0, [x23, x19]
 113a57c:	94000e01 	bl	113dd80 <der_ia5_char_encode>
 113a580:	39004a80 	strb	w0, [x20, #18]
 113a584:	d2800260 	mov	x0, #0x13                  	// #19
    out[1] = (unsigned char)(x - 2);
 113a588:	51000801 	sub	w1, w0, #0x2
 113a58c:	39000681 	strb	w1, [x20, #1]
    *outlen = x;
 113a590:	f9000300 	str	x0, [x24]
    return CRYPT_OK;
 113a594:	17ffff7b 	b	113a380 <der_encode_utctime+0x58>
       out[x++] = der_ia5_char_encode('Z');
 113a598:	52800b40 	mov	w0, #0x5a                  	// #90
 113a59c:	94000df9 	bl	113dd80 <der_ia5_char_encode>
 113a5a0:	39003a80 	strb	w0, [x20, #14]
 113a5a4:	d28001e0 	mov	x0, #0xf                   	// #15
 113a5a8:	17fffff8 	b	113a588 <der_encode_utctime+0x260>
    LTC_ARGCHK(utctime != NULL);
 113a5ac:	52800219 	mov	w25, #0x10                  	// #16
 113a5b0:	17ffff74 	b	113a380 <der_encode_utctime+0x58>

000000000113a5b4 <der_length_utctime>:
  @param outlen [out] The length of the DER encoding
  @return CRYPT_OK if successful
*/
int der_length_utctime(const ltc_utctime *utctime, unsigned long *outlen)
{
   LTC_ARGCHK(outlen  != NULL);
 113a5b4:	b4000181 	cbz	x1, 113a5e4 <der_length_utctime+0x30>
   LTC_ARGCHK(utctime != NULL);
 113a5b8:	b4000160 	cbz	x0, 113a5e4 <der_length_utctime+0x30>

   if (utctime->off_hh == 0 && utctime->off_mm == 0) {
 113a5bc:	b9401c02 	ldr	w2, [x0, #28]
 113a5c0:	350000e2 	cbnz	w2, 113a5dc <der_length_utctime+0x28>
 113a5c4:	b9402000 	ldr	w0, [x0, #32]
 113a5c8:	350000a0 	cbnz	w0, 113a5dc <der_length_utctime+0x28>
      /* we encode as YYMMDDhhmmssZ */
      *outlen = 2 + 13;
 113a5cc:	d28001e0 	mov	x0, #0xf                   	// #15
   } else {
      /* we encode as YYMMDDhhmmss{+|-}hh'mm' */
      *outlen = 2 + 17;
 113a5d0:	f9000020 	str	x0, [x1]
   }

   return CRYPT_OK;
 113a5d4:	52800000 	mov	w0, #0x0                   	// #0
}
 113a5d8:	d65f03c0 	ret
      *outlen = 2 + 17;
 113a5dc:	d2800260 	mov	x0, #0x13                  	// #19
 113a5e0:	17fffffc 	b	113a5d0 <der_length_utctime+0x1c>
   LTC_ARGCHK(outlen  != NULL);
 113a5e4:	52800200 	mov	w0, #0x10                  	// #16
 113a5e8:	17fffffc 	b	113a5d8 <der_length_utctime+0x24>

000000000113a5ec <der_encode_utf8_string>:
  @param outlen   [in/out] The max size and resulting size of the DER UTF8 STRING
  @return CRYPT_OK if successful
*/
int der_encode_utf8_string(const wchar_t *in,  unsigned long inlen,
                           unsigned char *out, unsigned long *outlen)
{
 113a5ec:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 113a5f0:	910003fd 	mov	x29, sp
 113a5f4:	a90153f3 	stp	x19, x20, [sp, #16]
 113a5f8:	a9025bf5 	stp	x21, x22, [sp, #32]
 113a5fc:	a90363f7 	stp	x23, x24, [sp, #48]
   unsigned long x, y, len;
   int err;

   LTC_ARGCHK(in     != NULL);
 113a600:	b5000100 	cbnz	x0, 113a620 <der_encode_utf8_string+0x34>
 113a604:	52800215 	mov	w21, #0x10                  	// #16

   /* return length */
   *outlen = x;

   return CRYPT_OK;
}
 113a608:	2a1503e0 	mov	w0, w21
 113a60c:	a94153f3 	ldp	x19, x20, [sp, #16]
 113a610:	a9425bf5 	ldp	x21, x22, [sp, #32]
 113a614:	a94363f7 	ldp	x23, x24, [sp, #48]
 113a618:	a8c57bfd 	ldp	x29, x30, [sp], #80
 113a61c:	d65f03c0 	ret
 113a620:	aa0203f4 	mov	x20, x2
   LTC_ARGCHK(out    != NULL);
 113a624:	b4ffff02 	cbz	x2, 113a604 <der_encode_utf8_string+0x18>
 113a628:	aa0303f6 	mov	x22, x3
   LTC_ARGCHK(outlen != NULL);
 113a62c:	b4fffec3 	cbz	x3, 113a604 <der_encode_utf8_string+0x18>
 113a630:	aa0003f3 	mov	x19, x0
 113a634:	aa0103f7 	mov	x23, x1
   for (x = len = 0; x < inlen; x++) {
 113a638:	d2800018 	mov	x24, #0x0                   	// #0
 113a63c:	f90023ff 	str	xzr, [sp, #64]
 113a640:	f94023e0 	ldr	x0, [sp, #64]
 113a644:	eb17001f 	cmp	x0, x23
 113a648:	540001e3 	b.cc	113a684 <der_encode_utf8_string+0x98>  // b.lo, b.ul, b.last
   if ((err = der_length_asn1_length(len, &x)) != CRYPT_OK) {
 113a64c:	910103e1 	add	x1, sp, #0x40
 113a650:	aa1803e0 	mov	x0, x24
 113a654:	94000b8b 	bl	113d480 <der_length_asn1_length>
 113a658:	2a0003f5 	mov	w21, w0
 113a65c:	35fffd60 	cbnz	w0, 113a608 <der_encode_utf8_string+0x1c>
   x += len + 1;
 113a660:	f94023e0 	ldr	x0, [sp, #64]
   if (x > *outlen) {
 113a664:	f94002c1 	ldr	x1, [x22]
   x += len + 1;
 113a668:	91000400 	add	x0, x0, #0x1
 113a66c:	8b180000 	add	x0, x0, x24
   if (x > *outlen) {
 113a670:	eb01001f 	cmp	x0, x1
 113a674:	540001e9 	b.ls	113a6b0 <der_encode_utf8_string+0xc4>  // b.plast
      return CRYPT_BUFFER_OVERFLOW;
 113a678:	528000d5 	mov	w21, #0x6                   	// #6
      *outlen = x;
 113a67c:	f90002c0 	str	x0, [x22]
      return CRYPT_BUFFER_OVERFLOW;
 113a680:	17ffffe2 	b	113a608 <der_encode_utf8_string+0x1c>
       if (!der_utf8_valid_char(in[x])) return CRYPT_INVALID_ARG;
 113a684:	b8607a60 	ldr	w0, [x19, x0, lsl #2]
 113a688:	94000076 	bl	113a860 <der_utf8_valid_char>
 113a68c:	34fffbc0 	cbz	w0, 113a604 <der_encode_utf8_string+0x18>
       len += der_utf8_charsize(in[x]);
 113a690:	f94023e0 	ldr	x0, [sp, #64]
 113a694:	b8607a60 	ldr	w0, [x19, x0, lsl #2]
 113a698:	94000065 	bl	113a82c <der_utf8_charsize>
 113a69c:	8b000318 	add	x24, x24, x0
   for (x = len = 0; x < inlen; x++) {
 113a6a0:	f94023e0 	ldr	x0, [sp, #64]
 113a6a4:	91000400 	add	x0, x0, #0x1
 113a6a8:	f90023e0 	str	x0, [sp, #64]
 113a6ac:	17ffffe5 	b	113a640 <der_encode_utf8_string+0x54>
   out[x++] = 0x0C;
 113a6b0:	aa1403e1 	mov	x1, x20
 113a6b4:	d2800020 	mov	x0, #0x1                   	// #1
 113a6b8:	f90023e0 	str	x0, [sp, #64]
 113a6bc:	52800180 	mov	w0, #0xc                   	// #12
   if ((err = der_encode_asn1_length(len, out + x, &y)) != CRYPT_OK) {
 113a6c0:	910123e2 	add	x2, sp, #0x48
   out[x++] = 0x0C;
 113a6c4:	38001420 	strb	w0, [x1], #1
   y = *outlen - x;
 113a6c8:	f94002c0 	ldr	x0, [x22]
 113a6cc:	d1000400 	sub	x0, x0, #0x1
 113a6d0:	f90027e0 	str	x0, [sp, #72]
   if ((err = der_encode_asn1_length(len, out + x, &y)) != CRYPT_OK) {
 113a6d4:	aa1803e0 	mov	x0, x24
 113a6d8:	94000aea 	bl	113d280 <der_encode_asn1_length>
 113a6dc:	2a0003f5 	mov	w21, w0
 113a6e0:	35fff940 	cbnz	w0, 113a608 <der_encode_utf8_string+0x1c>
   x += y;
 113a6e4:	a94407e0 	ldp	x0, x1, [sp, #64]
 113a6e8:	d00000b8 	adrp	x24, 1150000 <Te4+0x258>
 113a6ec:	91108318 	add	x24, x24, #0x420
 113a6f0:	8b010000 	add	x0, x0, x1
   for (y = 0; y < inlen; y++) {
 113a6f4:	a9047fe0 	stp	x0, xzr, [sp, #64]
 113a6f8:	f94027e0 	ldr	x0, [sp, #72]
 113a6fc:	eb17001f 	cmp	x0, x23
 113a700:	54000083 	b.cc	113a710 <der_encode_utf8_string+0x124>  // b.lo, b.ul, b.last
   *outlen = x;
 113a704:	f94023e0 	ldr	x0, [sp, #64]
 113a708:	f90002c0 	str	x0, [x22]
   return CRYPT_OK;
 113a70c:	17ffffbf 	b	113a608 <der_encode_utf8_string+0x1c>
       switch (der_utf8_charsize(in[y])) {
 113a710:	b8607a60 	ldr	w0, [x19, x0, lsl #2]
 113a714:	94000046 	bl	113a82c <der_utf8_charsize>
 113a718:	d1000400 	sub	x0, x0, #0x1
 113a71c:	f1000c1f 	cmp	x0, #0x3
 113a720:	f94027e2 	ldr	x2, [sp, #72]
 113a724:	54000188 	b.hi	113a754 <der_encode_utf8_string+0x168>  // b.pmore
 113a728:	71000c1f 	cmp	w0, #0x3
 113a72c:	54000148 	b.hi	113a754 <der_encode_utf8_string+0x168>  // b.pmore
 113a730:	f94023e4 	ldr	x4, [sp, #64]
 113a734:	38604b00 	ldrb	w0, [x24, w0, uxtw]
 113a738:	10000061 	adr	x1, 113a744 <der_encode_utf8_string+0x158>
 113a73c:	8b208820 	add	x0, x1, w0, sxtb #2
 113a740:	d61f0000 	br	x0
          case 1: out[x++] = (unsigned char)in[y]; break;
 113a744:	b8627a60 	ldr	w0, [x19, x2, lsl #2]
 113a748:	91000481 	add	x1, x4, #0x1
 113a74c:	38246a80 	strb	w0, [x20, x4]
 113a750:	f90023e1 	str	x1, [sp, #64]
   for (y = 0; y < inlen; y++) {
 113a754:	91000442 	add	x2, x2, #0x1
 113a758:	f90027e2 	str	x2, [sp, #72]
 113a75c:	17ffffe7 	b	113a6f8 <der_encode_utf8_string+0x10c>
          case 2: out[x++] = 0xC0 | ((in[y] >> 6) & 0x1F);  out[x++] = 0x80 | (in[y] & 0x3F); break;
 113a760:	d37ef441 	lsl	x1, x2, #2
 113a764:	b8616a60 	ldr	w0, [x19, x1]
 113a768:	d3462800 	ubfx	x0, x0, #6, #5
 113a76c:	321a6400 	orr	w0, w0, #0xffffffc0
 113a770:	38246a80 	strb	w0, [x20, x4]
 113a774:	b8616a60 	ldr	w0, [x19, x1]
 113a778:	91000881 	add	x1, x4, #0x2
 113a77c:	8b040284 	add	x4, x20, x4
 113a780:	f90023e1 	str	x1, [sp, #64]
 113a784:	12001400 	and	w0, w0, #0x3f
 113a788:	32196000 	orr	w0, w0, #0xffffff80
 113a78c:	39000480 	strb	w0, [x4, #1]
 113a790:	17fffff1 	b	113a754 <der_encode_utf8_string+0x168>
          case 3: out[x++] = 0xE0 | ((in[y] >> 12) & 0x0F); out[x++] = 0x80 | ((in[y] >> 6) & 0x3F); out[x++] = 0x80 | (in[y] & 0x3F); break;
 113a794:	d37ef441 	lsl	x1, x2, #2
 113a798:	8b040283 	add	x3, x20, x4
 113a79c:	b8616a60 	ldr	w0, [x19, x1]
 113a7a0:	d34c3c00 	ubfx	x0, x0, #12, #4
 113a7a4:	321b6800 	orr	w0, w0, #0xffffffe0
 113a7a8:	38246a80 	strb	w0, [x20, x4]
 113a7ac:	91000c84 	add	x4, x4, #0x3
 113a7b0:	f90023e4 	str	x4, [sp, #64]
 113a7b4:	b8616a60 	ldr	w0, [x19, x1]
 113a7b8:	d3462c00 	ubfx	x0, x0, #6, #6
 113a7bc:	32196000 	orr	w0, w0, #0xffffff80
 113a7c0:	39000460 	strb	w0, [x3, #1]
 113a7c4:	b8616a60 	ldr	w0, [x19, x1]
 113a7c8:	12001400 	and	w0, w0, #0x3f
 113a7cc:	32196000 	orr	w0, w0, #0xffffff80
 113a7d0:	39000860 	strb	w0, [x3, #2]
 113a7d4:	17ffffe0 	b	113a754 <der_encode_utf8_string+0x168>
          case 4: out[x++] = 0xF0 | ((in[y] >> 18) & 0x07); out[x++] = 0x80 | ((in[y] >> 12) & 0x3F); out[x++] = 0x80 | ((in[y] >> 6) & 0x3F); out[x++] = 0x80 | (in[y] & 0x3F); break;
 113a7d8:	d37ef441 	lsl	x1, x2, #2
 113a7dc:	8b040283 	add	x3, x20, x4
 113a7e0:	b8616a60 	ldr	w0, [x19, x1]
 113a7e4:	d3525000 	ubfx	x0, x0, #18, #3
 113a7e8:	321c6c00 	orr	w0, w0, #0xfffffff0
 113a7ec:	38246a80 	strb	w0, [x20, x4]
 113a7f0:	91001084 	add	x4, x4, #0x4
 113a7f4:	f90023e4 	str	x4, [sp, #64]
 113a7f8:	b8616a60 	ldr	w0, [x19, x1]
 113a7fc:	d34c4400 	ubfx	x0, x0, #12, #6
 113a800:	32196000 	orr	w0, w0, #0xffffff80
 113a804:	39000460 	strb	w0, [x3, #1]
 113a808:	b8616a60 	ldr	w0, [x19, x1]
 113a80c:	d3462c00 	ubfx	x0, x0, #6, #6
 113a810:	32196000 	orr	w0, w0, #0xffffff80
 113a814:	39000860 	strb	w0, [x3, #2]
 113a818:	b8616a60 	ldr	w0, [x19, x1]
 113a81c:	12001400 	and	w0, w0, #0x3f
 113a820:	32196000 	orr	w0, w0, #0xffffff80
 113a824:	39000c60 	strb	w0, [x3, #3]
 113a828:	17ffffcb 	b	113a754 <der_encode_utf8_string+0x168>

000000000113a82c <der_utf8_charsize>:
  @param c   The UTF-8 character to measure
  @return    The size in bytes
*/
unsigned long der_utf8_charsize(const wchar_t c)
{
   if (c <= 0x7F) {
 113a82c:	7101fc1f 	cmp	w0, #0x7f
 113a830:	54000109 	b.ls	113a850 <der_utf8_charsize+0x24>  // b.plast
      return 1;
   }
   if (c <= 0x7FF) {
 113a834:	711ffc1f 	cmp	w0, #0x7ff
 113a838:	54000109 	b.ls	113a858 <der_utf8_charsize+0x2c>  // b.plast
      return 2;
   }
#if LTC_WCHAR_MAX == 0xFFFF
   return 3;
#else
   if (c <= 0xFFFF) {
 113a83c:	529fffe1 	mov	w1, #0xffff                	// #65535
      return 3;
 113a840:	6b01001f 	cmp	w0, w1
 113a844:	9a9f97e0 	cset	x0, hi  // hi = pmore
 113a848:	91000c00 	add	x0, x0, #0x3
   }
   return 4;
#endif
}
 113a84c:	d65f03c0 	ret
      return 1;
 113a850:	d2800020 	mov	x0, #0x1                   	// #1
 113a854:	17fffffe 	b	113a84c <der_utf8_charsize+0x20>
      return 2;
 113a858:	d2800040 	mov	x0, #0x2                   	// #2
 113a85c:	17fffffc 	b	113a84c <der_utf8_charsize+0x20>

000000000113a860 <der_utf8_valid_char>:
*/
int der_utf8_valid_char(const wchar_t c)
{
   LTC_UNUSED_PARAM(c);
#if !defined(LTC_WCHAR_MAX) || LTC_WCHAR_MAX > 0xFFFF
   if (c > 0x10FFFF) return 0;
 113a860:	12bffde1 	mov	w1, #0x10ffff              	// #1114111
 113a864:	6b01001f 	cmp	w0, w1
#endif
#if LTC_WCHAR_MAX != 0xFFFF && LTC_WCHAR_MAX != 0xFFFFFFFF
   if (c < 0) return 0;
#endif
   return 1;
}
 113a868:	1a9f87e0 	cset	w0, ls  // ls = plast
 113a86c:	d65f03c0 	ret

000000000113a870 <der_length_utf8_string>:
int der_length_utf8_string(const wchar_t *in, unsigned long noctets, unsigned long *outlen)
{
   unsigned long x, len;
   int err;

   LTC_ARGCHK(in     != NULL);
 113a870:	b40004c0 	cbz	x0, 113a908 <der_length_utf8_string+0x98>
{
 113a874:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 113a878:	910003fd 	mov	x29, sp
 113a87c:	a90153f3 	stp	x19, x20, [sp, #16]
 113a880:	aa0203f3 	mov	x19, x2
   LTC_ARGCHK(outlen != NULL);
 113a884:	b4000322 	cbz	x2, 113a8e8 <der_length_utf8_string+0x78>

   len = 0;
   for (x = 0; x < noctets; x++) {
      if (!der_utf8_valid_char(in[x])) return CRYPT_INVALID_ARG;
 113a888:	d1001003 	sub	x3, x0, #0x4
 113a88c:	aa0103e5 	mov	x5, x1
   for (x = 0; x < noctets; x++) {
 113a890:	d2800004 	mov	x4, #0x0                   	// #0
 113a894:	52800001 	mov	w1, #0x0                   	// #0
   len = 0;
 113a898:	d2800014 	mov	x20, #0x0                   	// #0
   if (c > 0x10FFFF) return 0;
 113a89c:	12bffde2 	mov	w2, #0x10ffff              	// #1114111
   for (x = 0; x < noctets; x++) {
 113a8a0:	f90017ff 	str	xzr, [sp, #40]
 113a8a4:	eb05009f 	cmp	x4, x5
 113a8a8:	54000181 	b.ne	113a8d8 <der_length_utf8_string+0x68>  // b.any
 113a8ac:	34000041 	cbz	w1, 113a8b4 <der_length_utf8_string+0x44>
 113a8b0:	f90017e4 	str	x4, [sp, #40]
      len += der_utf8_charsize(in[x]);
   }

   if ((err = der_length_asn1_length(len, &x)) != CRYPT_OK) {
 113a8b4:	9100a3e1 	add	x1, sp, #0x28
 113a8b8:	aa1403e0 	mov	x0, x20
 113a8bc:	94000af1 	bl	113d480 <der_length_asn1_length>
 113a8c0:	35000160 	cbnz	w0, 113a8ec <der_length_utf8_string+0x7c>
      return err;
   }
   *outlen = 1 + x + len;
 113a8c4:	f94017e1 	ldr	x1, [sp, #40]
 113a8c8:	91000421 	add	x1, x1, #0x1
 113a8cc:	8b140021 	add	x1, x1, x20
 113a8d0:	f9000261 	str	x1, [x19]

   return CRYPT_OK;
 113a8d4:	14000006 	b	113a8ec <der_length_utf8_string+0x7c>
      if (!der_utf8_valid_char(in[x])) return CRYPT_INVALID_ARG;
 113a8d8:	91000484 	add	x4, x4, #0x1
 113a8dc:	b8647860 	ldr	w0, [x3, x4, lsl #2]
   if (c > 0x10FFFF) return 0;
 113a8e0:	6b02001f 	cmp	w0, w2
 113a8e4:	540000a9 	b.ls	113a8f8 <der_length_utf8_string+0x88>  // b.plast
      if (!der_utf8_valid_char(in[x])) return CRYPT_INVALID_ARG;
 113a8e8:	52800200 	mov	w0, #0x10                  	// #16
}
 113a8ec:	a94153f3 	ldp	x19, x20, [sp, #16]
 113a8f0:	a8c37bfd 	ldp	x29, x30, [sp], #48
 113a8f4:	d65f03c0 	ret
      len += der_utf8_charsize(in[x]);
 113a8f8:	97ffffcd 	bl	113a82c <der_utf8_charsize>
 113a8fc:	8b000294 	add	x20, x20, x0
 113a900:	52800021 	mov	w1, #0x1                   	// #1
 113a904:	17ffffe8 	b	113a8a4 <der_length_utf8_string+0x34>
      if (!der_utf8_valid_char(in[x])) return CRYPT_INVALID_ARG;
 113a908:	52800200 	mov	w0, #0x10                  	// #16
}
 113a90c:	d65f03c0 	ret

000000000113a910 <der_teletex_char_encode>:

int der_teletex_char_encode(int c)
{
   int x;
   for (x = 0; x < (int)(sizeof(teletex_table)/sizeof(teletex_table[0])); x++) {
       if (teletex_table[x].code == c) {
 113a910:	d00000a2 	adrp	x2, 1150000 <Te4+0x258>
 113a914:	91109042 	add	x2, x2, #0x424
{
 113a918:	d2800001 	mov	x1, #0x0                   	// #0
       if (teletex_table[x].code == c) {
 113a91c:	d37df024 	lsl	x4, x1, #3
 113a920:	b8626884 	ldr	w4, [x4, x2]
 113a924:	6b00009f 	cmp	w4, w0
 113a928:	54000081 	b.ne	113a938 <der_teletex_char_encode+0x28>  // b.any
          return teletex_table[x].value;
 113a92c:	8b21cc42 	add	x2, x2, w1, sxtw #3
 113a930:	b9400440 	ldr	w0, [x2, #4]
       }
   }
   return -1;
}
 113a934:	d65f03c0 	ret
   for (x = 0; x < (int)(sizeof(teletex_table)/sizeof(teletex_table[0])); x++) {
 113a938:	91000421 	add	x1, x1, #0x1
 113a93c:	f101d83f 	cmp	x1, #0x76
 113a940:	54fffee1 	b.ne	113a91c <der_teletex_char_encode+0xc>  // b.any
   return -1;
 113a944:	12800000 	mov	w0, #0xffffffff            	// #-1
 113a948:	17fffffb 	b	113a934 <der_teletex_char_encode+0x24>

000000000113a94c <der_teletex_value_decode>:

int der_teletex_value_decode(int v)
{
   int x;
   for (x = 0; x < (int)(sizeof(teletex_table)/sizeof(teletex_table[0])); x++) {
 113a94c:	d00000a2 	adrp	x2, 1150000 <Te4+0x258>
 113a950:	91109043 	add	x3, x2, #0x424
 113a954:	52800001 	mov	w1, #0x0                   	// #0
       if (teletex_table[x].value == v) {
 113a958:	b9400464 	ldr	w4, [x3, #4]
 113a95c:	6b00009f 	cmp	w4, w0
 113a960:	540000a1 	b.ne	113a974 <der_teletex_value_decode+0x28>  // b.any
          return teletex_table[x].code;
 113a964:	91109042 	add	x2, x2, #0x424
 113a968:	937d7c21 	sbfiz	x1, x1, #3, #32
 113a96c:	b8616840 	ldr	w0, [x2, x1]
       }
   }
   return -1;
}
 113a970:	d65f03c0 	ret
   for (x = 0; x < (int)(sizeof(teletex_table)/sizeof(teletex_table[0])); x++) {
 113a974:	11000421 	add	w1, w1, #0x1
 113a978:	91002063 	add	x3, x3, #0x8
 113a97c:	7101d83f 	cmp	w1, #0x76
 113a980:	54fffec1 	b.ne	113a958 <der_teletex_value_decode+0xc>  // b.any
   return -1;
 113a984:	12800000 	mov	w0, #0xffffffff            	// #-1
 113a988:	17fffffa 	b	113a970 <der_teletex_value_decode+0x24>

000000000113a98c <der_length_teletex_string>:
int der_length_teletex_string(const unsigned char *octets, unsigned long noctets, unsigned long *outlen)
{
   unsigned long x;
   int err;

   LTC_ARGCHK(outlen != NULL);
 113a98c:	b4000442 	cbz	x2, 113aa14 <der_length_teletex_string+0x88>
 113a990:	aa0003e5 	mov	x5, x0
   LTC_ARGCHK(octets != NULL);
 113a994:	b4000400 	cbz	x0, 113aa14 <der_length_teletex_string+0x88>
{
 113a998:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!

   /* scan string for validity */
   for (x = 0; x < noctets; x++) {
 113a99c:	d2800003 	mov	x3, #0x0                   	// #0
{
 113a9a0:	910003fd 	mov	x29, sp
 113a9a4:	a90153f3 	stp	x19, x20, [sp, #16]
 113a9a8:	aa0203f4 	mov	x20, x2
   for (x = 0; x < noctets; x++) {
 113a9ac:	aa0103f3 	mov	x19, x1
 113a9b0:	52800001 	mov	w1, #0x0                   	// #0
 113a9b4:	f90017ff 	str	xzr, [sp, #40]
 113a9b8:	eb03027f 	cmp	x19, x3
 113a9bc:	54000181 	b.ne	113a9ec <der_length_teletex_string+0x60>  // b.any
 113a9c0:	34000041 	cbz	w1, 113a9c8 <der_length_teletex_string+0x3c>
 113a9c4:	f90017f3 	str	x19, [sp, #40]
       if (der_teletex_char_encode(octets[x]) == -1) {
          return CRYPT_INVALID_ARG;
       }
   }

   if ((err = der_length_asn1_length(noctets, &x)) != CRYPT_OK) {
 113a9c8:	9100a3e1 	add	x1, sp, #0x28
 113a9cc:	aa1303e0 	mov	x0, x19
 113a9d0:	94000aac 	bl	113d480 <der_length_asn1_length>
 113a9d4:	350001a0 	cbnz	w0, 113aa08 <der_length_teletex_string+0x7c>
      return err;
   }
   *outlen = 1 + x + noctets;
 113a9d8:	f94017e1 	ldr	x1, [sp, #40]
 113a9dc:	91000421 	add	x1, x1, #0x1
 113a9e0:	8b130033 	add	x19, x1, x19
 113a9e4:	f9000293 	str	x19, [x20]

   return CRYPT_OK;
 113a9e8:	14000008 	b	113aa08 <der_length_teletex_string+0x7c>
       if (der_teletex_char_encode(octets[x]) == -1) {
 113a9ec:	386368a0 	ldrb	w0, [x5, x3]
 113a9f0:	97ffffc8 	bl	113a910 <der_teletex_char_encode>
 113a9f4:	91000463 	add	x3, x3, #0x1
 113a9f8:	3100041f 	cmn	w0, #0x1
 113a9fc:	52800021 	mov	w1, #0x1                   	// #1
 113aa00:	54fffdc1 	b.ne	113a9b8 <der_length_teletex_string+0x2c>  // b.any
          return CRYPT_INVALID_ARG;
 113aa04:	52800200 	mov	w0, #0x10                  	// #16
}
 113aa08:	a94153f3 	ldp	x19, x20, [sp, #16]
 113aa0c:	a8c37bfd 	ldp	x29, x30, [sp], #48
 113aa10:	d65f03c0 	ret
          return CRYPT_INVALID_ARG;
 113aa14:	52800200 	mov	w0, #0x10                  	// #16
}
 113aa18:	d65f03c0 	ret

000000000113aa1c <pk_oid_cmp_with_ulong>:
/*
   Compare an OID string to an array of `unsigned long`.
   @return CRYPT_OK if equal
*/
int pk_oid_cmp_with_ulong(const char *o1, const unsigned long *o2, unsigned long o2size)
{
 113aa1c:	a9ac7bfd 	stp	x29, x30, [sp, #-320]!
 113aa20:	910003fd 	mov	x29, sp
 113aa24:	a90153f3 	stp	x19, x20, [sp, #16]
 113aa28:	aa0003f3 	mov	x19, x0
 113aa2c:	aa0103f4 	mov	x20, x1
   unsigned long i;
   char tmp[256] = { 0 };
 113aa30:	910143e0 	add	x0, sp, #0x50
 113aa34:	52800001 	mov	w1, #0x0                   	// #0
{
 113aa38:	a9025bf5 	stp	x21, x22, [sp, #32]
 113aa3c:	aa0203f5 	mov	x21, x2
   char tmp[256] = { 0 };
 113aa40:	d2801e02 	mov	x2, #0xf0                  	// #240
 113aa44:	a9047fff 	stp	xzr, xzr, [sp, #64]
 113aa48:	940024a6 	bl	1143ce0 <memset>
   int err;

   if (o1 == NULL || o2 == NULL) return CRYPT_ERROR;
 113aa4c:	f100027f 	cmp	x19, #0x0
 113aa50:	fa401a84 	ccmp	x20, #0x0, #0x4, ne  // ne = any
 113aa54:	54000280 	b.eq	113aaa4 <pk_oid_cmp_with_ulong+0x88>  // b.none

   i = sizeof(tmp);
 113aa58:	d2802000 	mov	x0, #0x100                 	// #256
   if ((err = pk_oid_num_to_str(o2, o2size, tmp, &i)) != CRYPT_OK) {
 113aa5c:	910103f6 	add	x22, sp, #0x40
 113aa60:	9100e3e3 	add	x3, sp, #0x38
 113aa64:	aa1603e2 	mov	x2, x22
 113aa68:	aa1503e1 	mov	x1, x21
   i = sizeof(tmp);
 113aa6c:	f9001fe0 	str	x0, [sp, #56]
   if ((err = pk_oid_num_to_str(o2, o2size, tmp, &i)) != CRYPT_OK) {
 113aa70:	aa1403e0 	mov	x0, x20
 113aa74:	9400004d 	bl	113aba8 <pk_oid_num_to_str>
 113aa78:	350000e0 	cbnz	w0, 113aa94 <pk_oid_cmp_with_ulong+0x78>
      return err;
   }

   if (XSTRCMP(o1, tmp) != 0) {
 113aa7c:	aa1603e1 	mov	x1, x22
 113aa80:	aa1303e0 	mov	x0, x19
 113aa84:	9400249e 	bl	1143cfc <strcmp>
      return CRYPT_PK_INVALID_TYPE;
 113aa88:	7100001f 	cmp	w0, #0x0
 113aa8c:	52800241 	mov	w1, #0x12                  	// #18
 113aa90:	1a810000 	csel	w0, w0, w1, eq  // eq = none
   }

   return CRYPT_OK;
}
 113aa94:	a94153f3 	ldp	x19, x20, [sp, #16]
 113aa98:	a9425bf5 	ldp	x21, x22, [sp, #32]
 113aa9c:	a8d47bfd 	ldp	x29, x30, [sp], #320
 113aaa0:	d65f03c0 	ret
   if (o1 == NULL || o2 == NULL) return CRYPT_ERROR;
 113aaa4:	52800020 	mov	w0, #0x1                   	// #1
 113aaa8:	17fffffb 	b	113aa94 <pk_oid_cmp_with_ulong+0x78>

000000000113aaac <pk_oid_str_to_num>:

int pk_oid_str_to_num(const char *OID, unsigned long *oid, unsigned long *oidlen)
{
   unsigned long i, j, limit, OID_len, oid_j;

   LTC_ARGCHK(oidlen != NULL);
 113aaac:	b40007a2 	cbz	x2, 113aba0 <pk_oid_str_to_num+0xf4>
{
 113aab0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 113aab4:	910003fd 	mov	x29, sp
 113aab8:	a90153f3 	stp	x19, x20, [sp, #16]
 113aabc:	aa0103f4 	mov	x20, x1
 113aac0:	aa0203f3 	mov	x19, x2
 113aac4:	a9025bf5 	stp	x21, x22, [sp, #32]
 113aac8:	aa0003f5 	mov	x21, x0

   limit = *oidlen;
   *oidlen = 0; /* make sure that we return zero oidlen on error */
   for (i = 0; i < limit; i++) oid[i] = 0;
 113aacc:	d2800000 	mov	x0, #0x0                   	// #0
   limit = *oidlen;
 113aad0:	f9400056 	ldr	x22, [x2]
   *oidlen = 0; /* make sure that we return zero oidlen on error */
 113aad4:	f900005f 	str	xzr, [x2]
   for (i = 0; i < limit; i++) oid[i] = 0;
 113aad8:	eb16001f 	cmp	x0, x22
 113aadc:	540002a1 	b.ne	113ab30 <pk_oid_str_to_num+0x84>  // b.any

   if (OID == NULL) return CRYPT_OK;
 113aae0:	b40005d5 	cbz	x21, 113ab98 <pk_oid_str_to_num+0xec>

   OID_len = strlen(OID);
 113aae4:	aa1503e0 	mov	x0, x21
 113aae8:	9400248e 	bl	1143d20 <strlen>
   if (OID_len == 0) return CRYPT_OK;
 113aaec:	b4000560 	cbz	x0, 113ab98 <pk_oid_str_to_num+0xec>

   for (i = 0, j = 0; i < OID_len; i++) {
 113aaf0:	d2800003 	mov	x3, #0x0                   	// #0
 113aaf4:	d2800001 	mov	x1, #0x0                   	// #0
         if (++j >= limit) continue;
      }
      else if ((OID[i] >= '0') && (OID[i] <= '9')) {
         if ((j >= limit) || (oid == NULL)) continue;
         oid_j = oid[j];
         oid[j] = oid[j] * 10 + (OID[i] - '0');
 113aaf8:	d2800146 	mov	x6, #0xa                   	// #10
      if (OID[i] == '.') {
 113aafc:	38616aa4 	ldrb	w4, [x21, x1]
 113ab00:	7100b89f 	cmp	w4, #0x2e
 113ab04:	540001c1 	b.ne	113ab3c <pk_oid_str_to_num+0x90>  // b.any
         if (++j >= limit) continue;
 113ab08:	91000463 	add	x3, x3, #0x1
   for (i = 0, j = 0; i < OID_len; i++) {
 113ab0c:	91000421 	add	x1, x1, #0x1
 113ab10:	eb01001f 	cmp	x0, x1
 113ab14:	54ffff41 	b.ne	113aafc <pk_oid_str_to_num+0x50>  // b.any
      }
      else {
         return CRYPT_ERROR;
      }
   }
   if (j == 0) return CRYPT_ERROR;
 113ab18:	b40001a3 	cbz	x3, 113ab4c <pk_oid_str_to_num+0xa0>
   if (j >= limit) {
 113ab1c:	eb16007f 	cmp	x3, x22
 113ab20:	54000383 	b.cc	113ab90 <pk_oid_str_to_num+0xe4>  // b.lo, b.ul, b.last
      *oidlen = j;
      return CRYPT_BUFFER_OVERFLOW;
 113ab24:	528000c0 	mov	w0, #0x6                   	// #6
      *oidlen = j;
 113ab28:	f9000263 	str	x3, [x19]
      return CRYPT_BUFFER_OVERFLOW;
 113ab2c:	14000009 	b	113ab50 <pk_oid_str_to_num+0xa4>
   for (i = 0; i < limit; i++) oid[i] = 0;
 113ab30:	f8207a9f 	str	xzr, [x20, x0, lsl #3]
 113ab34:	91000400 	add	x0, x0, #0x1
 113ab38:	17ffffe8 	b	113aad8 <pk_oid_str_to_num+0x2c>
      else if ((OID[i] >= '0') && (OID[i] <= '9')) {
 113ab3c:	5100c084 	sub	w4, w4, #0x30
 113ab40:	12001c82 	and	w2, w4, #0xff
 113ab44:	7100245f 	cmp	w2, #0x9
 113ab48:	540000c9 	b.ls	113ab60 <pk_oid_str_to_num+0xb4>  // b.plast
         return CRYPT_ERROR;
 113ab4c:	52800020 	mov	w0, #0x1                   	// #1
   }
   *oidlen = j + 1;
   return CRYPT_OK;
}
 113ab50:	a94153f3 	ldp	x19, x20, [sp, #16]
 113ab54:	a9425bf5 	ldp	x21, x22, [sp, #32]
 113ab58:	a8c37bfd 	ldp	x29, x30, [sp], #48
 113ab5c:	d65f03c0 	ret
         if ((j >= limit) || (oid == NULL)) continue;
 113ab60:	f100029f 	cmp	x20, #0x0
 113ab64:	fa4312c0 	ccmp	x22, x3, #0x0, ne  // ne = any
 113ab68:	54fffd29 	b.ls	113ab0c <pk_oid_str_to_num+0x60>  // b.plast
         oid_j = oid[j];
 113ab6c:	d37df065 	lsl	x5, x3, #3
         oid[j] = oid[j] * 10 + (OID[i] - '0');
 113ab70:	93407c84 	sxtw	x4, w4
         oid_j = oid[j];
 113ab74:	f8656a82 	ldr	x2, [x20, x5]
         oid[j] = oid[j] * 10 + (OID[i] - '0');
 113ab78:	9b061044 	madd	x4, x2, x6, x4
 113ab7c:	f8256a84 	str	x4, [x20, x5]
         if (oid[j] < oid_j) return CRYPT_OVERFLOW;
 113ab80:	eb02009f 	cmp	x4, x2
 113ab84:	54fffc42 	b.cs	113ab0c <pk_oid_str_to_num+0x60>  // b.hs, b.nlast
 113ab88:	52800260 	mov	w0, #0x13                  	// #19
 113ab8c:	17fffff1 	b	113ab50 <pk_oid_str_to_num+0xa4>
   *oidlen = j + 1;
 113ab90:	91000463 	add	x3, x3, #0x1
 113ab94:	f9000263 	str	x3, [x19]
   if (OID == NULL) return CRYPT_OK;
 113ab98:	52800000 	mov	w0, #0x0                   	// #0
 113ab9c:	17ffffed 	b	113ab50 <pk_oid_str_to_num+0xa4>
   LTC_ARGCHK(oidlen != NULL);
 113aba0:	52800200 	mov	w0, #0x10                  	// #16
}
 113aba4:	d65f03c0 	ret

000000000113aba8 <pk_oid_num_to_str>:

int pk_oid_num_to_str(const unsigned long *oid, unsigned long oidlen, char *OID, unsigned long *outlen)
{
 113aba8:	a9ad7bfd 	stp	x29, x30, [sp, #-304]!
 113abac:	910003fd 	mov	x29, sp
 113abb0:	a90153f3 	stp	x19, x20, [sp, #16]
 113abb4:	aa0103f3 	mov	x19, x1
 113abb8:	aa0303f4 	mov	x20, x3
   int i;
   unsigned long j, k;
   char tmp[256] = { 0 };
 113abbc:	52800001 	mov	w1, #0x0                   	// #0
{
 113abc0:	a9025bf5 	stp	x21, x22, [sp, #32]
 113abc4:	aa0003f6 	mov	x22, x0
 113abc8:	aa0203f5 	mov	x21, x2
   char tmp[256] = { 0 };
 113abcc:	910103e0 	add	x0, sp, #0x40
 113abd0:	d2801e02 	mov	x2, #0xf0                  	// #240
 113abd4:	a9037fff 	stp	xzr, xzr, [sp, #48]
 113abd8:	94002442 	bl	1143ce0 <memset>

   LTC_ARGCHK(oid != NULL);
 113abdc:	b40007f6 	cbz	x22, 113acd8 <pk_oid_num_to_str+0x130>
   LTC_ARGCHK(OID != NULL);
 113abe0:	b40007d5 	cbz	x21, 113acd8 <pk_oid_num_to_str+0x130>
   LTC_ARGCHK(outlen != NULL);
 113abe4:	b40007b4 	cbz	x20, 113acd8 <pk_oid_num_to_str+0x130>

   for (i = oidlen - 1, k = 0; i >= 0; i--) {
 113abe8:	51000664 	sub	w4, w19, #0x1
 113abec:	9100c3e0 	add	x0, sp, #0x30
 113abf0:	d2800001 	mov	x1, #0x0                   	// #0
         tmp[k] = '0';
         if (++k >= sizeof(tmp)) return CRYPT_ERROR;
      }
      else {
         while (j > 0) {
            tmp[k] = '0' + (j % 10);
 113abf4:	d2800145 	mov	x5, #0xa                   	// #10
 113abf8:	93407c84 	sxtw	x4, w4
         tmp[k] = '0';
 113abfc:	52800608 	mov	w8, #0x30                  	// #48
            if (++k >= sizeof(tmp)) return CRYPT_ERROR;
            j /= 10;
         }
      }
      if (i > 0) {
        tmp[k] = '.';
 113ac00:	528005c9 	mov	w9, #0x2e                  	// #46
   for (i = oidlen - 1, k = 0; i >= 0; i--) {
 113ac04:	91000423 	add	x3, x1, #0x1
 113ac08:	2a0403e7 	mov	w7, w4
 113ac0c:	36f801c4 	tbz	w4, #31, 113ac44 <pk_oid_num_to_str+0x9c>
        if (++k >= sizeof(tmp)) return CRYPT_ERROR;
      }
   }
   if (*outlen < k + 1) {
 113ac10:	f9400280 	ldr	x0, [x20]
 113ac14:	eb03001f 	cmp	x0, x3
 113ac18:	54000523 	b.cc	113acbc <pk_oid_num_to_str+0x114>  // b.lo, b.ul, b.last
 113ac1c:	9100c3e2 	add	x2, sp, #0x30
      *outlen = k + 1;
      return CRYPT_BUFFER_OVERFLOW;
   }
   for (j = 0; j < k; j++) OID[j] = tmp[k - j - 1];
 113ac20:	d2800000 	mov	x0, #0x0                   	// #0
 113ac24:	8b010042 	add	x2, x2, x1
 113ac28:	d1000442 	sub	x2, x2, #0x1
 113ac2c:	eb01001f 	cmp	x0, x1
 113ac30:	540004c1 	b.ne	113acc8 <pk_oid_num_to_str+0x120>  // b.any
   OID[k] = '\0';
 113ac34:	38206abf 	strb	wzr, [x21, x0]
   *outlen = k; /* the length without terminating NUL byte */
 113ac38:	f9000280 	str	x0, [x20]
   return CRYPT_OK;
 113ac3c:	52800000 	mov	w0, #0x0                   	// #0
 113ac40:	14000007 	b	113ac5c <pk_oid_num_to_str+0xb4>
      j = oid[i];
 113ac44:	f8647ac2 	ldr	x2, [x22, x4, lsl #3]
      if (j == 0) {
 113ac48:	b5000142 	cbnz	x2, 113ac70 <pk_oid_num_to_str+0xc8>
         tmp[k] = '0';
 113ac4c:	38216808 	strb	w8, [x0, x1]
         if (++k >= sizeof(tmp)) return CRYPT_ERROR;
 113ac50:	f103fc7f 	cmp	x3, #0xff
 113ac54:	54000309 	b.ls	113acb4 <pk_oid_num_to_str+0x10c>  // b.plast
 113ac58:	52800020 	mov	w0, #0x1                   	// #1
}
 113ac5c:	a94153f3 	ldp	x19, x20, [sp, #16]
 113ac60:	a9425bf5 	ldp	x21, x22, [sp, #32]
 113ac64:	a8d37bfd 	ldp	x29, x30, [sp], #304
 113ac68:	d65f03c0 	ret
            j /= 10;
 113ac6c:	aa0603e2 	mov	x2, x6
            tmp[k] = '0' + (j % 10);
 113ac70:	9ac50846 	udiv	x6, x2, x5
 113ac74:	9b0588c3 	msub	x3, x6, x5, x2
 113ac78:	1100c063 	add	w3, w3, #0x30
 113ac7c:	38216803 	strb	w3, [x0, x1]
            if (++k >= sizeof(tmp)) return CRYPT_ERROR;
 113ac80:	91000421 	add	x1, x1, #0x1
 113ac84:	f103fc3f 	cmp	x1, #0xff
 113ac88:	54fffe88 	b.hi	113ac58 <pk_oid_num_to_str+0xb0>  // b.pmore
         while (j > 0) {
 113ac8c:	f100245f 	cmp	x2, #0x9
 113ac90:	54fffee8 	b.hi	113ac6c <pk_oid_num_to_str+0xc4>  // b.pmore
      if (i > 0) {
 113ac94:	340000c7 	cbz	w7, 113acac <pk_oid_num_to_str+0x104>
        tmp[k] = '.';
 113ac98:	38216809 	strb	w9, [x0, x1]
 113ac9c:	91000422 	add	x2, x1, #0x1
        if (++k >= sizeof(tmp)) return CRYPT_ERROR;
 113aca0:	f103fc3f 	cmp	x1, #0xff
 113aca4:	54fffda0 	b.eq	113ac58 <pk_oid_num_to_str+0xb0>  // b.none
 113aca8:	aa0203e1 	mov	x1, x2
   for (i = oidlen - 1, k = 0; i >= 0; i--) {
 113acac:	d1000484 	sub	x4, x4, #0x1
 113acb0:	17ffffd5 	b	113ac04 <pk_oid_num_to_str+0x5c>
 113acb4:	aa0303e1 	mov	x1, x3
 113acb8:	17fffff7 	b	113ac94 <pk_oid_num_to_str+0xec>
      return CRYPT_BUFFER_OVERFLOW;
 113acbc:	528000c0 	mov	w0, #0x6                   	// #6
      *outlen = k + 1;
 113acc0:	f9000283 	str	x3, [x20]
      return CRYPT_BUFFER_OVERFLOW;
 113acc4:	17ffffe6 	b	113ac5c <pk_oid_num_to_str+0xb4>
   for (j = 0; j < k; j++) OID[j] = tmp[k - j - 1];
 113acc8:	39400043 	ldrb	w3, [x2]
 113accc:	38206aa3 	strb	w3, [x21, x0]
 113acd0:	91000400 	add	x0, x0, #0x1
 113acd4:	17ffffd5 	b	113ac28 <pk_oid_num_to_str+0x80>
   LTC_ARGCHK(oid != NULL);
 113acd8:	52800200 	mov	w0, #0x10                  	// #16
 113acdc:	17ffffe0 	b	113ac5c <pk_oid_num_to_str+0xb4>

000000000113ace0 <pkcs_1_oaep_decode>:
int pkcs_1_oaep_decode(const unsigned char *msg,    unsigned long msglen,
                       const unsigned char *lparam, unsigned long lparamlen,
                             unsigned long modulus_bitlen, int hash_idx,
                             unsigned char *out,    unsigned long *outlen,
                             int           *res)
{
 113ace0:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
 113ace4:	910003fd 	mov	x29, sp
 113ace8:	a90153f3 	stp	x19, x20, [sp, #16]
 113acec:	a9025bf5 	stp	x21, x22, [sp, #32]
 113acf0:	a90363f7 	stp	x23, x24, [sp, #48]
 113acf4:	a9046bf9 	stp	x25, x26, [sp, #64]
 113acf8:	a90573fb 	stp	x27, x28, [sp, #80]
 113acfc:	a9061be2 	stp	x2, x6, [sp, #96]
 113ad00:	f9003fe3 	str	x3, [sp, #120]
   unsigned char *DB, *seed, *mask;
   unsigned long hLen, x, y, modulus_len;
   int           err, ret;

   LTC_ARGCHK(msg    != NULL);
 113ad04:	b4001680 	cbz	x0, 113afd4 <pkcs_1_oaep_decode+0x2f4>
 113ad08:	aa0003f9 	mov	x25, x0
   LTC_ARGCHK(out    != NULL);
 113ad0c:	b4001646 	cbz	x6, 113afd4 <pkcs_1_oaep_decode+0x2f4>
 113ad10:	aa0703f8 	mov	x24, x7
   LTC_ARGCHK(outlen != NULL);
 113ad14:	b4001607 	cbz	x7, 113afd4 <pkcs_1_oaep_decode+0x2f4>
   LTC_ARGCHK(res    != NULL);
 113ad18:	f9404be0 	ldr	x0, [sp, #144]
 113ad1c:	b40015c0 	cbz	x0, 113afd4 <pkcs_1_oaep_decode+0x2f4>

   /* default to invalid packet */
   *res = 0;
 113ad20:	b900001f 	str	wzr, [x0]
 113ad24:	aa0103f4 	mov	x20, x1
 113ad28:	aa0403f3 	mov	x19, x4
 113ad2c:	2a0503fb 	mov	w27, w5

   /* test valid hash */
   if ((err = hash_is_valid(hash_idx)) != CRYPT_OK) {
 113ad30:	2a0503e0 	mov	w0, w5
 113ad34:	97ffde50 	bl	1132674 <hash_is_valid>
 113ad38:	2a0003fc 	mov	w28, w0
 113ad3c:	35001380 	cbnz	w0, 113afac <pkcs_1_oaep_decode+0x2cc>
      return err;
   }
   hLen        = hash_descriptor[hash_idx]->hashsize;
 113ad40:	90000100 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
   modulus_len = (modulus_bitlen >> 3) + (modulus_bitlen & 7 ? 1 : 0);
 113ad44:	f2400a7f 	tst	x19, #0x7
 113ad48:	d343fe73 	lsr	x19, x19, #3
   hLen        = hash_descriptor[hash_idx]->hashsize;
 113ad4c:	f941a000 	ldr	x0, [x0, #832]
   modulus_len = (modulus_bitlen >> 3) + (modulus_bitlen & 7 ? 1 : 0);
 113ad50:	9a930673 	cinc	x19, x19, ne  // ne = any
   hLen        = hash_descriptor[hash_idx]->hashsize;
 113ad54:	f87bd800 	ldr	x0, [x0, w27, sxtw #3]
 113ad58:	f9400816 	ldr	x22, [x0, #16]

   /* test hash/message size */
   if ((2*hLen >= (modulus_len - 2)) || (msglen != modulus_len)) {
 113ad5c:	d1000a60 	sub	x0, x19, #0x2
 113ad60:	eb16041f 	cmp	x0, x22, lsl #1
 113ad64:	540013c9 	b.ls	113afdc <pkcs_1_oaep_decode+0x2fc>  // b.plast
 113ad68:	eb14027f 	cmp	x19, x20
 113ad6c:	54001381 	b.ne	113afdc <pkcs_1_oaep_decode+0x2fc>  // b.any
      return CRYPT_PK_INVALID_SIZE;
   }

   /* allocate ram for DB/mask/salt of size modulus_len */
   DB   = XMALLOC(modulus_len);
 113ad70:	aa1303e0 	mov	x0, x19
 113ad74:	940021b9 	bl	1143458 <malloc>
 113ad78:	aa0003fa 	mov	x26, x0
   mask = XMALLOC(modulus_len);
 113ad7c:	aa1303e0 	mov	x0, x19
 113ad80:	940021b6 	bl	1143458 <malloc>
 113ad84:	aa0003f5 	mov	x21, x0
   seed = XMALLOC(hLen);
 113ad88:	aa1603e0 	mov	x0, x22
 113ad8c:	940021b3 	bl	1143458 <malloc>
   if (DB == NULL || mask == NULL || seed == NULL) {
 113ad90:	f100035f 	cmp	x26, #0x0
   seed = XMALLOC(hLen);
 113ad94:	aa0003f4 	mov	x20, x0
   if (DB == NULL || mask == NULL || seed == NULL) {
 113ad98:	1a9f17e1 	cset	w1, eq  // eq = none
 113ad9c:	f10002bf 	cmp	x21, #0x0
 113ada0:	1a9f1421 	csinc	w1, w1, wzr, ne  // ne = any
 113ada4:	350000a1 	cbnz	w1, 113adb8 <pkcs_1_oaep_decode+0xd8>
 113ada8:	b50001a0 	cbnz	x0, 113addc <pkcs_1_oaep_decode+0xfc>
      if (DB != NULL) {
         XFREE(DB);
 113adac:	aa1a03e0 	mov	x0, x26
 113adb0:	9400220c 	bl	11435e0 <free>
 113adb4:	14000002 	b	113adbc <pkcs_1_oaep_decode+0xdc>
      if (DB != NULL) {
 113adb8:	b5ffffba 	cbnz	x26, 113adac <pkcs_1_oaep_decode+0xcc>
      }
      if (mask != NULL) {
 113adbc:	b4000075 	cbz	x21, 113adc8 <pkcs_1_oaep_decode+0xe8>
         XFREE(mask);
 113adc0:	aa1503e0 	mov	x0, x21
 113adc4:	94002207 	bl	11435e0 <free>
      }
      if (seed != NULL) {
 113adc8:	b4000074 	cbz	x20, 113add4 <pkcs_1_oaep_decode+0xf4>
         XFREE(seed);
 113adcc:	aa1403e0 	mov	x0, x20
 113add0:	94002204 	bl	11435e0 <free>
      }
      return CRYPT_MEM;
 113add4:	528001bc 	mov	w28, #0xd                   	// #13
 113add8:	14000075 	b	113afac <pkcs_1_oaep_decode+0x2cc>
    */

   ret = CRYPT_OK;

   /* must have leading 0x00 byte */
   if (msg[0] != 0x00) {
 113addc:	aa1903e1 	mov	x1, x25
      ret = CRYPT_INVALID_PACKET;
 113ade0:	528000e6 	mov	w6, #0x7                   	// #7
   if (msg[0] != 0x00) {
 113ade4:	38401422 	ldrb	w2, [x1], #1
      ret = CRYPT_INVALID_PACKET;
 113ade8:	7100005f 	cmp	w2, #0x0
   }

   /* now read the masked seed */
   x = 1;
   XMEMCPY(seed, msg + x, hLen);
 113adec:	aa1603e2 	mov	x2, x22
      ret = CRYPT_INVALID_PACKET;
 113adf0:	1a8603fc 	csel	w28, wzr, w6, eq  // eq = none
   XMEMCPY(seed, msg + x, hLen);
 113adf4:	97ff2167 	bl	1103390 <memcpy>
   x += hLen;

   /* now read the masked DB */
   XMEMCPY(DB, msg + x, modulus_len - hLen - 1);
 113adf8:	cb160260 	sub	x0, x19, x22
   x += hLen;
 113adfc:	910006c1 	add	x1, x22, #0x1
   XMEMCPY(DB, msg + x, modulus_len - hLen - 1);
 113ae00:	d1000417 	sub	x23, x0, #0x1
 113ae04:	8b010321 	add	x1, x25, x1
 113ae08:	aa1703e2 	mov	x2, x23
 113ae0c:	f9003be0 	str	x0, [sp, #112]
 113ae10:	aa1a03e0 	mov	x0, x26
 113ae14:	97ff215f 	bl	1103390 <memcpy>
   x += modulus_len - hLen - 1;

   /* compute MGF1 of maskedDB (hLen) */
   if ((err = pkcs_1_mgf1(hash_idx, DB, modulus_len - hLen - 1, mask, hLen)) != CRYPT_OK) {
 113ae18:	aa1603e4 	mov	x4, x22
 113ae1c:	aa1503e3 	mov	x3, x21
 113ae20:	aa1703e2 	mov	x2, x23
 113ae24:	aa1a03e1 	mov	x1, x26
 113ae28:	2a1b03e0 	mov	w0, w27
   x += modulus_len - hLen - 1;
 113ae2c:	f90047f3 	str	x19, [sp, #136]
   if ((err = pkcs_1_mgf1(hash_idx, DB, modulus_len - hLen - 1, mask, hLen)) != CRYPT_OK) {
 113ae30:	94001107 	bl	113f24c <pkcs_1_mgf1>
 113ae34:	2a0003f9 	mov	w25, w0
 113ae38:	350009a0 	cbnz	w0, 113af6c <pkcs_1_oaep_decode+0x28c>
      goto LBL_ERR;
   }

   /* XOR against seed */
   for (y = 0; y < hLen; y++) {
 113ae3c:	d2800000 	mov	x0, #0x0                   	// #0
 113ae40:	eb16001f 	cmp	x0, x22
 113ae44:	54000541 	b.ne	113aeec <pkcs_1_oaep_decode+0x20c>  // b.any
      seed[y] ^= mask[y];
   }

   /* compute MGF1 of seed (k - hlen - 1) */
   if ((err = pkcs_1_mgf1(hash_idx, seed, hLen, mask, modulus_len - hLen - 1)) != CRYPT_OK) {
 113ae48:	aa1703e4 	mov	x4, x23
 113ae4c:	aa1503e3 	mov	x3, x21
 113ae50:	aa1603e2 	mov	x2, x22
 113ae54:	aa1403e1 	mov	x1, x20
 113ae58:	2a1b03e0 	mov	w0, w27
 113ae5c:	940010fc 	bl	113f24c <pkcs_1_mgf1>
 113ae60:	2a0003f9 	mov	w25, w0
 113ae64:	35000840 	cbnz	w0, 113af6c <pkcs_1_oaep_decode+0x28c>
      goto LBL_ERR;
   }

   /* xor against DB */
   for (y = 0; y < (modulus_len - hLen - 1); y++) {
 113ae68:	d2800000 	mov	x0, #0x0                   	// #0
 113ae6c:	eb0002ff 	cmp	x23, x0
 113ae70:	540004a8 	b.hi	113af04 <pkcs_1_oaep_decode+0x224>  // b.pmore

   /* now DB == lhash || PS || 0x01 || M, PS == k - mlen - 2hlen - 2 zeroes */

   /* compute lhash and store it in seed [reuse temps!] */
   x = modulus_len;
   if (lparam != NULL) {
 113ae74:	f94033e0 	ldr	x0, [sp, #96]
   x = modulus_len;
 113ae78:	f90047f3 	str	x19, [sp, #136]
   if (lparam != NULL) {
 113ae7c:	910223e4 	add	x4, sp, #0x88
      if ((err = hash_memory(hash_idx, lparam, lparamlen, seed, &x)) != CRYPT_OK) {
 113ae80:	aa1403e3 	mov	x3, x20
   if (lparam != NULL) {
 113ae84:	b40004c0 	cbz	x0, 113af1c <pkcs_1_oaep_decode+0x23c>
      if ((err = hash_memory(hash_idx, lparam, lparamlen, seed, &x)) != CRYPT_OK) {
 113ae88:	f9403fe2 	ldr	x2, [sp, #120]
 113ae8c:	aa0003e1 	mov	x1, x0
 113ae90:	2a1b03e0 	mov	w0, w27
 113ae94:	97fff686 	bl	11388ac <hash_memory>
 113ae98:	2a0003f9 	mov	w25, w0
 113ae9c:	35000680 	cbnz	w0, 113af6c <pkcs_1_oaep_decode+0x28c>
         goto LBL_ERR;
      }
   }

   /* compare the lhash'es */
   if (XMEM_NEQ(seed, DB, hLen) != 0) {
 113aea0:	aa1a03e1 	mov	x1, x26
 113aea4:	aa1603e2 	mov	x2, x22
 113aea8:	aa1403e0 	mov	x0, x20
 113aeac:	94002839 	bl	1144f90 <consttime_memcmp>
 113aeb0:	7100001f 	cmp	w0, #0x0
 113aeb4:	528000f9 	mov	w25, #0x7                   	// #7
      ret = CRYPT_INVALID_PACKET;
   }

   /* now zeroes before a 0x01 */
   for (x = hLen; x < (modulus_len - hLen - 1) && DB[x] == 0x00; x++) {
 113aeb8:	aa1603e1 	mov	x1, x22
 113aebc:	1a990399 	csel	w25, w28, w25, eq  // eq = none
 113aec0:	d1000743 	sub	x3, x26, #0x1
 113aec4:	aa0103e0 	mov	x0, x1
 113aec8:	91000421 	add	x1, x1, #0x1
 113aecc:	eb0002ff 	cmp	x23, x0
 113aed0:	540002c9 	b.ls	113af28 <pkcs_1_oaep_decode+0x248>  // b.plast
 113aed4:	38616862 	ldrb	w2, [x3, x1]
 113aed8:	34ffff62 	cbz	w2, 113aec4 <pkcs_1_oaep_decode+0x1e4>
      /* step... */
   }

   /* error if wasn't 0x01 */
   if (x == (modulus_len - hLen - 1) || DB[x] != 0x01) {
 113aedc:	38606b40 	ldrb	w0, [x26, x0]
 113aee0:	7100041f 	cmp	w0, #0x1
 113aee4:	54000241 	b.ne	113af2c <pkcs_1_oaep_decode+0x24c>  // b.any
 113aee8:	14000012 	b	113af30 <pkcs_1_oaep_decode+0x250>
      seed[y] ^= mask[y];
 113aeec:	38606a81 	ldrb	w1, [x20, x0]
 113aef0:	38606aa2 	ldrb	w2, [x21, x0]
 113aef4:	4a020021 	eor	w1, w1, w2
 113aef8:	38206a81 	strb	w1, [x20, x0]
   for (y = 0; y < hLen; y++) {
 113aefc:	91000400 	add	x0, x0, #0x1
 113af00:	17ffffd0 	b	113ae40 <pkcs_1_oaep_decode+0x160>
       DB[y] ^= mask[y];
 113af04:	38606b41 	ldrb	w1, [x26, x0]
 113af08:	38606aa2 	ldrb	w2, [x21, x0]
 113af0c:	4a020021 	eor	w1, w1, w2
 113af10:	38206b41 	strb	w1, [x26, x0]
   for (y = 0; y < (modulus_len - hLen - 1); y++) {
 113af14:	91000400 	add	x0, x0, #0x1
 113af18:	17ffffd5 	b	113ae6c <pkcs_1_oaep_decode+0x18c>
      if ((err = hash_memory(hash_idx, DB, 0, seed, &x)) != CRYPT_OK) {
 113af1c:	aa1a03e1 	mov	x1, x26
 113af20:	d2800002 	mov	x2, #0x0                   	// #0
 113af24:	17ffffdb 	b	113ae90 <pkcs_1_oaep_decode+0x1b0>
   if (x == (modulus_len - hLen - 1) || DB[x] != 0x01) {
 113af28:	54fffda1 	b.ne	113aedc <pkcs_1_oaep_decode+0x1fc>  // b.any
      ret = CRYPT_INVALID_PACKET;
 113af2c:	528000f9 	mov	w25, #0x7                   	// #7
   }

   /* rest is the message (and skip 0x01) */
   if ((modulus_len - hLen - 1 - ++x) > *outlen) {
 113af30:	f9403be0 	ldr	x0, [sp, #112]
 113af34:	aa2103e2 	mvn	x2, x1
 113af38:	f90047e1 	str	x1, [sp, #136]
 113af3c:	8b000042 	add	x2, x2, x0
 113af40:	f9400300 	ldr	x0, [x24]
 113af44:	eb00005f 	cmp	x2, x0
 113af48:	54000428 	b.hi	113afcc <pkcs_1_oaep_decode+0x2ec>  // b.pmore
      ret = CRYPT_INVALID_PACKET;
   }

   if (ret == CRYPT_OK) {
 113af4c:	35000119 	cbnz	w25, 113af6c <pkcs_1_oaep_decode+0x28c>
      /* copy message */
      *outlen = modulus_len - hLen - 1 - x;
      XMEMCPY(out, DB + x, modulus_len - hLen - 1 - x);
 113af50:	f94037e0 	ldr	x0, [sp, #104]
      *outlen = modulus_len - hLen - 1 - x;
 113af54:	f9000302 	str	x2, [x24]
      XMEMCPY(out, DB + x, modulus_len - hLen - 1 - x);
 113af58:	8b010341 	add	x1, x26, x1
 113af5c:	97ff210d 	bl	1103390 <memcpy>

      /* valid packet */
      *res = 1;
 113af60:	f9404be1 	ldr	x1, [sp, #144]
 113af64:	52800020 	mov	w0, #0x1                   	// #1
 113af68:	b9000020 	str	w0, [x1]
   }
   err = ret;

LBL_ERR:
#ifdef LTC_CLEAN_STACK
   zeromem(DB,   modulus_len);
 113af6c:	aa1303e1 	mov	x1, x19
 113af70:	aa1a03e0 	mov	x0, x26
 113af74:	97ffdd34 	bl	1132444 <zeromem>

   XFREE(seed);
   XFREE(mask);
   XFREE(DB);

   return err;
 113af78:	2a1903fc 	mov	w28, w25
   zeromem(seed, hLen);
 113af7c:	aa1603e1 	mov	x1, x22
 113af80:	aa1403e0 	mov	x0, x20
 113af84:	97ffdd30 	bl	1132444 <zeromem>
   zeromem(mask, modulus_len);
 113af88:	aa1303e1 	mov	x1, x19
 113af8c:	aa1503e0 	mov	x0, x21
 113af90:	97ffdd2d 	bl	1132444 <zeromem>
   XFREE(seed);
 113af94:	aa1403e0 	mov	x0, x20
 113af98:	94002192 	bl	11435e0 <free>
   XFREE(mask);
 113af9c:	aa1503e0 	mov	x0, x21
 113afa0:	94002190 	bl	11435e0 <free>
   XFREE(DB);
 113afa4:	aa1a03e0 	mov	x0, x26
 113afa8:	9400218e 	bl	11435e0 <free>
}
 113afac:	2a1c03e0 	mov	w0, w28
 113afb0:	a94153f3 	ldp	x19, x20, [sp, #16]
 113afb4:	a9425bf5 	ldp	x21, x22, [sp, #32]
 113afb8:	a94363f7 	ldp	x23, x24, [sp, #48]
 113afbc:	a9446bf9 	ldp	x25, x26, [sp, #64]
 113afc0:	a94573fb 	ldp	x27, x28, [sp, #80]
 113afc4:	a8c97bfd 	ldp	x29, x30, [sp], #144
 113afc8:	d65f03c0 	ret
      ret = CRYPT_INVALID_PACKET;
 113afcc:	528000f9 	mov	w25, #0x7                   	// #7
 113afd0:	17ffffe7 	b	113af6c <pkcs_1_oaep_decode+0x28c>
   LTC_ARGCHK(msg    != NULL);
 113afd4:	5280021c 	mov	w28, #0x10                  	// #16
 113afd8:	17fffff5 	b	113afac <pkcs_1_oaep_decode+0x2cc>
      return CRYPT_PK_INVALID_SIZE;
 113afdc:	528002dc 	mov	w28, #0x16                  	// #22
 113afe0:	17fffff3 	b	113afac <pkcs_1_oaep_decode+0x2cc>

000000000113afe4 <pkcs_1_oaep_encode>:
int pkcs_1_oaep_encode(const unsigned char *msg,    unsigned long msglen,
                       const unsigned char *lparam, unsigned long lparamlen,
                             unsigned long modulus_bitlen, prng_state *prng,
                             int           prng_idx,         int  hash_idx,
                             unsigned char *out,    unsigned long *outlen)
{
 113afe4:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
 113afe8:	910003fd 	mov	x29, sp
 113afec:	a90153f3 	stp	x19, x20, [sp, #16]
 113aff0:	a9025bf5 	stp	x21, x22, [sp, #32]
 113aff4:	a90363f7 	stp	x23, x24, [sp, #48]
 113aff8:	a9046bf9 	stp	x25, x26, [sp, #64]
 113affc:	a90573fb 	stp	x27, x28, [sp, #80]
 113b000:	b90067e6 	str	w6, [sp, #100]
 113b004:	a90697e3 	stp	x3, x5, [sp, #104]
   unsigned char *DB, *seed, *mask;
   unsigned long hLen, x, y, modulus_len;
   int           err;

   LTC_ARGCHK(msg    != NULL);
 113b008:	b4001700 	cbz	x0, 113b2e8 <pkcs_1_oaep_encode+0x304>
 113b00c:	aa0003fa 	mov	x26, x0
   LTC_ARGCHK(out    != NULL);
 113b010:	f9404be0 	ldr	x0, [sp, #144]
 113b014:	b40016a0 	cbz	x0, 113b2e8 <pkcs_1_oaep_encode+0x304>
   LTC_ARGCHK(outlen != NULL);
 113b018:	f9404fe0 	ldr	x0, [sp, #152]
 113b01c:	b4001660 	cbz	x0, 113b2e8 <pkcs_1_oaep_encode+0x304>
 113b020:	aa0103f8 	mov	x24, x1
 113b024:	aa0203fc 	mov	x28, x2
 113b028:	aa0403f3 	mov	x19, x4
 113b02c:	2a0703f7 	mov	w23, w7

   /* test valid hash */
   if ((err = hash_is_valid(hash_idx)) != CRYPT_OK) {
 113b030:	2a0703e0 	mov	w0, w7
 113b034:	97ffdd90 	bl	1132674 <hash_is_valid>
 113b038:	2a0003fb 	mov	w27, w0
 113b03c:	35001060 	cbnz	w0, 113b248 <pkcs_1_oaep_encode+0x264>
      return err;
   }

   /* valid prng */
   if ((err = prng_is_valid(prng_idx)) != CRYPT_OK) {
 113b040:	b94067e0 	ldr	w0, [sp, #100]
 113b044:	97ffdda6 	bl	11326dc <prng_is_valid>
 113b048:	2a0003fb 	mov	w27, w0
 113b04c:	35000fe0 	cbnz	w0, 113b248 <pkcs_1_oaep_encode+0x264>
      return err;
   }

   hLen        = hash_descriptor[hash_idx]->hashsize;
 113b050:	f00000e0 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
   modulus_len = (modulus_bitlen >> 3) + (modulus_bitlen & 7 ? 1 : 0);
 113b054:	f2400a7f 	tst	x19, #0x7
 113b058:	d343fe73 	lsr	x19, x19, #3
   hLen        = hash_descriptor[hash_idx]->hashsize;
 113b05c:	f941a000 	ldr	x0, [x0, #832]
   modulus_len = (modulus_bitlen >> 3) + (modulus_bitlen & 7 ? 1 : 0);
 113b060:	9a930673 	cinc	x19, x19, ne  // ne = any
   hLen        = hash_descriptor[hash_idx]->hashsize;
 113b064:	f877d800 	ldr	x0, [x0, w23, sxtw #3]
 113b068:	f9400814 	ldr	x20, [x0, #16]

   /* test message size */
   if ((2*hLen >= (modulus_len - 2)) || (msglen > (modulus_len - 2*hLen - 2))) {
 113b06c:	d37ffa80 	lsl	x0, x20, #1
 113b070:	f9003fe0 	str	x0, [sp, #120]
 113b074:	d1000a60 	sub	x0, x19, #0x2
 113b078:	eb14041f 	cmp	x0, x20, lsl #1
 113b07c:	540013a9 	b.ls	113b2f0 <pkcs_1_oaep_encode+0x30c>  // b.plast
 113b080:	d37ffa81 	lsl	x1, x20, #1
 113b084:	cb010000 	sub	x0, x0, x1
 113b088:	eb18001f 	cmp	x0, x24
 113b08c:	54001323 	b.cc	113b2f0 <pkcs_1_oaep_encode+0x30c>  // b.lo, b.ul, b.last
      return CRYPT_PK_INVALID_SIZE;
   }

   /* allocate ram for DB/mask/salt of size modulus_len */
   DB   = XMALLOC(modulus_len);
 113b090:	aa1303e0 	mov	x0, x19
 113b094:	940020f1 	bl	1143458 <malloc>
 113b098:	aa0003f9 	mov	x25, x0
   mask = XMALLOC(modulus_len);
 113b09c:	aa1303e0 	mov	x0, x19
 113b0a0:	940020ee 	bl	1143458 <malloc>
 113b0a4:	aa0003f6 	mov	x22, x0
   seed = XMALLOC(hLen);
 113b0a8:	aa1403e0 	mov	x0, x20
 113b0ac:	940020eb 	bl	1143458 <malloc>
   if (DB == NULL || mask == NULL || seed == NULL) {
 113b0b0:	f100033f 	cmp	x25, #0x0
   seed = XMALLOC(hLen);
 113b0b4:	aa0003f5 	mov	x21, x0
   if (DB == NULL || mask == NULL || seed == NULL) {
 113b0b8:	fa401ac4 	ccmp	x22, #0x0, #0x4, ne  // ne = any
 113b0bc:	540000a0 	b.eq	113b0d0 <pkcs_1_oaep_encode+0xec>  // b.none
 113b0c0:	b50001a0 	cbnz	x0, 113b0f4 <pkcs_1_oaep_encode+0x110>
      if (DB != NULL) {
         XFREE(DB);
 113b0c4:	aa1903e0 	mov	x0, x25
 113b0c8:	94002146 	bl	11435e0 <free>
 113b0cc:	14000002 	b	113b0d4 <pkcs_1_oaep_encode+0xf0>
      if (DB != NULL) {
 113b0d0:	b5ffffb9 	cbnz	x25, 113b0c4 <pkcs_1_oaep_encode+0xe0>
      }
      if (mask != NULL) {
 113b0d4:	b4000076 	cbz	x22, 113b0e0 <pkcs_1_oaep_encode+0xfc>
         XFREE(mask);
 113b0d8:	aa1603e0 	mov	x0, x22
 113b0dc:	94002141 	bl	11435e0 <free>
      }
      if (seed != NULL) {
 113b0e0:	b4000075 	cbz	x21, 113b0ec <pkcs_1_oaep_encode+0x108>
         XFREE(seed);
 113b0e4:	aa1503e0 	mov	x0, x21
 113b0e8:	9400213e 	bl	11435e0 <free>
      }
      return CRYPT_MEM;
 113b0ec:	528001bb 	mov	w27, #0xd                   	// #13
 113b0f0:	14000056 	b	113b248 <pkcs_1_oaep_encode+0x264>
   }

   /* get lhash */
   /* DB == lhash || PS || 0x01 || M, PS == k - mlen - 2hlen - 2 zeroes */
   x = modulus_len;
 113b0f4:	f90047f3 	str	x19, [sp, #136]
   if (lparam != NULL) {
 113b0f8:	910223e4 	add	x4, sp, #0x88
      if ((err = hash_memory(hash_idx, lparam, lparamlen, DB, &x)) != CRYPT_OK) {
 113b0fc:	aa1903e3 	mov	x3, x25
   if (lparam != NULL) {
 113b100:	b4000b5c 	cbz	x28, 113b268 <pkcs_1_oaep_encode+0x284>
      if ((err = hash_memory(hash_idx, lparam, lparamlen, DB, &x)) != CRYPT_OK) {
 113b104:	f94037e2 	ldr	x2, [sp, #104]
 113b108:	aa1c03e1 	mov	x1, x28
 113b10c:	2a1703e0 	mov	w0, w23
 113b110:	97fff5e7 	bl	11388ac <hash_memory>
 113b114:	2a0003fb 	mov	w27, w0
 113b118:	350007a0 	cbnz	w0, 113b20c <pkcs_1_oaep_encode+0x228>
      }
   }

   /* append PS then 0x01 (to lhash)  */
   x = hLen;
   y = modulus_len - msglen - 2*hLen - 2;
 113b11c:	d37ffa80 	lsl	x0, x20, #1
   XMEMSET(DB+x, 0, y);
 113b120:	52800001 	mov	w1, #0x0                   	// #0
   y = modulus_len - msglen - 2*hLen - 2;
 113b124:	cb00027c 	sub	x28, x19, x0
   XMEMSET(DB+x, 0, y);
 113b128:	8b140320 	add	x0, x25, x20
   y = modulus_len - msglen - 2*hLen - 2;
 113b12c:	cb18039c 	sub	x28, x28, x24
 113b130:	d1000b9c 	sub	x28, x28, #0x2
   XMEMSET(DB+x, 0, y);
 113b134:	aa1c03e2 	mov	x2, x28
   x += y;
 113b138:	8b1c029c 	add	x28, x20, x28
   XMEMSET(DB+x, 0, y);
 113b13c:	940022e9 	bl	1143ce0 <memset>

   /* 0x01 byte */
   DB[x++] = 0x01;
 113b140:	9100079b 	add	x27, x28, #0x1
 113b144:	52800020 	mov	w0, #0x1                   	// #1

   /* message (length = msglen) */
   XMEMCPY(DB+x, msg, msglen);
 113b148:	aa1803e2 	mov	x2, x24
 113b14c:	aa1a03e1 	mov	x1, x26
   DB[x++] = 0x01;
 113b150:	383c6b20 	strb	w0, [x25, x28]
   XMEMCPY(DB+x, msg, msglen);
 113b154:	8b1b0320 	add	x0, x25, x27
 113b158:	97ff208e 	bl	1103390 <memcpy>
   x += msglen;

   /* now choose a random seed */
   if (prng_descriptor[prng_idx]->read(seed, hLen, prng) != hLen) {
 113b15c:	f00000e0 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 113b160:	b94067e1 	ldr	w1, [sp, #100]
 113b164:	f9403be2 	ldr	x2, [sp, #112]
   x += msglen;
 113b168:	8b180378 	add	x24, x27, x24
   if (prng_descriptor[prng_idx]->read(seed, hLen, prng) != hLen) {
 113b16c:	f9422c00 	ldr	x0, [x0, #1112]
   x += msglen;
 113b170:	f90047f8 	str	x24, [sp, #136]
   if (prng_descriptor[prng_idx]->read(seed, hLen, prng) != hLen) {
 113b174:	f861d800 	ldr	x0, [x0, w1, sxtw #3]
 113b178:	aa1403e1 	mov	x1, x20
 113b17c:	f9401403 	ldr	x3, [x0, #40]
 113b180:	aa1503e0 	mov	x0, x21
 113b184:	d63f0060 	blr	x3
 113b188:	eb14001f 	cmp	x0, x20
 113b18c:	54000aa1 	b.ne	113b2e0 <pkcs_1_oaep_encode+0x2fc>  // b.any
      err = CRYPT_ERROR_READPRNG;
      goto LBL_ERR;
   }

   /* compute MGF1 of seed (k - hlen - 1) */
   if ((err = pkcs_1_mgf1(hash_idx, seed, hLen, mask, modulus_len - hLen - 1)) != CRYPT_OK) {
 113b190:	d100067a 	sub	x26, x19, #0x1
 113b194:	aa1603e3 	mov	x3, x22
 113b198:	cb14035a 	sub	x26, x26, x20
 113b19c:	aa1403e2 	mov	x2, x20
 113b1a0:	aa1a03e4 	mov	x4, x26
 113b1a4:	aa1503e1 	mov	x1, x21
 113b1a8:	2a1703e0 	mov	w0, w23
 113b1ac:	94001028 	bl	113f24c <pkcs_1_mgf1>
 113b1b0:	2a0003fb 	mov	w27, w0
 113b1b4:	350002c0 	cbnz	w0, 113b20c <pkcs_1_oaep_encode+0x228>
      goto LBL_ERR;
   }

   /* xor against DB */
   for (y = 0; y < (modulus_len - hLen - 1); y++) {
 113b1b8:	d2800018 	mov	x24, #0x0                   	// #0
 113b1bc:	eb18035f 	cmp	x26, x24
 113b1c0:	540005a1 	b.ne	113b274 <pkcs_1_oaep_encode+0x290>  // b.any
       DB[y] ^= mask[y];
   }

   /* compute MGF1 of maskedDB (hLen) */
   if ((err = pkcs_1_mgf1(hash_idx, DB, modulus_len - hLen - 1, mask, hLen)) != CRYPT_OK) {
 113b1c4:	aa1403e4 	mov	x4, x20
 113b1c8:	aa1603e3 	mov	x3, x22
 113b1cc:	aa1803e2 	mov	x2, x24
 113b1d0:	aa1903e1 	mov	x1, x25
 113b1d4:	2a1703e0 	mov	w0, w23
 113b1d8:	9400101d 	bl	113f24c <pkcs_1_mgf1>
 113b1dc:	2a0003fb 	mov	w27, w0
 113b1e0:	35000160 	cbnz	w0, 113b20c <pkcs_1_oaep_encode+0x228>
      goto LBL_ERR;
   }

   /* XOR against seed */
   for (y = 0; y < hLen; y++) {
 113b1e4:	d2800000 	mov	x0, #0x0                   	// #0
 113b1e8:	eb14001f 	cmp	x0, x20
 113b1ec:	54000501 	b.ne	113b28c <pkcs_1_oaep_encode+0x2a8>  // b.any
      seed[y] ^= mask[y];
   }

   /* create string of length modulus_len */
   if (*outlen < modulus_len) {
 113b1f0:	f9404fe0 	ldr	x0, [sp, #152]
 113b1f4:	f9400000 	ldr	x0, [x0]
 113b1f8:	eb13001f 	cmp	x0, x19
 113b1fc:	54000542 	b.cs	113b2a4 <pkcs_1_oaep_encode+0x2c0>  // b.hs, b.nlast
      *outlen = modulus_len;
 113b200:	f9404fe0 	ldr	x0, [sp, #152]
      err = CRYPT_BUFFER_OVERFLOW;
 113b204:	528000db 	mov	w27, #0x6                   	// #6
      *outlen = modulus_len;
 113b208:	f9000013 	str	x19, [x0]
   *outlen = x;

   err = CRYPT_OK;
LBL_ERR:
#ifdef LTC_CLEAN_STACK
   zeromem(DB,   modulus_len);
 113b20c:	aa1303e1 	mov	x1, x19
 113b210:	aa1903e0 	mov	x0, x25
 113b214:	97ffdc8c 	bl	1132444 <zeromem>
   zeromem(seed, hLen);
 113b218:	aa1403e1 	mov	x1, x20
 113b21c:	aa1503e0 	mov	x0, x21
 113b220:	97ffdc89 	bl	1132444 <zeromem>
   zeromem(mask, modulus_len);
 113b224:	aa1303e1 	mov	x1, x19
 113b228:	aa1603e0 	mov	x0, x22
 113b22c:	97ffdc86 	bl	1132444 <zeromem>
#endif

   XFREE(seed);
 113b230:	aa1503e0 	mov	x0, x21
 113b234:	940020eb 	bl	11435e0 <free>
   XFREE(mask);
 113b238:	aa1603e0 	mov	x0, x22
 113b23c:	940020e9 	bl	11435e0 <free>
   XFREE(DB);
 113b240:	aa1903e0 	mov	x0, x25
 113b244:	940020e7 	bl	11435e0 <free>

   return err;
}
 113b248:	2a1b03e0 	mov	w0, w27
 113b24c:	a94153f3 	ldp	x19, x20, [sp, #16]
 113b250:	a9425bf5 	ldp	x21, x22, [sp, #32]
 113b254:	a94363f7 	ldp	x23, x24, [sp, #48]
 113b258:	a9446bf9 	ldp	x25, x26, [sp, #64]
 113b25c:	a94573fb 	ldp	x27, x28, [sp, #80]
 113b260:	a8c97bfd 	ldp	x29, x30, [sp], #144
 113b264:	d65f03c0 	ret
      if ((err = hash_memory(hash_idx, DB, 0, DB, &x)) != CRYPT_OK) {
 113b268:	aa1903e1 	mov	x1, x25
 113b26c:	d2800002 	mov	x2, #0x0                   	// #0
 113b270:	17ffffa7 	b	113b10c <pkcs_1_oaep_encode+0x128>
       DB[y] ^= mask[y];
 113b274:	38786b20 	ldrb	w0, [x25, x24]
 113b278:	38786ac1 	ldrb	w1, [x22, x24]
 113b27c:	4a010000 	eor	w0, w0, w1
 113b280:	38386b20 	strb	w0, [x25, x24]
   for (y = 0; y < (modulus_len - hLen - 1); y++) {
 113b284:	91000718 	add	x24, x24, #0x1
 113b288:	17ffffcd 	b	113b1bc <pkcs_1_oaep_encode+0x1d8>
      seed[y] ^= mask[y];
 113b28c:	38606aa1 	ldrb	w1, [x21, x0]
 113b290:	38606ac2 	ldrb	w2, [x22, x0]
 113b294:	4a020021 	eor	w1, w1, w2
 113b298:	38206aa1 	strb	w1, [x21, x0]
   for (y = 0; y < hLen; y++) {
 113b29c:	91000400 	add	x0, x0, #0x1
 113b2a0:	17ffffd2 	b	113b1e8 <pkcs_1_oaep_encode+0x204>
   out[x++] = 0x00;
 113b2a4:	f9404be0 	ldr	x0, [sp, #144]
   XMEMCPY(out+x, seed, hLen);
 113b2a8:	aa1403e2 	mov	x2, x20
 113b2ac:	aa1503e1 	mov	x1, x21
   out[x++] = 0x00;
 113b2b0:	3800141f 	strb	wzr, [x0], #1
   XMEMCPY(out+x, seed, hLen);
 113b2b4:	97ff2037 	bl	1103390 <memcpy>
   XMEMCPY(out+x, DB, modulus_len - hLen - 1);
 113b2b8:	f9404be3 	ldr	x3, [sp, #144]
   x += hLen;
 113b2bc:	91000680 	add	x0, x20, #0x1
   XMEMCPY(out+x, DB, modulus_len - hLen - 1);
 113b2c0:	aa1803e2 	mov	x2, x24
 113b2c4:	aa1903e1 	mov	x1, x25
 113b2c8:	8b000060 	add	x0, x3, x0
 113b2cc:	97ff2031 	bl	1103390 <memcpy>
   x += modulus_len - hLen - 1;
 113b2d0:	f90047f3 	str	x19, [sp, #136]
   *outlen = x;
 113b2d4:	f9404fe0 	ldr	x0, [sp, #152]
 113b2d8:	f9000013 	str	x19, [x0]
 113b2dc:	17ffffcc 	b	113b20c <pkcs_1_oaep_encode+0x228>
      err = CRYPT_ERROR_READPRNG;
 113b2e0:	5280013b 	mov	w27, #0x9                   	// #9
 113b2e4:	17ffffca 	b	113b20c <pkcs_1_oaep_encode+0x228>
   LTC_ARGCHK(msg    != NULL);
 113b2e8:	5280021b 	mov	w27, #0x10                  	// #16
 113b2ec:	17ffffd7 	b	113b248 <pkcs_1_oaep_encode+0x264>
      return CRYPT_PK_INVALID_SIZE;
 113b2f0:	528002db 	mov	w27, #0x16                  	// #22
 113b2f4:	17ffffd5 	b	113b248 <pkcs_1_oaep_encode+0x264>

000000000113b2f8 <pkcs_1_pss_decode>:
*/
int pkcs_1_pss_decode(const unsigned char *msghash, unsigned long msghashlen,
                      const unsigned char *sig,     unsigned long siglen,
                            unsigned long saltlen,  int           hash_idx,
                            unsigned long modulus_bitlen, int    *res)
{
 113b2f8:	a9aa7bfd 	stp	x29, x30, [sp, #-352]!
 113b2fc:	910003fd 	mov	x29, sp
 113b300:	a90153f3 	stp	x19, x20, [sp, #16]
 113b304:	a9025bf5 	stp	x21, x22, [sp, #32]
 113b308:	a90363f7 	stp	x23, x24, [sp, #48]
 113b30c:	a9046bf9 	stp	x25, x26, [sp, #64]
 113b310:	a90573fb 	stp	x27, x28, [sp, #80]
 113b314:	f90037e4 	str	x4, [sp, #104]
 113b318:	a90783e7 	stp	x7, x0, [sp, #120]
 113b31c:	f90047e1 	str	x1, [sp, #136]
   unsigned char *DB, *mask, *salt, *hash;
   unsigned long x, y, hLen, modulus_len;
   int           err;
   hash_state    md;

   LTC_ARGCHK(msghash != NULL);
 113b320:	b4001a20 	cbz	x0, 113b664 <pkcs_1_pss_decode+0x36c>
   LTC_ARGCHK(res     != NULL);
 113b324:	b4001a07 	cbz	x7, 113b664 <pkcs_1_pss_decode+0x36c>

   /* default to invalid */
   *res = 0;
 113b328:	b90000ff 	str	wzr, [x7]
 113b32c:	aa0303fa 	mov	x26, x3
 113b330:	aa0203fb 	mov	x27, x2
 113b334:	2a0503fc 	mov	w28, w5
 113b338:	aa0603f3 	mov	x19, x6

   /* ensure hash is valid */
   if ((err = hash_is_valid(hash_idx)) != CRYPT_OK) {
 113b33c:	2a0503e0 	mov	w0, w5
 113b340:	97ffdccd 	bl	1132674 <hash_is_valid>
 113b344:	2a0003e3 	mov	w3, w0
 113b348:	35000a00 	cbnz	w0, 113b488 <pkcs_1_pss_decode+0x190>
      return err;
   }

   hLen        = hash_descriptor[hash_idx]->hashsize;
   modulus_bitlen--;
 113b34c:	d1000666 	sub	x6, x19, #0x1
   modulus_len = (modulus_bitlen>>3) + (modulus_bitlen & 7 ? 1 : 0);
 113b350:	f9003be6 	str	x6, [sp, #112]

   /* check sizes */
   if ((saltlen > modulus_len) ||
 113b354:	f94037e0 	ldr	x0, [sp, #104]
   modulus_len = (modulus_bitlen>>3) + (modulus_bitlen & 7 ? 1 : 0);
 113b358:	f24008df 	tst	x6, #0x7
 113b35c:	d343fcd3 	lsr	x19, x6, #3
 113b360:	9a930673 	cinc	x19, x19, ne  // ne = any
   if ((saltlen > modulus_len) ||
 113b364:	eb00027f 	cmp	x19, x0
 113b368:	54001823 	b.cc	113b66c <pkcs_1_pss_decode+0x374>  // b.lo, b.ul, b.last
   hLen        = hash_descriptor[hash_idx]->hashsize;
 113b36c:	f00000e4 	adrp	x4, 115a000 <__scattered_array_1phys_mem_map+0x8>
 113b370:	93407f99 	sxtw	x25, w28
 113b374:	f941a084 	ldr	x4, [x4, #832]
 113b378:	f8797880 	ldr	x0, [x4, x25, lsl #3]
 113b37c:	f9400818 	ldr	x24, [x0, #16]
       (modulus_len < hLen + saltlen + 2)) {
 113b380:	f94037e0 	ldr	x0, [sp, #104]
 113b384:	91000800 	add	x0, x0, #0x2
 113b388:	8b180000 	add	x0, x0, x24
   if ((saltlen > modulus_len) ||
 113b38c:	eb13001f 	cmp	x0, x19
 113b390:	540016e8 	b.hi	113b66c <pkcs_1_pss_decode+0x374>  // b.pmore
      return CRYPT_PK_INVALID_SIZE;
   }

   /* allocate ram for DB/mask/salt/hash of size modulus_len */
   DB   = XMALLOC(modulus_len);
 113b394:	aa1303e0 	mov	x0, x19
 113b398:	94002030 	bl	1143458 <malloc>
 113b39c:	aa0003f4 	mov	x20, x0
   mask = XMALLOC(modulus_len);
 113b3a0:	aa1303e0 	mov	x0, x19
 113b3a4:	9400202d 	bl	1143458 <malloc>
 113b3a8:	aa0003f5 	mov	x21, x0
   salt = XMALLOC(modulus_len);
 113b3ac:	aa1303e0 	mov	x0, x19
 113b3b0:	9400202a 	bl	1143458 <malloc>
 113b3b4:	aa0003f7 	mov	x23, x0
   hash = XMALLOC(modulus_len);
 113b3b8:	aa1303e0 	mov	x0, x19
 113b3bc:	94002027 	bl	1143458 <malloc>
 113b3c0:	aa0003f6 	mov	x22, x0
   if (DB == NULL || mask == NULL || salt == NULL || hash == NULL) {
 113b3c4:	f100029f 	cmp	x20, #0x0
 113b3c8:	fa401aa4 	ccmp	x21, #0x0, #0x4, ne  // ne = any
 113b3cc:	54000100 	b.eq	113b3ec <pkcs_1_pss_decode+0xf4>  // b.none
 113b3d0:	f10002ff 	cmp	x23, #0x0
 113b3d4:	fa401804 	ccmp	x0, #0x0, #0x4, ne  // ne = any
 113b3d8:	f9403be6 	ldr	x6, [sp, #112]
 113b3dc:	54000201 	b.ne	113b41c <pkcs_1_pss_decode+0x124>  // b.any
      if (DB != NULL) {
         XFREE(DB);
 113b3e0:	aa1403e0 	mov	x0, x20
 113b3e4:	9400207f 	bl	11435e0 <free>
 113b3e8:	14000002 	b	113b3f0 <pkcs_1_pss_decode+0xf8>
      if (DB != NULL) {
 113b3ec:	b5ffffb4 	cbnz	x20, 113b3e0 <pkcs_1_pss_decode+0xe8>
      }
      if (mask != NULL) {
 113b3f0:	b4000075 	cbz	x21, 113b3fc <pkcs_1_pss_decode+0x104>
         XFREE(mask);
 113b3f4:	aa1503e0 	mov	x0, x21
 113b3f8:	9400207a 	bl	11435e0 <free>
      }
      if (salt != NULL) {
 113b3fc:	b4000077 	cbz	x23, 113b408 <pkcs_1_pss_decode+0x110>
         XFREE(salt);
 113b400:	aa1703e0 	mov	x0, x23
 113b404:	94002077 	bl	11435e0 <free>
      }
      if (hash != NULL) {
 113b408:	b4000076 	cbz	x22, 113b414 <pkcs_1_pss_decode+0x11c>
         XFREE(hash);
 113b40c:	aa1603e0 	mov	x0, x22
 113b410:	94002074 	bl	11435e0 <free>
      }
      return CRYPT_MEM;
 113b414:	528001a3 	mov	w3, #0xd                   	// #13
 113b418:	1400001c 	b	113b488 <pkcs_1_pss_decode+0x190>
   }

   /* ensure the 0xBC byte */
   if (sig[siglen-1] != 0xBC) {
 113b41c:	8b1a0363 	add	x3, x27, x26
 113b420:	385ff060 	ldurb	w0, [x3, #-1]
 113b424:	7102f01f 	cmp	w0, #0xbc
 113b428:	54000400 	b.eq	113b4a8 <pkcs_1_pss_decode+0x1b0>  // b.none
      err = CRYPT_INVALID_PACKET;
 113b42c:	528000e3 	mov	w3, #0x7                   	// #7
   }

   err = CRYPT_OK;
LBL_ERR:
#ifdef LTC_CLEAN_STACK
   zeromem(DB,   modulus_len);
 113b430:	aa1303e1 	mov	x1, x19
 113b434:	aa1403e0 	mov	x0, x20
 113b438:	b9006be3 	str	w3, [sp, #104]
 113b43c:	97ffdc02 	bl	1132444 <zeromem>
   zeromem(mask, modulus_len);
 113b440:	aa1303e1 	mov	x1, x19
 113b444:	aa1503e0 	mov	x0, x21
 113b448:	97ffdbff 	bl	1132444 <zeromem>
   zeromem(salt, modulus_len);
 113b44c:	aa1303e1 	mov	x1, x19
 113b450:	aa1703e0 	mov	x0, x23
 113b454:	97ffdbfc 	bl	1132444 <zeromem>
   zeromem(hash, modulus_len);
 113b458:	aa1303e1 	mov	x1, x19
 113b45c:	aa1603e0 	mov	x0, x22
 113b460:	97ffdbf9 	bl	1132444 <zeromem>
#endif

   XFREE(hash);
 113b464:	aa1603e0 	mov	x0, x22
 113b468:	9400205e 	bl	11435e0 <free>
   XFREE(salt);
 113b46c:	aa1703e0 	mov	x0, x23
 113b470:	9400205c 	bl	11435e0 <free>
   XFREE(mask);
 113b474:	aa1503e0 	mov	x0, x21
 113b478:	9400205a 	bl	11435e0 <free>
   XFREE(DB);
 113b47c:	aa1403e0 	mov	x0, x20
 113b480:	94002058 	bl	11435e0 <free>

   return err;
 113b484:	b9406be3 	ldr	w3, [sp, #104]
}
 113b488:	2a0303e0 	mov	w0, w3
 113b48c:	a94153f3 	ldp	x19, x20, [sp, #16]
 113b490:	a9425bf5 	ldp	x21, x22, [sp, #32]
 113b494:	a94363f7 	ldp	x23, x24, [sp, #48]
 113b498:	a9446bf9 	ldp	x25, x26, [sp, #64]
 113b49c:	a94573fb 	ldp	x27, x28, [sp, #80]
 113b4a0:	a8d67bfd 	ldp	x29, x30, [sp], #352
 113b4a4:	d65f03c0 	ret
   XMEMCPY(DB, sig + x, modulus_len - hLen - 1);
 113b4a8:	aa3803e4 	mvn	x4, x24
 113b4ac:	aa1b03e1 	mov	x1, x27
 113b4b0:	8b13009a 	add	x26, x4, x19
 113b4b4:	aa1403e0 	mov	x0, x20
 113b4b8:	aa1a03e2 	mov	x2, x26
 113b4bc:	f9003be6 	str	x6, [sp, #112]
 113b4c0:	97ff1fb4 	bl	1103390 <memcpy>
   XMEMCPY(hash, sig + x, hLen);
 113b4c4:	aa1803e2 	mov	x2, x24
 113b4c8:	8b1a0361 	add	x1, x27, x26
 113b4cc:	aa1603e0 	mov	x0, x22
 113b4d0:	97ff1fb0 	bl	1103390 <memcpy>
   if ((sig[0] & ~(0xFF >> ((modulus_len<<3) - (modulus_bitlen)))) != 0) {
 113b4d4:	f9403be6 	ldr	x6, [sp, #112]
 113b4d8:	531d7260 	lsl	w0, w19, #3
 113b4dc:	4b060000 	sub	w0, w0, w6
 113b4e0:	52801fe6 	mov	w6, #0xff                  	// #255
 113b4e4:	1ac028c5 	asr	w5, w6, w0
 113b4e8:	39400360 	ldrb	w0, [x27]
 113b4ec:	b90073e5 	str	w5, [sp, #112]
 113b4f0:	6a25001f 	bics	wzr, w0, w5
 113b4f4:	54fff9c1 	b.ne	113b42c <pkcs_1_pss_decode+0x134>  // b.any
   if ((err = pkcs_1_mgf1(hash_idx, hash, hLen, mask, modulus_len - hLen - 1)) != CRYPT_OK) {
 113b4f8:	aa1503e3 	mov	x3, x21
 113b4fc:	aa1a03e4 	mov	x4, x26
 113b500:	aa1803e2 	mov	x2, x24
 113b504:	aa1603e1 	mov	x1, x22
 113b508:	2a1c03e0 	mov	w0, w28
 113b50c:	94000f50 	bl	113f24c <pkcs_1_mgf1>
 113b510:	2a0003e3 	mov	w3, w0
 113b514:	35fff8e0 	cbnz	w0, 113b430 <pkcs_1_pss_decode+0x138>
 113b518:	b94073e5 	ldr	w5, [sp, #112]
   for (y = 0; y < (modulus_len - hLen - 1); y++) {
 113b51c:	d2800000 	mov	x0, #0x0                   	// #0
 113b520:	eb00035f 	cmp	x26, x0
 113b524:	540008c1 	b.ne	113b63c <pkcs_1_pss_decode+0x344>  // b.any
   DB[0] &= 0xFF >> ((modulus_len<<3) - (modulus_bitlen));
 113b528:	39400280 	ldrb	w0, [x20]
   for (x = 0; x < modulus_len - saltlen - hLen - 2; x++) {
 113b52c:	d280001a 	mov	x26, #0x0                   	// #0
 113b530:	f94037e1 	ldr	x1, [sp, #104]
   DB[0] &= 0xFF >> ((modulus_len<<3) - (modulus_bitlen));
 113b534:	0a0000a6 	and	w6, w5, w0
   for (x = 0; x < modulus_len - saltlen - hLen - 2; x++) {
 113b538:	cb180260 	sub	x0, x19, x24
   DB[0] &= 0xFF >> ((modulus_len<<3) - (modulus_bitlen));
 113b53c:	39000286 	strb	w6, [x20]
   for (x = 0; x < modulus_len - saltlen - hLen - 2; x++) {
 113b540:	cb010000 	sub	x0, x0, x1
 113b544:	d1000800 	sub	x0, x0, #0x2
 113b548:	387a6a81 	ldrb	w1, [x20, x26]
 113b54c:	eb1a001f 	cmp	x0, x26
 113b550:	b90073e1 	str	w1, [sp, #112]
 113b554:	54000808 	b.hi	113b654 <pkcs_1_pss_decode+0x35c>  // b.pmore
   if (DB[x++] != 0x01) {
 113b558:	2a0103e0 	mov	w0, w1
 113b55c:	7100041f 	cmp	w0, #0x1
 113b560:	54fff661 	b.ne	113b42c <pkcs_1_pss_decode+0x134>  // b.any
   if ((err = hash_descriptor[hash_idx]->init(&md)) != CRYPT_OK) {
 113b564:	f00000e4 	adrp	x4, 115a000 <__scattered_array_1phys_mem_map+0x8>
 113b568:	910243fb 	add	x27, sp, #0x90
 113b56c:	f941a09c 	ldr	x28, [x4, #832]
 113b570:	f8797b80 	ldr	x0, [x28, x25, lsl #3]
 113b574:	f9405401 	ldr	x1, [x0, #168]
 113b578:	aa1b03e0 	mov	x0, x27
 113b57c:	d63f0020 	blr	x1
 113b580:	2a0003e3 	mov	w3, w0
 113b584:	35fff560 	cbnz	w0, 113b430 <pkcs_1_pss_decode+0x138>
   zeromem(mask, 8);
 113b588:	aa1503e0 	mov	x0, x21
 113b58c:	d2800101 	mov	x1, #0x8                   	// #8
 113b590:	97ffdbad 	bl	1132444 <zeromem>
   if ((err = hash_descriptor[hash_idx]->process(&md, mask, 8)) != CRYPT_OK) {
 113b594:	f8797b80 	ldr	x0, [x28, x25, lsl #3]
 113b598:	aa1503e1 	mov	x1, x21
 113b59c:	d2800102 	mov	x2, #0x8                   	// #8
 113b5a0:	f9405803 	ldr	x3, [x0, #176]
 113b5a4:	aa1b03e0 	mov	x0, x27
 113b5a8:	d63f0060 	blr	x3
 113b5ac:	2a0003e3 	mov	w3, w0
 113b5b0:	35fff400 	cbnz	w0, 113b430 <pkcs_1_pss_decode+0x138>
   if ((err = hash_descriptor[hash_idx]->process(&md, msghash, msghashlen)) != CRYPT_OK) {
 113b5b4:	f8797b80 	ldr	x0, [x28, x25, lsl #3]
 113b5b8:	a9480be1 	ldp	x1, x2, [sp, #128]
 113b5bc:	f9405803 	ldr	x3, [x0, #176]
 113b5c0:	aa1b03e0 	mov	x0, x27
 113b5c4:	d63f0060 	blr	x3
 113b5c8:	2a0003e3 	mov	w3, w0
 113b5cc:	35fff320 	cbnz	w0, 113b430 <pkcs_1_pss_decode+0x138>
   if ((err = hash_descriptor[hash_idx]->process(&md, DB+x, saltlen)) != CRYPT_OK) {
 113b5d0:	f8797b80 	ldr	x0, [x28, x25, lsl #3]
   if (DB[x++] != 0x01) {
 113b5d4:	91000741 	add	x1, x26, #0x1
   if ((err = hash_descriptor[hash_idx]->process(&md, DB+x, saltlen)) != CRYPT_OK) {
 113b5d8:	f94037e2 	ldr	x2, [sp, #104]
 113b5dc:	8b010281 	add	x1, x20, x1
 113b5e0:	f9405803 	ldr	x3, [x0, #176]
 113b5e4:	aa1b03e0 	mov	x0, x27
 113b5e8:	d63f0060 	blr	x3
 113b5ec:	2a0003e3 	mov	w3, w0
 113b5f0:	35fff200 	cbnz	w0, 113b430 <pkcs_1_pss_decode+0x138>
   if ((err = hash_descriptor[hash_idx]->done(&md, mask)) != CRYPT_OK) {
 113b5f4:	f8797b80 	ldr	x0, [x28, x25, lsl #3]
 113b5f8:	aa1503e1 	mov	x1, x21
 113b5fc:	f9405c02 	ldr	x2, [x0, #184]
 113b600:	aa1b03e0 	mov	x0, x27
 113b604:	d63f0040 	blr	x2
 113b608:	2a0003e3 	mov	w3, w0
 113b60c:	35fff120 	cbnz	w0, 113b430 <pkcs_1_pss_decode+0x138>
   if (XMEM_NEQ(mask, hash, hLen) == 0) {
 113b610:	aa1803e2 	mov	x2, x24
 113b614:	aa1603e1 	mov	x1, x22
 113b618:	aa1503e0 	mov	x0, x21
 113b61c:	b9006be3 	str	w3, [sp, #104]
 113b620:	9400265c 	bl	1144f90 <consttime_memcmp>
 113b624:	b9406be3 	ldr	w3, [sp, #104]
 113b628:	35fff040 	cbnz	w0, 113b430 <pkcs_1_pss_decode+0x138>
      *res = 1;
 113b62c:	f9403fe0 	ldr	x0, [sp, #120]
 113b630:	b94073e1 	ldr	w1, [sp, #112]
 113b634:	b9000001 	str	w1, [x0]
 113b638:	17ffff7e 	b	113b430 <pkcs_1_pss_decode+0x138>
      DB[y] ^= mask[y];
 113b63c:	38606a81 	ldrb	w1, [x20, x0]
 113b640:	38606aa2 	ldrb	w2, [x21, x0]
 113b644:	4a020021 	eor	w1, w1, w2
 113b648:	38206a81 	strb	w1, [x20, x0]
   for (y = 0; y < (modulus_len - hLen - 1); y++) {
 113b64c:	91000400 	add	x0, x0, #0x1
 113b650:	17ffffb4 	b	113b520 <pkcs_1_pss_decode+0x228>
       if (DB[x] != 0x00) {
 113b654:	b94073e1 	ldr	w1, [sp, #112]
 113b658:	35ffeea1 	cbnz	w1, 113b42c <pkcs_1_pss_decode+0x134>
   for (x = 0; x < modulus_len - saltlen - hLen - 2; x++) {
 113b65c:	9100075a 	add	x26, x26, #0x1
 113b660:	17ffffba 	b	113b548 <pkcs_1_pss_decode+0x250>
   LTC_ARGCHK(msghash != NULL);
 113b664:	52800203 	mov	w3, #0x10                  	// #16
 113b668:	17ffff88 	b	113b488 <pkcs_1_pss_decode+0x190>
      return CRYPT_PK_INVALID_SIZE;
 113b66c:	528002c3 	mov	w3, #0x16                  	// #22
 113b670:	17ffff86 	b	113b488 <pkcs_1_pss_decode+0x190>

000000000113b674 <pkcs_1_pss_encode>:
int pkcs_1_pss_encode(const unsigned char *msghash, unsigned long msghashlen,
                            unsigned long saltlen,  prng_state   *prng,
                            int           prng_idx, int           hash_idx,
                            unsigned long modulus_bitlen,
                            unsigned char *out,     unsigned long *outlen)
{
 113b674:	a9aa7bfd 	stp	x29, x30, [sp, #-352]!
 113b678:	910003fd 	mov	x29, sp
 113b67c:	a90153f3 	stp	x19, x20, [sp, #16]
 113b680:	a9025bf5 	stp	x21, x22, [sp, #32]
 113b684:	a90363f7 	stp	x23, x24, [sp, #48]
 113b688:	a9046bf9 	stp	x25, x26, [sp, #64]
 113b68c:	a90573fb 	stp	x27, x28, [sp, #80]
 113b690:	f90033e7 	str	x7, [sp, #96]
 113b694:	b90077e5 	str	w5, [sp, #116]
 113b698:	a90787e0 	stp	x0, x1, [sp, #120]
 113b69c:	f90047e3 	str	x3, [sp, #136]
   unsigned char *DB, *mask, *salt, *hash;
   unsigned long x, y, hLen, modulus_len;
   int           err;
   hash_state    md;

   LTC_ARGCHK(msghash != NULL);
 113b6a0:	b4001ae0 	cbz	x0, 113b9fc <pkcs_1_pss_encode+0x388>
   LTC_ARGCHK(out     != NULL);
 113b6a4:	b4001ac7 	cbz	x7, 113b9fc <pkcs_1_pss_encode+0x388>
   LTC_ARGCHK(outlen  != NULL);
 113b6a8:	f940b3e0 	ldr	x0, [sp, #352]
 113b6ac:	b4001a80 	cbz	x0, 113b9fc <pkcs_1_pss_encode+0x388>
 113b6b0:	aa0203f7 	mov	x23, x2
 113b6b4:	2a0403fc 	mov	w28, w4
 113b6b8:	aa0603f3 	mov	x19, x6

   /* ensure hash and PRNG are valid */
   if ((err = hash_is_valid(hash_idx)) != CRYPT_OK) {
 113b6bc:	2a0503e0 	mov	w0, w5
 113b6c0:	97ffdbed 	bl	1132674 <hash_is_valid>
 113b6c4:	2a0003e3 	mov	w3, w0
 113b6c8:	35001320 	cbnz	w0, 113b92c <pkcs_1_pss_encode+0x2b8>
      return err;
   }
   if ((err = prng_is_valid(prng_idx)) != CRYPT_OK) {
 113b6cc:	2a1c03e0 	mov	w0, w28
 113b6d0:	97ffdc03 	bl	11326dc <prng_is_valid>
 113b6d4:	2a0003e3 	mov	w3, w0
 113b6d8:	350012a0 	cbnz	w0, 113b92c <pkcs_1_pss_encode+0x2b8>
      return err;
   }

   hLen        = hash_descriptor[hash_idx]->hashsize;
   modulus_bitlen--;
 113b6dc:	d1000660 	sub	x0, x19, #0x1
 113b6e0:	f90037e0 	str	x0, [sp, #104]
   modulus_len = (modulus_bitlen>>3) + (modulus_bitlen & 7 ? 1 : 0);
 113b6e4:	f240081f 	tst	x0, #0x7
 113b6e8:	d343fc13 	lsr	x19, x0, #3
 113b6ec:	9a930673 	cinc	x19, x19, ne  // ne = any

   /* check sizes */
   if ((saltlen > modulus_len) || (modulus_len < hLen + saltlen + 2)) {
 113b6f0:	eb17027f 	cmp	x19, x23
 113b6f4:	54001883 	b.cc	113ba04 <pkcs_1_pss_encode+0x390>  // b.lo, b.ul, b.last
   hLen        = hash_descriptor[hash_idx]->hashsize;
 113b6f8:	f00000e0 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 113b6fc:	b98077fa 	ldrsw	x26, [sp, #116]
 113b700:	aa0003f9 	mov	x25, x0
 113b704:	f941a001 	ldr	x1, [x0, #832]
 113b708:	f87a7821 	ldr	x1, [x1, x26, lsl #3]
 113b70c:	f940083b 	ldr	x27, [x1, #16]
   if ((saltlen > modulus_len) || (modulus_len < hLen + saltlen + 2)) {
 113b710:	91000ae1 	add	x1, x23, #0x2
 113b714:	8b1b0021 	add	x1, x1, x27
 113b718:	eb13003f 	cmp	x1, x19
 113b71c:	54001748 	b.hi	113ba04 <pkcs_1_pss_encode+0x390>  // b.pmore
      return CRYPT_PK_INVALID_SIZE;
   }

   /* allocate ram for DB/mask/salt/hash of size modulus_len */
   DB   = XMALLOC(modulus_len);
 113b720:	aa1303e0 	mov	x0, x19
 113b724:	94001f4d 	bl	1143458 <malloc>
 113b728:	aa0003f4 	mov	x20, x0
   mask = XMALLOC(modulus_len);
 113b72c:	aa1303e0 	mov	x0, x19
 113b730:	94001f4a 	bl	1143458 <malloc>
 113b734:	aa0003f8 	mov	x24, x0
   salt = XMALLOC(modulus_len);
 113b738:	aa1303e0 	mov	x0, x19
 113b73c:	94001f47 	bl	1143458 <malloc>
 113b740:	aa0003f5 	mov	x21, x0
   hash = XMALLOC(modulus_len);
 113b744:	aa1303e0 	mov	x0, x19
 113b748:	94001f44 	bl	1143458 <malloc>
 113b74c:	aa0003f6 	mov	x22, x0
   if (DB == NULL || mask == NULL || salt == NULL || hash == NULL) {
 113b750:	f100029f 	cmp	x20, #0x0
 113b754:	fa401b04 	ccmp	x24, #0x0, #0x4, ne  // ne = any
 113b758:	540000e0 	b.eq	113b774 <pkcs_1_pss_encode+0x100>  // b.none
 113b75c:	f10002bf 	cmp	x21, #0x0
 113b760:	fa401804 	ccmp	x0, #0x0, #0x4, ne  // ne = any
 113b764:	54000201 	b.ne	113b7a4 <pkcs_1_pss_encode+0x130>  // b.any
      if (DB != NULL) {
         XFREE(DB);
 113b768:	aa1403e0 	mov	x0, x20
 113b76c:	94001f9d 	bl	11435e0 <free>
 113b770:	14000002 	b	113b778 <pkcs_1_pss_encode+0x104>
      if (DB != NULL) {
 113b774:	b5ffffb4 	cbnz	x20, 113b768 <pkcs_1_pss_encode+0xf4>
      }
      if (mask != NULL) {
 113b778:	b4000078 	cbz	x24, 113b784 <pkcs_1_pss_encode+0x110>
         XFREE(mask);
 113b77c:	aa1803e0 	mov	x0, x24
 113b780:	94001f98 	bl	11435e0 <free>
      }
      if (salt != NULL) {
 113b784:	b4000075 	cbz	x21, 113b790 <pkcs_1_pss_encode+0x11c>
         XFREE(salt);
 113b788:	aa1503e0 	mov	x0, x21
 113b78c:	94001f95 	bl	11435e0 <free>
      }
      if (hash != NULL) {
 113b790:	b4000076 	cbz	x22, 113b79c <pkcs_1_pss_encode+0x128>
         XFREE(hash);
 113b794:	aa1603e0 	mov	x0, x22
 113b798:	94001f92 	bl	11435e0 <free>
      }
      return CRYPT_MEM;
 113b79c:	528001a3 	mov	w3, #0xd                   	// #13
 113b7a0:	14000063 	b	113b92c <pkcs_1_pss_encode+0x2b8>
   }


   /* generate random salt */
   if (saltlen > 0) {
 113b7a4:	b5000d57 	cbnz	x23, 113b94c <pkcs_1_pss_encode+0x2d8>
         goto LBL_ERR;
      }
   }

   /* M = (eight) 0x00 || msghash || salt, hash = H(M) */
   if ((err = hash_descriptor[hash_idx]->init(&md)) != CRYPT_OK) {
 113b7a8:	f941a339 	ldr	x25, [x25, #832]
 113b7ac:	910243fc 	add	x28, sp, #0x90
 113b7b0:	f87a7b20 	ldr	x0, [x25, x26, lsl #3]
 113b7b4:	f9405401 	ldr	x1, [x0, #168]
 113b7b8:	aa1c03e0 	mov	x0, x28
 113b7bc:	d63f0020 	blr	x1
 113b7c0:	2a0003e3 	mov	w3, w0
 113b7c4:	35000880 	cbnz	w0, 113b8d4 <pkcs_1_pss_encode+0x260>
      goto LBL_ERR;
   }
   zeromem(DB, 8);
 113b7c8:	aa1403e0 	mov	x0, x20
 113b7cc:	d2800101 	mov	x1, #0x8                   	// #8
 113b7d0:	97ffdb1d 	bl	1132444 <zeromem>
   if ((err = hash_descriptor[hash_idx]->process(&md, DB, 8)) != CRYPT_OK) {
 113b7d4:	f87a7b20 	ldr	x0, [x25, x26, lsl #3]
 113b7d8:	aa1403e1 	mov	x1, x20
 113b7dc:	d2800102 	mov	x2, #0x8                   	// #8
 113b7e0:	f9405803 	ldr	x3, [x0, #176]
 113b7e4:	aa1c03e0 	mov	x0, x28
 113b7e8:	d63f0060 	blr	x3
 113b7ec:	2a0003e3 	mov	w3, w0
 113b7f0:	35000720 	cbnz	w0, 113b8d4 <pkcs_1_pss_encode+0x260>
      goto LBL_ERR;
   }
   if ((err = hash_descriptor[hash_idx]->process(&md, msghash, msghashlen)) != CRYPT_OK) {
 113b7f4:	f87a7b20 	ldr	x0, [x25, x26, lsl #3]
 113b7f8:	a9478be1 	ldp	x1, x2, [sp, #120]
 113b7fc:	f9405803 	ldr	x3, [x0, #176]
 113b800:	aa1c03e0 	mov	x0, x28
 113b804:	d63f0060 	blr	x3
 113b808:	2a0003e3 	mov	w3, w0
 113b80c:	35000640 	cbnz	w0, 113b8d4 <pkcs_1_pss_encode+0x260>
      goto LBL_ERR;
   }
   if ((err = hash_descriptor[hash_idx]->process(&md, salt, saltlen)) != CRYPT_OK) {
 113b810:	f87a7b20 	ldr	x0, [x25, x26, lsl #3]
 113b814:	aa1703e2 	mov	x2, x23
 113b818:	aa1503e1 	mov	x1, x21
 113b81c:	f9405803 	ldr	x3, [x0, #176]
 113b820:	aa1c03e0 	mov	x0, x28
 113b824:	d63f0060 	blr	x3
 113b828:	2a0003e3 	mov	w3, w0
 113b82c:	35000540 	cbnz	w0, 113b8d4 <pkcs_1_pss_encode+0x260>
      goto LBL_ERR;
   }
   if ((err = hash_descriptor[hash_idx]->done(&md, hash)) != CRYPT_OK) {
 113b830:	f87a7b20 	ldr	x0, [x25, x26, lsl #3]
 113b834:	aa1603e1 	mov	x1, x22
 113b838:	f9405c02 	ldr	x2, [x0, #184]
 113b83c:	aa1c03e0 	mov	x0, x28
 113b840:	d63f0040 	blr	x2
 113b844:	2a0003e3 	mov	w3, w0
 113b848:	35000460 	cbnz	w0, 113b8d4 <pkcs_1_pss_encode+0x260>
      goto LBL_ERR;
   }

   /* generate DB = PS || 0x01 || salt, PS == modulus_len - saltlen - hLen - 2 zero bytes */
   x = 0;
   XMEMSET(DB + x, 0, modulus_len - saltlen - hLen - 2);
 113b84c:	cb1b027a 	sub	x26, x19, x27
 113b850:	52800001 	mov	w1, #0x0                   	// #0
 113b854:	cb17035c 	sub	x28, x26, x23
 113b858:	aa1403e0 	mov	x0, x20
 113b85c:	d1000b82 	sub	x2, x28, #0x2
 113b860:	f9003fe2 	str	x2, [sp, #120]
 113b864:	9400211f 	bl	1143ce0 <memset>
   x += modulus_len - saltlen - hLen - 2;
   DB[x++] = 0x01;
 113b868:	f9403fe2 	ldr	x2, [sp, #120]
 113b86c:	52800020 	mov	w0, #0x1                   	// #1
   XMEMCPY(DB + x, salt, saltlen);
 113b870:	aa1503e1 	mov	x1, x21
   DB[x++] = 0x01;
 113b874:	38226a80 	strb	w0, [x20, x2]
 113b878:	d1000780 	sub	x0, x28, #0x1
   XMEMCPY(DB + x, salt, saltlen);
 113b87c:	aa1703e2 	mov	x2, x23
 113b880:	8b000280 	add	x0, x20, x0
 113b884:	97ff1ec3 	bl	1103390 <memcpy>
   /* x += saltlen; */

   /* generate mask of length modulus_len - hLen - 1 from hash */
   if ((err = pkcs_1_mgf1(hash_idx, hash, hLen, mask, modulus_len - hLen - 1)) != CRYPT_OK) {
 113b888:	d1000757 	sub	x23, x26, #0x1
 113b88c:	b94077e0 	ldr	w0, [sp, #116]
 113b890:	aa1803e3 	mov	x3, x24
 113b894:	aa1703e4 	mov	x4, x23
 113b898:	aa1b03e2 	mov	x2, x27
 113b89c:	aa1603e1 	mov	x1, x22
 113b8a0:	94000e6b 	bl	113f24c <pkcs_1_mgf1>
 113b8a4:	2a0003e3 	mov	w3, w0
 113b8a8:	35000160 	cbnz	w0, 113b8d4 <pkcs_1_pss_encode+0x260>
      goto LBL_ERR;
   }

   /* xor against DB */
   for (y = 0; y < (modulus_len - hLen - 1); y++) {
 113b8ac:	d2800000 	mov	x0, #0x0                   	// #0
 113b8b0:	eb0002ff 	cmp	x23, x0
 113b8b4:	54000628 	b.hi	113b978 <pkcs_1_pss_encode+0x304>  // b.pmore
      DB[y] ^= mask[y];
   }

   /* output is DB || hash || 0xBC */
   if (*outlen < modulus_len) {
 113b8b8:	f940b3e0 	ldr	x0, [sp, #352]
 113b8bc:	f9400000 	ldr	x0, [x0]
 113b8c0:	eb13001f 	cmp	x0, x19
 113b8c4:	54000662 	b.cs	113b990 <pkcs_1_pss_encode+0x31c>  // b.hs, b.nlast
      *outlen = modulus_len;
 113b8c8:	f940b3e0 	ldr	x0, [sp, #352]
      err = CRYPT_BUFFER_OVERFLOW;
 113b8cc:	528000c3 	mov	w3, #0x6                   	// #6
      *outlen = modulus_len;
 113b8d0:	f9000013 	str	x19, [x0]
   /* store output size */
   *outlen = modulus_len;
   err = CRYPT_OK;
LBL_ERR:
#ifdef LTC_CLEAN_STACK
   zeromem(DB,   modulus_len);
 113b8d4:	aa1303e1 	mov	x1, x19
 113b8d8:	aa1403e0 	mov	x0, x20
 113b8dc:	b90063e3 	str	w3, [sp, #96]
 113b8e0:	97ffdad9 	bl	1132444 <zeromem>
   zeromem(mask, modulus_len);
 113b8e4:	aa1303e1 	mov	x1, x19
 113b8e8:	aa1803e0 	mov	x0, x24
 113b8ec:	97ffdad6 	bl	1132444 <zeromem>
   zeromem(salt, modulus_len);
 113b8f0:	aa1303e1 	mov	x1, x19
 113b8f4:	aa1503e0 	mov	x0, x21
 113b8f8:	97ffdad3 	bl	1132444 <zeromem>
   zeromem(hash, modulus_len);
 113b8fc:	aa1303e1 	mov	x1, x19
 113b900:	aa1603e0 	mov	x0, x22
 113b904:	97ffdad0 	bl	1132444 <zeromem>
#endif

   XFREE(hash);
 113b908:	aa1603e0 	mov	x0, x22
 113b90c:	94001f35 	bl	11435e0 <free>
   XFREE(salt);
 113b910:	aa1503e0 	mov	x0, x21
 113b914:	94001f33 	bl	11435e0 <free>
   XFREE(mask);
 113b918:	aa1803e0 	mov	x0, x24
 113b91c:	94001f31 	bl	11435e0 <free>
   XFREE(DB);
 113b920:	aa1403e0 	mov	x0, x20
 113b924:	94001f2f 	bl	11435e0 <free>

   return err;
 113b928:	b94063e3 	ldr	w3, [sp, #96]
}
 113b92c:	2a0303e0 	mov	w0, w3
 113b930:	a94153f3 	ldp	x19, x20, [sp, #16]
 113b934:	a9425bf5 	ldp	x21, x22, [sp, #32]
 113b938:	a94363f7 	ldp	x23, x24, [sp, #48]
 113b93c:	a9446bf9 	ldp	x25, x26, [sp, #64]
 113b940:	a94573fb 	ldp	x27, x28, [sp, #80]
 113b944:	a8d67bfd 	ldp	x29, x30, [sp], #352
 113b948:	d65f03c0 	ret
      if (prng_descriptor[prng_idx]->read(salt, saltlen, prng) != saltlen) {
 113b94c:	f9422f20 	ldr	x0, [x25, #1112]
 113b950:	aa1703e1 	mov	x1, x23
 113b954:	f94047e2 	ldr	x2, [sp, #136]
 113b958:	f87cd800 	ldr	x0, [x0, w28, sxtw #3]
 113b95c:	f9401403 	ldr	x3, [x0, #40]
 113b960:	aa1503e0 	mov	x0, x21
 113b964:	d63f0060 	blr	x3
 113b968:	eb17001f 	cmp	x0, x23
 113b96c:	54fff1e0 	b.eq	113b7a8 <pkcs_1_pss_encode+0x134>  // b.none
         err = CRYPT_ERROR_READPRNG;
 113b970:	52800123 	mov	w3, #0x9                   	// #9
 113b974:	17ffffd8 	b	113b8d4 <pkcs_1_pss_encode+0x260>
      DB[y] ^= mask[y];
 113b978:	38606a81 	ldrb	w1, [x20, x0]
 113b97c:	38606b02 	ldrb	w2, [x24, x0]
 113b980:	4a020021 	eor	w1, w1, w2
 113b984:	38206a81 	strb	w1, [x20, x0]
   for (y = 0; y < (modulus_len - hLen - 1); y++) {
 113b988:	91000400 	add	x0, x0, #0x1
 113b98c:	17ffffc9 	b	113b8b0 <pkcs_1_pss_encode+0x23c>
   XMEMCPY(out + y, DB, modulus_len - hLen - 1);
 113b990:	f94033e0 	ldr	x0, [sp, #96]
 113b994:	aa1703e2 	mov	x2, x23
 113b998:	aa1403e1 	mov	x1, x20
 113b99c:	b90077e3 	str	w3, [sp, #116]
 113b9a0:	97ff1e7c 	bl	1103390 <memcpy>
   XMEMCPY(out + y, hash, hLen);
 113b9a4:	f94033e0 	ldr	x0, [sp, #96]
 113b9a8:	aa1603e1 	mov	x1, x22
 113b9ac:	aa1b03e2 	mov	x2, x27
 113b9b0:	8b170017 	add	x23, x0, x23
 113b9b4:	aa1703e0 	mov	x0, x23
 113b9b8:	97ff1e76 	bl	1103390 <memcpy>
   out[0] &= 0xFF >> ((modulus_len<<3) - modulus_bitlen);
 113b9bc:	b9406be1 	ldr	w1, [sp, #104]
   out[y] = 0xBC;
 113b9c0:	12800860 	mov	w0, #0xffffffbc            	// #-68
 113b9c4:	383b6ae0 	strb	w0, [x23, x27]
   out[0] &= 0xFF >> ((modulus_len<<3) - modulus_bitlen);
 113b9c8:	531d7260 	lsl	w0, w19, #3
 113b9cc:	4b010006 	sub	w6, w0, w1
 113b9d0:	52801fe0 	mov	w0, #0xff                  	// #255
 113b9d4:	f94033e1 	ldr	x1, [sp, #96]
 113b9d8:	1ac62800 	asr	w0, w0, w6
 113b9dc:	b94077e3 	ldr	w3, [sp, #116]
 113b9e0:	39400021 	ldrb	w1, [x1]
 113b9e4:	0a010000 	and	w0, w0, w1
 113b9e8:	f94033e1 	ldr	x1, [sp, #96]
 113b9ec:	39000020 	strb	w0, [x1]
   *outlen = modulus_len;
 113b9f0:	f940b3e0 	ldr	x0, [sp, #352]
 113b9f4:	f9000013 	str	x19, [x0]
   err = CRYPT_OK;
 113b9f8:	17ffffb7 	b	113b8d4 <pkcs_1_pss_encode+0x260>
   LTC_ARGCHK(msghash != NULL);
 113b9fc:	52800203 	mov	w3, #0x10                  	// #16
 113ba00:	17ffffcb 	b	113b92c <pkcs_1_pss_encode+0x2b8>
      return CRYPT_PK_INVALID_SIZE;
 113ba04:	528002c3 	mov	w3, #0x16                  	// #22
 113ba08:	17ffffc9 	b	113b92c <pkcs_1_pss_encode+0x2b8>

000000000113ba0c <pkcs_1_v1_5_decode>:
                                       int  block_type,
                             unsigned long  modulus_bitlen,
                             unsigned char *out,
                             unsigned long *outlen,
                                       int *is_valid)
{
 113ba0c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  int result;

  /* default to invalid packet */
  *is_valid = 0;

  modulus_len = (modulus_bitlen >> 3) + (modulus_bitlen & 7 ? 1 : 0);
 113ba10:	f240087f 	tst	x3, #0x7
 113ba14:	d343fc63 	lsr	x3, x3, #3
{
 113ba18:	910003fd 	mov	x29, sp
  modulus_len = (modulus_bitlen >> 3) + (modulus_bitlen & 7 ? 1 : 0);
 113ba1c:	9a830463 	cinc	x3, x3, ne  // ne = any
  *is_valid = 0;
 113ba20:	b90000df 	str	wzr, [x6]
{
 113ba24:	a90153f3 	stp	x19, x20, [sp, #16]

  /* test message size */

  if ((msglen > modulus_len) || (modulus_len < 11)) {
 113ba28:	eb01007f 	cmp	x3, x1
 113ba2c:	fa4a2860 	ccmp	x3, #0xa, #0x0, cs  // cs = hs, nlast
 113ba30:	54000789 	b.ls	113bb20 <pkcs_1_v1_5_decode+0x114>  // b.plast
 113ba34:	aa0003e8 	mov	x8, x0
 113ba38:	aa0403e0 	mov	x0, x4
 113ba3c:	aa0603f4 	mov	x20, x6

  result = CRYPT_OK;

  /* separate encoded message */

  if ((msg[0] != 0x00) || (msg[1] != (unsigned char)block_type)) {
 113ba40:	39400104 	ldrb	w4, [x8]
 113ba44:	350004e4 	cbnz	w4, 113bae0 <pkcs_1_v1_5_decode+0xd4>
 113ba48:	39400504 	ldrb	w4, [x8, #1]
    result = CRYPT_INVALID_PACKET;
 113ba4c:	528000f3 	mov	w19, #0x7                   	// #7
 113ba50:	6b22009f 	cmp	w4, w2, uxtb
 113ba54:	1a9303f3 	csel	w19, wzr, w19, eq  // eq = none
  }

  if (block_type == LTC_PKCS_1_EME) {
 113ba58:	7100085f 	cmp	w2, #0x2
 113ba5c:	54000461 	b.ne	113bae8 <pkcs_1_v1_5_decode+0xdc>  // b.any
    for (i = 2; i < modulus_len; i++) {
 113ba60:	d2800047 	mov	x7, #0x2                   	// #2
      /* separator */
      if (msg[i] == 0x00) { break; }
 113ba64:	38676904 	ldrb	w4, [x8, x7]
 113ba68:	aa0703e2 	mov	x2, x7
 113ba6c:	910004e7 	add	x7, x7, #0x1
 113ba70:	34000084 	cbz	w4, 113ba80 <pkcs_1_v1_5_decode+0x74>
    for (i = 2; i < modulus_len; i++) {
 113ba74:	eb07007f 	cmp	x3, x7
 113ba78:	54ffff68 	b.hi	113ba64 <pkcs_1_v1_5_decode+0x58>  // b.pmore
 113ba7c:	aa0703e2 	mov	x2, x7
    }
    ps_len = i++ - 2;
 113ba80:	d1000847 	sub	x7, x2, #0x2
 113ba84:	91000442 	add	x2, x2, #0x1

    if (i >= modulus_len) {
      /* There was no octet with hexadecimal value 0x00 to separate ps from m.
       */
      result = CRYPT_INVALID_PACKET;
 113ba88:	eb02007f 	cmp	x3, x2
 113ba8c:	528000e2 	mov	w2, #0x7                   	// #7
 113ba90:	1a828273 	csel	w19, w19, w2, hi  // hi = pmore
    /* The length of ps is less than 8 octets.
     */
    result = CRYPT_INVALID_PACKET;
  }

  if (*outlen < (msglen - (2 + ps_len + 1))) {
 113ba94:	d1000c22 	sub	x2, x1, #0x3
    result = CRYPT_INVALID_PACKET;
 113ba98:	f1001cff 	cmp	x7, #0x7
  if (*outlen < (msglen - (2 + ps_len + 1))) {
 113ba9c:	f94000a1 	ldr	x1, [x5]
 113baa0:	cb070042 	sub	x2, x2, x7
    result = CRYPT_INVALID_PACKET;
 113baa4:	528000e3 	mov	w3, #0x7                   	// #7
 113baa8:	1a838273 	csel	w19, w19, w3, hi  // hi = pmore
  if (*outlen < (msglen - (2 + ps_len + 1))) {
 113baac:	eb02003f 	cmp	x1, x2
 113bab0:	540003c3 	b.cc	113bb28 <pkcs_1_v1_5_decode+0x11c>  // b.lo, b.ul, b.last
    result = CRYPT_INVALID_PACKET;
  }

  if (result == CRYPT_OK) {
 113bab4:	350000f3 	cbnz	w19, 113bad0 <pkcs_1_v1_5_decode+0xc4>
     *outlen = (msglen - (2 + ps_len + 1));
 113bab8:	f90000a2 	str	x2, [x5]
     XMEMCPY(out, &msg[2 + ps_len + 1], *outlen);
 113babc:	91000ce1 	add	x1, x7, #0x3
 113bac0:	8b010101 	add	x1, x8, x1
 113bac4:	97ff1e33 	bl	1103390 <memcpy>

     /* valid packet */
     *is_valid = 1;
 113bac8:	52800020 	mov	w0, #0x1                   	// #1
 113bacc:	b9000280 	str	w0, [x20]
  }

  return result;
} /* pkcs_1_v1_5_decode */
 113bad0:	2a1303e0 	mov	w0, w19
 113bad4:	a94153f3 	ldp	x19, x20, [sp, #16]
 113bad8:	a8c27bfd 	ldp	x29, x30, [sp], #32
 113badc:	d65f03c0 	ret
    result = CRYPT_INVALID_PACKET;
 113bae0:	528000f3 	mov	w19, #0x7                   	// #7
 113bae4:	17ffffdd 	b	113ba58 <pkcs_1_v1_5_decode+0x4c>
    for (i = 2; i < modulus_len - 1; i++) {
 113bae8:	d1000463 	sub	x3, x3, #0x1
 113baec:	d2800042 	mov	x2, #0x2                   	// #2
       if (msg[i] != 0xFF) { break; }
 113baf0:	38626904 	ldrb	w4, [x8, x2]
 113baf4:	7103fc9f 	cmp	w4, #0xff
 113baf8:	54000081 	b.ne	113bb08 <pkcs_1_v1_5_decode+0xfc>  // b.any
    for (i = 2; i < modulus_len - 1; i++) {
 113bafc:	91000442 	add	x2, x2, #0x1
 113bb00:	eb02007f 	cmp	x3, x2
 113bb04:	54ffff68 	b.hi	113baf0 <pkcs_1_v1_5_decode+0xe4>  // b.pmore
    if (msg[i] != 0) {
 113bb08:	38626903 	ldrb	w3, [x8, x2]
    ps_len = i - 2;
 113bb0c:	d1000847 	sub	x7, x2, #0x2
      result = CRYPT_INVALID_PACKET;
 113bb10:	7100007f 	cmp	w3, #0x0
 113bb14:	528000e3 	mov	w3, #0x7                   	// #7
 113bb18:	1a830273 	csel	w19, w19, w3, eq  // eq = none
    ps_len = i - 2;
 113bb1c:	17ffffde 	b	113ba94 <pkcs_1_v1_5_decode+0x88>
    return CRYPT_PK_INVALID_SIZE;
 113bb20:	528002d3 	mov	w19, #0x16                  	// #22
 113bb24:	17ffffeb 	b	113bad0 <pkcs_1_v1_5_decode+0xc4>
    result = CRYPT_INVALID_PACKET;
 113bb28:	2a0303f3 	mov	w19, w3
 113bb2c:	17ffffe9 	b	113bad0 <pkcs_1_v1_5_decode+0xc4>

000000000113bb30 <pkcs_1_v1_5_encode>:
                             unsigned long  modulus_bitlen,
                                prng_state *prng,
                                       int  prng_idx,
                             unsigned char *out,
                             unsigned long *outlen)
{
 113bb30:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
 113bb34:	910003fd 	mov	x29, sp
 113bb38:	a90153f3 	stp	x19, x20, [sp, #16]
 113bb3c:	a9025bf5 	stp	x21, x22, [sp, #32]
 113bb40:	a90363f7 	stp	x23, x24, [sp, #48]
 113bb44:	a9046bf9 	stp	x25, x26, [sp, #64]
 113bb48:	aa0003fa 	mov	x26, x0
  unsigned long modulus_len, ps_len, i;
  unsigned char *ps;
  int result;

  /* valid block_type? */
  if ((block_type != LTC_PKCS_1_EMSA) &&
 113bb4c:	51000440 	sub	w0, w2, #0x1
{
 113bb50:	a90573fb 	stp	x27, x28, [sp, #80]
  if ((block_type != LTC_PKCS_1_EMSA) &&
 113bb54:	7100041f 	cmp	w0, #0x1
 113bb58:	54000ac8 	b.hi	113bcb0 <pkcs_1_v1_5_encode+0x180>  // b.pmore
 113bb5c:	aa0103f8 	mov	x24, x1
 113bb60:	2a0203f6 	mov	w22, w2
 113bb64:	aa0303f3 	mov	x19, x3
 113bb68:	aa0403f9 	mov	x25, x4
 113bb6c:	93407cbc 	sxtw	x28, w5
 113bb70:	aa0603f4 	mov	x20, x6
 113bb74:	aa0703f7 	mov	x23, x7
      (block_type != LTC_PKCS_1_EME)) {
     return CRYPT_PK_INVALID_PADDING;
  }

  if (block_type == LTC_PKCS_1_EME) {    /* encryption padding, we need a valid PRNG */
 113bb78:	7100085f 	cmp	w2, #0x2
 113bb7c:	54000120 	b.eq	113bba0 <pkcs_1_v1_5_encode+0x70>  // b.none
    if ((result = prng_is_valid(prng_idx)) != CRYPT_OK) {
       return result;
    }
  }

  modulus_len = (modulus_bitlen >> 3) + (modulus_bitlen & 7 ? 1 : 0);
 113bb80:	f2400a7f 	tst	x19, #0x7
 113bb84:	d343fe73 	lsr	x19, x19, #3
 113bb88:	9a930673 	cinc	x19, x19, ne  // ne = any

  /* test message size */
  if ((msglen + 11) > modulus_len) {
 113bb8c:	91002f00 	add	x0, x24, #0xb
 113bb90:	eb13001f 	cmp	x0, x19
 113bb94:	540001a9 	b.ls	113bbc8 <pkcs_1_v1_5_encode+0x98>  // b.plast
    return CRYPT_PK_INVALID_SIZE;
 113bb98:	528002c0 	mov	w0, #0x16                  	// #22
 113bb9c:	14000004 	b	113bbac <pkcs_1_v1_5_encode+0x7c>
    if ((result = prng_is_valid(prng_idx)) != CRYPT_OK) {
 113bba0:	2a1c03e0 	mov	w0, w28
 113bba4:	97ffdace 	bl	11326dc <prng_is_valid>
 113bba8:	34fffec0 	cbz	w0, 113bb80 <pkcs_1_v1_5_encode+0x50>
  *outlen = modulus_len;

  result  = CRYPT_OK;
bail:
  return result;
} /* pkcs_1_v1_5_encode */
 113bbac:	a94153f3 	ldp	x19, x20, [sp, #16]
 113bbb0:	a9425bf5 	ldp	x21, x22, [sp, #32]
 113bbb4:	a94363f7 	ldp	x23, x24, [sp, #48]
 113bbb8:	a9446bf9 	ldp	x25, x26, [sp, #64]
 113bbbc:	a94573fb 	ldp	x27, x28, [sp, #80]
 113bbc0:	a8c77bfd 	ldp	x29, x30, [sp], #112
 113bbc4:	d65f03c0 	ret
  if (*outlen < modulus_len) {
 113bbc8:	f94002e0 	ldr	x0, [x23]
 113bbcc:	eb13001f 	cmp	x0, x19
 113bbd0:	54000082 	b.cs	113bbe0 <pkcs_1_v1_5_encode+0xb0>  // b.hs, b.nlast
    result = CRYPT_BUFFER_OVERFLOW;
 113bbd4:	528000c0 	mov	w0, #0x6                   	// #6
    *outlen = modulus_len;
 113bbd8:	f90002f3 	str	x19, [x23]
    goto bail;
 113bbdc:	17fffff4 	b	113bbac <pkcs_1_v1_5_encode+0x7c>
  ps_len = modulus_len - msglen - 3;
 113bbe0:	cb18027b 	sub	x27, x19, x24
  ps = &out[2];
 113bbe4:	91000a95 	add	x21, x20, #0x2
  ps_len = modulus_len - msglen - 3;
 113bbe8:	d1000f61 	sub	x1, x27, #0x3
  if (block_type == LTC_PKCS_1_EME) {
 113bbec:	71000adf 	cmp	w22, #0x2
 113bbf0:	54000561 	b.ne	113bc9c <pkcs_1_v1_5_encode+0x16c>  // b.any
    if (prng_descriptor[prng_idx]->read(ps, ps_len, prng) != ps_len) {
 113bbf4:	f00000e0 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 113bbf8:	aa1903e2 	mov	x2, x25
 113bbfc:	f9422c03 	ldr	x3, [x0, #1112]
 113bc00:	a9060fe1 	stp	x1, x3, [sp, #96]
 113bc04:	f87c7860 	ldr	x0, [x3, x28, lsl #3]
 113bc08:	f9401404 	ldr	x4, [x0, #40]
 113bc0c:	aa1503e0 	mov	x0, x21
 113bc10:	d63f0080 	blr	x4
 113bc14:	f94033e1 	ldr	x1, [sp, #96]
 113bc18:	eb01001f 	cmp	x0, x1
 113bc1c:	54000201 	b.ne	113bc5c <pkcs_1_v1_5_encode+0x12c>  // b.any
 113bc20:	d1000684 	sub	x4, x20, #0x1
        if (prng_descriptor[prng_idx]->read(&ps[i], 1, prng) != 1) {
 113bc24:	f94037e3 	ldr	x3, [sp, #104]
 113bc28:	8b1b0084 	add	x4, x4, x27
    for (i = 0; i < ps_len; i++) {
 113bc2c:	eb0402bf 	cmp	x21, x4
 113bc30:	540002e1 	b.ne	113bc8c <pkcs_1_v1_5_encode+0x15c>  // b.any
  out[2 + ps_len] = 0x00;
 113bc34:	8b1b0280 	add	x0, x20, x27
  out[0]          = 0x00;
 113bc38:	3900029f 	strb	wzr, [x20]
  out[1]          = (unsigned char)block_type;  /* block_type 1 or 2 */
 113bc3c:	39000696 	strb	w22, [x20, #1]
  XMEMCPY(&out[2 + ps_len + 1], msg, msglen);
 113bc40:	aa1803e2 	mov	x2, x24
 113bc44:	aa1a03e1 	mov	x1, x26
  out[2 + ps_len] = 0x00;
 113bc48:	381ff01f 	sturb	wzr, [x0, #-1]
  XMEMCPY(&out[2 + ps_len + 1], msg, msglen);
 113bc4c:	97ff1dd1 	bl	1103390 <memcpy>
  *outlen = modulus_len;
 113bc50:	f90002f3 	str	x19, [x23]
  result  = CRYPT_OK;
 113bc54:	52800000 	mov	w0, #0x0                   	// #0
 113bc58:	17ffffd5 	b	113bbac <pkcs_1_v1_5_encode+0x7c>
      result = CRYPT_ERROR_READPRNG;
 113bc5c:	52800120 	mov	w0, #0x9                   	// #9
 113bc60:	17ffffd3 	b	113bbac <pkcs_1_v1_5_encode+0x7c>
        if (prng_descriptor[prng_idx]->read(&ps[i], 1, prng) != 1) {
 113bc64:	f87c7860 	ldr	x0, [x3, x28, lsl #3]
 113bc68:	aa1903e2 	mov	x2, x25
 113bc6c:	d2800021 	mov	x1, #0x1                   	// #1
 113bc70:	a90613e3 	stp	x3, x4, [sp, #96]
 113bc74:	f9401405 	ldr	x5, [x0, #40]
 113bc78:	aa1503e0 	mov	x0, x21
 113bc7c:	d63f00a0 	blr	x5
 113bc80:	f100041f 	cmp	x0, #0x1
 113bc84:	a94613e3 	ldp	x3, x4, [sp, #96]
 113bc88:	54fffea1 	b.ne	113bc5c <pkcs_1_v1_5_encode+0x12c>  // b.any
      while (ps[i] == 0) {
 113bc8c:	394002a0 	ldrb	w0, [x21]
 113bc90:	34fffea0 	cbz	w0, 113bc64 <pkcs_1_v1_5_encode+0x134>
    for (i = 0; i < ps_len; i++) {
 113bc94:	910006b5 	add	x21, x21, #0x1
 113bc98:	17ffffe5 	b	113bc2c <pkcs_1_v1_5_encode+0xfc>
    XMEMSET(ps, 0xFF, ps_len);
 113bc9c:	aa0103e2 	mov	x2, x1
 113bca0:	aa1503e0 	mov	x0, x21
 113bca4:	52801fe1 	mov	w1, #0xff                  	// #255
 113bca8:	9400200e 	bl	1143ce0 <memset>
 113bcac:	17ffffe2 	b	113bc34 <pkcs_1_v1_5_encode+0x104>
     return CRYPT_PK_INVALID_PADDING;
 113bcb0:	52800300 	mov	w0, #0x18                  	// #24
 113bcb4:	17ffffbe 	b	113bbac <pkcs_1_v1_5_encode+0x7c>

000000000113bcb8 <ecc_get_oid_str>:
  @param key    The ECC key
  Return        CRYPT_OK on success
*/

int ecc_get_oid_str(char *out, unsigned long *outlen, const ecc_key *key)
{
 113bcb8:	aa0103e3 	mov	x3, x1
 113bcbc:	aa0203e4 	mov	x4, x2
   LTC_ARGCHK(key != NULL);
 113bcc0:	b40000a2 	cbz	x2, 113bcd4 <ecc_get_oid_str+0x1c>

   return pk_oid_num_to_str(key->dp.oid, key->dp.oidlen, out, outlen);
 113bcc4:	f9406881 	ldr	x1, [x4, #208]
 113bcc8:	aa0003e2 	mov	x2, x0
 113bccc:	91014080 	add	x0, x4, #0x50
 113bcd0:	17fffbb6 	b	113aba8 <pk_oid_num_to_str>
}
 113bcd4:	52800200 	mov	w0, #0x10                  	// #16
 113bcd8:	d65f03c0 	ret

000000000113bcdc <_ecc_cmp_hex_bn>:
#include "tomcrypt_private.h"

#ifdef LTC_MECC

static int _ecc_cmp_hex_bn(const char *left_hex, void *right_bn, void *tmp_bn)
{
 113bcdc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 113bce0:	910003fd 	mov	x29, sp
 113bce4:	a90153f3 	stp	x19, x20, [sp, #16]
   if (mp_read_radix(tmp_bn, left_hex, 16) != CRYPT_OK) return 0;
 113bce8:	f00000f4 	adrp	x20, 115a000 <__scattered_array_1phys_mem_map+0x8>
{
 113bcec:	aa0203f3 	mov	x19, x2
   if (mp_read_radix(tmp_bn, left_hex, 16) != CRYPT_OK) return 0;
 113bcf0:	f941d694 	ldr	x20, [x20, #936]
 113bcf4:	52800202 	mov	w2, #0x10                  	// #16
 113bcf8:	f9404683 	ldr	x3, [x20, #136]
{
 113bcfc:	f90013f5 	str	x21, [sp, #32]
 113bd00:	aa0103f5 	mov	x21, x1
   if (mp_read_radix(tmp_bn, left_hex, 16) != CRYPT_OK) return 0;
 113bd04:	aa0003e1 	mov	x1, x0
 113bd08:	aa1303e0 	mov	x0, x19
 113bd0c:	d63f0060 	blr	x3
 113bd10:	35000160 	cbnz	w0, 113bd3c <_ecc_cmp_hex_bn+0x60>
   if (mp_cmp(tmp_bn, right_bn) != LTC_MP_EQ)           return 0;
 113bd14:	f9403282 	ldr	x2, [x20, #96]
 113bd18:	aa1503e1 	mov	x1, x21
 113bd1c:	aa1303e0 	mov	x0, x19
 113bd20:	d63f0040 	blr	x2
 113bd24:	7100001f 	cmp	w0, #0x0
 113bd28:	1a9f17e0 	cset	w0, eq  // eq = none
   return 1;
}
 113bd2c:	a94153f3 	ldp	x19, x20, [sp, #16]
 113bd30:	f94013f5 	ldr	x21, [sp, #32]
 113bd34:	a8c37bfd 	ldp	x29, x30, [sp], #48
 113bd38:	d65f03c0 	ret
   if (mp_read_radix(tmp_bn, left_hex, 16) != CRYPT_OK) return 0;
 113bd3c:	52800000 	mov	w0, #0x0                   	// #0
 113bd40:	17fffffb 	b	113bd2c <_ecc_cmp_hex_bn+0x50>

000000000113bd44 <_ecc_oid_lookup>:

static void _ecc_oid_lookup(ecc_key *key)
{
 113bd44:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 113bd48:	910003fd 	mov	x29, sp
 113bd4c:	a9025bf5 	stp	x21, x22, [sp, #32]
   void *bn;
   const ltc_ecc_curve *curve;

   key->dp.oidlen = 0;
   if (mp_init(&bn) != CRYPT_OK) return;
 113bd50:	f00000f6 	adrp	x22, 115a000 <__scattered_array_1phys_mem_map+0x8>
{
 113bd54:	a90153f3 	stp	x19, x20, [sp, #16]
 113bd58:	aa0003f3 	mov	x19, x0
   key->dp.oidlen = 0;
 113bd5c:	f900681f 	str	xzr, [x0, #208]
   if (mp_init(&bn) != CRYPT_OK) return;
 113bd60:	f941d6c0 	ldr	x0, [x22, #936]
 113bd64:	f9400801 	ldr	x1, [x0, #16]
 113bd68:	9100e3e0 	add	x0, sp, #0x38
 113bd6c:	d63f0020 	blr	x1
 113bd70:	340007c0 	cbz	w0, 113be68 <_ecc_oid_lookup+0x124>
   mp_clear(bn);
   if (curve->prime && curve->OID) {
      key->dp.oidlen = 16; /* size of key->dp.oid */
      pk_oid_str_to_num(curve->OID, key->dp.oid, &key->dp.oidlen);
   }
}
 113bd74:	a94153f3 	ldp	x19, x20, [sp, #16]
 113bd78:	a9425bf5 	ldp	x21, x22, [sp, #32]
 113bd7c:	a8c47bfd 	ldp	x29, x30, [sp], #64
 113bd80:	d65f03c0 	ret
      if (_ecc_cmp_hex_bn(curve->prime, key->dp.prime,  bn) != 1) continue;
 113bd84:	f9400a61 	ldr	x1, [x19, #16]
 113bd88:	97ffffd5 	bl	113bcdc <_ecc_cmp_hex_bn>
 113bd8c:	7100041f 	cmp	w0, #0x1
 113bd90:	540000c0 	b.eq	113bda8 <_ecc_oid_lookup+0x64>  // b.none
   for (curve = ltc_ecc_curves; curve->prime != NULL; curve++) {
 113bd94:	91010294 	add	x20, x20, #0x40
 113bd98:	f9400280 	ldr	x0, [x20]
 113bd9c:	f9401fe2 	ldr	x2, [sp, #56]
 113bda0:	b5ffff20 	cbnz	x0, 113bd84 <_ecc_oid_lookup+0x40>
 113bda4:	14000023 	b	113be30 <_ecc_oid_lookup+0xec>
      if (_ecc_cmp_hex_bn(curve->order, key->dp.order,  bn) != 1) continue;
 113bda8:	f9400e80 	ldr	x0, [x20, #24]
 113bdac:	f9401661 	ldr	x1, [x19, #40]
 113bdb0:	f9401fe2 	ldr	x2, [sp, #56]
 113bdb4:	97ffffca 	bl	113bcdc <_ecc_cmp_hex_bn>
 113bdb8:	7100041f 	cmp	w0, #0x1
 113bdbc:	54fffec1 	b.ne	113bd94 <_ecc_oid_lookup+0x50>  // b.any
      if (_ecc_cmp_hex_bn(curve->A,     key->dp.A,      bn) != 1) continue;
 113bdc0:	f9400680 	ldr	x0, [x20, #8]
 113bdc4:	f9400e61 	ldr	x1, [x19, #24]
 113bdc8:	f9401fe2 	ldr	x2, [sp, #56]
 113bdcc:	97ffffc4 	bl	113bcdc <_ecc_cmp_hex_bn>
 113bdd0:	7100041f 	cmp	w0, #0x1
 113bdd4:	54fffe01 	b.ne	113bd94 <_ecc_oid_lookup+0x50>  // b.any
      if (_ecc_cmp_hex_bn(curve->B,     key->dp.B,      bn) != 1) continue;
 113bdd8:	f9400a80 	ldr	x0, [x20, #16]
 113bddc:	f9401261 	ldr	x1, [x19, #32]
 113bde0:	f9401fe2 	ldr	x2, [sp, #56]
 113bde4:	97ffffbe 	bl	113bcdc <_ecc_cmp_hex_bn>
 113bde8:	7100041f 	cmp	w0, #0x1
 113bdec:	54fffd41 	b.ne	113bd94 <_ecc_oid_lookup+0x50>  // b.any
      if (_ecc_cmp_hex_bn(curve->Gx,    key->dp.base.x, bn) != 1) continue;
 113bdf0:	f9401280 	ldr	x0, [x20, #32]
 113bdf4:	f9401a61 	ldr	x1, [x19, #48]
 113bdf8:	f9401fe2 	ldr	x2, [sp, #56]
 113bdfc:	97ffffb8 	bl	113bcdc <_ecc_cmp_hex_bn>
 113be00:	7100041f 	cmp	w0, #0x1
 113be04:	54fffc81 	b.ne	113bd94 <_ecc_oid_lookup+0x50>  // b.any
      if (_ecc_cmp_hex_bn(curve->Gy,    key->dp.base.y, bn) != 1) continue;
 113be08:	f9401680 	ldr	x0, [x20, #40]
 113be0c:	f9401e61 	ldr	x1, [x19, #56]
 113be10:	f9401fe2 	ldr	x2, [sp, #56]
 113be14:	97ffffb2 	bl	113bcdc <_ecc_cmp_hex_bn>
 113be18:	7100041f 	cmp	w0, #0x1
 113be1c:	54fffbc1 	b.ne	113bd94 <_ecc_oid_lookup+0x50>  // b.any
      if (key->dp.cofactor != curve->cofactor)                    continue;
 113be20:	f9401a80 	ldr	x0, [x20, #48]
 113be24:	f9402661 	ldr	x1, [x19, #72]
 113be28:	eb00003f 	cmp	x1, x0
 113be2c:	54fffb41 	b.ne	113bd94 <_ecc_oid_lookup+0x50>  // b.any
   mp_clear(bn);
 113be30:	f941d6b5 	ldr	x21, [x21, #936]
 113be34:	f9401fe0 	ldr	x0, [sp, #56]
 113be38:	f94016a1 	ldr	x1, [x21, #40]
 113be3c:	d63f0020 	blr	x1
   if (curve->prime && curve->OID) {
 113be40:	f9400280 	ldr	x0, [x20]
 113be44:	b4fff980 	cbz	x0, 113bd74 <_ecc_oid_lookup+0x30>
 113be48:	f9401e80 	ldr	x0, [x20, #56]
 113be4c:	b4fff940 	cbz	x0, 113bd74 <_ecc_oid_lookup+0x30>
      key->dp.oidlen = 16; /* size of key->dp.oid */
 113be50:	aa1303e2 	mov	x2, x19
 113be54:	d2800201 	mov	x1, #0x10                  	// #16
 113be58:	f80d0c41 	str	x1, [x2, #208]!
      pk_oid_str_to_num(curve->OID, key->dp.oid, &key->dp.oidlen);
 113be5c:	91014261 	add	x1, x19, #0x50
 113be60:	97fffb13 	bl	113aaac <pk_oid_str_to_num>
 113be64:	17ffffc4 	b	113bd74 <_ecc_oid_lookup+0x30>
   for (curve = ltc_ecc_curves; curve->prime != NULL; curve++) {
 113be68:	f9421ad4 	ldr	x20, [x22, #1072]
 113be6c:	aa1603f5 	mov	x21, x22
 113be70:	17ffffca 	b	113bd98 <_ecc_oid_lookup+0x54>

000000000113be74 <ecc_copy_curve>:

int ecc_copy_curve(const ecc_key *srckey, ecc_key *key)
{
 113be74:	d10183ff 	sub	sp, sp, #0x60
 113be78:	a9027bfd 	stp	x29, x30, [sp, #32]
 113be7c:	910083fd 	add	x29, sp, #0x20
 113be80:	a90353f3 	stp	x19, x20, [sp, #48]
 113be84:	a9045bf5 	stp	x21, x22, [sp, #64]
 113be88:	f9002bf7 	str	x23, [sp, #80]
   unsigned long i;
   int err;

   LTC_ARGCHK(key != NULL);
 113be8c:	b4000a21 	cbz	x1, 113bfd0 <ecc_copy_curve+0x15c>
 113be90:	aa0003f5 	mov	x21, x0
   LTC_ARGCHK(srckey != NULL);
 113be94:	b40009e0 	cbz	x0, 113bfd0 <ecc_copy_curve+0x15c>
 113be98:	aa0103f4 	mov	x20, x1

   if ((err = mp_init_multi(&key->dp.prime, &key->dp.order, &key->dp.A, &key->dp.B,
 113be9c:	9103c020 	add	x0, x1, #0xf0
 113bea0:	a9017fe0 	stp	x0, xzr, [sp, #16]
 113bea4:	9103a280 	add	x0, x20, #0xe8
 113bea8:	9100c037 	add	x23, x1, #0x30
 113beac:	f90007e0 	str	x0, [sp, #8]
 113beb0:	91038280 	add	x0, x20, #0xe0
 113beb4:	f90003e0 	str	x0, [sp]
 113beb8:	91036027 	add	x7, x1, #0xd8
 113bebc:	91010026 	add	x6, x1, #0x40
 113bec0:	9100e025 	add	x5, x1, #0x38
 113bec4:	91008023 	add	x3, x1, #0x20
 113bec8:	91006022 	add	x2, x1, #0x18
 113becc:	aa1703e4 	mov	x4, x23
 113bed0:	9100a021 	add	x1, x1, #0x28
 113bed4:	91004280 	add	x0, x20, #0x10
 113bed8:	97ffd7f7 	bl	1131eb4 <ltc_init_multi>
 113bedc:	2a0003f3 	mov	w19, w0
 113bee0:	350005e0 	cbnz	w0, 113bf9c <ecc_copy_curve+0x128>
                            NULL)) != CRYPT_OK) {
      return err;
   }

   /* A, B, order, prime, Gx, Gy */
   if ((err = mp_copy(srckey->dp.prime,  key->dp.prime )) != CRYPT_OK) { goto error; }
 113bee4:	f00000f6 	adrp	x22, 115a000 <__scattered_array_1phys_mem_map+0x8>
 113bee8:	f9400a81 	ldr	x1, [x20, #16]
 113beec:	f941d6d6 	ldr	x22, [x22, #936]
 113bef0:	f9400aa0 	ldr	x0, [x21, #16]
 113bef4:	f9401ec2 	ldr	x2, [x22, #56]
 113bef8:	d63f0040 	blr	x2
 113befc:	2a0003f3 	mov	w19, w0
 113bf00:	35000620 	cbnz	w0, 113bfc4 <ecc_copy_curve+0x150>
   if ((err = mp_copy(srckey->dp.order,  key->dp.order )) != CRYPT_OK) { goto error; }
 113bf04:	f9401681 	ldr	x1, [x20, #40]
 113bf08:	f94016a0 	ldr	x0, [x21, #40]
 113bf0c:	f9401ec2 	ldr	x2, [x22, #56]
 113bf10:	d63f0040 	blr	x2
 113bf14:	2a0003f3 	mov	w19, w0
 113bf18:	35000560 	cbnz	w0, 113bfc4 <ecc_copy_curve+0x150>
   if ((err = mp_copy(srckey->dp.A,      key->dp.A     )) != CRYPT_OK) { goto error; }
 113bf1c:	f9400e81 	ldr	x1, [x20, #24]
 113bf20:	f9400ea0 	ldr	x0, [x21, #24]
 113bf24:	f9401ec2 	ldr	x2, [x22, #56]
 113bf28:	d63f0040 	blr	x2
 113bf2c:	2a0003f3 	mov	w19, w0
 113bf30:	350004a0 	cbnz	w0, 113bfc4 <ecc_copy_curve+0x150>
   if ((err = mp_copy(srckey->dp.B,      key->dp.B     )) != CRYPT_OK) { goto error; }
 113bf34:	f9401281 	ldr	x1, [x20, #32]
 113bf38:	f94012a0 	ldr	x0, [x21, #32]
 113bf3c:	f9401ec2 	ldr	x2, [x22, #56]
 113bf40:	d63f0040 	blr	x2
 113bf44:	2a0003f3 	mov	w19, w0
 113bf48:	350003e0 	cbnz	w0, 113bfc4 <ecc_copy_curve+0x150>
   if ((err = ltc_ecc_copy_point(&srckey->dp.base, &key->dp.base)) != CRYPT_OK) { goto error; }
 113bf4c:	aa1703e1 	mov	x1, x23
 113bf50:	9100c2a0 	add	x0, x21, #0x30
 113bf54:	97ffedfb 	bl	1137740 <ltc_ecc_copy_point>
 113bf58:	2a0003f3 	mov	w19, w0
 113bf5c:	35000340 	cbnz	w0, 113bfc4 <ecc_copy_curve+0x150>
   /* cofactor & size */
   key->dp.cofactor = srckey->dp.cofactor;
 113bf60:	f94026a0 	ldr	x0, [x21, #72]
   key->dp.size     = srckey->dp.size;
   /* OID */
   if (srckey->dp.oidlen > 0) {
 113bf64:	f9406aa2 	ldr	x2, [x21, #208]
   key->dp.cofactor = srckey->dp.cofactor;
 113bf68:	f9002680 	str	x0, [x20, #72]
   key->dp.size     = srckey->dp.size;
 113bf6c:	b9400aa0 	ldr	w0, [x21, #8]
 113bf70:	b9000a80 	str	w0, [x20, #8]
   if (srckey->dp.oidlen > 0) {
 113bf74:	b4000222 	cbz	x2, 113bfb8 <ecc_copy_curve+0x144>
     key->dp.oidlen = srckey->dp.oidlen;
     for (i = 0; i < key->dp.oidlen; i++) key->dp.oid[i] = srckey->dp.oid[i];
 113bf78:	910142b5 	add	x21, x21, #0x50
 113bf7c:	91014294 	add	x20, x20, #0x50
 113bf80:	d2800000 	mov	x0, #0x0                   	// #0
     key->dp.oidlen = srckey->dp.oidlen;
 113bf84:	f9004282 	str	x2, [x20, #128]
     for (i = 0; i < key->dp.oidlen; i++) key->dp.oid[i] = srckey->dp.oid[i];
 113bf88:	f8607aa1 	ldr	x1, [x21, x0, lsl #3]
 113bf8c:	f8207a81 	str	x1, [x20, x0, lsl #3]
 113bf90:	91000400 	add	x0, x0, #0x1
 113bf94:	eb00005f 	cmp	x2, x0
 113bf98:	54ffff81 	b.ne	113bf88 <ecc_copy_curve+0x114>  // b.any
   return CRYPT_OK;

error:
   ecc_free(key);
   return err;
}
 113bf9c:	2a1303e0 	mov	w0, w19
 113bfa0:	a9427bfd 	ldp	x29, x30, [sp, #32]
 113bfa4:	a94353f3 	ldp	x19, x20, [sp, #48]
 113bfa8:	a9445bf5 	ldp	x21, x22, [sp, #64]
 113bfac:	f9402bf7 	ldr	x23, [sp, #80]
 113bfb0:	910183ff 	add	sp, sp, #0x60
 113bfb4:	d65f03c0 	ret
     _ecc_oid_lookup(key); /* try to find OID in ltc_ecc_curves */
 113bfb8:	aa1403e0 	mov	x0, x20
 113bfbc:	97ffff62 	bl	113bd44 <_ecc_oid_lookup>
 113bfc0:	17fffff7 	b	113bf9c <ecc_copy_curve+0x128>
   ecc_free(key);
 113bfc4:	aa1403e0 	mov	x0, x20
 113bfc8:	97ffe53d 	bl	11354bc <ecc_free>
   return err;
 113bfcc:	17fffff4 	b	113bf9c <ecc_copy_curve+0x128>
   LTC_ARGCHK(key != NULL);
 113bfd0:	52800213 	mov	w19, #0x10                  	// #16
 113bfd4:	17fffff2 	b	113bf9c <ecc_copy_curve+0x128>

000000000113bfd8 <der_encode_bit_string>:
{
   unsigned long len, x, y;
   unsigned char buf;
   int           err;

   LTC_ARGCHK(in     != NULL);
 113bfd8:	b40008e0 	cbz	x0, 113c0f4 <der_encode_bit_string+0x11c>
{
 113bfdc:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 113bfe0:	910003fd 	mov	x29, sp
 113bfe4:	a90153f3 	stp	x19, x20, [sp, #16]
 113bfe8:	aa0203f4 	mov	x20, x2
 113bfec:	a9025bf5 	stp	x21, x22, [sp, #32]
 113bff0:	f9001bf7 	str	x23, [sp, #48]
   LTC_ARGCHK(out    != NULL);
 113bff4:	b4000842 	cbz	x2, 113c0fc <der_encode_bit_string+0x124>
 113bff8:	aa0303f3 	mov	x19, x3
   LTC_ARGCHK(outlen != NULL);
 113bffc:	b4000803 	cbz	x3, 113c0fc <der_encode_bit_string+0x124>
 113c000:	aa0103f6 	mov	x22, x1

   /* avoid overflows */
   if ((err = der_length_bit_string(inlen, &len)) != CRYPT_OK) {
 113c004:	910123f7 	add	x23, sp, #0x48
 113c008:	aa0003f5 	mov	x21, x0
 113c00c:	aa1703e1 	mov	x1, x23
 113c010:	aa1603e0 	mov	x0, x22
 113c014:	9400003c 	bl	113c104 <der_length_bit_string>
 113c018:	350000e0 	cbnz	w0, 113c034 <der_encode_bit_string+0x5c>
      return err;
   }

   if (len > *outlen) {
 113c01c:	f9400261 	ldr	x1, [x19]
 113c020:	f94027e0 	ldr	x0, [sp, #72]
 113c024:	eb00003f 	cmp	x1, x0
 113c028:	54000102 	b.cs	113c048 <der_encode_bit_string+0x70>  // b.hs, b.nlast
      *outlen = len;
 113c02c:	f9000260 	str	x0, [x19]
      return CRYPT_BUFFER_OVERFLOW;
 113c030:	528000c0 	mov	w0, #0x6                   	// #6
   if (inlen & 7) {
      out[x++] = buf;
   }
   *outlen = x;
   return CRYPT_OK;
}
 113c034:	a94153f3 	ldp	x19, x20, [sp, #16]
 113c038:	a9425bf5 	ldp	x21, x22, [sp, #32]
 113c03c:	f9401bf7 	ldr	x23, [sp, #48]
 113c040:	a8c57bfd 	ldp	x29, x30, [sp], #80
 113c044:	d65f03c0 	ret
   out[x++] = 0x03;
 113c048:	aa1403e1 	mov	x1, x20
 113c04c:	52800060 	mov	w0, #0x3                   	// #3
   if ((err = der_encode_asn1_length(y, out + x, &len)) != CRYPT_OK) {
 113c050:	aa1703e2 	mov	x2, x23
   out[x++] = 0x03;
 113c054:	38001420 	strb	w0, [x1], #1
   len = *outlen - x;
 113c058:	f9400260 	ldr	x0, [x19]
 113c05c:	d1000400 	sub	x0, x0, #0x1
 113c060:	f90027e0 	str	x0, [sp, #72]
   y = ((inlen + 7) >> 3) + 1;
 113c064:	91001ec0 	add	x0, x22, #0x7
 113c068:	d343fc00 	lsr	x0, x0, #3
   if ((err = der_encode_asn1_length(y, out + x, &len)) != CRYPT_OK) {
 113c06c:	91000400 	add	x0, x0, #0x1
 113c070:	94000484 	bl	113d280 <der_encode_asn1_length>
 113c074:	35fffe00 	cbnz	w0, 113c034 <der_encode_bit_string+0x5c>
   x += len;
 113c078:	f94027e1 	ldr	x1, [sp, #72]
   out[x++] = (unsigned char)((8 - inlen) & 7);
 113c07c:	4b1603e2 	neg	w2, w22
 113c080:	12000842 	and	w2, w2, #0x7
   for (y = buf = 0; y < inlen; y++) {
 113c084:	d2800004 	mov	x4, #0x0                   	// #0
   out[x++] = (unsigned char)((8 - inlen) & 7);
 113c088:	91000823 	add	x3, x1, #0x2
 113c08c:	8b010281 	add	x1, x20, x1
 113c090:	39000422 	strb	w2, [x1, #1]
   for (y = buf = 0; y < inlen; y++) {
 113c094:	52800002 	mov	w2, #0x0                   	// #0
 113c098:	eb16009f 	cmp	x4, x22
 113c09c:	92400886 	and	x6, x4, #0x7
 113c0a0:	540000c1 	b.ne	113c0b8 <der_encode_bit_string+0xe0>  // b.any
   if (inlen & 7) {
 113c0a4:	b4000066 	cbz	x6, 113c0b0 <der_encode_bit_string+0xd8>
      out[x++] = buf;
 113c0a8:	38236a82 	strb	w2, [x20, x3]
 113c0ac:	91000463 	add	x3, x3, #0x1
   *outlen = x;
 113c0b0:	f9000263 	str	x3, [x19]
   return CRYPT_OK;
 113c0b4:	17ffffe0 	b	113c034 <der_encode_bit_string+0x5c>
       buf |= (in[y] ? 1 : 0) << (7 - (y & 7));
 113c0b8:	38646aa1 	ldrb	w1, [x21, x4]
 113c0bc:	2a2403e5 	mvn	w5, w4
 113c0c0:	120008a5 	and	w5, w5, #0x7
 113c0c4:	7100003f 	cmp	w1, #0x0
 113c0c8:	1a9f07e1 	cset	w1, ne  // ne = any
       if ((y & 7) == 7) {
 113c0cc:	f1001cdf 	cmp	x6, #0x7
       buf |= (in[y] ? 1 : 0) << (7 - (y & 7));
 113c0d0:	1ac52021 	lsl	w1, w1, w5
 113c0d4:	2a020022 	orr	w2, w1, w2
 113c0d8:	12001c42 	and	w2, w2, #0xff
       if ((y & 7) == 7) {
 113c0dc:	54000081 	b.ne	113c0ec <der_encode_bit_string+0x114>  // b.any
          out[x++] = buf;
 113c0e0:	38236a82 	strb	w2, [x20, x3]
 113c0e4:	91000463 	add	x3, x3, #0x1
          buf      = 0;
 113c0e8:	52800002 	mov	w2, #0x0                   	// #0
   for (y = buf = 0; y < inlen; y++) {
 113c0ec:	91000484 	add	x4, x4, #0x1
 113c0f0:	17ffffea 	b	113c098 <der_encode_bit_string+0xc0>
   LTC_ARGCHK(in     != NULL);
 113c0f4:	52800200 	mov	w0, #0x10                  	// #16
}
 113c0f8:	d65f03c0 	ret
   LTC_ARGCHK(in     != NULL);
 113c0fc:	52800200 	mov	w0, #0x10                  	// #16
 113c100:	17ffffcd 	b	113c034 <der_encode_bit_string+0x5c>

000000000113c104 <der_length_bit_string>:
int der_length_bit_string(unsigned long nbits, unsigned long *outlen)
{
   unsigned long nbytes, x;
   int err;

   LTC_ARGCHK(outlen != NULL);
 113c104:	b4000281 	cbz	x1, 113c154 <der_length_bit_string+0x50>
{
 113c108:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!

   /* get the number of the bytes */
   nbytes = (nbits >> 3) + ((nbits & 7) ? 1 : 0) + 1;
 113c10c:	f240081f 	tst	x0, #0x7
{
 113c110:	910003fd 	mov	x29, sp
 113c114:	a90153f3 	stp	x19, x20, [sp, #16]
   nbytes = (nbits >> 3) + ((nbits & 7) ? 1 : 0) + 1;
 113c118:	d343fc13 	lsr	x19, x0, #3
 113c11c:	91000673 	add	x19, x19, #0x1
 113c120:	9a930673 	cinc	x19, x19, ne  // ne = any
 113c124:	aa0103f4 	mov	x20, x1

   if ((err = der_length_asn1_length(nbytes, &x)) != CRYPT_OK) {
 113c128:	aa1303e0 	mov	x0, x19
 113c12c:	9100a3e1 	add	x1, sp, #0x28
 113c130:	940004d4 	bl	113d480 <der_length_asn1_length>
 113c134:	350000a0 	cbnz	w0, 113c148 <der_length_bit_string+0x44>
      return err;
   }
   *outlen = 1 + x + nbytes;
 113c138:	f94017e2 	ldr	x2, [sp, #40]
 113c13c:	91000442 	add	x2, x2, #0x1
 113c140:	8b130053 	add	x19, x2, x19
 113c144:	f9000293 	str	x19, [x20]

   return CRYPT_OK;
}
 113c148:	a94153f3 	ldp	x19, x20, [sp, #16]
 113c14c:	a8c37bfd 	ldp	x29, x30, [sp], #48
 113c150:	d65f03c0 	ret
   LTC_ARGCHK(outlen != NULL);
 113c154:	52800200 	mov	w0, #0x10                  	// #16
}
 113c158:	d65f03c0 	ret

000000000113c15c <der_encode_raw_bit_string>:
{
   unsigned long len, x, y;
   unsigned char buf;
   int           err;

   LTC_ARGCHK(in     != NULL);
 113c15c:	b4000980 	cbz	x0, 113c28c <der_encode_raw_bit_string+0x130>
{
 113c160:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 113c164:	910003fd 	mov	x29, sp
 113c168:	a90153f3 	stp	x19, x20, [sp, #16]
 113c16c:	aa0203f4 	mov	x20, x2
 113c170:	a9025bf5 	stp	x21, x22, [sp, #32]
 113c174:	f9001bf7 	str	x23, [sp, #48]
   LTC_ARGCHK(out    != NULL);
 113c178:	b40008e2 	cbz	x2, 113c294 <der_encode_raw_bit_string+0x138>
 113c17c:	aa0303f3 	mov	x19, x3
   LTC_ARGCHK(outlen != NULL);
 113c180:	b40008a3 	cbz	x3, 113c294 <der_encode_raw_bit_string+0x138>
 113c184:	aa0103f6 	mov	x22, x1

   /* avoid overflows */
   if ((err = der_length_bit_string(inlen, &len)) != CRYPT_OK) {
 113c188:	910123f7 	add	x23, sp, #0x48
 113c18c:	aa0003f5 	mov	x21, x0
 113c190:	aa1703e1 	mov	x1, x23
 113c194:	aa1603e0 	mov	x0, x22
 113c198:	97ffffdb 	bl	113c104 <der_length_bit_string>
 113c19c:	350000e0 	cbnz	w0, 113c1b8 <der_encode_raw_bit_string+0x5c>
      return err;
   }

   if (len > *outlen) {
 113c1a0:	f9400261 	ldr	x1, [x19]
 113c1a4:	f94027e0 	ldr	x0, [sp, #72]
 113c1a8:	eb00003f 	cmp	x1, x0
 113c1ac:	54000102 	b.cs	113c1cc <der_encode_raw_bit_string+0x70>  // b.hs, b.nlast
      *outlen = len;
 113c1b0:	f9000260 	str	x0, [x19]
      return CRYPT_BUFFER_OVERFLOW;
 113c1b4:	528000c0 	mov	w0, #0x6                   	// #6
      out[x++] = buf;
   }

   *outlen = x;
   return CRYPT_OK;
}
 113c1b8:	a94153f3 	ldp	x19, x20, [sp, #16]
 113c1bc:	a9425bf5 	ldp	x21, x22, [sp, #32]
 113c1c0:	f9401bf7 	ldr	x23, [sp, #48]
 113c1c4:	a8c57bfd 	ldp	x29, x30, [sp], #80
 113c1c8:	d65f03c0 	ret
   out[x++] = 0x03;
 113c1cc:	aa1403e1 	mov	x1, x20
 113c1d0:	52800060 	mov	w0, #0x3                   	// #3
   if ((err = der_encode_asn1_length(y, out + x, &len)) != CRYPT_OK) {
 113c1d4:	aa1703e2 	mov	x2, x23
   out[x++] = 0x03;
 113c1d8:	38001420 	strb	w0, [x1], #1
   len = *outlen - x;
 113c1dc:	f9400260 	ldr	x0, [x19]
 113c1e0:	d1000400 	sub	x0, x0, #0x1
 113c1e4:	f90027e0 	str	x0, [sp, #72]
   y = ((inlen + 7) >> 3) + 1;
 113c1e8:	91001ec0 	add	x0, x22, #0x7
 113c1ec:	d343fc00 	lsr	x0, x0, #3
   if ((err = der_encode_asn1_length(y, out + x, &len)) != CRYPT_OK) {
 113c1f0:	91000400 	add	x0, x0, #0x1
 113c1f4:	94000423 	bl	113d280 <der_encode_asn1_length>
 113c1f8:	35fffe00 	cbnz	w0, 113c1b8 <der_encode_raw_bit_string+0x5c>
   x += len;
 113c1fc:	f94027e1 	ldr	x1, [sp, #72]
   out[x++] = (unsigned char)((8 - inlen) & 7);
 113c200:	4b1603e2 	neg	w2, w22
 113c204:	12000842 	and	w2, w2, #0x7
   for (y = buf = 0; y < inlen; y++) {
 113c208:	d2800004 	mov	x4, #0x0                   	// #0
   out[x++] = (unsigned char)((8 - inlen) & 7);
 113c20c:	91000823 	add	x3, x1, #0x2
 113c210:	8b010281 	add	x1, x20, x1
      buf |= (getbit(in[y/8],7-y%8)?1:0) << (7 - (y & 7));
 113c214:	52800027 	mov	w7, #0x1                   	// #1
   out[x++] = (unsigned char)((8 - inlen) & 7);
 113c218:	39000422 	strb	w2, [x1, #1]
   for (y = buf = 0; y < inlen; y++) {
 113c21c:	52800002 	mov	w2, #0x0                   	// #0
 113c220:	eb16009f 	cmp	x4, x22
 113c224:	92400886 	and	x6, x4, #0x7
 113c228:	540000c1 	b.ne	113c240 <der_encode_raw_bit_string+0xe4>  // b.any
   if (inlen & 7) {
 113c22c:	b4000066 	cbz	x6, 113c238 <der_encode_raw_bit_string+0xdc>
      out[x++] = buf;
 113c230:	38236a82 	strb	w2, [x20, x3]
 113c234:	91000463 	add	x3, x3, #0x1
   *outlen = x;
 113c238:	f9000263 	str	x3, [x19]
   return CRYPT_OK;
 113c23c:	17ffffdf 	b	113c1b8 <der_encode_raw_bit_string+0x5c>
      buf |= (getbit(in[y/8],7-y%8)?1:0) << (7 - (y & 7));
 113c240:	d343fc85 	lsr	x5, x4, #3
 113c244:	2a2403e1 	mvn	w1, w4
 113c248:	12000821 	and	w1, w1, #0x7
 113c24c:	38656aa5 	ldrb	w5, [x21, x5]
 113c250:	1ac120e8 	lsl	w8, w7, w1
 113c254:	0a0800a5 	and	w5, w5, w8
 113c258:	1ac128a5 	asr	w5, w5, w1
 113c25c:	710000bf 	cmp	w5, #0x0
 113c260:	1a9f07e5 	cset	w5, ne  // ne = any
      if ((y & 7) == 7) {
 113c264:	f1001cdf 	cmp	x6, #0x7
      buf |= (getbit(in[y/8],7-y%8)?1:0) << (7 - (y & 7));
 113c268:	1ac120a1 	lsl	w1, w5, w1
 113c26c:	2a020022 	orr	w2, w1, w2
 113c270:	12001c42 	and	w2, w2, #0xff
      if ((y & 7) == 7) {
 113c274:	54000081 	b.ne	113c284 <der_encode_raw_bit_string+0x128>  // b.any
         out[x++] = buf;
 113c278:	38236a82 	strb	w2, [x20, x3]
 113c27c:	91000463 	add	x3, x3, #0x1
         buf      = 0;
 113c280:	52800002 	mov	w2, #0x0                   	// #0
   for (y = buf = 0; y < inlen; y++) {
 113c284:	91000484 	add	x4, x4, #0x1
 113c288:	17ffffe6 	b	113c220 <der_encode_raw_bit_string+0xc4>
   LTC_ARGCHK(in     != NULL);
 113c28c:	52800200 	mov	w0, #0x10                  	// #16
}
 113c290:	d65f03c0 	ret
   LTC_ARGCHK(in     != NULL);
 113c294:	52800200 	mov	w0, #0x10                  	// #16
 113c298:	17ffffc8 	b	113c1b8 <der_encode_raw_bit_string+0x5c>

000000000113c29c <der_encode_boolean>:
  @return CRYPT_OK if successful
*/
int der_encode_boolean(int in,
                       unsigned char *out, unsigned long *outlen)
{
   LTC_ARGCHK(outlen != NULL);
 113c29c:	b4000222 	cbz	x2, 113c2e0 <der_encode_boolean+0x44>
   LTC_ARGCHK(out    != NULL);
 113c2a0:	b4000201 	cbz	x1, 113c2e0 <der_encode_boolean+0x44>

   if (*outlen < 3) {
 113c2a4:	f9400043 	ldr	x3, [x2]
 113c2a8:	f100087f 	cmp	x3, #0x2
 113c2ac:	d2800063 	mov	x3, #0x3                   	// #3
       *outlen = 3;
 113c2b0:	f9000043 	str	x3, [x2]
   if (*outlen < 3) {
 113c2b4:	54000068 	b.hi	113c2c0 <der_encode_boolean+0x24>  // b.pmore
       return CRYPT_BUFFER_OVERFLOW;
 113c2b8:	528000c0 	mov	w0, #0x6                   	// #6
   out[0] = 0x01;
   out[1] = 0x01;
   out[2] = in ? 0xFF : 0x00;

   return CRYPT_OK;
}
 113c2bc:	d65f03c0 	ret
   out[2] = in ? 0xFF : 0x00;
 113c2c0:	7100001f 	cmp	w0, #0x0
   out[0] = 0x01;
 113c2c4:	52800022 	mov	w2, #0x1                   	// #1
   out[2] = in ? 0xFF : 0x00;
 113c2c8:	5a9f03e0 	csetm	w0, ne  // ne = any
   out[0] = 0x01;
 113c2cc:	39000022 	strb	w2, [x1]
   out[1] = 0x01;
 113c2d0:	39000422 	strb	w2, [x1, #1]
   out[2] = in ? 0xFF : 0x00;
 113c2d4:	39000820 	strb	w0, [x1, #2]
   return CRYPT_OK;
 113c2d8:	52800000 	mov	w0, #0x0                   	// #0
 113c2dc:	17fffff8 	b	113c2bc <der_encode_boolean+0x20>
   LTC_ARGCHK(outlen != NULL);
 113c2e0:	52800200 	mov	w0, #0x10                  	// #16
 113c2e4:	17fffff6 	b	113c2bc <der_encode_boolean+0x20>

000000000113c2e8 <der_length_boolean>:
  @param outlen [out] The length of the DER encoding
  @return CRYPT_OK if successful
*/
int der_length_boolean(unsigned long *outlen)
{
   LTC_ARGCHK(outlen != NULL);
 113c2e8:	b40000a0 	cbz	x0, 113c2fc <der_length_boolean+0x14>
   *outlen = 3;
 113c2ec:	d2800061 	mov	x1, #0x3                   	// #3
 113c2f0:	f9000001 	str	x1, [x0]
   return CRYPT_OK;
 113c2f4:	52800000 	mov	w0, #0x0                   	// #0
}
 113c2f8:	d65f03c0 	ret
   LTC_ARGCHK(outlen != NULL);
 113c2fc:	52800200 	mov	w0, #0x10                  	// #16
 113c300:	17fffffe 	b	113c2f8 <der_length_boolean+0x10>

000000000113c304 <der_decode_custom_type_ex>:
*/
int der_decode_custom_type_ex(const unsigned char *in,   unsigned long  inlen,
                                    ltc_asn1_list *root,
                                    ltc_asn1_list *list, unsigned long  outlen,
                                    unsigned int   flags)
{
 113c304:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
 113c308:	910003fd 	mov	x29, sp
 113c30c:	a90153f3 	stp	x19, x20, [sp, #16]
 113c310:	a9025bf5 	stp	x21, x22, [sp, #32]
 113c314:	a90363f7 	stp	x23, x24, [sp, #48]
 113c318:	a9046bf9 	stp	x25, x26, [sp, #64]
 113c31c:	a90573fb 	stp	x27, x28, [sp, #80]
 113c320:	f9003be3 	str	x3, [sp, #112]
 113c324:	b9007be5 	str	w5, [sp, #120]
   ltc_asn1_list ident;
   unsigned long size, x, y, z, blksize;
   unsigned char* in_new = NULL;
   void          *data;

   LTC_ARGCHK(in   != NULL);
 113c328:	b4003620 	cbz	x0, 113c9ec <der_decode_custom_type_ex+0x6e8>
 113c32c:	aa0103f3 	mov	x19, x1

   /* get blk size */
   if (inlen < 2) {
 113c330:	f100043f 	cmp	x1, #0x1
 113c334:	54003609 	b.ls	113c9f4 <der_decode_custom_type_ex+0x6f0>  // b.plast
 113c338:	aa0003f6 	mov	x22, x0
 113c33c:	aa0203f9 	mov	x25, x2
      return CRYPT_INVALID_PACKET;
   }
   x = 0;

   if (root == NULL) {
 113c340:	b50002a2 	cbnz	x2, 113c394 <der_decode_custom_type_ex+0x90>
      LTC_ARGCHK(list != NULL);
 113c344:	b4003543 	cbz	x3, 113c9ec <der_decode_custom_type_ex+0x6e8>

      /* sequence type? We allow 0x30 SEQUENCE and 0x31 SET since fundamentally they're the same structure */
      if (in[x] != 0x30 && in[x] != 0x31) {
 113c348:	394002c0 	ldrb	w0, [x22]
 113c34c:	5100c000 	sub	w0, w0, #0x30
 113c350:	12001c00 	and	w0, w0, #0xff
 113c354:	7100041f 	cmp	w0, #0x1
 113c358:	540034e8 	b.hi	113c9f4 <der_decode_custom_type_ex+0x6f0>  // b.pmore
 113c35c:	aa0403f5 	mov	x21, x4
   unsigned char* in_new = NULL;
 113c360:	d280001a 	mov	x26, #0x0                   	// #0
         return CRYPT_INVALID_PACKET;
      }
      ++x;
 113c364:	d2800034 	mov	x20, #0x1                   	// #1
      x -= 1;
      in_new[x] = (unsigned char)der_asn1_type_to_identifier_map[list[0].type];
      blksize = inlen - x;
   } else {

      y = inlen - x;
 113c368:	cb140260 	sub	x0, x19, x20
      if ((err = der_decode_asn1_length(&in[x], &y, &blksize)) != CRYPT_OK) {
 113c36c:	9102a3e2 	add	x2, sp, #0xa8
 113c370:	910263e1 	add	x1, sp, #0x98
      y = inlen - x;
 113c374:	f9004fe0 	str	x0, [sp, #152]
      if ((err = der_decode_asn1_length(&in[x], &y, &blksize)) != CRYPT_OK) {
 113c378:	8b1402c0 	add	x0, x22, x20
 113c37c:	94000301 	bl	113cf80 <der_decode_asn1_length>
 113c380:	2a0003e2 	mov	w2, w0
 113c384:	350013a0 	cbnz	w0, 113c5f8 <der_decode_custom_type_ex+0x2f4>
         goto LBL_ERR;
      }
      x += y;
 113c388:	f9404fe0 	ldr	x0, [sp, #152]
 113c38c:	8b000294 	add	x20, x20, x0
 113c390:	1400003c 	b	113c480 <der_decode_custom_type_ex+0x17c>
      if (root->type != LTC_ASN1_CUSTOM_TYPE) {
 113c394:	b9400040 	ldr	w0, [x2]
 113c398:	71004c1f 	cmp	w0, #0x13
 113c39c:	540032c1 	b.ne	113c9f4 <der_decode_custom_type_ex+0x6f0>  // b.any
      if (root->pc == LTC_ASN1_PC_PRIMITIVE) {
 113c3a0:	b9402440 	ldr	w0, [x2, #36]
 113c3a4:	35000440 	cbnz	w0, 113c42c <der_decode_custom_type_ex+0x128>
         in_new = XMALLOC(inlen);
 113c3a8:	aa0103e0 	mov	x0, x1
 113c3ac:	94001c2b 	bl	1143458 <malloc>
 113c3b0:	aa0003fa 	mov	x26, x0
         if (in_new == NULL) {
 113c3b4:	b4003240 	cbz	x0, 113c9fc <der_decode_custom_type_ex+0x6f8>
         XMEMCPY(in_new, in, inlen);
 113c3b8:	aa1603e1 	mov	x1, x22
 113c3bc:	aa1a03f6 	mov	x22, x26
 113c3c0:	aa1303e2 	mov	x2, x19
 113c3c4:	97ff1bf3 	bl	1103390 <memcpy>
      if ((err = der_decode_asn1_identifier(in, &y, &ident)) != CRYPT_OK) {
 113c3c8:	9102c3e2 	add	x2, sp, #0xb0
 113c3cc:	910263e1 	add	x1, sp, #0x98
 113c3d0:	aa1603e0 	mov	x0, x22
      y = inlen;
 113c3d4:	f9004ff3 	str	x19, [sp, #152]
      if ((err = der_decode_asn1_identifier(in, &y, &ident)) != CRYPT_OK) {
 113c3d8:	94000315 	bl	113d02c <der_decode_asn1_identifier>
 113c3dc:	2a0003e2 	mov	w2, w0
 113c3e0:	350010c0 	cbnz	w0, 113c5f8 <der_decode_custom_type_ex+0x2f4>
      if ((ident.type != root->type) ||
 113c3e4:	b9400320 	ldr	w0, [x25]
 113c3e8:	b940b3e1 	ldr	w1, [sp, #176]
 113c3ec:	6b00003f 	cmp	w1, w0
 113c3f0:	54001a21 	b.ne	113c734 <der_decode_custom_type_ex+0x430>  // b.any
            (ident.klass != root->klass) ||
 113c3f4:	f9401320 	ldr	x0, [x25, #32]
 113c3f8:	f9406be1 	ldr	x1, [sp, #208]
 113c3fc:	eb00003f 	cmp	x1, x0
 113c400:	540019a1 	b.ne	113c734 <der_decode_custom_type_ex+0x430>  // b.any
            (ident.pc != root->pc) ||
 113c404:	f9401720 	ldr	x0, [x25, #40]
 113c408:	f9406fe1 	ldr	x1, [sp, #216]
 113c40c:	eb00003f 	cmp	x1, x0
 113c410:	54001921 	b.ne	113c734 <der_decode_custom_type_ex+0x430>  // b.any
   if (root != NULL && root->pc == LTC_ASN1_PC_PRIMITIVE) {
 113c414:	b9402720 	ldr	w0, [x25, #36]
      x += y;
 113c418:	f9404ff4 	ldr	x20, [sp, #152]
   if (root != NULL && root->pc == LTC_ASN1_PC_PRIMITIVE) {
 113c41c:	340000c0 	cbz	w0, 113c434 <der_decode_custom_type_ex+0x130>
      outlen = root->size;
 113c420:	a940d720 	ldp	x0, x21, [x25, #8]
      list = root->data;
 113c424:	f9003be0 	str	x0, [sp, #112]
 113c428:	17ffffd0 	b	113c368 <der_decode_custom_type_ex+0x64>
   unsigned char* in_new = NULL;
 113c42c:	d280001a 	mov	x26, #0x0                   	// #0
 113c430:	17ffffe6 	b	113c3c8 <der_decode_custom_type_ex+0xc4>
      if (((unsigned long)root->used >= der_asn1_type_to_identifier_map_sz) ||
 113c434:	d00000e0 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 113c438:	b9401b21 	ldr	w1, [x25, #24]
 113c43c:	f9424403 	ldr	x3, [x0, #1160]
 113c440:	93407c22 	sxtw	x2, w1
 113c444:	f9400063 	ldr	x3, [x3]
 113c448:	eb21c07f 	cmp	x3, w1, sxtw
 113c44c:	54001749 	b.ls	113c734 <der_decode_custom_type_ex+0x430>  // b.plast
            (der_asn1_type_to_identifier_map[root->used] == -1)) {
 113c450:	f9415400 	ldr	x0, [x0, #680]
      if (((unsigned long)root->used >= der_asn1_type_to_identifier_map_sz) ||
 113c454:	b8627802 	ldr	w2, [x0, x2, lsl #2]
 113c458:	3100045f 	cmn	w2, #0x1
 113c45c:	540016c0 	b.eq	113c734 <der_decode_custom_type_ex+0x430>  // b.none
      x -= 1;
 113c460:	d1000694 	sub	x20, x20, #0x1
      in_new[x] = (unsigned char)der_asn1_type_to_identifier_map[list[0].type];
 113c464:	b8615800 	ldr	w0, [x0, w1, uxtw #2]
      outlen = 1;
 113c468:	d2800035 	mov	x21, #0x1                   	// #1
      root->type = (ltc_asn1_type)root->used;
 113c46c:	b9000321 	str	w1, [x25]
      blksize = inlen - x;
 113c470:	f9003bf9 	str	x25, [sp, #112]
      in_new[x] = (unsigned char)der_asn1_type_to_identifier_map[list[0].type];
 113c474:	38346b40 	strb	w0, [x26, x20]
      blksize = inlen - x;
 113c478:	cb140260 	sub	x0, x19, x20
 113c47c:	f90057e0 	str	x0, [sp, #168]
   }

   /* would this blksize overflow? */
   if (blksize > (inlen - x)) {
 113c480:	f94057e0 	ldr	x0, [sp, #168]
 113c484:	cb140273 	sub	x19, x19, x20
 113c488:	eb00027f 	cmp	x19, x0
 113c48c:	54001543 	b.cc	113c734 <der_decode_custom_type_ex+0x430>  // b.lo, b.ul, b.last
      goto LBL_ERR;
   }

   /* mark all as unused */
   for (i = 0; i < (int)outlen; i++) {
       list[i].used = 0;
 113c490:	f9403be2 	ldr	x2, [sp, #112]
 113c494:	d2800001 	mov	x1, #0x0                   	// #0
 113c498:	d2800a03 	mov	x3, #0x50                  	// #80
 113c49c:	91006042 	add	x2, x2, #0x18
   for (i = 0; i < (int)outlen; i++) {
 113c4a0:	b90087f5 	str	w21, [sp, #132]
 113c4a4:	6b0102bf 	cmp	w21, w1
 113c4a8:	5400062c 	b.gt	113c56c <der_decode_custom_type_ex+0x268>
   }
   ordered = flags & LTC_DER_SEQ_ORDERED;
 113c4ac:	b9407be1 	ldr	w1, [sp, #120]

   /* ok read data */
   seq_err  = CRYPT_OK;
   blksize += x;
 113c4b0:	8b140000 	add	x0, x0, x20
               }
               break;

           case LTC_ASN1_CHOICE:
               z = inlen;
               if ((err = der_decode_choice(in + x, &z, data, size)) != CRYPT_OK) {
 113c4b4:	910283f8 	add	x24, sp, #0xa0
               if ((err = der_decode_utf8_string(in + x, z, data, &size)) != CRYPT_OK) {
 113c4b8:	910243fb 	add	x27, sp, #0x90
   ordered = flags & LTC_DER_SEQ_ORDERED;
 113c4bc:	12000037 	and	w23, w1, #0x1
   for (i = 0; i < (int)outlen; i++) {
 113c4c0:	b9006fff 	str	wzr, [sp, #108]
   seq_err  = CRYPT_OK;
 113c4c4:	b90083ff 	str	wzr, [sp, #128]
   blksize += x;
 113c4c8:	f90057e0 	str	x0, [sp, #168]
   for (i = 0; i < (int)outlen; i++) {
 113c4cc:	900000a0 	adrp	x0, 1150000 <Te4+0x258>
 113c4d0:	911f5000 	add	x0, x0, #0x7d4
 113c4d4:	f90047e0 	str	x0, [sp, #136]
 113c4d8:	b9406fe1 	ldr	w1, [sp, #108]
 113c4dc:	b94087e0 	ldr	w0, [sp, #132]
 113c4e0:	6b01001f 	cmp	w0, w1
 113c4e4:	540001ed 	b.le	113c520 <der_decode_custom_type_ex+0x21c>
       type = list[i].type;
 113c4e8:	b9406fe0 	ldr	w0, [sp, #108]
 113c4ec:	52800a01 	mov	w1, #0x50                  	// #80
 113c4f0:	9b217c00 	smull	x0, w0, w1
 113c4f4:	f9403be1 	ldr	x1, [sp, #112]
 113c4f8:	8b000035 	add	x21, x1, x0
 113c4fc:	b8606821 	ldr	w1, [x1, x0]
       z    = 0;
 113c500:	f90053ff 	str	xzr, [sp, #160]
       size = list[i].size;
 113c504:	a9408ebc 	ldp	x28, x3, [x21, #8]
 113c508:	f9004be3 	str	x3, [sp, #144]
       if (!ordered && list[i].used == 1) { continue; }
 113c50c:	35000097 	cbnz	w23, 113c51c <der_decode_custom_type_ex+0x218>
 113c510:	b9401aa0 	ldr	w0, [x21, #24]
 113c514:	7100041f 	cmp	w0, #0x1
 113c518:	54000600 	b.eq	113c5d8 <der_decode_custom_type_ex+0x2d4>  // b.none
       if (type == LTC_ASN1_EOL) {
 113c51c:	35000301 	cbnz	w1, 113c57c <der_decode_custom_type_ex+0x278>
          /* restart the decoder */
          i = -1;
       }
   }

   for (i = 0; i < (int)outlen; i++) {
 113c520:	d2800000 	mov	x0, #0x0                   	// #0
      if (list[i].used == 0 && list[i].optional == 0) {
 113c524:	d2800a01 	mov	x1, #0x50                  	// #80
   for (i = 0; i < (int)outlen; i++) {
 113c528:	b94087e2 	ldr	w2, [sp, #132]
 113c52c:	6b00005f 	cmp	w2, w0
 113c530:	540023ac 	b.gt	113c9a4 <der_decode_custom_type_ex+0x6a0>
          err = CRYPT_INVALID_PACKET;
          goto LBL_ERR;
      }
   }

   if (blksize == x && seq_err == CRYPT_OK && inlen == 0) {
 113c534:	f94057e0 	ldr	x0, [sp, #168]
 113c538:	eb14001f 	cmp	x0, x20
 113c53c:	54002401 	b.ne	113c9bc <der_decode_custom_type_ex+0x6b8>  // b.any
 113c540:	b94083e1 	ldr	w1, [sp, #128]
 113c544:	f100027f 	cmp	x19, #0x0
 113c548:	1a9f17e0 	cset	w0, eq  // eq = none
 113c54c:	7100003f 	cmp	w1, #0x0
 113c550:	7a400804 	ccmp	w0, #0x0, #0x4, eq  // eq = none
 113c554:	54002481 	b.ne	113c9e4 <der_decode_custom_type_ex+0x6e0>  // b.any
      /* everything decoded and no errors in nested sequences */
      err = CRYPT_OK;
   } else if (blksize == x && seq_err == CRYPT_INPUT_TOO_LONG && inlen == 0) {
 113c558:	7100001f 	cmp	w0, #0x0
      /* a sequence reported too-long input, but now we've decoded everything */
      err = CRYPT_OK;
   } else if (blksize != x && ((flags & LTC_DER_SEQ_STRICT) == LTC_DER_SEQ_STRICT)) {
      err = CRYPT_INVALID_PACKET;
   } else {
      err = CRYPT_INPUT_TOO_LONG;
 113c55c:	528002a0 	mov	w0, #0x15                  	// #21
 113c560:	7a551820 	ccmp	w1, #0x15, #0x0, ne  // ne = any
 113c564:	1a8003e2 	csel	w2, wzr, w0, eq  // eq = none
 113c568:	14000024 	b	113c5f8 <der_decode_custom_type_ex+0x2f4>
       list[i].used = 0;
 113c56c:	9b037c24 	mul	x4, x1, x3
 113c570:	91000421 	add	x1, x1, #0x1
 113c574:	b824685f 	str	wzr, [x2, x4]
   for (i = 0; i < (int)outlen; i++) {
 113c578:	17ffffca 	b	113c4a0 <der_decode_custom_type_ex+0x19c>
       if (root != NULL && root->pc == LTC_ASN1_PC_PRIMITIVE && i != 0) {
 113c57c:	b40000b9 	cbz	x25, 113c590 <der_decode_custom_type_ex+0x28c>
 113c580:	b9402720 	ldr	w0, [x25, #36]
 113c584:	35000060 	cbnz	w0, 113c590 <der_decode_custom_type_ex+0x28c>
 113c588:	b9406fe0 	ldr	w0, [sp, #108]
 113c58c:	35002240 	cbnz	w0, 113c9d4 <der_decode_custom_type_ex+0x6d0>
       switch (type) {
 113c590:	51000420 	sub	w0, w1, #0x1
 113c594:	7100481f 	cmp	w0, #0x12
 113c598:	54002228 	b.hi	113c9dc <der_decode_custom_type_ex+0x6d8>  // b.pmore
 113c59c:	f94047e2 	ldr	x2, [sp, #136]
 113c5a0:	78605840 	ldrh	w0, [x2, w0, uxtw #1]
 113c5a4:	10000062 	adr	x2, 113c5b0 <der_decode_custom_type_ex+0x2ac>
 113c5a8:	8b20a840 	add	x0, x2, w0, sxth #2
 113c5ac:	d61f0000 	br	x0
               if ((err = der_decode_boolean(in + x, z, ((int *)data))) != CRYPT_OK) {
 113c5b0:	aa1c03e2 	mov	x2, x28
 113c5b4:	aa1303e1 	mov	x1, x19
 113c5b8:	8b1402c0 	add	x0, x22, x20
               z = inlen;
 113c5bc:	f90053f3 	str	x19, [sp, #160]
               if ((err = der_decode_boolean(in + x, z, ((int *)data))) != CRYPT_OK) {
 113c5c0:	94000c1a 	bl	113f628 <der_decode_boolean>
 113c5c4:	2a0003e2 	mov	w2, w0
 113c5c8:	34000100 	cbz	w0, 113c5e8 <der_decode_custom_type_ex+0x2e4>
                  if (!ordered || list[i].optional) { continue; }
 113c5cc:	34000077 	cbz	w23, 113c5d8 <der_decode_custom_type_ex+0x2d4>
 113c5d0:	b9401ea0 	ldr	w0, [x21, #28]
 113c5d4:	34000120 	cbz	w0, 113c5f8 <der_decode_custom_type_ex+0x2f4>
   for (i = 0; i < (int)outlen; i++) {
 113c5d8:	b9406fe0 	ldr	w0, [sp, #108]
 113c5dc:	11000400 	add	w0, w0, #0x1
 113c5e0:	b9006fe0 	str	w0, [sp, #108]
 113c5e4:	17ffffbd 	b	113c4d8 <der_decode_custom_type_ex+0x1d4>
               if ((err = der_length_boolean(&z)) != CRYPT_OK) {
 113c5e8:	aa1803e0 	mov	x0, x24
 113c5ec:	97ffff3f 	bl	113c2e8 <der_length_boolean>
               if ((err = der_length_custom_type(&list[i], &z, NULL)) != CRYPT_OK) {
 113c5f0:	2a0003e2 	mov	w2, w0
 113c5f4:	34000a80 	cbz	w0, 113c744 <der_decode_custom_type_ex+0x440>
   }

LBL_ERR:
   if (in_new != NULL) {
 113c5f8:	b40000ba 	cbz	x26, 113c60c <der_decode_custom_type_ex+0x308>
      XFREE(in_new);
 113c5fc:	aa1a03e0 	mov	x0, x26
 113c600:	b9006fe2 	str	w2, [sp, #108]
 113c604:	94001bf7 	bl	11435e0 <free>
 113c608:	b9406fe2 	ldr	w2, [sp, #108]
   }
   return err;
}
 113c60c:	2a0203e0 	mov	w0, w2
 113c610:	a94153f3 	ldp	x19, x20, [sp, #16]
 113c614:	a9425bf5 	ldp	x21, x22, [sp, #32]
 113c618:	a94363f7 	ldp	x23, x24, [sp, #48]
 113c61c:	a9446bf9 	ldp	x25, x26, [sp, #64]
 113c620:	a94573fb 	ldp	x27, x28, [sp, #80]
 113c624:	a8d07bfd 	ldp	x29, x30, [sp], #256
 113c628:	d65f03c0 	ret
               if ((err = der_decode_integer(in + x, z, data)) != CRYPT_OK) {
 113c62c:	aa1c03e2 	mov	x2, x28
 113c630:	aa1303e1 	mov	x1, x19
 113c634:	8b1402c0 	add	x0, x22, x20
               z = inlen;
 113c638:	f90053f3 	str	x19, [sp, #160]
               if ((err = der_decode_integer(in + x, z, data)) != CRYPT_OK) {
 113c63c:	94000614 	bl	113de8c <der_decode_integer>
 113c640:	2a0003e2 	mov	w2, w0
 113c644:	35fffc40 	cbnz	w0, 113c5cc <der_decode_custom_type_ex+0x2c8>
               if ((err = der_length_integer(data, &z)) != CRYPT_OK) {
 113c648:	aa1803e1 	mov	x1, x24
 113c64c:	aa1c03e0 	mov	x0, x28
 113c650:	9400070c 	bl	113e280 <der_length_integer>
 113c654:	17ffffe7 	b	113c5f0 <der_decode_custom_type_ex+0x2ec>
               if ((err = der_decode_short_integer(in + x, z, data)) != CRYPT_OK) {
 113c658:	aa1c03e2 	mov	x2, x28
 113c65c:	aa1303e1 	mov	x1, x19
 113c660:	8b1402c0 	add	x0, x22, x20
               z = inlen;
 113c664:	f90053f3 	str	x19, [sp, #160]
               if ((err = der_decode_short_integer(in + x, z, data)) != CRYPT_OK) {
 113c668:	940009a0 	bl	113ece8 <der_decode_short_integer>
 113c66c:	2a0003e2 	mov	w2, w0
 113c670:	35fffae0 	cbnz	w0, 113c5cc <der_decode_custom_type_ex+0x2c8>
               if ((err = der_length_short_integer(((unsigned long*)data)[0], &z)) != CRYPT_OK) {
 113c674:	f9400380 	ldr	x0, [x28]
 113c678:	aa1803e1 	mov	x1, x24
 113c67c:	97fff705 	bl	113a290 <der_length_short_integer>
 113c680:	17ffffdc 	b	113c5f0 <der_decode_custom_type_ex+0x2ec>
               if ((err = der_decode_bit_string(in + x, z, data, &size)) != CRYPT_OK) {
 113c684:	aa1b03e3 	mov	x3, x27
 113c688:	aa1c03e2 	mov	x2, x28
 113c68c:	aa1303e1 	mov	x1, x19
 113c690:	8b1402c0 	add	x0, x22, x20
               z = inlen;
 113c694:	f90053f3 	str	x19, [sp, #160]
               if ((err = der_decode_bit_string(in + x, z, data, &size)) != CRYPT_OK) {
 113c698:	94000b54 	bl	113f3e8 <der_decode_bit_string>
               if ((err = der_decode_raw_bit_string(in + x, z, data, &size)) != CRYPT_OK) {
 113c69c:	2a0003e2 	mov	w2, w0
 113c6a0:	35fff960 	cbnz	w0, 113c5cc <der_decode_custom_type_ex+0x2c8>
               list[i].size = size;
 113c6a4:	f9404be0 	ldr	x0, [sp, #144]
 113c6a8:	f9000aa0 	str	x0, [x21, #16]
               if ((err = der_length_bit_string(size, &z)) != CRYPT_OK) {
 113c6ac:	aa1803e1 	mov	x1, x24
 113c6b0:	97fffe95 	bl	113c104 <der_length_bit_string>
 113c6b4:	17ffffcf 	b	113c5f0 <der_decode_custom_type_ex+0x2ec>
               if ((err = der_decode_raw_bit_string(in + x, z, data, &size)) != CRYPT_OK) {
 113c6b8:	aa1b03e3 	mov	x3, x27
 113c6bc:	aa1c03e2 	mov	x2, x28
 113c6c0:	aa1303e1 	mov	x1, x19
 113c6c4:	8b1402c0 	add	x0, x22, x20
               z = inlen;
 113c6c8:	f90053f3 	str	x19, [sp, #160]
               if ((err = der_decode_raw_bit_string(in + x, z, data, &size)) != CRYPT_OK) {
 113c6cc:	94000b8b 	bl	113f4f8 <der_decode_raw_bit_string>
 113c6d0:	17fffff3 	b	113c69c <der_decode_custom_type_ex+0x398>
               if ((err = der_decode_octet_string(in + x, z, data, &size)) != CRYPT_OK) {
 113c6d4:	aa1c03e2 	mov	x2, x28
 113c6d8:	aa1b03e3 	mov	x3, x27
 113c6dc:	aa1303e1 	mov	x1, x19
 113c6e0:	8b1402c0 	add	x0, x22, x20
               z = inlen;
 113c6e4:	f90053f3 	str	x19, [sp, #160]
               if ((err = der_decode_octet_string(in + x, z, data, &size)) != CRYPT_OK) {
 113c6e8:	94000845 	bl	113e7fc <der_decode_octet_string>
 113c6ec:	2a0003e2 	mov	w2, w0
 113c6f0:	35fff6e0 	cbnz	w0, 113c5cc <der_decode_custom_type_ex+0x2c8>
               list[i].size = size;
 113c6f4:	f9404be0 	ldr	x0, [sp, #144]
 113c6f8:	f9000aa0 	str	x0, [x21, #16]
               if ((err = der_length_octet_string(size, &z)) != CRYPT_OK) {
 113c6fc:	aa1803e1 	mov	x1, x24
 113c700:	940008ad 	bl	113e9b4 <der_length_octet_string>
 113c704:	17ffffbb 	b	113c5f0 <der_decode_custom_type_ex+0x2ec>
               if (inlen < 2 || in[x] != 0x05 || in[x+1] != 0x00) {
 113c708:	f100067f 	cmp	x19, #0x1
 113c70c:	540000e9 	b.ls	113c728 <der_decode_custom_type_ex+0x424>  // b.plast
 113c710:	38746ac0 	ldrb	w0, [x22, x20]
 113c714:	7100141f 	cmp	w0, #0x5
 113c718:	54000081 	b.ne	113c728 <der_decode_custom_type_ex+0x424>  // b.any
 113c71c:	8b1402c0 	add	x0, x22, x20
 113c720:	39400400 	ldrb	w0, [x0, #1]
 113c724:	340000c0 	cbz	w0, 113c73c <der_decode_custom_type_ex+0x438>
                  if (!ordered || list[i].optional) { continue; }
 113c728:	34fff597 	cbz	w23, 113c5d8 <der_decode_custom_type_ex+0x2d4>
 113c72c:	b9401ea0 	ldr	w0, [x21, #28]
 113c730:	35fff540 	cbnz	w0, 113c5d8 <der_decode_custom_type_ex+0x2d4>
          err = CRYPT_INVALID_PACKET;
 113c734:	528000e2 	mov	w2, #0x7                   	// #7
 113c738:	17ffffb0 	b	113c5f8 <der_decode_custom_type_ex+0x2f4>
               z = 2;
 113c73c:	d2800040 	mov	x0, #0x2                   	// #2
 113c740:	f90053e0 	str	x0, [sp, #160]
       x           += z;
 113c744:	f94053e0 	ldr	x0, [sp, #160]
          i = -1;
 113c748:	710002ff 	cmp	w23, #0x0
       x           += z;
 113c74c:	8b000294 	add	x20, x20, x0
       inlen       -= z;
 113c750:	cb000273 	sub	x19, x19, x0
       list[i].used = 1;
 113c754:	52800020 	mov	w0, #0x1                   	// #1
 113c758:	b9001aa0 	str	w0, [x21, #24]
          i = -1;
 113c75c:	b9406fe0 	ldr	w0, [sp, #108]
 113c760:	5a9f1000 	csinv	w0, w0, wzr, ne  // ne = any
 113c764:	b9006fe0 	str	w0, [sp, #108]
 113c768:	17ffff9c 	b	113c5d8 <der_decode_custom_type_ex+0x2d4>
               if ((err = der_decode_object_identifier(in + x, z, data, &size)) != CRYPT_OK) {
 113c76c:	aa1c03e2 	mov	x2, x28
 113c770:	aa1b03e3 	mov	x3, x27
 113c774:	aa1303e1 	mov	x1, x19
 113c778:	8b1402c0 	add	x0, x22, x20
               z = inlen;
 113c77c:	f90053f3 	str	x19, [sp, #160]
               if ((err = der_decode_object_identifier(in + x, z, data, &size)) != CRYPT_OK) {
 113c780:	9400070c 	bl	113e3b0 <der_decode_object_identifier>
 113c784:	2a0003e2 	mov	w2, w0
 113c788:	35fff220 	cbnz	w0, 113c5cc <der_decode_custom_type_ex+0x2c8>
               list[i].size = size;
 113c78c:	f9404be1 	ldr	x1, [sp, #144]
 113c790:	f9000aa1 	str	x1, [x21, #16]
               if ((err = der_length_object_identifier(data, size, &z)) != CRYPT_OK) {
 113c794:	aa1803e2 	mov	x2, x24
 113c798:	aa1c03e0 	mov	x0, x28
 113c79c:	940007e0 	bl	113e71c <der_length_object_identifier>
 113c7a0:	17ffff94 	b	113c5f0 <der_decode_custom_type_ex+0x2ec>
               if ((err = der_decode_teletex_string(in + x, z, data, &size)) != CRYPT_OK) {
 113c7a4:	aa1c03e2 	mov	x2, x28
 113c7a8:	aa1b03e3 	mov	x3, x27
 113c7ac:	aa1303e1 	mov	x1, x19
 113c7b0:	8b1402c0 	add	x0, x22, x20
               z = inlen;
 113c7b4:	f90053f3 	str	x19, [sp, #160]
               if ((err = der_decode_teletex_string(in + x, z, data, &size)) != CRYPT_OK) {
 113c7b8:	94000a67 	bl	113f154 <der_decode_teletex_string>
 113c7bc:	2a0003e2 	mov	w2, w0
 113c7c0:	35fff060 	cbnz	w0, 113c5cc <der_decode_custom_type_ex+0x2c8>
               list[i].size = size;
 113c7c4:	f9404be1 	ldr	x1, [sp, #144]
 113c7c8:	f9000aa1 	str	x1, [x21, #16]
               if ((err = der_length_teletex_string(data, size, &z)) != CRYPT_OK) {
 113c7cc:	aa1803e2 	mov	x2, x24
 113c7d0:	aa1c03e0 	mov	x0, x28
 113c7d4:	97fff86e 	bl	113a98c <der_length_teletex_string>
 113c7d8:	17ffff86 	b	113c5f0 <der_decode_custom_type_ex+0x2ec>
               if ((err = der_decode_ia5_string(in + x, z, data, &size)) != CRYPT_OK) {
 113c7dc:	aa1c03e2 	mov	x2, x28
 113c7e0:	aa1b03e3 	mov	x3, x27
 113c7e4:	aa1303e1 	mov	x1, x19
 113c7e8:	8b1402c0 	add	x0, x22, x20
               z = inlen;
 113c7ec:	f90053f3 	str	x19, [sp, #160]
               if ((err = der_decode_ia5_string(in + x, z, data, &size)) != CRYPT_OK) {
 113c7f0:	940004ec 	bl	113dba0 <der_decode_ia5_string>
 113c7f4:	2a0003e2 	mov	w2, w0
 113c7f8:	35ffeea0 	cbnz	w0, 113c5cc <der_decode_custom_type_ex+0x2c8>
               list[i].size = size;
 113c7fc:	f9404be1 	ldr	x1, [sp, #144]
 113c800:	f9000aa1 	str	x1, [x21, #16]
               if ((err = der_length_ia5_string(data, size, &z)) != CRYPT_OK) {
 113c804:	aa1803e2 	mov	x2, x24
 113c808:	aa1c03e0 	mov	x0, x28
 113c80c:	9400057c 	bl	113ddfc <der_length_ia5_string>
 113c810:	17ffff78 	b	113c5f0 <der_decode_custom_type_ex+0x2ec>
               if ((err = der_decode_printable_string(in + x, z, data, &size)) != CRYPT_OK) {
 113c814:	aa1c03e2 	mov	x2, x28
 113c818:	aa1b03e3 	mov	x3, x27
 113c81c:	aa1303e1 	mov	x1, x19
 113c820:	8b1402c0 	add	x0, x22, x20
               z = inlen;
 113c824:	f90053f3 	str	x19, [sp, #160]
               if ((err = der_decode_printable_string(in + x, z, data, &size)) != CRYPT_OK) {
 113c828:	94000875 	bl	113e9fc <der_decode_printable_string>
 113c82c:	2a0003e2 	mov	w2, w0
 113c830:	35ffece0 	cbnz	w0, 113c5cc <der_decode_custom_type_ex+0x2c8>
               list[i].size = size;
 113c834:	f9404be1 	ldr	x1, [sp, #144]
 113c838:	f9000aa1 	str	x1, [x21, #16]
               if ((err = der_length_printable_string(data, size, &z)) != CRYPT_OK) {
 113c83c:	aa1803e2 	mov	x2, x24
 113c840:	aa1c03e0 	mov	x0, x28
 113c844:	94000905 	bl	113ec58 <der_length_printable_string>
 113c848:	17ffff6a 	b	113c5f0 <der_decode_custom_type_ex+0x2ec>
               if ((err = der_decode_utf8_string(in + x, z, data, &size)) != CRYPT_OK) {
 113c84c:	aa1c03e2 	mov	x2, x28
 113c850:	aa1b03e3 	mov	x3, x27
 113c854:	aa1303e1 	mov	x1, x19
 113c858:	8b1402c0 	add	x0, x22, x20
               z = inlen;
 113c85c:	f90053f3 	str	x19, [sp, #160]
               if ((err = der_decode_utf8_string(in + x, z, data, &size)) != CRYPT_OK) {
 113c860:	940009e4 	bl	113eff0 <der_decode_utf8_string>
 113c864:	2a0003e2 	mov	w2, w0
 113c868:	35ffeb20 	cbnz	w0, 113c5cc <der_decode_custom_type_ex+0x2c8>
               list[i].size = size;
 113c86c:	f9404be1 	ldr	x1, [sp, #144]
 113c870:	f9000aa1 	str	x1, [x21, #16]
               if ((err = der_length_utf8_string(data, size, &z)) != CRYPT_OK) {
 113c874:	aa1803e2 	mov	x2, x24
 113c878:	aa1c03e0 	mov	x0, x28
 113c87c:	97fff7fd 	bl	113a870 <der_length_utf8_string>
 113c880:	17ffff5c 	b	113c5f0 <der_decode_custom_type_ex+0x2ec>
               if ((err = der_decode_utctime(in + x, &z, data)) != CRYPT_OK) {
 113c884:	aa1c03e2 	mov	x2, x28
 113c888:	aa1803e1 	mov	x1, x24
 113c88c:	8b1402c0 	add	x0, x22, x20
               z = inlen;
 113c890:	f90053f3 	str	x19, [sp, #160]
               if ((err = der_decode_utctime(in + x, &z, data)) != CRYPT_OK) {
 113c894:	94000937 	bl	113ed70 <der_decode_utctime>
               if ((err = der_decode_choice(in + x, &z, data, size)) != CRYPT_OK) {
 113c898:	2a0003e2 	mov	w2, w0
 113c89c:	34fff540 	cbz	w0, 113c744 <der_decode_custom_type_ex+0x440>
 113c8a0:	17ffff4b 	b	113c5cc <der_decode_custom_type_ex+0x2c8>
               if ((err = der_decode_generalizedtime(in + x, &z, data)) != CRYPT_OK) {
 113c8a4:	aa1c03e2 	mov	x2, x28
 113c8a8:	aa1803e1 	mov	x1, x24
 113c8ac:	8b1402c0 	add	x0, x22, x20
               z = inlen;
 113c8b0:	f90053f3 	str	x19, [sp, #160]
               if ((err = der_decode_generalizedtime(in + x, &z, data)) != CRYPT_OK) {
 113c8b4:	940003ea 	bl	113d85c <der_decode_generalizedtime>
 113c8b8:	17fffff8 	b	113c898 <der_decode_custom_type_ex+0x594>
               if ((err = der_decode_set(in + x, z, data, size)) != CRYPT_OK) {
 113c8bc:	aa1c03e2 	mov	x2, x28
 113c8c0:	aa1303e1 	mov	x1, x19
 113c8c4:	8b1402c0 	add	x0, x22, x20
 113c8c8:	52800004 	mov	w4, #0x0                   	// #0
               z = inlen;
 113c8cc:	f90053f3 	str	x19, [sp, #160]
               if ((err = der_decode_set(in + x, z, data, size)) != CRYPT_OK) {
 113c8d0:	97fff2ce 	bl	1139408 <der_decode_sequence_ex>
 113c8d4:	2a0003e2 	mov	w2, w0
               if (err != CRYPT_OK) {
 113c8d8:	35ffe7a2 	cbnz	w2, 113c5cc <der_decode_custom_type_ex+0x2c8>
               if ((err = der_length_sequence(data, size, &z)) != CRYPT_OK) {
 113c8dc:	f9404be1 	ldr	x1, [sp, #144]
 113c8e0:	aa1803e2 	mov	x2, x24
 113c8e4:	aa1c03e0 	mov	x0, x28
 113c8e8:	97fff546 	bl	1139e00 <der_length_sequence>
 113c8ec:	17ffff41 	b	113c5f0 <der_decode_custom_type_ex+0x2ec>
               if ((type == LTC_ASN1_SETOF && (in[x] & 0x3F) != 0x31) || (type == LTC_ASN1_SEQUENCE && (in[x] & 0x3F) != 0x30)) {
 113c8f0:	8b1402c0 	add	x0, x22, x20
 113c8f4:	71003c3f 	cmp	w1, #0xf
 113c8f8:	540001e1 	b.ne	113c934 <der_decode_custom_type_ex+0x630>  // b.any
 113c8fc:	38746ac1 	ldrb	w1, [x22, x20]
 113c900:	12001421 	and	w1, w1, #0x3f
 113c904:	7100c43f 	cmp	w1, #0x31
 113c908:	54fff161 	b.ne	113c734 <der_decode_custom_type_ex+0x430>  // b.any
               err = der_decode_sequence_ex(in + x, z, data, size, flags);
 113c90c:	b9407be4 	ldr	w4, [sp, #120]
 113c910:	aa1c03e2 	mov	x2, x28
 113c914:	aa1303e1 	mov	x1, x19
               z = inlen;
 113c918:	f90053f3 	str	x19, [sp, #160]
               err = der_decode_sequence_ex(in + x, z, data, size, flags);
 113c91c:	97fff2bb 	bl	1139408 <der_decode_sequence_ex>
 113c920:	2a0003e2 	mov	w2, w0
               if (err == CRYPT_INPUT_TOO_LONG) {
 113c924:	7100541f 	cmp	w0, #0x15
 113c928:	54fffd81 	b.ne	113c8d8 <der_decode_custom_type_ex+0x5d4>  // b.any
                  seq_err = CRYPT_INPUT_TOO_LONG;
 113c92c:	b90083e0 	str	w0, [sp, #128]
 113c930:	17ffffeb 	b	113c8dc <der_decode_custom_type_ex+0x5d8>
               if ((type == LTC_ASN1_SETOF && (in[x] & 0x3F) != 0x31) || (type == LTC_ASN1_SEQUENCE && (in[x] & 0x3F) != 0x30)) {
 113c934:	7100343f 	cmp	w1, #0xd
 113c938:	54fffea1 	b.ne	113c90c <der_decode_custom_type_ex+0x608>  // b.any
 113c93c:	39400001 	ldrb	w1, [x0]
 113c940:	12001421 	and	w1, w1, #0x3f
 113c944:	7100c03f 	cmp	w1, #0x30
 113c948:	17fffff0 	b	113c908 <der_decode_custom_type_ex+0x604>
               err = der_decode_custom_type(in + x, z, &list[i]);
 113c94c:	aa1503e2 	mov	x2, x21
 113c950:	aa1303e1 	mov	x1, x19
 113c954:	8b1402c0 	add	x0, x22, x20
               z = inlen;
 113c958:	f90053f3 	str	x19, [sp, #160]
               err = der_decode_custom_type(in + x, z, &list[i]);
 113c95c:	9400002a 	bl	113ca04 <der_decode_custom_type>
 113c960:	2a0003e2 	mov	w2, w0
               if (err == CRYPT_INPUT_TOO_LONG) {
 113c964:	7100541f 	cmp	w0, #0x15
 113c968:	540000e0 	b.eq	113c984 <der_decode_custom_type_ex+0x680>  // b.none
               if (err != CRYPT_OK) {
 113c96c:	35ffe300 	cbnz	w0, 113c5cc <der_decode_custom_type_ex+0x2c8>
               if ((err = der_length_custom_type(&list[i], &z, NULL)) != CRYPT_OK) {
 113c970:	aa1803e1 	mov	x1, x24
 113c974:	aa1503e0 	mov	x0, x21
 113c978:	d2800002 	mov	x2, #0x0                   	// #0
 113c97c:	940000f7 	bl	113cd58 <der_length_custom_type>
 113c980:	17ffff1c 	b	113c5f0 <der_decode_custom_type_ex+0x2ec>
                  seq_err = CRYPT_INPUT_TOO_LONG;
 113c984:	b90083e0 	str	w0, [sp, #128]
 113c988:	17fffffa 	b	113c970 <der_decode_custom_type_ex+0x66c>
               if ((err = der_decode_choice(in + x, &z, data, size)) != CRYPT_OK) {
 113c98c:	aa1c03e2 	mov	x2, x28
 113c990:	aa1803e1 	mov	x1, x24
 113c994:	8b1402c0 	add	x0, x22, x20
               z = inlen;
 113c998:	f90053f3 	str	x19, [sp, #160]
               if ((err = der_decode_choice(in + x, &z, data, size)) != CRYPT_OK) {
 113c99c:	94000b39 	bl	113f680 <der_decode_choice>
 113c9a0:	17ffffbe 	b	113c898 <der_decode_custom_type_ex+0x594>
      if (list[i].used == 0 && list[i].optional == 0) {
 113c9a4:	f9403be2 	ldr	x2, [sp, #112]
 113c9a8:	9b010802 	madd	x2, x0, x1, x2
 113c9ac:	91000400 	add	x0, x0, #0x1
 113c9b0:	f9400c42 	ldr	x2, [x2, #24]
 113c9b4:	b5ffdba2 	cbnz	x2, 113c528 <der_decode_custom_type_ex+0x224>
 113c9b8:	17ffff5f 	b	113c734 <der_decode_custom_type_ex+0x430>
      err = CRYPT_INPUT_TOO_LONG;
 113c9bc:	f9403fe0 	ldr	x0, [sp, #120]
 113c9c0:	528000e2 	mov	w2, #0x7                   	// #7
 113c9c4:	f27f001f 	tst	x0, #0x2
 113c9c8:	528002a0 	mov	w0, #0x15                  	// #21
 113c9cc:	1a801042 	csel	w2, w2, w0, ne  // ne = any
 113c9d0:	17ffff0a 	b	113c5f8 <der_decode_custom_type_ex+0x2f4>
          err = CRYPT_PK_ASN1_ERROR;
 113c9d4:	52800282 	mov	w2, #0x14                  	// #20
 113c9d8:	17ffff08 	b	113c5f8 <der_decode_custom_type_ex+0x2f4>
      err = CRYPT_INVALID_PACKET;
 113c9dc:	52800202 	mov	w2, #0x10                  	// #16
 113c9e0:	17ffff06 	b	113c5f8 <der_decode_custom_type_ex+0x2f4>
      err = CRYPT_OK;
 113c9e4:	52800002 	mov	w2, #0x0                   	// #0
 113c9e8:	17ffff04 	b	113c5f8 <der_decode_custom_type_ex+0x2f4>
   LTC_ARGCHK(in   != NULL);
 113c9ec:	52800202 	mov	w2, #0x10                  	// #16
 113c9f0:	17ffff07 	b	113c60c <der_decode_custom_type_ex+0x308>
      return CRYPT_INVALID_PACKET;
 113c9f4:	528000e2 	mov	w2, #0x7                   	// #7
 113c9f8:	17ffff05 	b	113c60c <der_decode_custom_type_ex+0x308>
            return CRYPT_MEM;
 113c9fc:	528001a2 	mov	w2, #0xd                   	// #13
 113ca00:	17ffff03 	b	113c60c <der_decode_custom_type_ex+0x308>

000000000113ca04 <der_decode_custom_type>:
   LTC_ARGCHK(root != NULL);
 113ca04:	b40000a2 	cbz	x2, 113ca18 <der_decode_custom_type+0x14>
   return der_decode_custom_type_ex(in, inlen, root, NULL, 0, LTC_DER_SEQ_ORDERED | LTC_DER_SEQ_RELAXED);
 113ca08:	52800025 	mov	w5, #0x1                   	// #1
 113ca0c:	d2800004 	mov	x4, #0x0                   	// #0
 113ca10:	d2800003 	mov	x3, #0x0                   	// #0
 113ca14:	17fffe3c 	b	113c304 <der_decode_custom_type_ex>
}
 113ca18:	52800200 	mov	w0, #0x10                  	// #16
 113ca1c:	d65f03c0 	ret

000000000113ca20 <der_encode_custom_type>:
   ltc_asn1_type type;
   const ltc_asn1_list *list;
   unsigned long size, x, y, z, i, inlen, id_len;
   void          *data;

   LTC_ARGCHK(root    != NULL);
 113ca20:	b5000060 	cbnz	x0, 113ca2c <der_encode_custom_type+0xc>
 113ca24:	52800200 	mov	w0, #0x10                  	// #16
   *outlen = x;
   err = CRYPT_OK;

LBL_ERR:
   return err;
}
 113ca28:	d65f03c0 	ret
{
 113ca2c:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
 113ca30:	910003fd 	mov	x29, sp
 113ca34:	a90153f3 	stp	x19, x20, [sp, #16]
 113ca38:	aa0103f4 	mov	x20, x1
 113ca3c:	a9025bf5 	stp	x21, x22, [sp, #32]
 113ca40:	a90363f7 	stp	x23, x24, [sp, #48]
 113ca44:	a9046bf9 	stp	x25, x26, [sp, #64]
 113ca48:	a90573fb 	stp	x27, x28, [sp, #80]
   LTC_ARGCHK(out     != NULL);
 113ca4c:	b4001821 	cbz	x1, 113cd50 <der_encode_custom_type+0x330>
 113ca50:	aa0203fb 	mov	x27, x2
   LTC_ARGCHK(outlen  != NULL);
 113ca54:	b40017e2 	cbz	x2, 113cd50 <der_encode_custom_type+0x330>
   if ((err = der_length_custom_type(root, &y, &z)) != CRYPT_OK) return CRYPT_INVALID_ARG;
 113ca58:	910203f5 	add	x21, sp, #0x80
 113ca5c:	9101e3f8 	add	x24, sp, #0x78
 113ca60:	aa0003f6 	mov	x22, x0
 113ca64:	aa1503e2 	mov	x2, x21
 113ca68:	aa1803e1 	mov	x1, x24
   y = 0; z = 0;
 113ca6c:	a907ffff 	stp	xzr, xzr, [sp, #120]
   if ((err = der_length_custom_type(root, &y, &z)) != CRYPT_OK) return CRYPT_INVALID_ARG;
 113ca70:	940000ba 	bl	113cd58 <der_length_custom_type>
 113ca74:	350016e0 	cbnz	w0, 113cd50 <der_encode_custom_type+0x330>
   if (*outlen < y) {
 113ca78:	f9400361 	ldr	x1, [x27]
 113ca7c:	f9403fe0 	ldr	x0, [sp, #120]
 113ca80:	eb00003f 	cmp	x1, x0
 113ca84:	54000142 	b.cs	113caac <der_encode_custom_type+0x8c>  // b.hs, b.nlast
      *outlen = y;
 113ca88:	f9000360 	str	x0, [x27]
      err = CRYPT_BUFFER_OVERFLOW;
 113ca8c:	528000c0 	mov	w0, #0x6                   	// #6
}
 113ca90:	a94153f3 	ldp	x19, x20, [sp, #16]
 113ca94:	a9425bf5 	ldp	x21, x22, [sp, #32]
 113ca98:	a94363f7 	ldp	x23, x24, [sp, #48]
 113ca9c:	a9446bf9 	ldp	x25, x26, [sp, #64]
 113caa0:	a94573fb 	ldp	x27, x28, [sp, #80]
 113caa4:	a8c97bfd 	ldp	x29, x30, [sp], #144
 113caa8:	d65f03c0 	ret
   if ((err = der_length_asn1_identifier(root, &id_len)) != CRYPT_OK) return CRYPT_INVALID_ARG;
 113caac:	910223f9 	add	x25, sp, #0x88
 113cab0:	aa1603e0 	mov	x0, x22
 113cab4:	aa1903e1 	mov	x1, x25
 113cab8:	9400026f 	bl	113d474 <der_length_asn1_identifier>
 113cabc:	350014a0 	cbnz	w0, 113cd50 <der_encode_custom_type+0x330>
   if (root->pc == LTC_ASN1_PC_PRIMITIVE) {
 113cac0:	b94026c0 	ldr	w0, [x22, #36]
   x = id_len;
 113cac4:	f94047f3 	ldr	x19, [sp, #136]
   if (root->pc == LTC_ASN1_PC_PRIMITIVE) {
 113cac8:	350002a0 	cbnz	w0, 113cb1c <der_encode_custom_type+0xfc>
      x -= 1;
 113cacc:	d1000673 	sub	x19, x19, #0x1
 113cad0:	aa1603f7 	mov	x23, x22
      inlen = 1;
 113cad4:	d280003a 	mov	x26, #0x1                   	// #1
   *outlen -= x;
 113cad8:	f9400360 	ldr	x0, [x27]
   for (i = 0; i < inlen; i++) {
 113cadc:	d2800018 	mov	x24, #0x0                   	// #0
               z = 2;
 113cae0:	d280005c 	mov	x28, #0x2                   	// #2
   *outlen -= x;
 113cae4:	cb130000 	sub	x0, x0, x19
 113cae8:	f9000360 	str	x0, [x27]
   for (i = 0; i < inlen; i++) {
 113caec:	900000a0 	adrp	x0, 1150000 <Te4+0x258>
 113caf0:	911ff000 	add	x0, x0, #0x7fc
 113caf4:	f90037e0 	str	x0, [sp, #104]
 113caf8:	eb1a031f 	cmp	x24, x26
 113cafc:	54000281 	b.ne	113cb4c <der_encode_custom_type+0x12c>  // b.any
   if ((err = der_encode_asn1_identifier(root, out, &id_len)) != CRYPT_OK) {
 113cb00:	aa1903e2 	mov	x2, x25
 113cb04:	aa1403e1 	mov	x1, x20
 113cb08:	aa1603e0 	mov	x0, x22
 113cb0c:	9400018e 	bl	113d144 <der_encode_asn1_identifier>
 113cb10:	35fffc00 	cbnz	w0, 113ca90 <der_encode_custom_type+0x70>
   *outlen = x;
 113cb14:	f9000373 	str	x19, [x27]
   err = CRYPT_OK;
 113cb18:	17ffffde 	b	113ca90 <der_encode_custom_type+0x70>
      y = *outlen - x;
 113cb1c:	f9400360 	ldr	x0, [x27]
      if ((err = der_encode_asn1_length(z, &out[x], &y)) != CRYPT_OK) {
 113cb20:	aa1803e2 	mov	x2, x24
 113cb24:	8b130281 	add	x1, x20, x19
      y = *outlen - x;
 113cb28:	cb130000 	sub	x0, x0, x19
 113cb2c:	f9003fe0 	str	x0, [sp, #120]
      if ((err = der_encode_asn1_length(z, &out[x], &y)) != CRYPT_OK) {
 113cb30:	f94043e0 	ldr	x0, [sp, #128]
      inlen = root->size;
 113cb34:	a940ead7 	ldp	x23, x26, [x22, #8]
      if ((err = der_encode_asn1_length(z, &out[x], &y)) != CRYPT_OK) {
 113cb38:	940001d2 	bl	113d280 <der_encode_asn1_length>
 113cb3c:	35fffaa0 	cbnz	w0, 113ca90 <der_encode_custom_type+0x70>
      x += y;
 113cb40:	f9403fe0 	ldr	x0, [sp, #120]
 113cb44:	8b000273 	add	x19, x19, x0
 113cb48:	17ffffe4 	b	113cad8 <der_encode_custom_type+0xb8>
       if (root->pc == LTC_ASN1_PC_PRIMITIVE) {
 113cb4c:	b94026c0 	ldr	w0, [x22, #36]
 113cb50:	35000180 	cbnz	w0, 113cb80 <der_encode_custom_type+0x160>
          type = (ltc_asn1_type)list[i].used;
 113cb54:	b9401ae2 	ldr	w2, [x23, #24]
       size = list[i].size;
 113cb58:	a94086e0 	ldp	x0, x1, [x23, #8]
       if (type == LTC_ASN1_EOL) {
 113cb5c:	34fffd22 	cbz	w2, 113cb00 <der_encode_custom_type+0xe0>
       switch (type) {
 113cb60:	51000442 	sub	w2, w2, #0x1
 113cb64:	7100485f 	cmp	w2, #0x12
 113cb68:	54000f48 	b.hi	113cd50 <der_encode_custom_type+0x330>  // b.pmore
 113cb6c:	f94037e3 	ldr	x3, [sp, #104]
 113cb70:	38624862 	ldrb	w2, [x3, w2, uxtw]
 113cb74:	10000063 	adr	x3, 113cb80 <der_encode_custom_type+0x160>
 113cb78:	8b228862 	add	x2, x3, w2, sxtb #2
 113cb7c:	d61f0040 	br	x2
          type = list[i].type;
 113cb80:	b94002e2 	ldr	w2, [x23]
 113cb84:	17fffff5 	b	113cb58 <der_encode_custom_type+0x138>
               if ((err = der_encode_boolean(*((int *)data), out + x, &z)) != CRYPT_OK) {
 113cb88:	b9400000 	ldr	w0, [x0]
 113cb8c:	aa1503e2 	mov	x2, x21
               z = *outlen;
 113cb90:	f9400361 	ldr	x1, [x27]
 113cb94:	f90043e1 	str	x1, [sp, #128]
               if ((err = der_encode_boolean(*((int *)data), out + x, &z)) != CRYPT_OK) {
 113cb98:	8b130281 	add	x1, x20, x19
 113cb9c:	97fffdc0 	bl	113c29c <der_encode_boolean>
               if ((err = der_encode_custom_type(&list[i], out + x, &z)) != CRYPT_OK) {
 113cba0:	340004c0 	cbz	w0, 113cc38 <der_encode_custom_type+0x218>
 113cba4:	17ffffbb 	b	113ca90 <der_encode_custom_type+0x70>
               z = *outlen;
 113cba8:	f9400361 	ldr	x1, [x27]
               if ((err = der_encode_integer(data, out + x, &z)) != CRYPT_OK) {
 113cbac:	aa1503e2 	mov	x2, x21
               z = *outlen;
 113cbb0:	f90043e1 	str	x1, [sp, #128]
               if ((err = der_encode_integer(data, out + x, &z)) != CRYPT_OK) {
 113cbb4:	8b130281 	add	x1, x20, x19
 113cbb8:	94000501 	bl	113dfbc <der_encode_integer>
 113cbbc:	17fffff9 	b	113cba0 <der_encode_custom_type+0x180>
               z = *outlen;
 113cbc0:	f9400361 	ldr	x1, [x27]
 113cbc4:	f90043e1 	str	x1, [sp, #128]
               if ((err = der_encode_short_integer(*((unsigned long*)data), out + x, &z)) != CRYPT_OK) {
 113cbc8:	aa1503e2 	mov	x2, x21
 113cbcc:	8b130281 	add	x1, x20, x19
 113cbd0:	f9400000 	ldr	x0, [x0]
 113cbd4:	97fff568 	bl	113a174 <der_encode_short_integer>
 113cbd8:	17fffff2 	b	113cba0 <der_encode_custom_type+0x180>
               z = *outlen;
 113cbdc:	f9400362 	ldr	x2, [x27]
               if ((err = der_encode_bit_string(data, size, out + x, &z)) != CRYPT_OK) {
 113cbe0:	aa1503e3 	mov	x3, x21
               z = *outlen;
 113cbe4:	f90043e2 	str	x2, [sp, #128]
               if ((err = der_encode_bit_string(data, size, out + x, &z)) != CRYPT_OK) {
 113cbe8:	8b130282 	add	x2, x20, x19
 113cbec:	97fffcfb 	bl	113bfd8 <der_encode_bit_string>
 113cbf0:	17ffffec 	b	113cba0 <der_encode_custom_type+0x180>
               z = *outlen;
 113cbf4:	f9400362 	ldr	x2, [x27]
               if ((err = der_encode_raw_bit_string(data, size, out + x, &z)) != CRYPT_OK) {
 113cbf8:	aa1503e3 	mov	x3, x21
               z = *outlen;
 113cbfc:	f90043e2 	str	x2, [sp, #128]
               if ((err = der_encode_raw_bit_string(data, size, out + x, &z)) != CRYPT_OK) {
 113cc00:	8b130282 	add	x2, x20, x19
 113cc04:	97fffd56 	bl	113c15c <der_encode_raw_bit_string>
 113cc08:	17ffffe6 	b	113cba0 <der_encode_custom_type+0x180>
               z = *outlen;
 113cc0c:	f9400362 	ldr	x2, [x27]
               if ((err = der_encode_octet_string(data, size, out + x, &z)) != CRYPT_OK) {
 113cc10:	aa1503e3 	mov	x3, x21
               z = *outlen;
 113cc14:	f90043e2 	str	x2, [sp, #128]
               if ((err = der_encode_octet_string(data, size, out + x, &z)) != CRYPT_OK) {
 113cc18:	8b130282 	add	x2, x20, x19
 113cc1c:	9400072f 	bl	113e8d8 <der_encode_octet_string>
 113cc20:	17ffffe0 	b	113cba0 <der_encode_custom_type+0x180>
               out[x] = 0x05;
 113cc24:	528000a0 	mov	w0, #0x5                   	// #5
 113cc28:	38336a80 	strb	w0, [x20, x19]
               out[x+1] = 0x00;
 113cc2c:	8b130280 	add	x0, x20, x19
               z = 2;
 113cc30:	f90043fc 	str	x28, [sp, #128]
               out[x+1] = 0x00;
 113cc34:	3900041f 	strb	wzr, [x0, #1]
       *outlen -= z;
 113cc38:	f9400360 	ldr	x0, [x27]
   for (i = 0; i < inlen; i++) {
 113cc3c:	91000718 	add	x24, x24, #0x1
       x       += z;
 113cc40:	f94043e1 	ldr	x1, [sp, #128]
 113cc44:	910142f7 	add	x23, x23, #0x50
       *outlen -= z;
 113cc48:	cb010000 	sub	x0, x0, x1
       x       += z;
 113cc4c:	8b010273 	add	x19, x19, x1
       *outlen -= z;
 113cc50:	f9000360 	str	x0, [x27]
   for (i = 0; i < inlen; i++) {
 113cc54:	17ffffa9 	b	113caf8 <der_encode_custom_type+0xd8>
               z = *outlen;
 113cc58:	f9400362 	ldr	x2, [x27]
               if ((err = der_encode_object_identifier(data, size, out + x, &z)) != CRYPT_OK) {
 113cc5c:	aa1503e3 	mov	x3, x21
               z = *outlen;
 113cc60:	f90043e2 	str	x2, [sp, #128]
               if ((err = der_encode_object_identifier(data, size, out + x, &z)) != CRYPT_OK) {
 113cc64:	8b130282 	add	x2, x20, x19
 113cc68:	9400062e 	bl	113e520 <der_encode_object_identifier>
 113cc6c:	17ffffcd 	b	113cba0 <der_encode_custom_type+0x180>
               z = *outlen;
 113cc70:	f9400362 	ldr	x2, [x27]
               if ((err = der_encode_ia5_string(data, size, out + x, &z)) != CRYPT_OK) {
 113cc74:	aa1503e3 	mov	x3, x21
               z = *outlen;
 113cc78:	f90043e2 	str	x2, [sp, #128]
               if ((err = der_encode_ia5_string(data, size, out + x, &z)) != CRYPT_OK) {
 113cc7c:	8b130282 	add	x2, x20, x19
 113cc80:	94000406 	bl	113dc98 <der_encode_ia5_string>
 113cc84:	17ffffc7 	b	113cba0 <der_encode_custom_type+0x180>
               z = *outlen;
 113cc88:	f9400362 	ldr	x2, [x27]
               if ((err = der_encode_printable_string(data, size, out + x, &z)) != CRYPT_OK) {
 113cc8c:	aa1503e3 	mov	x3, x21
               z = *outlen;
 113cc90:	f90043e2 	str	x2, [sp, #128]
               if ((err = der_encode_printable_string(data, size, out + x, &z)) != CRYPT_OK) {
 113cc94:	8b130282 	add	x2, x20, x19
 113cc98:	94000797 	bl	113eaf4 <der_encode_printable_string>
 113cc9c:	17ffffc1 	b	113cba0 <der_encode_custom_type+0x180>
               z = *outlen;
 113cca0:	f9400362 	ldr	x2, [x27]
               if ((err = der_encode_utf8_string(data, size, out + x, &z)) != CRYPT_OK) {
 113cca4:	aa1503e3 	mov	x3, x21
               z = *outlen;
 113cca8:	f90043e2 	str	x2, [sp, #128]
               if ((err = der_encode_utf8_string(data, size, out + x, &z)) != CRYPT_OK) {
 113ccac:	8b130282 	add	x2, x20, x19
 113ccb0:	97fff64f 	bl	113a5ec <der_encode_utf8_string>
 113ccb4:	17ffffbb 	b	113cba0 <der_encode_custom_type+0x180>
               z = *outlen;
 113ccb8:	f9400361 	ldr	x1, [x27]
               if ((err = der_encode_utctime(data, out + x, &z)) != CRYPT_OK) {
 113ccbc:	aa1503e2 	mov	x2, x21
               z = *outlen;
 113ccc0:	f90043e1 	str	x1, [sp, #128]
               if ((err = der_encode_utctime(data, out + x, &z)) != CRYPT_OK) {
 113ccc4:	8b130281 	add	x1, x20, x19
 113ccc8:	97fff598 	bl	113a328 <der_encode_utctime>
 113cccc:	17ffffb5 	b	113cba0 <der_encode_custom_type+0x180>
               z = *outlen;
 113ccd0:	f9400361 	ldr	x1, [x27]
               if ((err = der_encode_generalizedtime(data, out + x, &z)) != CRYPT_OK) {
 113ccd4:	aa1503e2 	mov	x2, x21
               z = *outlen;
 113ccd8:	f90043e1 	str	x1, [sp, #128]
               if ((err = der_encode_generalizedtime(data, out + x, &z)) != CRYPT_OK) {
 113ccdc:	8b130281 	add	x1, x20, x19
 113cce0:	940001eb 	bl	113d48c <der_encode_generalizedtime>
 113cce4:	17ffffaf 	b	113cba0 <der_encode_custom_type+0x180>
               z = *outlen;
 113cce8:	f9400362 	ldr	x2, [x27]
               if ((err = der_encode_set(data, size, out + x, &z)) != CRYPT_OK) {
 113ccec:	aa1503e3 	mov	x3, x21
               z = *outlen;
 113ccf0:	f90043e2 	str	x2, [sp, #128]
               if ((err = der_encode_set(data, size, out + x, &z)) != CRYPT_OK) {
 113ccf4:	8b130282 	add	x2, x20, x19
 113ccf8:	97fff451 	bl	1139e3c <der_encode_set>
 113ccfc:	17ffffa9 	b	113cba0 <der_encode_custom_type+0x180>
               z = *outlen;
 113cd00:	f9400362 	ldr	x2, [x27]
               if ((err = der_encode_setof(data, size, out + x, &z)) != CRYPT_OK) {
 113cd04:	aa1503e3 	mov	x3, x21
               z = *outlen;
 113cd08:	f90043e2 	str	x2, [sp, #128]
               if ((err = der_encode_setof(data, size, out + x, &z)) != CRYPT_OK) {
 113cd0c:	8b130282 	add	x2, x20, x19
 113cd10:	97fff4a1 	bl	1139f94 <der_encode_setof>
 113cd14:	17ffffa3 	b	113cba0 <der_encode_custom_type+0x180>
               z = *outlen;
 113cd18:	f9400362 	ldr	x2, [x27]
               if ((err = der_encode_sequence_ex(data, size, out + x, &z, type)) != CRYPT_OK) {
 113cd1c:	aa1503e3 	mov	x3, x21
 113cd20:	528001a4 	mov	w4, #0xd                   	// #13
               z = *outlen;
 113cd24:	f90043e2 	str	x2, [sp, #128]
               if ((err = der_encode_sequence_ex(data, size, out + x, &z, type)) != CRYPT_OK) {
 113cd28:	8b130282 	add	x2, x20, x19
 113cd2c:	97fff269 	bl	11396d0 <der_encode_sequence_ex>
 113cd30:	17ffff9c 	b	113cba0 <der_encode_custom_type+0x180>
               z = *outlen;
 113cd34:	f9400360 	ldr	x0, [x27]
               if ((err = der_encode_custom_type(&list[i], out + x, &z)) != CRYPT_OK) {
 113cd38:	aa1503e2 	mov	x2, x21
 113cd3c:	8b130281 	add	x1, x20, x19
               z = *outlen;
 113cd40:	f90043e0 	str	x0, [sp, #128]
               if ((err = der_encode_custom_type(&list[i], out + x, &z)) != CRYPT_OK) {
 113cd44:	aa1703e0 	mov	x0, x23
 113cd48:	97ffff36 	bl	113ca20 <der_encode_custom_type>
 113cd4c:	17ffff95 	b	113cba0 <der_encode_custom_type+0x180>
       if (type == LTC_ASN1_EOL) {
 113cd50:	52800200 	mov	w0, #0x10                  	// #16
 113cd54:	17ffff4f 	b	113ca90 <der_encode_custom_type+0x70>

000000000113cd58 <der_length_custom_type>:
   @param outlen        [out] The length required in octets to store it
   @param payloadlen    [out] The length of the payload in octets
   @return CRYPT_OK on success
*/
int der_length_custom_type(const ltc_asn1_list *root, unsigned long *outlen, unsigned long *payloadlen)
{
 113cd58:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
 113cd5c:	910003fd 	mov	x29, sp
 113cd60:	a90153f3 	stp	x19, x20, [sp, #16]
 113cd64:	a9025bf5 	stp	x21, x22, [sp, #32]
 113cd68:	a90363f7 	stp	x23, x24, [sp, #48]
 113cd6c:	a9046bf9 	stp	x25, x26, [sp, #64]
 113cd70:	a90573fb 	stp	x27, x28, [sp, #80]
   const ltc_asn1_list *list;
   ltc_asn1_type type;
   unsigned long size, x, y, i, inlen, id_len;
   void          *data;

   LTC_ARGCHK(root    != NULL);
 113cd74:	b4000fe0 	cbz	x0, 113cf70 <der_length_custom_type+0x218>
 113cd78:	aa0103f9 	mov	x25, x1
   LTC_ARGCHK(outlen  != NULL);
 113cd7c:	b4000fa1 	cbz	x1, 113cf70 <der_length_custom_type+0x218>
 113cd80:	aa0003f7 	mov	x23, x0
 113cd84:	aa0203f8 	mov	x24, x2

   /* get size of output that will be required */
   if ((err = der_length_asn1_identifier(root, &id_len)) != CRYPT_OK) {
 113cd88:	9101a3e1 	add	x1, sp, #0x68
 113cd8c:	940001ba 	bl	113d474 <der_length_asn1_identifier>
 113cd90:	2a0003f4 	mov	w20, w0
 113cd94:	35000260 	cbnz	w0, 113cde0 <der_length_custom_type+0x88>
      return err;
   }
   y = id_len;

   if (root->pc == LTC_ASN1_PC_PRIMITIVE) {
 113cd98:	b94026e0 	ldr	w0, [x23, #36]
   y = id_len;
 113cd9c:	f94037f3 	ldr	x19, [sp, #104]
   if (root->pc == LTC_ASN1_PC_PRIMITIVE) {
 113cda0:	34000300 	cbz	w0, 113ce00 <der_length_custom_type+0xa8>
      list = root;
      inlen = 1;
   } else {
      list = root->data;
      inlen = root->size;
 113cda4:	a940f2f6 	ldp	x22, x28, [x23, #8]
   }
   for (i = 0; i < inlen; i++) {
 113cda8:	900000bb 	adrp	x27, 1150000 <Te4+0x258>
               break;

           case LTC_ASN1_SET:
           case LTC_ASN1_SETOF:
           case LTC_ASN1_SEQUENCE:
               if ((err = der_length_sequence(data, size, &x)) != CRYPT_OK) {
 113cdac:	910183f5 	add	x21, sp, #0x60
 113cdb0:	9120437b 	add	x27, x27, #0x810
   for (i = 0; i < inlen; i++) {
 113cdb4:	d280001a 	mov	x26, #0x0                   	// #0
 113cdb8:	b94026e0 	ldr	w0, [x23, #36]
 113cdbc:	eb1c035f 	cmp	x26, x28
 113cdc0:	54000261 	b.ne	113ce0c <der_length_custom_type+0xb4>  // b.any
               err = CRYPT_INVALID_ARG;
               goto LBL_ERR;
       }
   }

   if (root->pc == LTC_ASN1_PC_PRIMITIVE) {
 113cdc4:	35000be0 	cbnz	w0, 113cf40 <der_length_custom_type+0x1e8>
      /* In case it's a PRIMITIVE element we're going
       * to only replace the identifier of the one element
       * by the custom identifier.
       */
      y -= 1;
 113cdc8:	d1000673 	sub	x19, x19, #0x1
      if (payloadlen != NULL) {
 113cdcc:	b4000098 	cbz	x24, 113cddc <der_length_custom_type+0x84>
         *payloadlen = y - id_len;
 113cdd0:	f94037e0 	ldr	x0, [sp, #104]
 113cdd4:	cb000260 	sub	x0, x19, x0
 113cdd8:	f9000300 	str	x0, [x24]
      }
      y += x;
   }

   /* store size */
   *outlen = y;
 113cddc:	f9000333 	str	x19, [x25]

LBL_ERR:
   return err;
}
 113cde0:	2a1403e0 	mov	w0, w20
 113cde4:	a94153f3 	ldp	x19, x20, [sp, #16]
 113cde8:	a9425bf5 	ldp	x21, x22, [sp, #32]
 113cdec:	a94363f7 	ldp	x23, x24, [sp, #48]
 113cdf0:	a9446bf9 	ldp	x25, x26, [sp, #64]
 113cdf4:	a94573fb 	ldp	x27, x28, [sp, #80]
 113cdf8:	a8c77bfd 	ldp	x29, x30, [sp], #112
 113cdfc:	d65f03c0 	ret
 113ce00:	aa1703f6 	mov	x22, x23
      inlen = 1;
 113ce04:	d280003c 	mov	x28, #0x1                   	// #1
 113ce08:	17ffffe8 	b	113cda8 <der_length_custom_type+0x50>
       if (root->pc == LTC_ASN1_PC_PRIMITIVE) {
 113ce0c:	350001e0 	cbnz	w0, 113ce48 <der_length_custom_type+0xf0>
          type = (ltc_asn1_type)list[i].used;
 113ce10:	b9401ac1 	ldr	w1, [x22, #24]
       if (type == LTC_ASN1_EOL) {
 113ce14:	34fffd81 	cbz	w1, 113cdc4 <der_length_custom_type+0x6c>
       if (!list[i].used && list[i].optional) continue;
 113ce18:	b9401ac0 	ldr	w0, [x22, #24]
 113ce1c:	35000060 	cbnz	w0, 113ce28 <der_length_custom_type+0xd0>
 113ce20:	b9401ec0 	ldr	w0, [x22, #28]
 113ce24:	35000420 	cbnz	w0, 113cea8 <der_length_custom_type+0x150>
 113ce28:	51000421 	sub	w1, w1, #0x1
 113ce2c:	7100483f 	cmp	w1, #0x12
       size = list[i].size;
 113ce30:	a9408ec0 	ldp	x0, x3, [x22, #8]
 113ce34:	540009e8 	b.hi	113cf70 <der_length_custom_type+0x218>  // b.pmore
 113ce38:	38614b61 	ldrb	w1, [x27, w1, uxtw]
 113ce3c:	10000062 	adr	x2, 113ce48 <der_length_custom_type+0xf0>
 113ce40:	8b218841 	add	x1, x2, w1, sxtb #2
 113ce44:	d61f0020 	br	x1
          type = list[i].type;
 113ce48:	b94002c1 	ldr	w1, [x22]
 113ce4c:	17fffff2 	b	113ce14 <der_length_custom_type+0xbc>
              if ((err = der_length_boolean(&x)) != CRYPT_OK) {
 113ce50:	aa1503e0 	mov	x0, x21
 113ce54:	97fffd25 	bl	113c2e8 <der_length_boolean>
               if ((err = der_length_sequence(data, size, &x)) != CRYPT_OK) {
 113ce58:	35000900 	cbnz	w0, 113cf78 <der_length_custom_type+0x220>
               y += x;
 113ce5c:	f94033e0 	ldr	x0, [sp, #96]
 113ce60:	8b000273 	add	x19, x19, x0
               break;
 113ce64:	14000011 	b	113cea8 <der_length_custom_type+0x150>
               if ((err = der_length_integer(data, &x)) != CRYPT_OK) {
 113ce68:	aa1503e1 	mov	x1, x21
 113ce6c:	94000505 	bl	113e280 <der_length_integer>
 113ce70:	17fffffa 	b	113ce58 <der_length_custom_type+0x100>
               if ((err = der_length_short_integer(*((unsigned long *)data), &x)) != CRYPT_OK) {
 113ce74:	f9400000 	ldr	x0, [x0]
 113ce78:	aa1503e1 	mov	x1, x21
 113ce7c:	97fff505 	bl	113a290 <der_length_short_integer>
 113ce80:	17fffff6 	b	113ce58 <der_length_custom_type+0x100>
               if ((err = der_length_bit_string(size, &x)) != CRYPT_OK) {
 113ce84:	aa1503e1 	mov	x1, x21
 113ce88:	aa0303e0 	mov	x0, x3
 113ce8c:	97fffc9e 	bl	113c104 <der_length_bit_string>
 113ce90:	17fffff2 	b	113ce58 <der_length_custom_type+0x100>
               if ((err = der_length_octet_string(size, &x)) != CRYPT_OK) {
 113ce94:	aa1503e1 	mov	x1, x21
 113ce98:	aa0303e0 	mov	x0, x3
 113ce9c:	940006c6 	bl	113e9b4 <der_length_octet_string>
 113cea0:	17ffffee 	b	113ce58 <der_length_custom_type+0x100>
               y += 2;
 113cea4:	91000a73 	add	x19, x19, #0x2
   for (i = 0; i < inlen; i++) {
 113cea8:	9100075a 	add	x26, x26, #0x1
 113ceac:	910142d6 	add	x22, x22, #0x50
 113ceb0:	17ffffc2 	b	113cdb8 <der_length_custom_type+0x60>
               if ((err = der_length_object_identifier(data, size, &x)) != CRYPT_OK) {
 113ceb4:	aa1503e2 	mov	x2, x21
 113ceb8:	aa0303e1 	mov	x1, x3
 113cebc:	94000618 	bl	113e71c <der_length_object_identifier>
 113cec0:	17ffffe6 	b	113ce58 <der_length_custom_type+0x100>
               if ((err = der_length_ia5_string(data, size, &x)) != CRYPT_OK) {
 113cec4:	aa1503e2 	mov	x2, x21
 113cec8:	aa0303e1 	mov	x1, x3
 113cecc:	940003cc 	bl	113ddfc <der_length_ia5_string>
 113ced0:	17ffffe2 	b	113ce58 <der_length_custom_type+0x100>
               if ((err = der_length_teletex_string(data, size, &x)) != CRYPT_OK) {
 113ced4:	aa1503e2 	mov	x2, x21
 113ced8:	aa0303e1 	mov	x1, x3
 113cedc:	97fff6ac 	bl	113a98c <der_length_teletex_string>
 113cee0:	17ffffde 	b	113ce58 <der_length_custom_type+0x100>
               if ((err = der_length_printable_string(data, size, &x)) != CRYPT_OK) {
 113cee4:	aa1503e2 	mov	x2, x21
 113cee8:	aa0303e1 	mov	x1, x3
 113ceec:	9400075b 	bl	113ec58 <der_length_printable_string>
 113cef0:	17ffffda 	b	113ce58 <der_length_custom_type+0x100>
               if ((err = der_length_utctime(data, &x)) != CRYPT_OK) {
 113cef4:	aa1503e1 	mov	x1, x21
 113cef8:	97fff5af 	bl	113a5b4 <der_length_utctime>
 113cefc:	17ffffd7 	b	113ce58 <der_length_custom_type+0x100>
               if ((err = der_length_generalizedtime(data, &x)) != CRYPT_OK) {
 113cf00:	aa1503e1 	mov	x1, x21
 113cf04:	9400030d 	bl	113db38 <der_length_generalizedtime>
 113cf08:	17ffffd4 	b	113ce58 <der_length_custom_type+0x100>
               if ((err = der_length_utf8_string(data, size, &x)) != CRYPT_OK) {
 113cf0c:	aa1503e2 	mov	x2, x21
 113cf10:	aa0303e1 	mov	x1, x3
 113cf14:	97fff657 	bl	113a870 <der_length_utf8_string>
 113cf18:	17ffffd0 	b	113ce58 <der_length_custom_type+0x100>
               if ((err = der_length_custom_type(&list[i], &x, NULL)) != CRYPT_OK) {
 113cf1c:	aa1503e1 	mov	x1, x21
 113cf20:	aa1603e0 	mov	x0, x22
 113cf24:	d2800002 	mov	x2, #0x0                   	// #0
 113cf28:	97ffff8c 	bl	113cd58 <der_length_custom_type>
 113cf2c:	17ffffcb 	b	113ce58 <der_length_custom_type+0x100>
               if ((err = der_length_sequence(data, size, &x)) != CRYPT_OK) {
 113cf30:	aa1503e2 	mov	x2, x21
 113cf34:	aa0303e1 	mov	x1, x3
 113cf38:	97fff3b2 	bl	1139e00 <der_length_sequence>
 113cf3c:	17ffffc7 	b	113ce58 <der_length_custom_type+0x100>
      if ((err = der_length_asn1_length(y - id_len, &x)) != CRYPT_OK) {
 113cf40:	f94037e0 	ldr	x0, [sp, #104]
 113cf44:	910183e1 	add	x1, sp, #0x60
 113cf48:	cb000260 	sub	x0, x19, x0
 113cf4c:	9400014d 	bl	113d480 <der_length_asn1_length>
 113cf50:	35000140 	cbnz	w0, 113cf78 <der_length_custom_type+0x220>
      if (payloadlen != NULL) {
 113cf54:	b4000098 	cbz	x24, 113cf64 <der_length_custom_type+0x20c>
         *payloadlen = y - id_len;
 113cf58:	f94037e0 	ldr	x0, [sp, #104]
 113cf5c:	cb000260 	sub	x0, x19, x0
 113cf60:	f9000300 	str	x0, [x24]
      y += x;
 113cf64:	f94033e0 	ldr	x0, [sp, #96]
 113cf68:	8b000273 	add	x19, x19, x0
 113cf6c:	17ffff9c 	b	113cddc <der_length_custom_type+0x84>
       data = list[i].data;
 113cf70:	52800214 	mov	w20, #0x10                  	// #16
 113cf74:	17ffff9b 	b	113cde0 <der_length_custom_type+0x88>
 113cf78:	2a0003f4 	mov	w20, w0
 113cf7c:	17ffff99 	b	113cde0 <der_length_custom_type+0x88>

000000000113cf80 <der_decode_asn1_length>:
*/
int der_decode_asn1_length(const unsigned char *in, unsigned long *inlen, unsigned long *outlen)
{
   unsigned long real_len, decoded_len, offset, i;

   LTC_ARGCHK(in    != NULL);
 113cf80:	b40004a0 	cbz	x0, 113d014 <der_decode_asn1_length+0x94>
   LTC_ARGCHK(inlen != NULL);
 113cf84:	b4000481 	cbz	x1, 113d014 <der_decode_asn1_length+0x94>

   if (*inlen < 1) {
 113cf88:	f9400025 	ldr	x5, [x1]
 113cf8c:	b40004c5 	cbz	x5, 113d024 <der_decode_asn1_length+0xa4>
      return CRYPT_BUFFER_OVERFLOW;
   }

   real_len = in[0];
 113cf90:	39400003 	ldrb	w3, [x0]
 113cf94:	39400006 	ldrb	w6, [x0]

   if (real_len < 128) {
 113cf98:	f101fc7f 	cmp	x3, #0x7f
 113cf9c:	54000389 	b.ls	113d00c <der_decode_asn1_length+0x8c>  // b.plast
      decoded_len = real_len;
      offset = 1;
   } else {
      real_len &= 0x7F;
 113cfa0:	924018c4 	and	x4, x6, #0x7f
      if (real_len == 0) {
 113cfa4:	f24018df 	tst	x6, #0x7f
 113cfa8:	540003a0 	b.eq	113d01c <der_decode_asn1_length+0x9c>  // b.none
         return CRYPT_PK_ASN1_ERROR;
      }
      if (real_len > sizeof(decoded_len)) {
 113cfac:	f100209f 	cmp	x4, #0x8
 113cfb0:	54000069 	b.ls	113cfbc <der_decode_asn1_length+0x3c>  // b.plast
         return CRYPT_OVERFLOW;
 113cfb4:	52800260 	mov	w0, #0x13                  	// #19
   if (outlen != NULL) *outlen = decoded_len;
   if (decoded_len > (*inlen - offset)) return CRYPT_OVERFLOW;
   *inlen = offset;

   return CRYPT_OK;
}
 113cfb8:	d65f03c0 	ret
      if (real_len > (*inlen - 1)) {
 113cfbc:	d10004a5 	sub	x5, x5, #0x1
 113cfc0:	eb0400bf 	cmp	x5, x4
 113cfc4:	54000303 	b.cc	113d024 <der_decode_asn1_length+0xa4>  // b.lo, b.ul, b.last
      offset = 1 + real_len;
 113cfc8:	91000486 	add	x6, x4, #0x1
      for (i = 0; i < real_len; i++) {
 113cfcc:	d2800005 	mov	x5, #0x0                   	// #0
      decoded_len = 0;
 113cfd0:	d2800003 	mov	x3, #0x0                   	// #0
         decoded_len = (decoded_len << 8) | in[1 + i];
 113cfd4:	910004a5 	add	x5, x5, #0x1
      for (i = 0; i < real_len; i++) {
 113cfd8:	eb0400bf 	cmp	x5, x4
         decoded_len = (decoded_len << 8) | in[1 + i];
 113cfdc:	38656807 	ldrb	w7, [x0, x5]
 113cfe0:	aa0320e3 	orr	x3, x7, x3, lsl #8
      for (i = 0; i < real_len; i++) {
 113cfe4:	54ffff83 	b.cc	113cfd4 <der_decode_asn1_length+0x54>  // b.lo, b.ul, b.last
   if (outlen != NULL) *outlen = decoded_len;
 113cfe8:	b4000042 	cbz	x2, 113cff0 <der_decode_asn1_length+0x70>
 113cfec:	f9000043 	str	x3, [x2]
   if (decoded_len > (*inlen - offset)) return CRYPT_OVERFLOW;
 113cff0:	f9400020 	ldr	x0, [x1]
 113cff4:	cb060000 	sub	x0, x0, x6
 113cff8:	eb03001f 	cmp	x0, x3
 113cffc:	54fffdc3 	b.cc	113cfb4 <der_decode_asn1_length+0x34>  // b.lo, b.ul, b.last
   return CRYPT_OK;
 113d000:	52800000 	mov	w0, #0x0                   	// #0
   *inlen = offset;
 113d004:	f9000026 	str	x6, [x1]
   return CRYPT_OK;
 113d008:	17ffffec 	b	113cfb8 <der_decode_asn1_length+0x38>
      offset = 1;
 113d00c:	d2800026 	mov	x6, #0x1                   	// #1
 113d010:	17fffff6 	b	113cfe8 <der_decode_asn1_length+0x68>
   LTC_ARGCHK(in    != NULL);
 113d014:	52800200 	mov	w0, #0x10                  	// #16
 113d018:	17ffffe8 	b	113cfb8 <der_decode_asn1_length+0x38>
         return CRYPT_PK_ASN1_ERROR;
 113d01c:	52800280 	mov	w0, #0x14                  	// #20
 113d020:	17ffffe6 	b	113cfb8 <der_decode_asn1_length+0x38>
      return CRYPT_BUFFER_OVERFLOW;
 113d024:	528000c0 	mov	w0, #0x6                   	// #6
 113d028:	17ffffe4 	b	113cfb8 <der_decode_asn1_length+0x38>

000000000113d02c <der_decode_asn1_identifier>:
{
   ulong64 tmp;
   unsigned long tag_len;
   int err;

   LTC_ARGCHK(id    != NULL);
 113d02c:	b4000842 	cbz	x2, 113d134 <der_decode_asn1_identifier+0x108>
   LTC_ARGCHK(in    != NULL);
 113d030:	b4000820 	cbz	x0, 113d134 <der_decode_asn1_identifier+0x108>
   LTC_ARGCHK(inlen != NULL);
 113d034:	b4000801 	cbz	x1, 113d134 <der_decode_asn1_identifier+0x108>

   if (*inlen == 0) {
 113d038:	f9400028 	ldr	x8, [x1]
 113d03c:	b4000808 	cbz	x8, 113d13c <der_decode_asn1_identifier+0x110>
      return CRYPT_BUFFER_OVERFLOW;
   }

   tag_len = 1;
   id->klass = (in[0] >> 6) & 0x3;
 113d040:	39400006 	ldrb	w6, [x0]
 113d044:	53067cc6 	lsr	w6, w6, #6
 113d048:	b9002046 	str	w6, [x2, #32]
   id->pc = (in[0] >> 5) & 0x1;
 113d04c:	39400005 	ldrb	w5, [x0]
 113d050:	d34514a5 	ubfx	x5, x5, #5, #1
 113d054:	b9002445 	str	w5, [x2, #36]
   id->tag = in[0] & 0x1f;
 113d058:	39400003 	ldrb	w3, [x0]
 113d05c:	12001063 	and	w3, w3, #0x1f

   err = CRYPT_OK;
   if (id->tag == 0x1f) {
 113d060:	71007c7f 	cmp	w3, #0x1f
 113d064:	54000561 	b.ne	113d110 <der_decode_asn1_identifier+0xe4>  // b.any
   tag_len = 1;
 113d068:	d2800023 	mov	x3, #0x1                   	// #1
      id->tag = 0;
 113d06c:	f900145f 	str	xzr, [x2, #40]
      do {
         if (*inlen < tag_len) {
 113d070:	eb03011f 	cmp	x8, x3
 113d074:	54000082 	b.cs	113d084 <der_decode_asn1_identifier+0x58>  // b.hs, b.nlast
   }

   if (err != CRYPT_OK) {
      id->pc = 0;
      id->klass = 0;
      id->tag = 0;
 113d078:	a9027c5f 	stp	xzr, xzr, [x2, #32]
            id->type = LTC_ASN1_CUSTOM_TYPE;
         }
      }
   }

   return CRYPT_OK;
 113d07c:	52800000 	mov	w0, #0x0                   	// #0
}
 113d080:	d65f03c0 	ret
         id->tag <<= 7;
 113d084:	f9401444 	ldr	x4, [x2, #40]
 113d088:	d379e087 	lsl	x7, x4, #7
 113d08c:	f9001447 	str	x7, [x2, #40]
         id->tag |= in[tag_len] & 0x7f;
 113d090:	38636804 	ldrb	w4, [x0, x3]
 113d094:	92401884 	and	x4, x4, #0x7f
 113d098:	aa070084 	orr	x4, x4, x7
 113d09c:	f9001444 	str	x4, [x2, #40]
         tmp = in[tag_len] & 0x80;
 113d0a0:	38636807 	ldrb	w7, [x0, x3]
         tag_len++;
 113d0a4:	91000463 	add	x3, x3, #0x1
      } while ((tmp != 0) && (tag_len < 10));
 113d0a8:	13001ce7 	sxtb	w7, w7
 113d0ac:	710000ff 	cmp	w7, #0x0
 113d0b0:	fa49b862 	ccmp	x3, #0x9, #0x2, lt  // lt = tstop
 113d0b4:	54fffde9 	b.ls	113d070 <der_decode_asn1_identifier+0x44>  // b.plast
      if (tmp != 0) {
 113d0b8:	37fffe07 	tbnz	w7, #31, 113d078 <der_decode_asn1_identifier+0x4c>
      } else if (id->tag < 0x1f) {
 113d0bc:	f100789f 	cmp	x4, #0x1e
 113d0c0:	54fffdc9 	b.ls	113d078 <der_decode_asn1_identifier+0x4c>  // b.plast
      *inlen = tag_len;
 113d0c4:	f9000023 	str	x3, [x1]
      if ((id->klass == LTC_ASN1_CL_UNIVERSAL) &&
 113d0c8:	35000326 	cbnz	w6, 113d12c <der_decode_asn1_identifier+0x100>
            (id->tag < der_asn1_tag_to_type_map_sz) &&
 113d0cc:	b00000e1 	adrp	x1, 115a000 <__scattered_array_1phys_mem_map+0x8>
 113d0d0:	f9401440 	ldr	x0, [x2, #40]
 113d0d4:	f9424023 	ldr	x3, [x1, #1152]
      if ((id->klass == LTC_ASN1_CL_UNIVERSAL) &&
 113d0d8:	f9400063 	ldr	x3, [x3]
 113d0dc:	eb03001f 	cmp	x0, x3
 113d0e0:	54000202 	b.cs	113d120 <der_decode_asn1_identifier+0xf4>  // b.hs, b.nlast
            (id->tag < der_asn1_tag_to_type_map_sz) &&
 113d0e4:	f100701f 	cmp	x0, #0x1c
 113d0e8:	540001c8 	b.hi	113d120 <der_decode_asn1_identifier+0xf4>  // b.pmore
            (id->pc == tag_constructed_map[id->tag])) {
 113d0ec:	900000e3 	adrp	x3, 1159000 <Worder+0x2854>
 113d0f0:	91264c63 	add	x3, x3, #0x993
 113d0f4:	38606863 	ldrb	w3, [x3, x0]
            (id->tag < tag_constructed_map_sz) &&
 113d0f8:	6b0300bf 	cmp	w5, w3
 113d0fc:	54000121 	b.ne	113d120 <der_decode_asn1_identifier+0xf4>  // b.any
         id->type = der_asn1_tag_to_type_map[id->tag];
 113d100:	f9421421 	ldr	x1, [x1, #1064]
 113d104:	b8607820 	ldr	w0, [x1, x0, lsl #2]
 113d108:	b9000040 	str	w0, [x2]
 113d10c:	17ffffdc 	b	113d07c <der_decode_asn1_identifier+0x50>
   id->tag = in[0] & 0x1f;
 113d110:	92401c63 	and	x3, x3, #0xff
 113d114:	f9001443 	str	x3, [x2, #40]
   tag_len = 1;
 113d118:	d2800023 	mov	x3, #0x1                   	// #1
 113d11c:	17ffffea 	b	113d0c4 <der_decode_asn1_identifier+0x98>
         if ((id->klass == LTC_ASN1_CL_UNIVERSAL) && (id->tag == 0)) {
 113d120:	b5000060 	cbnz	x0, 113d12c <der_decode_asn1_identifier+0x100>
            id->type = LTC_ASN1_EOL;
 113d124:	b900005f 	str	wzr, [x2]
 113d128:	17ffffd6 	b	113d080 <der_decode_asn1_identifier+0x54>
            id->type = LTC_ASN1_CUSTOM_TYPE;
 113d12c:	52800260 	mov	w0, #0x13                  	// #19
 113d130:	17fffff6 	b	113d108 <der_decode_asn1_identifier+0xdc>
   LTC_ARGCHK(id    != NULL);
 113d134:	52800200 	mov	w0, #0x10                  	// #16
 113d138:	17ffffd2 	b	113d080 <der_decode_asn1_identifier+0x54>
      return CRYPT_BUFFER_OVERFLOW;
 113d13c:	528000c0 	mov	w0, #0x6                   	// #6
 113d140:	17ffffd0 	b	113d080 <der_decode_asn1_identifier+0x54>

000000000113d144 <der_encode_asn1_identifier>:
int der_encode_asn1_identifier(const ltc_asn1_list *id, unsigned char *out, unsigned long *outlen)
{
   ulong64 tmp;
   unsigned long tag_len;

   LTC_ARGCHK(id  != NULL);
 113d144:	b40009a0 	cbz	x0, 113d278 <der_encode_asn1_identifier+0x134>
   LTC_ARGCHK(outlen != NULL);
 113d148:	b4000982 	cbz	x2, 113d278 <der_encode_asn1_identifier+0x134>

   if (id->type != LTC_ASN1_CUSTOM_TYPE) {
 113d14c:	b9400003 	ldr	w3, [x0]
 113d150:	71004c7f 	cmp	w3, #0x13
 113d154:	54000220 	b.eq	113d198 <der_encode_asn1_identifier+0x54>  // b.none
      if ((unsigned)id->type >= der_asn1_type_to_identifier_map_sz) {
 113d158:	b00000e0 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 113d15c:	2a0303e4 	mov	w4, w3
 113d160:	f9424405 	ldr	x5, [x0, #1160]
 113d164:	f94000a5 	ldr	x5, [x5]
 113d168:	eb2340bf 	cmp	x5, w3, uxtw
 113d16c:	54000869 	b.ls	113d278 <der_encode_asn1_identifier+0x134>  // b.plast
         return CRYPT_INVALID_ARG;
      }
      if (der_asn1_type_to_identifier_map[id->type] == -1) {
 113d170:	f9415400 	ldr	x0, [x0, #680]
 113d174:	b8647800 	ldr	w0, [x0, x4, lsl #2]
 113d178:	3100041f 	cmn	w0, #0x1
 113d17c:	540007e0 	b.eq	113d278 <der_encode_asn1_identifier+0x134>  // b.none
         return CRYPT_INVALID_ARG;
      }
      if (out != NULL) {
 113d180:	b4000041 	cbz	x1, 113d188 <der_encode_asn1_identifier+0x44>
         *out = der_asn1_type_to_identifier_map[id->type];
 113d184:	39000020 	strb	w0, [x1]
      }
      *outlen = 1;
 113d188:	d2800020 	mov	x0, #0x1                   	// #1
 113d18c:	f9000040 	str	x0, [x2]
         out[tag_len] &= ~0x80;
      }
      *outlen = tag_len + 1;
   }

   return CRYPT_OK;
 113d190:	52800000 	mov	w0, #0x0                   	// #0
 113d194:	1400000f 	b	113d1d0 <der_encode_asn1_identifier+0x8c>
   if (id->klass < LTC_ASN1_CL_UNIVERSAL || id->klass > LTC_ASN1_CL_PRIVATE) {
 113d198:	b9402003 	ldr	w3, [x0, #32]
 113d19c:	71000c7f 	cmp	w3, #0x3
 113d1a0:	540006c8 	b.hi	113d278 <der_encode_asn1_identifier+0x134>  // b.pmore
   if (id->pc < LTC_ASN1_PC_PRIMITIVE || id->pc > LTC_ASN1_PC_CONSTRUCTED) {
 113d1a4:	b9402404 	ldr	w4, [x0, #36]
 113d1a8:	7100049f 	cmp	w4, #0x1
 113d1ac:	54000668 	b.hi	113d278 <der_encode_asn1_identifier+0x134>  // b.pmore
   if (id->tag > (ULONG_MAX >> (8 + 7))) {
 113d1b0:	f9401406 	ldr	x6, [x0, #40]
 113d1b4:	92ffffc5 	mov	x5, #0x1ffffffffffff       	// #562949953421311
 113d1b8:	eb0500df 	cmp	x6, x5
 113d1bc:	540005e8 	b.hi	113d278 <der_encode_asn1_identifier+0x134>  // b.pmore
   if (out != NULL) {
 113d1c0:	b4000101 	cbz	x1, 113d1e0 <der_encode_asn1_identifier+0x9c>
      if (*outlen < 1) {
 113d1c4:	f9400045 	ldr	x5, [x2]
 113d1c8:	b5000065 	cbnz	x5, 113d1d4 <der_encode_asn1_identifier+0x90>
         return CRYPT_BUFFER_OVERFLOW;
 113d1cc:	528000c0 	mov	w0, #0x6                   	// #6
}
 113d1d0:	d65f03c0 	ret
      out[0] = id->klass << 6 | id->pc << 5;
 113d1d4:	531b0884 	ubfiz	w4, w4, #5, #3
 113d1d8:	2a031883 	orr	w3, w4, w3, lsl #6
 113d1dc:	39000023 	strb	w3, [x1]
   if (id->tag < 0x1f) {
 113d1e0:	f9401405 	ldr	x5, [x0, #40]
 113d1e4:	f10078bf 	cmp	x5, #0x1e
 113d1e8:	540000c8 	b.hi	113d200 <der_encode_asn1_identifier+0xbc>  // b.pmore
      if (out != NULL) {
 113d1ec:	b4fffce1 	cbz	x1, 113d188 <der_encode_asn1_identifier+0x44>
         out[0] |= id->tag & 0x1f;
 113d1f0:	39400020 	ldrb	w0, [x1]
 113d1f4:	2a050005 	orr	w5, w0, w5
 113d1f8:	39000025 	strb	w5, [x1]
 113d1fc:	17ffffe3 	b	113d188 <der_encode_asn1_identifier+0x44>
      tag_len = 0;
 113d200:	d2800003 	mov	x3, #0x0                   	// #0
         tag_len++;
 113d204:	aa0303e4 	mov	x4, x3
         tmp >>= 7;
 113d208:	d347fca5 	lsr	x5, x5, #7
         tag_len++;
 113d20c:	91000463 	add	x3, x3, #0x1
      } while (tmp);
 113d210:	b5ffffa5 	cbnz	x5, 113d204 <der_encode_asn1_identifier+0xc0>
      if (out != NULL) {
 113d214:	91000887 	add	x7, x4, #0x2
 113d218:	b40001e1 	cbz	x1, 113d254 <der_encode_asn1_identifier+0x110>
         if (*outlen < tag_len + 1) {
 113d21c:	f9400045 	ldr	x5, [x2]
 113d220:	eb0700bf 	cmp	x5, x7
 113d224:	54fffd43 	b.cc	113d1cc <der_encode_asn1_identifier+0x88>  // b.lo, b.ul, b.last
         out[0] |= 0x1f;
 113d228:	39400025 	ldrb	w5, [x1]
         for (tmp = 1; tmp <= tag_len; ++tmp) {
 113d22c:	d2800026 	mov	x6, #0x1                   	// #1
         out[0] |= 0x1f;
 113d230:	320010a5 	orr	w5, w5, #0x1f
 113d234:	39000025 	strb	w5, [x1]
         for (tmp = 1; tmp <= tag_len; ++tmp) {
 113d238:	528000e5 	mov	w5, #0x7                   	// #7
 113d23c:	1b057c84 	mul	w4, w4, w5
 113d240:	eb0300df 	cmp	x6, x3
 113d244:	540000c9 	b.ls	113d25c <der_encode_asn1_identifier+0x118>  // b.plast
         out[tag_len] &= ~0x80;
 113d248:	38636820 	ldrb	w0, [x1, x3]
 113d24c:	12001800 	and	w0, w0, #0x7f
 113d250:	38236820 	strb	w0, [x1, x3]
      *outlen = tag_len + 1;
 113d254:	f9000047 	str	x7, [x2]
 113d258:	17ffffce 	b	113d190 <der_encode_asn1_identifier+0x4c>
            out[tmp] = ((id->tag >> (7 * (tag_len - tmp))) & 0x7f) | 0x80;
 113d25c:	f9401405 	ldr	x5, [x0, #40]
 113d260:	9ac424a5 	lsr	x5, x5, x4
 113d264:	51001c84 	sub	w4, w4, #0x7
 113d268:	321960a5 	orr	w5, w5, #0xffffff80
 113d26c:	38266825 	strb	w5, [x1, x6]
         for (tmp = 1; tmp <= tag_len; ++tmp) {
 113d270:	910004c6 	add	x6, x6, #0x1
 113d274:	17fffff3 	b	113d240 <der_encode_asn1_identifier+0xfc>
   LTC_ARGCHK(id  != NULL);
 113d278:	52800200 	mov	w0, #0x10                  	// #16
 113d27c:	17ffffd5 	b	113d1d0 <der_encode_asn1_identifier+0x8c>

000000000113d280 <der_encode_asn1_length>:
*/
int der_encode_asn1_length(unsigned long len, unsigned char *out, unsigned long *outlen)
{
   unsigned long x, y;

   LTC_ARGCHK(outlen != NULL);
 113d280:	b4000ee2 	cbz	x2, 113d45c <der_encode_asn1_length+0x1dc>
 113d284:	aa0003e4 	mov	x4, x0

   x = len;
   y = 0;
 113d288:	d2800003 	mov	x3, #0x0                   	// #0

   while(x != 0) {
 113d28c:	b5000124 	cbnz	x4, 113d2b0 <der_encode_asn1_length+0x30>
      y++;
      x >>= 8;
   }
   if (y == 0) {
 113d290:	b4000ea3 	cbz	x3, 113d464 <der_encode_asn1_length+0x1e4>
      return CRYPT_PK_ASN1_ERROR;
   }

   if (out == NULL) {
 113d294:	b5000141 	cbnz	x1, 113d2bc <der_encode_asn1_length+0x3c>
      if (len < 128) {
 113d298:	f101fc1f 	cmp	x0, #0x7f
 113d29c:	54000049 	b.ls	113d2a4 <der_encode_asn1_length+0x24>  // b.plast
         x = y;
      } else {
         x = y + 1;
 113d2a0:	91000463 	add	x3, x3, #0x1
      }
      #endif
   }
   *outlen = x;

   return CRYPT_OK;
 113d2a4:	52800000 	mov	w0, #0x0                   	// #0
   *outlen = x;
 113d2a8:	f9000043 	str	x3, [x2]
}
 113d2ac:	d65f03c0 	ret
      y++;
 113d2b0:	91000463 	add	x3, x3, #0x1
      x >>= 8;
 113d2b4:	d348fc84 	lsr	x4, x4, #8
 113d2b8:	17fffff5 	b	113d28c <der_encode_asn1_length+0xc>
      if (*outlen < y) {
 113d2bc:	f9400044 	ldr	x4, [x2]
 113d2c0:	eb03009f 	cmp	x4, x3
 113d2c4:	54000d43 	b.cc	113d46c <der_encode_asn1_length+0x1ec>  // b.lo, b.ul, b.last
      if (len < 128) {
 113d2c8:	12001c03 	and	w3, w0, #0xff
 113d2cc:	f101fc1f 	cmp	x0, #0x7f
 113d2d0:	54000088 	b.hi	113d2e0 <der_encode_asn1_length+0x60>  // b.pmore
         out[x++] = (unsigned char)len;
 113d2d4:	39000023 	strb	w3, [x1]
 113d2d8:	d2800023 	mov	x3, #0x1                   	// #1
 113d2dc:	17fffff2 	b	113d2a4 <der_encode_asn1_length+0x24>
      } else if (len <= 0xffUL) {
 113d2e0:	f103fc1f 	cmp	x0, #0xff
 113d2e4:	540000c8 	b.hi	113d2fc <der_encode_asn1_length+0x7c>  // b.pmore
         out[x++] = 0x81;
 113d2e8:	12800fc0 	mov	w0, #0xffffff81            	// #-127
 113d2ec:	39000020 	strb	w0, [x1]
         out[x++] = (unsigned char)len;
 113d2f0:	39000423 	strb	w3, [x1, #1]
 113d2f4:	d2800043 	mov	x3, #0x2                   	// #2
 113d2f8:	17ffffeb 	b	113d2a4 <der_encode_asn1_length+0x24>
      } else if (len <= 0xffffUL) {
 113d2fc:	d29fffe5 	mov	x5, #0xffff                	// #65535
 113d300:	53083c04 	ubfx	w4, w0, #8, #8
 113d304:	eb05001f 	cmp	x0, x5
 113d308:	540000e8 	b.hi	113d324 <der_encode_asn1_length+0xa4>  // b.pmore
         out[x++] = 0x82;
 113d30c:	12800fa0 	mov	w0, #0xffffff82            	// #-126
 113d310:	39000020 	strb	w0, [x1]
         out[x++] = (unsigned char)((len>>8UL)&255);
 113d314:	39000424 	strb	w4, [x1, #1]
         out[x++] = (unsigned char)(len&255);
 113d318:	39000823 	strb	w3, [x1, #2]
 113d31c:	d2800063 	mov	x3, #0x3                   	// #3
 113d320:	17ffffe1 	b	113d2a4 <der_encode_asn1_length+0x24>
      } else if (len <= 0xffffffUL) {
 113d324:	b2405fe6 	mov	x6, #0xffffff              	// #16777215
 113d328:	53105c05 	ubfx	w5, w0, #16, #8
 113d32c:	eb06001f 	cmp	x0, x6
 113d330:	54000108 	b.hi	113d350 <der_encode_asn1_length+0xd0>  // b.pmore
         out[x++] = 0x83;
 113d334:	12800f80 	mov	w0, #0xffffff83            	// #-125
 113d338:	39000020 	strb	w0, [x1]
         out[x++] = (unsigned char)((len>>16UL)&255);
 113d33c:	39000425 	strb	w5, [x1, #1]
         out[x++] = (unsigned char)((len>>8UL)&255);
 113d340:	39000824 	strb	w4, [x1, #2]
         out[x++] = (unsigned char)(len&255);
 113d344:	39000c23 	strb	w3, [x1, #3]
 113d348:	d2800083 	mov	x3, #0x4                   	// #4
 113d34c:	17ffffd6 	b	113d2a4 <der_encode_asn1_length+0x24>
      } else if (len <= 0xffffffffUL) {
 113d350:	b2407fe7 	mov	x7, #0xffffffff            	// #4294967295
 113d354:	53187c06 	lsr	w6, w0, #24
 113d358:	eb07001f 	cmp	x0, x7
 113d35c:	54000128 	b.hi	113d380 <der_encode_asn1_length+0x100>  // b.pmore
         out[x++] = 0x84;
 113d360:	12800f60 	mov	w0, #0xffffff84            	// #-124
 113d364:	39000020 	strb	w0, [x1]
         out[x++] = (unsigned char)((len>>24UL)&255);
 113d368:	39000426 	strb	w6, [x1, #1]
         out[x++] = (unsigned char)((len>>16UL)&255);
 113d36c:	39000825 	strb	w5, [x1, #2]
         out[x++] = (unsigned char)((len>>8UL)&255);
 113d370:	39000c24 	strb	w4, [x1, #3]
         out[x++] = (unsigned char)(len&255);
 113d374:	39001023 	strb	w3, [x1, #4]
 113d378:	d28000a3 	mov	x3, #0x5                   	// #5
 113d37c:	17ffffca 	b	113d2a4 <der_encode_asn1_length+0x24>
      } else if (len <= 0xffffffffffULL) {
 113d380:	b2409fe8 	mov	x8, #0xffffffffff          	// #1099511627775
 113d384:	d3609c07 	ubfx	x7, x0, #32, #8
 113d388:	eb08001f 	cmp	x0, x8
 113d38c:	54000148 	b.hi	113d3b4 <der_encode_asn1_length+0x134>  // b.pmore
         out[x++] = 0x85;
 113d390:	12800f40 	mov	w0, #0xffffff85            	// #-123
 113d394:	39000020 	strb	w0, [x1]
         out[x++] = (unsigned char)((len>>32ULL)&255);
 113d398:	39000427 	strb	w7, [x1, #1]
         out[x++] = (unsigned char)((len>>24ULL)&255);
 113d39c:	39000826 	strb	w6, [x1, #2]
         out[x++] = (unsigned char)((len>>16ULL)&255);
 113d3a0:	39000c25 	strb	w5, [x1, #3]
         out[x++] = (unsigned char)((len>>8ULL)&255);
 113d3a4:	39001024 	strb	w4, [x1, #4]
         out[x++] = (unsigned char)(len&255);
 113d3a8:	39001423 	strb	w3, [x1, #5]
 113d3ac:	d28000c3 	mov	x3, #0x6                   	// #6
 113d3b0:	17ffffbd 	b	113d2a4 <der_encode_asn1_length+0x24>
      } else if (len <= 0xffffffffffffULL) {
 113d3b4:	92ffffe9 	mov	x9, #0xffffffffffff        	// #281474976710655
 113d3b8:	d368bc08 	ubfx	x8, x0, #40, #8
 113d3bc:	eb09001f 	cmp	x0, x9
 113d3c0:	54000168 	b.hi	113d3ec <der_encode_asn1_length+0x16c>  // b.pmore
         out[x++] = 0x86;
 113d3c4:	12800f20 	mov	w0, #0xffffff86            	// #-122
 113d3c8:	39000020 	strb	w0, [x1]
         out[x++] = (unsigned char)((len>>40ULL)&255);
 113d3cc:	39000428 	strb	w8, [x1, #1]
         out[x++] = (unsigned char)((len>>32ULL)&255);
 113d3d0:	39000827 	strb	w7, [x1, #2]
         out[x++] = (unsigned char)((len>>24ULL)&255);
 113d3d4:	39000c26 	strb	w6, [x1, #3]
         out[x++] = (unsigned char)((len>>16ULL)&255);
 113d3d8:	39001025 	strb	w5, [x1, #4]
         out[x++] = (unsigned char)((len>>8ULL)&255);
 113d3dc:	39001424 	strb	w4, [x1, #5]
         out[x++] = (unsigned char)(len&255);
 113d3e0:	39001823 	strb	w3, [x1, #6]
 113d3e4:	d28000e3 	mov	x3, #0x7                   	// #7
 113d3e8:	17ffffaf 	b	113d2a4 <der_encode_asn1_length+0x24>
      } else if (len <= 0xffffffffffffffULL) {
 113d3ec:	92ffe00a 	mov	x10, #0xffffffffffffff      	// #72057594037927935
 113d3f0:	d370dc09 	ubfx	x9, x0, #48, #8
 113d3f4:	eb0a001f 	cmp	x0, x10
 113d3f8:	54000188 	b.hi	113d428 <der_encode_asn1_length+0x1a8>  // b.pmore
         out[x++] = 0x87;
 113d3fc:	12800f00 	mov	w0, #0xffffff87            	// #-121
 113d400:	39000020 	strb	w0, [x1]
         out[x++] = (unsigned char)((len>>48ULL)&255);
 113d404:	39000429 	strb	w9, [x1, #1]
         out[x++] = (unsigned char)((len>>40ULL)&255);
 113d408:	39000828 	strb	w8, [x1, #2]
         out[x++] = (unsigned char)((len>>32ULL)&255);
 113d40c:	39000c27 	strb	w7, [x1, #3]
         out[x++] = (unsigned char)((len>>24ULL)&255);
 113d410:	39001026 	strb	w6, [x1, #4]
         out[x++] = (unsigned char)((len>>16ULL)&255);
 113d414:	39001425 	strb	w5, [x1, #5]
         out[x++] = (unsigned char)((len>>8ULL)&255);
 113d418:	39001824 	strb	w4, [x1, #6]
         out[x++] = (unsigned char)(len&255);
 113d41c:	39001c23 	strb	w3, [x1, #7]
 113d420:	d2800103 	mov	x3, #0x8                   	// #8
 113d424:	17ffffa0 	b	113d2a4 <der_encode_asn1_length+0x24>
         out[x++] = (unsigned char)((len>>56ULL)&255);
 113d428:	d378fc00 	lsr	x0, x0, #56
         out[x++] = 0x88;
 113d42c:	12800eea 	mov	w10, #0xffffff88            	// #-120
 113d430:	3900002a 	strb	w10, [x1]
         out[x++] = (unsigned char)((len>>56ULL)&255);
 113d434:	39000420 	strb	w0, [x1, #1]
         out[x++] = (unsigned char)((len>>48ULL)&255);
 113d438:	39000829 	strb	w9, [x1, #2]
         out[x++] = (unsigned char)((len>>40ULL)&255);
 113d43c:	39000c28 	strb	w8, [x1, #3]
         out[x++] = (unsigned char)((len>>32ULL)&255);
 113d440:	39001027 	strb	w7, [x1, #4]
         out[x++] = (unsigned char)((len>>24ULL)&255);
 113d444:	39001426 	strb	w6, [x1, #5]
         out[x++] = (unsigned char)((len>>16ULL)&255);
 113d448:	39001825 	strb	w5, [x1, #6]
         out[x++] = (unsigned char)((len>>8ULL)&255);
 113d44c:	39001c24 	strb	w4, [x1, #7]
         out[x++] = (unsigned char)(len&255);
 113d450:	39002023 	strb	w3, [x1, #8]
 113d454:	d2800123 	mov	x3, #0x9                   	// #9
 113d458:	17ffff93 	b	113d2a4 <der_encode_asn1_length+0x24>
   LTC_ARGCHK(outlen != NULL);
 113d45c:	52800200 	mov	w0, #0x10                  	// #16
 113d460:	17ffff93 	b	113d2ac <der_encode_asn1_length+0x2c>
      return CRYPT_PK_ASN1_ERROR;
 113d464:	52800280 	mov	w0, #0x14                  	// #20
 113d468:	17ffff91 	b	113d2ac <der_encode_asn1_length+0x2c>
         return CRYPT_BUFFER_OVERFLOW;
 113d46c:	528000c0 	mov	w0, #0x6                   	// #6
 113d470:	17ffff8f 	b	113d2ac <der_encode_asn1_length+0x2c>

000000000113d474 <der_length_asn1_identifier>:
  @return CRYPT_OK if successful
*/

int der_length_asn1_identifier(const ltc_asn1_list *id, unsigned long *idlen)
{
   return der_encode_asn1_identifier(id, NULL, idlen);
 113d474:	aa0103e2 	mov	x2, x1
 113d478:	d2800001 	mov	x1, #0x0                   	// #0
 113d47c:	17ffff32 	b	113d144 <der_encode_asn1_identifier>

000000000113d480 <der_length_asn1_length>:
  @param outlen   [out] The length that's required to store len
  @return CRYPT_OK if successful
*/
int der_length_asn1_length(unsigned long len, unsigned long *outlen)
{
   return der_encode_asn1_length(len, NULL, outlen);
 113d480:	aa0103e2 	mov	x2, x1
 113d484:	d2800001 	mov	x1, #0x0                   	// #0
 113d488:	17ffff7e 	b	113d280 <der_encode_asn1_length>

000000000113d48c <der_encode_generalizedtime>:
  @param outlen       [in/out] The length of the DER encoding
  @return CRYPT_OK if successful
*/
int der_encode_generalizedtime(const ltc_generalizedtime *gtime,
                                     unsigned char       *out, unsigned long *outlen)
{
 113d48c:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
 113d490:	910003fd 	mov	x29, sp
 113d494:	a90153f3 	stp	x19, x20, [sp, #16]
 113d498:	a9025bf5 	stp	x21, x22, [sp, #32]
 113d49c:	a90363f7 	stp	x23, x24, [sp, #48]
 113d4a0:	a9046bf9 	stp	x25, x26, [sp, #64]
 113d4a4:	a90573fb 	stp	x27, x28, [sp, #80]
    unsigned long x, tmplen;
    int           err;

    LTC_ARGCHK(gtime != NULL);
 113d4a8:	b4001c80 	cbz	x0, 113d838 <der_encode_generalizedtime+0x3ac>
 113d4ac:	aa0103f5 	mov	x21, x1
    LTC_ARGCHK(out     != NULL);
 113d4b0:	b4001c41 	cbz	x1, 113d838 <der_encode_generalizedtime+0x3ac>
 113d4b4:	aa0203f9 	mov	x25, x2
    LTC_ARGCHK(outlen  != NULL);
 113d4b8:	b4001c02 	cbz	x2, 113d838 <der_encode_generalizedtime+0x3ac>
 113d4bc:	aa0003f4 	mov	x20, x0

    if ((err = der_length_generalizedtime(gtime, &tmplen)) != CRYPT_OK) {
 113d4c0:	9101e3e1 	add	x1, sp, #0x78
 113d4c4:	9400019d 	bl	113db38 <der_length_generalizedtime>
 113d4c8:	2a0003f8 	mov	w24, w0
 113d4cc:	350000e0 	cbnz	w0, 113d4e8 <der_encode_generalizedtime+0x5c>
       return err;
    }
    if (tmplen > *outlen) {
 113d4d0:	f9400321 	ldr	x1, [x25]
 113d4d4:	f9403fe0 	ldr	x0, [sp, #120]
 113d4d8:	eb00003f 	cmp	x1, x0
 113d4dc:	54000162 	b.cs	113d508 <der_encode_generalizedtime+0x7c>  // b.hs, b.nlast
        *outlen = tmplen;
        return CRYPT_BUFFER_OVERFLOW;
 113d4e0:	528000d8 	mov	w24, #0x6                   	// #6
        *outlen = tmplen;
 113d4e4:	f9000320 	str	x0, [x25]
    out[1] = (unsigned char)(x - 2);

    /* all good let's return */
    *outlen = x;
    return CRYPT_OK;
}
 113d4e8:	2a1803e0 	mov	w0, w24
 113d4ec:	a94153f3 	ldp	x19, x20, [sp, #16]
 113d4f0:	a9425bf5 	ldp	x21, x22, [sp, #32]
 113d4f4:	a94363f7 	ldp	x23, x24, [sp, #48]
 113d4f8:	a9446bf9 	ldp	x25, x26, [sp, #64]
 113d4fc:	a94573fb 	ldp	x27, x28, [sp, #80]
 113d500:	a8c87bfd 	ldp	x29, x30, [sp], #128
 113d504:	d65f03c0 	ret
    out[0] = 0x18;
 113d508:	52800300 	mov	w0, #0x18                  	// #24
 113d50c:	390002a0 	strb	w0, [x21]
    STORE_V4(gtime->YYYY);
 113d510:	52807d01 	mov	w1, #0x3e8                 	// #1000
 113d514:	52800153 	mov	w19, #0xa                   	// #10
 113d518:	b9400280 	ldr	w0, [x20]
 113d51c:	b00000d7 	adrp	x23, 1156000 <ta_pub_key_modulus+0x7>
 113d520:	91331ef6 	add	x22, x23, #0xcc7
 113d524:	1ac10800 	udiv	w0, w0, w1
 113d528:	1ad30801 	udiv	w1, w0, w19
 113d52c:	1b138020 	msub	w0, w1, w19, w0
 113d530:	38606ac0 	ldrb	w0, [x22, x0]
 113d534:	94000213 	bl	113dd80 <der_ia5_char_encode>
 113d538:	39000aa0 	strb	w0, [x21, #2]
 113d53c:	52800c81 	mov	w1, #0x64                  	// #100
 113d540:	b9400280 	ldr	w0, [x20]
 113d544:	1ac10800 	udiv	w0, w0, w1
 113d548:	1ad30801 	udiv	w1, w0, w19
 113d54c:	1b138020 	msub	w0, w1, w19, w0
 113d550:	38606ac0 	ldrb	w0, [x22, x0]
 113d554:	9400020b 	bl	113dd80 <der_ia5_char_encode>
 113d558:	39000ea0 	strb	w0, [x21, #3]
 113d55c:	b9400280 	ldr	w0, [x20]
 113d560:	1ad30800 	udiv	w0, w0, w19
 113d564:	1ad30801 	udiv	w1, w0, w19
 113d568:	1b138020 	msub	w0, w1, w19, w0
 113d56c:	38606ac0 	ldrb	w0, [x22, x0]
 113d570:	94000204 	bl	113dd80 <der_ia5_char_encode>
 113d574:	390012a0 	strb	w0, [x21, #4]
 113d578:	b9400281 	ldr	w1, [x20]
 113d57c:	1ad30820 	udiv	w0, w1, w19
 113d580:	1b138400 	msub	w0, w0, w19, w1
 113d584:	38606ac0 	ldrb	w0, [x22, x0]
 113d588:	940001fe 	bl	113dd80 <der_ia5_char_encode>
 113d58c:	390016a0 	strb	w0, [x21, #5]
    STORE_V(gtime->MM);
 113d590:	b9400680 	ldr	w0, [x20, #4]
 113d594:	1ad30800 	udiv	w0, w0, w19
 113d598:	1ad30801 	udiv	w1, w0, w19
 113d59c:	1b138020 	msub	w0, w1, w19, w0
 113d5a0:	38606ac0 	ldrb	w0, [x22, x0]
 113d5a4:	940001f7 	bl	113dd80 <der_ia5_char_encode>
 113d5a8:	39001aa0 	strb	w0, [x21, #6]
 113d5ac:	b9400681 	ldr	w1, [x20, #4]
 113d5b0:	1ad30820 	udiv	w0, w1, w19
 113d5b4:	1b138400 	msub	w0, w0, w19, w1
 113d5b8:	38606ac0 	ldrb	w0, [x22, x0]
 113d5bc:	940001f1 	bl	113dd80 <der_ia5_char_encode>
 113d5c0:	39001ea0 	strb	w0, [x21, #7]
    STORE_V(gtime->DD);
 113d5c4:	b9400a80 	ldr	w0, [x20, #8]
 113d5c8:	1ad30800 	udiv	w0, w0, w19
 113d5cc:	1ad30801 	udiv	w1, w0, w19
 113d5d0:	1b138020 	msub	w0, w1, w19, w0
 113d5d4:	38606ac0 	ldrb	w0, [x22, x0]
 113d5d8:	940001ea 	bl	113dd80 <der_ia5_char_encode>
 113d5dc:	390022a0 	strb	w0, [x21, #8]
 113d5e0:	b9400a81 	ldr	w1, [x20, #8]
 113d5e4:	1ad30820 	udiv	w0, w1, w19
 113d5e8:	1b138400 	msub	w0, w0, w19, w1
 113d5ec:	38606ac0 	ldrb	w0, [x22, x0]
 113d5f0:	940001e4 	bl	113dd80 <der_ia5_char_encode>
 113d5f4:	390026a0 	strb	w0, [x21, #9]
    STORE_V(gtime->hh);
 113d5f8:	b9400e80 	ldr	w0, [x20, #12]
 113d5fc:	1ad30800 	udiv	w0, w0, w19
 113d600:	1ad30801 	udiv	w1, w0, w19
 113d604:	1b138020 	msub	w0, w1, w19, w0
 113d608:	38606ac0 	ldrb	w0, [x22, x0]
 113d60c:	940001dd 	bl	113dd80 <der_ia5_char_encode>
 113d610:	39002aa0 	strb	w0, [x21, #10]
 113d614:	b9400e81 	ldr	w1, [x20, #12]
 113d618:	1ad30820 	udiv	w0, w1, w19
 113d61c:	1b138400 	msub	w0, w0, w19, w1
 113d620:	38606ac0 	ldrb	w0, [x22, x0]
 113d624:	940001d7 	bl	113dd80 <der_ia5_char_encode>
 113d628:	39002ea0 	strb	w0, [x21, #11]
    STORE_V(gtime->mm);
 113d62c:	b9401280 	ldr	w0, [x20, #16]
 113d630:	1ad30800 	udiv	w0, w0, w19
 113d634:	1ad30801 	udiv	w1, w0, w19
 113d638:	1b138020 	msub	w0, w1, w19, w0
 113d63c:	38606ac0 	ldrb	w0, [x22, x0]
 113d640:	940001d0 	bl	113dd80 <der_ia5_char_encode>
 113d644:	390032a0 	strb	w0, [x21, #12]
 113d648:	b9401281 	ldr	w1, [x20, #16]
 113d64c:	1ad30820 	udiv	w0, w1, w19
 113d650:	1b138400 	msub	w0, w0, w19, w1
 113d654:	38606ac0 	ldrb	w0, [x22, x0]
 113d658:	940001ca 	bl	113dd80 <der_ia5_char_encode>
 113d65c:	390036a0 	strb	w0, [x21, #13]
    STORE_V(gtime->ss);
 113d660:	b9401680 	ldr	w0, [x20, #20]
 113d664:	1ad30800 	udiv	w0, w0, w19
 113d668:	1ad30801 	udiv	w1, w0, w19
 113d66c:	1b138020 	msub	w0, w1, w19, w0
 113d670:	38606ac0 	ldrb	w0, [x22, x0]
 113d674:	940001c3 	bl	113dd80 <der_ia5_char_encode>
 113d678:	39003aa0 	strb	w0, [x21, #14]
 113d67c:	b9401681 	ldr	w1, [x20, #20]
 113d680:	1ad30820 	udiv	w0, w1, w19
 113d684:	1b138400 	msub	w0, w0, w19, w1
 113d688:	38606ac0 	ldrb	w0, [x22, x0]
 113d68c:	aa1703f6 	mov	x22, x23
 113d690:	940001bc 	bl	113dd80 <der_ia5_char_encode>
 113d694:	39003ea0 	strb	w0, [x21, #15]
    if (gtime->fs) {
 113d698:	b9401a9c 	ldr	w28, [x20, #24]
 113d69c:	34000c3c 	cbz	w28, 113d820 <der_encode_generalizedtime+0x394>
       out[x++] = der_ia5_char_encode('.');
 113d6a0:	528005c0 	mov	w0, #0x2e                  	// #46
 113d6a4:	940001b7 	bl	113dd80 <der_ia5_char_encode>
       unsigned len = 0;
 113d6a8:	5280001a 	mov	w26, #0x0                   	// #0
       divisor = 1;
 113d6ac:	d280003b 	mov	x27, #0x1                   	// #1
          divisor *= 10;
 113d6b0:	d2800141 	mov	x1, #0xa                   	// #10
       out[x++] = der_ia5_char_encode('.');
 113d6b4:	390042a0 	strb	w0, [x21, #16]
          fs /= 10;
 113d6b8:	2a1c03e0 	mov	w0, w28
 113d6bc:	2a1a03f7 	mov	w23, w26
 113d6c0:	1ad30b9c 	udiv	w28, w28, w19
          divisor *= 10;
 113d6c4:	9b017f7b 	mul	x27, x27, x1
          len++;
 113d6c8:	1100075a 	add	w26, w26, #0x1
       } while(fs != 0);
 113d6cc:	7100241f 	cmp	w0, #0x9
 113d6d0:	54ffff48 	b.hi	113d6b8 <der_encode_generalizedtime+0x22c>  // b.pmore
 113d6d4:	aa1503f3 	mov	x19, x21
 113d6d8:	0b150342 	add	w2, w26, w21
          out[x++] = der_ia5_char_encode(baseten[(gtime->fs/divisor) % 10]);
 113d6dc:	91331ec3 	add	x3, x22, #0xcc7
          divisor /= 10;
 113d6e0:	d280015c 	mov	x28, #0xa                   	// #10
       while (len-- > 1) {
 113d6e4:	4b130041 	sub	w1, w2, w19
 113d6e8:	b9401a80 	ldr	w0, [x20, #24]
 113d6ec:	7100043f 	cmp	w1, #0x1
 113d6f0:	540007c8 	b.hi	113d7e8 <der_encode_generalizedtime+0x35c>  // b.pmore
 113d6f4:	2a1703f3 	mov	w19, w23
 113d6f8:	7100035f 	cmp	w26, #0x0
       out[x++] = der_ia5_char_encode(baseten[gtime->fs % 10]);
 113d6fc:	52800142 	mov	w2, #0xa                   	// #10
 113d700:	91004677 	add	x23, x19, #0x11
 113d704:	d2800221 	mov	x1, #0x11                  	// #17
 113d708:	91004a73 	add	x19, x19, #0x12
 113d70c:	9a8112f7 	csel	x23, x23, x1, ne  // ne = any
 113d710:	d2800241 	mov	x1, #0x12                  	// #18
 113d714:	9a811273 	csel	x19, x19, x1, ne  // ne = any
 113d718:	1ac20801 	udiv	w1, w0, w2
 113d71c:	1b028020 	msub	w0, w1, w2, w0
 113d720:	91331ec1 	add	x1, x22, #0xcc7
 113d724:	38606820 	ldrb	w0, [x1, x0]
 113d728:	94000196 	bl	113dd80 <der_ia5_char_encode>
 113d72c:	38376aa0 	strb	w0, [x21, x23]
    if (gtime->off_mm || gtime->off_hh) {
 113d730:	b9402680 	ldr	w0, [x20, #36]
 113d734:	8b1302ba 	add	x26, x21, x19
 113d738:	9100067b 	add	x27, x19, #0x1
 113d73c:	35000060 	cbnz	w0, 113d748 <der_encode_generalizedtime+0x2bc>
 113d740:	b9402280 	ldr	w0, [x20, #32]
 113d744:	34000720 	cbz	w0, 113d828 <der_encode_generalizedtime+0x39c>
       out[x++] = der_ia5_char_encode(gtime->off_dir ? '-' : '+');
 113d748:	b9401e80 	ldr	w0, [x20, #28]
 113d74c:	528005a1 	mov	w1, #0x2d                  	// #45
       STORE_V(gtime->off_hh);
 113d750:	52800157 	mov	w23, #0xa                   	// #10
 113d754:	91331ed6 	add	x22, x22, #0xcc7
       out[x++] = der_ia5_char_encode(gtime->off_dir ? '-' : '+');
 113d758:	7100001f 	cmp	w0, #0x0
 113d75c:	52800560 	mov	w0, #0x2b                  	// #43
 113d760:	1a801020 	csel	w0, w1, w0, ne  // ne = any
 113d764:	94000187 	bl	113dd80 <der_ia5_char_encode>
 113d768:	39000340 	strb	w0, [x26]
       STORE_V(gtime->off_hh);
 113d76c:	b9402280 	ldr	w0, [x20, #32]
 113d770:	1ad70800 	udiv	w0, w0, w23
 113d774:	1ad70801 	udiv	w1, w0, w23
 113d778:	1b178020 	msub	w0, w1, w23, w0
 113d77c:	38606ac0 	ldrb	w0, [x22, x0]
 113d780:	94000180 	bl	113dd80 <der_ia5_char_encode>
 113d784:	383b6aa0 	strb	w0, [x21, x27]
       STORE_V(gtime->off_mm);
 113d788:	9100167b 	add	x27, x19, #0x5
       STORE_V(gtime->off_hh);
 113d78c:	b9402281 	ldr	w1, [x20, #32]
 113d790:	1ad70820 	udiv	w0, w1, w23
 113d794:	1b178400 	msub	w0, w0, w23, w1
 113d798:	38606ac0 	ldrb	w0, [x22, x0]
 113d79c:	94000179 	bl	113dd80 <der_ia5_char_encode>
 113d7a0:	39000b40 	strb	w0, [x26, #2]
       STORE_V(gtime->off_mm);
 113d7a4:	b9402680 	ldr	w0, [x20, #36]
 113d7a8:	1ad70800 	udiv	w0, w0, w23
 113d7ac:	1ad70801 	udiv	w1, w0, w23
 113d7b0:	1b178020 	msub	w0, w1, w23, w0
 113d7b4:	38606ac0 	ldrb	w0, [x22, x0]
 113d7b8:	94000172 	bl	113dd80 <der_ia5_char_encode>
 113d7bc:	39000f40 	strb	w0, [x26, #3]
 113d7c0:	b9402681 	ldr	w1, [x20, #36]
 113d7c4:	1ad70820 	udiv	w0, w1, w23
 113d7c8:	1b178417 	msub	w23, w0, w23, w1
 113d7cc:	38776ac0 	ldrb	w0, [x22, x23]
 113d7d0:	9400016c 	bl	113dd80 <der_ia5_char_encode>
 113d7d4:	39001340 	strb	w0, [x26, #4]
    out[1] = (unsigned char)(x - 2);
 113d7d8:	51000b60 	sub	w0, w27, #0x2
 113d7dc:	390006a0 	strb	w0, [x21, #1]
    *outlen = x;
 113d7e0:	f900033b 	str	x27, [x25]
    return CRYPT_OK;
 113d7e4:	17ffff41 	b	113d4e8 <der_encode_generalizedtime+0x5c>
          divisor /= 10;
 113d7e8:	9adc0b7b 	udiv	x27, x27, x28
          out[x++] = der_ia5_char_encode(baseten[(gtime->fs/divisor) % 10]);
 113d7ec:	2a0003e0 	mov	w0, w0
 113d7f0:	f90033e3 	str	x3, [sp, #96]
 113d7f4:	91000673 	add	x19, x19, #0x1
 113d7f8:	b9006fe2 	str	w2, [sp, #108]
 113d7fc:	9adb0800 	udiv	x0, x0, x27
 113d800:	9adc0801 	udiv	x1, x0, x28
 113d804:	9b1c8020 	msub	x0, x1, x28, x0
 113d808:	38606860 	ldrb	w0, [x3, x0]
 113d80c:	9400015d 	bl	113dd80 <der_ia5_char_encode>
 113d810:	39004260 	strb	w0, [x19, #16]
 113d814:	b9406fe2 	ldr	w2, [sp, #108]
 113d818:	f94033e3 	ldr	x3, [sp, #96]
 113d81c:	17ffffb2 	b	113d6e4 <der_encode_generalizedtime+0x258>
    STORE_V(gtime->ss);
 113d820:	d2800213 	mov	x19, #0x10                  	// #16
 113d824:	17ffffc3 	b	113d730 <der_encode_generalizedtime+0x2a4>
       out[x++] = der_ia5_char_encode('Z');
 113d828:	52800b40 	mov	w0, #0x5a                  	// #90
 113d82c:	94000155 	bl	113dd80 <der_ia5_char_encode>
 113d830:	39000340 	strb	w0, [x26]
 113d834:	17ffffe9 	b	113d7d8 <der_encode_generalizedtime+0x34c>
    LTC_ARGCHK(gtime != NULL);
 113d838:	52800218 	mov	w24, #0x10                  	// #16
 113d83c:	17ffff2b 	b	113d4e8 <der_encode_generalizedtime+0x5c>

000000000113d840 <_char_to_int>:
*/

#ifdef LTC_DER

static int _char_to_int(unsigned char x)
{
 113d840:	12001c00 	and	w0, w0, #0xff
 113d844:	5100c000 	sub	w0, w0, #0x30
 113d848:	12001c01 	and	w1, w0, #0xff
 113d84c:	7100243f 	cmp	w1, #0x9
      case '7': return 7;
      case '8': return 8;
      case '9': return 9;
      default:  return 100;
   }
}
 113d850:	52800c81 	mov	w1, #0x64                  	// #100
 113d854:	1a819000 	csel	w0, w0, w1, ls  // ls = plast
 113d858:	d65f03c0 	ret

000000000113d85c <der_decode_generalizedtime>:
{
   unsigned char buf[32];
   unsigned long x;
   int           y;

   LTC_ARGCHK(in    != NULL);
 113d85c:	b4001620 	cbz	x0, 113db20 <der_decode_generalizedtime+0x2c4>
{
 113d860:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
 113d864:	910003fd 	mov	x29, sp
 113d868:	a90153f3 	stp	x19, x20, [sp, #16]
 113d86c:	a9025bf5 	stp	x21, x22, [sp, #32]
 113d870:	aa0103f6 	mov	x22, x1
 113d874:	a90363f7 	stp	x23, x24, [sp, #48]
 113d878:	f90023f9 	str	x25, [sp, #64]
   LTC_ARGCHK(inlen != NULL);
 113d87c:	b4001561 	cbz	x1, 113db28 <der_decode_generalizedtime+0x2cc>
 113d880:	aa0203f3 	mov	x19, x2
   LTC_ARGCHK(out   != NULL);
 113d884:	b4001522 	cbz	x2, 113db28 <der_decode_generalizedtime+0x2cc>

   /* check header */
   if (*inlen < 2UL || (in[1] >= sizeof(buf)) || ((in[1] + 2UL) > *inlen)) {
 113d888:	f9400021 	ldr	x1, [x1]
 113d88c:	f100043f 	cmp	x1, #0x1
 113d890:	54001249 	b.ls	113dad8 <der_decode_generalizedtime+0x27c>  // b.plast
 113d894:	aa0003f5 	mov	x21, x0
 113d898:	39400400 	ldrb	w0, [x0, #1]
 113d89c:	71007c1f 	cmp	w0, #0x1f
 113d8a0:	540011c8 	b.hi	113dad8 <der_decode_generalizedtime+0x27c>  // b.pmore
 113d8a4:	92401c00 	and	x0, x0, #0xff
 113d8a8:	91000800 	add	x0, x0, #0x2
 113d8ac:	eb00003f 	cmp	x1, x0
 113d8b0:	54001143 	b.cc	113dad8 <der_decode_generalizedtime+0x27c>  // b.lo, b.ul, b.last
       if (y == -1) {
          return CRYPT_INVALID_PACKET;
       }
       if (!((y >= '0' && y <= '9')
            || y == 'Z' || y == '.'
            || y == '+' || y == '-')) {
 113d8b4:	d28ffdb8 	mov	x24, #0x7fed                	// #32749
       y = der_ia5_value_decode(in[x+2]);
 113d8b8:	91000ab7 	add	x23, x21, #0x2
          return CRYPT_INVALID_PACKET;
       }
       buf[x] = y;
 113d8bc:	910143f9 	add	x25, sp, #0x50
   for (x = 0; x < in[1]; x++) {
 113d8c0:	d2800014 	mov	x20, #0x0                   	// #0
            || y == '+' || y == '-')) {
 113d8c4:	f2d00018 	movk	x24, #0x8000, lsl #32
   for (x = 0; x < in[1]; x++) {
 113d8c8:	394006a1 	ldrb	w1, [x21, #1]
 113d8cc:	91000a80 	add	x0, x20, #0x2
 113d8d0:	eb14003f 	cmp	x1, x20
 113d8d4:	54000a08 	b.hi	113da14 <der_decode_generalizedtime+0x1b8>  // b.pmore
   }
   *inlen = 2 + x;
 113d8d8:	f90002c0 	str	x0, [x22]

   if (x < 15) {
 113d8dc:	f1003a9f 	cmp	x20, #0xe
 113d8e0:	54000fc9 	b.ls	113dad8 <der_decode_generalizedtime+0x27c>  // b.plast

    So let's do a trivial decode upto [including] ss
   */

    x = 0;
    DECODE_V4(out->YYYY, 10000);
 113d8e4:	394143e0 	ldrb	w0, [sp, #80]
 113d8e8:	97ffffd6 	bl	113d840 <_char_to_int>
 113d8ec:	2a0003e2 	mov	w2, w0
 113d8f0:	394147e0 	ldrb	w0, [sp, #81]
 113d8f4:	97ffffd3 	bl	113d840 <_char_to_int>
 113d8f8:	52800c81 	mov	w1, #0x64                  	// #100
 113d8fc:	1b017c00 	mul	w0, w0, w1
 113d900:	52807d01 	mov	w1, #0x3e8                 	// #1000
 113d904:	1b010042 	madd	w2, w2, w1, w0
 113d908:	39414be0 	ldrb	w0, [sp, #82]
 113d90c:	97ffffcd 	bl	113d840 <_char_to_int>
 113d910:	52800143 	mov	w3, #0xa                   	// #10
 113d914:	1b030802 	madd	w2, w0, w3, w2
 113d918:	39414fe0 	ldrb	w0, [sp, #83]
 113d91c:	97ffffc9 	bl	113d840 <_char_to_int>
 113d920:	0b000040 	add	w0, w2, w0
 113d924:	b9000260 	str	w0, [x19]
 113d928:	5284e1e1 	mov	w1, #0x270f                	// #9999
 113d92c:	6b01001f 	cmp	w0, w1
 113d930:	54000d48 	b.hi	113dad8 <der_decode_generalizedtime+0x27c>  // b.pmore
    DECODE_V(out->MM, 13);
 113d934:	394153e0 	ldrb	w0, [sp, #84]
 113d938:	97ffffc2 	bl	113d840 <_char_to_int>
 113d93c:	2a0003e2 	mov	w2, w0
 113d940:	394157e0 	ldrb	w0, [sp, #85]
 113d944:	97ffffbf 	bl	113d840 <_char_to_int>
 113d948:	1b030040 	madd	w0, w2, w3, w0
 113d94c:	b9000660 	str	w0, [x19, #4]
 113d950:	7100301f 	cmp	w0, #0xc
 113d954:	54000c28 	b.hi	113dad8 <der_decode_generalizedtime+0x27c>  // b.pmore
    DECODE_V(out->DD, 32);
 113d958:	39415be0 	ldrb	w0, [sp, #86]
 113d95c:	97ffffb9 	bl	113d840 <_char_to_int>
 113d960:	2a0003e2 	mov	w2, w0
 113d964:	39415fe0 	ldrb	w0, [sp, #87]
 113d968:	97ffffb6 	bl	113d840 <_char_to_int>
 113d96c:	1b030040 	madd	w0, w2, w3, w0
 113d970:	b9000a60 	str	w0, [x19, #8]
 113d974:	71007c1f 	cmp	w0, #0x1f
 113d978:	54000b08 	b.hi	113dad8 <der_decode_generalizedtime+0x27c>  // b.pmore
    DECODE_V(out->hh, 24);
 113d97c:	394163e0 	ldrb	w0, [sp, #88]
 113d980:	97ffffb0 	bl	113d840 <_char_to_int>
 113d984:	2a0003e2 	mov	w2, w0
 113d988:	394167e0 	ldrb	w0, [sp, #89]
 113d98c:	97ffffad 	bl	113d840 <_char_to_int>
 113d990:	1b030040 	madd	w0, w2, w3, w0
 113d994:	b9000e60 	str	w0, [x19, #12]
 113d998:	71005c1f 	cmp	w0, #0x17
 113d99c:	540009e8 	b.hi	113dad8 <der_decode_generalizedtime+0x27c>  // b.pmore
    DECODE_V(out->mm, 60);
 113d9a0:	39416be0 	ldrb	w0, [sp, #90]
 113d9a4:	97ffffa7 	bl	113d840 <_char_to_int>
 113d9a8:	2a0003e2 	mov	w2, w0
 113d9ac:	39416fe0 	ldrb	w0, [sp, #91]
 113d9b0:	97ffffa4 	bl	113d840 <_char_to_int>
 113d9b4:	1b030040 	madd	w0, w2, w3, w0
 113d9b8:	b9001260 	str	w0, [x19, #16]
 113d9bc:	7100ec1f 	cmp	w0, #0x3b
 113d9c0:	540008c8 	b.hi	113dad8 <der_decode_generalizedtime+0x27c>  // b.pmore
    DECODE_V(out->ss, 60);
 113d9c4:	394173e0 	ldrb	w0, [sp, #92]
 113d9c8:	97ffff9e 	bl	113d840 <_char_to_int>
 113d9cc:	2a0003e2 	mov	w2, w0
 113d9d0:	394177e0 	ldrb	w0, [sp, #93]
 113d9d4:	97ffff9b 	bl	113d840 <_char_to_int>
 113d9d8:	1b030040 	madd	w0, w2, w3, w0
 113d9dc:	b9001660 	str	w0, [x19, #20]
 113d9e0:	7100ec1f 	cmp	w0, #0x3b
 113d9e4:	540007a8 	b.hi	113dad8 <der_decode_generalizedtime+0x27c>  // b.pmore

    /* clear fractional seconds info */
    out->fs = 0;

    /* now is it Z or . */
    if (buf[x] == 'Z') {
 113d9e8:	39417be0 	ldrb	w0, [sp, #94]
    out->fs = 0;
 113d9ec:	b9001a7f 	str	wzr, [x19, #24]
    if (buf[x] == 'Z') {
 113d9f0:	7101681f 	cmp	w0, #0x5a
 113d9f4:	54000281 	b.ne	113da44 <der_decode_generalizedtime+0x1e8>  // b.any
       return CRYPT_OK;
 113d9f8:	52800000 	mov	w0, #0x0                   	// #0
       DECODE_V(out->off_hh, 24);
       DECODE_V(out->off_mm, 60);
       return CRYPT_OK;
    }
    return CRYPT_INVALID_PACKET;
}
 113d9fc:	a94153f3 	ldp	x19, x20, [sp, #16]
 113da00:	a9425bf5 	ldp	x21, x22, [sp, #32]
 113da04:	a94363f7 	ldp	x23, x24, [sp, #48]
 113da08:	f94023f9 	ldr	x25, [sp, #64]
 113da0c:	a8c77bfd 	ldp	x29, x30, [sp], #112
 113da10:	d65f03c0 	ret
       y = der_ia5_value_decode(in[x+2]);
 113da14:	38746ae0 	ldrb	w0, [x23, x20]
 113da18:	940000e9 	bl	113ddbc <der_ia5_value_decode>
       if (y == -1) {
 113da1c:	3100041f 	cmn	w0, #0x1
 113da20:	540005c0 	b.eq	113dad8 <der_decode_generalizedtime+0x27c>  // b.none
            || y == '+' || y == '-')) {
 113da24:	5100ac01 	sub	w1, w0, #0x2b
 113da28:	7100bc3f 	cmp	w1, #0x2f
 113da2c:	54000568 	b.hi	113dad8 <der_decode_generalizedtime+0x27c>  // b.pmore
 113da30:	9ac12701 	lsr	x1, x24, x1
 113da34:	36000521 	tbz	w1, #0, 113dad8 <der_decode_generalizedtime+0x27c>
       buf[x] = y;
 113da38:	38396a80 	strb	w0, [x20, x25]
   for (x = 0; x < in[1]; x++) {
 113da3c:	91000694 	add	x20, x20, #0x1
 113da40:	17ffffa2 	b	113d8c8 <der_decode_generalizedtime+0x6c>
    if (buf[x] == '.') {
 113da44:	7100b81f 	cmp	w0, #0x2e
 113da48:	910143e3 	add	x3, sp, #0x50
 113da4c:	54000640 	b.eq	113db14 <der_decode_generalizedtime+0x2b8>  // b.none
    DECODE_V(out->ss, 60);
 113da50:	d28001c2 	mov	x2, #0xe                   	// #14
    if (buf[x] == 'Z') {
 113da54:	38626860 	ldrb	w0, [x3, x2]
 113da58:	7101681f 	cmp	w0, #0x5a
 113da5c:	54fffce0 	b.eq	113d9f8 <der_decode_generalizedtime+0x19c>  // b.none
    if (buf[x] == '+' || buf[x] == '-') {
 113da60:	7100ac1f 	cmp	w0, #0x2b
 113da64:	528005a1 	mov	w1, #0x2d                  	// #45
 113da68:	7a411004 	ccmp	w0, w1, #0x4, ne  // ne = any
 113da6c:	54000361 	b.ne	113dad8 <der_decode_generalizedtime+0x27c>  // b.any
       out->off_dir = (buf[x++] == '+') ? 0 : 1;
 113da70:	7100ac1f 	cmp	w0, #0x2b
 113da74:	1a9f07e0 	cset	w0, ne  // ne = any
 113da78:	b9001e60 	str	w0, [x19, #28]
       DECODE_V(out->off_hh, 24);
 113da7c:	910147e0 	add	x0, sp, #0x51
 113da80:	38626800 	ldrb	w0, [x0, x2]
 113da84:	97ffff6f 	bl	113d840 <_char_to_int>
 113da88:	2a0003e3 	mov	w3, w0
 113da8c:	91014be0 	add	x0, sp, #0x52
 113da90:	38626800 	ldrb	w0, [x0, x2]
 113da94:	97ffff6b 	bl	113d840 <_char_to_int>
 113da98:	52800144 	mov	w4, #0xa                   	// #10
 113da9c:	1b040060 	madd	w0, w3, w4, w0
 113daa0:	b9002260 	str	w0, [x19, #32]
 113daa4:	71005c1f 	cmp	w0, #0x17
 113daa8:	54000188 	b.hi	113dad8 <der_decode_generalizedtime+0x27c>  // b.pmore
       DECODE_V(out->off_mm, 60);
 113daac:	91014fe0 	add	x0, sp, #0x53
 113dab0:	38626800 	ldrb	w0, [x0, x2]
 113dab4:	97ffff63 	bl	113d840 <_char_to_int>
 113dab8:	2a0003e3 	mov	w3, w0
 113dabc:	910153e0 	add	x0, sp, #0x54
 113dac0:	38626800 	ldrb	w0, [x0, x2]
 113dac4:	97ffff5f 	bl	113d840 <_char_to_int>
 113dac8:	1b040060 	madd	w0, w3, w4, w0
 113dacc:	b9002660 	str	w0, [x19, #36]
 113dad0:	7100ec1f 	cmp	w0, #0x3b
 113dad4:	54fff929 	b.ls	113d9f8 <der_decode_generalizedtime+0x19c>  // b.plast
 113dad8:	528000e0 	mov	w0, #0x7                   	// #7
 113dadc:	17ffffc8 	b	113d9fc <der_decode_generalizedtime+0x1a0>
          unsigned fs = out->fs;
 113dae0:	b9401a64 	ldr	w4, [x19, #24]
          out->fs += _char_to_int(buf[x]);
 113dae4:	97ffff57 	bl	113d840 <_char_to_int>
 113dae8:	1b050080 	madd	w0, w4, w5, w0
 113daec:	b9001a60 	str	w0, [x19, #24]
          if (fs > out->fs) return CRYPT_OVERFLOW;
 113daf0:	6b04001f 	cmp	w0, w4
 113daf4:	540001e3 	b.cc	113db30 <der_decode_generalizedtime+0x2d4>  // b.lo, b.ul, b.last
          x++;
 113daf8:	91000442 	add	x2, x2, #0x1
       while (buf[x] >= '0' && buf[x] <= '9') {
 113dafc:	38626860 	ldrb	w0, [x3, x2]
 113db00:	5100c001 	sub	w1, w0, #0x30
 113db04:	12001c21 	and	w1, w1, #0xff
 113db08:	7100243f 	cmp	w1, #0x9
 113db0c:	54fffea9 	b.ls	113dae0 <der_decode_generalizedtime+0x284>  // b.plast
 113db10:	17ffffd1 	b	113da54 <der_decode_generalizedtime+0x1f8>
       x++;
 113db14:	d28001e2 	mov	x2, #0xf                   	// #15
          out->fs *= 10;
 113db18:	52800145 	mov	w5, #0xa                   	// #10
 113db1c:	17fffff8 	b	113dafc <der_decode_generalizedtime+0x2a0>
   LTC_ARGCHK(in    != NULL);
 113db20:	52800200 	mov	w0, #0x10                  	// #16
}
 113db24:	d65f03c0 	ret
   LTC_ARGCHK(in    != NULL);
 113db28:	52800200 	mov	w0, #0x10                  	// #16
 113db2c:	17ffffb4 	b	113d9fc <der_decode_generalizedtime+0x1a0>
          if (fs > out->fs) return CRYPT_OVERFLOW;
 113db30:	52800260 	mov	w0, #0x13                  	// #19
 113db34:	17ffffb2 	b	113d9fc <der_decode_generalizedtime+0x1a0>

000000000113db38 <der_length_generalizedtime>:
  @param outlen [out] The length of the DER encoding
  @return CRYPT_OK if successful
*/
int der_length_generalizedtime(const ltc_generalizedtime *gtime, unsigned long *outlen)
{
   LTC_ARGCHK(outlen  != NULL);
 113db38:	b4000301 	cbz	x1, 113db98 <der_length_generalizedtime+0x60>
   LTC_ARGCHK(gtime != NULL);
 113db3c:	b40002e0 	cbz	x0, 113db98 <der_length_generalizedtime+0x60>

   if (gtime->fs == 0) {
 113db40:	b9401804 	ldr	w4, [x0, #24]
 113db44:	d2800222 	mov	x2, #0x11                  	// #17
 113db48:	35000084 	cbnz	w4, 113db58 <der_length_generalizedtime+0x20>
      /* we encode as YYYYMMDDhhmmssZ */
      *outlen = 2 + 14 + 1;
 113db4c:	f9000022 	str	x2, [x1]
         len += 5;
      }
      *outlen = len;
   }

   return CRYPT_OK;
 113db50:	52800000 	mov	w0, #0x0                   	// #0
}
 113db54:	d65f03c0 	ret
         fs /= 10;
 113db58:	52800146 	mov	w6, #0xa                   	// #10
 113db5c:	2a0403e5 	mov	w5, w4
 113db60:	aa0203e3 	mov	x3, x2
 113db64:	1ac60884 	udiv	w4, w4, w6
         len++;
 113db68:	91000442 	add	x2, x2, #0x1
      } while(fs != 0);
 113db6c:	710024bf 	cmp	w5, #0x9
 113db70:	54ffff68 	b.hi	113db5c <der_length_generalizedtime+0x24>  // b.pmore
      if (gtime->off_hh == 0 && gtime->off_mm == 0) {
 113db74:	b9402002 	ldr	w2, [x0, #32]
 113db78:	350000c2 	cbnz	w2, 113db90 <der_length_generalizedtime+0x58>
 113db7c:	b9402400 	ldr	w0, [x0, #36]
 113db80:	35000080 	cbnz	w0, 113db90 <der_length_generalizedtime+0x58>
         len += 1;
 113db84:	91000860 	add	x0, x3, #0x2
      *outlen = len;
 113db88:	f9000020 	str	x0, [x1]
 113db8c:	17fffff1 	b	113db50 <der_length_generalizedtime+0x18>
         len += 5;
 113db90:	91001860 	add	x0, x3, #0x6
 113db94:	17fffffd 	b	113db88 <der_length_generalizedtime+0x50>
   LTC_ARGCHK(outlen  != NULL);
 113db98:	52800200 	mov	w0, #0x10                  	// #16
 113db9c:	17ffffee 	b	113db54 <der_length_generalizedtime+0x1c>

000000000113dba0 <der_decode_ia5_string>:
  @param outlen  [in/out] The number of octets stored
  @return CRYPT_OK if successful
*/
int der_decode_ia5_string(const unsigned char *in, unsigned long inlen,
                                unsigned char *out, unsigned long *outlen)
{
 113dba0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 113dba4:	910003fd 	mov	x29, sp
 113dba8:	a90153f3 	stp	x19, x20, [sp, #16]
 113dbac:	a9025bf5 	stp	x21, x22, [sp, #32]
 113dbb0:	f9001bf7 	str	x23, [sp, #48]
   unsigned long x, y, len;
   int           t, err;

   LTC_ARGCHK(in     != NULL);
 113dbb4:	b5000100 	cbnz	x0, 113dbd4 <der_decode_ia5_string+0x34>
 113dbb8:	52800214 	mov	w20, #0x10                  	// #16
   }

   *outlen = y;

   return CRYPT_OK;
}
 113dbbc:	2a1403e0 	mov	w0, w20
 113dbc0:	a94153f3 	ldp	x19, x20, [sp, #16]
 113dbc4:	a9425bf5 	ldp	x21, x22, [sp, #32]
 113dbc8:	f9401bf7 	ldr	x23, [sp, #48]
 113dbcc:	a8c57bfd 	ldp	x29, x30, [sp], #80
 113dbd0:	d65f03c0 	ret
 113dbd4:	aa0203f7 	mov	x23, x2
   LTC_ARGCHK(out    != NULL);
 113dbd8:	b4ffff02 	cbz	x2, 113dbb8 <der_decode_ia5_string+0x18>
 113dbdc:	aa0303f5 	mov	x21, x3
   LTC_ARGCHK(outlen != NULL);
 113dbe0:	b4fffec3 	cbz	x3, 113dbb8 <der_decode_ia5_string+0x18>
 113dbe4:	aa0103f6 	mov	x22, x1
   if (inlen < 2) {
 113dbe8:	f100043f 	cmp	x1, #0x1
 113dbec:	54000068 	b.hi	113dbf8 <der_decode_ia5_string+0x58>  // b.pmore
      return CRYPT_INVALID_PACKET;
 113dbf0:	528000f4 	mov	w20, #0x7                   	// #7
 113dbf4:	17fffff2 	b	113dbbc <der_decode_ia5_string+0x1c>
 113dbf8:	aa0003f3 	mov	x19, x0
   if ((in[0] & 0x1F) != 0x16) {
 113dbfc:	39400000 	ldrb	w0, [x0]
 113dc00:	12001000 	and	w0, w0, #0x1f
 113dc04:	7100581f 	cmp	w0, #0x16
 113dc08:	54ffff41 	b.ne	113dbf0 <der_decode_ia5_string+0x50>  // b.any
   y = inlen - x;
 113dc0c:	d1000420 	sub	x0, x1, #0x1
   if ((err = der_decode_asn1_length(in + x, &y, &len)) != CRYPT_OK) {
 113dc10:	910123e2 	add	x2, sp, #0x48
 113dc14:	910103e1 	add	x1, sp, #0x40
   y = inlen - x;
 113dc18:	f90023e0 	str	x0, [sp, #64]
   if ((err = der_decode_asn1_length(in + x, &y, &len)) != CRYPT_OK) {
 113dc1c:	91000660 	add	x0, x19, #0x1
 113dc20:	97fffcd8 	bl	113cf80 <der_decode_asn1_length>
 113dc24:	2a0003f4 	mov	w20, w0
 113dc28:	35fffca0 	cbnz	w0, 113dbbc <der_decode_ia5_string+0x1c>
   if (len > *outlen) {
 113dc2c:	a9440be0 	ldp	x0, x2, [sp, #64]
 113dc30:	f94002a3 	ldr	x3, [x21]
 113dc34:	aa2003e1 	mvn	x1, x0
 113dc38:	eb02007f 	cmp	x3, x2
 113dc3c:	54000082 	b.cs	113dc4c <der_decode_ia5_string+0xac>  // b.hs, b.nlast
      return CRYPT_BUFFER_OVERFLOW;
 113dc40:	528000d4 	mov	w20, #0x6                   	// #6
      *outlen = len;
 113dc44:	f90002a2 	str	x2, [x21]
      return CRYPT_BUFFER_OVERFLOW;
 113dc48:	17ffffdd 	b	113dbbc <der_decode_ia5_string+0x1c>
   if (len > (inlen - x)) {
 113dc4c:	8b160036 	add	x22, x1, x22
 113dc50:	eb16005f 	cmp	x2, x22
 113dc54:	54fffce8 	b.hi	113dbf0 <der_decode_ia5_string+0x50>  // b.pmore
   for (y = 0; y < len; y++) {
 113dc58:	8b000273 	add	x19, x19, x0
 113dc5c:	f90023ff 	str	xzr, [sp, #64]
 113dc60:	a94407e0 	ldp	x0, x1, [sp, #64]
 113dc64:	eb01001f 	cmp	x0, x1
 113dc68:	54000063 	b.cc	113dc74 <der_decode_ia5_string+0xd4>  // b.lo, b.ul, b.last
   *outlen = y;
 113dc6c:	f90002a0 	str	x0, [x21]
   return CRYPT_OK;
 113dc70:	17ffffd3 	b	113dbbc <der_decode_ia5_string+0x1c>
       t = der_ia5_value_decode(in[x++]);
 113dc74:	38401e60 	ldrb	w0, [x19, #1]!
 113dc78:	94000051 	bl	113ddbc <der_ia5_value_decode>
       if (t == -1) {
 113dc7c:	3100041f 	cmn	w0, #0x1
 113dc80:	54fff9c0 	b.eq	113dbb8 <der_decode_ia5_string+0x18>  // b.none
       out[y] = t;
 113dc84:	f94023e1 	ldr	x1, [sp, #64]
 113dc88:	38216ae0 	strb	w0, [x23, x1]
   for (y = 0; y < len; y++) {
 113dc8c:	91000421 	add	x1, x1, #0x1
 113dc90:	f90023e1 	str	x1, [sp, #64]
 113dc94:	17fffff3 	b	113dc60 <der_decode_ia5_string+0xc0>

000000000113dc98 <der_encode_ia5_string>:
  @param outlen   [in/out] The max size and resulting size of the DER IA5 STRING
  @return CRYPT_OK if successful
*/
int der_encode_ia5_string(const unsigned char *in, unsigned long inlen,
                                unsigned char *out, unsigned long *outlen)
{
 113dc98:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
 113dc9c:	910003fd 	mov	x29, sp
 113dca0:	a90153f3 	stp	x19, x20, [sp, #16]
 113dca4:	a9025bf5 	stp	x21, x22, [sp, #32]
 113dca8:	a90363f7 	stp	x23, x24, [sp, #48]
 113dcac:	f90023f9 	str	x25, [sp, #64]
   unsigned long x, y, len;
   int           err;

   LTC_ARGCHK(in     != NULL);
 113dcb0:	b4000640 	cbz	x0, 113dd78 <der_encode_ia5_string+0xe0>
 113dcb4:	aa0203f6 	mov	x22, x2
   LTC_ARGCHK(out    != NULL);
 113dcb8:	b4000602 	cbz	x2, 113dd78 <der_encode_ia5_string+0xe0>
 113dcbc:	aa0303f5 	mov	x21, x3
   LTC_ARGCHK(outlen != NULL);
 113dcc0:	b40005c3 	cbz	x3, 113dd78 <der_encode_ia5_string+0xe0>

   /* get the size */
   if ((err = der_length_ia5_string(in, inlen, &len)) != CRYPT_OK) {
 113dcc4:	910163f4 	add	x20, sp, #0x58
 113dcc8:	aa0003f8 	mov	x24, x0
 113dccc:	aa0103f7 	mov	x23, x1
 113dcd0:	aa1403e2 	mov	x2, x20
 113dcd4:	9400004a 	bl	113ddfc <der_length_ia5_string>
 113dcd8:	2a0003f3 	mov	w19, w0
 113dcdc:	350000e0 	cbnz	w0, 113dcf8 <der_encode_ia5_string+0x60>
      return err;
   }

   /* too big? */
   if (len > *outlen) {
 113dce0:	f94002a1 	ldr	x1, [x21]
 113dce4:	f9402fe0 	ldr	x0, [sp, #88]
 113dce8:	eb00003f 	cmp	x1, x0
 113dcec:	54000142 	b.cs	113dd14 <der_encode_ia5_string+0x7c>  // b.hs, b.nlast
      *outlen = len;
      return CRYPT_BUFFER_OVERFLOW;
 113dcf0:	528000d3 	mov	w19, #0x6                   	// #6
      *outlen = len;
 113dcf4:	f90002a0 	str	x0, [x21]

   /* retun length */
   *outlen = x;

   return CRYPT_OK;
}
 113dcf8:	2a1303e0 	mov	w0, w19
 113dcfc:	a94153f3 	ldp	x19, x20, [sp, #16]
 113dd00:	a9425bf5 	ldp	x21, x22, [sp, #32]
 113dd04:	a94363f7 	ldp	x23, x24, [sp, #48]
 113dd08:	f94023f9 	ldr	x25, [sp, #64]
 113dd0c:	a8c67bfd 	ldp	x29, x30, [sp], #96
 113dd10:	d65f03c0 	ret
   out[x++] = 0x16;
 113dd14:	aa1603e1 	mov	x1, x22
 113dd18:	528002c0 	mov	w0, #0x16                  	// #22
   if ((err = der_encode_asn1_length(inlen, out + x, &len)) != CRYPT_OK) {
 113dd1c:	aa1403e2 	mov	x2, x20
   out[x++] = 0x16;
 113dd20:	38001420 	strb	w0, [x1], #1
   len = *outlen - x;
 113dd24:	f94002a0 	ldr	x0, [x21]
 113dd28:	d1000400 	sub	x0, x0, #0x1
 113dd2c:	f9002fe0 	str	x0, [sp, #88]
   if ((err = der_encode_asn1_length(inlen, out + x, &len)) != CRYPT_OK) {
 113dd30:	aa1703e0 	mov	x0, x23
 113dd34:	97fffd53 	bl	113d280 <der_encode_asn1_length>
 113dd38:	2a0003f3 	mov	w19, w0
 113dd3c:	35fffde0 	cbnz	w0, 113dcf8 <der_encode_ia5_string+0x60>
   x += len;
 113dd40:	f9402ff4 	ldr	x20, [sp, #88]
 113dd44:	91000699 	add	x25, x20, #0x1
   for (y = 0; y < inlen; y++) {
 113dd48:	d2800014 	mov	x20, #0x0                   	// #0
       out[x++] = der_ia5_char_encode(in[y]);
 113dd4c:	8b1902d6 	add	x22, x22, x25
   for (y = 0; y < inlen; y++) {
 113dd50:	eb17029f 	cmp	x20, x23
 113dd54:	54000081 	b.ne	113dd64 <der_encode_ia5_string+0xcc>  // b.any
   *outlen = x;
 113dd58:	8b190294 	add	x20, x20, x25
 113dd5c:	f90002b4 	str	x20, [x21]
   return CRYPT_OK;
 113dd60:	17ffffe6 	b	113dcf8 <der_encode_ia5_string+0x60>
       out[x++] = der_ia5_char_encode(in[y]);
 113dd64:	38746b00 	ldrb	w0, [x24, x20]
 113dd68:	94000006 	bl	113dd80 <der_ia5_char_encode>
 113dd6c:	38346ac0 	strb	w0, [x22, x20]
   for (y = 0; y < inlen; y++) {
 113dd70:	91000694 	add	x20, x20, #0x1
 113dd74:	17fffff7 	b	113dd50 <der_encode_ia5_string+0xb8>
   LTC_ARGCHK(in     != NULL);
 113dd78:	52800213 	mov	w19, #0x10                  	// #16
 113dd7c:	17ffffdf 	b	113dcf8 <der_encode_ia5_string+0x60>

000000000113dd80 <der_ia5_char_encode>:

int der_ia5_char_encode(int c)
{
   int x;
   for (x = 0; x < (int)(sizeof(ia5_table)/sizeof(ia5_table[0])); x++) {
       if (ia5_table[x].code == c) {
 113dd80:	f0000082 	adrp	x2, 1150000 <Te4+0x258>
 113dd84:	9123c042 	add	x2, x2, #0x8f0
{
 113dd88:	d2800001 	mov	x1, #0x0                   	// #0
       if (ia5_table[x].code == c) {
 113dd8c:	d37df024 	lsl	x4, x1, #3
 113dd90:	b8626884 	ldr	w4, [x4, x2]
 113dd94:	6b00009f 	cmp	w4, w0
 113dd98:	54000081 	b.ne	113dda8 <der_ia5_char_encode+0x28>  // b.any
          return ia5_table[x].value;
 113dd9c:	8b21cc42 	add	x2, x2, w1, sxtw #3
 113dda0:	b9400440 	ldr	w0, [x2, #4]
       }
   }
   return -1;
}
 113dda4:	d65f03c0 	ret
   for (x = 0; x < (int)(sizeof(ia5_table)/sizeof(ia5_table[0])); x++) {
 113dda8:	91000421 	add	x1, x1, #0x1
 113ddac:	f101983f 	cmp	x1, #0x66
 113ddb0:	54fffee1 	b.ne	113dd8c <der_ia5_char_encode+0xc>  // b.any
   return -1;
 113ddb4:	12800000 	mov	w0, #0xffffffff            	// #-1
 113ddb8:	17fffffb 	b	113dda4 <der_ia5_char_encode+0x24>

000000000113ddbc <der_ia5_value_decode>:

int der_ia5_value_decode(int v)
{
   int x;
   for (x = 0; x < (int)(sizeof(ia5_table)/sizeof(ia5_table[0])); x++) {
 113ddbc:	f0000082 	adrp	x2, 1150000 <Te4+0x258>
 113ddc0:	9123c043 	add	x3, x2, #0x8f0
 113ddc4:	52800001 	mov	w1, #0x0                   	// #0
       if (ia5_table[x].value == v) {
 113ddc8:	b9400464 	ldr	w4, [x3, #4]
 113ddcc:	6b00009f 	cmp	w4, w0
 113ddd0:	540000a1 	b.ne	113dde4 <der_ia5_value_decode+0x28>  // b.any
          return ia5_table[x].code;
 113ddd4:	9123c042 	add	x2, x2, #0x8f0
 113ddd8:	937d7c21 	sbfiz	x1, x1, #3, #32
 113dddc:	b8616840 	ldr	w0, [x2, x1]
       }
   }
   return -1;
}
 113dde0:	d65f03c0 	ret
   for (x = 0; x < (int)(sizeof(ia5_table)/sizeof(ia5_table[0])); x++) {
 113dde4:	11000421 	add	w1, w1, #0x1
 113dde8:	91002063 	add	x3, x3, #0x8
 113ddec:	7101983f 	cmp	w1, #0x66
 113ddf0:	54fffec1 	b.ne	113ddc8 <der_ia5_value_decode+0xc>  // b.any
   return -1;
 113ddf4:	12800000 	mov	w0, #0xffffffff            	// #-1
 113ddf8:	17fffffa 	b	113dde0 <der_ia5_value_decode+0x24>

000000000113ddfc <der_length_ia5_string>:
int der_length_ia5_string(const unsigned char *octets, unsigned long noctets, unsigned long *outlen)
{
   unsigned long x;
   int err;

   LTC_ARGCHK(outlen != NULL);
 113ddfc:	b4000442 	cbz	x2, 113de84 <der_length_ia5_string+0x88>
 113de00:	aa0003e5 	mov	x5, x0
   LTC_ARGCHK(octets != NULL);
 113de04:	b4000400 	cbz	x0, 113de84 <der_length_ia5_string+0x88>
{
 113de08:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!

   /* scan string for validity */
   for (x = 0; x < noctets; x++) {
 113de0c:	d2800003 	mov	x3, #0x0                   	// #0
{
 113de10:	910003fd 	mov	x29, sp
 113de14:	a90153f3 	stp	x19, x20, [sp, #16]
 113de18:	aa0203f4 	mov	x20, x2
   for (x = 0; x < noctets; x++) {
 113de1c:	aa0103f3 	mov	x19, x1
 113de20:	52800001 	mov	w1, #0x0                   	// #0
 113de24:	f90017ff 	str	xzr, [sp, #40]
 113de28:	eb03027f 	cmp	x19, x3
 113de2c:	54000181 	b.ne	113de5c <der_length_ia5_string+0x60>  // b.any
 113de30:	34000041 	cbz	w1, 113de38 <der_length_ia5_string+0x3c>
 113de34:	f90017f3 	str	x19, [sp, #40]
       if (der_ia5_char_encode(octets[x]) == -1) {
          return CRYPT_INVALID_ARG;
       }
   }

   if ((err = der_length_asn1_length(noctets, &x)) != CRYPT_OK) {
 113de38:	9100a3e1 	add	x1, sp, #0x28
 113de3c:	aa1303e0 	mov	x0, x19
 113de40:	97fffd90 	bl	113d480 <der_length_asn1_length>
 113de44:	350001a0 	cbnz	w0, 113de78 <der_length_ia5_string+0x7c>
      return err;
   }
   *outlen = 1 + x + noctets;
 113de48:	f94017e1 	ldr	x1, [sp, #40]
 113de4c:	91000421 	add	x1, x1, #0x1
 113de50:	8b130033 	add	x19, x1, x19
 113de54:	f9000293 	str	x19, [x20]

   return CRYPT_OK;
 113de58:	14000008 	b	113de78 <der_length_ia5_string+0x7c>
       if (der_ia5_char_encode(octets[x]) == -1) {
 113de5c:	386368a0 	ldrb	w0, [x5, x3]
 113de60:	97ffffc8 	bl	113dd80 <der_ia5_char_encode>
 113de64:	91000463 	add	x3, x3, #0x1
 113de68:	3100041f 	cmn	w0, #0x1
 113de6c:	52800021 	mov	w1, #0x1                   	// #1
 113de70:	54fffdc1 	b.ne	113de28 <der_length_ia5_string+0x2c>  // b.any
          return CRYPT_INVALID_ARG;
 113de74:	52800200 	mov	w0, #0x10                  	// #16
}
 113de78:	a94153f3 	ldp	x19, x20, [sp, #16]
 113de7c:	a8c37bfd 	ldp	x29, x30, [sp], #48
 113de80:	d65f03c0 	ret
          return CRYPT_INVALID_ARG;
 113de84:	52800200 	mov	w0, #0x10                  	// #16
}
 113de88:	d65f03c0 	ret

000000000113de8c <der_decode_integer>:
  @param inlen    Size of DER encoded data
  @param num      The first mp_int to decode
  @return CRYPT_OK if successful
*/
int der_decode_integer(const unsigned char *in, unsigned long inlen, void *num)
{
 113de8c:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
 113de90:	910003fd 	mov	x29, sp
 113de94:	a90153f3 	stp	x19, x20, [sp, #16]
 113de98:	a9025bf5 	stp	x21, x22, [sp, #32]
 113de9c:	a90363f7 	stp	x23, x24, [sp, #48]
 113dea0:	f90023f9 	str	x25, [sp, #64]
   unsigned long x, y;
   int           err;

   LTC_ARGCHK(num    != NULL);
 113dea4:	b4000842 	cbz	x2, 113dfac <der_decode_integer+0x120>
 113dea8:	aa0003f4 	mov	x20, x0
   LTC_ARGCHK(in     != NULL);
 113deac:	b4000800 	cbz	x0, 113dfac <der_decode_integer+0x120>

   /* min DER INTEGER is 0x02 01 00 == 0 */
   if (inlen < (1 + 1 + 1)) {
 113deb0:	f100083f 	cmp	x1, #0x2
 113deb4:	54000809 	b.ls	113dfb4 <der_decode_integer+0x128>  // b.plast
      return CRYPT_INVALID_PACKET;
   }

   /* ok expect 0x02 when we AND with 0001 1111 [1F] */
   x = 0;
   if ((in[x++] & 0x1F) != 0x02) {
 113deb8:	39400000 	ldrb	w0, [x0]
 113debc:	12001000 	and	w0, w0, #0x1f
 113dec0:	7100081f 	cmp	w0, #0x2
 113dec4:	54000781 	b.ne	113dfb4 <der_decode_integer+0x128>  // b.any
      return CRYPT_INVALID_PACKET;
   }

   /* get the length of the data */
   inlen -= x;
 113dec8:	d1000421 	sub	x1, x1, #0x1
 113decc:	aa0203f7 	mov	x23, x2
   if ((err = der_decode_asn1_length(in + x, &inlen, &y)) != CRYPT_OK) {
 113ded0:	91000680 	add	x0, x20, #0x1
 113ded4:	910183e2 	add	x2, sp, #0x60
   inlen -= x;
 113ded8:	f9002fe1 	str	x1, [sp, #88]
   if ((err = der_decode_asn1_length(in + x, &inlen, &y)) != CRYPT_OK) {
 113dedc:	910163e1 	add	x1, sp, #0x58
 113dee0:	97fffc28 	bl	113cf80 <der_decode_asn1_length>
 113dee4:	2a0003f3 	mov	w19, w0
 113dee8:	35000540 	cbnz	w0, 113df90 <der_decode_integer+0x104>
      return err;
   }
   x += inlen;

   if ((err = mp_read_unsigned_bin(num, (unsigned char *)in + x, y)) != CRYPT_OK) {
 113deec:	b00000f8 	adrp	x24, 115a000 <__scattered_array_1phys_mem_map+0x8>
 113def0:	aa1703e0 	mov	x0, x23
 113def4:	a9458bf9 	ldp	x25, x2, [sp, #88]
 113def8:	f941d716 	ldr	x22, [x24, #936]
 113defc:	f94056c3 	ldr	x3, [x22, #168]
   x += inlen;
 113df00:	91000739 	add	x25, x25, #0x1
   if ((err = mp_read_unsigned_bin(num, (unsigned char *)in + x, y)) != CRYPT_OK) {
 113df04:	8b190281 	add	x1, x20, x25
 113df08:	d63f0060 	blr	x3
 113df0c:	2a0003f3 	mov	w19, w0
 113df10:	35000400 	cbnz	w0, 113df90 <der_decode_integer+0x104>
      return err;
   }

   /* see if it's negative */
   if (in[x] & 0x80) {
 113df14:	38f96a80 	ldrsb	w0, [x20, x25]
 113df18:	36f803c0 	tbz	w0, #31, 113df90 <der_decode_integer+0x104>
      void *tmp;
      if (mp_init(&tmp) != CRYPT_OK) {
 113df1c:	f9400ac1 	ldr	x1, [x22, #16]
 113df20:	9101a3e0 	add	x0, sp, #0x68
 113df24:	d63f0020 	blr	x1
 113df28:	350001c0 	cbnz	w0, 113df60 <der_decode_integer+0xd4>
         return CRYPT_MEM;
      }

      if (mp_2expt(tmp, mp_count_bits(num)) != CRYPT_OK || mp_sub(num, tmp, num) != CRYPT_OK) {
 113df2c:	f9403ac1 	ldr	x1, [x22, #112]
 113df30:	aa1703e0 	mov	x0, x23
 113df34:	f94042d3 	ldr	x19, [x22, #128]
 113df38:	f94037f4 	ldr	x20, [sp, #104]
 113df3c:	d63f0020 	blr	x1
 113df40:	2a0003e1 	mov	w1, w0
 113df44:	aa1403e0 	mov	x0, x20
 113df48:	d63f0260 	blr	x19
         mp_clear(tmp);
 113df4c:	f941d715 	ldr	x21, [x24, #936]
      if (mp_2expt(tmp, mp_count_bits(num)) != CRYPT_OK || mp_sub(num, tmp, num) != CRYPT_OK) {
 113df50:	340000c0 	cbz	w0, 113df68 <der_decode_integer+0xdc>
         mp_clear(tmp);
 113df54:	f94016a1 	ldr	x1, [x21, #40]
 113df58:	f94037e0 	ldr	x0, [sp, #104]
 113df5c:	d63f0020 	blr	x1
         return CRYPT_MEM;
 113df60:	528001b3 	mov	w19, #0xd                   	// #13
 113df64:	1400000b 	b	113df90 <der_decode_integer+0x104>
      if (mp_2expt(tmp, mp_count_bits(num)) != CRYPT_OK || mp_sub(num, tmp, num) != CRYPT_OK) {
 113df68:	f94037e1 	ldr	x1, [sp, #104]
 113df6c:	aa1703e2 	mov	x2, x23
 113df70:	f94062c3 	ldr	x3, [x22, #192]
 113df74:	aa1703e0 	mov	x0, x23
 113df78:	d63f0060 	blr	x3
 113df7c:	2a0003f3 	mov	w19, w0
 113df80:	35fffea0 	cbnz	w0, 113df54 <der_decode_integer+0xc8>
         return CRYPT_MEM;
      }
      mp_clear(tmp);
 113df84:	f94016a1 	ldr	x1, [x21, #40]
 113df88:	f94037e0 	ldr	x0, [sp, #104]
 113df8c:	d63f0020 	blr	x1
   }

   return CRYPT_OK;

}
 113df90:	2a1303e0 	mov	w0, w19
 113df94:	a94153f3 	ldp	x19, x20, [sp, #16]
 113df98:	a9425bf5 	ldp	x21, x22, [sp, #32]
 113df9c:	a94363f7 	ldp	x23, x24, [sp, #48]
 113dfa0:	f94023f9 	ldr	x25, [sp, #64]
 113dfa4:	a8c77bfd 	ldp	x29, x30, [sp], #112
 113dfa8:	d65f03c0 	ret
   LTC_ARGCHK(num    != NULL);
 113dfac:	52800213 	mov	w19, #0x10                  	// #16
 113dfb0:	17fffff8 	b	113df90 <der_decode_integer+0x104>
      return CRYPT_INVALID_PACKET;
 113dfb4:	528000f3 	mov	w19, #0x7                   	// #7
 113dfb8:	17fffff6 	b	113df90 <der_decode_integer+0x104>

000000000113dfbc <der_encode_integer>:
  @param out      [out] The destination for the DER encoded integers
  @param outlen   [in/out] The max size and resulting size of the DER encoded integers
  @return CRYPT_OK if successful
*/
int der_encode_integer(void *num, unsigned char *out, unsigned long *outlen)
{
 113dfbc:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
 113dfc0:	910003fd 	mov	x29, sp
 113dfc4:	a90153f3 	stp	x19, x20, [sp, #16]
 113dfc8:	a9025bf5 	stp	x21, x22, [sp, #32]
 113dfcc:	a90363f7 	stp	x23, x24, [sp, #48]
 113dfd0:	a9046bf9 	stp	x25, x26, [sp, #64]
 113dfd4:	f9002bfb 	str	x27, [sp, #80]
   unsigned long tmplen, y, len;
   int           err, leading_zero;

   LTC_ARGCHK(num    != NULL);
 113dfd8:	b40014c0 	cbz	x0, 113e270 <der_encode_integer+0x2b4>
 113dfdc:	aa0103f5 	mov	x21, x1
   LTC_ARGCHK(out    != NULL);
 113dfe0:	b4001481 	cbz	x1, 113e270 <der_encode_integer+0x2b4>
 113dfe4:	aa0203f7 	mov	x23, x2
   LTC_ARGCHK(outlen != NULL);
 113dfe8:	b4001442 	cbz	x2, 113e270 <der_encode_integer+0x2b4>
 113dfec:	aa0003f3 	mov	x19, x0

   /* find out how big this will be */
   if ((err = der_length_integer(num, &tmplen)) != CRYPT_OK) {
 113dff0:	9101a3e1 	add	x1, sp, #0x68
 113dff4:	940000a3 	bl	113e280 <der_length_integer>
 113dff8:	2a0003f6 	mov	w22, w0
 113dffc:	350013e0 	cbnz	w0, 113e278 <der_encode_integer+0x2bc>
      return err;
   }

   if (*outlen < tmplen) {
 113e000:	f94002e1 	ldr	x1, [x23]
 113e004:	f94037e0 	ldr	x0, [sp, #104]
 113e008:	eb00003f 	cmp	x1, x0
 113e00c:	54000162 	b.cs	113e038 <der_encode_integer+0x7c>  // b.hs, b.nlast
      *outlen = tmplen;
      return CRYPT_BUFFER_OVERFLOW;
 113e010:	528000d4 	mov	w20, #0x6                   	// #6
      *outlen = tmplen;
 113e014:	f90002e0 	str	x0, [x23]
   }

   /* we good */
   *outlen = tmplen;
   return CRYPT_OK;
}
 113e018:	2a1403e0 	mov	w0, w20
 113e01c:	a94153f3 	ldp	x19, x20, [sp, #16]
 113e020:	a9425bf5 	ldp	x21, x22, [sp, #32]
 113e024:	a94363f7 	ldp	x23, x24, [sp, #48]
 113e028:	a9446bf9 	ldp	x25, x26, [sp, #64]
 113e02c:	f9402bfb 	ldr	x27, [sp, #80]
 113e030:	a8c87bfd 	ldp	x29, x30, [sp], #128
 113e034:	d65f03c0 	ret
   if (mp_cmp_d(num, 0) != LTC_MP_LT) {
 113e038:	900000fa 	adrp	x26, 115a000 <__scattered_array_1phys_mem_map+0x8>
 113e03c:	d2800001 	mov	x1, #0x0                   	// #0
 113e040:	aa1303e0 	mov	x0, x19
 113e044:	aa1a03f8 	mov	x24, x26
 113e048:	f941d759 	ldr	x25, [x26, #936]
 113e04c:	f9403722 	ldr	x2, [x25, #104]
 113e050:	d63f0040 	blr	x2
 113e054:	3100041f 	cmn	w0, #0x1
      if ((mp_count_bits(num) & 7) == 0 || mp_iszero(num) == LTC_MP_YES) {
 113e058:	aa1303e0 	mov	x0, x19
 113e05c:	f9403b21 	ldr	x1, [x25, #112]
   if (mp_cmp_d(num, 0) != LTC_MP_LT) {
 113e060:	540005e0 	b.eq	113e11c <der_encode_integer+0x160>  // b.none
      if ((mp_count_bits(num) & 7) == 0 || mp_iszero(num) == LTC_MP_YES) {
 113e064:	d63f0020 	blr	x1
 113e068:	f240081f 	tst	x0, #0x7
 113e06c:	54000540 	b.eq	113e114 <der_encode_integer+0x158>  // b.none
 113e070:	f9403722 	ldr	x2, [x25, #104]
 113e074:	aa1303e0 	mov	x0, x19
 113e078:	d2800001 	mov	x1, #0x0                   	// #0
 113e07c:	d63f0040 	blr	x2
 113e080:	7100001f 	cmp	w0, #0x0
 113e084:	1a9f17f6 	cset	w22, eq  // eq = none
      y = mp_unsigned_bin_size(num) + leading_zero;
 113e088:	f941d700 	ldr	x0, [x24, #936]
 113e08c:	f9404c01 	ldr	x1, [x0, #152]
 113e090:	aa1303e0 	mov	x0, x19
 113e094:	d63f0020 	blr	x1
 113e098:	8b36c014 	add	x20, x0, w22, sxtw
   *out++ = 0x02;
 113e09c:	52800040 	mov	w0, #0x2                   	// #2
 113e0a0:	380016a0 	strb	w0, [x21], #1
   if ((err = der_encode_asn1_length(y, out, &len)) != CRYPT_OK) {
 113e0a4:	9101c3e2 	add	x2, sp, #0x70
   len = *outlen - 1;
 113e0a8:	f94002e0 	ldr	x0, [x23]
   if ((err = der_encode_asn1_length(y, out, &len)) != CRYPT_OK) {
 113e0ac:	aa1503e1 	mov	x1, x21
   len = *outlen - 1;
 113e0b0:	d1000400 	sub	x0, x0, #0x1
 113e0b4:	f9003be0 	str	x0, [sp, #112]
   if ((err = der_encode_asn1_length(y, out, &len)) != CRYPT_OK) {
 113e0b8:	aa1403e0 	mov	x0, x20
 113e0bc:	97fffc71 	bl	113d280 <der_encode_asn1_length>
 113e0c0:	2a0003f4 	mov	w20, w0
 113e0c4:	35fffaa0 	cbnz	w0, 113e018 <der_encode_integer+0x5c>
   out += len;
 113e0c8:	f9403be0 	ldr	x0, [sp, #112]
 113e0cc:	8b0002b9 	add	x25, x21, x0
   if (leading_zero) {
 113e0d0:	34000076 	cbz	w22, 113e0dc <der_encode_integer+0x120>
      *out++ = 0x00;
 113e0d4:	91000739 	add	x25, x25, #0x1
 113e0d8:	38206abf 	strb	wzr, [x21, x0]
   if (mp_cmp_d(num, 0) == LTC_MP_GT) {
 113e0dc:	f941d715 	ldr	x21, [x24, #936]
 113e0e0:	aa1303e0 	mov	x0, x19
 113e0e4:	d2800001 	mov	x1, #0x0                   	// #0
 113e0e8:	f94036a2 	ldr	x2, [x21, #104]
 113e0ec:	d63f0040 	blr	x2
 113e0f0:	7100041f 	cmp	w0, #0x1
 113e0f4:	54000401 	b.ne	113e174 <der_encode_integer+0x1b8>  // b.any
      if ((err = mp_to_unsigned_bin(num, out)) != CRYPT_OK) {
 113e0f8:	f94052a2 	ldr	x2, [x21, #160]
 113e0fc:	aa1903e1 	mov	x1, x25
 113e100:	aa1303e0 	mov	x0, x19
 113e104:	d63f0040 	blr	x2
 113e108:	34000ae0 	cbz	w0, 113e264 <der_encode_integer+0x2a8>
 113e10c:	2a0003f4 	mov	w20, w0
 113e110:	17ffffc2 	b	113e018 <der_encode_integer+0x5c>
         leading_zero = 1;
 113e114:	52800036 	mov	w22, #0x1                   	// #1
 113e118:	17ffffdc 	b	113e088 <der_encode_integer+0xcc>
      y            = mp_count_bits(num);
 113e11c:	d63f0020 	blr	x1
 113e120:	93407c14 	sxtw	x20, w0
      if (((mp_cnt_lsb(num)+1)==mp_count_bits(num)) && ((mp_count_bits(num)&7)==0)) --y;
 113e124:	f9403f21 	ldr	x1, [x25, #120]
 113e128:	aa1303e0 	mov	x0, x19
      y            = y + (8 - (y & 7));
 113e12c:	927df294 	and	x20, x20, #0xfffffffffffffff8
 113e130:	91002294 	add	x20, x20, #0x8
      if (((mp_cnt_lsb(num)+1)==mp_count_bits(num)) && ((mp_count_bits(num)&7)==0)) --y;
 113e134:	d63f0020 	blr	x1
 113e138:	2a0003fa 	mov	w26, w0
 113e13c:	f9403b21 	ldr	x1, [x25, #112]
 113e140:	1100075a 	add	w26, w26, #0x1
 113e144:	aa1303e0 	mov	x0, x19
      y            = y >> 3;
 113e148:	d343fe94 	lsr	x20, x20, #3
      if (((mp_cnt_lsb(num)+1)==mp_count_bits(num)) && ((mp_count_bits(num)&7)==0)) --y;
 113e14c:	d63f0020 	blr	x1
 113e150:	6b00035f 	cmp	w26, w0
 113e154:	54fffa41 	b.ne	113e09c <der_encode_integer+0xe0>  // b.any
 113e158:	f9403b21 	ldr	x1, [x25, #112]
 113e15c:	aa1303e0 	mov	x0, x19
 113e160:	d63f0020 	blr	x1
 113e164:	f240081f 	tst	x0, #0x7
 113e168:	9a9f17e0 	cset	x0, eq  // eq = none
 113e16c:	cb000294 	sub	x20, x20, x0
 113e170:	17ffffcb 	b	113e09c <der_encode_integer+0xe0>
   } else if (mp_iszero(num) != LTC_MP_YES) {
 113e174:	f94036a2 	ldr	x2, [x21, #104]
 113e178:	aa1303e0 	mov	x0, x19
 113e17c:	d2800001 	mov	x1, #0x0                   	// #0
 113e180:	d63f0040 	blr	x2
 113e184:	34000700 	cbz	w0, 113e264 <der_encode_integer+0x2a8>
      if (mp_init(&tmp) != CRYPT_OK) {
 113e188:	f9400aa1 	ldr	x1, [x21, #16]
 113e18c:	9101e3e0 	add	x0, sp, #0x78
 113e190:	d63f0020 	blr	x1
 113e194:	35000400 	cbnz	w0, 113e214 <der_encode_integer+0x258>
      y = mp_count_bits(num);
 113e198:	f9403aa1 	ldr	x1, [x21, #112]
 113e19c:	aa1303e0 	mov	x0, x19
 113e1a0:	d63f0020 	blr	x1
 113e1a4:	93407c16 	sxtw	x22, w0
      if (((mp_cnt_lsb(num)+1)==mp_count_bits(num)) && ((mp_count_bits(num)&7)==0)) y -= 8;
 113e1a8:	f9403ea1 	ldr	x1, [x21, #120]
 113e1ac:	aa1303e0 	mov	x0, x19
      y = y + (8 - (y & 7));
 113e1b0:	927df2d6 	and	x22, x22, #0xfffffffffffffff8
 113e1b4:	910022db 	add	x27, x22, #0x8
      if (((mp_cnt_lsb(num)+1)==mp_count_bits(num)) && ((mp_count_bits(num)&7)==0)) y -= 8;
 113e1b8:	d63f0020 	blr	x1
 113e1bc:	2a0003fa 	mov	w26, w0
 113e1c0:	f9403aa1 	ldr	x1, [x21, #112]
 113e1c4:	1100075a 	add	w26, w26, #0x1
 113e1c8:	aa1303e0 	mov	x0, x19
 113e1cc:	d63f0020 	blr	x1
 113e1d0:	6b00035f 	cmp	w26, w0
 113e1d4:	540000c1 	b.ne	113e1ec <der_encode_integer+0x230>  // b.any
 113e1d8:	f9403aa1 	ldr	x1, [x21, #112]
 113e1dc:	aa1303e0 	mov	x0, x19
 113e1e0:	d63f0020 	blr	x1
 113e1e4:	f240081f 	tst	x0, #0x7
 113e1e8:	9a96137b 	csel	x27, x27, x22, ne  // ne = any
      if (mp_2expt(tmp, y) != CRYPT_OK || mp_add(tmp, num, tmp) != CRYPT_OK) {
 113e1ec:	f941d715 	ldr	x21, [x24, #936]
 113e1f0:	2a1b03e1 	mov	w1, w27
 113e1f4:	f9403fe0 	ldr	x0, [sp, #120]
 113e1f8:	f94042a2 	ldr	x2, [x21, #128]
 113e1fc:	d63f0040 	blr	x2
 113e200:	340000e0 	cbz	w0, 113e21c <der_encode_integer+0x260>
         mp_clear(tmp);
 113e204:	f941d718 	ldr	x24, [x24, #936]
 113e208:	f9403fe0 	ldr	x0, [sp, #120]
 113e20c:	f9401701 	ldr	x1, [x24, #40]
 113e210:	d63f0020 	blr	x1
         return CRYPT_MEM;
 113e214:	528001b3 	mov	w19, #0xd                   	// #13
 113e218:	14000010 	b	113e258 <der_encode_integer+0x29c>
      if (mp_2expt(tmp, y) != CRYPT_OK || mp_add(tmp, num, tmp) != CRYPT_OK) {
 113e21c:	f9403fe2 	ldr	x2, [sp, #120]
 113e220:	aa1303e1 	mov	x1, x19
 113e224:	f9405aa3 	ldr	x3, [x21, #176]
 113e228:	aa0203e0 	mov	x0, x2
 113e22c:	d63f0060 	blr	x3
 113e230:	35fffea0 	cbnz	w0, 113e204 <der_encode_integer+0x248>
      if ((err = mp_to_unsigned_bin(tmp, out)) != CRYPT_OK) {
 113e234:	f9403fe0 	ldr	x0, [sp, #120]
 113e238:	aa1903e1 	mov	x1, x25
 113e23c:	f94052a2 	ldr	x2, [x21, #160]
 113e240:	d63f0040 	blr	x2
 113e244:	2a0003f3 	mov	w19, w0
         mp_clear(tmp);
 113e248:	f94016a1 	ldr	x1, [x21, #40]
 113e24c:	f9403fe0 	ldr	x0, [sp, #120]
      if ((err = mp_to_unsigned_bin(tmp, out)) != CRYPT_OK) {
 113e250:	34000093 	cbz	w19, 113e260 <der_encode_integer+0x2a4>
         mp_clear(tmp);
 113e254:	d63f0020 	blr	x1
         return CRYPT_MEM;
 113e258:	2a1303f4 	mov	w20, w19
 113e25c:	17ffff6f 	b	113e018 <der_encode_integer+0x5c>
      mp_clear(tmp);
 113e260:	d63f0020 	blr	x1
   *outlen = tmplen;
 113e264:	f94037e0 	ldr	x0, [sp, #104]
 113e268:	f90002e0 	str	x0, [x23]
   return CRYPT_OK;
 113e26c:	17ffff6b 	b	113e018 <der_encode_integer+0x5c>
   LTC_ARGCHK(num    != NULL);
 113e270:	52800214 	mov	w20, #0x10                  	// #16
 113e274:	17ffff69 	b	113e018 <der_encode_integer+0x5c>
 113e278:	2a0003f4 	mov	w20, w0
 113e27c:	17ffff67 	b	113e018 <der_encode_integer+0x5c>

000000000113e280 <der_length_integer>:
int der_length_integer(void *num, unsigned long *outlen)
{
   unsigned long z, len;
   int           leading_zero, err;

   LTC_ARGCHK(num     != NULL);
 113e280:	b4000900 	cbz	x0, 113e3a0 <der_length_integer+0x120>
{
 113e284:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 113e288:	910003fd 	mov	x29, sp
 113e28c:	a90153f3 	stp	x19, x20, [sp, #16]
 113e290:	a9025bf5 	stp	x21, x22, [sp, #32]
 113e294:	aa0103f6 	mov	x22, x1
   LTC_ARGCHK(outlen  != NULL);
 113e298:	b4000881 	cbz	x1, 113e3a8 <der_length_integer+0x128>

   if (mp_cmp_d(num, 0) != LTC_MP_LT) {
 113e29c:	900000f3 	adrp	x19, 115a000 <__scattered_array_1phys_mem_map+0x8>
 113e2a0:	aa0003f4 	mov	x20, x0
 113e2a4:	d2800001 	mov	x1, #0x0                   	// #0
 113e2a8:	f941d673 	ldr	x19, [x19, #936]
 113e2ac:	f9403662 	ldr	x2, [x19, #104]
 113e2b0:	d63f0040 	blr	x2
 113e2b4:	3100041f 	cmn	w0, #0x1
      /* positive */

      /* we only need a leading zero if the msb of the first byte is one */
      if ((mp_count_bits(num) & 7) == 0 || mp_iszero(num) == LTC_MP_YES) {
 113e2b8:	aa1403e0 	mov	x0, x20
 113e2bc:	f9403a61 	ldr	x1, [x19, #112]
   if (mp_cmp_d(num, 0) != LTC_MP_LT) {
 113e2c0:	540003c0 	b.eq	113e338 <der_length_integer+0xb8>  // b.none
      if ((mp_count_bits(num) & 7) == 0 || mp_iszero(num) == LTC_MP_YES) {
 113e2c4:	d63f0020 	blr	x1
 113e2c8:	f240081f 	tst	x0, #0x7
 113e2cc:	54000320 	b.eq	113e330 <der_length_integer+0xb0>  // b.none
 113e2d0:	f9403662 	ldr	x2, [x19, #104]
 113e2d4:	aa1403e0 	mov	x0, x20
 113e2d8:	d2800001 	mov	x1, #0x0                   	// #0
 113e2dc:	d63f0040 	blr	x2
 113e2e0:	7100001f 	cmp	w0, #0x0
 113e2e4:	1a9f17f5 	cset	w21, eq  // eq = none
      } else {
         leading_zero = 0;
      }

      /* size for bignum */
      len = leading_zero + mp_unsigned_bin_size(num);
 113e2e8:	900000f3 	adrp	x19, 115a000 <__scattered_array_1phys_mem_map+0x8>
 113e2ec:	aa1403e0 	mov	x0, x20
 113e2f0:	f941d673 	ldr	x19, [x19, #936]
 113e2f4:	f9404e61 	ldr	x1, [x19, #152]
 113e2f8:	d63f0020 	blr	x1
 113e2fc:	8b35c013 	add	x19, x0, w21, sxtw
      z = z + (8 - (z & 7));
      if (((mp_cnt_lsb(num)+1)==mp_count_bits(num)) && ((mp_count_bits(num)&7)==0)) --z;
      len = z >> 3;
   }

   if ((err = der_length_asn1_length(len, &z)) != CRYPT_OK) {
 113e300:	9100e3e1 	add	x1, sp, #0x38
 113e304:	aa1303e0 	mov	x0, x19
 113e308:	97fffc5e 	bl	113d480 <der_length_asn1_length>
 113e30c:	350000a0 	cbnz	w0, 113e320 <der_length_integer+0xa0>
      return err;
   }
   *outlen = 1 + z + len;
 113e310:	f9401fe1 	ldr	x1, [sp, #56]
 113e314:	91000421 	add	x1, x1, #0x1
 113e318:	8b130033 	add	x19, x1, x19
 113e31c:	f90002d3 	str	x19, [x22]

   return CRYPT_OK;
}
 113e320:	a94153f3 	ldp	x19, x20, [sp, #16]
 113e324:	a9425bf5 	ldp	x21, x22, [sp, #32]
 113e328:	a8c47bfd 	ldp	x29, x30, [sp], #64
 113e32c:	d65f03c0 	ret
         leading_zero = 1;
 113e330:	52800035 	mov	w21, #0x1                   	// #1
 113e334:	17ffffed 	b	113e2e8 <der_length_integer+0x68>
      z = mp_count_bits(num);
 113e338:	d63f0020 	blr	x1
 113e33c:	93407c00 	sxtw	x0, w0
      if (((mp_cnt_lsb(num)+1)==mp_count_bits(num)) && ((mp_count_bits(num)&7)==0)) --z;
 113e340:	f9403e61 	ldr	x1, [x19, #120]
      z = z + (8 - (z & 7));
 113e344:	927df000 	and	x0, x0, #0xfffffffffffffff8
 113e348:	91002000 	add	x0, x0, #0x8
 113e34c:	f9001fe0 	str	x0, [sp, #56]
      if (((mp_cnt_lsb(num)+1)==mp_count_bits(num)) && ((mp_count_bits(num)&7)==0)) --z;
 113e350:	aa1403e0 	mov	x0, x20
 113e354:	d63f0020 	blr	x1
 113e358:	2a0003f5 	mov	w21, w0
 113e35c:	f9403a61 	ldr	x1, [x19, #112]
 113e360:	110006b5 	add	w21, w21, #0x1
 113e364:	aa1403e0 	mov	x0, x20
 113e368:	d63f0020 	blr	x1
 113e36c:	6b0002bf 	cmp	w21, w0
 113e370:	54000121 	b.ne	113e394 <der_length_integer+0x114>  // b.any
 113e374:	f9403a61 	ldr	x1, [x19, #112]
 113e378:	aa1403e0 	mov	x0, x20
 113e37c:	d63f0020 	blr	x1
 113e380:	f240081f 	tst	x0, #0x7
 113e384:	54000081 	b.ne	113e394 <der_length_integer+0x114>  // b.any
 113e388:	f9401fe0 	ldr	x0, [sp, #56]
 113e38c:	d1000400 	sub	x0, x0, #0x1
 113e390:	f9001fe0 	str	x0, [sp, #56]
      len = z >> 3;
 113e394:	f9401ff3 	ldr	x19, [sp, #56]
 113e398:	d343fe73 	lsr	x19, x19, #3
 113e39c:	17ffffd9 	b	113e300 <der_length_integer+0x80>
   LTC_ARGCHK(num     != NULL);
 113e3a0:	52800200 	mov	w0, #0x10                  	// #16
}
 113e3a4:	d65f03c0 	ret
   LTC_ARGCHK(num     != NULL);
 113e3a8:	52800200 	mov	w0, #0x10                  	// #16
 113e3ac:	17ffffdd 	b	113e320 <der_length_integer+0xa0>

000000000113e3b0 <der_decode_object_identifier>:
                                       unsigned long *words, unsigned long *outlen)
{
   unsigned long x, y, t, len;
   int err;

   LTC_ARGCHK(in     != NULL);
 113e3b0:	b4000b00 	cbz	x0, 113e510 <der_decode_object_identifier+0x160>
{
 113e3b4:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 113e3b8:	910003fd 	mov	x29, sp
 113e3bc:	a90153f3 	stp	x19, x20, [sp, #16]
 113e3c0:	aa0203f3 	mov	x19, x2
 113e3c4:	a9025bf5 	stp	x21, x22, [sp, #32]
   LTC_ARGCHK(words  != NULL);
 113e3c8:	b4000a82 	cbz	x2, 113e518 <der_decode_object_identifier+0x168>
 113e3cc:	aa0303f4 	mov	x20, x3
   LTC_ARGCHK(outlen != NULL);
 113e3d0:	b4000a43 	cbz	x3, 113e518 <der_decode_object_identifier+0x168>
 113e3d4:	aa0103f5 	mov	x21, x1

   /* header is at least 3 bytes */
   if (inlen < 3) {
 113e3d8:	f100083f 	cmp	x1, #0x2
 113e3dc:	540000c8 	b.hi	113e3f4 <der_decode_object_identifier+0x44>  // b.pmore
      return CRYPT_INVALID_PACKET;
 113e3e0:	528000e0 	mov	w0, #0x7                   	// #7
      err =  CRYPT_OK;
   }

   *outlen = y;
   return err;
}
 113e3e4:	a94153f3 	ldp	x19, x20, [sp, #16]
 113e3e8:	a9425bf5 	ldp	x21, x22, [sp, #32]
 113e3ec:	a8c47bfd 	ldp	x29, x30, [sp], #64
 113e3f0:	d65f03c0 	ret
 113e3f4:	aa0003f6 	mov	x22, x0
   if (*outlen < 2) {
 113e3f8:	f9400060 	ldr	x0, [x3]
 113e3fc:	f100041f 	cmp	x0, #0x1
 113e400:	540000a8 	b.hi	113e414 <der_decode_object_identifier+0x64>  // b.pmore
      *outlen = 2;
 113e404:	d2800040 	mov	x0, #0x2                   	// #2
 113e408:	f9000060 	str	x0, [x3]
      return CRYPT_BUFFER_OVERFLOW;
 113e40c:	528000c0 	mov	w0, #0x6                   	// #6
 113e410:	17fffff5 	b	113e3e4 <der_decode_object_identifier+0x34>
   if ((in[x++] & 0x1F) != 0x06) {
 113e414:	394002c0 	ldrb	w0, [x22]
 113e418:	12001000 	and	w0, w0, #0x1f
 113e41c:	7100181f 	cmp	w0, #0x6
 113e420:	54fffe01 	b.ne	113e3e0 <der_decode_object_identifier+0x30>  // b.any
   y = inlen - x;
 113e424:	d1000420 	sub	x0, x1, #0x1
   if ((err = der_decode_asn1_length(in + x, &y, &len)) != CRYPT_OK) {
 113e428:	9100e3e2 	add	x2, sp, #0x38
 113e42c:	9100c3e1 	add	x1, sp, #0x30
   y = inlen - x;
 113e430:	f9001be0 	str	x0, [sp, #48]
   if ((err = der_decode_asn1_length(in + x, &y, &len)) != CRYPT_OK) {
 113e434:	910006c0 	add	x0, x22, #0x1
 113e438:	97fffad2 	bl	113cf80 <der_decode_asn1_length>
 113e43c:	35fffd40 	cbnz	w0, 113e3e4 <der_decode_object_identifier+0x34>
   if ((len == 0) || (len > (inlen - x))) {
 113e440:	a9430be1 	ldp	x1, x2, [sp, #48]
   x += y;
 113e444:	91000420 	add	x0, x1, #0x1
   if ((len == 0) || (len > (inlen - x))) {
 113e448:	b4fffcc2 	cbz	x2, 113e3e0 <der_decode_object_identifier+0x30>
 113e44c:	cb0002b5 	sub	x21, x21, x0
 113e450:	eb15005f 	cmp	x2, x21
 113e454:	54fffc68 	b.hi	113e3e0 <der_decode_object_identifier+0x30>  // b.pmore
   y = 0;
 113e458:	8b020021 	add	x1, x1, x2
   while (len--) {
 113e45c:	52800003 	mov	w3, #0x0                   	// #0
 113e460:	91000422 	add	x2, x1, #0x1
 113e464:	d2800004 	mov	x4, #0x0                   	// #0
   t = 0;
 113e468:	d2800001 	mov	x1, #0x0                   	// #0
                  words[0] = 2;
 113e46c:	d2800048 	mov	x8, #0x2                   	// #2
                  words[0] = t / 40;
 113e470:	d2800506 	mov	x6, #0x28                  	// #40
   y = 0;
 113e474:	f9001bff 	str	xzr, [sp, #48]
   while (len--) {
 113e478:	eb02001f 	cmp	x0, x2
 113e47c:	f9400285 	ldr	x5, [x20]
 113e480:	54000121 	b.ne	113e4a4 <der_decode_object_identifier+0xf4>  // b.any
 113e484:	34000043 	cbz	w3, 113e48c <der_decode_object_identifier+0xdc>
 113e488:	f9001be4 	str	x4, [sp, #48]
   if (y > *outlen) {
 113e48c:	f9401be1 	ldr	x1, [sp, #48]
      err =  CRYPT_BUFFER_OVERFLOW;
 113e490:	528000c0 	mov	w0, #0x6                   	// #6
   *outlen = y;
 113e494:	f9000281 	str	x1, [x20]
      err =  CRYPT_BUFFER_OVERFLOW;
 113e498:	eb05003f 	cmp	x1, x5
 113e49c:	1a8093e0 	csel	w0, wzr, w0, ls  // ls = plast
   return err;
 113e4a0:	17ffffd1 	b	113e3e4 <der_decode_object_identifier+0x34>
      t = (t << 7) | (in[x] & 0x7F);
 113e4a4:	38606ac7 	ldrb	w7, [x22, x0]
      if (!(in[x++] & 0x80)) {
 113e4a8:	91000400 	add	x0, x0, #0x1
      t = (t << 7) | (in[x] & 0x7F);
 113e4ac:	924018e9 	and	x9, x7, #0x7f
 113e4b0:	aa011d21 	orr	x1, x9, x1, lsl #7
      if (!(in[x++] & 0x80)) {
 113e4b4:	373ffe27 	tbnz	w7, #7, 113e478 <der_decode_object_identifier+0xc8>
         if (y >= *outlen) {
 113e4b8:	eb0400bf 	cmp	x5, x4
 113e4bc:	540000a8 	b.hi	113e4d0 <der_decode_object_identifier+0x120>  // b.pmore
               words[y++] = t;
 113e4c0:	91000484 	add	x4, x4, #0x1
 113e4c4:	52800023 	mov	w3, #0x1                   	// #1
         t = 0;
 113e4c8:	d2800001 	mov	x1, #0x0                   	// #0
 113e4cc:	17ffffeb 	b	113e478 <der_decode_object_identifier+0xc8>
            if (y == 0) {
 113e4d0:	b50001c4 	cbnz	x4, 113e508 <der_decode_object_identifier+0x158>
               if (t <= 79) {
 113e4d4:	f1013c3f 	cmp	x1, #0x4f
 113e4d8:	54000128 	b.hi	113e4fc <der_decode_object_identifier+0x14c>  // b.pmore
                  words[0] = t / 40;
 113e4dc:	9ac60823 	udiv	x3, x1, x6
                  words[1] = t % 40;
 113e4e0:	9b068461 	msub	x1, x3, x6, x1
                  words[0] = t / 40;
 113e4e4:	f9000263 	str	x3, [x19]
                  words[1] = t % 40;
 113e4e8:	52800023 	mov	w3, #0x1                   	// #1
               y = 2;
 113e4ec:	d2800044 	mov	x4, #0x2                   	// #2
                  words[1] = t - 80;
 113e4f0:	f9000661 	str	x1, [x19, #8]
         t = 0;
 113e4f4:	d2800001 	mov	x1, #0x0                   	// #0
 113e4f8:	17ffffe0 	b	113e478 <der_decode_object_identifier+0xc8>
                  words[1] = t - 80;
 113e4fc:	d1014021 	sub	x1, x1, #0x50
                  words[0] = 2;
 113e500:	f9000268 	str	x8, [x19]
                  words[1] = t - 80;
 113e504:	17fffff9 	b	113e4e8 <der_decode_object_identifier+0x138>
               words[y++] = t;
 113e508:	f8247a61 	str	x1, [x19, x4, lsl #3]
 113e50c:	17ffffed 	b	113e4c0 <der_decode_object_identifier+0x110>
   LTC_ARGCHK(in     != NULL);
 113e510:	52800200 	mov	w0, #0x10                  	// #16
}
 113e514:	d65f03c0 	ret
   LTC_ARGCHK(in     != NULL);
 113e518:	52800200 	mov	w0, #0x10                  	// #16
 113e51c:	17ffffb2 	b	113e3e4 <der_decode_object_identifier+0x34>

000000000113e520 <der_encode_object_identifier>:
                                       unsigned char *out,   unsigned long *outlen)
{
   unsigned long i, x, y, z, t, mask, wordbuf;
   int           err;

   LTC_ARGCHK(words  != NULL);
 113e520:	b4000e80 	cbz	x0, 113e6f0 <der_encode_object_identifier+0x1d0>
{
 113e524:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
 113e528:	910003fd 	mov	x29, sp
 113e52c:	a90153f3 	stp	x19, x20, [sp, #16]
 113e530:	aa0203f3 	mov	x19, x2
 113e534:	a9025bf5 	stp	x21, x22, [sp, #32]
 113e538:	a90363f7 	stp	x23, x24, [sp, #48]
 113e53c:	a9046bf9 	stp	x25, x26, [sp, #64]
   LTC_ARGCHK(out    != NULL);
 113e540:	b4000dc2 	cbz	x2, 113e6f8 <der_encode_object_identifier+0x1d8>
 113e544:	aa0303f5 	mov	x21, x3
   LTC_ARGCHK(outlen != NULL);
 113e548:	b4000d83 	cbz	x3, 113e6f8 <der_encode_object_identifier+0x1d8>
 113e54c:	aa0003f4 	mov	x20, x0
 113e550:	aa0103f6 	mov	x22, x1

   /* check length */
   if ((err = der_length_object_identifier(words, nwords, &x)) != CRYPT_OK) {
 113e554:	910143e2 	add	x2, sp, #0x50
 113e558:	94000071 	bl	113e71c <der_length_object_identifier>
 113e55c:	350000e0 	cbnz	w0, 113e578 <der_encode_object_identifier+0x58>
      return err;
   }
   if (x > *outlen) {
 113e560:	f94002a1 	ldr	x1, [x21]
 113e564:	f9402be0 	ldr	x0, [sp, #80]
 113e568:	eb00003f 	cmp	x1, x0
 113e56c:	54000122 	b.cs	113e590 <der_encode_object_identifier+0x70>  // b.hs, b.nlast
      *outlen = x;
 113e570:	f90002a0 	str	x0, [x21]
      return CRYPT_BUFFER_OVERFLOW;
 113e574:	528000c0 	mov	w0, #0x6                   	// #6
      }
   }

   *outlen = x;
   return CRYPT_OK;
}
 113e578:	a94153f3 	ldp	x19, x20, [sp, #16]
 113e57c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 113e580:	a94363f7 	ldp	x23, x24, [sp, #48]
 113e584:	a9446bf9 	ldp	x25, x26, [sp, #64]
 113e588:	a8c67bfd 	ldp	x29, x30, [sp], #96
 113e58c:	d65f03c0 	ret
   wordbuf = words[0] * 40 + words[1];
 113e590:	a9400297 	ldp	x23, x0, [x20]
 113e594:	d2800501 	mov	x1, #0x28                  	// #40
       if (y < nwords - 1) {
 113e598:	d10006da 	sub	x26, x22, #0x1
   z = 0;
 113e59c:	d2800018 	mov	x24, #0x0                   	// #0
       z += t/7 + ((t%7) ? 1 : 0) + (wordbuf == 0 ? 1 : 0);
 113e5a0:	d28000f9 	mov	x25, #0x7                   	// #7
   wordbuf = words[0] * 40 + words[1];
 113e5a4:	9b0102f7 	madd	x23, x23, x1, x0
   for (y = 1; y < nwords; y++) {
 113e5a8:	d2800020 	mov	x0, #0x1                   	// #1
 113e5ac:	f9002fe0 	str	x0, [sp, #88]
 113e5b0:	f9402fe0 	ldr	x0, [sp, #88]
 113e5b4:	eb16001f 	cmp	x0, x22
 113e5b8:	540003c3 	b.cc	113e630 <der_encode_object_identifier+0x110>  // b.lo, b.ul, b.last
   out[x++] = 0x06;
 113e5bc:	aa1303e1 	mov	x1, x19
 113e5c0:	528000c0 	mov	w0, #0x6                   	// #6
 113e5c4:	d2800037 	mov	x23, #0x1                   	// #1
   if ((err = der_encode_asn1_length(z, out + x, &y)) != CRYPT_OK) {
 113e5c8:	910163e2 	add	x2, sp, #0x58
   out[x++] = 0x06;
 113e5cc:	38001420 	strb	w0, [x1], #1
   y = *outlen - x;
 113e5d0:	f94002a0 	ldr	x0, [x21]
 113e5d4:	d1000400 	sub	x0, x0, #0x1
 113e5d8:	a90503f7 	stp	x23, x0, [sp, #80]
   if ((err = der_encode_asn1_length(z, out + x, &y)) != CRYPT_OK) {
 113e5dc:	aa1803e0 	mov	x0, x24
 113e5e0:	97fffb28 	bl	113d280 <der_encode_asn1_length>
 113e5e4:	35fffca0 	cbnz	w0, 113e578 <der_encode_object_identifier+0x58>
   x += y;
 113e5e8:	a94507e4 	ldp	x4, x1, [sp, #80]
   wordbuf = words[0] * 40 + words[1];
 113e5ec:	d2800502 	mov	x2, #0x28                  	// #40
 113e5f0:	f9400283 	ldr	x3, [x20]
            out[x++] = (unsigned char)((t & 0x7F) | mask);
 113e5f4:	d1000669 	sub	x9, x19, #0x1
      if (i < nwords - 1) {
 113e5f8:	d10006ca 	sub	x10, x22, #0x1
   x += y;
 113e5fc:	8b010084 	add	x4, x4, x1
 113e600:	f9002be4 	str	x4, [sp, #80]
   wordbuf = words[0] * 40 + words[1];
 113e604:	f9400681 	ldr	x1, [x20, #8]
 113e608:	9b020463 	madd	x3, x3, x2, x1
   for (i = 1; i < nwords; i++) {
 113e60c:	aa1703e2 	mov	x2, x23
 113e610:	52800001 	mov	w1, #0x0                   	// #0
 113e614:	eb16005f 	cmp	x2, x22
 113e618:	540002c3 	b.cc	113e670 <der_encode_object_identifier+0x150>  // b.lo, b.ul, b.last
 113e61c:	34000041 	cbz	w1, 113e624 <der_encode_object_identifier+0x104>
 113e620:	f9002be4 	str	x4, [sp, #80]
   *outlen = x;
 113e624:	f9402be1 	ldr	x1, [sp, #80]
 113e628:	f90002a1 	str	x1, [x21]
   return CRYPT_OK;
 113e62c:	17ffffd3 	b	113e578 <der_encode_object_identifier+0x58>
       t = der_object_identifier_bits(wordbuf);
 113e630:	aa1703e0 	mov	x0, x23
 113e634:	94000033 	bl	113e700 <der_object_identifier_bits>
       z += t/7 + ((t%7) ? 1 : 0) + (wordbuf == 0 ? 1 : 0);
 113e638:	9ad90801 	udiv	x1, x0, x25
 113e63c:	f10002ff 	cmp	x23, #0x0
 113e640:	9a981718 	cinc	x24, x24, eq  // eq = none
 113e644:	9b198020 	msub	x0, x1, x25, x0
 113e648:	f100001f 	cmp	x0, #0x0
       if (y < nwords - 1) {
 113e64c:	f9402fe0 	ldr	x0, [sp, #88]
       z += t/7 + ((t%7) ? 1 : 0) + (wordbuf == 0 ? 1 : 0);
 113e650:	9a810421 	cinc	x1, x1, ne  // ne = any
 113e654:	8b180038 	add	x24, x1, x24
       if (y < nwords - 1) {
 113e658:	eb00035f 	cmp	x26, x0
 113e65c:	91000400 	add	x0, x0, #0x1
 113e660:	54000049 	b.ls	113e668 <der_encode_object_identifier+0x148>  // b.plast
          wordbuf = words[y + 1];
 113e664:	f8607a97 	ldr	x23, [x20, x0, lsl #3]
   for (y = 1; y < nwords; y++) {
 113e668:	f9002fe0 	str	x0, [sp, #88]
 113e66c:	17ffffd1 	b	113e5b0 <der_encode_object_identifier+0x90>
      if (t) {
 113e670:	92407c66 	and	x6, x3, #0xffffffff
 113e674:	34000383 	cbz	w3, 113e6e4 <der_encode_object_identifier+0x1c4>
 113e678:	aa0403e1 	mov	x1, x4
         mask = 0;
 113e67c:	d2800008 	mov	x8, #0x0                   	// #0
            out[x++] = (unsigned char)((t & 0x7F) | mask);
 113e680:	aa0103e5 	mov	x5, x1
 113e684:	91000421 	add	x1, x1, #0x1
 113e688:	120018c7 	and	w7, w6, #0x7f
            t    >>= 7;
 113e68c:	d347fcc6 	lsr	x6, x6, #7
            out[x++] = (unsigned char)((t & 0x7F) | mask);
 113e690:	2a0800e7 	orr	w7, w7, w8
            mask  |= 0x80;  /* upper bit is set on all but the last byte */
 113e694:	d2801008 	mov	x8, #0x80                  	// #128
            out[x++] = (unsigned char)((t & 0x7F) | mask);
 113e698:	38216927 	strb	w7, [x9, x1]
         while (t) {
 113e69c:	b5ffff26 	cbnz	x6, 113e680 <der_encode_object_identifier+0x160>
         while (y < z) {
 113e6a0:	eb05009f 	cmp	x4, x5
 113e6a4:	54000123 	b.cc	113e6c8 <der_encode_object_identifier+0x1a8>  // b.lo, b.ul, b.last
      if (i < nwords - 1) {
 113e6a8:	91000445 	add	x5, x2, #0x1
 113e6ac:	eb02015f 	cmp	x10, x2
 113e6b0:	54000049 	b.ls	113e6b8 <der_encode_object_identifier+0x198>  // b.plast
         wordbuf = words[i + 1];
 113e6b4:	f8657a83 	ldr	x3, [x20, x5, lsl #3]
   for (i = 1; i < nwords; i++) {
 113e6b8:	aa0103e4 	mov	x4, x1
 113e6bc:	aa0503e2 	mov	x2, x5
 113e6c0:	52800021 	mov	w1, #0x1                   	// #1
 113e6c4:	17ffffd4 	b	113e614 <der_encode_object_identifier+0xf4>
            t = out[y]; out[y] = out[z]; out[z] = (unsigned char)t;
 113e6c8:	38656a67 	ldrb	w7, [x19, x5]
 113e6cc:	38646a66 	ldrb	w6, [x19, x4]
 113e6d0:	38246a67 	strb	w7, [x19, x4]
            ++y;
 113e6d4:	91000484 	add	x4, x4, #0x1
            t = out[y]; out[y] = out[z]; out[z] = (unsigned char)t;
 113e6d8:	38256a66 	strb	w6, [x19, x5]
            --z;
 113e6dc:	d10004a5 	sub	x5, x5, #0x1
 113e6e0:	17fffff0 	b	113e6a0 <der_encode_object_identifier+0x180>
 113e6e4:	91000481 	add	x1, x4, #0x1
         out[x++] = 0x00;
 113e6e8:	38246a7f 	strb	wzr, [x19, x4]
 113e6ec:	17ffffef 	b	113e6a8 <der_encode_object_identifier+0x188>
   LTC_ARGCHK(words  != NULL);
 113e6f0:	52800200 	mov	w0, #0x10                  	// #16
}
 113e6f4:	d65f03c0 	ret
   LTC_ARGCHK(words  != NULL);
 113e6f8:	52800200 	mov	w0, #0x10                  	// #16
 113e6fc:	17ffff9f 	b	113e578 <der_encode_object_identifier+0x58>

000000000113e700 <der_object_identifier_bits>:
#ifdef LTC_DER

unsigned long der_object_identifier_bits(unsigned long x)
{
   unsigned long c;
   x &= 0xFFFFFFFF;
 113e700:	2a0003e1 	mov	w1, w0
   c  = 0;
 113e704:	d2800000 	mov	x0, #0x0                   	// #0
   while (x) {
 113e708:	b5000041 	cbnz	x1, 113e710 <der_object_identifier_bits+0x10>
     ++c;
     x >>= 1;
   }
   return c;
}
 113e70c:	d65f03c0 	ret
     ++c;
 113e710:	91000400 	add	x0, x0, #0x1
     x >>= 1;
 113e714:	d341fc21 	lsr	x1, x1, #1
 113e718:	17fffffc 	b	113e708 <der_object_identifier_bits+0x8>

000000000113e71c <der_length_object_identifier>:
*/
int der_length_object_identifier(const unsigned long *words, unsigned long nwords, unsigned long *outlen)
{
   unsigned long y, z, t, wordbuf;

   LTC_ARGCHK(words  != NULL);
 113e71c:	b4000680 	cbz	x0, 113e7ec <der_length_object_identifier+0xd0>
   LTC_ARGCHK(outlen != NULL);
 113e720:	b4000662 	cbz	x2, 113e7ec <der_length_object_identifier+0xd0>
 113e724:	aa0103e6 	mov	x6, x1


   /* must be >= 2 words */
   if (nwords < 2) {
 113e728:	f100043f 	cmp	x1, #0x1
 113e72c:	54000609 	b.ls	113e7ec <der_length_object_identifier+0xd0>  // b.plast
      return CRYPT_INVALID_ARG;
   }

   /* word1 = 0,1,2 and word2 0..39 */
   if (words[0] > 2 || (words[0] < 2 && words[1] > 39)) {
 113e730:	f9400004 	ldr	x4, [x0]
 113e734:	aa0003e5 	mov	x5, x0
 113e738:	f100089f 	cmp	x4, #0x2
 113e73c:	54000588 	b.hi	113e7ec <der_length_object_identifier+0xd0>  // b.pmore
 113e740:	f9400400 	ldr	x0, [x0, #8]
 113e744:	54000060 	b.eq	113e750 <der_length_object_identifier+0x34>  // b.none
 113e748:	f1009c1f 	cmp	x0, #0x27
 113e74c:	54000508 	b.hi	113e7ec <der_length_object_identifier+0xd0>  // b.pmore
      return CRYPT_INVALID_ARG;
   }

   /* leading word is the first two */
   z = 0;
   wordbuf = words[0] * 40 + words[1];
 113e750:	d2800501 	mov	x1, #0x28                  	// #40
   for (y = 1; y < nwords; y++) {
       t = der_object_identifier_bits(wordbuf);
       z += t/7 + ((t%7) ? 1 : 0) + (wordbuf == 0 ? 1 : 0);
       if (y < nwords - 1) {
 113e754:	d10004c9 	sub	x9, x6, #0x1
{
 113e758:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
   z = 0;
 113e75c:	d2800003 	mov	x3, #0x0                   	// #0
   wordbuf = words[0] * 40 + words[1];
 113e760:	9b010084 	madd	x4, x4, x1, x0
   for (y = 1; y < nwords; y++) {
 113e764:	d2800027 	mov	x7, #0x1                   	// #1
       z += t/7 + ((t%7) ? 1 : 0) + (wordbuf == 0 ? 1 : 0);
 113e768:	d28000e8 	mov	x8, #0x7                   	// #7
{
 113e76c:	910003fd 	mov	x29, sp
       t = der_object_identifier_bits(wordbuf);
 113e770:	aa0403e0 	mov	x0, x4
 113e774:	97ffffe3 	bl	113e700 <der_object_identifier_bits>
       z += t/7 + ((t%7) ? 1 : 0) + (wordbuf == 0 ? 1 : 0);
 113e778:	9ac80801 	udiv	x1, x0, x8
 113e77c:	9b088020 	msub	x0, x1, x8, x0
 113e780:	f100001f 	cmp	x0, #0x0
 113e784:	9a830463 	cinc	x3, x3, ne  // ne = any
 113e788:	f100009f 	cmp	x4, #0x0
 113e78c:	9a811421 	cinc	x1, x1, eq  // eq = none
       if (y < nwords - 1) {
 113e790:	eb07013f 	cmp	x9, x7
       z += t/7 + ((t%7) ? 1 : 0) + (wordbuf == 0 ? 1 : 0);
 113e794:	8b030023 	add	x3, x1, x3
       if (y < nwords - 1) {
 113e798:	910004e7 	add	x7, x7, #0x1
 113e79c:	54000049 	b.ls	113e7a4 <der_length_object_identifier+0x88>  // b.plast
          /* grab next word */
          wordbuf = words[y+1];
 113e7a0:	f86778a4 	ldr	x4, [x5, x7, lsl #3]
   for (y = 1; y < nwords; y++) {
 113e7a4:	eb0600ff 	cmp	x7, x6
 113e7a8:	54fffe41 	b.ne	113e770 <der_length_object_identifier+0x54>  // b.any
       }
   }

   /* now depending on the length our length encoding changes */
   if (z < 128) {
 113e7ac:	f101fc7f 	cmp	x3, #0x7f
 113e7b0:	540000c8 	b.hi	113e7c8 <der_length_object_identifier+0xac>  // b.pmore
      z += 2;
 113e7b4:	91000863 	add	x3, x3, #0x2
   } else {
      return CRYPT_INVALID_ARG;
   }

   *outlen = z;
   return CRYPT_OK;
 113e7b8:	52800000 	mov	w0, #0x0                   	// #0
   *outlen = z;
 113e7bc:	f9000043 	str	x3, [x2]
}
 113e7c0:	a8c17bfd 	ldp	x29, x30, [sp], #16
 113e7c4:	d65f03c0 	ret
   } else if (z < 256) {
 113e7c8:	f103fc7f 	cmp	x3, #0xff
 113e7cc:	54000068 	b.hi	113e7d8 <der_length_object_identifier+0xbc>  // b.pmore
      z += 3;
 113e7d0:	91000c63 	add	x3, x3, #0x3
 113e7d4:	17fffff9 	b	113e7b8 <der_length_object_identifier+0x9c>
   } else if (z < 65536UL) {
 113e7d8:	d29fffe0 	mov	x0, #0xffff                	// #65535
 113e7dc:	eb00007f 	cmp	x3, x0
 113e7e0:	540000a8 	b.hi	113e7f4 <der_length_object_identifier+0xd8>  // b.pmore
      z += 4;
 113e7e4:	91001063 	add	x3, x3, #0x4
 113e7e8:	17fffff4 	b	113e7b8 <der_length_object_identifier+0x9c>
   LTC_ARGCHK(words  != NULL);
 113e7ec:	52800200 	mov	w0, #0x10                  	// #16
}
 113e7f0:	d65f03c0 	ret
   LTC_ARGCHK(words  != NULL);
 113e7f4:	52800200 	mov	w0, #0x10                  	// #16
 113e7f8:	17fffff2 	b	113e7c0 <der_length_object_identifier+0xa4>

000000000113e7fc <der_decode_octet_string>:
                                  unsigned char *out, unsigned long *outlen)
{
   unsigned long x, y, len;
   int err;

   LTC_ARGCHK(in     != NULL);
 113e7fc:	b4000660 	cbz	x0, 113e8c8 <der_decode_octet_string+0xcc>
{
 113e800:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 113e804:	910003fd 	mov	x29, sp
 113e808:	a90153f3 	stp	x19, x20, [sp, #16]
 113e80c:	a9025bf5 	stp	x21, x22, [sp, #32]
 113e810:	aa0203f6 	mov	x22, x2
   LTC_ARGCHK(out    != NULL);
 113e814:	b40005e2 	cbz	x2, 113e8d0 <der_decode_octet_string+0xd4>
 113e818:	aa0303f5 	mov	x21, x3
   LTC_ARGCHK(outlen != NULL);
 113e81c:	b40005a3 	cbz	x3, 113e8d0 <der_decode_octet_string+0xd4>
 113e820:	aa0103f4 	mov	x20, x1

   /* must have header at least */
   if (inlen < 2) {
 113e824:	f100043f 	cmp	x1, #0x1
 113e828:	540000c8 	b.hi	113e840 <der_decode_octet_string+0x44>  // b.pmore
      return CRYPT_INVALID_PACKET;
 113e82c:	528000e0 	mov	w0, #0x7                   	// #7
   }

   *outlen = y;

   return CRYPT_OK;
}
 113e830:	a94153f3 	ldp	x19, x20, [sp, #16]
 113e834:	a9425bf5 	ldp	x21, x22, [sp, #32]
 113e838:	a8c47bfd 	ldp	x29, x30, [sp], #64
 113e83c:	d65f03c0 	ret
 113e840:	aa0003f3 	mov	x19, x0
   if ((in[0] & 0x1F) != 0x04) {
 113e844:	39400000 	ldrb	w0, [x0]
 113e848:	12001000 	and	w0, w0, #0x1f
 113e84c:	7100101f 	cmp	w0, #0x4
 113e850:	54fffee1 	b.ne	113e82c <der_decode_octet_string+0x30>  // b.any
   y = inlen - x;
 113e854:	d1000420 	sub	x0, x1, #0x1
   if ((err = der_decode_asn1_length(in + x, &y, &len)) != CRYPT_OK) {
 113e858:	9100e3e2 	add	x2, sp, #0x38
 113e85c:	9100c3e1 	add	x1, sp, #0x30
   y = inlen - x;
 113e860:	f9001be0 	str	x0, [sp, #48]
   if ((err = der_decode_asn1_length(in + x, &y, &len)) != CRYPT_OK) {
 113e864:	91000660 	add	x0, x19, #0x1
 113e868:	97fff9c6 	bl	113cf80 <der_decode_asn1_length>
 113e86c:	35fffe20 	cbnz	w0, 113e830 <der_decode_octet_string+0x34>
   if (len > *outlen) {
 113e870:	a9430fe2 	ldp	x2, x3, [sp, #48]
 113e874:	f94002a4 	ldr	x4, [x21]
 113e878:	aa2203e1 	mvn	x1, x2
 113e87c:	eb03009f 	cmp	x4, x3
 113e880:	54000082 	b.cs	113e890 <der_decode_octet_string+0x94>  // b.hs, b.nlast
      return CRYPT_BUFFER_OVERFLOW;
 113e884:	528000c0 	mov	w0, #0x6                   	// #6
      *outlen = len;
 113e888:	f90002a3 	str	x3, [x21]
      return CRYPT_BUFFER_OVERFLOW;
 113e88c:	17ffffe9 	b	113e830 <der_decode_octet_string+0x34>
   if (len > (inlen - x)) {
 113e890:	8b010294 	add	x20, x20, x1
 113e894:	eb14007f 	cmp	x3, x20
 113e898:	54fffca8 	b.hi	113e82c <der_decode_octet_string+0x30>  // b.pmore
       out[y] = in[x++];
 113e89c:	91000442 	add	x2, x2, #0x1
 113e8a0:	d2800001 	mov	x1, #0x0                   	// #0
 113e8a4:	8b020273 	add	x19, x19, x2
   for (y = 0; y < len; y++) {
 113e8a8:	eb01007f 	cmp	x3, x1
 113e8ac:	54000061 	b.ne	113e8b8 <der_decode_octet_string+0xbc>  // b.any
   *outlen = y;
 113e8b0:	f90002a3 	str	x3, [x21]
   return CRYPT_OK;
 113e8b4:	17ffffdf 	b	113e830 <der_decode_octet_string+0x34>
       out[y] = in[x++];
 113e8b8:	38616a62 	ldrb	w2, [x19, x1]
 113e8bc:	38216ac2 	strb	w2, [x22, x1]
   for (y = 0; y < len; y++) {
 113e8c0:	91000421 	add	x1, x1, #0x1
 113e8c4:	17fffff9 	b	113e8a8 <der_decode_octet_string+0xac>
   LTC_ARGCHK(in     != NULL);
 113e8c8:	52800200 	mov	w0, #0x10                  	// #16
}
 113e8cc:	d65f03c0 	ret
   LTC_ARGCHK(in     != NULL);
 113e8d0:	52800200 	mov	w0, #0x10                  	// #16
 113e8d4:	17ffffd7 	b	113e830 <der_decode_octet_string+0x34>

000000000113e8d8 <der_encode_octet_string>:
                                  unsigned char *out, unsigned long *outlen)
{
   unsigned long x, y, len;
   int           err;

   LTC_ARGCHK(in     != NULL);
 113e8d8:	b4000660 	cbz	x0, 113e9a4 <der_encode_octet_string+0xcc>
{
 113e8dc:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 113e8e0:	910003fd 	mov	x29, sp
 113e8e4:	a90153f3 	stp	x19, x20, [sp, #16]
 113e8e8:	aa0203f4 	mov	x20, x2
 113e8ec:	a9025bf5 	stp	x21, x22, [sp, #32]
 113e8f0:	f9001bf7 	str	x23, [sp, #48]
   LTC_ARGCHK(out    != NULL);
 113e8f4:	b40005c2 	cbz	x2, 113e9ac <der_encode_octet_string+0xd4>
 113e8f8:	aa0303f3 	mov	x19, x3
   LTC_ARGCHK(outlen != NULL);
 113e8fc:	b4000583 	cbz	x3, 113e9ac <der_encode_octet_string+0xd4>
 113e900:	aa0103f6 	mov	x22, x1

   /* get the size */
   if ((err = der_length_octet_string(inlen, &len)) != CRYPT_OK) {
 113e904:	910123f7 	add	x23, sp, #0x48
 113e908:	aa0003f5 	mov	x21, x0
 113e90c:	aa1703e1 	mov	x1, x23
 113e910:	aa1603e0 	mov	x0, x22
 113e914:	94000028 	bl	113e9b4 <der_length_octet_string>
 113e918:	350000e0 	cbnz	w0, 113e934 <der_encode_octet_string+0x5c>
      return err;
   }

   /* too big? */
   if (len > *outlen) {
 113e91c:	f9400261 	ldr	x1, [x19]
 113e920:	f94027e0 	ldr	x0, [sp, #72]
 113e924:	eb00003f 	cmp	x1, x0
 113e928:	54000102 	b.cs	113e948 <der_encode_octet_string+0x70>  // b.hs, b.nlast
      *outlen = len;
 113e92c:	f9000260 	str	x0, [x19]
      return CRYPT_BUFFER_OVERFLOW;
 113e930:	528000c0 	mov	w0, #0x6                   	// #6

   /* retun length */
   *outlen = x;

   return CRYPT_OK;
}
 113e934:	a94153f3 	ldp	x19, x20, [sp, #16]
 113e938:	a9425bf5 	ldp	x21, x22, [sp, #32]
 113e93c:	f9401bf7 	ldr	x23, [sp, #48]
 113e940:	a8c57bfd 	ldp	x29, x30, [sp], #80
 113e944:	d65f03c0 	ret
   out[x++] = 0x04;
 113e948:	aa1403e1 	mov	x1, x20
 113e94c:	52800080 	mov	w0, #0x4                   	// #4
   if ((err = der_encode_asn1_length(inlen, out + x, &len)) != CRYPT_OK) {
 113e950:	aa1703e2 	mov	x2, x23
   out[x++] = 0x04;
 113e954:	38001420 	strb	w0, [x1], #1
   len = *outlen - x;
 113e958:	f9400260 	ldr	x0, [x19]
 113e95c:	d1000400 	sub	x0, x0, #0x1
 113e960:	f90027e0 	str	x0, [sp, #72]
   if ((err = der_encode_asn1_length(inlen, out + x, &len)) != CRYPT_OK) {
 113e964:	aa1603e0 	mov	x0, x22
 113e968:	97fffa46 	bl	113d280 <der_encode_asn1_length>
 113e96c:	35fffe40 	cbnz	w0, 113e934 <der_encode_octet_string+0x5c>
   x += len;
 113e970:	f94027e4 	ldr	x4, [sp, #72]
 113e974:	91000481 	add	x1, x4, #0x1
   for (y = 0; y < inlen; y++) {
 113e978:	d2800004 	mov	x4, #0x0                   	// #0
       out[x++] = in[y];
 113e97c:	8b010294 	add	x20, x20, x1
   for (y = 0; y < inlen; y++) {
 113e980:	eb16009f 	cmp	x4, x22
 113e984:	54000081 	b.ne	113e994 <der_encode_octet_string+0xbc>  // b.any
   *outlen = x;
 113e988:	8b010084 	add	x4, x4, x1
 113e98c:	f9000264 	str	x4, [x19]
   return CRYPT_OK;
 113e990:	17ffffe9 	b	113e934 <der_encode_octet_string+0x5c>
       out[x++] = in[y];
 113e994:	38646aa2 	ldrb	w2, [x21, x4]
 113e998:	38246a82 	strb	w2, [x20, x4]
   for (y = 0; y < inlen; y++) {
 113e99c:	91000484 	add	x4, x4, #0x1
 113e9a0:	17fffff8 	b	113e980 <der_encode_octet_string+0xa8>
   LTC_ARGCHK(in     != NULL);
 113e9a4:	52800200 	mov	w0, #0x10                  	// #16
}
 113e9a8:	d65f03c0 	ret
   LTC_ARGCHK(in     != NULL);
 113e9ac:	52800200 	mov	w0, #0x10                  	// #16
 113e9b0:	17ffffe1 	b	113e934 <der_encode_octet_string+0x5c>

000000000113e9b4 <der_length_octet_string>:
int der_length_octet_string(unsigned long noctets, unsigned long *outlen)
{
   unsigned long x;
   int err;

   LTC_ARGCHK(outlen != NULL);
 113e9b4:	b4000201 	cbz	x1, 113e9f4 <der_length_octet_string+0x40>
{
 113e9b8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 113e9bc:	910003fd 	mov	x29, sp
 113e9c0:	a90153f3 	stp	x19, x20, [sp, #16]
 113e9c4:	aa0103f3 	mov	x19, x1

   if ((err = der_length_asn1_length(noctets, &x)) != CRYPT_OK) {
 113e9c8:	aa0003f4 	mov	x20, x0
 113e9cc:	9100a3e1 	add	x1, sp, #0x28
 113e9d0:	97fffaac 	bl	113d480 <der_length_asn1_length>
 113e9d4:	350000a0 	cbnz	w0, 113e9e8 <der_length_octet_string+0x34>
      return err;
   }
   *outlen = 1 + x + noctets;
 113e9d8:	f94017e2 	ldr	x2, [sp, #40]
 113e9dc:	91000442 	add	x2, x2, #0x1
 113e9e0:	8b140042 	add	x2, x2, x20
 113e9e4:	f9000262 	str	x2, [x19]

   return CRYPT_OK;
}
 113e9e8:	a94153f3 	ldp	x19, x20, [sp, #16]
 113e9ec:	a8c37bfd 	ldp	x29, x30, [sp], #48
 113e9f0:	d65f03c0 	ret
   LTC_ARGCHK(outlen != NULL);
 113e9f4:	52800200 	mov	w0, #0x10                  	// #16
}
 113e9f8:	d65f03c0 	ret

000000000113e9fc <der_decode_printable_string>:
  @param outlen  [in/out] The number of octets stored
  @return CRYPT_OK if successful
*/
int der_decode_printable_string(const unsigned char *in, unsigned long inlen,
                                unsigned char *out, unsigned long *outlen)
{
 113e9fc:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 113ea00:	910003fd 	mov	x29, sp
 113ea04:	a90153f3 	stp	x19, x20, [sp, #16]
 113ea08:	a9025bf5 	stp	x21, x22, [sp, #32]
 113ea0c:	f9001bf7 	str	x23, [sp, #48]
   unsigned long x, y, len;
   int           t, err;

   LTC_ARGCHK(in     != NULL);
 113ea10:	b5000100 	cbnz	x0, 113ea30 <der_decode_printable_string+0x34>
 113ea14:	52800214 	mov	w20, #0x10                  	// #16
   }

   *outlen = y;

   return CRYPT_OK;
}
 113ea18:	2a1403e0 	mov	w0, w20
 113ea1c:	a94153f3 	ldp	x19, x20, [sp, #16]
 113ea20:	a9425bf5 	ldp	x21, x22, [sp, #32]
 113ea24:	f9401bf7 	ldr	x23, [sp, #48]
 113ea28:	a8c57bfd 	ldp	x29, x30, [sp], #80
 113ea2c:	d65f03c0 	ret
 113ea30:	aa0203f7 	mov	x23, x2
   LTC_ARGCHK(out    != NULL);
 113ea34:	b4ffff02 	cbz	x2, 113ea14 <der_decode_printable_string+0x18>
 113ea38:	aa0303f5 	mov	x21, x3
   LTC_ARGCHK(outlen != NULL);
 113ea3c:	b4fffec3 	cbz	x3, 113ea14 <der_decode_printable_string+0x18>
 113ea40:	aa0103f6 	mov	x22, x1
   if (inlen < 2) {
 113ea44:	f100043f 	cmp	x1, #0x1
 113ea48:	54000068 	b.hi	113ea54 <der_decode_printable_string+0x58>  // b.pmore
      return CRYPT_INVALID_PACKET;
 113ea4c:	528000f4 	mov	w20, #0x7                   	// #7
 113ea50:	17fffff2 	b	113ea18 <der_decode_printable_string+0x1c>
 113ea54:	aa0003f3 	mov	x19, x0
   if ((in[0] & 0x1F) != 0x13) {
 113ea58:	39400000 	ldrb	w0, [x0]
 113ea5c:	12001000 	and	w0, w0, #0x1f
 113ea60:	71004c1f 	cmp	w0, #0x13
 113ea64:	54ffff41 	b.ne	113ea4c <der_decode_printable_string+0x50>  // b.any
   y = inlen - x;
 113ea68:	d1000420 	sub	x0, x1, #0x1
   if ((err = der_decode_asn1_length(in + x, &y, &len)) != CRYPT_OK) {
 113ea6c:	910123e2 	add	x2, sp, #0x48
 113ea70:	910103e1 	add	x1, sp, #0x40
   y = inlen - x;
 113ea74:	f90023e0 	str	x0, [sp, #64]
   if ((err = der_decode_asn1_length(in + x, &y, &len)) != CRYPT_OK) {
 113ea78:	91000660 	add	x0, x19, #0x1
 113ea7c:	97fff941 	bl	113cf80 <der_decode_asn1_length>
 113ea80:	2a0003f4 	mov	w20, w0
 113ea84:	35fffca0 	cbnz	w0, 113ea18 <der_decode_printable_string+0x1c>
   if (len > *outlen) {
 113ea88:	a9440be0 	ldp	x0, x2, [sp, #64]
 113ea8c:	f94002a3 	ldr	x3, [x21]
 113ea90:	aa2003e1 	mvn	x1, x0
 113ea94:	eb02007f 	cmp	x3, x2
 113ea98:	54000082 	b.cs	113eaa8 <der_decode_printable_string+0xac>  // b.hs, b.nlast
      return CRYPT_BUFFER_OVERFLOW;
 113ea9c:	528000d4 	mov	w20, #0x6                   	// #6
      *outlen = len;
 113eaa0:	f90002a2 	str	x2, [x21]
      return CRYPT_BUFFER_OVERFLOW;
 113eaa4:	17ffffdd 	b	113ea18 <der_decode_printable_string+0x1c>
   if (len > (inlen - x)) {
 113eaa8:	8b160036 	add	x22, x1, x22
 113eaac:	eb16005f 	cmp	x2, x22
 113eab0:	54fffce8 	b.hi	113ea4c <der_decode_printable_string+0x50>  // b.pmore
   for (y = 0; y < len; y++) {
 113eab4:	8b000273 	add	x19, x19, x0
 113eab8:	f90023ff 	str	xzr, [sp, #64]
 113eabc:	a94407e0 	ldp	x0, x1, [sp, #64]
 113eac0:	eb01001f 	cmp	x0, x1
 113eac4:	54000063 	b.cc	113ead0 <der_decode_printable_string+0xd4>  // b.lo, b.ul, b.last
   *outlen = y;
 113eac8:	f90002a0 	str	x0, [x21]
   return CRYPT_OK;
 113eacc:	17ffffd3 	b	113ea18 <der_decode_printable_string+0x1c>
       t = der_printable_value_decode(in[x++]);
 113ead0:	38401e60 	ldrb	w0, [x19, #1]!
 113ead4:	94000051 	bl	113ec18 <der_printable_value_decode>
       if (t == -1) {
 113ead8:	3100041f 	cmn	w0, #0x1
 113eadc:	54fff9c0 	b.eq	113ea14 <der_decode_printable_string+0x18>  // b.none
       out[y] = t;
 113eae0:	f94023e1 	ldr	x1, [sp, #64]
 113eae4:	38216ae0 	strb	w0, [x23, x1]
   for (y = 0; y < len; y++) {
 113eae8:	91000421 	add	x1, x1, #0x1
 113eaec:	f90023e1 	str	x1, [sp, #64]
 113eaf0:	17fffff3 	b	113eabc <der_decode_printable_string+0xc0>

000000000113eaf4 <der_encode_printable_string>:
  @param outlen   [in/out] The max size and resulting size of the DER printable STRING
  @return CRYPT_OK if successful
*/
int der_encode_printable_string(const unsigned char *in, unsigned long inlen,
                                unsigned char *out, unsigned long *outlen)
{
 113eaf4:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
 113eaf8:	910003fd 	mov	x29, sp
 113eafc:	a90153f3 	stp	x19, x20, [sp, #16]
 113eb00:	a9025bf5 	stp	x21, x22, [sp, #32]
 113eb04:	a90363f7 	stp	x23, x24, [sp, #48]
 113eb08:	f90023f9 	str	x25, [sp, #64]
   unsigned long x, y, len;
   int           err;

   LTC_ARGCHK(in     != NULL);
 113eb0c:	b4000640 	cbz	x0, 113ebd4 <der_encode_printable_string+0xe0>
 113eb10:	aa0203f6 	mov	x22, x2
   LTC_ARGCHK(out    != NULL);
 113eb14:	b4000602 	cbz	x2, 113ebd4 <der_encode_printable_string+0xe0>
 113eb18:	aa0303f5 	mov	x21, x3
   LTC_ARGCHK(outlen != NULL);
 113eb1c:	b40005c3 	cbz	x3, 113ebd4 <der_encode_printable_string+0xe0>

   /* get the size */
   if ((err = der_length_printable_string(in, inlen, &len)) != CRYPT_OK) {
 113eb20:	910163f4 	add	x20, sp, #0x58
 113eb24:	aa0003f8 	mov	x24, x0
 113eb28:	aa0103f7 	mov	x23, x1
 113eb2c:	aa1403e2 	mov	x2, x20
 113eb30:	9400004a 	bl	113ec58 <der_length_printable_string>
 113eb34:	2a0003f3 	mov	w19, w0
 113eb38:	350000e0 	cbnz	w0, 113eb54 <der_encode_printable_string+0x60>
      return err;
   }

   /* too big? */
   if (len > *outlen) {
 113eb3c:	f94002a1 	ldr	x1, [x21]
 113eb40:	f9402fe0 	ldr	x0, [sp, #88]
 113eb44:	eb00003f 	cmp	x1, x0
 113eb48:	54000142 	b.cs	113eb70 <der_encode_printable_string+0x7c>  // b.hs, b.nlast
      *outlen = len;
      return CRYPT_BUFFER_OVERFLOW;
 113eb4c:	528000d3 	mov	w19, #0x6                   	// #6
      *outlen = len;
 113eb50:	f90002a0 	str	x0, [x21]

   /* retun length */
   *outlen = x;

   return CRYPT_OK;
}
 113eb54:	2a1303e0 	mov	w0, w19
 113eb58:	a94153f3 	ldp	x19, x20, [sp, #16]
 113eb5c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 113eb60:	a94363f7 	ldp	x23, x24, [sp, #48]
 113eb64:	f94023f9 	ldr	x25, [sp, #64]
 113eb68:	a8c67bfd 	ldp	x29, x30, [sp], #96
 113eb6c:	d65f03c0 	ret
   out[x++] = 0x13;
 113eb70:	aa1603e1 	mov	x1, x22
 113eb74:	52800260 	mov	w0, #0x13                  	// #19
   if ((err = der_encode_asn1_length(inlen, out + x, &len)) != CRYPT_OK) {
 113eb78:	aa1403e2 	mov	x2, x20
   out[x++] = 0x13;
 113eb7c:	38001420 	strb	w0, [x1], #1
   len = *outlen - x;
 113eb80:	f94002a0 	ldr	x0, [x21]
 113eb84:	d1000400 	sub	x0, x0, #0x1
 113eb88:	f9002fe0 	str	x0, [sp, #88]
   if ((err = der_encode_asn1_length(inlen, out + x, &len)) != CRYPT_OK) {
 113eb8c:	aa1703e0 	mov	x0, x23
 113eb90:	97fff9bc 	bl	113d280 <der_encode_asn1_length>
 113eb94:	2a0003f3 	mov	w19, w0
 113eb98:	35fffde0 	cbnz	w0, 113eb54 <der_encode_printable_string+0x60>
   x += len;
 113eb9c:	f9402ff4 	ldr	x20, [sp, #88]
 113eba0:	91000699 	add	x25, x20, #0x1
   for (y = 0; y < inlen; y++) {
 113eba4:	d2800014 	mov	x20, #0x0                   	// #0
       out[x++] = der_printable_char_encode(in[y]);
 113eba8:	8b1902d6 	add	x22, x22, x25
   for (y = 0; y < inlen; y++) {
 113ebac:	eb17029f 	cmp	x20, x23
 113ebb0:	54000081 	b.ne	113ebc0 <der_encode_printable_string+0xcc>  // b.any
   *outlen = x;
 113ebb4:	8b190294 	add	x20, x20, x25
 113ebb8:	f90002b4 	str	x20, [x21]
   return CRYPT_OK;
 113ebbc:	17ffffe6 	b	113eb54 <der_encode_printable_string+0x60>
       out[x++] = der_printable_char_encode(in[y]);
 113ebc0:	38746b00 	ldrb	w0, [x24, x20]
 113ebc4:	94000006 	bl	113ebdc <der_printable_char_encode>
 113ebc8:	38346ac0 	strb	w0, [x22, x20]
   for (y = 0; y < inlen; y++) {
 113ebcc:	91000694 	add	x20, x20, #0x1
 113ebd0:	17fffff7 	b	113ebac <der_encode_printable_string+0xb8>
   LTC_ARGCHK(in     != NULL);
 113ebd4:	52800213 	mov	w19, #0x10                  	// #16
 113ebd8:	17ffffdf 	b	113eb54 <der_encode_printable_string+0x60>

000000000113ebdc <der_printable_char_encode>:

int der_printable_char_encode(int c)
{
   int x;
   for (x = 0; x < (int)(sizeof(printable_table)/sizeof(printable_table[0])); x++) {
       if (printable_table[x].code == c) {
 113ebdc:	d0000082 	adrp	x2, 1150000 <Te4+0x258>
 113ebe0:	91308042 	add	x2, x2, #0xc20
{
 113ebe4:	d2800001 	mov	x1, #0x0                   	// #0
       if (printable_table[x].code == c) {
 113ebe8:	d37df024 	lsl	x4, x1, #3
 113ebec:	b8626884 	ldr	w4, [x4, x2]
 113ebf0:	6b00009f 	cmp	w4, w0
 113ebf4:	54000081 	b.ne	113ec04 <der_printable_char_encode+0x28>  // b.any
          return printable_table[x].value;
 113ebf8:	8b21cc42 	add	x2, x2, w1, sxtw #3
 113ebfc:	b9400440 	ldr	w0, [x2, #4]
       }
   }
   return -1;
}
 113ec00:	d65f03c0 	ret
   for (x = 0; x < (int)(sizeof(printable_table)/sizeof(printable_table[0])); x++) {
 113ec04:	91000421 	add	x1, x1, #0x1
 113ec08:	f101283f 	cmp	x1, #0x4a
 113ec0c:	54fffee1 	b.ne	113ebe8 <der_printable_char_encode+0xc>  // b.any
   return -1;
 113ec10:	12800000 	mov	w0, #0xffffffff            	// #-1
 113ec14:	17fffffb 	b	113ec00 <der_printable_char_encode+0x24>

000000000113ec18 <der_printable_value_decode>:

int der_printable_value_decode(int v)
{
   int x;
   for (x = 0; x < (int)(sizeof(printable_table)/sizeof(printable_table[0])); x++) {
 113ec18:	d0000082 	adrp	x2, 1150000 <Te4+0x258>
 113ec1c:	91308043 	add	x3, x2, #0xc20
 113ec20:	52800001 	mov	w1, #0x0                   	// #0
       if (printable_table[x].value == v) {
 113ec24:	b9400464 	ldr	w4, [x3, #4]
 113ec28:	6b00009f 	cmp	w4, w0
 113ec2c:	540000a1 	b.ne	113ec40 <der_printable_value_decode+0x28>  // b.any
          return printable_table[x].code;
 113ec30:	91308042 	add	x2, x2, #0xc20
 113ec34:	937d7c21 	sbfiz	x1, x1, #3, #32
 113ec38:	b8616840 	ldr	w0, [x2, x1]
       }
   }
   return -1;
}
 113ec3c:	d65f03c0 	ret
   for (x = 0; x < (int)(sizeof(printable_table)/sizeof(printable_table[0])); x++) {
 113ec40:	11000421 	add	w1, w1, #0x1
 113ec44:	91002063 	add	x3, x3, #0x8
 113ec48:	7101283f 	cmp	w1, #0x4a
 113ec4c:	54fffec1 	b.ne	113ec24 <der_printable_value_decode+0xc>  // b.any
   return -1;
 113ec50:	12800000 	mov	w0, #0xffffffff            	// #-1
 113ec54:	17fffffa 	b	113ec3c <der_printable_value_decode+0x24>

000000000113ec58 <der_length_printable_string>:
int der_length_printable_string(const unsigned char *octets, unsigned long noctets, unsigned long *outlen)
{
   unsigned long x;
   int err;

   LTC_ARGCHK(outlen != NULL);
 113ec58:	b4000442 	cbz	x2, 113ece0 <der_length_printable_string+0x88>
 113ec5c:	aa0003e5 	mov	x5, x0
   LTC_ARGCHK(octets != NULL);
 113ec60:	b4000400 	cbz	x0, 113ece0 <der_length_printable_string+0x88>
{
 113ec64:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!

   /* scan string for validity */
   for (x = 0; x < noctets; x++) {
 113ec68:	d2800003 	mov	x3, #0x0                   	// #0
{
 113ec6c:	910003fd 	mov	x29, sp
 113ec70:	a90153f3 	stp	x19, x20, [sp, #16]
 113ec74:	aa0203f4 	mov	x20, x2
   for (x = 0; x < noctets; x++) {
 113ec78:	aa0103f3 	mov	x19, x1
 113ec7c:	52800001 	mov	w1, #0x0                   	// #0
 113ec80:	f90017ff 	str	xzr, [sp, #40]
 113ec84:	eb03027f 	cmp	x19, x3
 113ec88:	54000181 	b.ne	113ecb8 <der_length_printable_string+0x60>  // b.any
 113ec8c:	34000041 	cbz	w1, 113ec94 <der_length_printable_string+0x3c>
 113ec90:	f90017f3 	str	x19, [sp, #40]
       if (der_printable_char_encode(octets[x]) == -1) {
          return CRYPT_INVALID_ARG;
       }
   }

   if ((err = der_length_asn1_length(noctets, &x)) != CRYPT_OK) {
 113ec94:	9100a3e1 	add	x1, sp, #0x28
 113ec98:	aa1303e0 	mov	x0, x19
 113ec9c:	97fff9f9 	bl	113d480 <der_length_asn1_length>
 113eca0:	350001a0 	cbnz	w0, 113ecd4 <der_length_printable_string+0x7c>
      return err;
   }
   *outlen = 1 + x + noctets;
 113eca4:	f94017e1 	ldr	x1, [sp, #40]
 113eca8:	91000421 	add	x1, x1, #0x1
 113ecac:	8b130033 	add	x19, x1, x19
 113ecb0:	f9000293 	str	x19, [x20]

   return CRYPT_OK;
 113ecb4:	14000008 	b	113ecd4 <der_length_printable_string+0x7c>
       if (der_printable_char_encode(octets[x]) == -1) {
 113ecb8:	386368a0 	ldrb	w0, [x5, x3]
 113ecbc:	97ffffc8 	bl	113ebdc <der_printable_char_encode>
 113ecc0:	91000463 	add	x3, x3, #0x1
 113ecc4:	3100041f 	cmn	w0, #0x1
 113ecc8:	52800021 	mov	w1, #0x1                   	// #1
 113eccc:	54fffdc1 	b.ne	113ec84 <der_length_printable_string+0x2c>  // b.any
          return CRYPT_INVALID_ARG;
 113ecd0:	52800200 	mov	w0, #0x10                  	// #16
}
 113ecd4:	a94153f3 	ldp	x19, x20, [sp, #16]
 113ecd8:	a8c37bfd 	ldp	x29, x30, [sp], #48
 113ecdc:	d65f03c0 	ret
          return CRYPT_INVALID_ARG;
 113ece0:	52800200 	mov	w0, #0x10                  	// #16
}
 113ece4:	d65f03c0 	ret

000000000113ece8 <der_decode_short_integer>:
*/
int der_decode_short_integer(const unsigned char *in, unsigned long inlen, unsigned long *num)
{
   unsigned long len, x, y;

   LTC_ARGCHK(num    != NULL);
 113ece8:	b40002e2 	cbz	x2, 113ed44 <der_decode_short_integer+0x5c>
   LTC_ARGCHK(in     != NULL);
 113ecec:	b40002c0 	cbz	x0, 113ed44 <der_decode_short_integer+0x5c>

   /* check length */
   if (inlen < 2) {
 113ecf0:	f100043f 	cmp	x1, #0x1
 113ecf4:	540002c9 	b.ls	113ed4c <der_decode_short_integer+0x64>  // b.plast
      return CRYPT_INVALID_PACKET;
   }

   /* check header */
   x = 0;
   if ((in[x++] & 0x1F) != 0x02) {
 113ecf8:	39400003 	ldrb	w3, [x0]
 113ecfc:	12001063 	and	w3, w3, #0x1f
 113ed00:	7100087f 	cmp	w3, #0x2
 113ed04:	54000241 	b.ne	113ed4c <der_decode_short_integer+0x64>  // b.any
      return CRYPT_INVALID_PACKET;
   }

   /* get the packet len */
   len = in[x++];
 113ed08:	39400403 	ldrb	w3, [x0, #1]

   if (x + len > inlen) {
 113ed0c:	91000864 	add	x4, x3, #0x2
 113ed10:	eb01009f 	cmp	x4, x1
 113ed14:	540001c8 	b.hi	113ed4c <der_decode_short_integer+0x64>  // b.pmore
 113ed18:	91000800 	add	x0, x0, #0x2
      return CRYPT_INVALID_PACKET;
   }

   /* read number */
   y = 0;
 113ed1c:	d2800001 	mov	x1, #0x0                   	// #0
   while (len--) {
 113ed20:	d1000463 	sub	x3, x3, #0x1
 113ed24:	b100047f 	cmn	x3, #0x1
 113ed28:	54000081 	b.ne	113ed38 <der_decode_short_integer+0x50>  // b.any
      y = (y<<8) | (unsigned long)in[x++];
   }
   *num = y;

   return CRYPT_OK;
 113ed2c:	52800000 	mov	w0, #0x0                   	// #0
   *num = y;
 113ed30:	f9000041 	str	x1, [x2]

}
 113ed34:	d65f03c0 	ret
      y = (y<<8) | (unsigned long)in[x++];
 113ed38:	38401404 	ldrb	w4, [x0], #1
 113ed3c:	aa012081 	orr	x1, x4, x1, lsl #8
 113ed40:	17fffff8 	b	113ed20 <der_decode_short_integer+0x38>
   LTC_ARGCHK(num    != NULL);
 113ed44:	52800200 	mov	w0, #0x10                  	// #16
 113ed48:	17fffffb 	b	113ed34 <der_decode_short_integer+0x4c>
      return CRYPT_INVALID_PACKET;
 113ed4c:	528000e0 	mov	w0, #0x7                   	// #7
 113ed50:	17fffff9 	b	113ed34 <der_decode_short_integer+0x4c>

000000000113ed54 <_char_to_int>:
*/

#ifdef LTC_DER

static int _char_to_int(unsigned char x)
{
 113ed54:	12001c00 	and	w0, w0, #0xff
 113ed58:	5100c000 	sub	w0, w0, #0x30
 113ed5c:	12001c01 	and	w1, w0, #0xff
 113ed60:	7100243f 	cmp	w1, #0x9
      case '7': return 7;
      case '8': return 8;
      case '9': return 9;
      default:  return 100;
   }
}
 113ed64:	52800c81 	mov	w1, #0x64                  	// #100
 113ed68:	1a819000 	csel	w0, w0, w1, ls  // ls = plast
 113ed6c:	d65f03c0 	ret

000000000113ed70 <der_decode_utctime>:
  @param out    [out] Destination of UTC time structure
  @return CRYPT_OK   if successful
*/
int der_decode_utctime(const unsigned char *in, unsigned long *inlen,
                             ltc_utctime   *out)
{
 113ed70:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
 113ed74:	910003fd 	mov	x29, sp
 113ed78:	a90153f3 	stp	x19, x20, [sp, #16]
 113ed7c:	a9025bf5 	stp	x21, x22, [sp, #32]
 113ed80:	a90363f7 	stp	x23, x24, [sp, #48]
   unsigned char buf[32] = { 0 }; /* initialize as all zeroes */
 113ed84:	a9047fff 	stp	xzr, xzr, [sp, #64]
 113ed88:	a9057fff 	stp	xzr, xzr, [sp, #80]
   unsigned long x;
   int           y;

   LTC_ARGCHK(in    != NULL);
 113ed8c:	b40012e0 	cbz	x0, 113efe8 <der_decode_utctime+0x278>
 113ed90:	aa0103f6 	mov	x22, x1
   LTC_ARGCHK(inlen != NULL);
 113ed94:	b40012a1 	cbz	x1, 113efe8 <der_decode_utctime+0x278>
 113ed98:	aa0203f3 	mov	x19, x2
   LTC_ARGCHK(out   != NULL);
 113ed9c:	b4001262 	cbz	x2, 113efe8 <der_decode_utctime+0x278>

   /* check header */
   if (*inlen < 2UL || (in[1] >= sizeof(buf)) || ((in[1] + 2UL) > *inlen)) {
 113eda0:	f9400021 	ldr	x1, [x1]
 113eda4:	f100043f 	cmp	x1, #0x1
 113eda8:	54000d69 	b.ls	113ef54 <der_decode_utctime+0x1e4>  // b.plast
 113edac:	aa0003f5 	mov	x21, x0
 113edb0:	39400400 	ldrb	w0, [x0, #1]
 113edb4:	71007c1f 	cmp	w0, #0x1f
 113edb8:	54000ce8 	b.hi	113ef54 <der_decode_utctime+0x1e4>  // b.pmore
 113edbc:	92401c00 	and	x0, x0, #0xff
 113edc0:	91000800 	add	x0, x0, #0x2
 113edc4:	eb00003f 	cmp	x1, x0
 113edc8:	54000c63 	b.cc	113ef54 <der_decode_utctime+0x1e4>  // b.lo, b.ul, b.last
      return CRYPT_INVALID_PACKET;
   }

   /* decode the string */
   for (x = 0; x < in[1]; x++) {
       y = der_ia5_value_decode(in[x+2]);
 113edcc:	91000ab7 	add	x23, x21, #0x2
       if (y == -1) {
          return CRYPT_INVALID_PACKET;
       }
       buf[x] = y;
 113edd0:	910103f8 	add	x24, sp, #0x40
   for (x = 0; x < in[1]; x++) {
 113edd4:	d2800014 	mov	x20, #0x0                   	// #0
 113edd8:	394006a1 	ldrb	w1, [x21, #1]
 113eddc:	91000a80 	add	x0, x20, #0x2
 113ede0:	eb14003f 	cmp	x1, x20
 113ede4:	54000768 	b.hi	113eed0 <der_decode_utctime+0x160>  // b.pmore
   }
   *inlen = 2 + x;
 113ede8:	f90002c0 	str	x0, [x22]

    So let's do a trivial decode upto [including] mm
   */

    x = 0;
    DECODE_V(out->YY, 100);
 113edec:	394103e0 	ldrb	w0, [sp, #64]
 113edf0:	97ffffd9 	bl	113ed54 <_char_to_int>
 113edf4:	2a0003e3 	mov	w3, w0
 113edf8:	394107e0 	ldrb	w0, [sp, #65]
 113edfc:	97ffffd6 	bl	113ed54 <_char_to_int>
 113ee00:	52800142 	mov	w2, #0xa                   	// #10
 113ee04:	1b020060 	madd	w0, w3, w2, w0
 113ee08:	b9000260 	str	w0, [x19]
 113ee0c:	71018c1f 	cmp	w0, #0x63
 113ee10:	54000a28 	b.hi	113ef54 <der_decode_utctime+0x1e4>  // b.pmore
    DECODE_V(out->MM, 13);
 113ee14:	39410be0 	ldrb	w0, [sp, #66]
 113ee18:	97ffffcf 	bl	113ed54 <_char_to_int>
 113ee1c:	2a0003e3 	mov	w3, w0
 113ee20:	39410fe0 	ldrb	w0, [sp, #67]
 113ee24:	97ffffcc 	bl	113ed54 <_char_to_int>
 113ee28:	1b020060 	madd	w0, w3, w2, w0
 113ee2c:	b9000660 	str	w0, [x19, #4]
 113ee30:	7100301f 	cmp	w0, #0xc
 113ee34:	54000908 	b.hi	113ef54 <der_decode_utctime+0x1e4>  // b.pmore
    DECODE_V(out->DD, 32);
 113ee38:	394113e0 	ldrb	w0, [sp, #68]
 113ee3c:	97ffffc6 	bl	113ed54 <_char_to_int>
 113ee40:	2a0003e3 	mov	w3, w0
 113ee44:	394117e0 	ldrb	w0, [sp, #69]
 113ee48:	97ffffc3 	bl	113ed54 <_char_to_int>
 113ee4c:	1b020060 	madd	w0, w3, w2, w0
 113ee50:	b9000a60 	str	w0, [x19, #8]
 113ee54:	71007c1f 	cmp	w0, #0x1f
 113ee58:	540007e8 	b.hi	113ef54 <der_decode_utctime+0x1e4>  // b.pmore
    DECODE_V(out->hh, 24);
 113ee5c:	39411be0 	ldrb	w0, [sp, #70]
 113ee60:	97ffffbd 	bl	113ed54 <_char_to_int>
 113ee64:	2a0003e3 	mov	w3, w0
 113ee68:	39411fe0 	ldrb	w0, [sp, #71]
 113ee6c:	97ffffba 	bl	113ed54 <_char_to_int>
 113ee70:	1b020060 	madd	w0, w3, w2, w0
 113ee74:	b9000e60 	str	w0, [x19, #12]
 113ee78:	71005c1f 	cmp	w0, #0x17
 113ee7c:	540006c8 	b.hi	113ef54 <der_decode_utctime+0x1e4>  // b.pmore
    DECODE_V(out->mm, 60);
 113ee80:	394123e0 	ldrb	w0, [sp, #72]
 113ee84:	97ffffb4 	bl	113ed54 <_char_to_int>
 113ee88:	2a0003e3 	mov	w3, w0
 113ee8c:	394127e0 	ldrb	w0, [sp, #73]
 113ee90:	97ffffb1 	bl	113ed54 <_char_to_int>
 113ee94:	1b020060 	madd	w0, w3, w2, w0
 113ee98:	b9001260 	str	w0, [x19, #16]
 113ee9c:	7100ec1f 	cmp	w0, #0x3b
 113eea0:	540005a8 	b.hi	113ef54 <der_decode_utctime+0x1e4>  // b.pmore

    /* clear timezone and seconds info */
    out->off_dir = out->off_hh = out->off_mm = out->ss = 0;

    /* now is it Z, +, - or 0-9 */
    if (buf[x] == 'Z') {
 113eea4:	39412be4 	ldrb	w4, [sp, #74]
    out->off_dir = out->off_hh = out->off_mm = out->ss = 0;
 113eea8:	2902fe7f 	stp	wzr, wzr, [x19, #20]
 113eeac:	2903fe7f 	stp	wzr, wzr, [x19, #28]
    if (buf[x] == 'Z') {
 113eeb0:	7101689f 	cmp	w4, #0x5a
 113eeb4:	540001c1 	b.ne	113eeec <der_decode_utctime+0x17c>  // b.any
       return CRYPT_OK;
 113eeb8:	52800000 	mov	w0, #0x0                   	// #0
       DECODE_V(out->off_hh, 24);
       DECODE_V(out->off_mm, 60);
       return CRYPT_OK;
    }
    return CRYPT_INVALID_PACKET;
}
 113eebc:	a94153f3 	ldp	x19, x20, [sp, #16]
 113eec0:	a9425bf5 	ldp	x21, x22, [sp, #32]
 113eec4:	a94363f7 	ldp	x23, x24, [sp, #48]
 113eec8:	a8c67bfd 	ldp	x29, x30, [sp], #96
 113eecc:	d65f03c0 	ret
       y = der_ia5_value_decode(in[x+2]);
 113eed0:	38746ae0 	ldrb	w0, [x23, x20]
 113eed4:	97fffbba 	bl	113ddbc <der_ia5_value_decode>
       if (y == -1) {
 113eed8:	3100041f 	cmn	w0, #0x1
 113eedc:	540003c0 	b.eq	113ef54 <der_decode_utctime+0x1e4>  // b.none
       buf[x] = y;
 113eee0:	38386a80 	strb	w0, [x20, x24]
   for (x = 0; x < in[1]; x++) {
 113eee4:	91000694 	add	x20, x20, #0x1
 113eee8:	17ffffbc 	b	113edd8 <der_decode_utctime+0x68>
    if (buf[x] == '+' || buf[x] == '-') {
 113eeec:	7100ac9f 	cmp	w4, #0x2b
 113eef0:	39412fe0 	ldrb	w0, [sp, #75]
 113eef4:	1a9f17e5 	cset	w5, eq  // eq = none
 113eef8:	7100b49f 	cmp	w4, #0x2d
 113eefc:	1a9f14a5 	csinc	w5, w5, wzr, ne  // ne = any
 113ef00:	97ffff95 	bl	113ed54 <_char_to_int>
 113ef04:	2a0003e3 	mov	w3, w0
 113ef08:	340002a5 	cbz	w5, 113ef5c <der_decode_utctime+0x1ec>
       out->off_dir = (buf[x++] == '+') ? 0 : 1;
 113ef0c:	7100ac9f 	cmp	w4, #0x2b
 113ef10:	1a9f07e0 	cset	w0, ne  // ne = any
 113ef14:	b9001a60 	str	w0, [x19, #24]
       DECODE_V(out->off_hh, 24);
 113ef18:	394133e0 	ldrb	w0, [sp, #76]
 113ef1c:	97ffff8e 	bl	113ed54 <_char_to_int>
 113ef20:	1b020063 	madd	w3, w3, w2, w0
 113ef24:	b9001e63 	str	w3, [x19, #28]
 113ef28:	71005c7f 	cmp	w3, #0x17
 113ef2c:	54000148 	b.hi	113ef54 <der_decode_utctime+0x1e4>  // b.pmore
       DECODE_V(out->off_mm, 60);
 113ef30:	394137e0 	ldrb	w0, [sp, #77]
 113ef34:	97ffff88 	bl	113ed54 <_char_to_int>
 113ef38:	2a0003e3 	mov	w3, w0
 113ef3c:	39413be0 	ldrb	w0, [sp, #78]
 113ef40:	97ffff85 	bl	113ed54 <_char_to_int>
 113ef44:	1b020062 	madd	w2, w3, w2, w0
 113ef48:	b9002262 	str	w2, [x19, #32]
 113ef4c:	7100ec5f 	cmp	w2, #0x3b
 113ef50:	54fffb49 	b.ls	113eeb8 <der_decode_utctime+0x148>  // b.plast
 113ef54:	528000e0 	mov	w0, #0x7                   	// #7
 113ef58:	17ffffd9 	b	113eebc <der_decode_utctime+0x14c>
    DECODE_V(out->ss, 60);
 113ef5c:	2a0403e0 	mov	w0, w4
 113ef60:	97ffff7d 	bl	113ed54 <_char_to_int>
 113ef64:	1b020c02 	madd	w2, w0, w2, w3
 113ef68:	b9001662 	str	w2, [x19, #20]
 113ef6c:	7100ec5f 	cmp	w2, #0x3b
 113ef70:	54ffff28 	b.hi	113ef54 <der_decode_utctime+0x1e4>  // b.pmore
    if (buf[x] == 'Z') {
 113ef74:	394133e0 	ldrb	w0, [sp, #76]
 113ef78:	7101681f 	cmp	w0, #0x5a
 113ef7c:	54fff9e0 	b.eq	113eeb8 <der_decode_utctime+0x148>  // b.none
    if (buf[x] == '+' || buf[x] == '-') {
 113ef80:	7100ac1f 	cmp	w0, #0x2b
 113ef84:	528005a1 	mov	w1, #0x2d                  	// #45
 113ef88:	7a411004 	ccmp	w0, w1, #0x4, ne  // ne = any
 113ef8c:	54fffe41 	b.ne	113ef54 <der_decode_utctime+0x1e4>  // b.any
       out->off_dir = (buf[x++] == '+') ? 0 : 1;
 113ef90:	7100ac1f 	cmp	w0, #0x2b
 113ef94:	1a9f07e0 	cset	w0, ne  // ne = any
 113ef98:	b9001a60 	str	w0, [x19, #24]
       DECODE_V(out->off_hh, 24);
 113ef9c:	394137e0 	ldrb	w0, [sp, #77]
 113efa0:	97ffff6d 	bl	113ed54 <_char_to_int>
 113efa4:	2a0003e2 	mov	w2, w0
 113efa8:	39413be0 	ldrb	w0, [sp, #78]
 113efac:	97ffff6a 	bl	113ed54 <_char_to_int>
 113efb0:	52800143 	mov	w3, #0xa                   	// #10
 113efb4:	1b030040 	madd	w0, w2, w3, w0
 113efb8:	b9001e60 	str	w0, [x19, #28]
 113efbc:	71005c1f 	cmp	w0, #0x17
 113efc0:	54fffca8 	b.hi	113ef54 <der_decode_utctime+0x1e4>  // b.pmore
       DECODE_V(out->off_mm, 60);
 113efc4:	39413fe0 	ldrb	w0, [sp, #79]
 113efc8:	97ffff63 	bl	113ed54 <_char_to_int>
 113efcc:	2a0003e2 	mov	w2, w0
 113efd0:	394143e0 	ldrb	w0, [sp, #80]
 113efd4:	97ffff60 	bl	113ed54 <_char_to_int>
 113efd8:	1b030040 	madd	w0, w2, w3, w0
 113efdc:	b9002260 	str	w0, [x19, #32]
 113efe0:	7100ec1f 	cmp	w0, #0x3b
 113efe4:	17ffffdb 	b	113ef50 <der_decode_utctime+0x1e0>
   LTC_ARGCHK(in    != NULL);
 113efe8:	52800200 	mov	w0, #0x10                  	// #16
 113efec:	17ffffb4 	b	113eebc <der_decode_utctime+0x14c>

000000000113eff0 <der_decode_utf8_string>:
{
   wchar_t       tmp;
   unsigned long x, y, z, len;
   int err;

   LTC_ARGCHK(in     != NULL);
 113eff0:	b4000aa0 	cbz	x0, 113f144 <der_decode_utf8_string+0x154>
{
 113eff4:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 113eff8:	910003fd 	mov	x29, sp
 113effc:	a90153f3 	stp	x19, x20, [sp, #16]
 113f000:	a9025bf5 	stp	x21, x22, [sp, #32]
 113f004:	aa0203f6 	mov	x22, x2
   LTC_ARGCHK(out    != NULL);
 113f008:	b4000a22 	cbz	x2, 113f14c <der_decode_utf8_string+0x15c>
 113f00c:	aa0303f5 	mov	x21, x3
   LTC_ARGCHK(outlen != NULL);
 113f010:	b40009e3 	cbz	x3, 113f14c <der_decode_utf8_string+0x15c>
 113f014:	aa0103f3 	mov	x19, x1

   /* must have header at least */
   if (inlen < 2) {
 113f018:	f100043f 	cmp	x1, #0x1
 113f01c:	540004c9 	b.ls	113f0b4 <der_decode_utf8_string+0xc4>  // b.plast
 113f020:	aa0003f4 	mov	x20, x0
      return CRYPT_INVALID_PACKET;
   }

   /* check for 0x0C */
   if ((in[0] & 0x1F) != 0x0C) {
 113f024:	39400000 	ldrb	w0, [x0]
 113f028:	12001000 	and	w0, w0, #0x1f
 113f02c:	7100301f 	cmp	w0, #0xc
 113f030:	54000421 	b.ne	113f0b4 <der_decode_utf8_string+0xc4>  // b.any
      return CRYPT_INVALID_PACKET;
   }
   x = 1;

   /* get the length of the data */
   y = inlen - x;
 113f034:	d1000420 	sub	x0, x1, #0x1
   if ((err = der_decode_asn1_length(in + x, &y, &len)) != CRYPT_OK) {
 113f038:	9100e3e2 	add	x2, sp, #0x38
 113f03c:	9100c3e1 	add	x1, sp, #0x30
   y = inlen - x;
 113f040:	f9001be0 	str	x0, [sp, #48]
   if ((err = der_decode_asn1_length(in + x, &y, &len)) != CRYPT_OK) {
 113f044:	91000680 	add	x0, x20, #0x1
 113f048:	97fff7ce 	bl	113cf80 <der_decode_asn1_length>
 113f04c:	35000360 	cbnz	w0, 113f0b8 <der_decode_utf8_string+0xc8>
      return err;
   }
   x += y;

   if (len > (inlen - x)) {
 113f050:	a94303e4 	ldp	x4, x0, [sp, #48]
   x += y;
 113f054:	91000484 	add	x4, x4, #0x1
   if (len > (inlen - x)) {
 113f058:	cb040261 	sub	x1, x19, x4
 113f05c:	eb00003f 	cmp	x1, x0
 113f060:	540002a3 	b.cc	113f0b4 <der_decode_utf8_string+0xc4>  // b.lo, b.ul, b.last
      return CRYPT_INVALID_PACKET;
   }

   /* proceed to decode */
   for (y = 0; x < inlen; ) {
 113f064:	d2800000 	mov	x0, #0x0                   	// #0
 113f068:	52800001 	mov	w1, #0x0                   	// #0
 113f06c:	f9001bff 	str	xzr, [sp, #48]
 113f070:	eb13009f 	cmp	x4, x19
 113f074:	54000143 	b.cc	113f09c <der_decode_utf8_string+0xac>  // b.lo, b.ul, b.last
 113f078:	34000041 	cbz	w1, 113f080 <der_decode_utf8_string+0x90>
 113f07c:	f9001be0 	str	x0, [sp, #48]
      if (y < *outlen) {
         out[y] = tmp;
      }
      y++;
   }
   if (y > *outlen) {
 113f080:	f94002a0 	ldr	x0, [x21]
 113f084:	f9401be1 	ldr	x1, [sp, #48]
      err = CRYPT_BUFFER_OVERFLOW;
   } else {
      err = CRYPT_OK;
   }
   *outlen = y;
 113f088:	f90002a1 	str	x1, [x21]
      err = CRYPT_BUFFER_OVERFLOW;
 113f08c:	eb01001f 	cmp	x0, x1
 113f090:	528000c0 	mov	w0, #0x6                   	// #6
 113f094:	1a8023e0 	csel	w0, wzr, w0, cs  // cs = hs, nlast

   return err;
 113f098:	14000008 	b	113f0b8 <der_decode_utf8_string+0xc8>
      tmp = in[x++];
 113f09c:	38646a86 	ldrb	w6, [x20, x4]
 113f0a0:	91000481 	add	x1, x4, #0x1
      for (z = 0; (tmp & 0x80) && (z <= 4); z++, tmp = (tmp << 1) & 0xFF);
 113f0a4:	d2800005 	mov	x5, #0x0                   	// #0
 113f0a8:	36380166 	tbz	w6, #7, 113f0d4 <der_decode_utf8_string+0xe4>
 113f0ac:	f10014bf 	cmp	x5, #0x5
 113f0b0:	540000c1 	b.ne	113f0c8 <der_decode_utf8_string+0xd8>  // b.any
         return CRYPT_INVALID_PACKET;
 113f0b4:	528000e0 	mov	w0, #0x7                   	// #7
}
 113f0b8:	a94153f3 	ldp	x19, x20, [sp, #16]
 113f0bc:	a9425bf5 	ldp	x21, x22, [sp, #32]
 113f0c0:	a8c47bfd 	ldp	x29, x30, [sp], #64
 113f0c4:	d65f03c0 	ret
      for (z = 0; (tmp & 0x80) && (z <= 4); z++, tmp = (tmp << 1) & 0xFF);
 113f0c8:	910004a5 	add	x5, x5, #0x1
 113f0cc:	531f18c6 	ubfiz	w6, w6, #1, #7
 113f0d0:	17fffff6 	b	113f0a8 <der_decode_utf8_string+0xb8>
      if (z == 1 || z > 4 || (x + (z - 1) > inlen)) {
 113f0d4:	f10004bf 	cmp	x5, #0x1
 113f0d8:	fa4418a2 	ccmp	x5, #0x4, #0x2, ne  // ne = any
 113f0dc:	54fffec8 	b.hi	113f0b4 <der_decode_utf8_string+0xc4>  // b.pmore
 113f0e0:	8b050084 	add	x4, x4, x5
 113f0e4:	eb13009f 	cmp	x4, x19
 113f0e8:	54fffe68 	b.hi	113f0b4 <der_decode_utf8_string+0xc4>  // b.pmore
      tmp >>= z;
 113f0ec:	f10004bf 	cmp	x5, #0x1
 113f0f0:	1ac524c6 	lsr	w6, w6, w5
      if (z > 1) { --z; }
 113f0f4:	9a9f97e2 	cset	x2, hi  // hi = pmore
 113f0f8:	cb0200a5 	sub	x5, x5, x2
 113f0fc:	8b050024 	add	x4, x1, x5
      while (z-- != 0) {
 113f100:	eb04003f 	cmp	x1, x4
 113f104:	54000101 	b.ne	113f124 <der_decode_utf8_string+0x134>  // b.any
      if (y < *outlen) {
 113f108:	f94002a1 	ldr	x1, [x21]
 113f10c:	eb00003f 	cmp	x1, x0
 113f110:	54000049 	b.ls	113f118 <der_decode_utf8_string+0x128>  // b.plast
         out[y] = tmp;
 113f114:	b8207ac6 	str	w6, [x22, x0, lsl #2]
      y++;
 113f118:	91000400 	add	x0, x0, #0x1
   for (y = 0; x < inlen; ) {
 113f11c:	52800021 	mov	w1, #0x1                   	// #1
 113f120:	17ffffd4 	b	113f070 <der_decode_utf8_string+0x80>
         if ((in[x] & 0xC0) != 0x80) {
 113f124:	38616a82 	ldrb	w2, [x20, x1]
 113f128:	121a0443 	and	w3, w2, #0xc0
 113f12c:	7102007f 	cmp	w3, #0x80
 113f130:	54fffc21 	b.ne	113f0b4 <der_decode_utf8_string+0xc4>  // b.any
         tmp = (tmp << 6) | ((wchar_t)in[x++] & 0x3F);
 113f134:	12001442 	and	w2, w2, #0x3f
 113f138:	91000421 	add	x1, x1, #0x1
 113f13c:	2a061846 	orr	w6, w2, w6, lsl #6
 113f140:	17fffff0 	b	113f100 <der_decode_utf8_string+0x110>
   LTC_ARGCHK(in     != NULL);
 113f144:	52800200 	mov	w0, #0x10                  	// #16
}
 113f148:	d65f03c0 	ret
   LTC_ARGCHK(in     != NULL);
 113f14c:	52800200 	mov	w0, #0x10                  	// #16
 113f150:	17ffffda 	b	113f0b8 <der_decode_utf8_string+0xc8>

000000000113f154 <der_decode_teletex_string>:
  @param outlen  [in/out] The number of octets stored
  @return CRYPT_OK if successful
*/
int der_decode_teletex_string(const unsigned char *in, unsigned long inlen,
                                unsigned char *out, unsigned long *outlen)
{
 113f154:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 113f158:	910003fd 	mov	x29, sp
 113f15c:	a90153f3 	stp	x19, x20, [sp, #16]
 113f160:	a9025bf5 	stp	x21, x22, [sp, #32]
 113f164:	f9001bf7 	str	x23, [sp, #48]
   unsigned long x, y, len;
   int           t, err;

   LTC_ARGCHK(in     != NULL);
 113f168:	b5000100 	cbnz	x0, 113f188 <der_decode_teletex_string+0x34>
 113f16c:	52800214 	mov	w20, #0x10                  	// #16
   }

   *outlen = y;

   return CRYPT_OK;
}
 113f170:	2a1403e0 	mov	w0, w20
 113f174:	a94153f3 	ldp	x19, x20, [sp, #16]
 113f178:	a9425bf5 	ldp	x21, x22, [sp, #32]
 113f17c:	f9401bf7 	ldr	x23, [sp, #48]
 113f180:	a8c57bfd 	ldp	x29, x30, [sp], #80
 113f184:	d65f03c0 	ret
 113f188:	aa0203f7 	mov	x23, x2
   LTC_ARGCHK(out    != NULL);
 113f18c:	b4ffff02 	cbz	x2, 113f16c <der_decode_teletex_string+0x18>
 113f190:	aa0303f5 	mov	x21, x3
   LTC_ARGCHK(outlen != NULL);
 113f194:	b4fffec3 	cbz	x3, 113f16c <der_decode_teletex_string+0x18>
 113f198:	aa0103f6 	mov	x22, x1
   if (inlen < 2) {
 113f19c:	f100043f 	cmp	x1, #0x1
 113f1a0:	54000068 	b.hi	113f1ac <der_decode_teletex_string+0x58>  // b.pmore
      return CRYPT_INVALID_PACKET;
 113f1a4:	528000f4 	mov	w20, #0x7                   	// #7
 113f1a8:	17fffff2 	b	113f170 <der_decode_teletex_string+0x1c>
 113f1ac:	aa0003f3 	mov	x19, x0
   if ((in[0] & 0x1F) != 0x14) {
 113f1b0:	39400000 	ldrb	w0, [x0]
 113f1b4:	12001000 	and	w0, w0, #0x1f
 113f1b8:	7100501f 	cmp	w0, #0x14
 113f1bc:	54ffff41 	b.ne	113f1a4 <der_decode_teletex_string+0x50>  // b.any
   y = inlen - x;
 113f1c0:	d1000420 	sub	x0, x1, #0x1
   if ((err = der_decode_asn1_length(in + x, &y, &len)) != CRYPT_OK) {
 113f1c4:	910123e2 	add	x2, sp, #0x48
 113f1c8:	910103e1 	add	x1, sp, #0x40
   y = inlen - x;
 113f1cc:	f90023e0 	str	x0, [sp, #64]
   if ((err = der_decode_asn1_length(in + x, &y, &len)) != CRYPT_OK) {
 113f1d0:	91000660 	add	x0, x19, #0x1
 113f1d4:	97fff76b 	bl	113cf80 <der_decode_asn1_length>
 113f1d8:	2a0003f4 	mov	w20, w0
 113f1dc:	35fffca0 	cbnz	w0, 113f170 <der_decode_teletex_string+0x1c>
   if (len > *outlen) {
 113f1e0:	a9440be0 	ldp	x0, x2, [sp, #64]
 113f1e4:	f94002a3 	ldr	x3, [x21]
 113f1e8:	aa2003e1 	mvn	x1, x0
 113f1ec:	eb02007f 	cmp	x3, x2
 113f1f0:	54000082 	b.cs	113f200 <der_decode_teletex_string+0xac>  // b.hs, b.nlast
      return CRYPT_BUFFER_OVERFLOW;
 113f1f4:	528000d4 	mov	w20, #0x6                   	// #6
      *outlen = len;
 113f1f8:	f90002a2 	str	x2, [x21]
      return CRYPT_BUFFER_OVERFLOW;
 113f1fc:	17ffffdd 	b	113f170 <der_decode_teletex_string+0x1c>
   if (len > (inlen - x)) {
 113f200:	8b160036 	add	x22, x1, x22
 113f204:	eb16005f 	cmp	x2, x22
 113f208:	54fffce8 	b.hi	113f1a4 <der_decode_teletex_string+0x50>  // b.pmore
   for (y = 0; y < len; y++) {
 113f20c:	8b000273 	add	x19, x19, x0
 113f210:	f90023ff 	str	xzr, [sp, #64]
 113f214:	a94407e0 	ldp	x0, x1, [sp, #64]
 113f218:	eb01001f 	cmp	x0, x1
 113f21c:	54000063 	b.cc	113f228 <der_decode_teletex_string+0xd4>  // b.lo, b.ul, b.last
   *outlen = y;
 113f220:	f90002a0 	str	x0, [x21]
   return CRYPT_OK;
 113f224:	17ffffd3 	b	113f170 <der_decode_teletex_string+0x1c>
       t = der_teletex_value_decode(in[x++]);
 113f228:	38401e60 	ldrb	w0, [x19, #1]!
 113f22c:	97ffedc8 	bl	113a94c <der_teletex_value_decode>
       if (t == -1) {
 113f230:	3100041f 	cmn	w0, #0x1
 113f234:	54fff9c0 	b.eq	113f16c <der_decode_teletex_string+0x18>  // b.none
       out[y] = t;
 113f238:	f94023e1 	ldr	x1, [sp, #64]
 113f23c:	38216ae0 	strb	w0, [x23, x1]
   for (y = 0; y < len; y++) {
 113f240:	91000421 	add	x1, x1, #0x1
 113f244:	f90023e1 	str	x1, [sp, #64]
 113f248:	17fffff3 	b	113f214 <der_decode_teletex_string+0xc0>

000000000113f24c <pkcs_1_mgf1>:
   @return CRYPT_OK if successful
*/
int pkcs_1_mgf1(int                  hash_idx,
                const unsigned char *seed, unsigned long seedlen,
                      unsigned char *mask, unsigned long masklen)
{
 113f24c:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
 113f250:	910003fd 	mov	x29, sp
 113f254:	a90153f3 	stp	x19, x20, [sp, #16]
 113f258:	a9025bf5 	stp	x21, x22, [sp, #32]
 113f25c:	a90363f7 	stp	x23, x24, [sp, #48]
 113f260:	a9046bf9 	stp	x25, x26, [sp, #64]
 113f264:	a90573fb 	stp	x27, x28, [sp, #80]
 113f268:	f90037e2 	str	x2, [sp, #104]
   ulong32       counter;
   int           err;
   hash_state    *md;
   unsigned char *buf;

   LTC_ARGCHK(seed != NULL);
 113f26c:	b4000ba1 	cbz	x1, 113f3e0 <pkcs_1_mgf1+0x194>
 113f270:	aa0303f5 	mov	x21, x3
   LTC_ARGCHK(mask != NULL);
 113f274:	b4000b63 	cbz	x3, 113f3e0 <pkcs_1_mgf1+0x194>
 113f278:	93407c1c 	sxtw	x28, w0
 113f27c:	aa0103f6 	mov	x22, x1
 113f280:	aa0403f4 	mov	x20, x4

   /* ensure valid hash */
   if ((err = hash_is_valid(hash_idx)) != CRYPT_OK) {
 113f284:	97ffccfc 	bl	1132674 <hash_is_valid>
 113f288:	35000960 	cbnz	w0, 113f3b4 <pkcs_1_mgf1+0x168>
      return err;
   }

   /* get hash output size */
   hLen = hash_descriptor[hash_idx]->hashsize;
 113f28c:	f00000c1 	adrp	x1, 115a000 <__scattered_array_1phys_mem_map+0x8>
      }
      return CRYPT_MEM;
   }

   /* start counter */
   counter = 0;
 113f290:	52800019 	mov	w25, #0x0                   	// #0
   hLen = hash_descriptor[hash_idx]->hashsize;
 113f294:	f941a038 	ldr	x24, [x1, #832]
 113f298:	f87c7b00 	ldr	x0, [x24, x28, lsl #3]
 113f29c:	f9400817 	ldr	x23, [x0, #16]
   md  = XMALLOC(sizeof(hash_state));
 113f2a0:	d2801a00 	mov	x0, #0xd0                  	// #208
 113f2a4:	9400106d 	bl	1143458 <malloc>
 113f2a8:	aa0003fa 	mov	x26, x0
   buf = XMALLOC(hLen);
 113f2ac:	aa1703e0 	mov	x0, x23
 113f2b0:	9400106a 	bl	1143458 <malloc>
   if (md == NULL || buf == NULL) {
 113f2b4:	f100035f 	cmp	x26, #0x0
   buf = XMALLOC(hLen);
 113f2b8:	aa0003fb 	mov	x27, x0
   if (md == NULL || buf == NULL) {
 113f2bc:	fa401804 	ccmp	x0, #0x0, #0x4, ne  // ne = any
 113f2c0:	54000601 	b.ne	113f380 <pkcs_1_mgf1+0x134>  // b.any
      if (md != NULL) {
 113f2c4:	b400007a 	cbz	x26, 113f2d0 <pkcs_1_mgf1+0x84>
         XFREE(md);
 113f2c8:	aa1a03e0 	mov	x0, x26
 113f2cc:	940010c5 	bl	11435e0 <free>
      if (buf != NULL) {
 113f2d0:	b400007b 	cbz	x27, 113f2dc <pkcs_1_mgf1+0x90>
         XFREE(buf);
 113f2d4:	aa1b03e0 	mov	x0, x27
 113f2d8:	940010c2 	bl	11435e0 <free>
      return CRYPT_MEM;
 113f2dc:	528001a0 	mov	w0, #0xd                   	// #13
 113f2e0:	14000035 	b	113f3b4 <pkcs_1_mgf1+0x168>

   while (masklen > 0) {
       /* handle counter */
       STORE32H(counter, buf);
 113f2e4:	5ac00b20 	rev	w0, w25
 113f2e8:	b9000360 	str	w0, [x27]
       ++counter;

       /* get hash of seed || counter */
       if ((err = hash_descriptor[hash_idx]->init(md)) != CRYPT_OK) {
 113f2ec:	f87c7b00 	ldr	x0, [x24, x28, lsl #3]
       ++counter;
 113f2f0:	11000739 	add	w25, w25, #0x1
       if ((err = hash_descriptor[hash_idx]->init(md)) != CRYPT_OK) {
 113f2f4:	f9405401 	ldr	x1, [x0, #168]
 113f2f8:	aa1a03e0 	mov	x0, x26
 113f2fc:	d63f0020 	blr	x1
 113f300:	2a0003f3 	mov	w19, w0
 113f304:	35000420 	cbnz	w0, 113f388 <pkcs_1_mgf1+0x13c>
          goto LBL_ERR;
       }
       if ((err = hash_descriptor[hash_idx]->process(md, seed, seedlen)) != CRYPT_OK) {
 113f308:	f87c7b00 	ldr	x0, [x24, x28, lsl #3]
 113f30c:	aa1603e1 	mov	x1, x22
 113f310:	f94037e2 	ldr	x2, [sp, #104]
 113f314:	f9405804 	ldr	x4, [x0, #176]
 113f318:	aa1a03e0 	mov	x0, x26
 113f31c:	d63f0080 	blr	x4
 113f320:	2a0003f3 	mov	w19, w0
 113f324:	35000320 	cbnz	w0, 113f388 <pkcs_1_mgf1+0x13c>
          goto LBL_ERR;
       }
       if ((err = hash_descriptor[hash_idx]->process(md, buf, 4)) != CRYPT_OK) {
 113f328:	f87c7b00 	ldr	x0, [x24, x28, lsl #3]
 113f32c:	aa1b03e1 	mov	x1, x27
 113f330:	d2800082 	mov	x2, #0x4                   	// #4
 113f334:	f9405804 	ldr	x4, [x0, #176]
 113f338:	aa1a03e0 	mov	x0, x26
 113f33c:	d63f0080 	blr	x4
 113f340:	2a0003f3 	mov	w19, w0
 113f344:	35000220 	cbnz	w0, 113f388 <pkcs_1_mgf1+0x13c>
          goto LBL_ERR;
       }
       if ((err = hash_descriptor[hash_idx]->done(md, buf)) != CRYPT_OK) {
 113f348:	f87c7b00 	ldr	x0, [x24, x28, lsl #3]
 113f34c:	aa1b03e1 	mov	x1, x27
 113f350:	f9405c02 	ldr	x2, [x0, #184]
 113f354:	aa1a03e0 	mov	x0, x26
 113f358:	d63f0040 	blr	x2
 113f35c:	2a0003f3 	mov	w19, w0
 113f360:	35000140 	cbnz	w0, 113f388 <pkcs_1_mgf1+0x13c>
          goto LBL_ERR;
       }

       /* store it */
       for (x = 0; x < hLen && masklen > 0; x++, masklen--) {
 113f364:	d2800000 	mov	x0, #0x0                   	// #0
 113f368:	eb000282 	subs	x2, x20, x0
 113f36c:	8b0002a1 	add	x1, x21, x0
 113f370:	fa571002 	ccmp	x0, x23, #0x2, ne  // ne = any
 113f374:	540002e3 	b.cc	113f3d0 <pkcs_1_mgf1+0x184>  // b.lo, b.ul, b.last
 113f378:	aa0203f4 	mov	x20, x2
 113f37c:	aa0103f5 	mov	x21, x1
   while (masklen > 0) {
 113f380:	b5fffb34 	cbnz	x20, 113f2e4 <pkcs_1_mgf1+0x98>
          *mask++ = buf[x];
       }
   }

   err = CRYPT_OK;
 113f384:	52800013 	mov	w19, #0x0                   	// #0
LBL_ERR:
#ifdef LTC_CLEAN_STACK
   zeromem(buf, hLen);
 113f388:	aa1703e1 	mov	x1, x23
 113f38c:	aa1b03e0 	mov	x0, x27
 113f390:	97ffcc2d 	bl	1132444 <zeromem>
   zeromem(md,  sizeof(hash_state));
 113f394:	d2801a01 	mov	x1, #0xd0                  	// #208
 113f398:	aa1a03e0 	mov	x0, x26
 113f39c:	97ffcc2a 	bl	1132444 <zeromem>
#endif

   XFREE(buf);
 113f3a0:	aa1b03e0 	mov	x0, x27
 113f3a4:	9400108f 	bl	11435e0 <free>
   XFREE(md);
 113f3a8:	aa1a03e0 	mov	x0, x26
 113f3ac:	9400108d 	bl	11435e0 <free>

   return err;
 113f3b0:	2a1303e0 	mov	w0, w19
}
 113f3b4:	a94153f3 	ldp	x19, x20, [sp, #16]
 113f3b8:	a9425bf5 	ldp	x21, x22, [sp, #32]
 113f3bc:	a94363f7 	ldp	x23, x24, [sp, #48]
 113f3c0:	a9446bf9 	ldp	x25, x26, [sp, #64]
 113f3c4:	a94573fb 	ldp	x27, x28, [sp, #80]
 113f3c8:	a8c77bfd 	ldp	x29, x30, [sp], #112
 113f3cc:	d65f03c0 	ret
          *mask++ = buf[x];
 113f3d0:	38606b61 	ldrb	w1, [x27, x0]
 113f3d4:	38206aa1 	strb	w1, [x21, x0]
       for (x = 0; x < hLen && masklen > 0; x++, masklen--) {
 113f3d8:	91000400 	add	x0, x0, #0x1
 113f3dc:	17ffffe3 	b	113f368 <pkcs_1_mgf1+0x11c>
   LTC_ARGCHK(seed != NULL);
 113f3e0:	52800200 	mov	w0, #0x10                  	// #16
 113f3e4:	17fffff4 	b	113f3b4 <pkcs_1_mgf1+0x168>

000000000113f3e8 <der_decode_bit_string>:
                                unsigned char *out, unsigned long *outlen)
{
   unsigned long dlen, blen, x, y;
   int err;

   LTC_ARGCHK(in     != NULL);
 113f3e8:	b4000800 	cbz	x0, 113f4e8 <der_decode_bit_string+0x100>
{
 113f3ec:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 113f3f0:	910003fd 	mov	x29, sp
 113f3f4:	a90153f3 	stp	x19, x20, [sp, #16]
 113f3f8:	a9025bf5 	stp	x21, x22, [sp, #32]
 113f3fc:	aa0203f6 	mov	x22, x2
   LTC_ARGCHK(out    != NULL);
 113f400:	b4000782 	cbz	x2, 113f4f0 <der_decode_bit_string+0x108>
 113f404:	aa0303f5 	mov	x21, x3
   LTC_ARGCHK(outlen != NULL);
 113f408:	b4000743 	cbz	x3, 113f4f0 <der_decode_bit_string+0x108>
 113f40c:	aa0103f4 	mov	x20, x1

   /* packet must be at least 4 bytes */
   if (inlen < 4) {
 113f410:	f1000c3f 	cmp	x1, #0x3
 113f414:	540006e9 	b.ls	113f4f0 <der_decode_bit_string+0x108>  // b.plast
 113f418:	aa0003f3 	mov	x19, x0
       return CRYPT_INVALID_ARG;
   }

   /* check for 0x03 */
   if ((in[0]&0x1F) != 0x03) {
 113f41c:	39400000 	ldrb	w0, [x0]
 113f420:	12001000 	and	w0, w0, #0x1f
 113f424:	71000c1f 	cmp	w0, #0x3
 113f428:	540000c0 	b.eq	113f440 <der_decode_bit_string+0x58>  // b.none
      return CRYPT_INVALID_PACKET;
 113f42c:	528000e0 	mov	w0, #0x7                   	// #7
   }

   /* we done */
   *outlen = blen;
   return CRYPT_OK;
}
 113f430:	a94153f3 	ldp	x19, x20, [sp, #16]
 113f434:	a9425bf5 	ldp	x21, x22, [sp, #32]
 113f438:	a8c47bfd 	ldp	x29, x30, [sp], #64
 113f43c:	d65f03c0 	ret
   y = inlen - 1;
 113f440:	d1000420 	sub	x0, x1, #0x1
   if ((err = der_decode_asn1_length(in + x, &y, &dlen)) != CRYPT_OK) {
 113f444:	9100c3e2 	add	x2, sp, #0x30
 113f448:	9100e3e1 	add	x1, sp, #0x38
   y = inlen - 1;
 113f44c:	f9001fe0 	str	x0, [sp, #56]
   if ((err = der_decode_asn1_length(in + x, &y, &dlen)) != CRYPT_OK) {
 113f450:	91000660 	add	x0, x19, #0x1
 113f454:	97fff6cb 	bl	113cf80 <der_decode_asn1_length>
 113f458:	35fffec0 	cbnz	w0, 113f430 <der_decode_bit_string+0x48>
   x += y;
 113f45c:	a94317e4 	ldp	x4, x5, [sp, #48]
 113f460:	910004a2 	add	x2, x5, #0x1
   if ((dlen == 0) || (dlen > (inlen - x))) {
 113f464:	b4fffe44 	cbz	x4, 113f42c <der_decode_bit_string+0x44>
 113f468:	cb020294 	sub	x20, x20, x2
 113f46c:	eb14009f 	cmp	x4, x20
 113f470:	54fffde8 	b.hi	113f42c <der_decode_bit_string+0x44>  // b.pmore
   blen = ((dlen - 1) << 3) - (in[x++] & 7);
 113f474:	38626a62 	ldrb	w2, [x19, x2]
 113f478:	d1000481 	sub	x1, x4, #0x1
 113f47c:	910008a5 	add	x5, x5, #0x2
 113f480:	92400842 	and	x2, x2, #0x7
 113f484:	d37df021 	lsl	x1, x1, #3
 113f488:	cb020021 	sub	x1, x1, x2
   if (blen > *outlen) {
 113f48c:	f94002a2 	ldr	x2, [x21]
 113f490:	eb01005f 	cmp	x2, x1
 113f494:	54000262 	b.cs	113f4e0 <der_decode_bit_string+0xf8>  // b.hs, b.nlast
      return CRYPT_BUFFER_OVERFLOW;
 113f498:	528000c0 	mov	w0, #0x6                   	// #6
      *outlen = blen;
 113f49c:	f90002a1 	str	x1, [x21]
      return CRYPT_BUFFER_OVERFLOW;
 113f4a0:	17ffffe4 	b	113f430 <der_decode_bit_string+0x48>
       out[y] = (in[x] & (1 << (7 - (y & 7)))) ? 1 : 0;
 113f4a4:	38656a64 	ldrb	w4, [x19, x5]
 113f4a8:	2a2303e2 	mvn	w2, w3
 113f4ac:	12000842 	and	w2, w2, #0x7
 113f4b0:	1ac22884 	asr	w4, w4, w2
 113f4b4:	12000084 	and	w4, w4, #0x1
 113f4b8:	38236ac4 	strb	w4, [x22, x3]
       if ((y & 7) == 7) {
 113f4bc:	92400862 	and	x2, x3, #0x7
 113f4c0:	f1001c5f 	cmp	x2, #0x7
 113f4c4:	54000041 	b.ne	113f4cc <der_decode_bit_string+0xe4>  // b.any
          ++x;
 113f4c8:	910004a5 	add	x5, x5, #0x1
   for (y = 0; y < blen; y++) {
 113f4cc:	91000463 	add	x3, x3, #0x1
 113f4d0:	eb03003f 	cmp	x1, x3
 113f4d4:	54fffe81 	b.ne	113f4a4 <der_decode_bit_string+0xbc>  // b.any
   *outlen = blen;
 113f4d8:	f90002a1 	str	x1, [x21]
   return CRYPT_OK;
 113f4dc:	17ffffd5 	b	113f430 <der_decode_bit_string+0x48>
 113f4e0:	d2800003 	mov	x3, #0x0                   	// #0
 113f4e4:	17fffffb 	b	113f4d0 <der_decode_bit_string+0xe8>
   LTC_ARGCHK(in     != NULL);
 113f4e8:	52800200 	mov	w0, #0x10                  	// #16
}
 113f4ec:	d65f03c0 	ret
   LTC_ARGCHK(in     != NULL);
 113f4f0:	52800200 	mov	w0, #0x10                  	// #16
 113f4f4:	17ffffcf 	b	113f430 <der_decode_bit_string+0x48>

000000000113f4f8 <der_decode_raw_bit_string>:
                                unsigned char *out, unsigned long *outlen)
{
   unsigned long dlen, blen, x, y;
   int err;

   LTC_ARGCHK(in     != NULL);
 113f4f8:	b4000900 	cbz	x0, 113f618 <der_decode_raw_bit_string+0x120>
{
 113f4fc:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
 113f500:	910003fd 	mov	x29, sp
 113f504:	a90153f3 	stp	x19, x20, [sp, #16]
 113f508:	a9025bf5 	stp	x21, x22, [sp, #32]
 113f50c:	aa0203f6 	mov	x22, x2
   LTC_ARGCHK(out    != NULL);
 113f510:	b4000882 	cbz	x2, 113f620 <der_decode_raw_bit_string+0x128>
 113f514:	aa0303f5 	mov	x21, x3
   LTC_ARGCHK(outlen != NULL);
 113f518:	b4000843 	cbz	x3, 113f620 <der_decode_raw_bit_string+0x128>
 113f51c:	aa0103f4 	mov	x20, x1

   /* packet must be at least 4 bytes */
   if (inlen < 4) {
 113f520:	f1000c3f 	cmp	x1, #0x3
 113f524:	540007e9 	b.ls	113f620 <der_decode_raw_bit_string+0x128>  // b.plast
 113f528:	aa0003f3 	mov	x19, x0
       return CRYPT_INVALID_ARG;
   }

   /* check for 0x03 */
   if ((in[0]&0x1F) != 0x03) {
 113f52c:	39400000 	ldrb	w0, [x0]
 113f530:	12001000 	and	w0, w0, #0x1f
 113f534:	71000c1f 	cmp	w0, #0x3
 113f538:	540000c0 	b.eq	113f550 <der_decode_raw_bit_string+0x58>  // b.none
      return CRYPT_INVALID_PACKET;
 113f53c:	528000e0 	mov	w0, #0x7                   	// #7
   }

   /* we done */
   *outlen = blen;
   return CRYPT_OK;
}
 113f540:	a94153f3 	ldp	x19, x20, [sp, #16]
 113f544:	a9425bf5 	ldp	x21, x22, [sp, #32]
 113f548:	a8c47bfd 	ldp	x29, x30, [sp], #64
 113f54c:	d65f03c0 	ret
   y = inlen - 1;
 113f550:	d1000420 	sub	x0, x1, #0x1
   if ((err = der_decode_asn1_length(in + x, &y, &dlen)) != CRYPT_OK) {
 113f554:	9100c3e2 	add	x2, sp, #0x30
 113f558:	9100e3e1 	add	x1, sp, #0x38
   y = inlen - 1;
 113f55c:	f9001fe0 	str	x0, [sp, #56]
   if ((err = der_decode_asn1_length(in + x, &y, &dlen)) != CRYPT_OK) {
 113f560:	91000660 	add	x0, x19, #0x1
 113f564:	97fff687 	bl	113cf80 <der_decode_asn1_length>
 113f568:	35fffec0 	cbnz	w0, 113f540 <der_decode_raw_bit_string+0x48>
   x += y;
 113f56c:	a9431be4 	ldp	x4, x6, [sp, #48]
 113f570:	910004c2 	add	x2, x6, #0x1
   if ((dlen == 0) || (dlen > (inlen - x))) {
 113f574:	b4fffe44 	cbz	x4, 113f53c <der_decode_raw_bit_string+0x44>
 113f578:	cb020294 	sub	x20, x20, x2
 113f57c:	eb14009f 	cmp	x4, x20
 113f580:	54fffde8 	b.hi	113f53c <der_decode_raw_bit_string+0x44>  // b.pmore
   blen = ((dlen - 1) << 3) - (in[x++] & 7);
 113f584:	38626a62 	ldrb	w2, [x19, x2]
 113f588:	d1000481 	sub	x1, x4, #0x1
 113f58c:	910008c6 	add	x6, x6, #0x2
 113f590:	92400842 	and	x2, x2, #0x7
 113f594:	d37df021 	lsl	x1, x1, #3
 113f598:	cb020021 	sub	x1, x1, x2
   if (blen > *outlen) {
 113f59c:	f94002a2 	ldr	x2, [x21]
 113f5a0:	eb01005f 	cmp	x2, x1
 113f5a4:	54000082 	b.cs	113f5b4 <der_decode_raw_bit_string+0xbc>  // b.hs, b.nlast
      return CRYPT_BUFFER_OVERFLOW;
 113f5a8:	528000c0 	mov	w0, #0x6                   	// #6
      *outlen = blen;
 113f5ac:	f90002a1 	str	x1, [x21]
      return CRYPT_BUFFER_OVERFLOW;
 113f5b0:	17ffffe4 	b	113f540 <der_decode_raw_bit_string+0x48>
   for (y = 0; y < blen; y++) {
 113f5b4:	d2800003 	mov	x3, #0x0                   	// #0
 113f5b8:	52800029 	mov	w9, #0x1                   	// #1
 113f5bc:	eb03003f 	cmp	x1, x3
 113f5c0:	54000061 	b.ne	113f5cc <der_decode_raw_bit_string+0xd4>  // b.any
   *outlen = blen;
 113f5c4:	f90002a1 	str	x1, [x21]
   return CRYPT_OK;
 113f5c8:	17ffffde 	b	113f540 <der_decode_raw_bit_string+0x48>
      if (in[x] & (1 << (7 - (y & 7)))) {
 113f5cc:	d343fc68 	lsr	x8, x3, #3
 113f5d0:	38666a62 	ldrb	w2, [x19, x6]
 113f5d4:	2a2303e5 	mvn	w5, w3
 113f5d8:	120008aa 	and	w10, w5, #0x7
 113f5dc:	38686ac7 	ldrb	w7, [x22, x8]
 113f5e0:	1aca2842 	asr	w2, w2, w10
 113f5e4:	1aca2124 	lsl	w4, w9, w10
 113f5e8:	12001c84 	and	w4, w4, #0xff
         SETBIT(out[y/8], 7-(y%8));
 113f5ec:	f240005f 	tst	x2, #0x1
 113f5f0:	0a2400e5 	bic	w5, w7, w4
 113f5f4:	2a0400e4 	orr	w4, w7, w4
      if ((y & 7) == 7) {
 113f5f8:	92400862 	and	x2, x3, #0x7
         SETBIT(out[y/8], 7-(y%8));
 113f5fc:	1a851084 	csel	w4, w4, w5, ne  // ne = any
 113f600:	38286ac4 	strb	w4, [x22, x8]
      if ((y & 7) == 7) {
 113f604:	f1001c5f 	cmp	x2, #0x7
 113f608:	54000041 	b.ne	113f610 <der_decode_raw_bit_string+0x118>  // b.any
         ++x;
 113f60c:	910004c6 	add	x6, x6, #0x1
   for (y = 0; y < blen; y++) {
 113f610:	91000463 	add	x3, x3, #0x1
 113f614:	17ffffea 	b	113f5bc <der_decode_raw_bit_string+0xc4>
   LTC_ARGCHK(in     != NULL);
 113f618:	52800200 	mov	w0, #0x10                  	// #16
}
 113f61c:	d65f03c0 	ret
   LTC_ARGCHK(in     != NULL);
 113f620:	52800200 	mov	w0, #0x10                  	// #16
 113f624:	17ffffc7 	b	113f540 <der_decode_raw_bit_string+0x48>

000000000113f628 <der_decode_boolean>:
  @return CRYPT_OK if successful
*/
int der_decode_boolean(const unsigned char *in, unsigned long inlen,
                                       int *out)
{
   LTC_ARGCHK(in  != NULL);
 113f628:	b4000280 	cbz	x0, 113f678 <der_decode_boolean+0x50>
   LTC_ARGCHK(out != NULL);
 113f62c:	b4000262 	cbz	x2, 113f678 <der_decode_boolean+0x50>

   if (inlen < 3 || in[0] != 0x01 || in[1] != 0x01 || (in[2] != 0x00 && in[2] != 0xFF)) {
 113f630:	f100083f 	cmp	x1, #0x2
 113f634:	54000229 	b.ls	113f678 <der_decode_boolean+0x50>  // b.plast
 113f638:	39400001 	ldrb	w1, [x0]
 113f63c:	7100043f 	cmp	w1, #0x1
 113f640:	540001c1 	b.ne	113f678 <der_decode_boolean+0x50>  // b.any
 113f644:	39400401 	ldrb	w1, [x0, #1]
 113f648:	7100043f 	cmp	w1, #0x1
 113f64c:	54000161 	b.ne	113f678 <der_decode_boolean+0x50>  // b.any
 113f650:	39400801 	ldrb	w1, [x0, #2]
 113f654:	51000420 	sub	w0, w1, #0x1
 113f658:	12001c00 	and	w0, w0, #0xff
 113f65c:	7103f41f 	cmp	w0, #0xfd
 113f660:	540000c9 	b.ls	113f678 <der_decode_boolean+0x50>  // b.plast
      return CRYPT_INVALID_ARG;
   }

   *out = (in[2]==0xFF) ? 1 : 0;
 113f664:	7103fc3f 	cmp	w1, #0xff
 113f668:	1a9f17e0 	cset	w0, eq  // eq = none
 113f66c:	b9000040 	str	w0, [x2]

   return CRYPT_OK;
 113f670:	52800000 	mov	w0, #0x0                   	// #0
}
 113f674:	d65f03c0 	ret
   LTC_ARGCHK(in  != NULL);
 113f678:	52800200 	mov	w0, #0x10                  	// #16
 113f67c:	17fffffe 	b	113f674 <der_decode_boolean+0x4c>

000000000113f680 <der_decode_choice>:
                            ltc_asn1_list *list, unsigned long  outlen)
{
   unsigned long size, x, z;
   void          *data;

   LTC_ARGCHK(in    != NULL);
 113f680:	b4001b40 	cbz	x0, 113f9e8 <der_decode_choice+0x368>
{
 113f684:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
 113f688:	910003fd 	mov	x29, sp
 113f68c:	a90153f3 	stp	x19, x20, [sp, #16]
 113f690:	a9025bf5 	stp	x21, x22, [sp, #32]
 113f694:	a90363f7 	stp	x23, x24, [sp, #48]
 113f698:	aa0103f8 	mov	x24, x1
 113f69c:	a9046bf9 	stp	x25, x26, [sp, #64]
 113f6a0:	f9002bfb 	str	x27, [sp, #80]
   LTC_ARGCHK(inlen != NULL);
 113f6a4:	b4001a61 	cbz	x1, 113f9f0 <der_decode_choice+0x370>
 113f6a8:	aa0203f3 	mov	x19, x2
   LTC_ARGCHK(list  != NULL);
 113f6ac:	b4001a22 	cbz	x2, 113f9f0 <der_decode_choice+0x370>
 113f6b0:	aa0003f9 	mov	x25, x0

   /* get blk size */
   if (*inlen < 2) {
 113f6b4:	f9400020 	ldr	x0, [x1]
 113f6b8:	f100041f 	cmp	x0, #0x1
 113f6bc:	54000408 	b.hi	113f73c <der_decode_choice+0xbc>  // b.pmore
      return CRYPT_INVALID_PACKET;
 113f6c0:	528000e0 	mov	w0, #0x7                   	// #7
               return CRYPT_INVALID_ARG;
       }
   }

   return CRYPT_INVALID_PACKET;
}
 113f6c4:	a94153f3 	ldp	x19, x20, [sp, #16]
 113f6c8:	a9425bf5 	ldp	x21, x22, [sp, #32]
 113f6cc:	a94363f7 	ldp	x23, x24, [sp, #48]
 113f6d0:	a9446bf9 	ldp	x25, x26, [sp, #64]
 113f6d4:	f9402bfb 	ldr	x27, [sp, #80]
 113f6d8:	a8c77bfd 	ldp	x29, x30, [sp], #112
 113f6dc:	d65f03c0 	ret
       list[x].used = 0;
 113f6e0:	9b017c82 	mul	x2, x4, x1
   for (x = 0; x < outlen; x++) {
 113f6e4:	91000484 	add	x4, x4, #0x1
       list[x].used = 0;
 113f6e8:	b822681f 	str	wzr, [x0, x2]
   for (x = 0; x < outlen; x++) {
 113f6ec:	eb03009f 	cmp	x4, x3
 113f6f0:	54ffff81 	b.ne	113f6e0 <der_decode_choice+0x60>  // b.any
 113f6f4:	b000009b 	adrp	x27, 1150000 <Te4+0x258>
 113f6f8:	aa1903fa 	mov	x26, x25
 113f6fc:	8b190097 	add	x23, x4, x25
 113f700:	9139c37b 	add	x27, x27, #0xe70
                  if (der_length_custom_type(&list[x], &z, NULL) == CRYPT_OK) {
 113f704:	9101a3f5 	add	x21, sp, #0x68
               if (der_decode_utf8_string(in, *inlen, data, &size) == CRYPT_OK) {
 113f708:	910183f6 	add	x22, sp, #0x60
   for (x = 0; x < outlen; x++) {
 113f70c:	eb1a02ff 	cmp	x23, x26
 113f710:	54fffd80 	b.eq	113f6c0 <der_decode_choice+0x40>  // b.none
       size = list[x].size;
 113f714:	b9400260 	ldr	w0, [x19]
 113f718:	a9408e74 	ldp	x20, x3, [x19, #8]
 113f71c:	f90033e3 	str	x3, [sp, #96]
       switch (list[x].type) {
 113f720:	51000400 	sub	w0, w0, #0x1
 113f724:	7100481f 	cmp	w0, #0x12
 113f728:	54001648 	b.hi	113f9f0 <der_decode_choice+0x370>  // b.pmore
 113f72c:	78605b60 	ldrh	w0, [x27, w0, uxtw #1]
 113f730:	10000061 	adr	x1, 113f73c <der_decode_choice+0xbc>
 113f734:	8b20a820 	add	x0, x1, w0, sxth #2
 113f738:	d61f0000 	br	x0
       list[x].used = 0;
 113f73c:	91006040 	add	x0, x2, #0x18
   for (x = 0; x < outlen; x++) {
 113f740:	d2800004 	mov	x4, #0x0                   	// #0
       list[x].used = 0;
 113f744:	d2800a01 	mov	x1, #0x50                  	// #80
 113f748:	17ffffe9 	b	113f6ec <der_decode_choice+0x6c>
               if (der_decode_boolean(in, *inlen, data) == CRYPT_OK) {
 113f74c:	f9400301 	ldr	x1, [x24]
 113f750:	aa1403e2 	mov	x2, x20
 113f754:	aa1903e0 	mov	x0, x25
 113f758:	97ffffb4 	bl	113f628 <der_decode_boolean>
 113f75c:	35001400 	cbnz	w0, 113f9dc <der_decode_choice+0x35c>
                  if (der_length_boolean(&z) == CRYPT_OK) {
 113f760:	aa1503e0 	mov	x0, x21
 113f764:	97fff2e1 	bl	113c2e8 <der_length_boolean>
                  if (der_length_custom_type(&list[x], &z, NULL) == CRYPT_OK) {
 113f768:	350013a0 	cbnz	w0, 113f9dc <der_decode_choice+0x35c>
                     list[x].used = 1;
 113f76c:	52800021 	mov	w1, #0x1                   	// #1
 113f770:	b9001a61 	str	w1, [x19, #24]
 113f774:	14000021 	b	113f7f8 <der_decode_choice+0x178>
               if (der_decode_integer(in, *inlen, data) == CRYPT_OK) {
 113f778:	f9400301 	ldr	x1, [x24]
 113f77c:	aa1403e2 	mov	x2, x20
 113f780:	aa1903e0 	mov	x0, x25
 113f784:	97fff9c2 	bl	113de8c <der_decode_integer>
 113f788:	350012a0 	cbnz	w0, 113f9dc <der_decode_choice+0x35c>
                  if (der_length_integer(data, &z) == CRYPT_OK) {
 113f78c:	aa1503e1 	mov	x1, x21
 113f790:	aa1403e0 	mov	x0, x20
 113f794:	97fffabb 	bl	113e280 <der_length_integer>
 113f798:	17fffff4 	b	113f768 <der_decode_choice+0xe8>
               if (der_decode_short_integer(in, *inlen, data) == CRYPT_OK) {
 113f79c:	f9400301 	ldr	x1, [x24]
 113f7a0:	aa1403e2 	mov	x2, x20
 113f7a4:	aa1903e0 	mov	x0, x25
 113f7a8:	97fffd50 	bl	113ece8 <der_decode_short_integer>
 113f7ac:	35001180 	cbnz	w0, 113f9dc <der_decode_choice+0x35c>
                  if (der_length_short_integer(size, &z) == CRYPT_OK) {
 113f7b0:	f94033e0 	ldr	x0, [sp, #96]
 113f7b4:	aa1503e1 	mov	x1, x21
 113f7b8:	97ffeab6 	bl	113a290 <der_length_short_integer>
 113f7bc:	17ffffeb 	b	113f768 <der_decode_choice+0xe8>
               if (der_decode_bit_string(in, *inlen, data, &size) == CRYPT_OK) {
 113f7c0:	f9400301 	ldr	x1, [x24]
 113f7c4:	aa1603e3 	mov	x3, x22
 113f7c8:	aa1403e2 	mov	x2, x20
 113f7cc:	aa1903e0 	mov	x0, x25
 113f7d0:	97ffff06 	bl	113f3e8 <der_decode_bit_string>
               if (der_decode_raw_bit_string(in, *inlen, data, &size) == CRYPT_OK) {
 113f7d4:	35001040 	cbnz	w0, 113f9dc <der_decode_choice+0x35c>
                  if (der_length_bit_string(size, &z) == CRYPT_OK) {
 113f7d8:	f94033e0 	ldr	x0, [sp, #96]
 113f7dc:	aa1503e1 	mov	x1, x21
 113f7e0:	97fff249 	bl	113c104 <der_length_bit_string>
                  if (der_length_utf8_string(data, size, &z) == CRYPT_OK) {
 113f7e4:	35000fc0 	cbnz	w0, 113f9dc <der_decode_choice+0x35c>
                     list[x].used = 1;
 113f7e8:	52800021 	mov	w1, #0x1                   	// #1
 113f7ec:	b9001a61 	str	w1, [x19, #24]
                     list[x].size = size;
 113f7f0:	f94033e1 	ldr	x1, [sp, #96]
 113f7f4:	f9000a61 	str	x1, [x19, #16]
                     *inlen       = z;
 113f7f8:	f94037e1 	ldr	x1, [sp, #104]
 113f7fc:	f9000301 	str	x1, [x24]
                     return CRYPT_OK;
 113f800:	17ffffb1 	b	113f6c4 <der_decode_choice+0x44>
               if (der_decode_raw_bit_string(in, *inlen, data, &size) == CRYPT_OK) {
 113f804:	f9400301 	ldr	x1, [x24]
 113f808:	aa1603e3 	mov	x3, x22
 113f80c:	aa1403e2 	mov	x2, x20
 113f810:	aa1903e0 	mov	x0, x25
 113f814:	97ffff39 	bl	113f4f8 <der_decode_raw_bit_string>
 113f818:	17ffffef 	b	113f7d4 <der_decode_choice+0x154>
               if (der_decode_octet_string(in, *inlen, data, &size) == CRYPT_OK) {
 113f81c:	f9400301 	ldr	x1, [x24]
 113f820:	aa1603e3 	mov	x3, x22
 113f824:	aa1403e2 	mov	x2, x20
 113f828:	aa1903e0 	mov	x0, x25
 113f82c:	97fffbf4 	bl	113e7fc <der_decode_octet_string>
 113f830:	35000d60 	cbnz	w0, 113f9dc <der_decode_choice+0x35c>
                  if (der_length_octet_string(size, &z) == CRYPT_OK) {
 113f834:	f94033e0 	ldr	x0, [sp, #96]
 113f838:	aa1503e1 	mov	x1, x21
 113f83c:	97fffc5e 	bl	113e9b4 <der_length_octet_string>
 113f840:	17ffffe9 	b	113f7e4 <der_decode_choice+0x164>
               if (*inlen == 2 && in[x] == 0x05 && in[x+1] == 0x00) {
 113f844:	f9400300 	ldr	x0, [x24]
 113f848:	f100081f 	cmp	x0, #0x2
 113f84c:	54000c81 	b.ne	113f9dc <der_decode_choice+0x35c>  // b.any
 113f850:	39400340 	ldrb	w0, [x26]
 113f854:	7100141f 	cmp	w0, #0x5
 113f858:	54000c21 	b.ne	113f9dc <der_decode_choice+0x35c>  // b.any
 113f85c:	39400740 	ldrb	w0, [x26, #1]
 113f860:	35000be0 	cbnz	w0, 113f9dc <der_decode_choice+0x35c>
                  list[x].used   = 1;
 113f864:	52800020 	mov	w0, #0x1                   	// #1
 113f868:	b9001a60 	str	w0, [x19, #24]
                  return CRYPT_OK;
 113f86c:	52800000 	mov	w0, #0x0                   	// #0
 113f870:	17ffff95 	b	113f6c4 <der_decode_choice+0x44>
               if (der_decode_object_identifier(in, *inlen, data, &size) == CRYPT_OK) {
 113f874:	f9400301 	ldr	x1, [x24]
 113f878:	aa1603e3 	mov	x3, x22
 113f87c:	aa1403e2 	mov	x2, x20
 113f880:	aa1903e0 	mov	x0, x25
 113f884:	97fffacb 	bl	113e3b0 <der_decode_object_identifier>
 113f888:	35000aa0 	cbnz	w0, 113f9dc <der_decode_choice+0x35c>
                  if (der_length_object_identifier(data, size, &z) == CRYPT_OK) {
 113f88c:	f94033e1 	ldr	x1, [sp, #96]
 113f890:	aa1503e2 	mov	x2, x21
 113f894:	aa1403e0 	mov	x0, x20
 113f898:	97fffba1 	bl	113e71c <der_length_object_identifier>
 113f89c:	17ffffd2 	b	113f7e4 <der_decode_choice+0x164>
               if (der_decode_teletex_string(in, *inlen, data, &size) == CRYPT_OK) {
 113f8a0:	f9400301 	ldr	x1, [x24]
 113f8a4:	aa1603e3 	mov	x3, x22
 113f8a8:	aa1403e2 	mov	x2, x20
 113f8ac:	aa1903e0 	mov	x0, x25
 113f8b0:	97fffe29 	bl	113f154 <der_decode_teletex_string>
 113f8b4:	35000940 	cbnz	w0, 113f9dc <der_decode_choice+0x35c>
                  if (der_length_teletex_string(data, size, &z) == CRYPT_OK) {
 113f8b8:	f94033e1 	ldr	x1, [sp, #96]
 113f8bc:	aa1503e2 	mov	x2, x21
 113f8c0:	aa1403e0 	mov	x0, x20
 113f8c4:	97ffec32 	bl	113a98c <der_length_teletex_string>
 113f8c8:	17ffffc7 	b	113f7e4 <der_decode_choice+0x164>
               if (der_decode_ia5_string(in, *inlen, data, &size) == CRYPT_OK) {
 113f8cc:	f9400301 	ldr	x1, [x24]
 113f8d0:	aa1603e3 	mov	x3, x22
 113f8d4:	aa1403e2 	mov	x2, x20
 113f8d8:	aa1903e0 	mov	x0, x25
 113f8dc:	97fff8b1 	bl	113dba0 <der_decode_ia5_string>
 113f8e0:	350007e0 	cbnz	w0, 113f9dc <der_decode_choice+0x35c>
                  if (der_length_ia5_string(data, size, &z) == CRYPT_OK) {
 113f8e4:	f94033e1 	ldr	x1, [sp, #96]
 113f8e8:	aa1503e2 	mov	x2, x21
 113f8ec:	aa1403e0 	mov	x0, x20
 113f8f0:	97fff943 	bl	113ddfc <der_length_ia5_string>
 113f8f4:	17ffffbc 	b	113f7e4 <der_decode_choice+0x164>
               if (der_decode_printable_string(in, *inlen, data, &size) == CRYPT_OK) {
 113f8f8:	f9400301 	ldr	x1, [x24]
 113f8fc:	aa1603e3 	mov	x3, x22
 113f900:	aa1403e2 	mov	x2, x20
 113f904:	aa1903e0 	mov	x0, x25
 113f908:	97fffc3d 	bl	113e9fc <der_decode_printable_string>
 113f90c:	35000680 	cbnz	w0, 113f9dc <der_decode_choice+0x35c>
                  if (der_length_printable_string(data, size, &z) == CRYPT_OK) {
 113f910:	f94033e1 	ldr	x1, [sp, #96]
 113f914:	aa1503e2 	mov	x2, x21
 113f918:	aa1403e0 	mov	x0, x20
 113f91c:	97fffccf 	bl	113ec58 <der_length_printable_string>
 113f920:	17ffffb1 	b	113f7e4 <der_decode_choice+0x164>
               if (der_decode_utf8_string(in, *inlen, data, &size) == CRYPT_OK) {
 113f924:	f9400301 	ldr	x1, [x24]
 113f928:	aa1603e3 	mov	x3, x22
 113f92c:	aa1403e2 	mov	x2, x20
 113f930:	aa1903e0 	mov	x0, x25
 113f934:	97fffdaf 	bl	113eff0 <der_decode_utf8_string>
 113f938:	35000520 	cbnz	w0, 113f9dc <der_decode_choice+0x35c>
                  if (der_length_utf8_string(data, size, &z) == CRYPT_OK) {
 113f93c:	f94033e1 	ldr	x1, [sp, #96]
 113f940:	aa1503e2 	mov	x2, x21
 113f944:	aa1403e0 	mov	x0, x20
 113f948:	97ffebca 	bl	113a870 <der_length_utf8_string>
 113f94c:	17ffffa6 	b	113f7e4 <der_decode_choice+0x164>
               z = *inlen;
 113f950:	f9400300 	ldr	x0, [x24]
               if (der_decode_utctime(in, &z, data) == CRYPT_OK) {
 113f954:	aa1403e2 	mov	x2, x20
 113f958:	aa1503e1 	mov	x1, x21
               z = *inlen;
 113f95c:	f90037e0 	str	x0, [sp, #104]
               if (der_decode_utctime(in, &z, data) == CRYPT_OK) {
 113f960:	aa1903e0 	mov	x0, x25
 113f964:	97fffd03 	bl	113ed70 <der_decode_utctime>
 113f968:	17ffff80 	b	113f768 <der_decode_choice+0xe8>
               z = *inlen;
 113f96c:	f9400300 	ldr	x0, [x24]
               if (der_decode_generalizedtime(in, &z, data) == CRYPT_OK) {
 113f970:	aa1403e2 	mov	x2, x20
 113f974:	aa1503e1 	mov	x1, x21
               z = *inlen;
 113f978:	f90037e0 	str	x0, [sp, #104]
               if (der_decode_generalizedtime(in, &z, data) == CRYPT_OK) {
 113f97c:	aa1903e0 	mov	x0, x25
 113f980:	97fff7b7 	bl	113d85c <der_decode_generalizedtime>
 113f984:	17ffff79 	b	113f768 <der_decode_choice+0xe8>
               if (der_decode_sequence(in, *inlen, data, size) == CRYPT_OK) {
 113f988:	f9400301 	ldr	x1, [x24]
 113f98c:	aa1403e2 	mov	x2, x20
 113f990:	aa1903e0 	mov	x0, x25
 113f994:	52800024 	mov	w4, #0x1                   	// #1
 113f998:	97ffe69c 	bl	1139408 <der_decode_sequence_ex>
 113f99c:	35000200 	cbnz	w0, 113f9dc <der_decode_choice+0x35c>
                  if (der_length_sequence(data, size, &z) == CRYPT_OK) {
 113f9a0:	f94033e1 	ldr	x1, [sp, #96]
 113f9a4:	aa1503e2 	mov	x2, x21
 113f9a8:	aa1403e0 	mov	x0, x20
 113f9ac:	97ffe915 	bl	1139e00 <der_length_sequence>
 113f9b0:	17ffff6e 	b	113f768 <der_decode_choice+0xe8>
               if (der_decode_custom_type(in, *inlen, &list[x]) == CRYPT_OK) {
 113f9b4:	f9400301 	ldr	x1, [x24]
 113f9b8:	aa1303e2 	mov	x2, x19
 113f9bc:	aa1903e0 	mov	x0, x25
 113f9c0:	97fff411 	bl	113ca04 <der_decode_custom_type>
 113f9c4:	350000c0 	cbnz	w0, 113f9dc <der_decode_choice+0x35c>
                  if (der_length_custom_type(&list[x], &z, NULL) == CRYPT_OK) {
 113f9c8:	aa1503e1 	mov	x1, x21
 113f9cc:	aa1303e0 	mov	x0, x19
 113f9d0:	d2800002 	mov	x2, #0x0                   	// #0
 113f9d4:	97fff4e1 	bl	113cd58 <der_length_custom_type>
 113f9d8:	17ffff64 	b	113f768 <der_decode_choice+0xe8>
   for (x = 0; x < outlen; x++) {
 113f9dc:	91014273 	add	x19, x19, #0x50
 113f9e0:	9100075a 	add	x26, x26, #0x1
 113f9e4:	17ffff4a 	b	113f70c <der_decode_choice+0x8c>
   LTC_ARGCHK(in    != NULL);
 113f9e8:	52800200 	mov	w0, #0x10                  	// #16
}
 113f9ec:	d65f03c0 	ret
       switch (list[x].type) {
 113f9f0:	52800200 	mov	w0, #0x10                  	// #16
 113f9f4:	17ffff34 	b	113f6c4 <der_decode_choice+0x44>

000000000113f9f8 <mpi_get_digit>:

/*
 * Convert an ASCII character to digit value
 */
static int mpi_get_digit( mbedtls_mpi_uint *d, int radix, char c )
{
 113f9f8:	12001c42 	and	w2, w2, #0xff
    *d = 255;

    if( c >= 0x30 && c <= 0x39 ) *d = c - 0x30;
 113f9fc:	5100c043 	sub	w3, w2, #0x30
 113fa00:	12001c64 	and	w4, w3, #0xff
 113fa04:	7100249f 	cmp	w4, #0x9
 113fa08:	54000108 	b.hi	113fa28 <mpi_get_digit+0x30>  // b.pmore
 113fa0c:	93407c63 	sxtw	x3, w3
 113fa10:	f9000003 	str	x3, [x0]
    if( c >= 0x41 && c <= 0x46 ) *d = c - 0x37;
    if( c >= 0x61 && c <= 0x66 ) *d = c - 0x57;

    if( *d >= (mbedtls_mpi_uint) radix )
 113fa14:	f9400000 	ldr	x0, [x0]
        return( MBEDTLS_ERR_MPI_INVALID_CHARACTER );
 113fa18:	eb21c01f 	cmp	x0, w1, sxtw

    return( 0 );
}
 113fa1c:	128000a0 	mov	w0, #0xfffffffa            	// #-6
 113fa20:	1a9f2000 	csel	w0, w0, wzr, cs  // cs = hs, nlast
 113fa24:	d65f03c0 	ret
    if( c >= 0x41 && c <= 0x46 ) *d = c - 0x37;
 113fa28:	51010443 	sub	w3, w2, #0x41
 113fa2c:	12001c63 	and	w3, w3, #0xff
 113fa30:	7100147f 	cmp	w3, #0x5
 113fa34:	540000a8 	b.hi	113fa48 <mpi_get_digit+0x50>  // b.pmore
 113fa38:	5100dc42 	sub	w2, w2, #0x37
 113fa3c:	93407c42 	sxtw	x2, w2
    if( c >= 0x61 && c <= 0x66 ) *d = c - 0x57;
 113fa40:	f9000002 	str	x2, [x0]
 113fa44:	17fffff4 	b	113fa14 <mpi_get_digit+0x1c>
 113fa48:	51018443 	sub	w3, w2, #0x61
 113fa4c:	51015c42 	sub	w2, w2, #0x57
 113fa50:	12001c63 	and	w3, w3, #0xff
 113fa54:	7100187f 	cmp	w3, #0x6
 113fa58:	93407c42 	sxtw	x2, w2
 113fa5c:	d2801fe3 	mov	x3, #0xff                  	// #255
 113fa60:	9a833042 	csel	x2, x2, x3, cc  // cc = lo, ul, last
 113fa64:	17fffff7 	b	113fa40 <mpi_get_digit+0x48>

000000000113fa68 <mpi_sub_hlp>:
static void mpi_sub_hlp( size_t n, mbedtls_mpi_uint *s, mbedtls_mpi_uint *d )
{
    size_t i;
    mbedtls_mpi_uint c, z;

    for( i = c = 0; i < n; i++, s++, d++ )
 113fa68:	d2800005 	mov	x5, #0x0                   	// #0
 113fa6c:	d2800003 	mov	x3, #0x0                   	// #0
 113fa70:	eb00007f 	cmp	x3, x0
 113fa74:	54000081 	b.ne	113fa84 <mpi_sub_hlp+0x1c>  // b.any
 113fa78:	8b030c43 	add	x3, x2, x3, lsl #3
    {
        z = ( *d <  c );     *d -=  c;
        c = ( *d < *s ) + z; *d -= *s;
    }

    while( c != 0 )
 113fa7c:	b50001c5 	cbnz	x5, 113fab4 <mpi_sub_hlp+0x4c>
    {
        z = ( *d < c ); *d -= c;
        c = z; d++;
    }
}
 113fa80:	d65f03c0 	ret
        z = ( *d <  c );     *d -=  c;
 113fa84:	f8637844 	ldr	x4, [x2, x3, lsl #3]
 113fa88:	eb05009f 	cmp	x4, x5
 113fa8c:	cb050084 	sub	x4, x4, x5
 113fa90:	f8237844 	str	x4, [x2, x3, lsl #3]
 113fa94:	9a9f27e7 	cset	x7, cc  // cc = lo, ul, last
        c = ( *d < *s ) + z; *d -= *s;
 113fa98:	f8637826 	ldr	x6, [x1, x3, lsl #3]
 113fa9c:	eb06009f 	cmp	x4, x6
 113faa0:	cb060084 	sub	x4, x4, x6
 113faa4:	9a8724e5 	cinc	x5, x7, cc  // cc = lo, ul, last
 113faa8:	f8237844 	str	x4, [x2, x3, lsl #3]
    for( i = c = 0; i < n; i++, s++, d++ )
 113faac:	91000463 	add	x3, x3, #0x1
 113fab0:	17fffff0 	b	113fa70 <mpi_sub_hlp+0x8>
        z = ( *d < c ); *d -= c;
 113fab4:	f9400060 	ldr	x0, [x3]
 113fab8:	eb050005 	subs	x5, x0, x5
 113fabc:	f8008465 	str	x5, [x3], #8
        c = z; d++;
 113fac0:	9a9f27e5 	cset	x5, cc  // cc = lo, ul, last
 113fac4:	17ffffee 	b	113fa7c <mpi_sub_hlp+0x14>

000000000113fac8 <mpi_mul_hlp>:
        MULADDC_INIT
        MULADDC_CORE
        MULADDC_STOP
    }
#else /* MULADDC_HUIT */
    for( ; i >= 16; i -= 16 )
 113fac8:	aa0203e4 	mov	x4, x2
 113facc:	aa0103e6 	mov	x6, x1
 113fad0:	aa0003e8 	mov	x8, x0
    mbedtls_mpi_uint c = 0, t = 0;
 113fad4:	d2800005 	mov	x5, #0x0                   	// #0
    for( ; i >= 16; i -= 16 )
 113fad8:	f1003d1f 	cmp	x8, #0xf
 113fadc:	f940008a 	ldr	x10, [x4]
 113fae0:	54000bc8 	b.hi	113fc58 <mpi_mul_hlp+0x190>  // b.pmore
 113fae4:	d344fc04 	lsr	x4, x0, #4
 113fae8:	928001e6 	mov	x6, #0xfffffffffffffff0    	// #-16
 113faec:	d379e088 	lsl	x8, x4, #7
 113faf0:	9b060080 	madd	x0, x4, x6, x0
 113faf4:	8b041c26 	add	x6, x1, x4, lsl #7
 113faf8:	8b041c44 	add	x4, x2, x4, lsl #7
        MULADDC_CORE   MULADDC_CORE
        MULADDC_CORE   MULADDC_CORE
        MULADDC_STOP
    }

    for( ; i >= 8; i -= 8 )
 113fafc:	f1001c1f 	cmp	x0, #0x7
 113fb00:	54000969 	b.ls	113fc2c <mpi_mul_hlp+0x164>  // b.plast
    {
        MULADDC_INIT
        MULADDC_CORE   MULADDC_CORE
 113fb04:	f8686821 	ldr	x1, [x1, x8]
    for( ; i >= 8; i -= 8 )
 113fb08:	d1002000 	sub	x0, x0, #0x8
        MULADDC_CORE   MULADDC_CORE

        MULADDC_CORE   MULADDC_CORE
        MULADDC_CORE   MULADDC_CORE
 113fb0c:	910100c6 	add	x6, x6, #0x40
 113fb10:	91010084 	add	x4, x4, #0x40
        MULADDC_CORE   MULADDC_CORE
 113fb14:	9b017c67 	mul	x7, x3, x1
 113fb18:	9bc17c61 	umulh	x1, x3, x1
 113fb1c:	ab0700a5 	adds	x5, x5, x7
 113fb20:	9a813421 	cinc	x1, x1, cs  // cs = hs, nlast
 113fb24:	ab050145 	adds	x5, x10, x5
 113fb28:	f8286845 	str	x5, [x2, x8]
 113fb2c:	9a813421 	cinc	x1, x1, cs  // cs = hs, nlast
 113fb30:	f85c80c2 	ldur	x2, [x6, #-56]
 113fb34:	9b027c65 	mul	x5, x3, x2
 113fb38:	9bc27c62 	umulh	x2, x3, x2
 113fb3c:	ab050021 	adds	x1, x1, x5
 113fb40:	f85c8085 	ldur	x5, [x4, #-56]
 113fb44:	9a823442 	cinc	x2, x2, cs  // cs = hs, nlast
 113fb48:	ab050021 	adds	x1, x1, x5
 113fb4c:	f81c8081 	stur	x1, [x4, #-56]
 113fb50:	9a823442 	cinc	x2, x2, cs  // cs = hs, nlast
        MULADDC_CORE   MULADDC_CORE
 113fb54:	f85d00c1 	ldur	x1, [x6, #-48]
 113fb58:	9b017c65 	mul	x5, x3, x1
 113fb5c:	9bc17c61 	umulh	x1, x3, x1
 113fb60:	ab050042 	adds	x2, x2, x5
 113fb64:	f85d0085 	ldur	x5, [x4, #-48]
 113fb68:	9a813421 	cinc	x1, x1, cs  // cs = hs, nlast
 113fb6c:	ab050042 	adds	x2, x2, x5
 113fb70:	f81d0082 	stur	x2, [x4, #-48]
 113fb74:	9a813421 	cinc	x1, x1, cs  // cs = hs, nlast
 113fb78:	f85d80c2 	ldur	x2, [x6, #-40]
 113fb7c:	9b027c65 	mul	x5, x3, x2
 113fb80:	9bc27c62 	umulh	x2, x3, x2
 113fb84:	ab050021 	adds	x1, x1, x5
 113fb88:	f85d8085 	ldur	x5, [x4, #-40]
 113fb8c:	9a823442 	cinc	x2, x2, cs  // cs = hs, nlast
 113fb90:	ab050021 	adds	x1, x1, x5
 113fb94:	f81d8081 	stur	x1, [x4, #-40]
 113fb98:	9a823442 	cinc	x2, x2, cs  // cs = hs, nlast
        MULADDC_CORE   MULADDC_CORE
 113fb9c:	f85e00c1 	ldur	x1, [x6, #-32]
 113fba0:	9b017c65 	mul	x5, x3, x1
 113fba4:	9bc17c61 	umulh	x1, x3, x1
 113fba8:	ab050042 	adds	x2, x2, x5
 113fbac:	f85e0085 	ldur	x5, [x4, #-32]
 113fbb0:	9a813421 	cinc	x1, x1, cs  // cs = hs, nlast
 113fbb4:	ab050042 	adds	x2, x2, x5
 113fbb8:	f81e0082 	stur	x2, [x4, #-32]
 113fbbc:	9a813421 	cinc	x1, x1, cs  // cs = hs, nlast
 113fbc0:	f85e80c2 	ldur	x2, [x6, #-24]
 113fbc4:	9b027c65 	mul	x5, x3, x2
 113fbc8:	9bc27c62 	umulh	x2, x3, x2
 113fbcc:	ab050021 	adds	x1, x1, x5
 113fbd0:	f85e8085 	ldur	x5, [x4, #-24]
 113fbd4:	9a823442 	cinc	x2, x2, cs  // cs = hs, nlast
 113fbd8:	ab050021 	adds	x1, x1, x5
 113fbdc:	f81e8081 	stur	x1, [x4, #-24]
 113fbe0:	9a823442 	cinc	x2, x2, cs  // cs = hs, nlast
        MULADDC_CORE   MULADDC_CORE
 113fbe4:	f85f00c1 	ldur	x1, [x6, #-16]
 113fbe8:	9b017c65 	mul	x5, x3, x1
 113fbec:	9bc17c61 	umulh	x1, x3, x1
 113fbf0:	ab050042 	adds	x2, x2, x5
 113fbf4:	f85f0085 	ldur	x5, [x4, #-16]
 113fbf8:	9a813421 	cinc	x1, x1, cs  // cs = hs, nlast
 113fbfc:	ab050042 	adds	x2, x2, x5
 113fc00:	f81f0082 	stur	x2, [x4, #-16]
 113fc04:	9a813421 	cinc	x1, x1, cs  // cs = hs, nlast
 113fc08:	f85f80c5 	ldur	x5, [x6, #-8]
 113fc0c:	9b057c62 	mul	x2, x3, x5
 113fc10:	9bc57c65 	umulh	x5, x3, x5
 113fc14:	ab020021 	adds	x1, x1, x2
 113fc18:	f85f8082 	ldur	x2, [x4, #-8]
 113fc1c:	9a8534a5 	cinc	x5, x5, cs  // cs = hs, nlast
 113fc20:	ab020021 	adds	x1, x1, x2
 113fc24:	f81f8081 	stur	x1, [x4, #-8]
 113fc28:	9a8534a5 	cinc	x5, x5, cs  // cs = hs, nlast
 113fc2c:	d2800001 	mov	x1, #0x0                   	// #0
        MULADDC_STOP
    }

    for( ; i > 0; i-- )
 113fc30:	eb00003f 	cmp	x1, x0
 113fc34:	f8617887 	ldr	x7, [x4, x1, lsl #3]
 113fc38:	54001361 	b.ne	113fea4 <mpi_mul_hlp+0x3dc>  // b.any
 113fc3c:	8b010c84 	add	x4, x4, x1, lsl #3
#endif /* MULADDC_HUIT */

    t++;

    do {
        *d += c; c = ( *d < c ); d++;
 113fc40:	f9400080 	ldr	x0, [x4]
 113fc44:	ab050005 	adds	x5, x0, x5
 113fc48:	f8008485 	str	x5, [x4], #8
 113fc4c:	d2800025 	mov	x5, #0x1                   	// #1
    }
    while( c != 0 );
 113fc50:	54ffff82 	b.cs	113fc40 <mpi_mul_hlp+0x178>  // b.hs, b.nlast
}
 113fc54:	d65f03c0 	ret
        MULADDC_CORE   MULADDC_CORE
 113fc58:	f94000c7 	ldr	x7, [x6]
 113fc5c:	910200c6 	add	x6, x6, #0x80
 113fc60:	91020084 	add	x4, x4, #0x80
    for( ; i >= 16; i -= 16 )
 113fc64:	d1004108 	sub	x8, x8, #0x10
        MULADDC_CORE   MULADDC_CORE
 113fc68:	9b077c69 	mul	x9, x3, x7
 113fc6c:	9bc77c67 	umulh	x7, x3, x7
 113fc70:	ab0900a5 	adds	x5, x5, x9
 113fc74:	9a8734e7 	cinc	x7, x7, cs  // cs = hs, nlast
 113fc78:	ab0a00a5 	adds	x5, x5, x10
 113fc7c:	f8180085 	stur	x5, [x4, #-128]
 113fc80:	9a8734e7 	cinc	x7, x7, cs  // cs = hs, nlast
 113fc84:	f85880c5 	ldur	x5, [x6, #-120]
 113fc88:	9b057c69 	mul	x9, x3, x5
 113fc8c:	9bc57c65 	umulh	x5, x3, x5
 113fc90:	ab0900e7 	adds	x7, x7, x9
 113fc94:	f8588089 	ldur	x9, [x4, #-120]
 113fc98:	9a8534a5 	cinc	x5, x5, cs  // cs = hs, nlast
 113fc9c:	ab070127 	adds	x7, x9, x7
 113fca0:	f8188087 	stur	x7, [x4, #-120]
 113fca4:	9a8534a5 	cinc	x5, x5, cs  // cs = hs, nlast
        MULADDC_CORE   MULADDC_CORE
 113fca8:	f85900c7 	ldur	x7, [x6, #-112]
 113fcac:	9b077c69 	mul	x9, x3, x7
 113fcb0:	9bc77c67 	umulh	x7, x3, x7
 113fcb4:	ab0900a5 	adds	x5, x5, x9
 113fcb8:	f8590089 	ldur	x9, [x4, #-112]
 113fcbc:	9a8734e7 	cinc	x7, x7, cs  // cs = hs, nlast
 113fcc0:	ab050125 	adds	x5, x9, x5
 113fcc4:	f8190085 	stur	x5, [x4, #-112]
 113fcc8:	9a8734e7 	cinc	x7, x7, cs  // cs = hs, nlast
 113fccc:	f85980c5 	ldur	x5, [x6, #-104]
 113fcd0:	9b057c69 	mul	x9, x3, x5
 113fcd4:	9bc57c65 	umulh	x5, x3, x5
 113fcd8:	ab0900e7 	adds	x7, x7, x9
 113fcdc:	f8598089 	ldur	x9, [x4, #-104]
 113fce0:	9a8534a5 	cinc	x5, x5, cs  // cs = hs, nlast
 113fce4:	ab070127 	adds	x7, x9, x7
 113fce8:	f8198087 	stur	x7, [x4, #-104]
 113fcec:	9a8534a5 	cinc	x5, x5, cs  // cs = hs, nlast
        MULADDC_CORE   MULADDC_CORE
 113fcf0:	f85a00c7 	ldur	x7, [x6, #-96]
 113fcf4:	9b077c69 	mul	x9, x3, x7
 113fcf8:	9bc77c67 	umulh	x7, x3, x7
 113fcfc:	ab0900a5 	adds	x5, x5, x9
 113fd00:	f85a0089 	ldur	x9, [x4, #-96]
 113fd04:	9a8734e7 	cinc	x7, x7, cs  // cs = hs, nlast
 113fd08:	ab050125 	adds	x5, x9, x5
 113fd0c:	f81a0085 	stur	x5, [x4, #-96]
 113fd10:	9a8734e7 	cinc	x7, x7, cs  // cs = hs, nlast
 113fd14:	f85a80c5 	ldur	x5, [x6, #-88]
 113fd18:	9b057c69 	mul	x9, x3, x5
 113fd1c:	9bc57c65 	umulh	x5, x3, x5
 113fd20:	ab0900e7 	adds	x7, x7, x9
 113fd24:	f85a8089 	ldur	x9, [x4, #-88]
 113fd28:	9a8534a5 	cinc	x5, x5, cs  // cs = hs, nlast
 113fd2c:	ab070127 	adds	x7, x9, x7
 113fd30:	f81a8087 	stur	x7, [x4, #-88]
 113fd34:	9a8534a5 	cinc	x5, x5, cs  // cs = hs, nlast
        MULADDC_CORE   MULADDC_CORE
 113fd38:	f85b00c7 	ldur	x7, [x6, #-80]
 113fd3c:	9b077c69 	mul	x9, x3, x7
 113fd40:	9bc77c67 	umulh	x7, x3, x7
 113fd44:	ab0900a5 	adds	x5, x5, x9
 113fd48:	f85b0089 	ldur	x9, [x4, #-80]
 113fd4c:	9a8734e7 	cinc	x7, x7, cs  // cs = hs, nlast
 113fd50:	ab050125 	adds	x5, x9, x5
 113fd54:	f81b0085 	stur	x5, [x4, #-80]
 113fd58:	9a8734e7 	cinc	x7, x7, cs  // cs = hs, nlast
 113fd5c:	f85b80c5 	ldur	x5, [x6, #-72]
 113fd60:	9b057c69 	mul	x9, x3, x5
 113fd64:	9bc57c65 	umulh	x5, x3, x5
 113fd68:	ab0900e7 	adds	x7, x7, x9
 113fd6c:	f85b8089 	ldur	x9, [x4, #-72]
 113fd70:	9a8534a5 	cinc	x5, x5, cs  // cs = hs, nlast
 113fd74:	ab070127 	adds	x7, x9, x7
 113fd78:	f81b8087 	stur	x7, [x4, #-72]
 113fd7c:	9a8534a5 	cinc	x5, x5, cs  // cs = hs, nlast
        MULADDC_CORE   MULADDC_CORE
 113fd80:	f85c00c7 	ldur	x7, [x6, #-64]
 113fd84:	9b077c69 	mul	x9, x3, x7
 113fd88:	9bc77c67 	umulh	x7, x3, x7
 113fd8c:	ab0900a5 	adds	x5, x5, x9
 113fd90:	f85c0089 	ldur	x9, [x4, #-64]
 113fd94:	9a8734e7 	cinc	x7, x7, cs  // cs = hs, nlast
 113fd98:	ab050125 	adds	x5, x9, x5
 113fd9c:	f81c0085 	stur	x5, [x4, #-64]
 113fda0:	9a8734e7 	cinc	x7, x7, cs  // cs = hs, nlast
 113fda4:	f85c80c5 	ldur	x5, [x6, #-56]
 113fda8:	9b057c69 	mul	x9, x3, x5
 113fdac:	9bc57c65 	umulh	x5, x3, x5
 113fdb0:	ab0900e7 	adds	x7, x7, x9
 113fdb4:	f85c8089 	ldur	x9, [x4, #-56]
 113fdb8:	9a8534a5 	cinc	x5, x5, cs  // cs = hs, nlast
 113fdbc:	ab070127 	adds	x7, x9, x7
 113fdc0:	f81c8087 	stur	x7, [x4, #-56]
 113fdc4:	9a8534a5 	cinc	x5, x5, cs  // cs = hs, nlast
        MULADDC_CORE   MULADDC_CORE
 113fdc8:	f85d00c7 	ldur	x7, [x6, #-48]
 113fdcc:	9b077c69 	mul	x9, x3, x7
 113fdd0:	9bc77c67 	umulh	x7, x3, x7
 113fdd4:	ab0900a5 	adds	x5, x5, x9
 113fdd8:	f85d0089 	ldur	x9, [x4, #-48]
 113fddc:	9a8734e7 	cinc	x7, x7, cs  // cs = hs, nlast
 113fde0:	ab050125 	adds	x5, x9, x5
 113fde4:	f81d0085 	stur	x5, [x4, #-48]
 113fde8:	9a8734e7 	cinc	x7, x7, cs  // cs = hs, nlast
 113fdec:	f85d80c5 	ldur	x5, [x6, #-40]
 113fdf0:	9b057c69 	mul	x9, x3, x5
 113fdf4:	9bc57c65 	umulh	x5, x3, x5
 113fdf8:	ab0900e7 	adds	x7, x7, x9
 113fdfc:	f85d8089 	ldur	x9, [x4, #-40]
 113fe00:	9a8534a5 	cinc	x5, x5, cs  // cs = hs, nlast
 113fe04:	ab070127 	adds	x7, x9, x7
 113fe08:	f81d8087 	stur	x7, [x4, #-40]
 113fe0c:	9a8534a5 	cinc	x5, x5, cs  // cs = hs, nlast
        MULADDC_CORE   MULADDC_CORE
 113fe10:	f85e00c7 	ldur	x7, [x6, #-32]
 113fe14:	9b077c69 	mul	x9, x3, x7
 113fe18:	9bc77c67 	umulh	x7, x3, x7
 113fe1c:	ab0900a5 	adds	x5, x5, x9
 113fe20:	f85e0089 	ldur	x9, [x4, #-32]
 113fe24:	9a8734e7 	cinc	x7, x7, cs  // cs = hs, nlast
 113fe28:	ab050125 	adds	x5, x9, x5
 113fe2c:	f81e0085 	stur	x5, [x4, #-32]
 113fe30:	9a8734e7 	cinc	x7, x7, cs  // cs = hs, nlast
 113fe34:	f85e80c5 	ldur	x5, [x6, #-24]
 113fe38:	9b057c69 	mul	x9, x3, x5
 113fe3c:	9bc57c65 	umulh	x5, x3, x5
 113fe40:	ab0900e7 	adds	x7, x7, x9
 113fe44:	f85e8089 	ldur	x9, [x4, #-24]
 113fe48:	9a8534a5 	cinc	x5, x5, cs  // cs = hs, nlast
 113fe4c:	ab070127 	adds	x7, x9, x7
 113fe50:	f81e8087 	stur	x7, [x4, #-24]
 113fe54:	9a8534a5 	cinc	x5, x5, cs  // cs = hs, nlast
        MULADDC_CORE   MULADDC_CORE
 113fe58:	f85f00c7 	ldur	x7, [x6, #-16]
 113fe5c:	9b077c69 	mul	x9, x3, x7
 113fe60:	9bc77c67 	umulh	x7, x3, x7
 113fe64:	ab0900a5 	adds	x5, x5, x9
 113fe68:	f85f0089 	ldur	x9, [x4, #-16]
 113fe6c:	9a8734e7 	cinc	x7, x7, cs  // cs = hs, nlast
 113fe70:	ab050125 	adds	x5, x9, x5
 113fe74:	f81f0085 	stur	x5, [x4, #-16]
 113fe78:	9a8734e7 	cinc	x7, x7, cs  // cs = hs, nlast
 113fe7c:	f85f80c5 	ldur	x5, [x6, #-8]
 113fe80:	9b057c69 	mul	x9, x3, x5
 113fe84:	9bc57c65 	umulh	x5, x3, x5
 113fe88:	ab0900e7 	adds	x7, x7, x9
 113fe8c:	f85f8089 	ldur	x9, [x4, #-8]
 113fe90:	9a8534a5 	cinc	x5, x5, cs  // cs = hs, nlast
 113fe94:	ab070127 	adds	x7, x9, x7
 113fe98:	f81f8087 	stur	x7, [x4, #-8]
 113fe9c:	9a8534a5 	cinc	x5, x5, cs  // cs = hs, nlast
    for( ; i >= 16; i -= 16 )
 113fea0:	17ffff0e 	b	113fad8 <mpi_mul_hlp+0x10>
        MULADDC_CORE
 113fea4:	f86178c2 	ldr	x2, [x6, x1, lsl #3]
 113fea8:	9b027c68 	mul	x8, x3, x2
 113feac:	9bc27c62 	umulh	x2, x3, x2
 113feb0:	ab0800a8 	adds	x8, x5, x8
 113feb4:	9a823445 	cinc	x5, x2, cs  // cs = hs, nlast
 113feb8:	ab0800e7 	adds	x7, x7, x8
 113febc:	9a8534a5 	cinc	x5, x5, cs  // cs = hs, nlast
 113fec0:	f8217887 	str	x7, [x4, x1, lsl #3]
    for( ; i > 0; i-- )
 113fec4:	91000421 	add	x1, x1, #0x1
 113fec8:	17ffff5a 	b	113fc30 <mpi_mul_hlp+0x168>

000000000113fecc <mbedtls_mpi_mod_int.part.0>:
    }

    /*
     * general case
     */
    for( i = A->n, y = 0; i > 0; i-- )
 113fecc:	f9400425 	ldr	x5, [x1, #8]
 113fed0:	d2800003 	mov	x3, #0x0                   	// #0
 113fed4:	d10004a5 	sub	x5, x5, #0x1
 113fed8:	b10004bf 	cmn	x5, #0x1
 113fedc:	54000101 	b.ne	113fefc <mbedtls_mpi_mod_int.part.0+0x30>  // b.any

    /*
     * If A is negative, then the current y represents a negative value.
     * Flipping it to the positive side.
     */
    if( A->s < 0 && y != 0 )
 113fee0:	79c00021 	ldrsh	w1, [x1]
 113fee4:	36f80061 	tbz	w1, #31, 113fef0 <mbedtls_mpi_mod_int.part.0+0x24>
 113fee8:	b4000043 	cbz	x3, 113fef0 <mbedtls_mpi_mod_int.part.0+0x24>
        y = b - y;
 113feec:	cb030043 	sub	x3, x2, x3

    *r = y;
 113fef0:	f9000003 	str	x3, [x0]

    return( 0 );
}
 113fef4:	52800000 	mov	w0, #0x0                   	// #0
 113fef8:	d65f03c0 	ret
        x  = A->p[i - 1];
 113fefc:	f9400824 	ldr	x4, [x1, #16]
 113ff00:	f8657886 	ldr	x6, [x4, x5, lsl #3]
        y  = ( y << biH ) | ( x >> biH );
 113ff04:	93c68063 	extr	x3, x3, x6, #32
        y  = ( y << biH ) | ( x >> biH );
 113ff08:	9ac20864 	udiv	x4, x3, x2
 113ff0c:	9b028c83 	msub	x3, x4, x2, x3
 113ff10:	92407cc4 	and	x4, x6, #0xffffffff
 113ff14:	aa038084 	orr	x4, x4, x3, lsl #32
 113ff18:	9ac20883 	udiv	x3, x4, x2
 113ff1c:	9b029063 	msub	x3, x3, x2, x4
    for( i = A->n, y = 0; i > 0; i-- )
 113ff20:	17ffffed 	b	113fed4 <mbedtls_mpi_mod_int.part.0+0x8>

000000000113ff24 <mpi_bigendian_to_host.part.0>:
static void mpi_bigendian_to_host( mbedtls_mpi_uint * const p, size_t limbs )
 113ff24:	d10043ff 	sub	sp, sp, #0x10
    for( cur_limb_left = p, cur_limb_right = p + ( limbs - 1 );
 113ff28:	8b010c01 	add	x1, x0, x1, lsl #3
 113ff2c:	d1002021 	sub	x1, x1, #0x8
        tmp |= (mbedtls_mpi_uint) *x_ptr;
 113ff30:	910023e5 	add	x5, sp, #0x8
    for( cur_limb_left = p, cur_limb_right = p + ( limbs - 1 );
 113ff34:	eb01001f 	cmp	x0, x1
 113ff38:	54000069 	b.ls	113ff44 <mpi_bigendian_to_host.part.0+0x20>  // b.plast
}
 113ff3c:	910043ff 	add	sp, sp, #0x10
 113ff40:	d65f03c0 	ret
    return( mpi_uint_bigendian_to_host_c( x ) );
 113ff44:	f9400002 	ldr	x2, [x0]
    mbedtls_mpi_uint tmp = 0;
 113ff48:	d2800003 	mov	x3, #0x0                   	// #0
 113ff4c:	f90007e2 	str	x2, [sp, #8]
        tmp             = mpi_uint_bigendian_to_host( *cur_limb_left  );
 113ff50:	d2800002 	mov	x2, #0x0                   	// #0
        tmp |= (mbedtls_mpi_uint) *x_ptr;
 113ff54:	38656844 	ldrb	w4, [x2, x5]
 113ff58:	91000442 	add	x2, x2, #0x1
    for( i = 0, x_ptr = (unsigned char*) &x; i < ciL; i++, x_ptr++ )
 113ff5c:	f100205f 	cmp	x2, #0x8
        tmp |= (mbedtls_mpi_uint) *x_ptr;
 113ff60:	aa032083 	orr	x3, x4, x3, lsl #8
    for( i = 0, x_ptr = (unsigned char*) &x; i < ciL; i++, x_ptr++ )
 113ff64:	54ffff81 	b.ne	113ff54 <mpi_bigendian_to_host.part.0+0x30>  // b.any
    return( mpi_uint_bigendian_to_host_c( x ) );
 113ff68:	f9400022 	ldr	x2, [x1]
    mbedtls_mpi_uint tmp = 0;
 113ff6c:	d2800004 	mov	x4, #0x0                   	// #0
 113ff70:	f90007e2 	str	x2, [sp, #8]
        *cur_limb_left  = mpi_uint_bigendian_to_host( *cur_limb_right );
 113ff74:	d2800002 	mov	x2, #0x0                   	// #0
        tmp |= (mbedtls_mpi_uint) *x_ptr;
 113ff78:	386268a6 	ldrb	w6, [x5, x2]
 113ff7c:	91000442 	add	x2, x2, #0x1
    for( i = 0, x_ptr = (unsigned char*) &x; i < ciL; i++, x_ptr++ )
 113ff80:	f100205f 	cmp	x2, #0x8
        tmp |= (mbedtls_mpi_uint) *x_ptr;
 113ff84:	aa0420c4 	orr	x4, x6, x4, lsl #8
    for( i = 0, x_ptr = (unsigned char*) &x; i < ciL; i++, x_ptr++ )
 113ff88:	54ffff81 	b.ne	113ff78 <mpi_bigendian_to_host.part.0+0x54>  // b.any
        *cur_limb_left  = mpi_uint_bigendian_to_host( *cur_limb_right );
 113ff8c:	f8008404 	str	x4, [x0], #8
        *cur_limb_right = tmp;
 113ff90:	f81f8423 	str	x3, [x1], #-8
         cur_limb_left++, cur_limb_right-- )
 113ff94:	17ffffe8 	b	113ff34 <mpi_bigendian_to_host.part.0+0x10>

000000000113ff98 <mbedtls_mpi_init>:
    X->s = 1;
 113ff98:	52800021 	mov	w1, #0x1                   	// #1
 113ff9c:	b9000001 	str	w1, [x0]
    X->p = NULL;
 113ffa0:	a900fc1f 	stp	xzr, xzr, [x0, #8]
}
 113ffa4:	d65f03c0 	ret

000000000113ffa8 <mbedtls_mpi_init_mempool>:
    mpi_init( X, !!mbedtls_mpi_mempool /*use_mempool*/ );
 113ffa8:	f00000c1 	adrp	x1, 115a000 <__scattered_array_1phys_mem_map+0x8>
    X->s = 1;
 113ffac:	52800022 	mov	w2, #0x1                   	// #1
    X->p = NULL;
 113ffb0:	a900fc1f 	stp	xzr, xzr, [x0, #8]
    mpi_init( X, !!mbedtls_mpi_mempool /*use_mempool*/ );
 113ffb4:	f9424c21 	ldr	x1, [x1, #1176]
 113ffb8:	f9400021 	ldr	x1, [x1]
    X->s = 1;
 113ffbc:	79000002 	strh	w2, [x0]
    mpi_init( X, !!mbedtls_mpi_mempool /*use_mempool*/ );
 113ffc0:	f100003f 	cmp	x1, #0x0
 113ffc4:	1a9f07e1 	cset	w1, ne  // ne = any
    X->use_mempool = use_mempool;
 113ffc8:	79000401 	strh	w1, [x0, #2]
}
 113ffcc:	d65f03c0 	ret

000000000113ffd0 <mbedtls_mpi_free>:
    if( X == NULL )
 113ffd0:	b4000340 	cbz	x0, 1140038 <mbedtls_mpi_free+0x68>
{
 113ffd4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 113ffd8:	910003fd 	mov	x29, sp
 113ffdc:	f9000bf3 	str	x19, [sp, #16]
 113ffe0:	aa0003f3 	mov	x19, x0
    if( X->p != NULL )
 113ffe4:	f9400800 	ldr	x0, [x0, #16]
 113ffe8:	b4000160 	cbz	x0, 1140014 <mbedtls_mpi_free+0x44>
    mbedtls_platform_zeroize( v, ciL * n );
 113ffec:	f9400661 	ldr	x1, [x19, #8]
 113fff0:	d37df021 	lsl	x1, x1, #3
 113fff4:	94000aaa 	bl	1142a9c <mbedtls_platform_zeroize>
        if( X->use_mempool )
 113fff8:	79c00660 	ldrsh	w0, [x19, #2]
 113fffc:	34000180 	cbz	w0, 114002c <mbedtls_mpi_free+0x5c>
            mempool_free( mbedtls_mpi_mempool, X->p );
 1140000:	d00000c0 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1140004:	f9400a61 	ldr	x1, [x19, #16]
 1140008:	f9424c00 	ldr	x0, [x0, #1176]
 114000c:	f9400000 	ldr	x0, [x0]
 1140010:	940013ce 	bl	1144f48 <mempool_free>
    X->s = 1;
 1140014:	52800020 	mov	w0, #0x1                   	// #1
 1140018:	79000260 	strh	w0, [x19]
    X->p = NULL;
 114001c:	a900fe7f 	stp	xzr, xzr, [x19, #8]
}
 1140020:	f9400bf3 	ldr	x19, [sp, #16]
 1140024:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1140028:	d65f03c0 	ret
            mbedtls_free( X->p );
 114002c:	f9400a60 	ldr	x0, [x19, #16]
 1140030:	94000d6c 	bl	11435e0 <free>
 1140034:	17fffff8 	b	1140014 <mbedtls_mpi_free+0x44>
 1140038:	d65f03c0 	ret

000000000114003c <mbedtls_mpi_grow>:
{
 114003c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1140040:	910003fd 	mov	x29, sp
 1140044:	a90153f3 	stp	x19, x20, [sp, #16]
 1140048:	aa0003f3 	mov	x19, x0
    if( nblimbs > MBEDTLS_MPI_MAX_LIMBS )
 114004c:	d284e200 	mov	x0, #0x2710                	// #10000
{
 1140050:	a9025bf5 	stp	x21, x22, [sp, #32]
    if( nblimbs > MBEDTLS_MPI_MAX_LIMBS )
 1140054:	eb00003f 	cmp	x1, x0
 1140058:	540000c9 	b.ls	1140070 <mbedtls_mpi_grow+0x34>  // b.plast
        return( MBEDTLS_ERR_MPI_ALLOC_FAILED );
 114005c:	128001e0 	mov	w0, #0xfffffff0            	// #-16
}
 1140060:	a94153f3 	ldp	x19, x20, [sp, #16]
 1140064:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1140068:	a8c37bfd 	ldp	x29, x30, [sp], #48
 114006c:	d65f03c0 	ret
    if( X->n < nblimbs )
 1140070:	f9400660 	ldr	x0, [x19, #8]
 1140074:	aa0103f5 	mov	x21, x1
 1140078:	eb01001f 	cmp	x0, x1
 114007c:	540003e2 	b.cs	11400f8 <mbedtls_mpi_grow+0xbc>  // b.hs, b.nlast
        if( X->use_mempool )
 1140080:	79c00660 	ldrsh	w0, [x19, #2]
 1140084:	340003e0 	cbz	w0, 1140100 <mbedtls_mpi_grow+0xc4>
            p = mempool_alloc( mbedtls_mpi_mempool, nblimbs * ciL );
 1140088:	d00000c0 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 114008c:	d37df036 	lsl	x22, x1, #3
 1140090:	aa1603e1 	mov	x1, x22
 1140094:	f9424c00 	ldr	x0, [x0, #1176]
 1140098:	f9400000 	ldr	x0, [x0]
 114009c:	94001379 	bl	1144e80 <mempool_alloc>
 11400a0:	aa0003f4 	mov	x20, x0
            if( p == NULL )
 11400a4:	b4fffdc0 	cbz	x0, 114005c <mbedtls_mpi_grow+0x20>
            memset( p, 0, nblimbs * ciL );
 11400a8:	aa1603e2 	mov	x2, x22
 11400ac:	52800001 	mov	w1, #0x0                   	// #0
 11400b0:	94000f0c 	bl	1143ce0 <memset>
        if( X->p != NULL )
 11400b4:	f9400a61 	ldr	x1, [x19, #16]
 11400b8:	b40001e1 	cbz	x1, 11400f4 <mbedtls_mpi_grow+0xb8>
            memcpy( p, X->p, X->n * ciL );
 11400bc:	f9400662 	ldr	x2, [x19, #8]
 11400c0:	aa1403e0 	mov	x0, x20
 11400c4:	d37df042 	lsl	x2, x2, #3
 11400c8:	97ff0cb2 	bl	1103390 <memcpy>
    mbedtls_platform_zeroize( v, ciL * n );
 11400cc:	a9408261 	ldp	x1, x0, [x19, #8]
 11400d0:	d37df021 	lsl	x1, x1, #3
 11400d4:	94000a72 	bl	1142a9c <mbedtls_platform_zeroize>
            if( X->use_mempool )
 11400d8:	79c00660 	ldrsh	w0, [x19, #2]
 11400dc:	340001e0 	cbz	w0, 1140118 <mbedtls_mpi_grow+0xdc>
                mempool_free( mbedtls_mpi_mempool, X->p);
 11400e0:	d00000c0 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 11400e4:	f9400a61 	ldr	x1, [x19, #16]
 11400e8:	f9424c00 	ldr	x0, [x0, #1176]
 11400ec:	f9400000 	ldr	x0, [x0]
 11400f0:	94001396 	bl	1144f48 <mempool_free>
        X->p = p;
 11400f4:	a900d275 	stp	x21, x20, [x19, #8]
    return( 0 );
 11400f8:	52800000 	mov	w0, #0x0                   	// #0
 11400fc:	17ffffd9 	b	1140060 <mbedtls_mpi_grow+0x24>
            p = (mbedtls_mpi_uint*)mbedtls_calloc( nblimbs, ciL );
 1140100:	aa1503e0 	mov	x0, x21
 1140104:	d2800101 	mov	x1, #0x8                   	// #8
 1140108:	94000cf2 	bl	11434d0 <calloc>
 114010c:	aa0003f4 	mov	x20, x0
            if( p == NULL )
 1140110:	b5fffd20 	cbnz	x0, 11400b4 <mbedtls_mpi_grow+0x78>
 1140114:	17ffffd2 	b	114005c <mbedtls_mpi_grow+0x20>
                mbedtls_free( X->p );
 1140118:	f9400a60 	ldr	x0, [x19, #16]
 114011c:	94000d31 	bl	11435e0 <free>
 1140120:	17fffff5 	b	11400f4 <mbedtls_mpi_grow+0xb8>

0000000001140124 <mbedtls_mpi_copy>:
    if( X == Y )
 1140124:	eb01001f 	cmp	x0, x1
 1140128:	54000540 	b.eq	11401d0 <mbedtls_mpi_copy+0xac>  // b.none
{
 114012c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1140130:	910003fd 	mov	x29, sp
 1140134:	a90153f3 	stp	x19, x20, [sp, #16]
    if( Y->n == 0 )
 1140138:	f9400433 	ldr	x19, [x1, #8]
{
 114013c:	f90013f5 	str	x21, [sp, #32]
 1140140:	aa0103f5 	mov	x21, x1
    if( Y->n == 0 )
 1140144:	b5000093 	cbnz	x19, 1140154 <mbedtls_mpi_copy+0x30>
        mbedtls_mpi_free( X );
 1140148:	97ffffa2 	bl	113ffd0 <mbedtls_mpi_free>
    memcpy( X->p, Y->p, i * ciL );
 114014c:	52800000 	mov	w0, #0x0                   	// #0
 1140150:	14000011 	b	1140194 <mbedtls_mpi_copy+0x70>
 1140154:	aa0003f4 	mov	x20, x0
    for( i = Y->n - 1; i > 0; i-- )
 1140158:	d1000673 	sub	x19, x19, #0x1
 114015c:	b4000093 	cbz	x19, 114016c <mbedtls_mpi_copy+0x48>
        if( Y->p[i] != 0 )
 1140160:	f9400aa0 	ldr	x0, [x21, #16]
 1140164:	f8737800 	ldr	x0, [x0, x19, lsl #3]
 1140168:	b4ffff80 	cbz	x0, 1140158 <mbedtls_mpi_copy+0x34>
    X->s = Y->s;
 114016c:	79c002a0 	ldrsh	w0, [x21]
    i++;
 1140170:	91000673 	add	x19, x19, #0x1
    if( X->n < i )
 1140174:	f9400682 	ldr	x2, [x20, #8]
    X->s = Y->s;
 1140178:	79000280 	strh	w0, [x20]
    if( X->n < i )
 114017c:	eb13005f 	cmp	x2, x19
 1140180:	54000122 	b.cs	11401a4 <mbedtls_mpi_copy+0x80>  // b.hs, b.nlast
        MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, i ) );
 1140184:	aa1303e1 	mov	x1, x19
 1140188:	aa1403e0 	mov	x0, x20
 114018c:	97ffffac 	bl	114003c <mbedtls_mpi_grow>
 1140190:	34000160 	cbz	w0, 11401bc <mbedtls_mpi_copy+0x98>
}
 1140194:	a94153f3 	ldp	x19, x20, [sp, #16]
 1140198:	f94013f5 	ldr	x21, [sp, #32]
 114019c:	a8c37bfd 	ldp	x29, x30, [sp], #48
 11401a0:	d65f03c0 	ret
        memset( X->p + i, 0, ( X->n - i ) * ciL );
 11401a4:	f9400a80 	ldr	x0, [x20, #16]
 11401a8:	cb130042 	sub	x2, x2, x19
 11401ac:	52800001 	mov	w1, #0x0                   	// #0
 11401b0:	d37df042 	lsl	x2, x2, #3
 11401b4:	8b130c00 	add	x0, x0, x19, lsl #3
 11401b8:	94000eca 	bl	1143ce0 <memset>
    memcpy( X->p, Y->p, i * ciL );
 11401bc:	f9400a80 	ldr	x0, [x20, #16]
 11401c0:	d37df262 	lsl	x2, x19, #3
 11401c4:	f9400aa1 	ldr	x1, [x21, #16]
 11401c8:	97ff0c72 	bl	1103390 <memcpy>
 11401cc:	17ffffe0 	b	114014c <mbedtls_mpi_copy+0x28>
        return( 0 );
 11401d0:	52800000 	mov	w0, #0x0                   	// #0
}
 11401d4:	d65f03c0 	ret

00000000011401d8 <mbedtls_mpi_lset>:
{
 11401d8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 11401dc:	910003fd 	mov	x29, sp
 11401e0:	a90153f3 	stp	x19, x20, [sp, #16]
 11401e4:	aa0003f3 	mov	x19, x0
 11401e8:	aa0103f4 	mov	x20, x1
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, 1 ) );
 11401ec:	d2800021 	mov	x1, #0x1                   	// #1
{
 11401f0:	f90013f5 	str	x21, [sp, #32]
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, 1 ) );
 11401f4:	97ffff92 	bl	114003c <mbedtls_mpi_grow>
 11401f8:	2a0003f5 	mov	w21, w0
 11401fc:	35000180 	cbnz	w0, 114022c <mbedtls_mpi_lset+0x54>
    memset( X->p, 0, X->n * ciL );
 1140200:	a9408262 	ldp	x2, x0, [x19, #8]
 1140204:	52800001 	mov	w1, #0x0                   	// #0
 1140208:	d37df042 	lsl	x2, x2, #3
 114020c:	94000eb5 	bl	1143ce0 <memset>
    X->p[0] = ( z < 0 ) ? -z : z;
 1140210:	f9400a60 	ldr	x0, [x19, #16]
 1140214:	f100029f 	cmp	x20, #0x0
 1140218:	da94a681 	cneg	x1, x20, lt  // lt = tstop
 114021c:	f9000001 	str	x1, [x0]
    X->s    = ( z < 0 ) ? -1 : 1;
 1140220:	52800020 	mov	w0, #0x1                   	// #1
 1140224:	5a80a400 	cneg	w0, w0, lt  // lt = tstop
 1140228:	79000260 	strh	w0, [x19]
}
 114022c:	2a1503e0 	mov	w0, w21
 1140230:	a94153f3 	ldp	x19, x20, [sp, #16]
 1140234:	f94013f5 	ldr	x21, [sp, #32]
 1140238:	a8c37bfd 	ldp	x29, x30, [sp], #48
 114023c:	d65f03c0 	ret

0000000001140240 <mbedtls_mpi_set_bit>:
{
 1140240:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1140244:	910003fd 	mov	x29, sp
 1140248:	a90153f3 	stp	x19, x20, [sp, #16]
 114024c:	12001c53 	and	w19, w2, #0xff
    if( val != 0 && val != 1 )
 1140250:	7100067f 	cmp	w19, #0x1
{
 1140254:	a9025bf5 	stp	x21, x22, [sp, #32]
    if( val != 0 && val != 1 )
 1140258:	54000368 	b.hi	11402c4 <mbedtls_mpi_set_bit+0x84>  // b.pmore
 114025c:	aa0103f4 	mov	x20, x1
 1140260:	d346fc35 	lsr	x21, x1, #6
    if( X->n * biL <= pos )
 1140264:	f9400401 	ldr	x1, [x0, #8]
 1140268:	aa0003f6 	mov	x22, x0
 114026c:	eb011a9f 	cmp	x20, x1, lsl #6
 1140270:	540001a2 	b.cs	11402a4 <mbedtls_mpi_set_bit+0x64>  // b.hs, b.nlast
    X->p[off] &= ~( (mbedtls_mpi_uint) 0x01 << idx );
 1140274:	f9400ac1 	ldr	x1, [x22, #16]
 1140278:	d37df2b5 	lsl	x21, x21, #3
    X->p[off] |= (mbedtls_mpi_uint) val << idx;
 114027c:	92401e73 	and	x19, x19, #0xff
    X->p[off] &= ~( (mbedtls_mpi_uint) 0x01 << idx );
 1140280:	d2800020 	mov	x0, #0x1                   	// #1
 1140284:	9ad42000 	lsl	x0, x0, x20
 1140288:	f8756822 	ldr	x2, [x1, x21]
    X->p[off] |= (mbedtls_mpi_uint) val << idx;
 114028c:	9ad42273 	lsl	x19, x19, x20
    X->p[off] &= ~( (mbedtls_mpi_uint) 0x01 << idx );
 1140290:	8a200040 	bic	x0, x2, x0
    X->p[off] |= (mbedtls_mpi_uint) val << idx;
 1140294:	aa130000 	orr	x0, x0, x19
 1140298:	f8356820 	str	x0, [x1, x21]
            return( 0 );
 114029c:	52800000 	mov	w0, #0x0                   	// #0
 11402a0:	14000005 	b	11402b4 <mbedtls_mpi_set_bit+0x74>
        if( val == 0 )
 11402a4:	34ffffd3 	cbz	w19, 114029c <mbedtls_mpi_set_bit+0x5c>
        MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, off + 1 ) );
 11402a8:	910006a1 	add	x1, x21, #0x1
 11402ac:	97ffff64 	bl	114003c <mbedtls_mpi_grow>
 11402b0:	34fffe20 	cbz	w0, 1140274 <mbedtls_mpi_set_bit+0x34>
}
 11402b4:	a94153f3 	ldp	x19, x20, [sp, #16]
 11402b8:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11402bc:	a8c37bfd 	ldp	x29, x30, [sp], #48
 11402c0:	d65f03c0 	ret
        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );
 11402c4:	12800060 	mov	w0, #0xfffffffc            	// #-4
 11402c8:	17fffffb 	b	11402b4 <mbedtls_mpi_set_bit+0x74>

00000000011402cc <mbedtls_mpi_lsb>:
    for( i = 0; i < X->n; i++ )
 11402cc:	f9400405 	ldr	x5, [x0, #8]
{
 11402d0:	aa0003e3 	mov	x3, x0
    size_t i, j, count = 0;
 11402d4:	d2800004 	mov	x4, #0x0                   	// #0
    for( i = 0; i < X->n; i++ )
 11402d8:	d2800002 	mov	x2, #0x0                   	// #0
 11402dc:	eb0200bf 	cmp	x5, x2
 11402e0:	54000061 	b.ne	11402ec <mbedtls_mpi_lsb+0x20>  // b.any
    return( 0 );
 11402e4:	d2800000 	mov	x0, #0x0                   	// #0
}
 11402e8:	d65f03c0 	ret
            if( ( ( X->p[i] >> j ) & 1 ) != 0 )
 11402ec:	f9400860 	ldr	x0, [x3, #16]
        for( j = 0; j < biL; j++, count++ )
 11402f0:	d2800001 	mov	x1, #0x0                   	// #0
            if( ( ( X->p[i] >> j ) & 1 ) != 0 )
 11402f4:	f8627806 	ldr	x6, [x0, x2, lsl #3]
 11402f8:	8b010080 	add	x0, x4, x1
 11402fc:	9ac124c7 	lsr	x7, x6, x1
 1140300:	3707ff47 	tbnz	w7, #0, 11402e8 <mbedtls_mpi_lsb+0x1c>
        for( j = 0; j < biL; j++, count++ )
 1140304:	91000421 	add	x1, x1, #0x1
 1140308:	8b010080 	add	x0, x4, x1
 114030c:	f101003f 	cmp	x1, #0x40
 1140310:	54ffff41 	b.ne	11402f8 <mbedtls_mpi_lsb+0x2c>  // b.any
    for( i = 0; i < X->n; i++ )
 1140314:	91000442 	add	x2, x2, #0x1
        for( j = 0; j < biL; j++, count++ )
 1140318:	aa0003e4 	mov	x4, x0
 114031c:	17fffff0 	b	11402dc <mbedtls_mpi_lsb+0x10>

0000000001140320 <mbedtls_mpi_bitlen>:
{
 1140320:	aa0003e2 	mov	x2, x0
    if( X->n == 0 )
 1140324:	f9400400 	ldr	x0, [x0, #8]
 1140328:	b4000200 	cbz	x0, 1140368 <mbedtls_mpi_bitlen+0x48>
    for( i = X->n - 1; i > 0; i-- )
 114032c:	d1000401 	sub	x1, x0, #0x1
 1140330:	f9400840 	ldr	x0, [x2, #16]
 1140334:	b50001c1 	cbnz	x1, 114036c <mbedtls_mpi_bitlen+0x4c>
    mbedtls_mpi_uint mask = (mbedtls_mpi_uint) 1 << (biL - 1);
 1140338:	d2f00002 	mov	x2, #0x8000000000000000    	// #-9223372036854775808
    j = biL - mbedtls_clz( X->p[i] );
 114033c:	f8617803 	ldr	x3, [x0, x1, lsl #3]
    for( j = 0; j < biL; j++ )
 1140340:	d2800000 	mov	x0, #0x0                   	// #0
        if( x & mask ) break;
 1140344:	ea02007f 	tst	x3, x2
 1140348:	540000a1 	b.ne	114035c <mbedtls_mpi_bitlen+0x3c>  // b.any
    for( j = 0; j < biL; j++ )
 114034c:	91000400 	add	x0, x0, #0x1
        mask >>= 1;
 1140350:	d341fc42 	lsr	x2, x2, #1
    for( j = 0; j < biL; j++ )
 1140354:	f101001f 	cmp	x0, #0x40
 1140358:	54ffff61 	b.ne	1140344 <mbedtls_mpi_bitlen+0x24>  // b.any
    return( ( i * biL ) + j );
 114035c:	91000421 	add	x1, x1, #0x1
 1140360:	d37ae421 	lsl	x1, x1, #6
 1140364:	cb000020 	sub	x0, x1, x0
}
 1140368:	d65f03c0 	ret
        if( X->p[i] != 0 )
 114036c:	f8617802 	ldr	x2, [x0, x1, lsl #3]
 1140370:	b5fffe42 	cbnz	x2, 1140338 <mbedtls_mpi_bitlen+0x18>
    for( i = X->n - 1; i > 0; i-- )
 1140374:	d1000421 	sub	x1, x1, #0x1
 1140378:	17ffffef 	b	1140334 <mbedtls_mpi_bitlen+0x14>

000000000114037c <mbedtls_mpi_size>:
{
 114037c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 1140380:	910003fd 	mov	x29, sp
    return( ( mbedtls_mpi_bitlen( X ) + 7 ) >> 3 );
 1140384:	97ffffe7 	bl	1140320 <mbedtls_mpi_bitlen>
 1140388:	91001c00 	add	x0, x0, #0x7
}
 114038c:	a8c17bfd 	ldp	x29, x30, [sp], #16
 1140390:	d343fc00 	lsr	x0, x0, #3
 1140394:	d65f03c0 	ret

0000000001140398 <mbedtls_mpi_read_binary>:
{
 1140398:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    size_t const limbs    = CHARS_TO_LIMBS( buflen );
 114039c:	f240085f 	tst	x2, #0x7
{
 11403a0:	910003fd 	mov	x29, sp
 11403a4:	f9001bf7 	str	x23, [sp, #48]
 11403a8:	aa0103f7 	mov	x23, x1
    if( X->n != limbs )
 11403ac:	f9400401 	ldr	x1, [x0, #8]
{
 11403b0:	a90153f3 	stp	x19, x20, [sp, #16]
 11403b4:	aa0003f3 	mov	x19, x0
 11403b8:	a9025bf5 	stp	x21, x22, [sp, #32]
    size_t const limbs    = CHARS_TO_LIMBS( buflen );
 11403bc:	d343fc55 	lsr	x21, x2, #3
 11403c0:	9a9506b5 	cinc	x21, x21, ne  // ne = any
{
 11403c4:	aa0203f6 	mov	x22, x2
    if( X->n != limbs )
 11403c8:	eb15003f 	cmp	x1, x21
 11403cc:	54000181 	b.ne	11403fc <mbedtls_mpi_read_binary+0x64>  // b.any
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( X, 0 ) );
 11403d0:	aa1303e0 	mov	x0, x19
 11403d4:	d2800001 	mov	x1, #0x0                   	// #0
 11403d8:	97ffff80 	bl	11401d8 <mbedtls_mpi_lset>
 11403dc:	2a0003f4 	mov	w20, w0
 11403e0:	34000260 	cbz	w0, 114042c <mbedtls_mpi_read_binary+0x94>
}
 11403e4:	2a1403e0 	mov	w0, w20
 11403e8:	a94153f3 	ldp	x19, x20, [sp, #16]
 11403ec:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11403f0:	f9401bf7 	ldr	x23, [sp, #48]
 11403f4:	a8c47bfd 	ldp	x29, x30, [sp], #64
 11403f8:	d65f03c0 	ret
        short use_mempool = X->use_mempool;
 11403fc:	79c00414 	ldrsh	w20, [x0, #2]
        mbedtls_mpi_free( X );
 1140400:	97fffef4 	bl	113ffd0 <mbedtls_mpi_free>
    X->s = 1;
 1140404:	52800020 	mov	w0, #0x1                   	// #1
 1140408:	79000260 	strh	w0, [x19]
    X->use_mempool = use_mempool;
 114040c:	79000674 	strh	w20, [x19, #2]
        MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, limbs ) );
 1140410:	aa1503e1 	mov	x1, x21
    X->p = NULL;
 1140414:	a900fe7f 	stp	xzr, xzr, [x19, #8]
        MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, limbs ) );
 1140418:	aa1303e0 	mov	x0, x19
 114041c:	97ffff08 	bl	114003c <mbedtls_mpi_grow>
 1140420:	2a0003f4 	mov	w20, w0
 1140424:	34fffd60 	cbz	w0, 11403d0 <mbedtls_mpi_read_binary+0x38>
 1140428:	17ffffef 	b	11403e4 <mbedtls_mpi_read_binary+0x4c>
    if( buf != NULL )
 114042c:	b4fffdd7 	cbz	x23, 11403e4 <mbedtls_mpi_read_binary+0x4c>
        memcpy( Xp + overhead, buf, buflen );
 1140430:	f9400a63 	ldr	x3, [x19, #16]
    size_t const overhead = ( limbs * ciL ) - buflen;
 1140434:	d37df2a0 	lsl	x0, x21, #3
 1140438:	cb160000 	sub	x0, x0, x22
        memcpy( Xp + overhead, buf, buflen );
 114043c:	aa1603e2 	mov	x2, x22
 1140440:	aa1703e1 	mov	x1, x23
 1140444:	8b000060 	add	x0, x3, x0
 1140448:	97ff0bd2 	bl	1103390 <memcpy>
    if( limbs == 0 )
 114044c:	b4fffcd5 	cbz	x21, 11403e4 <mbedtls_mpi_read_binary+0x4c>
 1140450:	f9400a60 	ldr	x0, [x19, #16]
 1140454:	aa1503e1 	mov	x1, x21
 1140458:	97fffeb3 	bl	113ff24 <mpi_bigendian_to_host.part.0>
    return( ret );
 114045c:	17ffffe2 	b	11403e4 <mbedtls_mpi_read_binary+0x4c>

0000000001140460 <mbedtls_mpi_write_binary>:
{
 1140460:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1140464:	910003fd 	mov	x29, sp
 1140468:	a90153f3 	stp	x19, x20, [sp, #16]
 114046c:	aa0003f3 	mov	x19, x0
 1140470:	aa0103e0 	mov	x0, x1
    stored_bytes = X->n * ciL;
 1140474:	f9400661 	ldr	x1, [x19, #8]
{
 1140478:	f90013f5 	str	x21, [sp, #32]
    stored_bytes = X->n * ciL;
 114047c:	d37df034 	lsl	x20, x1, #3
    if( stored_bytes < buflen )
 1140480:	eb010c5f 	cmp	x2, x1, lsl #3
 1140484:	54000389 	b.ls	11404f4 <mbedtls_mpi_write_binary+0x94>  // b.plast
        p = buf + buflen - stored_bytes;
 1140488:	cb140042 	sub	x2, x2, x20
        memset( buf, 0, buflen - stored_bytes );
 114048c:	52800001 	mov	w1, #0x0                   	// #0
        p = buf + buflen - stored_bytes;
 1140490:	8b020015 	add	x21, x0, x2
        memset( buf, 0, buflen - stored_bytes );
 1140494:	94000e13 	bl	1143ce0 <memset>
        p = buf + buflen - stored_bytes;
 1140498:	aa1503e0 	mov	x0, x21
 114049c:	aa1403e2 	mov	x2, x20
    for( i = 0; i < bytes_to_copy; i++ )
 11404a0:	8b020001 	add	x1, x0, x2
 11404a4:	d2800003 	mov	x3, #0x0                   	// #0
 11404a8:	d1000421 	sub	x1, x1, #0x1
 11404ac:	eb03005f 	cmp	x2, x3
 11404b0:	54000261 	b.ne	11404fc <mbedtls_mpi_write_binary+0x9c>  // b.any
    return( 0 );
 11404b4:	52800000 	mov	w0, #0x0                   	// #0
}
 11404b8:	a94153f3 	ldp	x19, x20, [sp, #16]
 11404bc:	f94013f5 	ldr	x21, [sp, #32]
 11404c0:	a8c37bfd 	ldp	x29, x30, [sp], #48
 11404c4:	d65f03c0 	ret
            if( GET_BYTE( X, i ) != 0 )
 11404c8:	f9400a65 	ldr	x5, [x19, #16]
 11404cc:	927df024 	and	x4, x1, #0xfffffffffffffff8
 11404d0:	531d0823 	ubfiz	w3, w1, #3, #3
 11404d4:	f86468a4 	ldr	x4, [x5, x4]
 11404d8:	9ac32483 	lsr	x3, x4, x3
 11404dc:	72001c7f 	tst	w3, #0xff
 11404e0:	540001e1 	b.ne	114051c <mbedtls_mpi_write_binary+0xbc>  // b.any
        for( i = bytes_to_copy; i < stored_bytes; i++ )
 11404e4:	91000421 	add	x1, x1, #0x1
 11404e8:	eb14003f 	cmp	x1, x20
 11404ec:	54fffee1 	b.ne	11404c8 <mbedtls_mpi_write_binary+0x68>  // b.any
 11404f0:	17ffffec 	b	11404a0 <mbedtls_mpi_write_binary+0x40>
 11404f4:	aa0203e1 	mov	x1, x2
 11404f8:	17fffffc 	b	11404e8 <mbedtls_mpi_write_binary+0x88>
        p[bytes_to_copy - i - 1] = GET_BYTE( X, i );
 11404fc:	f9400a65 	ldr	x5, [x19, #16]
 1140500:	927df060 	and	x0, x3, #0xfffffffffffffff8
 1140504:	531d0864 	ubfiz	w4, w3, #3, #3
    for( i = 0; i < bytes_to_copy; i++ )
 1140508:	91000463 	add	x3, x3, #0x1
        p[bytes_to_copy - i - 1] = GET_BYTE( X, i );
 114050c:	f86068a0 	ldr	x0, [x5, x0]
 1140510:	9ac42400 	lsr	x0, x0, x4
 1140514:	39000020 	strb	w0, [x1]
    for( i = 0; i < bytes_to_copy; i++ )
 1140518:	17ffffe4 	b	11404a8 <mbedtls_mpi_write_binary+0x48>
                return( MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL );
 114051c:	128000e0 	mov	w0, #0xfffffff8            	// #-8
 1140520:	17ffffe6 	b	11404b8 <mbedtls_mpi_write_binary+0x58>

0000000001140524 <mbedtls_mpi_shift_l>:
{
 1140524:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1140528:	910003fd 	mov	x29, sp
 114052c:	a90153f3 	stp	x19, x20, [sp, #16]
 1140530:	aa0003f3 	mov	x19, x0
    v0 = count / (biL    );
 1140534:	d346fc34 	lsr	x20, x1, #6
{
 1140538:	a9025bf5 	stp	x21, x22, [sp, #32]
 114053c:	aa0103f5 	mov	x21, x1
    t1 = count & (biL - 1);
 1140540:	92401436 	and	x22, x1, #0x3f
    i = mbedtls_mpi_bitlen( X ) + count;
 1140544:	97ffff77 	bl	1140320 <mbedtls_mpi_bitlen>
 1140548:	8b150000 	add	x0, x0, x21
    if( X->n * biL < i )
 114054c:	f9400661 	ldr	x1, [x19, #8]
 1140550:	eb01181f 	cmp	x0, x1, lsl #6
 1140554:	540000c8 	b.hi	114056c <mbedtls_mpi_shift_l+0x48>  // b.pmore
    if( v0 > 0 )
 1140558:	f100febf 	cmp	x21, #0x3f
 114055c:	540001c8 	b.hi	1140594 <mbedtls_mpi_shift_l+0x70>  // b.pmore
    if( t1 > 0 )
 1140560:	b5000656 	cbnz	x22, 1140628 <mbedtls_mpi_shift_l+0x104>
    ret = 0;
 1140564:	52800000 	mov	w0, #0x0                   	// #0
 1140568:	14000007 	b	1140584 <mbedtls_mpi_shift_l+0x60>
        MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, BITS_TO_LIMBS( i ) ) );
 114056c:	f240141f 	tst	x0, #0x3f
 1140570:	d346fc00 	lsr	x0, x0, #6
 1140574:	9a800401 	cinc	x1, x0, ne  // ne = any
 1140578:	aa1303e0 	mov	x0, x19
 114057c:	97fffeb0 	bl	114003c <mbedtls_mpi_grow>
 1140580:	34fffec0 	cbz	w0, 1140558 <mbedtls_mpi_shift_l+0x34>
}
 1140584:	a94153f3 	ldp	x19, x20, [sp, #16]
 1140588:	a9425bf5 	ldp	x21, x22, [sp, #32]
 114058c:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1140590:	d65f03c0 	ret
        for( i = X->n; i > v0; i-- )
 1140594:	f9400661 	ldr	x1, [x19, #8]
 1140598:	928000e3 	mov	x3, #0xfffffffffffffff8    	// #-8
 114059c:	9b037e83 	mul	x3, x20, x3
 11405a0:	aa0103e2 	mov	x2, x1
 11405a4:	d37df020 	lsl	x0, x1, #3
 11405a8:	d1002000 	sub	x0, x0, #0x8
 11405ac:	eb14005f 	cmp	x2, x20
 11405b0:	54000168 	b.hi	11405dc <mbedtls_mpi_shift_l+0xb8>  // b.pmore
 11405b4:	eb010280 	subs	x0, x20, x1
 11405b8:	9a9f9000 	csel	x0, x0, xzr, ls  // ls = plast
 11405bc:	8b000021 	add	x1, x1, x0
 11405c0:	d37df021 	lsl	x1, x1, #3
        for( ; i > 0; i-- )
 11405c4:	d1002021 	sub	x1, x1, #0x8
 11405c8:	b100203f 	cmn	x1, #0x8
 11405cc:	54fffca0 	b.eq	1140560 <mbedtls_mpi_shift_l+0x3c>  // b.none
            X->p[i - 1] = 0;
 11405d0:	f9400a60 	ldr	x0, [x19, #16]
 11405d4:	f821681f 	str	xzr, [x0, x1]
 11405d8:	17fffffb 	b	11405c4 <mbedtls_mpi_shift_l+0xa0>
            X->p[i - 1] = X->p[i - v0 - 1];
 11405dc:	f9400a64 	ldr	x4, [x19, #16]
        for( i = X->n; i > v0; i-- )
 11405e0:	d1000442 	sub	x2, x2, #0x1
            X->p[i - 1] = X->p[i - v0 - 1];
 11405e4:	8b030085 	add	x5, x4, x3
 11405e8:	f86068a5 	ldr	x5, [x5, x0]
 11405ec:	f8206885 	str	x5, [x4, x0]
        for( i = X->n; i > v0; i-- )
 11405f0:	d1002000 	sub	x0, x0, #0x8
 11405f4:	17ffffee 	b	11405ac <mbedtls_mpi_shift_l+0x88>
            r1 = X->p[i] >> (biL - t1);
 11405f8:	f9400a65 	ldr	x5, [x19, #16]
 11405fc:	d37df284 	lsl	x4, x20, #3
        for( i = v0; i < X->n; i++ )
 1140600:	91000694 	add	x20, x20, #0x1
            r1 = X->p[i] >> (biL - t1);
 1140604:	f86468a3 	ldr	x3, [x5, x4]
            X->p[i] <<= t1;
 1140608:	9ad62061 	lsl	x1, x3, x22
            X->p[i] |= r0;
 114060c:	aa020021 	orr	x1, x1, x2
            r0 = r1;
 1140610:	9ac02462 	lsr	x2, x3, x0
            X->p[i] |= r0;
 1140614:	f82468a1 	str	x1, [x5, x4]
        for( i = v0; i < X->n; i++ )
 1140618:	f9400661 	ldr	x1, [x19, #8]
 114061c:	eb14003f 	cmp	x1, x20
 1140620:	54fffec8 	b.hi	11405f8 <mbedtls_mpi_shift_l+0xd4>  // b.pmore
 1140624:	17ffffd0 	b	1140564 <mbedtls_mpi_shift_l+0x40>
            r1 = X->p[i] >> (biL - t1);
 1140628:	52800800 	mov	w0, #0x40                  	// #64
    mbedtls_mpi_uint r0 = 0, r1;
 114062c:	d2800002 	mov	x2, #0x0                   	// #0
            r1 = X->p[i] >> (biL - t1);
 1140630:	4b160000 	sub	w0, w0, w22
 1140634:	17fffff9 	b	1140618 <mbedtls_mpi_shift_l+0xf4>

0000000001140638 <mbedtls_mpi_shift_r>:
    if( v0 > X->n || ( v0 == X->n && v1 > 0 ) )
 1140638:	f9400403 	ldr	x3, [x0, #8]
    v0 = count /  biL;
 114063c:	d346fc24 	lsr	x4, x1, #6
    v1 = count & (biL - 1);
 1140640:	92401422 	and	x2, x1, #0x3f
    if( v0 > X->n || ( v0 == X->n && v1 > 0 ) )
 1140644:	eb04007f 	cmp	x3, x4
 1140648:	54000063 	b.cc	1140654 <mbedtls_mpi_shift_r+0x1c>  // b.lo, b.ul, b.last
 114064c:	54000081 	b.ne	114065c <mbedtls_mpi_shift_r+0x24>  // b.any
 1140650:	b40004e2 	cbz	x2, 11406ec <mbedtls_mpi_shift_r+0xb4>
        return mbedtls_mpi_lset( X, 0 );
 1140654:	d2800001 	mov	x1, #0x0                   	// #0
 1140658:	17fffee0 	b	11401d8 <mbedtls_mpi_lset>
    if( v0 > 0 )
 114065c:	f100fc3f 	cmp	x1, #0x3f
 1140660:	540004a8 	b.hi	11406f4 <mbedtls_mpi_shift_r+0xbc>  // b.pmore
    if( v1 > 0 )
 1140664:	b5000262 	cbnz	x2, 11406b0 <mbedtls_mpi_shift_r+0x78>
}
 1140668:	52800000 	mov	w0, #0x0                   	// #0
 114066c:	d65f03c0 	ret
            X->p[i] = X->p[i + v0];
 1140670:	f9400805 	ldr	x5, [x0, #16]
 1140674:	f86368a6 	ldr	x6, [x5, x3]
 1140678:	91002063 	add	x3, x3, #0x8
 114067c:	f82178a6 	str	x6, [x5, x1, lsl #3]
        for( i = 0; i < X->n - v0; i++ )
 1140680:	91000421 	add	x1, x1, #0x1
 1140684:	f9400405 	ldr	x5, [x0, #8]
 1140688:	cb0400a5 	sub	x5, x5, x4
 114068c:	eb0100bf 	cmp	x5, x1
 1140690:	54ffff08 	b.hi	1140670 <mbedtls_mpi_shift_r+0x38>  // b.pmore
        for( ; i < X->n; i++ )
 1140694:	f9400403 	ldr	x3, [x0, #8]
 1140698:	eb01007f 	cmp	x3, x1
 114069c:	54fffe49 	b.ls	1140664 <mbedtls_mpi_shift_r+0x2c>  // b.plast
            X->p[i] = 0;
 11406a0:	f9400803 	ldr	x3, [x0, #16]
 11406a4:	f821787f 	str	xzr, [x3, x1, lsl #3]
        for( ; i < X->n; i++ )
 11406a8:	91000421 	add	x1, x1, #0x1
 11406ac:	17fffffa 	b	1140694 <mbedtls_mpi_shift_r+0x5c>
        for( i = X->n; i > 0; i-- )
 11406b0:	f9400401 	ldr	x1, [x0, #8]
            r1 = X->p[i - 1] << (biL - v1);
 11406b4:	52800804 	mov	w4, #0x40                  	// #64
 11406b8:	4b020084 	sub	w4, w4, w2
    mbedtls_mpi_uint r0 = 0, r1;
 11406bc:	d2800006 	mov	x6, #0x0                   	// #0
        for( i = X->n; i > 0; i-- )
 11406c0:	d1000421 	sub	x1, x1, #0x1
 11406c4:	b100043f 	cmn	x1, #0x1
 11406c8:	54fffd00 	b.eq	1140668 <mbedtls_mpi_shift_r+0x30>  // b.none
            r1 = X->p[i - 1] << (biL - v1);
 11406cc:	f9400808 	ldr	x8, [x0, #16]
 11406d0:	d37df023 	lsl	x3, x1, #3
 11406d4:	f8636907 	ldr	x7, [x8, x3]
            X->p[i - 1] >>= v1;
 11406d8:	9ac224e5 	lsr	x5, x7, x2
            X->p[i - 1] |= r0;
 11406dc:	aa0600a5 	orr	x5, x5, x6
            r0 = r1;
 11406e0:	9ac420e6 	lsl	x6, x7, x4
            X->p[i - 1] |= r0;
 11406e4:	f8236905 	str	x5, [x8, x3]
        for( i = X->n; i > 0; i-- )
 11406e8:	17fffff6 	b	11406c0 <mbedtls_mpi_shift_r+0x88>
    if( v0 > 0 )
 11406ec:	f100fc3f 	cmp	x1, #0x3f
 11406f0:	54fffbc9 	b.ls	1140668 <mbedtls_mpi_shift_r+0x30>  // b.plast
 11406f4:	d37df083 	lsl	x3, x4, #3
{
 11406f8:	d2800001 	mov	x1, #0x0                   	// #0
 11406fc:	17ffffe2 	b	1140684 <mbedtls_mpi_shift_r+0x4c>

0000000001140700 <mbedtls_mpi_cmp_abs>:
    for( i = X->n; i > 0; i-- )
 1140700:	f9400402 	ldr	x2, [x0, #8]
 1140704:	b50000c2 	cbnz	x2, 114071c <mbedtls_mpi_cmp_abs+0x1c>
    for( j = Y->n; j > 0; j-- )
 1140708:	f9400423 	ldr	x3, [x1, #8]
 114070c:	b5000143 	cbnz	x3, 1140734 <mbedtls_mpi_cmp_abs+0x34>
    if( i == 0 && j == 0 )
 1140710:	f100005f 	cmp	x2, #0x0
 1140714:	1a9f07e0 	cset	w0, ne  // ne = any
}
 1140718:	d65f03c0 	ret
        if( X->p[i - 1] != 0 )
 114071c:	f9400803 	ldr	x3, [x0, #16]
 1140720:	8b020c63 	add	x3, x3, x2, lsl #3
 1140724:	f85f8063 	ldur	x3, [x3, #-8]
 1140728:	b5ffff03 	cbnz	x3, 1140708 <mbedtls_mpi_cmp_abs+0x8>
    for( i = X->n; i > 0; i-- )
 114072c:	d1000442 	sub	x2, x2, #0x1
 1140730:	17fffff5 	b	1140704 <mbedtls_mpi_cmp_abs+0x4>
        if( Y->p[j - 1] != 0 )
 1140734:	f9400824 	ldr	x4, [x1, #16]
 1140738:	8b030c85 	add	x5, x4, x3, lsl #3
 114073c:	f85f80a5 	ldur	x5, [x5, #-8]
 1140740:	b40000a5 	cbz	x5, 1140754 <mbedtls_mpi_cmp_abs+0x54>
    if( i > j ) return(  1 );
 1140744:	eb03005f 	cmp	x2, x3
 1140748:	540000a9 	b.ls	114075c <mbedtls_mpi_cmp_abs+0x5c>  // b.plast
 114074c:	52800020 	mov	w0, #0x1                   	// #1
 1140750:	17fffff2 	b	1140718 <mbedtls_mpi_cmp_abs+0x18>
    for( j = Y->n; j > 0; j-- )
 1140754:	d1000463 	sub	x3, x3, #0x1
 1140758:	17ffffed 	b	114070c <mbedtls_mpi_cmp_abs+0xc>
    if( j > i ) return( -1 );
 114075c:	540001c3 	b.cc	1140794 <mbedtls_mpi_cmp_abs+0x94>  // b.lo, b.ul, b.last
 1140760:	d1000442 	sub	x2, x2, #0x1
    for( ; i > 0; i-- )
 1140764:	b100045f 	cmn	x2, #0x1
 1140768:	54000061 	b.ne	1140774 <mbedtls_mpi_cmp_abs+0x74>  // b.any
        return( 0 );
 114076c:	52800000 	mov	w0, #0x0                   	// #0
 1140770:	17ffffea 	b	1140718 <mbedtls_mpi_cmp_abs+0x18>
        if( X->p[i - 1] > Y->p[i - 1] ) return(  1 );
 1140774:	f9400803 	ldr	x3, [x0, #16]
 1140778:	d37df041 	lsl	x1, x2, #3
 114077c:	f8616863 	ldr	x3, [x3, x1]
 1140780:	f8616881 	ldr	x1, [x4, x1]
 1140784:	eb01007f 	cmp	x3, x1
 1140788:	54fffe28 	b.hi	114074c <mbedtls_mpi_cmp_abs+0x4c>  // b.pmore
        if( X->p[i - 1] < Y->p[i - 1] ) return( -1 );
 114078c:	d1000442 	sub	x2, x2, #0x1
 1140790:	54fffea2 	b.cs	1140764 <mbedtls_mpi_cmp_abs+0x64>  // b.hs, b.nlast
    if( j > i ) return( -1 );
 1140794:	12800000 	mov	w0, #0xffffffff            	// #-1
 1140798:	17ffffe0 	b	1140718 <mbedtls_mpi_cmp_abs+0x18>

000000000114079c <mbedtls_mpi_cmp_mpi>:
    for( i = X->n; i > 0; i-- )
 114079c:	f9400402 	ldr	x2, [x0, #8]
{
 11407a0:	aa0003e3 	mov	x3, x0
    for( i = X->n; i > 0; i-- )
 11407a4:	b5000102 	cbnz	x2, 11407c4 <mbedtls_mpi_cmp_mpi+0x28>
    for( j = Y->n; j > 0; j-- )
 11407a8:	f9400420 	ldr	x0, [x1, #8]
 11407ac:	b5000180 	cbnz	x0, 11407dc <mbedtls_mpi_cmp_mpi+0x40>
    if( i == 0 && j == 0 )
 11407b0:	b40005c2 	cbz	x2, 1140868 <mbedtls_mpi_cmp_mpi+0xcc>
    if( i > j ) return(  X->s );
 11407b4:	eb00005f 	cmp	x2, x0
 11407b8:	540001e9 	b.ls	11407f4 <mbedtls_mpi_cmp_mpi+0x58>  // b.plast
 11407bc:	79c00060 	ldrsh	w0, [x3]
}
 11407c0:	d65f03c0 	ret
        if( X->p[i - 1] != 0 )
 11407c4:	f9400860 	ldr	x0, [x3, #16]
 11407c8:	8b020c00 	add	x0, x0, x2, lsl #3
 11407cc:	f85f8000 	ldur	x0, [x0, #-8]
 11407d0:	b5fffec0 	cbnz	x0, 11407a8 <mbedtls_mpi_cmp_mpi+0xc>
    for( i = X->n; i > 0; i-- )
 11407d4:	d1000442 	sub	x2, x2, #0x1
 11407d8:	17fffff3 	b	11407a4 <mbedtls_mpi_cmp_mpi+0x8>
        if( Y->p[j - 1] != 0 )
 11407dc:	f9400824 	ldr	x4, [x1, #16]
 11407e0:	8b000c84 	add	x4, x4, x0, lsl #3
 11407e4:	f85f8084 	ldur	x4, [x4, #-8]
 11407e8:	b5fffe64 	cbnz	x4, 11407b4 <mbedtls_mpi_cmp_mpi+0x18>
    for( j = Y->n; j > 0; j-- )
 11407ec:	d1000400 	sub	x0, x0, #0x1
 11407f0:	17ffffef 	b	11407ac <mbedtls_mpi_cmp_mpi+0x10>
    if( j > i ) return( -Y->s );
 11407f4:	79c00024 	ldrsh	w4, [x1]
 11407f8:	54000062 	b.cs	1140804 <mbedtls_mpi_cmp_mpi+0x68>  // b.hs, b.nlast
 11407fc:	4b0403e0 	neg	w0, w4
 1140800:	17fffff0 	b	11407c0 <mbedtls_mpi_cmp_mpi+0x24>
    if( X->s > 0 && Y->s < 0 ) return(  1 );
 1140804:	79c00060 	ldrsh	w0, [x3]
 1140808:	7100001f 	cmp	w0, #0x0
 114080c:	5400008d 	b.le	114081c <mbedtls_mpi_cmp_mpi+0x80>
 1140810:	36f80264 	tbz	w4, #31, 114085c <mbedtls_mpi_cmp_mpi+0xc0>
 1140814:	52800020 	mov	w0, #0x1                   	// #1
 1140818:	17ffffea 	b	11407c0 <mbedtls_mpi_cmp_mpi+0x24>
    if( Y->s > 0 && X->s < 0 ) return( -1 );
 114081c:	7100009f 	cmp	w4, #0x0
 1140820:	540001ed 	b.le	114085c <mbedtls_mpi_cmp_mpi+0xc0>
 1140824:	340001c0 	cbz	w0, 114085c <mbedtls_mpi_cmp_mpi+0xc0>
 1140828:	12800000 	mov	w0, #0xffffffff            	// #-1
 114082c:	17ffffe5 	b	11407c0 <mbedtls_mpi_cmp_mpi+0x24>
        if( X->p[i - 1] > Y->p[i - 1] ) return(  X->s );
 1140830:	f9400826 	ldr	x6, [x1, #16]
 1140834:	d37df044 	lsl	x4, x2, #3
 1140838:	f9400865 	ldr	x5, [x3, #16]
 114083c:	f86468a5 	ldr	x5, [x5, x4]
 1140840:	f86468c4 	ldr	x4, [x6, x4]
 1140844:	eb0400bf 	cmp	x5, x4
 1140848:	54fffbc8 	b.hi	11407c0 <mbedtls_mpi_cmp_mpi+0x24>  // b.pmore
        if( X->p[i - 1] < Y->p[i - 1] ) return( -X->s );
 114084c:	d1000442 	sub	x2, x2, #0x1
 1140850:	54000082 	b.cs	1140860 <mbedtls_mpi_cmp_mpi+0xc4>  // b.hs, b.nlast
 1140854:	4b0003e0 	neg	w0, w0
 1140858:	17ffffda 	b	11407c0 <mbedtls_mpi_cmp_mpi+0x24>
 114085c:	d1000442 	sub	x2, x2, #0x1
    for( ; i > 0; i-- )
 1140860:	b100045f 	cmn	x2, #0x1
 1140864:	54fffe61 	b.ne	1140830 <mbedtls_mpi_cmp_mpi+0x94>  // b.any
        return( 0 );
 1140868:	52800000 	mov	w0, #0x0                   	// #0
 114086c:	17ffffd5 	b	11407c0 <mbedtls_mpi_cmp_mpi+0x24>

0000000001140870 <mbedtls_mpi_cmp_int>:
{
 1140870:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    *p  = ( z < 0 ) ? -z : z;
 1140874:	f100003f 	cmp	x1, #0x0
 1140878:	da81a422 	cneg	x2, x1, lt  // lt = tstop
{
 114087c:	910003fd 	mov	x29, sp
    *p  = ( z < 0 ) ? -z : z;
 1140880:	f9000be2 	str	x2, [sp, #16]
    Y.s = ( z < 0 ) ? -1 : 1;
 1140884:	52800022 	mov	w2, #0x1                   	// #1
 1140888:	5a82a442 	cneg	w2, w2, lt  // lt = tstop
    Y.n = 1;
 114088c:	d2800021 	mov	x1, #0x1                   	// #1
 1140890:	f90013e1 	str	x1, [sp, #32]
    Y.p = p;
 1140894:	910043e1 	add	x1, sp, #0x10
    Y.s = ( z < 0 ) ? -1 : 1;
 1140898:	790033e2 	strh	w2, [sp, #24]
    Y.p = p;
 114089c:	f90017e1 	str	x1, [sp, #40]
    return( mbedtls_mpi_cmp_mpi( X, &Y ) );
 11408a0:	910063e1 	add	x1, sp, #0x18
 11408a4:	97ffffbe 	bl	114079c <mbedtls_mpi_cmp_mpi>
}
 11408a8:	a8c37bfd 	ldp	x29, x30, [sp], #48
 11408ac:	d65f03c0 	ret

00000000011408b0 <mbedtls_mpi_add_abs>:
{
 11408b0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    if( X == B )
 11408b4:	eb02001f 	cmp	x0, x2
{
 11408b8:	910003fd 	mov	x29, sp
 11408bc:	a90153f3 	stp	x19, x20, [sp, #16]
 11408c0:	aa0003f4 	mov	x20, x0
 11408c4:	a9025bf5 	stp	x21, x22, [sp, #32]
 11408c8:	aa0103f6 	mov	x22, x1
 11408cc:	f9001bf7 	str	x23, [sp, #48]
    if( X == B )
 11408d0:	540000a0 	b.eq	11408e4 <mbedtls_mpi_add_abs+0x34>  // b.none
 11408d4:	aa0203f3 	mov	x19, x2
    if( X != A )
 11408d8:	eb01001f 	cmp	x0, x1
 11408dc:	54000461 	b.ne	1140968 <mbedtls_mpi_add_abs+0xb8>  // b.any
{
 11408e0:	aa1303f6 	mov	x22, x19
    for( j = B->n; j > 0; j-- )
 11408e4:	f94006d3 	ldr	x19, [x22, #8]
    X->s = 1;
 11408e8:	52800020 	mov	w0, #0x1                   	// #1
 11408ec:	79000280 	strh	w0, [x20]
    for( j = B->n; j > 0; j-- )
 11408f0:	b50004f3 	cbnz	x19, 114098c <mbedtls_mpi_add_abs+0xdc>
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, j ) );
 11408f4:	aa1303e1 	mov	x1, x19
 11408f8:	aa1403e0 	mov	x0, x20
 11408fc:	97fffdd0 	bl	114003c <mbedtls_mpi_grow>
 1140900:	2a0003f5 	mov	w21, w0
 1140904:	35000380 	cbnz	w0, 1140974 <mbedtls_mpi_add_abs+0xc4>
    o = B->p; p = X->p; c = 0;
 1140908:	f9400a82 	ldr	x2, [x20, #16]
    for( i = 0; i < j; i++, o++, p++ )
 114090c:	d2800001 	mov	x1, #0x0                   	// #0
    o = B->p; p = X->p; c = 0;
 1140910:	f9400ac4 	ldr	x4, [x22, #16]
 1140914:	d2800016 	mov	x22, #0x0                   	// #0
    for( i = 0; i < j; i++, o++, p++ )
 1140918:	eb01027f 	cmp	x19, x1
 114091c:	54000441 	b.ne	11409a4 <mbedtls_mpi_add_abs+0xf4>  // b.any
 1140920:	8b130c42 	add	x2, x2, x19, lsl #3
    while( c != 0 )
 1140924:	b4000296 	cbz	x22, 1140974 <mbedtls_mpi_add_abs+0xc4>
        if( i >= X->n )
 1140928:	f9400680 	ldr	x0, [x20, #8]
 114092c:	91000677 	add	x23, x19, #0x1
 1140930:	eb13001f 	cmp	x0, x19
 1140934:	540000e8 	b.hi	1140950 <mbedtls_mpi_add_abs+0xa0>  // b.pmore
            MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, i + 1 ) );
 1140938:	aa1703e1 	mov	x1, x23
 114093c:	aa1403e0 	mov	x0, x20
 1140940:	97fffdbf 	bl	114003c <mbedtls_mpi_grow>
 1140944:	35000420 	cbnz	w0, 11409c8 <mbedtls_mpi_add_abs+0x118>
            p = X->p + i;
 1140948:	f9400a82 	ldr	x2, [x20, #16]
 114094c:	8b130c42 	add	x2, x2, x19, lsl #3
        *p += c; c = ( *p < c ); i++; p++;
 1140950:	f9400040 	ldr	x0, [x2]
 1140954:	aa1703f3 	mov	x19, x23
 1140958:	ab160016 	adds	x22, x0, x22
 114095c:	f8008456 	str	x22, [x2], #8
 1140960:	9a9f37f6 	cset	x22, cs  // cs = hs, nlast
 1140964:	17fffff0 	b	1140924 <mbedtls_mpi_add_abs+0x74>
        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( X, A ) );
 1140968:	97fffdef 	bl	1140124 <mbedtls_mpi_copy>
 114096c:	2a0003f5 	mov	w21, w0
 1140970:	34fffb80 	cbz	w0, 11408e0 <mbedtls_mpi_add_abs+0x30>
}
 1140974:	2a1503e0 	mov	w0, w21
 1140978:	a94153f3 	ldp	x19, x20, [sp, #16]
 114097c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1140980:	f9401bf7 	ldr	x23, [sp, #48]
 1140984:	a8c47bfd 	ldp	x29, x30, [sp], #64
 1140988:	d65f03c0 	ret
        if( B->p[j - 1] != 0 )
 114098c:	f9400ac0 	ldr	x0, [x22, #16]
 1140990:	8b130c00 	add	x0, x0, x19, lsl #3
 1140994:	f85f8000 	ldur	x0, [x0, #-8]
 1140998:	b5fffae0 	cbnz	x0, 11408f4 <mbedtls_mpi_add_abs+0x44>
    for( j = B->n; j > 0; j-- )
 114099c:	d1000673 	sub	x19, x19, #0x1
 11409a0:	17ffffd4 	b	11408f0 <mbedtls_mpi_add_abs+0x40>
        tmp= *o;
 11409a4:	f8617840 	ldr	x0, [x2, x1, lsl #3]
 11409a8:	f8617883 	ldr	x3, [x4, x1, lsl #3]
        *p +=  c; c  = ( *p <  c );
 11409ac:	ab160000 	adds	x0, x0, x22
 11409b0:	9a9f37f6 	cset	x22, cs  // cs = hs, nlast
        *p += tmp; c += ( *p < tmp );
 11409b4:	ab030000 	adds	x0, x0, x3
 11409b8:	f8217840 	str	x0, [x2, x1, lsl #3]
 11409bc:	9a9636d6 	cinc	x22, x22, cs  // cs = hs, nlast
    for( i = 0; i < j; i++, o++, p++ )
 11409c0:	91000421 	add	x1, x1, #0x1
 11409c4:	17ffffd5 	b	1140918 <mbedtls_mpi_add_abs+0x68>
            MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, i + 1 ) );
 11409c8:	2a0003f5 	mov	w21, w0
    return( ret );
 11409cc:	17ffffea 	b	1140974 <mbedtls_mpi_add_abs+0xc4>

00000000011409d0 <mbedtls_mpi_sub_abs>:
{
 11409d0:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
 11409d4:	910003fd 	mov	x29, sp
 11409d8:	a9025bf5 	stp	x21, x22, [sp, #32]
 11409dc:	aa0103f6 	mov	x22, x1
 11409e0:	aa0003f5 	mov	x21, x0
    if( mbedtls_mpi_cmp_abs( A, B ) < 0 )
 11409e4:	aa0203e1 	mov	x1, x2
 11409e8:	aa1603e0 	mov	x0, x22
{
 11409ec:	a90153f3 	stp	x19, x20, [sp, #16]
 11409f0:	aa0203f4 	mov	x20, x2
 11409f4:	f9001bf7 	str	x23, [sp, #48]
    if( mbedtls_mpi_cmp_abs( A, B ) < 0 )
 11409f8:	97ffff42 	bl	1140700 <mbedtls_mpi_cmp_abs>
 11409fc:	37f804e0 	tbnz	w0, #31, 1140a98 <mbedtls_mpi_sub_abs+0xc8>
    mbedtls_mpi_init_mempool( &TB );
 1140a00:	910123f7 	add	x23, sp, #0x48
 1140a04:	aa1703e0 	mov	x0, x23
 1140a08:	97fffd68 	bl	113ffa8 <mbedtls_mpi_init_mempool>
    if( X == B )
 1140a0c:	eb15029f 	cmp	x20, x21
 1140a10:	540000c1 	b.ne	1140a28 <mbedtls_mpi_sub_abs+0x58>  // b.any
        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TB, B ) );
 1140a14:	aa1403e1 	mov	x1, x20
 1140a18:	97fffdc3 	bl	1140124 <mbedtls_mpi_copy>
 1140a1c:	2a0003f3 	mov	w19, w0
 1140a20:	35000220 	cbnz	w0, 1140a64 <mbedtls_mpi_sub_abs+0x94>
        B = &TB;
 1140a24:	aa1703f4 	mov	x20, x23
    if( X != A )
 1140a28:	eb1502df 	cmp	x22, x21
 1140a2c:	54000121 	b.ne	1140a50 <mbedtls_mpi_sub_abs+0x80>  // b.any
    X->s = 1;
 1140a30:	52800020 	mov	w0, #0x1                   	// #1
 1140a34:	790002a0 	strh	w0, [x21]
    for( n = B->n; n > 0; n-- )
 1140a38:	a9408680 	ldp	x0, x1, [x20, #8]
 1140a3c:	b5000240 	cbnz	x0, 1140a84 <mbedtls_mpi_sub_abs+0xb4>
    mpi_sub_hlp( n, B->p, X->p );
 1140a40:	f9400aa2 	ldr	x2, [x21, #16]
    ret = 0;
 1140a44:	52800013 	mov	w19, #0x0                   	// #0
    mpi_sub_hlp( n, B->p, X->p );
 1140a48:	97fffc08 	bl	113fa68 <mpi_sub_hlp>
 1140a4c:	14000006 	b	1140a64 <mbedtls_mpi_sub_abs+0x94>
        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( X, A ) );
 1140a50:	aa1603e1 	mov	x1, x22
 1140a54:	aa1503e0 	mov	x0, x21
 1140a58:	97fffdb3 	bl	1140124 <mbedtls_mpi_copy>
 1140a5c:	2a0003f3 	mov	w19, w0
 1140a60:	34fffe80 	cbz	w0, 1140a30 <mbedtls_mpi_sub_abs+0x60>
    mbedtls_mpi_free( &TB );
 1140a64:	aa1703e0 	mov	x0, x23
 1140a68:	97fffd5a 	bl	113ffd0 <mbedtls_mpi_free>
}
 1140a6c:	2a1303e0 	mov	w0, w19
 1140a70:	a94153f3 	ldp	x19, x20, [sp, #16]
 1140a74:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1140a78:	f9401bf7 	ldr	x23, [sp, #48]
 1140a7c:	a8c67bfd 	ldp	x29, x30, [sp], #96
 1140a80:	d65f03c0 	ret
        if( B->p[n - 1] != 0 )
 1140a84:	8b000c22 	add	x2, x1, x0, lsl #3
 1140a88:	f85f8042 	ldur	x2, [x2, #-8]
 1140a8c:	b5fffda2 	cbnz	x2, 1140a40 <mbedtls_mpi_sub_abs+0x70>
    for( n = B->n; n > 0; n-- )
 1140a90:	d1000400 	sub	x0, x0, #0x1
 1140a94:	17ffffea 	b	1140a3c <mbedtls_mpi_sub_abs+0x6c>
        return( MBEDTLS_ERR_MPI_NEGATIVE_VALUE );
 1140a98:	12800133 	mov	w19, #0xfffffff6            	// #-10
 1140a9c:	17fffff4 	b	1140a6c <mbedtls_mpi_sub_abs+0x9c>

0000000001140aa0 <mbedtls_mpi_add_mpi>:
{
 1140aa0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1140aa4:	910003fd 	mov	x29, sp
    if( A->s * B->s < 0 )
 1140aa8:	79c00043 	ldrsh	w3, [x2]
{
 1140aac:	a90153f3 	stp	x19, x20, [sp, #16]
 1140ab0:	aa0003f3 	mov	x19, x0
    s = A->s;
 1140ab4:	79c00034 	ldrsh	w20, [x1]
    if( A->s * B->s < 0 )
 1140ab8:	1b147c63 	mul	w3, w3, w20
 1140abc:	36f802e3 	tbz	w3, #31, 1140b18 <mbedtls_mpi_add_mpi+0x78>
 1140ac0:	aa0103e7 	mov	x7, x1
 1140ac4:	aa0203e6 	mov	x6, x2
        if( mbedtls_mpi_cmp_abs( A, B ) >= 0 )
 1140ac8:	aa0203e1 	mov	x1, x2
 1140acc:	aa0703e0 	mov	x0, x7
 1140ad0:	97ffff0c 	bl	1140700 <mbedtls_mpi_cmp_abs>
 1140ad4:	37f80120 	tbnz	w0, #31, 1140af8 <mbedtls_mpi_add_mpi+0x58>
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( X, A, B ) );
 1140ad8:	aa0603e2 	mov	x2, x6
 1140adc:	aa0703e1 	mov	x1, x7
 1140ae0:	aa1303e0 	mov	x0, x19
 1140ae4:	97ffffbb 	bl	11409d0 <mbedtls_mpi_sub_abs>
        MBEDTLS_MPI_CHK( mbedtls_mpi_add_abs( X, A, B ) );
 1140ae8:	34000140 	cbz	w0, 1140b10 <mbedtls_mpi_add_mpi+0x70>
}
 1140aec:	a94153f3 	ldp	x19, x20, [sp, #16]
 1140af0:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1140af4:	d65f03c0 	ret
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( X, B, A ) );
 1140af8:	aa0703e2 	mov	x2, x7
 1140afc:	aa0603e1 	mov	x1, x6
 1140b00:	aa1303e0 	mov	x0, x19
 1140b04:	97ffffb3 	bl	11409d0 <mbedtls_mpi_sub_abs>
 1140b08:	35ffff20 	cbnz	w0, 1140aec <mbedtls_mpi_add_mpi+0x4c>
            X->s = -s;
 1140b0c:	4b1403f4 	neg	w20, w20
        X->s = s;
 1140b10:	79000274 	strh	w20, [x19]
    return( ret );
 1140b14:	17fffff6 	b	1140aec <mbedtls_mpi_add_mpi+0x4c>
        MBEDTLS_MPI_CHK( mbedtls_mpi_add_abs( X, A, B ) );
 1140b18:	97ffff66 	bl	11408b0 <mbedtls_mpi_add_abs>
 1140b1c:	17fffff3 	b	1140ae8 <mbedtls_mpi_add_mpi+0x48>

0000000001140b20 <mbedtls_mpi_sub_mpi>:
{
 1140b20:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1140b24:	910003fd 	mov	x29, sp
    if( A->s * B->s > 0 )
 1140b28:	79c00043 	ldrsh	w3, [x2]
{
 1140b2c:	a90153f3 	stp	x19, x20, [sp, #16]
 1140b30:	aa0003f3 	mov	x19, x0
    s = A->s;
 1140b34:	79c00034 	ldrsh	w20, [x1]
    if( A->s * B->s > 0 )
 1140b38:	1b147c63 	mul	w3, w3, w20
 1140b3c:	7100007f 	cmp	w3, #0x0
 1140b40:	540002ed 	b.le	1140b9c <mbedtls_mpi_sub_mpi+0x7c>
 1140b44:	aa0103e7 	mov	x7, x1
 1140b48:	aa0203e6 	mov	x6, x2
        if( mbedtls_mpi_cmp_abs( A, B ) >= 0 )
 1140b4c:	aa0203e1 	mov	x1, x2
 1140b50:	aa0703e0 	mov	x0, x7
 1140b54:	97fffeeb 	bl	1140700 <mbedtls_mpi_cmp_abs>
 1140b58:	37f80120 	tbnz	w0, #31, 1140b7c <mbedtls_mpi_sub_mpi+0x5c>
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( X, A, B ) );
 1140b5c:	aa0603e2 	mov	x2, x6
 1140b60:	aa0703e1 	mov	x1, x7
 1140b64:	aa1303e0 	mov	x0, x19
 1140b68:	97ffff9a 	bl	11409d0 <mbedtls_mpi_sub_abs>
        MBEDTLS_MPI_CHK( mbedtls_mpi_add_abs( X, A, B ) );
 1140b6c:	34000140 	cbz	w0, 1140b94 <mbedtls_mpi_sub_mpi+0x74>
}
 1140b70:	a94153f3 	ldp	x19, x20, [sp, #16]
 1140b74:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1140b78:	d65f03c0 	ret
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( X, B, A ) );
 1140b7c:	aa0703e2 	mov	x2, x7
 1140b80:	aa0603e1 	mov	x1, x6
 1140b84:	aa1303e0 	mov	x0, x19
 1140b88:	97ffff92 	bl	11409d0 <mbedtls_mpi_sub_abs>
 1140b8c:	35ffff20 	cbnz	w0, 1140b70 <mbedtls_mpi_sub_mpi+0x50>
            X->s = -s;
 1140b90:	4b1403f4 	neg	w20, w20
        X->s = s;
 1140b94:	79000274 	strh	w20, [x19]
    return( ret );
 1140b98:	17fffff6 	b	1140b70 <mbedtls_mpi_sub_mpi+0x50>
        MBEDTLS_MPI_CHK( mbedtls_mpi_add_abs( X, A, B ) );
 1140b9c:	97ffff45 	bl	11408b0 <mbedtls_mpi_add_abs>
 1140ba0:	17fffff3 	b	1140b6c <mbedtls_mpi_sub_mpi+0x4c>

0000000001140ba4 <mbedtls_mpi_add_int>:
{
 1140ba4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    p[0] = ( b < 0 ) ? -b : b;
 1140ba8:	f100005f 	cmp	x2, #0x0
 1140bac:	da82a443 	cneg	x3, x2, lt  // lt = tstop
{
 1140bb0:	910003fd 	mov	x29, sp
    p[0] = ( b < 0 ) ? -b : b;
 1140bb4:	f9000be3 	str	x3, [sp, #16]
    _B.s = ( b < 0 ) ? -1 : 1;
 1140bb8:	52800023 	mov	w3, #0x1                   	// #1
 1140bbc:	5a83a463 	cneg	w3, w3, lt  // lt = tstop
    _B.n = 1;
 1140bc0:	d2800022 	mov	x2, #0x1                   	// #1
 1140bc4:	f90013e2 	str	x2, [sp, #32]
    _B.p = p;
 1140bc8:	910043e2 	add	x2, sp, #0x10
    _B.s = ( b < 0 ) ? -1 : 1;
 1140bcc:	790033e3 	strh	w3, [sp, #24]
    _B.p = p;
 1140bd0:	f90017e2 	str	x2, [sp, #40]
    return( mbedtls_mpi_add_mpi( X, A, &_B ) );
 1140bd4:	910063e2 	add	x2, sp, #0x18
 1140bd8:	97ffffb2 	bl	1140aa0 <mbedtls_mpi_add_mpi>
}
 1140bdc:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1140be0:	d65f03c0 	ret

0000000001140be4 <mbedtls_mpi_sub_int>:
{
 1140be4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    p[0] = ( b < 0 ) ? -b : b;
 1140be8:	f100005f 	cmp	x2, #0x0
 1140bec:	da82a443 	cneg	x3, x2, lt  // lt = tstop
{
 1140bf0:	910003fd 	mov	x29, sp
    p[0] = ( b < 0 ) ? -b : b;
 1140bf4:	f9000be3 	str	x3, [sp, #16]
    _B.s = ( b < 0 ) ? -1 : 1;
 1140bf8:	52800023 	mov	w3, #0x1                   	// #1
 1140bfc:	5a83a463 	cneg	w3, w3, lt  // lt = tstop
    _B.n = 1;
 1140c00:	d2800022 	mov	x2, #0x1                   	// #1
 1140c04:	f90013e2 	str	x2, [sp, #32]
    _B.p = p;
 1140c08:	910043e2 	add	x2, sp, #0x10
    _B.s = ( b < 0 ) ? -1 : 1;
 1140c0c:	790033e3 	strh	w3, [sp, #24]
    _B.p = p;
 1140c10:	f90017e2 	str	x2, [sp, #40]
    return( mbedtls_mpi_sub_mpi( X, A, &_B ) );
 1140c14:	910063e2 	add	x2, sp, #0x18
 1140c18:	97ffffc2 	bl	1140b20 <mbedtls_mpi_sub_mpi>
}
 1140c1c:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1140c20:	d65f03c0 	ret

0000000001140c24 <mbedtls_mpi_mul_mpi>:
{
 1140c24:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
 1140c28:	910003fd 	mov	x29, sp
 1140c2c:	a90363f7 	stp	x23, x24, [sp, #48]
    mbedtls_mpi_init_mempool( &TA ); mbedtls_mpi_init_mempool( &TB );
 1140c30:	910143f7 	add	x23, sp, #0x50
 1140c34:	9101a3f8 	add	x24, sp, #0x68
{
 1140c38:	a90153f3 	stp	x19, x20, [sp, #16]
 1140c3c:	aa0003f4 	mov	x20, x0
    mbedtls_mpi_init_mempool( &TA ); mbedtls_mpi_init_mempool( &TB );
 1140c40:	aa1703e0 	mov	x0, x23
{
 1140c44:	a9025bf5 	stp	x21, x22, [sp, #32]
 1140c48:	aa0203f6 	mov	x22, x2
 1140c4c:	a9046bf9 	stp	x25, x26, [sp, #64]
 1140c50:	aa0103f9 	mov	x25, x1
    mbedtls_mpi_init_mempool( &TA ); mbedtls_mpi_init_mempool( &TB );
 1140c54:	97fffcd5 	bl	113ffa8 <mbedtls_mpi_init_mempool>
 1140c58:	aa1803e0 	mov	x0, x24
 1140c5c:	97fffcd3 	bl	113ffa8 <mbedtls_mpi_init_mempool>
    if( X == A ) { MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TA, A ) ); A = &TA; }
 1140c60:	eb19029f 	cmp	x20, x25
 1140c64:	540000e1 	b.ne	1140c80 <mbedtls_mpi_mul_mpi+0x5c>  // b.any
 1140c68:	aa1403e1 	mov	x1, x20
 1140c6c:	aa1703e0 	mov	x0, x23
 1140c70:	97fffd2d 	bl	1140124 <mbedtls_mpi_copy>
 1140c74:	2a0003f3 	mov	w19, w0
 1140c78:	35000300 	cbnz	w0, 1140cd8 <mbedtls_mpi_mul_mpi+0xb4>
 1140c7c:	aa1703f9 	mov	x25, x23
    if( X == B ) { MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TB, B ) ); B = &TB; }
 1140c80:	eb16029f 	cmp	x20, x22
 1140c84:	540000e1 	b.ne	1140ca0 <mbedtls_mpi_mul_mpi+0x7c>  // b.any
 1140c88:	aa1403e1 	mov	x1, x20
 1140c8c:	aa1803e0 	mov	x0, x24
 1140c90:	97fffd25 	bl	1140124 <mbedtls_mpi_copy>
 1140c94:	2a0003f3 	mov	w19, w0
 1140c98:	35000200 	cbnz	w0, 1140cd8 <mbedtls_mpi_mul_mpi+0xb4>
 1140c9c:	aa1803f6 	mov	x22, x24
    for( i = A->n; i > 0; i-- )
 1140ca0:	f940073a 	ldr	x26, [x25, #8]
 1140ca4:	b500031a 	cbnz	x26, 1140d04 <mbedtls_mpi_mul_mpi+0xe0>
    for( j = B->n; j > 0; j-- )
 1140ca8:	f94006d5 	ldr	x21, [x22, #8]
 1140cac:	b5000395 	cbnz	x21, 1140d1c <mbedtls_mpi_mul_mpi+0xf8>
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, i + j ) );
 1140cb0:	8b150341 	add	x1, x26, x21
 1140cb4:	aa1403e0 	mov	x0, x20
 1140cb8:	97fffce1 	bl	114003c <mbedtls_mpi_grow>
 1140cbc:	2a0003f3 	mov	w19, w0
 1140cc0:	350000c0 	cbnz	w0, 1140cd8 <mbedtls_mpi_mul_mpi+0xb4>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( X, 0 ) );
 1140cc4:	aa1403e0 	mov	x0, x20
 1140cc8:	d2800001 	mov	x1, #0x0                   	// #0
 1140ccc:	97fffd43 	bl	11401d8 <mbedtls_mpi_lset>
 1140cd0:	2a0003f3 	mov	w19, w0
 1140cd4:	340003e0 	cbz	w0, 1140d50 <mbedtls_mpi_mul_mpi+0x12c>
    mbedtls_mpi_free( &TB ); mbedtls_mpi_free( &TA );
 1140cd8:	aa1803e0 	mov	x0, x24
 1140cdc:	97fffcbd 	bl	113ffd0 <mbedtls_mpi_free>
 1140ce0:	aa1703e0 	mov	x0, x23
 1140ce4:	97fffcbb 	bl	113ffd0 <mbedtls_mpi_free>
}
 1140ce8:	2a1303e0 	mov	w0, w19
 1140cec:	a94153f3 	ldp	x19, x20, [sp, #16]
 1140cf0:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1140cf4:	a94363f7 	ldp	x23, x24, [sp, #48]
 1140cf8:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1140cfc:	a8c87bfd 	ldp	x29, x30, [sp], #128
 1140d00:	d65f03c0 	ret
        if( A->p[i - 1] != 0 )
 1140d04:	f9400b20 	ldr	x0, [x25, #16]
 1140d08:	8b1a0c00 	add	x0, x0, x26, lsl #3
 1140d0c:	f85f8000 	ldur	x0, [x0, #-8]
 1140d10:	b5fffcc0 	cbnz	x0, 1140ca8 <mbedtls_mpi_mul_mpi+0x84>
    for( i = A->n; i > 0; i-- )
 1140d14:	d100075a 	sub	x26, x26, #0x1
 1140d18:	17ffffe3 	b	1140ca4 <mbedtls_mpi_mul_mpi+0x80>
        if( B->p[j - 1] != 0 )
 1140d1c:	f9400ac0 	ldr	x0, [x22, #16]
 1140d20:	8b150c00 	add	x0, x0, x21, lsl #3
 1140d24:	f85f8000 	ldur	x0, [x0, #-8]
 1140d28:	b5fffc40 	cbnz	x0, 1140cb0 <mbedtls_mpi_mul_mpi+0x8c>
    for( j = B->n; j > 0; j-- )
 1140d2c:	d10006b5 	sub	x21, x21, #0x1
 1140d30:	17ffffdf 	b	1140cac <mbedtls_mpi_mul_mpi+0x88>
        mpi_mul_hlp( i, A->p, X->p + j - 1, B->p[j - 1] );
 1140d34:	f9400ac0 	ldr	x0, [x22, #16]
 1140d38:	f9400a82 	ldr	x2, [x20, #16]
 1140d3c:	f8757803 	ldr	x3, [x0, x21, lsl #3]
 1140d40:	aa1a03e0 	mov	x0, x26
 1140d44:	f9400b21 	ldr	x1, [x25, #16]
 1140d48:	8b150c42 	add	x2, x2, x21, lsl #3
 1140d4c:	97fffb5f 	bl	113fac8 <mpi_mul_hlp>
    for( ; j > 0; j-- )
 1140d50:	d10006b5 	sub	x21, x21, #0x1
 1140d54:	b10006bf 	cmn	x21, #0x1
 1140d58:	54fffee1 	b.ne	1140d34 <mbedtls_mpi_mul_mpi+0x110>  // b.any
    X->s = A->s * B->s;
 1140d5c:	79400320 	ldrh	w0, [x25]
 1140d60:	794002c1 	ldrh	w1, [x22]
 1140d64:	1b017c00 	mul	w0, w0, w1
 1140d68:	79000280 	strh	w0, [x20]
 1140d6c:	17ffffdb 	b	1140cd8 <mbedtls_mpi_mul_mpi+0xb4>

0000000001140d70 <mbedtls_mpi_mul_int>:
{
 1140d70:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    _B.s = 1;
 1140d74:	52800023 	mov	w3, #0x1                   	// #1
{
 1140d78:	910003fd 	mov	x29, sp
    _B.s = 1;
 1140d7c:	790033e3 	strh	w3, [sp, #24]
    _B.n = 1;
 1140d80:	d2800023 	mov	x3, #0x1                   	// #1
 1140d84:	f90013e3 	str	x3, [sp, #32]
    _B.p = p;
 1140d88:	910043e3 	add	x3, sp, #0x10
    p[0] = b;
 1140d8c:	f9000be2 	str	x2, [sp, #16]
    return( mbedtls_mpi_mul_mpi( X, A, &_B ) );
 1140d90:	910063e2 	add	x2, sp, #0x18
    _B.p = p;
 1140d94:	f90017e3 	str	x3, [sp, #40]
    return( mbedtls_mpi_mul_mpi( X, A, &_B ) );
 1140d98:	97ffffa3 	bl	1140c24 <mbedtls_mpi_mul_mpi>
}
 1140d9c:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1140da0:	d65f03c0 	ret

0000000001140da4 <mbedtls_mpi_read_string>:
{
 1140da4:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
 1140da8:	910003fd 	mov	x29, sp
 1140dac:	a90153f3 	stp	x19, x20, [sp, #16]
 1140db0:	aa0003f4 	mov	x20, x0
    if( radix < 2 || radix > 16 )
 1140db4:	51000820 	sub	w0, w1, #0x2
{
 1140db8:	a9025bf5 	stp	x21, x22, [sp, #32]
    if( radix < 2 || radix > 16 )
 1140dbc:	7100381f 	cmp	w0, #0xe
{
 1140dc0:	a90363f7 	stp	x23, x24, [sp, #48]
 1140dc4:	a9046bf9 	stp	x25, x26, [sp, #64]
 1140dc8:	a90573fb 	stp	x27, x28, [sp, #80]
    if( radix < 2 || radix > 16 )
 1140dcc:	54000149 	b.ls	1140df4 <mbedtls_mpi_read_string+0x50>  // b.plast
        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );
 1140dd0:	12800073 	mov	w19, #0xfffffffc            	// #-4
}
 1140dd4:	2a1303e0 	mov	w0, w19
 1140dd8:	a94153f3 	ldp	x19, x20, [sp, #16]
 1140ddc:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1140de0:	a94363f7 	ldp	x23, x24, [sp, #48]
 1140de4:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1140de8:	a94573fb 	ldp	x27, x28, [sp, #80]
 1140dec:	a8c87bfd 	ldp	x29, x30, [sp], #128
 1140df0:	d65f03c0 	ret
    mbedtls_mpi_init_mempool( &T );
 1140df4:	9101a3f8 	add	x24, sp, #0x68
 1140df8:	2a0103f7 	mov	w23, w1
 1140dfc:	aa0203f6 	mov	x22, x2
 1140e00:	aa1803e0 	mov	x0, x24
 1140e04:	97fffc69 	bl	113ffa8 <mbedtls_mpi_init_mempool>
    slen = strlen( s );
 1140e08:	aa1603e0 	mov	x0, x22
 1140e0c:	94000bc5 	bl	1143d20 <strlen>
    if( radix == 16 )
 1140e10:	710042ff 	cmp	w23, #0x10
    slen = strlen( s );
 1140e14:	aa0003f5 	mov	x21, x0
    if( radix == 16 )
 1140e18:	54000621 	b.ne	1140edc <mbedtls_mpi_read_string+0x138>  // b.any
        if( slen > MPI_SIZE_T_MAX >> 2 )
 1140e1c:	92f80000 	mov	x0, #0x3fffffffffffffff    	// #4611686018427387903
 1140e20:	eb0002bf 	cmp	x21, x0
 1140e24:	54fffd68 	b.hi	1140dd0 <mbedtls_mpi_read_string+0x2c>  // b.pmore
        n = BITS_TO_LIMBS( slen << 2 );
 1140e28:	d37e0ea0 	ubfiz	x0, x21, #2, #4
 1140e2c:	d344f6a1 	ubfx	x1, x21, #4, #58
 1140e30:	f100001f 	cmp	x0, #0x0
        MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, n ) );
 1140e34:	aa1403e0 	mov	x0, x20
 1140e38:	9a810421 	cinc	x1, x1, ne  // ne = any
 1140e3c:	97fffc80 	bl	114003c <mbedtls_mpi_grow>
 1140e40:	2a0003f3 	mov	w19, w0
 1140e44:	35000240 	cbnz	w0, 1140e8c <mbedtls_mpi_read_string+0xe8>
        MBEDTLS_MPI_CHK( mbedtls_mpi_lset( X, 0 ) );
 1140e48:	aa1403e0 	mov	x0, x20
 1140e4c:	d2800001 	mov	x1, #0x0                   	// #0
 1140e50:	97fffce2 	bl	11401d8 <mbedtls_mpi_lset>
 1140e54:	2a0003f3 	mov	w19, w0
 1140e58:	350001a0 	cbnz	w0, 1140e8c <mbedtls_mpi_read_string+0xe8>
            MBEDTLS_MPI_CHK( mpi_get_digit( &d, radix, s[i - 1] ) );
 1140e5c:	910183e6 	add	x6, sp, #0x60
        for( i = slen, j = 0; i > 0; i--, j++ )
 1140e60:	d2800005 	mov	x5, #0x0                   	// #0
 1140e64:	b5000075 	cbnz	x21, 1140e70 <mbedtls_mpi_read_string+0xcc>
            MBEDTLS_MPI_CHK( mpi_get_digit( &d, radix, s[i - 1] ) );
 1140e68:	52800013 	mov	w19, #0x0                   	// #0
 1140e6c:	14000008 	b	1140e8c <mbedtls_mpi_read_string+0xe8>
            if( i == 1 && s[i - 1] == '-' )
 1140e70:	f10006bf 	cmp	x21, #0x1
 1140e74:	54000121 	b.ne	1140e98 <mbedtls_mpi_read_string+0xf4>  // b.any
 1140e78:	394002c0 	ldrb	w0, [x22]
 1140e7c:	7100b41f 	cmp	w0, #0x2d
 1140e80:	540000c1 	b.ne	1140e98 <mbedtls_mpi_read_string+0xf4>  // b.any
                X->s = -1;
 1140e84:	12800000 	mov	w0, #0xffffffff            	// #-1
 1140e88:	79000280 	strh	w0, [x20]
    mbedtls_mpi_free( &T );
 1140e8c:	aa1803e0 	mov	x0, x24
 1140e90:	97fffc50 	bl	113ffd0 <mbedtls_mpi_free>
    return( ret );
 1140e94:	17ffffd0 	b	1140dd4 <mbedtls_mpi_read_string+0x30>
            MBEDTLS_MPI_CHK( mpi_get_digit( &d, radix, s[i - 1] ) );
 1140e98:	d10006b5 	sub	x21, x21, #0x1
 1140e9c:	aa0603e0 	mov	x0, x6
 1140ea0:	52800201 	mov	w1, #0x10                  	// #16
 1140ea4:	38756ac2 	ldrb	w2, [x22, x21]
 1140ea8:	97fffad4 	bl	113f9f8 <mpi_get_digit>
 1140eac:	350006c0 	cbnz	w0, 1140f84 <mbedtls_mpi_read_string+0x1e0>
            X->p[j / ( 2 * ciL )] |= d << ( ( j % ( 2 * ciL ) ) << 2 );
 1140eb0:	d344fca0 	lsr	x0, x5, #4
 1140eb4:	531e0ca2 	ubfiz	w2, w5, #2, #4
 1140eb8:	f9400a83 	ldr	x3, [x20, #16]
 1140ebc:	d37df000 	lsl	x0, x0, #3
 1140ec0:	f94033e1 	ldr	x1, [sp, #96]
        for( i = slen, j = 0; i > 0; i--, j++ )
 1140ec4:	910004a5 	add	x5, x5, #0x1
            X->p[j / ( 2 * ciL )] |= d << ( ( j % ( 2 * ciL ) ) << 2 );
 1140ec8:	9ac22022 	lsl	x2, x1, x2
 1140ecc:	f8606861 	ldr	x1, [x3, x0]
 1140ed0:	aa020021 	orr	x1, x1, x2
 1140ed4:	f8206861 	str	x1, [x3, x0]
        for( i = slen, j = 0; i > 0; i--, j++ )
 1140ed8:	17ffffe3 	b	1140e64 <mbedtls_mpi_read_string+0xc0>
        MBEDTLS_MPI_CHK( mbedtls_mpi_lset( X, 0 ) );
 1140edc:	aa1403e0 	mov	x0, x20
 1140ee0:	d2800001 	mov	x1, #0x0                   	// #0
 1140ee4:	97fffcbd 	bl	11401d8 <mbedtls_mpi_lset>
 1140ee8:	2a0003f3 	mov	w19, w0
 1140eec:	35fffd00 	cbnz	w0, 1140e8c <mbedtls_mpi_read_string+0xe8>
            MBEDTLS_MPI_CHK( mpi_get_digit( &d, radix, s[i] ) );
 1140ef0:	910183fa 	add	x26, sp, #0x60
            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( &T, X, radix ) );
 1140ef4:	93407efb 	sxtw	x27, w23
        for( i = 0; i < slen; i++ )
 1140ef8:	d2800019 	mov	x25, #0x0                   	// #0
                X->s = -1;
 1140efc:	1280001c 	mov	w28, #0xffffffff            	// #-1
        for( i = 0; i < slen; i++ )
 1140f00:	eb15033f 	cmp	x25, x21
 1140f04:	54fffb20 	b.eq	1140e68 <mbedtls_mpi_read_string+0xc4>  // b.none
            if( i == 0 && s[i] == '-' )
 1140f08:	b50000f9 	cbnz	x25, 1140f24 <mbedtls_mpi_read_string+0x180>
 1140f0c:	394002c0 	ldrb	w0, [x22]
 1140f10:	7100b41f 	cmp	w0, #0x2d
 1140f14:	54000081 	b.ne	1140f24 <mbedtls_mpi_read_string+0x180>  // b.any
                X->s = -1;
 1140f18:	7900029c 	strh	w28, [x20]
        for( i = 0; i < slen; i++ )
 1140f1c:	91000739 	add	x25, x25, #0x1
 1140f20:	17fffff8 	b	1140f00 <mbedtls_mpi_read_string+0x15c>
            MBEDTLS_MPI_CHK( mpi_get_digit( &d, radix, s[i] ) );
 1140f24:	38796ac2 	ldrb	w2, [x22, x25]
 1140f28:	2a1703e1 	mov	w1, w23
 1140f2c:	aa1a03e0 	mov	x0, x26
 1140f30:	97fffab2 	bl	113f9f8 <mpi_get_digit>
 1140f34:	2a0003f3 	mov	w19, w0
 1140f38:	35fffaa0 	cbnz	w0, 1140e8c <mbedtls_mpi_read_string+0xe8>
            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( &T, X, radix ) );
 1140f3c:	aa1b03e2 	mov	x2, x27
 1140f40:	aa1403e1 	mov	x1, x20
 1140f44:	aa1803e0 	mov	x0, x24
 1140f48:	97ffff8a 	bl	1140d70 <mbedtls_mpi_mul_int>
 1140f4c:	2a0003f3 	mov	w19, w0
 1140f50:	35fff9e0 	cbnz	w0, 1140e8c <mbedtls_mpi_read_string+0xe8>
            if( X->s == 1 )
 1140f54:	79c00280 	ldrsh	w0, [x20]
                MBEDTLS_MPI_CHK( mbedtls_mpi_add_int( X, &T, d ) );
 1140f58:	aa1803e1 	mov	x1, x24
 1140f5c:	f94033e2 	ldr	x2, [sp, #96]
            if( X->s == 1 )
 1140f60:	7100041f 	cmp	w0, #0x1
                MBEDTLS_MPI_CHK( mbedtls_mpi_add_int( X, &T, d ) );
 1140f64:	aa1403e0 	mov	x0, x20
            if( X->s == 1 )
 1140f68:	540000a1 	b.ne	1140f7c <mbedtls_mpi_read_string+0x1d8>  // b.any
                MBEDTLS_MPI_CHK( mbedtls_mpi_add_int( X, &T, d ) );
 1140f6c:	97ffff0e 	bl	1140ba4 <mbedtls_mpi_add_int>
                MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( X, &T, d ) );
 1140f70:	2a0003f3 	mov	w19, w0
 1140f74:	34fffd40 	cbz	w0, 1140f1c <mbedtls_mpi_read_string+0x178>
 1140f78:	17ffffc5 	b	1140e8c <mbedtls_mpi_read_string+0xe8>
 1140f7c:	97ffff1a 	bl	1140be4 <mbedtls_mpi_sub_int>
 1140f80:	17fffffc 	b	1140f70 <mbedtls_mpi_read_string+0x1cc>
            MBEDTLS_MPI_CHK( mpi_get_digit( &d, radix, s[i - 1] ) );
 1140f84:	2a0003f3 	mov	w19, w0
 1140f88:	17ffffc1 	b	1140e8c <mbedtls_mpi_read_string+0xe8>

0000000001140f8c <mbedtls_mpi_div_mpi>:
{
 1140f8c:	a9ab7bfd 	stp	x29, x30, [sp, #-336]!
 1140f90:	910003fd 	mov	x29, sp
 1140f94:	a90153f3 	stp	x19, x20, [sp, #16]
 1140f98:	a9025bf5 	stp	x21, x22, [sp, #32]
 1140f9c:	a90363f7 	stp	x23, x24, [sp, #48]
 1140fa0:	aa0103f7 	mov	x23, x1
 1140fa4:	aa0203f8 	mov	x24, x2
    if( mbedtls_mpi_cmp_int( B, 0 ) == 0 )
 1140fa8:	d2800001 	mov	x1, #0x0                   	// #0
{
 1140fac:	a9046bf9 	stp	x25, x26, [sp, #64]
 1140fb0:	aa0003f9 	mov	x25, x0
    if( mbedtls_mpi_cmp_int( B, 0 ) == 0 )
 1140fb4:	aa0303e0 	mov	x0, x3
{
 1140fb8:	a90573fb 	stp	x27, x28, [sp, #80]
 1140fbc:	f90037e3 	str	x3, [sp, #104]
    if( mbedtls_mpi_cmp_int( B, 0 ) == 0 )
 1140fc0:	97fffe2c 	bl	1140870 <mbedtls_mpi_cmp_int>
 1140fc4:	340026e0 	cbz	w0, 11414a0 <mbedtls_mpi_div_mpi+0x514>
    mbedtls_mpi_init_mempool( &X ); mbedtls_mpi_init_mempool( &Y );
 1140fc8:	910303f4 	add	x20, sp, #0xc0
 1140fcc:	910363f6 	add	x22, sp, #0xd8
 1140fd0:	aa1403e0 	mov	x0, x20
 1140fd4:	97fffbf5 	bl	113ffa8 <mbedtls_mpi_init_mempool>
 1140fd8:	aa1603e0 	mov	x0, x22
    mbedtls_mpi_init_mempool( &Z ); mbedtls_mpi_init_mempool( &T1 );
 1140fdc:	9103c3fc 	add	x28, sp, #0xf0
    mbedtls_mpi_init_mempool( &X ); mbedtls_mpi_init_mempool( &Y );
 1140fe0:	97fffbf2 	bl	113ffa8 <mbedtls_mpi_init_mempool>
    mbedtls_mpi_init_mempool( &Z ); mbedtls_mpi_init_mempool( &T1 );
 1140fe4:	910423f5 	add	x21, sp, #0x108
 1140fe8:	aa1c03e0 	mov	x0, x28
 1140fec:	97fffbef 	bl	113ffa8 <mbedtls_mpi_init_mempool>
 1140ff0:	aa1503e0 	mov	x0, x21
 1140ff4:	97fffbed 	bl	113ffa8 <mbedtls_mpi_init_mempool>
    if( mbedtls_mpi_cmp_abs( A, B ) < 0 )
 1140ff8:	f94037e1 	ldr	x1, [sp, #104]
    T2.n = sizeof( TP2 ) / sizeof( *TP2 );
 1140ffc:	d2800060 	mov	x0, #0x3                   	// #3
 1141000:	f90097e0 	str	x0, [sp, #296]
    T2.p = TP2;
 1141004:	9104e3e0 	add	x0, sp, #0x138
    T2.s = 1;
 1141008:	52800033 	mov	w19, #0x1                   	// #1
    T2.p = TP2;
 114100c:	f90043e0 	str	x0, [sp, #128]
    T2.s = 1;
 1141010:	790243f3 	strh	w19, [sp, #288]
    T2.p = TP2;
 1141014:	f9009be0 	str	x0, [sp, #304]
    if( mbedtls_mpi_cmp_abs( A, B ) < 0 )
 1141018:	aa1803e0 	mov	x0, x24
 114101c:	97fffdb9 	bl	1140700 <mbedtls_mpi_cmp_abs>
 1141020:	36f80460 	tbz	w0, #31, 11410ac <mbedtls_mpi_div_mpi+0x120>
        if( Q != NULL ) MBEDTLS_MPI_CHK( mbedtls_mpi_lset( Q, 0 ) );
 1141024:	b5000179 	cbnz	x25, 1141050 <mbedtls_mpi_div_mpi+0xc4>
        if( R != NULL ) MBEDTLS_MPI_CHK( mbedtls_mpi_copy( R, A ) );
 1141028:	b5000377 	cbnz	x23, 1141094 <mbedtls_mpi_div_mpi+0x108>
        return( 0 );
 114102c:	5280001b 	mov	w27, #0x0                   	// #0
}
 1141030:	2a1b03e0 	mov	w0, w27
 1141034:	a94153f3 	ldp	x19, x20, [sp, #16]
 1141038:	a9425bf5 	ldp	x21, x22, [sp, #32]
 114103c:	a94363f7 	ldp	x23, x24, [sp, #48]
 1141040:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1141044:	a94573fb 	ldp	x27, x28, [sp, #80]
 1141048:	a8d57bfd 	ldp	x29, x30, [sp], #336
 114104c:	d65f03c0 	ret
        if( Q != NULL ) MBEDTLS_MPI_CHK( mbedtls_mpi_lset( Q, 0 ) );
 1141050:	aa1903e0 	mov	x0, x25
 1141054:	d2800001 	mov	x1, #0x0                   	// #0
 1141058:	97fffc60 	bl	11401d8 <mbedtls_mpi_lset>
 114105c:	2a0003fb 	mov	w27, w0
 1141060:	34fffe40 	cbz	w0, 1141028 <mbedtls_mpi_div_mpi+0x9c>
    mbedtls_mpi_free( &X ); mbedtls_mpi_free( &Y ); mbedtls_mpi_free( &Z );
 1141064:	aa1403e0 	mov	x0, x20
 1141068:	97fffbda 	bl	113ffd0 <mbedtls_mpi_free>
 114106c:	aa1603e0 	mov	x0, x22
 1141070:	97fffbd8 	bl	113ffd0 <mbedtls_mpi_free>
 1141074:	aa1c03e0 	mov	x0, x28
 1141078:	97fffbd6 	bl	113ffd0 <mbedtls_mpi_free>
    mbedtls_mpi_free( &T1 );
 114107c:	aa1503e0 	mov	x0, x21
 1141080:	97fffbd4 	bl	113ffd0 <mbedtls_mpi_free>
    mbedtls_platform_zeroize( TP2, sizeof( TP2 ) );
 1141084:	f94043e0 	ldr	x0, [sp, #128]
 1141088:	d2800301 	mov	x1, #0x18                  	// #24
 114108c:	94000684 	bl	1142a9c <mbedtls_platform_zeroize>
    return( ret );
 1141090:	17ffffe8 	b	1141030 <mbedtls_mpi_div_mpi+0xa4>
        if( R != NULL ) MBEDTLS_MPI_CHK( mbedtls_mpi_copy( R, A ) );
 1141094:	aa1803e1 	mov	x1, x24
 1141098:	aa1703e0 	mov	x0, x23
 114109c:	97fffc22 	bl	1140124 <mbedtls_mpi_copy>
 11410a0:	2a0003fb 	mov	w27, w0
 11410a4:	35fffe00 	cbnz	w0, 1141064 <mbedtls_mpi_div_mpi+0xd8>
 11410a8:	17ffffe1 	b	114102c <mbedtls_mpi_div_mpi+0xa0>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &X, A ) );
 11410ac:	aa1803e1 	mov	x1, x24
 11410b0:	aa1403e0 	mov	x0, x20
 11410b4:	97fffc1c 	bl	1140124 <mbedtls_mpi_copy>
 11410b8:	2a0003fb 	mov	w27, w0
 11410bc:	35fffd40 	cbnz	w0, 1141064 <mbedtls_mpi_div_mpi+0xd8>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &Y, B ) );
 11410c0:	f94037e1 	ldr	x1, [sp, #104]
 11410c4:	aa1603e0 	mov	x0, x22
 11410c8:	97fffc17 	bl	1140124 <mbedtls_mpi_copy>
 11410cc:	2a0003fb 	mov	w27, w0
 11410d0:	35fffca0 	cbnz	w0, 1141064 <mbedtls_mpi_div_mpi+0xd8>
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &Z, A->n + 2 ) );
 11410d4:	f9400701 	ldr	x1, [x24, #8]
 11410d8:	aa1c03e0 	mov	x0, x28
    X.s = Y.s = 1;
 11410dc:	790183f3 	strh	w19, [sp, #192]
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &Z, A->n + 2 ) );
 11410e0:	91000821 	add	x1, x1, #0x2
    X.s = Y.s = 1;
 11410e4:	7901b3f3 	strh	w19, [sp, #216]
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &Z, A->n + 2 ) );
 11410e8:	97fffbd5 	bl	114003c <mbedtls_mpi_grow>
 11410ec:	2a0003fb 	mov	w27, w0
 11410f0:	35fffba0 	cbnz	w0, 1141064 <mbedtls_mpi_div_mpi+0xd8>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &Z,  0 ) );
 11410f4:	aa1c03e0 	mov	x0, x28
 11410f8:	d2800001 	mov	x1, #0x0                   	// #0
 11410fc:	97fffc37 	bl	11401d8 <mbedtls_mpi_lset>
 1141100:	2a0003fb 	mov	w27, w0
 1141104:	35fffb00 	cbnz	w0, 1141064 <mbedtls_mpi_div_mpi+0xd8>
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &T1, 2 ) );
 1141108:	aa1503e0 	mov	x0, x21
 114110c:	d2800041 	mov	x1, #0x2                   	// #2
 1141110:	97fffbcb 	bl	114003c <mbedtls_mpi_grow>
 1141114:	2a0003fb 	mov	w27, w0
 1141118:	35fffa60 	cbnz	w0, 1141064 <mbedtls_mpi_div_mpi+0xd8>
    k = mbedtls_mpi_bitlen( &Y ) % biL;
 114111c:	aa1603e0 	mov	x0, x22
 1141120:	97fffc80 	bl	1140320 <mbedtls_mpi_bitlen>
 1141124:	92401400 	and	x0, x0, #0x3f
    if( k < biL - 1 )
 1141128:	f100fc1f 	cmp	x0, #0x3f
 114112c:	54000a60 	b.eq	1141278 <mbedtls_mpi_div_mpi+0x2ec>  // b.none
        k = biL - 1 - k;
 1141130:	d28007fa 	mov	x26, #0x3f                  	// #63
 1141134:	cb00035a 	sub	x26, x26, x0
        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &X, k ) );
 1141138:	aa1a03e1 	mov	x1, x26
 114113c:	aa1403e0 	mov	x0, x20
 1141140:	97fffcf9 	bl	1140524 <mbedtls_mpi_shift_l>
 1141144:	2a0003fb 	mov	w27, w0
 1141148:	35fff8e0 	cbnz	w0, 1141064 <mbedtls_mpi_div_mpi+0xd8>
        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &Y, k ) );
 114114c:	aa1a03e1 	mov	x1, x26
 1141150:	aa1603e0 	mov	x0, x22
 1141154:	97fffcf4 	bl	1140524 <mbedtls_mpi_shift_l>
 1141158:	2a0003fb 	mov	w27, w0
 114115c:	35fff840 	cbnz	w0, 1141064 <mbedtls_mpi_div_mpi+0xd8>
    n = X.n - 1;
 1141160:	f94067e0 	ldr	x0, [sp, #200]
 1141164:	f90033e0 	str	x0, [sp, #96]
    t = Y.n - 1;
 1141168:	f94073e0 	ldr	x0, [sp, #224]
 114116c:	f9003be0 	str	x0, [sp, #112]
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &Y, biL * ( n - t ) ) );
 1141170:	f94033e0 	ldr	x0, [sp, #96]
 1141174:	f9403be1 	ldr	x1, [sp, #112]
 1141178:	cb010013 	sub	x19, x0, x1
 114117c:	d37ae660 	lsl	x0, x19, #6
 1141180:	f9003fe0 	str	x0, [sp, #120]
 1141184:	aa0003e1 	mov	x1, x0
 1141188:	aa1603e0 	mov	x0, x22
 114118c:	97fffce6 	bl	1140524 <mbedtls_mpi_shift_l>
 1141190:	2a0003fb 	mov	w27, w0
 1141194:	35fff680 	cbnz	w0, 1141064 <mbedtls_mpi_div_mpi+0xd8>
        Z.p[n - t]++;
 1141198:	d37df273 	lsl	x19, x19, #3
    while( mbedtls_mpi_cmp_mpi( &X, &Y ) >= 0 )
 114119c:	aa1603e1 	mov	x1, x22
 11411a0:	aa1403e0 	mov	x0, x20
 11411a4:	97fffd7e 	bl	114079c <mbedtls_mpi_cmp_mpi>
 11411a8:	36f806c0 	tbz	w0, #31, 1141280 <mbedtls_mpi_div_mpi+0x2f4>
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &Y, biL * ( n - t ) ) );
 11411ac:	f9403fe1 	ldr	x1, [sp, #120]
 11411b0:	aa1603e0 	mov	x0, x22
 11411b4:	97fffd21 	bl	1140638 <mbedtls_mpi_shift_r>
 11411b8:	2a0003fb 	mov	w27, w0
 11411bc:	35fff540 	cbnz	w0, 1141064 <mbedtls_mpi_div_mpi+0xd8>
    n = X.n - 1;
 11411c0:	f94033e0 	ldr	x0, [sp, #96]
 11411c4:	d1002273 	sub	x19, x19, #0x8
 11411c8:	d1000400 	sub	x0, x0, #0x1
 11411cc:	f90033e0 	str	x0, [sp, #96]
    t = Y.n - 1;
 11411d0:	f9403be0 	ldr	x0, [sp, #112]
 11411d4:	d1000400 	sub	x0, x0, #0x1
 11411d8:	f9003fe0 	str	x0, [sp, #120]
        if( X.p[i] >= Y.p[t] )
 11411dc:	d37df000 	lsl	x0, x0, #3
 11411e0:	f9003be0 	str	x0, [sp, #112]
    return (mbedtls_mpi_uint) quotient;
 11411e4:	b0000060 	adrp	x0, 114e000 <ldelf_data+0x8000>
 11411e8:	f90047e0 	str	x0, [sp, #136]
        while( mbedtls_mpi_cmp_mpi( &T1, &T2 ) > 0 );
 11411ec:	910483e0 	add	x0, sp, #0x120
 11411f0:	f9004be0 	str	x0, [sp, #144]
    for( i = n; i > t ; i-- )
 11411f4:	f94033e0 	ldr	x0, [sp, #96]
 11411f8:	f9403fe1 	ldr	x1, [sp, #120]
 11411fc:	eb01001f 	cmp	x0, x1
 1141200:	54000568 	b.hi	11412ac <mbedtls_mpi_div_mpi+0x320>  // b.pmore
    if( Q != NULL )
 1141204:	b4000159 	cbz	x25, 114122c <mbedtls_mpi_div_mpi+0x2a0>
        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( Q, &Z ) );
 1141208:	aa1c03e1 	mov	x1, x28
 114120c:	aa1903e0 	mov	x0, x25
 1141210:	97fffbc5 	bl	1140124 <mbedtls_mpi_copy>
 1141214:	35001420 	cbnz	w0, 1141498 <mbedtls_mpi_div_mpi+0x50c>
        Q->s = A->s * B->s;
 1141218:	f94037e1 	ldr	x1, [sp, #104]
 114121c:	79400300 	ldrh	w0, [x24]
 1141220:	79400021 	ldrh	w1, [x1]
 1141224:	1b017c00 	mul	w0, w0, w1
 1141228:	79000320 	strh	w0, [x25]
    if( R != NULL )
 114122c:	b4fff1d7 	cbz	x23, 1141064 <mbedtls_mpi_div_mpi+0xd8>
        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &X, k ) );
 1141230:	aa1a03e1 	mov	x1, x26
 1141234:	aa1403e0 	mov	x0, x20
 1141238:	97fffd00 	bl	1140638 <mbedtls_mpi_shift_r>
 114123c:	350012e0 	cbnz	w0, 1141498 <mbedtls_mpi_div_mpi+0x50c>
        X.s = A->s;
 1141240:	79400300 	ldrh	w0, [x24]
        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( R, &X ) );
 1141244:	aa1403e1 	mov	x1, x20
        X.s = A->s;
 1141248:	790183e0 	strh	w0, [sp, #192]
        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( R, &X ) );
 114124c:	aa1703e0 	mov	x0, x23
 1141250:	97fffbb5 	bl	1140124 <mbedtls_mpi_copy>
 1141254:	35001220 	cbnz	w0, 1141498 <mbedtls_mpi_div_mpi+0x50c>
        if( mbedtls_mpi_cmp_int( R, 0 ) == 0 )
 1141258:	aa1703e0 	mov	x0, x23
 114125c:	d2800001 	mov	x1, #0x0                   	// #0
 1141260:	97fffd84 	bl	1140870 <mbedtls_mpi_cmp_int>
 1141264:	35fff000 	cbnz	w0, 1141064 <mbedtls_mpi_div_mpi+0xd8>
            R->s = 1;
 1141268:	52800020 	mov	w0, #0x1                   	// #1
        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( R, &X ) );
 114126c:	5280001b 	mov	w27, #0x0                   	// #0
            R->s = 1;
 1141270:	790002e0 	strh	w0, [x23]
 1141274:	17ffff7c 	b	1141064 <mbedtls_mpi_div_mpi+0xd8>
    else k = 0;
 1141278:	d280001a 	mov	x26, #0x0                   	// #0
 114127c:	17ffffb9 	b	1141160 <mbedtls_mpi_div_mpi+0x1d4>
        Z.p[n - t]++;
 1141280:	f94083e1 	ldr	x1, [sp, #256]
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &X, &X, &Y ) );
 1141284:	aa1603e2 	mov	x2, x22
        Z.p[n - t]++;
 1141288:	f8736820 	ldr	x0, [x1, x19]
 114128c:	91000400 	add	x0, x0, #0x1
 1141290:	f8336820 	str	x0, [x1, x19]
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &X, &X, &Y ) );
 1141294:	aa1403e1 	mov	x1, x20
 1141298:	aa1403e0 	mov	x0, x20
 114129c:	97fffe21 	bl	1140b20 <mbedtls_mpi_sub_mpi>
 11412a0:	2a0003fb 	mov	w27, w0
 11412a4:	34fff7c0 	cbz	w0, 114119c <mbedtls_mpi_div_mpi+0x210>
 11412a8:	17ffff6f 	b	1141064 <mbedtls_mpi_div_mpi+0xd8>
        if( X.p[i] >= Y.p[t] )
 11412ac:	f94033e0 	ldr	x0, [sp, #96]
 11412b0:	f9406be5 	ldr	x5, [sp, #208]
 11412b4:	d37df007 	lsl	x7, x0, #3
 11412b8:	f9403be2 	ldr	x2, [sp, #112]
 11412bc:	8b000ca9 	add	x9, x5, x0, lsl #3
 11412c0:	f94077e0 	ldr	x0, [sp, #232]
 11412c4:	d10020e8 	sub	x8, x7, #0x8
 11412c8:	f86768a1 	ldr	x1, [x5, x7]
 11412cc:	f8626802 	ldr	x2, [x0, x2]
 11412d0:	f94083e0 	ldr	x0, [sp, #256]
 11412d4:	eb02003f 	cmp	x1, x2
 11412d8:	8b130006 	add	x6, x0, x19
 11412dc:	54000b03 	b.cc	114143c <mbedtls_mpi_div_mpi+0x4b0>  // b.lo, b.ul, b.last
            Z.p[i - t - 1] = ~0;
 11412e0:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
 11412e4:	f8336801 	str	x1, [x0, x19]
        T2.p[0] = ( i < 2 ) ? 0 : X.p[i - 2];
 11412e8:	f94033e0 	ldr	x0, [sp, #96]
 11412ec:	f100041f 	cmp	x0, #0x1
 11412f0:	54000cc0 	b.eq	1141488 <mbedtls_mpi_div_mpi+0x4fc>  // b.none
 11412f4:	f85f0120 	ldur	x0, [x9, #-16]
 11412f8:	f9009fe0 	str	x0, [sp, #312]
        T2.p[1] = ( i < 1 ) ? 0 : X.p[i - 1];
 11412fc:	f86868a0 	ldr	x0, [x5, x8]
 1141300:	f900a3e0 	str	x0, [sp, #320]
        T2.p[2] = X.p[i];
 1141304:	f86768a0 	ldr	x0, [x5, x7]
 1141308:	f900a7e0 	str	x0, [sp, #328]
        Z.p[i - t - 1]++;
 114130c:	f94000c0 	ldr	x0, [x6]
 1141310:	91000400 	add	x0, x0, #0x1
 1141314:	f90000c0 	str	x0, [x6]
            Z.p[i - t - 1]--;
 1141318:	f94083e1 	ldr	x1, [sp, #256]
 114131c:	f8736820 	ldr	x0, [x1, x19]
 1141320:	d1000400 	sub	x0, x0, #0x1
 1141324:	f8336820 	str	x0, [x1, x19]
            MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &T1, 0 ) );
 1141328:	aa1503e0 	mov	x0, x21
 114132c:	d2800001 	mov	x1, #0x0                   	// #0
 1141330:	97fffbaa 	bl	11401d8 <mbedtls_mpi_lset>
 1141334:	35000b20 	cbnz	w0, 1141498 <mbedtls_mpi_div_mpi+0x50c>
            T1.p[0] = ( t < 1 ) ? 0 : Y.p[t - 1];
 1141338:	f9403fe0 	ldr	x0, [sp, #120]
 114133c:	f94077e1 	ldr	x1, [sp, #232]
 1141340:	b4000a80 	cbz	x0, 1141490 <mbedtls_mpi_div_mpi+0x504>
 1141344:	f9403be0 	ldr	x0, [sp, #112]
 1141348:	8b000020 	add	x0, x1, x0
 114134c:	f85f8002 	ldur	x2, [x0, #-8]
 1141350:	f9408fe0 	ldr	x0, [sp, #280]
 1141354:	f9000002 	str	x2, [x0]
            T1.p[1] = Y.p[t];
 1141358:	f9403be2 	ldr	x2, [sp, #112]
 114135c:	f8626821 	ldr	x1, [x1, x2]
 1141360:	f9000401 	str	x1, [x0, #8]
            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( &T1, &T1, Z.p[i - t - 1] ) );
 1141364:	f94083e0 	ldr	x0, [sp, #256]
 1141368:	aa1503e1 	mov	x1, x21
 114136c:	f8736802 	ldr	x2, [x0, x19]
 1141370:	aa1503e0 	mov	x0, x21
 1141374:	97fffe7f 	bl	1140d70 <mbedtls_mpi_mul_int>
 1141378:	35000900 	cbnz	w0, 1141498 <mbedtls_mpi_div_mpi+0x50c>
        while( mbedtls_mpi_cmp_mpi( &T1, &T2 ) > 0 );
 114137c:	f9404be1 	ldr	x1, [sp, #144]
 1141380:	aa1503e0 	mov	x0, x21
 1141384:	97fffd06 	bl	114079c <mbedtls_mpi_cmp_mpi>
 1141388:	7100001f 	cmp	w0, #0x0
 114138c:	54fffc6c 	b.gt	1141318 <mbedtls_mpi_div_mpi+0x38c>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( &T1, &Y, Z.p[i - t - 1] ) );
 1141390:	f94083e0 	ldr	x0, [sp, #256]
 1141394:	aa1603e1 	mov	x1, x22
 1141398:	f8736802 	ldr	x2, [x0, x19]
 114139c:	aa1503e0 	mov	x0, x21
 11413a0:	97fffe74 	bl	1140d70 <mbedtls_mpi_mul_int>
 11413a4:	350007a0 	cbnz	w0, 1141498 <mbedtls_mpi_div_mpi+0x50c>
        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &T1,  biL * ( i - t - 1 ) ) );
 11413a8:	d37df260 	lsl	x0, x19, #3
 11413ac:	f9004fe0 	str	x0, [sp, #152]
 11413b0:	aa0003e1 	mov	x1, x0
 11413b4:	aa1503e0 	mov	x0, x21
 11413b8:	97fffc5b 	bl	1140524 <mbedtls_mpi_shift_l>
 11413bc:	350006e0 	cbnz	w0, 1141498 <mbedtls_mpi_div_mpi+0x50c>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &X, &X, &T1 ) );
 11413c0:	aa1503e2 	mov	x2, x21
 11413c4:	aa1403e1 	mov	x1, x20
 11413c8:	aa1403e0 	mov	x0, x20
 11413cc:	97fffdd5 	bl	1140b20 <mbedtls_mpi_sub_mpi>
 11413d0:	35000640 	cbnz	w0, 1141498 <mbedtls_mpi_div_mpi+0x50c>
        if( mbedtls_mpi_cmp_int( &X, 0 ) < 0 )
 11413d4:	aa1403e0 	mov	x0, x20
 11413d8:	d2800001 	mov	x1, #0x0                   	// #0
 11413dc:	97fffd25 	bl	1140870 <mbedtls_mpi_cmp_int>
 11413e0:	36f80240 	tbz	w0, #31, 1141428 <mbedtls_mpi_div_mpi+0x49c>
            MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &T1, &Y ) );
 11413e4:	aa1603e1 	mov	x1, x22
 11413e8:	aa1503e0 	mov	x0, x21
 11413ec:	97fffb4e 	bl	1140124 <mbedtls_mpi_copy>
 11413f0:	35000540 	cbnz	w0, 1141498 <mbedtls_mpi_div_mpi+0x50c>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &T1, biL * ( i - t - 1 ) ) );
 11413f4:	d37df261 	lsl	x1, x19, #3
 11413f8:	aa1503e0 	mov	x0, x21
 11413fc:	97fffc4a 	bl	1140524 <mbedtls_mpi_shift_l>
 1141400:	350004c0 	cbnz	w0, 1141498 <mbedtls_mpi_div_mpi+0x50c>
            MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &X, &X, &T1 ) );
 1141404:	aa1503e2 	mov	x2, x21
 1141408:	aa1403e1 	mov	x1, x20
 114140c:	aa1403e0 	mov	x0, x20
 1141410:	97fffda4 	bl	1140aa0 <mbedtls_mpi_add_mpi>
 1141414:	35000420 	cbnz	w0, 1141498 <mbedtls_mpi_div_mpi+0x50c>
            Z.p[i - t - 1]--;
 1141418:	f94083e1 	ldr	x1, [sp, #256]
 114141c:	f8736820 	ldr	x0, [x1, x19]
 1141420:	d1000400 	sub	x0, x0, #0x1
 1141424:	f8336820 	str	x0, [x1, x19]
    for( i = n; i > t ; i-- )
 1141428:	f94033e0 	ldr	x0, [sp, #96]
 114142c:	d1002273 	sub	x19, x19, #0x8
 1141430:	d1000400 	sub	x0, x0, #0x1
 1141434:	f90033e0 	str	x0, [sp, #96]
 1141438:	17ffff6f 	b	11411f4 <mbedtls_mpi_div_mpi+0x268>
            Z.p[i - t - 1] = mbedtls_int_div_int( X.p[i], X.p[i - 1],
 114143c:	f86868a0 	ldr	x0, [x5, x8]
    if( 0 == d || u1 >= d )
 1141440:	b4000202 	cbz	x2, 1141480 <mbedtls_mpi_div_mpi+0x4f4>
    quotient = dividend / d;
 1141444:	d2800003 	mov	x3, #0x0                   	// #0
 1141448:	a909a7e5 	stp	x5, x9, [sp, #152]
 114144c:	a90a9be7 	stp	x7, x6, [sp, #168]
 1141450:	f9005fe8 	str	x8, [sp, #184]
 1141454:	97ff080b 	bl	1103480 <__udivti3>
 1141458:	aa0003e2 	mov	x2, x0
    return (mbedtls_mpi_uint) quotient;
 114145c:	f100003f 	cmp	x1, #0x0
 1141460:	f94047e0 	ldr	x0, [sp, #136]
 1141464:	a949a7e5 	ldp	x5, x9, [sp, #152]
 1141468:	f9400000 	ldr	x0, [x0]
 114146c:	a94a9be7 	ldp	x7, x6, [sp, #168]
 1141470:	9a821000 	csel	x0, x0, x2, ne  // ne = any
 1141474:	f9405fe8 	ldr	x8, [sp, #184]
            Z.p[i - t - 1] = mbedtls_int_div_int( X.p[i], X.p[i - 1],
 1141478:	f90000c0 	str	x0, [x6]
 114147c:	17ffff9b 	b	11412e8 <mbedtls_mpi_div_mpi+0x35c>
        return ( ~0 );
 1141480:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
 1141484:	17fffffd 	b	1141478 <mbedtls_mpi_div_mpi+0x4ec>
        T2.p[0] = ( i < 2 ) ? 0 : X.p[i - 2];
 1141488:	d2800000 	mov	x0, #0x0                   	// #0
 114148c:	17ffff9b 	b	11412f8 <mbedtls_mpi_div_mpi+0x36c>
            T1.p[0] = ( t < 1 ) ? 0 : Y.p[t - 1];
 1141490:	d2800002 	mov	x2, #0x0                   	// #0
 1141494:	17ffffaf 	b	1141350 <mbedtls_mpi_div_mpi+0x3c4>
 1141498:	2a0003fb 	mov	w27, w0
 114149c:	17fffef2 	b	1141064 <mbedtls_mpi_div_mpi+0xd8>
        return( MBEDTLS_ERR_MPI_DIVISION_BY_ZERO );
 11414a0:	1280017b 	mov	w27, #0xfffffff4            	// #-12
 11414a4:	17fffee3 	b	1141030 <mbedtls_mpi_div_mpi+0xa4>

00000000011414a8 <mbedtls_mpi_div_int>:
{
 11414a8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    p[0] = ( b < 0 ) ? -b : b;
 11414ac:	f100007f 	cmp	x3, #0x0
 11414b0:	da83a464 	cneg	x4, x3, lt  // lt = tstop
{
 11414b4:	910003fd 	mov	x29, sp
    p[0] = ( b < 0 ) ? -b : b;
 11414b8:	f9000be4 	str	x4, [sp, #16]
    _B.s = ( b < 0 ) ? -1 : 1;
 11414bc:	52800024 	mov	w4, #0x1                   	// #1
 11414c0:	5a84a484 	cneg	w4, w4, lt  // lt = tstop
    _B.n = 1;
 11414c4:	d2800023 	mov	x3, #0x1                   	// #1
 11414c8:	f90013e3 	str	x3, [sp, #32]
    _B.p = p;
 11414cc:	910043e3 	add	x3, sp, #0x10
    _B.s = ( b < 0 ) ? -1 : 1;
 11414d0:	790033e4 	strh	w4, [sp, #24]
    _B.p = p;
 11414d4:	f90017e3 	str	x3, [sp, #40]
    return( mbedtls_mpi_div_mpi( Q, R, A, &_B ) );
 11414d8:	910063e3 	add	x3, sp, #0x18
 11414dc:	97fffeac 	bl	1140f8c <mbedtls_mpi_div_mpi>
}
 11414e0:	a8c37bfd 	ldp	x29, x30, [sp], #48
 11414e4:	d65f03c0 	ret

00000000011414e8 <mbedtls_mpi_mod_mpi>:
{
 11414e8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 11414ec:	aa0103e7 	mov	x7, x1
    if( mbedtls_mpi_cmp_int( B, 0 ) < 0 )
 11414f0:	d2800001 	mov	x1, #0x0                   	// #0
{
 11414f4:	910003fd 	mov	x29, sp
 11414f8:	a90153f3 	stp	x19, x20, [sp, #16]
 11414fc:	aa0003f3 	mov	x19, x0
    if( mbedtls_mpi_cmp_int( B, 0 ) < 0 )
 1141500:	aa0203e0 	mov	x0, x2
{
 1141504:	f90013f5 	str	x21, [sp, #32]
 1141508:	aa0203f5 	mov	x21, x2
    if( mbedtls_mpi_cmp_int( B, 0 ) < 0 )
 114150c:	97fffcd9 	bl	1140870 <mbedtls_mpi_cmp_int>
 1141510:	37f80420 	tbnz	w0, #31, 1141594 <mbedtls_mpi_mod_mpi+0xac>
    MBEDTLS_MPI_CHK( mbedtls_mpi_div_mpi( NULL, R, A, B ) );
 1141514:	aa1503e3 	mov	x3, x21
 1141518:	aa0703e2 	mov	x2, x7
 114151c:	aa1303e1 	mov	x1, x19
 1141520:	d2800000 	mov	x0, #0x0                   	// #0
 1141524:	97fffe9a 	bl	1140f8c <mbedtls_mpi_div_mpi>
 1141528:	2a0003f4 	mov	w20, w0
 114152c:	34000160 	cbz	w0, 1141558 <mbedtls_mpi_mod_mpi+0x70>
}
 1141530:	2a1403e0 	mov	w0, w20
 1141534:	a94153f3 	ldp	x19, x20, [sp, #16]
 1141538:	f94013f5 	ldr	x21, [sp, #32]
 114153c:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1141540:	d65f03c0 	ret
      MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( R, R, B ) );
 1141544:	aa1503e2 	mov	x2, x21
 1141548:	aa1303e1 	mov	x1, x19
 114154c:	aa1303e0 	mov	x0, x19
 1141550:	97fffd54 	bl	1140aa0 <mbedtls_mpi_add_mpi>
 1141554:	350001c0 	cbnz	w0, 114158c <mbedtls_mpi_mod_mpi+0xa4>
    while( mbedtls_mpi_cmp_int( R, 0 ) < 0 )
 1141558:	aa1303e0 	mov	x0, x19
 114155c:	d2800001 	mov	x1, #0x0                   	// #0
 1141560:	97fffcc4 	bl	1140870 <mbedtls_mpi_cmp_int>
 1141564:	37ffff00 	tbnz	w0, #31, 1141544 <mbedtls_mpi_mod_mpi+0x5c>
    while( mbedtls_mpi_cmp_mpi( R, B ) >= 0 )
 1141568:	aa1503e1 	mov	x1, x21
 114156c:	aa1303e0 	mov	x0, x19
 1141570:	97fffc8b 	bl	114079c <mbedtls_mpi_cmp_mpi>
 1141574:	37fffde0 	tbnz	w0, #31, 1141530 <mbedtls_mpi_mod_mpi+0x48>
      MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( R, R, B ) );
 1141578:	aa1503e2 	mov	x2, x21
 114157c:	aa1303e1 	mov	x1, x19
 1141580:	aa1303e0 	mov	x0, x19
 1141584:	97fffd67 	bl	1140b20 <mbedtls_mpi_sub_mpi>
 1141588:	34ffff00 	cbz	w0, 1141568 <mbedtls_mpi_mod_mpi+0x80>
 114158c:	2a0003f4 	mov	w20, w0
 1141590:	17ffffe8 	b	1141530 <mbedtls_mpi_mod_mpi+0x48>
        return( MBEDTLS_ERR_MPI_NEGATIVE_VALUE );
 1141594:	12800134 	mov	w20, #0xfffffff6            	// #-10
 1141598:	17ffffe6 	b	1141530 <mbedtls_mpi_mod_mpi+0x48>

000000000114159c <mbedtls_mpi_mod_int>:
{
 114159c:	aa0003e4 	mov	x4, x0
    if( b == 0 )
 11415a0:	f100005f 	cmp	x2, #0x0
 11415a4:	b40001e2 	cbz	x2, 11415e0 <mbedtls_mpi_mod_int+0x44>
    if( b < 0 )
 11415a8:	5400020b 	b.lt	11415e8 <mbedtls_mpi_mod_int+0x4c>  // b.tstop
    if( b == 1 )
 11415ac:	f100045f 	cmp	x2, #0x1
 11415b0:	54000081 	b.ne	11415c0 <mbedtls_mpi_mod_int+0x24>  // b.any
        *r = 0;
 11415b4:	f900001f 	str	xzr, [x0]
        return( 0 );
 11415b8:	52800000 	mov	w0, #0x0                   	// #0
}
 11415bc:	d65f03c0 	ret
    if( b == 2 )
 11415c0:	f100085f 	cmp	x2, #0x2
 11415c4:	540000c1 	b.ne	11415dc <mbedtls_mpi_mod_int+0x40>  // b.any
        *r = A->p[0] & 1;
 11415c8:	f9400820 	ldr	x0, [x1, #16]
 11415cc:	f9400000 	ldr	x0, [x0]
 11415d0:	92400000 	and	x0, x0, #0x1
 11415d4:	f9000080 	str	x0, [x4]
 11415d8:	17fffff8 	b	11415b8 <mbedtls_mpi_mod_int+0x1c>
 11415dc:	17fffa3c 	b	113fecc <mbedtls_mpi_mod_int.part.0>
        return( MBEDTLS_ERR_MPI_DIVISION_BY_ZERO );
 11415e0:	12800160 	mov	w0, #0xfffffff4            	// #-12
 11415e4:	17fffff6 	b	11415bc <mbedtls_mpi_mod_int+0x20>
        return( MBEDTLS_ERR_MPI_NEGATIVE_VALUE );
 11415e8:	12800120 	mov	w0, #0xfffffff6            	// #-10
 11415ec:	17fffff4 	b	11415bc <mbedtls_mpi_mod_int+0x20>

00000000011415f0 <mbedtls_mpi_write_string>:
{
 11415f0:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
 11415f4:	910003fd 	mov	x29, sp
 11415f8:	a90153f3 	stp	x19, x20, [sp, #16]
 11415fc:	a9025bf5 	stp	x21, x22, [sp, #32]
 1141600:	a90363f7 	stp	x23, x24, [sp, #48]
 1141604:	93407c38 	sxtw	x24, w1
    if( radix < 2 || radix > 16 )
 1141608:	51000b01 	sub	w1, w24, #0x2
{
 114160c:	a9046bf9 	stp	x25, x26, [sp, #64]
    if( radix < 2 || radix > 16 )
 1141610:	7100383f 	cmp	w1, #0xe
{
 1141614:	a90573fb 	stp	x27, x28, [sp, #80]
    if( radix < 2 || radix > 16 )
 1141618:	54001028 	b.hi	114181c <mbedtls_mpi_write_string+0x22c>  // b.pmore
 114161c:	aa0003e6 	mov	x6, x0
 1141620:	aa0203f6 	mov	x22, x2
 1141624:	aa0303f7 	mov	x23, x3
 1141628:	aa0403f5 	mov	x21, x4
    n = mbedtls_mpi_bitlen( X ); /* Number of bits necessary to present `n`. */
 114162c:	97fffb3d 	bl	1140320 <mbedtls_mpi_bitlen>
    if( radix >=  4 ) n >>= 1;   /* Number of 4-adic digits necessary to present
 1141630:	71000f1f 	cmp	w24, #0x3
 1141634:	5400004d 	b.le	114163c <mbedtls_mpi_write_string+0x4c>
 1141638:	d341fc00 	lsr	x0, x0, #1
    if( radix >= 16 ) n >>= 1;   /* Number of hexadecimal digits necessary to
 114163c:	7100431f 	cmp	w24, #0x10
 1141640:	54000041 	b.ne	1141648 <mbedtls_mpi_write_string+0x58>  // b.any
 1141644:	d341fc00 	lsr	x0, x0, #1
    n += ( n & 1 ); /* Make n even to have enough space for hexadecimal writing,
 1141648:	91001005 	add	x5, x0, #0x4
 114164c:	927ff8a5 	and	x5, x5, #0xfffffffffffffffe
    if( buflen < n )
 1141650:	eb1700bf 	cmp	x5, x23
 1141654:	54000169 	b.ls	1141680 <mbedtls_mpi_write_string+0x90>  // b.plast
        return( MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL );
 1141658:	128000f4 	mov	w20, #0xfffffff8            	// #-8
        *olen = n;
 114165c:	f90002a5 	str	x5, [x21]
}
 1141660:	2a1403e0 	mov	w0, w20
 1141664:	a94153f3 	ldp	x19, x20, [sp, #16]
 1141668:	a9425bf5 	ldp	x21, x22, [sp, #32]
 114166c:	a94363f7 	ldp	x23, x24, [sp, #48]
 1141670:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1141674:	a94573fb 	ldp	x27, x28, [sp, #80]
 1141678:	a8c87bfd 	ldp	x29, x30, [sp], #128
 114167c:	d65f03c0 	ret
    mbedtls_mpi_init_mempool( &T );
 1141680:	9101a3fb 	add	x27, sp, #0x68
        *p++ = '-';
 1141684:	aa1603f3 	mov	x19, x22
    mbedtls_mpi_init_mempool( &T );
 1141688:	aa1b03e0 	mov	x0, x27
 114168c:	97fffa47 	bl	113ffa8 <mbedtls_mpi_init_mempool>
    if( X->s == -1 )
 1141690:	79c000c0 	ldrsh	w0, [x6]
 1141694:	3100041f 	cmn	w0, #0x1
 1141698:	54000081 	b.ne	11416a8 <mbedtls_mpi_write_string+0xb8>  // b.any
        buflen--;
 114169c:	d10006f7 	sub	x23, x23, #0x1
        *p++ = '-';
 11416a0:	528005a0 	mov	w0, #0x2d                  	// #45
 11416a4:	38001660 	strb	w0, [x19], #1
    if( radix == 16 )
 11416a8:	7100431f 	cmp	w24, #0x10
 11416ac:	54000561 	b.ne	1141758 <mbedtls_mpi_write_string+0x168>  // b.any
        for( i = X->n, k = 0; i > 0; i-- )
 11416b0:	f94004c0 	ldr	x0, [x6, #8]
                *(p++) = "0123456789ABCDEF" [c / 16];
 11416b4:	900000c4 	adrp	x4, 1159000 <Worder+0x2854>
 11416b8:	9126c084 	add	x4, x4, #0x9b0
        for( i = X->n, k = 0; i > 0; i-- )
 11416bc:	d2800002 	mov	x2, #0x0                   	// #0
 11416c0:	b5000100 	cbnz	x0, 11416e0 <mbedtls_mpi_write_string+0xf0>
    *p++ = '\0';
 11416c4:	3800167f 	strb	wzr, [x19], #1
    *olen = p - buf;
 11416c8:	52800014 	mov	w20, #0x0                   	// #0
 11416cc:	cb160273 	sub	x19, x19, x22
 11416d0:	f90002b3 	str	x19, [x21]
    mbedtls_mpi_free( &T );
 11416d4:	aa1b03e0 	mov	x0, x27
 11416d8:	97fffa3e 	bl	113ffd0 <mbedtls_mpi_free>
    return( ret );
 11416dc:	17ffffe1 	b	1141660 <mbedtls_mpi_write_string+0x70>
                c = ( X->p[i - 1] >> ( ( j - 1 ) << 3) ) & 0xFF;
 11416e0:	d37df005 	lsl	x5, x0, #3
 11416e4:	d2800103 	mov	x3, #0x8                   	// #8
 11416e8:	d10020a5 	sub	x5, x5, #0x8
 11416ec:	f94008c8 	ldr	x8, [x6, #16]
 11416f0:	531d7061 	lsl	w1, w3, #3
 11416f4:	51002027 	sub	w7, w1, #0x8
                if( c == 0 && k == 0 && ( i + j ) != 2 )
 11416f8:	52000042 	eor	w2, w2, #0x1
                c = ( X->p[i - 1] >> ( ( j - 1 ) << 3) ) & 0xFF;
 11416fc:	f8656901 	ldr	x1, [x8, x5]
 1141700:	9ac72421 	lsr	x1, x1, x7
                if( c == 0 && k == 0 && ( i + j ) != 2 )
 1141704:	72001c27 	ands	w7, w1, #0xff
 1141708:	1a9f0042 	csel	w2, w2, wzr, eq  // eq = none
 114170c:	34000082 	cbz	w2, 114171c <mbedtls_mpi_write_string+0x12c>
 1141710:	8b030002 	add	x2, x0, x3
 1141714:	f100085f 	cmp	x2, #0x2
 1141718:	540001c1 	b.ne	1141750 <mbedtls_mpi_write_string+0x160>  // b.any
                *(p++) = "0123456789ABCDEF" [c / 16];
 114171c:	d3441ce2 	ubfx	x2, x7, #4, #4
                *(p++) = "0123456789ABCDEF" [c % 16];
 1141720:	92400c21 	and	x1, x1, #0xf
                *(p++) = "0123456789ABCDEF" [c / 16];
 1141724:	38626887 	ldrb	w7, [x4, x2]
 1141728:	aa1303e2 	mov	x2, x19
                *(p++) = "0123456789ABCDEF" [c % 16];
 114172c:	38616881 	ldrb	w1, [x4, x1]
                *(p++) = "0123456789ABCDEF" [c / 16];
 1141730:	38002447 	strb	w7, [x2], #2
                *(p++) = "0123456789ABCDEF" [c % 16];
 1141734:	39000661 	strb	w1, [x19, #1]
 1141738:	aa0203f3 	mov	x19, x2
                k = 1;
 114173c:	d2800022 	mov	x2, #0x1                   	// #1
            for( j = ciL; j > 0; j-- )
 1141740:	f1000463 	subs	x3, x3, #0x1
 1141744:	54fffd41 	b.ne	11416ec <mbedtls_mpi_write_string+0xfc>  // b.any
        for( i = X->n, k = 0; i > 0; i-- )
 1141748:	d1000400 	sub	x0, x0, #0x1
 114174c:	17ffffdd 	b	11416c0 <mbedtls_mpi_write_string+0xd0>
 1141750:	d2800002 	mov	x2, #0x0                   	// #0
 1141754:	17fffffb 	b	1141740 <mbedtls_mpi_write_string+0x150>
        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &T, X ) );
 1141758:	aa0603e1 	mov	x1, x6
 114175c:	aa1b03e0 	mov	x0, x27
 1141760:	97fffa71 	bl	1140124 <mbedtls_mpi_copy>
 1141764:	2a0003f4 	mov	w20, w0
 1141768:	35fffb60 	cbnz	w0, 11416d4 <mbedtls_mpi_write_string+0xe4>
        if( T.s == -1 )
 114176c:	79c0d3e0 	ldrsh	w0, [sp, #104]
 1141770:	3100041f 	cmn	w0, #0x1
 1141774:	54000061 	b.ne	1141780 <mbedtls_mpi_write_string+0x190>  // b.any
            T.s = 1;
 1141778:	52800020 	mov	w0, #0x1                   	// #1
 114177c:	7900d3e0 	strh	w0, [sp, #104]
    char *p_end = *p + buflen;
 1141780:	8b170279 	add	x25, x19, x23
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_int( &r, X, radix ) );
 1141784:	910183fa 	add	x26, sp, #0x60
    char *p_end = *p + buflen;
 1141788:	aa1903fc 	mov	x28, x25
        if( length >= buflen )
 114178c:	cb1c0320 	sub	x0, x25, x28
 1141790:	eb0002ff 	cmp	x23, x0
 1141794:	54000489 	b.ls	1141824 <mbedtls_mpi_write_string+0x234>  // b.plast
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_int( &r, X, radix ) );
 1141798:	aa1803e2 	mov	x2, x24
 114179c:	aa1b03e1 	mov	x1, x27
 11417a0:	aa1a03e0 	mov	x0, x26
 11417a4:	97ffff7e 	bl	114159c <mbedtls_mpi_mod_int>
 11417a8:	2a0003f4 	mov	w20, w0
 11417ac:	35fff940 	cbnz	w0, 11416d4 <mbedtls_mpi_write_string+0xe4>
        MBEDTLS_MPI_CHK( mbedtls_mpi_div_int( X, NULL, X, radix ) );
 11417b0:	aa1803e3 	mov	x3, x24
 11417b4:	aa1b03e2 	mov	x2, x27
 11417b8:	aa1b03e0 	mov	x0, x27
 11417bc:	d2800001 	mov	x1, #0x0                   	// #0
 11417c0:	97ffff3a 	bl	11414a8 <mbedtls_mpi_div_int>
 11417c4:	2a0003f4 	mov	w20, w0
 11417c8:	35fff860 	cbnz	w0, 11416d4 <mbedtls_mpi_write_string+0xe4>
        if( r < 0xA )
 11417cc:	f94033e2 	ldr	x2, [sp, #96]
 11417d0:	12001c40 	and	w0, w2, #0xff
            *(--p_end) = (char)( '0' + r );
 11417d4:	f100245f 	cmp	x2, #0x9
 11417d8:	1100c001 	add	w1, w0, #0x30
 11417dc:	1100dc00 	add	w0, w0, #0x37
 11417e0:	12001c21 	and	w1, w1, #0xff
 11417e4:	12001c00 	and	w0, w0, #0xff
 11417e8:	1a818000 	csel	w0, w0, w1, hi  // hi = pmore
 11417ec:	381fff80 	strb	w0, [x28, #-1]!
    } while( mbedtls_mpi_cmp_int( X, 0 ) != 0 );
 11417f0:	d2800001 	mov	x1, #0x0                   	// #0
 11417f4:	aa1b03e0 	mov	x0, x27
 11417f8:	cb1c0334 	sub	x20, x25, x28
 11417fc:	97fffc1d 	bl	1140870 <mbedtls_mpi_cmp_int>
 1141800:	35fffc60 	cbnz	w0, 114178c <mbedtls_mpi_write_string+0x19c>
    memmove( *p, p_end, length );
 1141804:	aa1303e0 	mov	x0, x19
 1141808:	aa1403e2 	mov	x2, x20
 114180c:	aa1c03e1 	mov	x1, x28
    *p += length;
 1141810:	8b140273 	add	x19, x19, x20
    memmove( *p, p_end, length );
 1141814:	9400091c 	bl	1143c84 <memmove>
    *p += length;
 1141818:	17ffffab 	b	11416c4 <mbedtls_mpi_write_string+0xd4>
        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );
 114181c:	12800074 	mov	w20, #0xfffffffc            	// #-4
 1141820:	17ffff90 	b	1141660 <mbedtls_mpi_write_string+0x70>
            return( MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL );
 1141824:	128000f4 	mov	w20, #0xfffffff8            	// #-8
 1141828:	17ffffab 	b	11416d4 <mbedtls_mpi_write_string+0xe4>

000000000114182c <mpi_check_small_factors>:
 * 1: certain prime
 * MBEDTLS_ERR_MPI_NOT_ACCEPTABLE: certain non-prime
 * other negative: error
 */
static int mpi_check_small_factors( const mbedtls_mpi *X )
{
 114182c:	aa0003e9 	mov	x9, x0
    int ret = 0;
    size_t i;
    mbedtls_mpi_uint r;

    if( ( X->p[0] & 1 ) == 0 )
 1141830:	f9400800 	ldr	x0, [x0, #16]
 1141834:	f9400000 	ldr	x0, [x0]
 1141838:	360003c0 	tbz	w0, #0, 11418b0 <mpi_check_small_factors+0x84>
{
 114183c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1141840:	f0000068 	adrp	x8, 1150000 <Te4+0x258>
 1141844:	913a6108 	add	x8, x8, #0xe98
    for( i = 0; small_prime[i] > 0; i++ )
    {
        if( mbedtls_mpi_cmp_int( X, small_prime[i] ) <= 0 )
            return( 1 );

        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_int( &r, X, small_prime[i] ) );
 1141848:	910063ea 	add	x10, sp, #0x18
{
 114184c:	910003fd 	mov	x29, sp
    for( i = 0; small_prime[i] > 0; i++ )
 1141850:	b9400107 	ldr	w7, [x8]
 1141854:	710000ff 	cmp	w7, #0x0
 1141858:	5400008c 	b.gt	1141868 <mpi_check_small_factors+0x3c>

        if( r == 0 )
            return( MBEDTLS_ERR_MPI_NOT_ACCEPTABLE );
    }

cleanup:
 114185c:	52800000 	mov	w0, #0x0                   	// #0
    return( ret );
}
 1141860:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1141864:	d65f03c0 	ret
        if( mbedtls_mpi_cmp_int( X, small_prime[i] ) <= 0 )
 1141868:	93407ce7 	sxtw	x7, w7
 114186c:	aa0903e0 	mov	x0, x9
 1141870:	aa0703e1 	mov	x1, x7
 1141874:	97fffbff 	bl	1140870 <mbedtls_mpi_cmp_int>
 1141878:	7100001f 	cmp	w0, #0x0
 114187c:	5400016d 	b.le	11418a8 <mpi_check_small_factors+0x7c>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_int( &r, X, small_prime[i] ) );
 1141880:	aa0703e2 	mov	x2, x7
 1141884:	aa0903e1 	mov	x1, x9
 1141888:	aa0a03e0 	mov	x0, x10
 114188c:	97ffff44 	bl	114159c <mbedtls_mpi_mod_int>
 1141890:	35fffe80 	cbnz	w0, 1141860 <mpi_check_small_factors+0x34>
        if( r == 0 )
 1141894:	f9400fe0 	ldr	x0, [sp, #24]
 1141898:	91001108 	add	x8, x8, #0x4
 114189c:	b5fffda0 	cbnz	x0, 1141850 <mpi_check_small_factors+0x24>
            return( MBEDTLS_ERR_MPI_NOT_ACCEPTABLE );
 11418a0:	128001a0 	mov	w0, #0xfffffff2            	// #-14
 11418a4:	17ffffef 	b	1141860 <mpi_check_small_factors+0x34>
            return( 1 );
 11418a8:	52800020 	mov	w0, #0x1                   	// #1
 11418ac:	17ffffed 	b	1141860 <mpi_check_small_factors+0x34>
        return( MBEDTLS_ERR_MPI_NOT_ACCEPTABLE );
 11418b0:	128001a0 	mov	w0, #0xfffffff2            	// #-14
}
 11418b4:	d65f03c0 	ret

00000000011418b8 <mbedtls_mpi_montg_init>:
    mbedtls_mpi_uint x, m0 = N->p[0];
 11418b8:	f9400821 	ldr	x1, [x1, #16]
    x += ( ( m0 + 2 ) & 4 ) << 1;
 11418bc:	52800082 	mov	w2, #0x4                   	// #4
        x *= ( 2 - ( m0 * x ) );
 11418c0:	d2800045 	mov	x5, #0x2                   	// #2
    mbedtls_mpi_uint x, m0 = N->p[0];
 11418c4:	f9400023 	ldr	x3, [x1]
    x += ( ( m0 + 2 ) & 4 ) << 1;
 11418c8:	91000861 	add	x1, x3, #0x2
 11418cc:	d37ff821 	lsl	x1, x1, #1
 11418d0:	927d0021 	and	x1, x1, #0x8
 11418d4:	8b030021 	add	x1, x1, x3
        x *= ( 2 - ( m0 * x ) );
 11418d8:	9b019464 	msub	x4, x3, x1, x5
    for( i = biL; i >= 8; i /= 2 )
 11418dc:	71000442 	subs	w2, w2, #0x1
        x *= ( 2 - ( m0 * x ) );
 11418e0:	9b047c21 	mul	x1, x1, x4
    for( i = biL; i >= 8; i /= 2 )
 11418e4:	54ffffa1 	b.ne	11418d8 <mbedtls_mpi_montg_init+0x20>  // b.any
    *mm = ~x + 1;
 11418e8:	cb0103e1 	neg	x1, x1
 11418ec:	f9000001 	str	x1, [x0]
}
 11418f0:	d65f03c0 	ret

00000000011418f4 <mbedtls_mpi_montmul>:
{
 11418f4:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 11418f8:	910003fd 	mov	x29, sp
 11418fc:	a90153f3 	stp	x19, x20, [sp, #16]
 1141900:	aa0203f3 	mov	x19, x2
 1141904:	a9025bf5 	stp	x21, x22, [sp, #32]
 1141908:	aa0003f5 	mov	x21, x0
    if( T->n < N->n + 1 || T->p == NULL )
 114190c:	f9400660 	ldr	x0, [x19, #8]
{
 1141910:	a90363f7 	stp	x23, x24, [sp, #48]
    if( T->n < N->n + 1 || T->p == NULL )
 1141914:	f9400482 	ldr	x2, [x4, #8]
{
 1141918:	f90023f9 	str	x25, [sp, #64]
    if( T->n < N->n + 1 || T->p == NULL )
 114191c:	91000400 	add	x0, x0, #0x1
 1141920:	eb00005f 	cmp	x2, x0
 1141924:	540007c3 	b.cc	1141a1c <mbedtls_mpi_montmul+0x128>  // b.lo, b.ul, b.last
 1141928:	f9400880 	ldr	x0, [x4, #16]
 114192c:	aa0403f6 	mov	x22, x4
 1141930:	b4000760 	cbz	x0, 1141a1c <mbedtls_mpi_montmul+0x128>
 1141934:	aa0103f8 	mov	x24, x1
 1141938:	aa0303f7 	mov	x23, x3
    memset( T->p, 0, T->n * ciL );
 114193c:	d37df042 	lsl	x2, x2, #3
 1141940:	52800001 	mov	w1, #0x0                   	// #0
 1141944:	940008e7 	bl	1143ce0 <memset>
    for( i = 0; i < n; i++ )
 1141948:	d2800014 	mov	x20, #0x0                   	// #0
    n = N->n;
 114194c:	f940066d 	ldr	x13, [x19, #8]
    m = ( B->n < n ) ? B->n : n;
 1141950:	f9400700 	ldr	x0, [x24, #8]
        *d++ = u0; d[n + 1] = 0;
 1141954:	910005ac 	add	x12, x13, #0x1
    d = T->p;
 1141958:	f9400ad9 	ldr	x25, [x22, #16]
    m = ( B->n < n ) ? B->n : n;
 114195c:	eb0d001f 	cmp	x0, x13
        *d++ = u0; d[n + 1] = 0;
 1141960:	d37df18c 	lsl	x12, x12, #3
    m = ( B->n < n ) ? B->n : n;
 1141964:	9a8d900f 	csel	x15, x0, x13, ls  // ls = plast
    d = T->p;
 1141968:	aa1903eb 	mov	x11, x25
    for( i = 0; i < n; i++ )
 114196c:	eb0d029f 	cmp	x20, x13
 1141970:	f9400aa0 	ldr	x0, [x21, #16]
 1141974:	54000281 	b.ne	11419c4 <mbedtls_mpi_montmul+0xd0>  // b.any
    memcpy( A->p, d, ( n + 1 ) * ciL );
 1141978:	aa0c03e2 	mov	x2, x12
 114197c:	d1002181 	sub	x1, x12, #0x8
 1141980:	8b010321 	add	x1, x25, x1
 1141984:	97ff0683 	bl	1103390 <memcpy>
    if( mbedtls_mpi_cmp_abs( A, N ) >= 0 )
 1141988:	aa1303e1 	mov	x1, x19
 114198c:	aa1503e0 	mov	x0, x21
 1141990:	97fffb5c 	bl	1140700 <mbedtls_mpi_cmp_abs>
 1141994:	37f803e0 	tbnz	w0, #31, 1141a10 <mbedtls_mpi_montmul+0x11c>
        mpi_sub_hlp( n, N->p, A->p );
 1141998:	f9400a61 	ldr	x1, [x19, #16]
 114199c:	f9400aa2 	ldr	x2, [x21, #16]
        mpi_sub_hlp( n, A->p, T->p );
 11419a0:	aa1403e0 	mov	x0, x20
 11419a4:	97fff831 	bl	113fa68 <mpi_sub_hlp>
    return( 0 );
 11419a8:	52800000 	mov	w0, #0x0                   	// #0
}
 11419ac:	a94153f3 	ldp	x19, x20, [sp, #16]
 11419b0:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11419b4:	a94363f7 	ldp	x23, x24, [sp, #48]
 11419b8:	f94023f9 	ldr	x25, [sp, #64]
 11419bc:	a8c57bfd 	ldp	x29, x30, [sp], #80
 11419c0:	d65f03c0 	ret
        u1 = ( d[0] + u0 * B->p[0] ) * mm;
 11419c4:	f9400b01 	ldr	x1, [x24, #16]
        mpi_mul_hlp( m, B->p, d, u0 );
 11419c8:	aa0b03e2 	mov	x2, x11
        u0 = A->p[i];
 11419cc:	f8747812 	ldr	x18, [x0, x20, lsl #3]
    for( i = 0; i < n; i++ )
 11419d0:	91000694 	add	x20, x20, #0x1
        u1 = ( d[0] + u0 * B->p[0] ) * mm;
 11419d4:	f9400160 	ldr	x0, [x11]
        mpi_mul_hlp( m, B->p, d, u0 );
 11419d8:	aa1203e3 	mov	x3, x18
        u1 = ( d[0] + u0 * B->p[0] ) * mm;
 11419dc:	f940002e 	ldr	x14, [x1]
 11419e0:	9b0e024e 	madd	x14, x18, x14, x0
        mpi_mul_hlp( m, B->p, d, u0 );
 11419e4:	aa0f03e0 	mov	x0, x15
        u1 = ( d[0] + u0 * B->p[0] ) * mm;
 11419e8:	9b177dce 	mul	x14, x14, x23
        mpi_mul_hlp( m, B->p, d, u0 );
 11419ec:	97fff837 	bl	113fac8 <mpi_mul_hlp>
        mpi_mul_hlp( n, N->p, d, u1 );
 11419f0:	aa0b03e2 	mov	x2, x11
 11419f4:	f9400a61 	ldr	x1, [x19, #16]
 11419f8:	aa0e03e3 	mov	x3, x14
 11419fc:	aa0d03e0 	mov	x0, x13
 1141a00:	97fff832 	bl	113fac8 <mpi_mul_hlp>
        *d++ = u0; d[n + 1] = 0;
 1141a04:	f8008572 	str	x18, [x11], #8
 1141a08:	f82c697f 	str	xzr, [x11, x12]
    for( i = 0; i < n; i++ )
 1141a0c:	17ffffd8 	b	114196c <mbedtls_mpi_montmul+0x78>
        mpi_sub_hlp( n, A->p, T->p );
 1141a10:	f9400aa1 	ldr	x1, [x21, #16]
 1141a14:	f9400ac2 	ldr	x2, [x22, #16]
 1141a18:	17ffffe2 	b	11419a0 <mbedtls_mpi_montmul+0xac>
        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );
 1141a1c:	12800060 	mov	w0, #0xfffffffc            	// #-4
 1141a20:	17ffffe3 	b	11419ac <mbedtls_mpi_montmul+0xb8>

0000000001141a24 <mbedtls_mpi_montred>:
{
 1141a24:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    mbedtls_mpi_uint z = 1;
 1141a28:	d2800025 	mov	x5, #0x1                   	// #1
{
 1141a2c:	910003fd 	mov	x29, sp
    U.p = &z;
 1141a30:	910043e4 	add	x4, sp, #0x10
    mbedtls_mpi_uint z = 1;
 1141a34:	f9000be5 	str	x5, [sp, #16]
    U.n = U.s = (int) z;
 1141a38:	790033e5 	strh	w5, [sp, #24]
    U.p = &z;
 1141a3c:	a90213e5 	stp	x5, x4, [sp, #32]
    return( mbedtls_mpi_montmul( A, &U, N, mm, T ) );
 1141a40:	aa0303e4 	mov	x4, x3
 1141a44:	aa0203e3 	mov	x3, x2
 1141a48:	aa0103e2 	mov	x2, x1
 1141a4c:	910063e1 	add	x1, sp, #0x18
 1141a50:	97ffffa9 	bl	11418f4 <mbedtls_mpi_montmul>
}
 1141a54:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1141a58:	d65f03c0 	ret

0000000001141a5c <mbedtls_mpi_exp_mod>:
{
 1141a5c:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
 1141a60:	910003fd 	mov	x29, sp
 1141a64:	a90153f3 	stp	x19, x20, [sp, #16]
 1141a68:	aa0303f3 	mov	x19, x3
 1141a6c:	a9025bf5 	stp	x21, x22, [sp, #32]
 1141a70:	aa0003f5 	mov	x21, x0
    if( mbedtls_mpi_cmp_int( N, 0 ) <= 0 || ( N->p[0] & 1 ) == 0 )
 1141a74:	aa0303e0 	mov	x0, x3
{
 1141a78:	a90363f7 	stp	x23, x24, [sp, #48]
 1141a7c:	a9046bf9 	stp	x25, x26, [sp, #64]
 1141a80:	aa0203fa 	mov	x26, x2
 1141a84:	aa0403f9 	mov	x25, x4
 1141a88:	a90573fb 	stp	x27, x28, [sp, #80]
 1141a8c:	aa0103fb 	mov	x27, x1
    if( mbedtls_mpi_cmp_int( N, 0 ) <= 0 || ( N->p[0] & 1 ) == 0 )
 1141a90:	d2800001 	mov	x1, #0x0                   	// #0
 1141a94:	97fffb77 	bl	1140870 <mbedtls_mpi_cmp_int>
 1141a98:	7100001f 	cmp	w0, #0x0
 1141a9c:	540032cd 	b.le	11420f4 <mbedtls_mpi_exp_mod+0x698>
 1141aa0:	f9400a60 	ldr	x0, [x19, #16]
 1141aa4:	f9400000 	ldr	x0, [x0]
 1141aa8:	92400001 	and	x1, x0, #0x1
 1141aac:	f9003be1 	str	x1, [sp, #112]
 1141ab0:	36003220 	tbz	w0, #0, 11420f4 <mbedtls_mpi_exp_mod+0x698>
    if( mbedtls_mpi_cmp_int( E, 0 ) < 0 )
 1141ab4:	aa1a03e0 	mov	x0, x26
 1141ab8:	d2800001 	mov	x1, #0x0                   	// #0
 1141abc:	97fffb6d 	bl	1140870 <mbedtls_mpi_cmp_int>
 1141ac0:	37f831a0 	tbnz	w0, #31, 11420f4 <mbedtls_mpi_exp_mod+0x698>
    mbedtls_mpi_montg_init( &mm, N );
 1141ac4:	aa1303e1 	mov	x1, x19
 1141ac8:	9102c3e0 	add	x0, sp, #0xb0
    mbedtls_mpi_init_mempool( &RR ); mbedtls_mpi_init_mempool( &T );
 1141acc:	9102e3f8 	add	x24, sp, #0xb8
    mbedtls_mpi_montg_init( &mm, N );
 1141ad0:	97ffff7a 	bl	11418b8 <mbedtls_mpi_montg_init>
    mbedtls_mpi_init_mempool( &RR ); mbedtls_mpi_init_mempool( &T );
 1141ad4:	aa1803e0 	mov	x0, x24
 1141ad8:	910343f6 	add	x22, sp, #0xd0
 1141adc:	97fff933 	bl	113ffa8 <mbedtls_mpi_init_mempool>
 1141ae0:	aa1603e0 	mov	x0, x22
 1141ae4:	97fff931 	bl	113ffa8 <mbedtls_mpi_init_mempool>
    mbedtls_mpi_init_mempool( &Apos );
 1141ae8:	9103a3e0 	add	x0, sp, #0xe8
 1141aec:	f90037e0 	str	x0, [sp, #104]
 1141af0:	97fff92e 	bl	113ffa8 <mbedtls_mpi_init_mempool>
    i = mbedtls_mpi_bitlen( E );
 1141af4:	aa1a03e0 	mov	x0, x26
 1141af8:	97fffa0a 	bl	1140320 <mbedtls_mpi_bitlen>
    wsize = ( i > 671 ) ? 6 : ( i > 239 ) ? 5 :
 1141afc:	f10a7c1f 	cmp	x0, #0x29f
 1141b00:	540012c8 	b.hi	1141d58 <mbedtls_mpi_exp_mod+0x2fc>  // b.pmore
 1141b04:	f103bc1f 	cmp	x0, #0xef
 1141b08:	540012c8 	b.hi	1141d60 <mbedtls_mpi_exp_mod+0x304>  // b.pmore
 1141b0c:	f1013c1f 	cmp	x0, #0x4f
 1141b10:	540012c8 	b.hi	1141d68 <mbedtls_mpi_exp_mod+0x30c>  // b.pmore
 1141b14:	f1005c1f 	cmp	x0, #0x17
 1141b18:	d2800077 	mov	x23, #0x3                   	// #3
 1141b1c:	f9403be0 	ldr	x0, [sp, #112]
 1141b20:	9a979017 	csel	x23, x0, x23, ls  // ls = plast
    j = N->n + 1;
 1141b24:	f9400660 	ldr	x0, [x19, #8]
 1141b28:	91000400 	add	x0, x0, #0x1
 1141b2c:	f90043e0 	str	x0, [sp, #128]
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, j ) );
 1141b30:	aa0003e1 	mov	x1, x0
 1141b34:	aa1503e0 	mov	x0, x21
 1141b38:	97fff941 	bl	114003c <mbedtls_mpi_grow>
 1141b3c:	2a0003e2 	mov	w2, w0
 1141b40:	b00000c0 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1141b44:	f90053e0 	str	x0, [sp, #160]
 1141b48:	35002ce2 	cbnz	w2, 11420e4 <mbedtls_mpi_exp_mod+0x688>
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &T, j * 2 ) );
 1141b4c:	f94043e0 	ldr	x0, [sp, #128]
 1141b50:	d37ff801 	lsl	x1, x0, #1
 1141b54:	aa1603e0 	mov	x0, x22
 1141b58:	97fff939 	bl	114003c <mbedtls_mpi_grow>
 1141b5c:	2a0003e2 	mov	w2, w0
 1141b60:	35002c20 	cbnz	w0, 11420e4 <mbedtls_mpi_exp_mod+0x688>
    neg = ( A->s == -1 );
 1141b64:	79c00360 	ldrsh	w0, [x27]
 1141b68:	b9007fe0 	str	w0, [sp, #124]
    if( neg )
 1141b6c:	3100041f 	cmn	w0, #0x1
 1141b70:	54000121 	b.ne	1141b94 <mbedtls_mpi_exp_mod+0x138>  // b.any
        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &Apos, A ) );
 1141b74:	f94037e0 	ldr	x0, [sp, #104]
 1141b78:	aa1b03e1 	mov	x1, x27
 1141b7c:	97fff96a 	bl	1140124 <mbedtls_mpi_copy>
 1141b80:	2a0003e2 	mov	w2, w0
 1141b84:	35002b00 	cbnz	w0, 11420e4 <mbedtls_mpi_exp_mod+0x688>
        A = &Apos;
 1141b88:	f94037fb 	ldr	x27, [sp, #104]
        Apos.s = 1;
 1141b8c:	52800020 	mov	w0, #0x1                   	// #1
 1141b90:	7901d3e0 	strh	w0, [sp, #232]
    if( _RR == NULL || _RR->p == NULL )
 1141b94:	b4000079 	cbz	x25, 1141ba0 <mbedtls_mpi_exp_mod+0x144>
 1141b98:	f9400b20 	ldr	x0, [x25, #16]
 1141b9c:	b5000ea0 	cbnz	x0, 1141d70 <mbedtls_mpi_exp_mod+0x314>
        MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &RR, 1 ) );
 1141ba0:	aa1803e0 	mov	x0, x24
 1141ba4:	d2800021 	mov	x1, #0x1                   	// #1
 1141ba8:	97fff98c 	bl	11401d8 <mbedtls_mpi_lset>
 1141bac:	2a0003e2 	mov	w2, w0
 1141bb0:	350029a0 	cbnz	w0, 11420e4 <mbedtls_mpi_exp_mod+0x688>
        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &RR, N->n * 2 * biL ) );
 1141bb4:	f9400661 	ldr	x1, [x19, #8]
 1141bb8:	aa1803e0 	mov	x0, x24
 1141bbc:	d379e021 	lsl	x1, x1, #7
 1141bc0:	97fffa59 	bl	1140524 <mbedtls_mpi_shift_l>
 1141bc4:	2a0003e2 	mov	w2, w0
 1141bc8:	350028e0 	cbnz	w0, 11420e4 <mbedtls_mpi_exp_mod+0x688>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &RR, &RR, N ) );
 1141bcc:	aa1303e2 	mov	x2, x19
 1141bd0:	aa1803e1 	mov	x1, x24
 1141bd4:	aa1803e0 	mov	x0, x24
 1141bd8:	97fffe44 	bl	11414e8 <mbedtls_mpi_mod_mpi>
 1141bdc:	2a0003e2 	mov	w2, w0
 1141be0:	35002820 	cbnz	w0, 11420e4 <mbedtls_mpi_exp_mod+0x688>
        if( _RR != NULL )
 1141be4:	b40000b9 	cbz	x25, 1141bf8 <mbedtls_mpi_exp_mod+0x19c>
            memcpy( _RR, &RR, sizeof( mbedtls_mpi ) );
 1141be8:	aa1803e1 	mov	x1, x24
 1141bec:	aa1903e0 	mov	x0, x25
 1141bf0:	d2800302 	mov	x2, #0x18                  	// #24
        memcpy( &RR, _RR, sizeof( mbedtls_mpi ) );
 1141bf4:	97ff05e7 	bl	1103390 <memcpy>
    W = mempool_alloc( mbedtls_mpi_mempool,
 1141bf8:	b00000c0 	adrp	x0, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1141bfc:	d2818001 	mov	x1, #0xc00                 	// #3072
 1141c00:	f9424c00 	ldr	x0, [x0, #1176]
 1141c04:	f9400000 	ldr	x0, [x0]
 1141c08:	94000c9e 	bl	1144e80 <mempool_alloc>
 1141c0c:	aa0003f4 	mov	x20, x0
    if( W == NULL ) {
 1141c10:	b40026e0 	cbz	x0, 11420ec <mbedtls_mpi_exp_mod+0x690>
 1141c14:	91300000 	add	x0, x0, #0xc00
 1141c18:	f9004be0 	str	x0, [sp, #144]
 1141c1c:	aa1403e0 	mov	x0, x20
 1141c20:	f90033f4 	str	x20, [sp, #96]
        mbedtls_mpi_init_mempool( W + i );
 1141c24:	97fff8e1 	bl	113ffa8 <mbedtls_mpi_init_mempool>
    for( i = 0; i < array_size_W; i++ )
 1141c28:	91006000 	add	x0, x0, #0x18
 1141c2c:	f9404be1 	ldr	x1, [sp, #144]
 1141c30:	eb00003f 	cmp	x1, x0
 1141c34:	54ffff81 	b.ne	1141c24 <mbedtls_mpi_exp_mod+0x1c8>  // b.any
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &W[1],  j ) );
 1141c38:	f94043e1 	ldr	x1, [sp, #128]
 1141c3c:	9100629c 	add	x28, x20, #0x18
 1141c40:	aa1c03e0 	mov	x0, x28
 1141c44:	97fff8fe 	bl	114003c <mbedtls_mpi_grow>
 1141c48:	2a0003e2 	mov	w2, w0
 1141c4c:	35002020 	cbnz	w0, 1142050 <mbedtls_mpi_exp_mod+0x5f4>
    if( mbedtls_mpi_cmp_mpi( A, N ) >= 0 )
 1141c50:	aa1303e1 	mov	x1, x19
 1141c54:	aa1b03e0 	mov	x0, x27
 1141c58:	97fffad1 	bl	114079c <mbedtls_mpi_cmp_mpi>
 1141c5c:	37f80920 	tbnz	w0, #31, 1141d80 <mbedtls_mpi_exp_mod+0x324>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &W[1], A, N ) );
 1141c60:	aa1303e2 	mov	x2, x19
 1141c64:	aa1b03e1 	mov	x1, x27
 1141c68:	aa1c03e0 	mov	x0, x28
 1141c6c:	97fffe1f 	bl	11414e8 <mbedtls_mpi_mod_mpi>
 1141c70:	2a0003e2 	mov	w2, w0
 1141c74:	35001ee0 	cbnz	w0, 1142050 <mbedtls_mpi_exp_mod+0x5f4>
    MBEDTLS_MPI_CHK( mbedtls_mpi_montmul( &W[1], &RR, N, mm, &T ) );
 1141c78:	f9405be3 	ldr	x3, [sp, #176]
 1141c7c:	aa1303e2 	mov	x2, x19
 1141c80:	aa1603e4 	mov	x4, x22
 1141c84:	aa1803e1 	mov	x1, x24
 1141c88:	aa1c03e0 	mov	x0, x28
 1141c8c:	97ffff1a 	bl	11418f4 <mbedtls_mpi_montmul>
 1141c90:	2a0003e2 	mov	w2, w0
 1141c94:	35001de0 	cbnz	w0, 1142050 <mbedtls_mpi_exp_mod+0x5f4>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( X, &RR ) );
 1141c98:	aa1803e1 	mov	x1, x24
 1141c9c:	aa1503e0 	mov	x0, x21
 1141ca0:	97fff921 	bl	1140124 <mbedtls_mpi_copy>
 1141ca4:	2a0003e2 	mov	w2, w0
 1141ca8:	35001d40 	cbnz	w0, 1142050 <mbedtls_mpi_exp_mod+0x5f4>
    MBEDTLS_MPI_CHK( mbedtls_mpi_montred( X, N, mm, &T ) );
 1141cac:	f9405be2 	ldr	x2, [sp, #176]
 1141cb0:	aa1603e3 	mov	x3, x22
 1141cb4:	aa1303e1 	mov	x1, x19
 1141cb8:	aa1503e0 	mov	x0, x21
 1141cbc:	97ffff5a 	bl	1141a24 <mbedtls_mpi_montred>
 1141cc0:	2a0003e2 	mov	w2, w0
 1141cc4:	35001c60 	cbnz	w0, 1142050 <mbedtls_mpi_exp_mod+0x5f4>
    if( wsize > 1 )
 1141cc8:	f10006ff 	cmp	x23, #0x1
 1141ccc:	54000621 	b.ne	1141d90 <mbedtls_mpi_exp_mod+0x334>  // b.any
    nblimbs = E->n;
 1141cd0:	f940075b 	ldr	x27, [x26, #8]
    state   = 0;
 1141cd4:	d2800002 	mov	x2, #0x0                   	// #0
    nbits   = 0;
 1141cd8:	d2800005 	mov	x5, #0x0                   	// #0
    bufsize = 0;
 1141cdc:	d2800007 	mov	x7, #0x0                   	// #0
    wbits   = 0;
 1141ce0:	d2800006 	mov	x6, #0x0                   	// #0
        if( bufsize == 0 )
 1141ce4:	b5000fc7 	cbnz	x7, 1141edc <mbedtls_mpi_exp_mod+0x480>
            if( nblimbs == 0 )
 1141ce8:	b5000f7b 	cbnz	x27, 1141ed4 <mbedtls_mpi_exp_mod+0x478>
        if( ( wbits & ( one << wsize ) ) != 0 )
 1141cec:	d2800020 	mov	x0, #0x1                   	// #1
 1141cf0:	9ad72017 	lsl	x23, x0, x23
    for( i = 0; i < nbits; i++ )
 1141cf4:	eb05037f 	cmp	x27, x5
 1141cf8:	f9405be2 	ldr	x2, [sp, #176]
 1141cfc:	54001701 	b.ne	1141fdc <mbedtls_mpi_exp_mod+0x580>  // b.any
    MBEDTLS_MPI_CHK( mbedtls_mpi_montred( X, N, mm, &T ) );
 1141d00:	aa1603e3 	mov	x3, x22
 1141d04:	aa1303e1 	mov	x1, x19
 1141d08:	aa1503e0 	mov	x0, x21
 1141d0c:	97ffff46 	bl	1141a24 <mbedtls_mpi_montred>
 1141d10:	2a0003e2 	mov	w2, w0
 1141d14:	350019e0 	cbnz	w0, 1142050 <mbedtls_mpi_exp_mod+0x5f4>
    if( neg && E->n != 0 && ( E->p[0] & 1 ) != 0 )
 1141d18:	b9407fe0 	ldr	w0, [sp, #124]
 1141d1c:	3100041f 	cmn	w0, #0x1
 1141d20:	54001981 	b.ne	1142050 <mbedtls_mpi_exp_mod+0x5f4>  // b.any
 1141d24:	f9400740 	ldr	x0, [x26, #8]
 1141d28:	b4001940 	cbz	x0, 1142050 <mbedtls_mpi_exp_mod+0x5f4>
 1141d2c:	f9400b40 	ldr	x0, [x26, #16]
 1141d30:	f9400000 	ldr	x0, [x0]
 1141d34:	360018e0 	tbz	w0, #0, 1142050 <mbedtls_mpi_exp_mod+0x5f4>
        X->s = -1;
 1141d38:	7940fbe0 	ldrh	w0, [sp, #124]
        MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( X, N, X ) );
 1141d3c:	aa1503e2 	mov	x2, x21
        X->s = -1;
 1141d40:	790002a0 	strh	w0, [x21]
        MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( X, N, X ) );
 1141d44:	aa1303e1 	mov	x1, x19
 1141d48:	aa1503e0 	mov	x0, x21
 1141d4c:	97fffb55 	bl	1140aa0 <mbedtls_mpi_add_mpi>
 1141d50:	2a0003e2 	mov	w2, w0
cleanup:
 1141d54:	140000bf 	b	1142050 <mbedtls_mpi_exp_mod+0x5f4>
    wsize = ( i > 671 ) ? 6 : ( i > 239 ) ? 5 :
 1141d58:	d28000d7 	mov	x23, #0x6                   	// #6
 1141d5c:	17ffff72 	b	1141b24 <mbedtls_mpi_exp_mod+0xc8>
 1141d60:	d28000b7 	mov	x23, #0x5                   	// #5
 1141d64:	17ffff70 	b	1141b24 <mbedtls_mpi_exp_mod+0xc8>
 1141d68:	d2800097 	mov	x23, #0x4                   	// #4
 1141d6c:	17ffff6e 	b	1141b24 <mbedtls_mpi_exp_mod+0xc8>
        memcpy( &RR, _RR, sizeof( mbedtls_mpi ) );
 1141d70:	aa1903e1 	mov	x1, x25
 1141d74:	aa1803e0 	mov	x0, x24
 1141d78:	d2800302 	mov	x2, #0x18                  	// #24
 1141d7c:	17ffff9e 	b	1141bf4 <mbedtls_mpi_exp_mod+0x198>
        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &W[1], A ) );
 1141d80:	aa1b03e1 	mov	x1, x27
 1141d84:	aa1c03e0 	mov	x0, x28
 1141d88:	97fff8e7 	bl	1140124 <mbedtls_mpi_copy>
 1141d8c:	17ffffb9 	b	1141c70 <mbedtls_mpi_exp_mod+0x214>
        j =  one << ( wsize - 1 );
 1141d90:	510006e0 	sub	w0, w23, #0x1
 1141d94:	b90083e0 	str	w0, [sp, #128]
        MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &W[j], N->n + 1 ) );
 1141d98:	d2800305 	mov	x5, #0x18                  	// #24
        j =  one << ( wsize - 1 );
 1141d9c:	b9009bf7 	str	w23, [sp, #152]
        MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &W[j], N->n + 1 ) );
 1141da0:	394203e0 	ldrb	w0, [sp, #128]
 1141da4:	f9400661 	ldr	x1, [x19, #8]
 1141da8:	9ac020a5 	lsl	x5, x5, x0
 1141dac:	8b05029b 	add	x27, x20, x5
 1141db0:	91000421 	add	x1, x1, #0x1
 1141db4:	aa1b03e0 	mov	x0, x27
 1141db8:	97fff8a1 	bl	114003c <mbedtls_mpi_grow>
 1141dbc:	2a0003e2 	mov	w2, w0
 1141dc0:	35001480 	cbnz	w0, 1142050 <mbedtls_mpi_exp_mod+0x5f4>
        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &W[j], &W[1]    ) );
 1141dc4:	aa1c03e1 	mov	x1, x28
 1141dc8:	aa1b03e0 	mov	x0, x27
 1141dcc:	97fff8d6 	bl	1140124 <mbedtls_mpi_copy>
 1141dd0:	2a0003e2 	mov	w2, w0
 1141dd4:	350013e0 	cbnz	w0, 1142050 <mbedtls_mpi_exp_mod+0x5f4>
        for( i = 0; i < wsize - 1; i++ )
 1141dd8:	d10006e7 	sub	x7, x23, #0x1
 1141ddc:	d2800006 	mov	x6, #0x0                   	// #0
            MBEDTLS_MPI_CHK( mbedtls_mpi_montmul( &W[j], &W[j], N, mm, &T ) );
 1141de0:	f9405be3 	ldr	x3, [sp, #176]
 1141de4:	aa1303e2 	mov	x2, x19
 1141de8:	aa1603e4 	mov	x4, x22
 1141dec:	aa1b03e1 	mov	x1, x27
 1141df0:	aa1b03e0 	mov	x0, x27
 1141df4:	f90047e6 	str	x6, [sp, #136]
 1141df8:	f90057e7 	str	x7, [sp, #168]
 1141dfc:	97fffebe 	bl	11418f4 <mbedtls_mpi_montmul>
 1141e00:	2a0003e2 	mov	w2, w0
 1141e04:	35001260 	cbnz	w0, 1142050 <mbedtls_mpi_exp_mod+0x5f4>
        for( i = 0; i < wsize - 1; i++ )
 1141e08:	f94047e6 	ldr	x6, [sp, #136]
 1141e0c:	f94057e7 	ldr	x7, [sp, #168]
 1141e10:	910004c6 	add	x6, x6, #0x1
 1141e14:	eb0600ff 	cmp	x7, x6
 1141e18:	54fffe48 	b.hi	1141de0 <mbedtls_mpi_exp_mod+0x384>  // b.pmore
        j =  one << ( wsize - 1 );
 1141e1c:	394203e1 	ldrb	w1, [sp, #128]
 1141e20:	d2800020 	mov	x0, #0x1                   	// #1
 1141e24:	9ac12001 	lsl	x1, x0, x1
        for( i = j + 1; i < ( one << wsize ); i++ )
 1141e28:	8b000021 	add	x1, x1, x0
 1141e2c:	f90047e1 	str	x1, [sp, #136]
 1141e30:	394263e1 	ldrb	w1, [sp, #152]
 1141e34:	9ac12000 	lsl	x0, x0, x1
 1141e38:	394203e1 	ldrb	w1, [sp, #128]
 1141e3c:	f9004fe0 	str	x0, [sp, #152]
 1141e40:	d2800300 	mov	x0, #0x18                  	// #24
 1141e44:	9ac1201b 	lsl	x27, x0, x1
 1141e48:	8b1b0283 	add	x3, x20, x27
 1141e4c:	f94047e1 	ldr	x1, [sp, #136]
 1141e50:	f9404fe0 	ldr	x0, [sp, #152]
 1141e54:	eb01001f 	cmp	x0, x1
 1141e58:	54fff3c9 	b.ls	1141cd0 <mbedtls_mpi_exp_mod+0x274>  // b.plast
            MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &W[i], N->n + 1 ) );
 1141e5c:	f9400661 	ldr	x1, [x19, #8]
 1141e60:	9100607b 	add	x27, x3, #0x18
 1141e64:	aa1b03e0 	mov	x0, x27
 1141e68:	f90043e3 	str	x3, [sp, #128]
 1141e6c:	91000421 	add	x1, x1, #0x1
 1141e70:	97fff873 	bl	114003c <mbedtls_mpi_grow>
 1141e74:	2a0003e2 	mov	w2, w0
 1141e78:	35000ec0 	cbnz	w0, 1142050 <mbedtls_mpi_exp_mod+0x5f4>
            MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &W[i], &W[i - 1] ) );
 1141e7c:	f94043e3 	ldr	x3, [sp, #128]
 1141e80:	aa1b03e0 	mov	x0, x27
 1141e84:	aa0303e1 	mov	x1, x3
 1141e88:	97fff8a7 	bl	1140124 <mbedtls_mpi_copy>
 1141e8c:	2a0003e2 	mov	w2, w0
 1141e90:	35000e00 	cbnz	w0, 1142050 <mbedtls_mpi_exp_mod+0x5f4>
            MBEDTLS_MPI_CHK( mbedtls_mpi_montmul( &W[i], &W[1], N, mm, &T ) );
 1141e94:	f9405be3 	ldr	x3, [sp, #176]
 1141e98:	aa1303e2 	mov	x2, x19
 1141e9c:	aa1603e4 	mov	x4, x22
 1141ea0:	aa1c03e1 	mov	x1, x28
 1141ea4:	aa1b03e0 	mov	x0, x27
 1141ea8:	97fffe93 	bl	11418f4 <mbedtls_mpi_montmul>
 1141eac:	2a0003e2 	mov	w2, w0
 1141eb0:	35000d00 	cbnz	w0, 1142050 <mbedtls_mpi_exp_mod+0x5f4>
        for( i = j + 1; i < ( one << wsize ); i++ )
 1141eb4:	f94047e0 	ldr	x0, [sp, #136]
 1141eb8:	aa1b03e3 	mov	x3, x27
 1141ebc:	91000400 	add	x0, x0, #0x1
 1141ec0:	f90047e0 	str	x0, [sp, #136]
 1141ec4:	17ffffe2 	b	1141e4c <mbedtls_mpi_exp_mod+0x3f0>
        state = 2;
 1141ec8:	d2800041 	mov	x1, #0x2                   	// #2
            wbits = 0;
 1141ecc:	aa0103e2 	mov	x2, x1
 1141ed0:	17ffff85 	b	1141ce4 <mbedtls_mpi_exp_mod+0x288>
            nblimbs--;
 1141ed4:	d100077b 	sub	x27, x27, #0x1
            bufsize = sizeof( mbedtls_mpi_uint ) << 3;
 1141ed8:	d2800807 	mov	x7, #0x40                  	// #64
        ei = (E->p[nblimbs] >> bufsize) & 1;
 1141edc:	f9400b40 	ldr	x0, [x26, #16]
        bufsize--;
 1141ee0:	d10004e7 	sub	x7, x7, #0x1
        ei = (E->p[nblimbs] >> bufsize) & 1;
 1141ee4:	f87b7800 	ldr	x0, [x0, x27, lsl #3]
 1141ee8:	9ac72400 	lsr	x0, x0, x7
 1141eec:	92400000 	and	x0, x0, #0x1
        if( ei == 0 && state == 0 )
 1141ef0:	aa000041 	orr	x1, x2, x0
 1141ef4:	b4fffec1 	cbz	x1, 1141ecc <mbedtls_mpi_exp_mod+0x470>
        if( ei == 0 && state == 1 )
 1141ef8:	52000001 	eor	w1, w0, #0x1
 1141efc:	f100045f 	cmp	x2, #0x1
 1141f00:	1a9f0021 	csel	w1, w1, wzr, eq  // eq = none
 1141f04:	340001e1 	cbz	w1, 1141f40 <mbedtls_mpi_exp_mod+0x4e4>
            MBEDTLS_MPI_CHK( mbedtls_mpi_montmul( X, X, N, mm, &T ) );
 1141f08:	f9405be3 	ldr	x3, [sp, #176]
 1141f0c:	aa1303e2 	mov	x2, x19
 1141f10:	aa1603e4 	mov	x4, x22
 1141f14:	aa1503e1 	mov	x1, x21
 1141f18:	aa1503e0 	mov	x0, x21
 1141f1c:	a9081fe6 	stp	x6, x7, [sp, #128]
 1141f20:	f9004fe5 	str	x5, [sp, #152]
 1141f24:	97fffe74 	bl	11418f4 <mbedtls_mpi_montmul>
 1141f28:	2a0003e2 	mov	w2, w0
 1141f2c:	35000920 	cbnz	w0, 1142050 <mbedtls_mpi_exp_mod+0x5f4>
 1141f30:	f9403be1 	ldr	x1, [sp, #112]
 1141f34:	a9481fe6 	ldp	x6, x7, [sp, #128]
 1141f38:	f9404fe5 	ldr	x5, [sp, #152]
 1141f3c:	17ffffe4 	b	1141ecc <mbedtls_mpi_exp_mod+0x470>
        nbits++;
 1141f40:	910004a5 	add	x5, x5, #0x1
        wbits |= ( ei << ( wsize - nbits ) );
 1141f44:	4b0502e1 	sub	w1, w23, w5
        if( nbits == wsize )
 1141f48:	eb0502ff 	cmp	x23, x5
        wbits |= ( ei << ( wsize - nbits ) );
 1141f4c:	9ac12000 	lsl	x0, x0, x1
 1141f50:	aa0000c6 	orr	x6, x6, x0
        if( nbits == wsize )
 1141f54:	54fffba1 	b.ne	1141ec8 <mbedtls_mpi_exp_mod+0x46c>  // b.any
            for( i = 0; i < wsize; i++ )
 1141f58:	d2800008 	mov	x8, #0x0                   	// #0
                MBEDTLS_MPI_CHK( mbedtls_mpi_montmul( X, X, N, mm, &T ) );
 1141f5c:	f9405be3 	ldr	x3, [sp, #176]
 1141f60:	aa1303e2 	mov	x2, x19
 1141f64:	aa1603e4 	mov	x4, x22
 1141f68:	aa1503e1 	mov	x1, x21
 1141f6c:	aa1503e0 	mov	x0, x21
 1141f70:	a9081fe6 	stp	x6, x7, [sp, #128]
 1141f74:	f9004fe5 	str	x5, [sp, #152]
 1141f78:	f90057e8 	str	x8, [sp, #168]
 1141f7c:	97fffe5e 	bl	11418f4 <mbedtls_mpi_montmul>
 1141f80:	2a0003e2 	mov	w2, w0
 1141f84:	35000660 	cbnz	w0, 1142050 <mbedtls_mpi_exp_mod+0x5f4>
            for( i = 0; i < wsize; i++ )
 1141f88:	f94057e8 	ldr	x8, [sp, #168]
 1141f8c:	f9404fe5 	ldr	x5, [sp, #152]
 1141f90:	91000508 	add	x8, x8, #0x1
 1141f94:	a9481fe6 	ldp	x6, x7, [sp, #128]
 1141f98:	eb0800bf 	cmp	x5, x8
 1141f9c:	54fffe08 	b.hi	1141f5c <mbedtls_mpi_exp_mod+0x500>  // b.pmore
            MBEDTLS_MPI_CHK( mbedtls_mpi_montmul( X, &W[wbits], N, mm, &T ) );
 1141fa0:	d2800300 	mov	x0, #0x18                  	// #24
 1141fa4:	aa1303e2 	mov	x2, x19
 1141fa8:	f9405be3 	ldr	x3, [sp, #176]
 1141fac:	9b0050c1 	madd	x1, x6, x0, x20
 1141fb0:	aa1603e4 	mov	x4, x22
 1141fb4:	aa1503e0 	mov	x0, x21
 1141fb8:	f90043e7 	str	x7, [sp, #128]
 1141fbc:	97fffe4e 	bl	11418f4 <mbedtls_mpi_montmul>
 1141fc0:	2a0003e2 	mov	w2, w0
 1141fc4:	35000460 	cbnz	w0, 1142050 <mbedtls_mpi_exp_mod+0x5f4>
            nbits = 0;
 1141fc8:	d2800005 	mov	x5, #0x0                   	// #0
            wbits = 0;
 1141fcc:	d2800006 	mov	x6, #0x0                   	// #0
            state--;
 1141fd0:	f9403be1 	ldr	x1, [sp, #112]
 1141fd4:	f94043e7 	ldr	x7, [sp, #128]
 1141fd8:	17ffffbd 	b	1141ecc <mbedtls_mpi_exp_mod+0x470>
        MBEDTLS_MPI_CHK( mbedtls_mpi_montmul( X, X, N, mm, &T ) );
 1141fdc:	aa0203e3 	mov	x3, x2
 1141fe0:	aa1303e2 	mov	x2, x19
 1141fe4:	aa1603e4 	mov	x4, x22
 1141fe8:	aa1503e1 	mov	x1, x21
 1141fec:	aa1503e0 	mov	x0, x21
 1141ff0:	f9003be6 	str	x6, [sp, #112]
 1141ff4:	f90043e5 	str	x5, [sp, #128]
 1141ff8:	97fffe3f 	bl	11418f4 <mbedtls_mpi_montmul>
 1141ffc:	2a0003e2 	mov	w2, w0
 1142000:	35000280 	cbnz	w0, 1142050 <mbedtls_mpi_exp_mod+0x5f4>
        wbits <<= 1;
 1142004:	f9403be6 	ldr	x6, [sp, #112]
        if( ( wbits & ( one << wsize ) ) != 0 )
 1142008:	f94043e5 	ldr	x5, [sp, #128]
        wbits <<= 1;
 114200c:	d37ff8c6 	lsl	x6, x6, #1
        if( ( wbits & ( one << wsize ) ) != 0 )
 1142010:	ea0602ff 	tst	x23, x6
 1142014:	54000061 	b.ne	1142020 <mbedtls_mpi_exp_mod+0x5c4>  // b.any
    for( i = 0; i < nbits; i++ )
 1142018:	9100077b 	add	x27, x27, #0x1
 114201c:	17ffff36 	b	1141cf4 <mbedtls_mpi_exp_mod+0x298>
            MBEDTLS_MPI_CHK( mbedtls_mpi_montmul( X, &W[1], N, mm, &T ) );
 1142020:	f9405be3 	ldr	x3, [sp, #176]
 1142024:	aa1303e2 	mov	x2, x19
 1142028:	aa1603e4 	mov	x4, x22
 114202c:	aa1c03e1 	mov	x1, x28
 1142030:	aa1503e0 	mov	x0, x21
 1142034:	f9003be6 	str	x6, [sp, #112]
 1142038:	f90043e5 	str	x5, [sp, #128]
 114203c:	97fffe2e 	bl	11418f4 <mbedtls_mpi_montmul>
 1142040:	2a0003e2 	mov	w2, w0
 1142044:	f9403be6 	ldr	x6, [sp, #112]
 1142048:	f94043e5 	ldr	x5, [sp, #128]
 114204c:	34fffe60 	cbz	w0, 1142018 <mbedtls_mpi_exp_mod+0x5bc>
            mbedtls_mpi_free( W + i );
 1142050:	f94033e0 	ldr	x0, [sp, #96]
 1142054:	b90073e2 	str	w2, [sp, #112]
 1142058:	97fff7de 	bl	113ffd0 <mbedtls_mpi_free>
        for( i = 0; i < array_size_W; i++ )
 114205c:	f94033e0 	ldr	x0, [sp, #96]
 1142060:	b94073e2 	ldr	w2, [sp, #112]
 1142064:	91006000 	add	x0, x0, #0x18
 1142068:	f90033e0 	str	x0, [sp, #96]
 114206c:	f9404be0 	ldr	x0, [sp, #144]
 1142070:	f94033e1 	ldr	x1, [sp, #96]
 1142074:	eb01001f 	cmp	x0, x1
 1142078:	54fffec1 	b.ne	1142050 <mbedtls_mpi_exp_mod+0x5f4>  // b.any
    mempool_free( mbedtls_mpi_mempool , W );
 114207c:	f94053e0 	ldr	x0, [sp, #160]
 1142080:	aa1403e1 	mov	x1, x20
 1142084:	b90063e2 	str	w2, [sp, #96]
 1142088:	f9424c00 	ldr	x0, [x0, #1176]
 114208c:	f9400000 	ldr	x0, [x0]
 1142090:	94000bae 	bl	1144f48 <mempool_free>
    mbedtls_mpi_free( &T ); mbedtls_mpi_free( &Apos );
 1142094:	aa1603e0 	mov	x0, x22
 1142098:	97fff7ce 	bl	113ffd0 <mbedtls_mpi_free>
 114209c:	f94037e0 	ldr	x0, [sp, #104]
 11420a0:	97fff7cc 	bl	113ffd0 <mbedtls_mpi_free>
    if( _RR == NULL || _RR->p == NULL )
 11420a4:	b94063e2 	ldr	w2, [sp, #96]
 11420a8:	b4000079 	cbz	x25, 11420b4 <mbedtls_mpi_exp_mod+0x658>
 11420ac:	f9400b20 	ldr	x0, [x25, #16]
 11420b0:	b50000a0 	cbnz	x0, 11420c4 <mbedtls_mpi_exp_mod+0x668>
        mbedtls_mpi_free( &RR );
 11420b4:	aa1803e0 	mov	x0, x24
 11420b8:	b90063e2 	str	w2, [sp, #96]
 11420bc:	97fff7c5 	bl	113ffd0 <mbedtls_mpi_free>
 11420c0:	b94063e2 	ldr	w2, [sp, #96]
}
 11420c4:	2a0203e0 	mov	w0, w2
 11420c8:	a94153f3 	ldp	x19, x20, [sp, #16]
 11420cc:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11420d0:	a94363f7 	ldp	x23, x24, [sp, #48]
 11420d4:	a9446bf9 	ldp	x25, x26, [sp, #64]
 11420d8:	a94573fb 	ldp	x27, x28, [sp, #80]
 11420dc:	a8d07bfd 	ldp	x29, x30, [sp], #256
 11420e0:	d65f03c0 	ret
    mbedtls_mpi *W = NULL;
 11420e4:	d2800014 	mov	x20, #0x0                   	// #0
 11420e8:	17ffffe5 	b	114207c <mbedtls_mpi_exp_mod+0x620>
        ret = MBEDTLS_ERR_MPI_ALLOC_FAILED;
 11420ec:	128001e2 	mov	w2, #0xfffffff0            	// #-16
 11420f0:	17ffffe3 	b	114207c <mbedtls_mpi_exp_mod+0x620>
        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );
 11420f4:	12800062 	mov	w2, #0xfffffffc            	// #-4
 11420f8:	17fffff3 	b	11420c4 <mbedtls_mpi_exp_mod+0x668>

00000000011420fc <mbedtls_mpi_gcd>:
{
 11420fc:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
 1142100:	aa0103e3 	mov	x3, x1
 1142104:	910003fd 	mov	x29, sp
 1142108:	a9025bf5 	stp	x21, x22, [sp, #32]
    mbedtls_mpi_init_mempool( &TA ); mbedtls_mpi_init_mempool( &TB );
 114210c:	910103f5 	add	x21, sp, #0x40
{
 1142110:	aa0003f6 	mov	x22, x0
    mbedtls_mpi_init_mempool( &TA ); mbedtls_mpi_init_mempool( &TB );
 1142114:	aa1503e0 	mov	x0, x21
{
 1142118:	a90153f3 	stp	x19, x20, [sp, #16]
    mbedtls_mpi_init_mempool( &TA ); mbedtls_mpi_init_mempool( &TB );
 114211c:	910163f4 	add	x20, sp, #0x58
{
 1142120:	f9001bf7 	str	x23, [sp, #48]
 1142124:	aa0203f7 	mov	x23, x2
    mbedtls_mpi_init_mempool( &TA ); mbedtls_mpi_init_mempool( &TB );
 1142128:	97fff7a0 	bl	113ffa8 <mbedtls_mpi_init_mempool>
 114212c:	aa1403e0 	mov	x0, x20
 1142130:	97fff79e 	bl	113ffa8 <mbedtls_mpi_init_mempool>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TA, A ) );
 1142134:	aa1503e0 	mov	x0, x21
 1142138:	aa0303e1 	mov	x1, x3
 114213c:	97fff7fa 	bl	1140124 <mbedtls_mpi_copy>
 1142140:	2a0003f3 	mov	w19, w0
 1142144:	350008a0 	cbnz	w0, 1142258 <mbedtls_mpi_gcd+0x15c>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TB, B ) );
 1142148:	aa1703e1 	mov	x1, x23
 114214c:	aa1403e0 	mov	x0, x20
 1142150:	97fff7f5 	bl	1140124 <mbedtls_mpi_copy>
 1142154:	2a0003f3 	mov	w19, w0
 1142158:	35000800 	cbnz	w0, 1142258 <mbedtls_mpi_gcd+0x15c>
    lz = mbedtls_mpi_lsb( &TA );
 114215c:	aa1503e0 	mov	x0, x21
 1142160:	97fff85b 	bl	11402cc <mbedtls_mpi_lsb>
 1142164:	aa0003f7 	mov	x23, x0
    lzt = mbedtls_mpi_lsb( &TB );
 1142168:	aa1403e0 	mov	x0, x20
 114216c:	97fff858 	bl	11402cc <mbedtls_mpi_lsb>
    if( lzt < lz )
 1142170:	eb0002ff 	cmp	x23, x0
 1142174:	9a8092f7 	csel	x23, x23, x0, ls  // ls = plast
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TA, lz ) );
 1142178:	aa1503e0 	mov	x0, x21
 114217c:	aa1703e1 	mov	x1, x23
 1142180:	97fff92e 	bl	1140638 <mbedtls_mpi_shift_r>
 1142184:	2a0003f3 	mov	w19, w0
 1142188:	35000680 	cbnz	w0, 1142258 <mbedtls_mpi_gcd+0x15c>
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TB, lz ) );
 114218c:	aa1703e1 	mov	x1, x23
 1142190:	aa1403e0 	mov	x0, x20
 1142194:	97fff929 	bl	1140638 <mbedtls_mpi_shift_r>
 1142198:	2a0003f3 	mov	w19, w0
 114219c:	350005e0 	cbnz	w0, 1142258 <mbedtls_mpi_gcd+0x15c>
    TA.s = TB.s = 1;
 11421a0:	52800020 	mov	w0, #0x1                   	// #1
 11421a4:	790083e0 	strh	w0, [sp, #64]
 11421a8:	7900b3e0 	strh	w0, [sp, #88]
    while( mbedtls_mpi_cmp_int( &TA, 0 ) != 0 )
 11421ac:	aa1503e0 	mov	x0, x21
 11421b0:	d2800001 	mov	x1, #0x0                   	// #0
 11421b4:	97fff9af 	bl	1140870 <mbedtls_mpi_cmp_int>
 11421b8:	35000160 	cbnz	w0, 11421e4 <mbedtls_mpi_gcd+0xe8>
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &TB, lz ) );
 11421bc:	aa1703e1 	mov	x1, x23
 11421c0:	aa1403e0 	mov	x0, x20
 11421c4:	97fff8d8 	bl	1140524 <mbedtls_mpi_shift_l>
 11421c8:	2a0003f3 	mov	w19, w0
 11421cc:	35000460 	cbnz	w0, 1142258 <mbedtls_mpi_gcd+0x15c>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( G, &TB ) );
 11421d0:	aa1403e1 	mov	x1, x20
 11421d4:	aa1603e0 	mov	x0, x22
 11421d8:	97fff7d3 	bl	1140124 <mbedtls_mpi_copy>
 11421dc:	2a0003f3 	mov	w19, w0
cleanup:
 11421e0:	1400001e 	b	1142258 <mbedtls_mpi_gcd+0x15c>
        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TA, mbedtls_mpi_lsb( &TA ) ) );
 11421e4:	aa1503e0 	mov	x0, x21
 11421e8:	97fff839 	bl	11402cc <mbedtls_mpi_lsb>
 11421ec:	aa0003e1 	mov	x1, x0
 11421f0:	aa1503e0 	mov	x0, x21
 11421f4:	97fff911 	bl	1140638 <mbedtls_mpi_shift_r>
 11421f8:	2a0003f3 	mov	w19, w0
 11421fc:	350002e0 	cbnz	w0, 1142258 <mbedtls_mpi_gcd+0x15c>
        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TB, mbedtls_mpi_lsb( &TB ) ) );
 1142200:	aa1403e0 	mov	x0, x20
 1142204:	97fff832 	bl	11402cc <mbedtls_mpi_lsb>
 1142208:	aa0003e1 	mov	x1, x0
 114220c:	aa1403e0 	mov	x0, x20
 1142210:	97fff90a 	bl	1140638 <mbedtls_mpi_shift_r>
 1142214:	2a0003f3 	mov	w19, w0
 1142218:	35000200 	cbnz	w0, 1142258 <mbedtls_mpi_gcd+0x15c>
        if( mbedtls_mpi_cmp_mpi( &TA, &TB ) >= 0 )
 114221c:	aa1403e1 	mov	x1, x20
 1142220:	aa1503e0 	mov	x0, x21
 1142224:	97fff95e 	bl	114079c <mbedtls_mpi_cmp_mpi>
 1142228:	37f802c0 	tbnz	w0, #31, 1142280 <mbedtls_mpi_gcd+0x184>
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( &TA, &TA, &TB ) );
 114222c:	aa1403e2 	mov	x2, x20
 1142230:	aa1503e1 	mov	x1, x21
 1142234:	aa1503e0 	mov	x0, x21
 1142238:	97fff9e6 	bl	11409d0 <mbedtls_mpi_sub_abs>
 114223c:	2a0003f3 	mov	w19, w0
 1142240:	350000c0 	cbnz	w0, 1142258 <mbedtls_mpi_gcd+0x15c>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TA, 1 ) );
 1142244:	aa1503e0 	mov	x0, x21
 1142248:	d2800021 	mov	x1, #0x1                   	// #1
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TB, 1 ) );
 114224c:	97fff8fb 	bl	1140638 <mbedtls_mpi_shift_r>
 1142250:	2a0003f3 	mov	w19, w0
 1142254:	34fffac0 	cbz	w0, 11421ac <mbedtls_mpi_gcd+0xb0>
    mbedtls_mpi_free( &TA ); mbedtls_mpi_free( &TB );
 1142258:	aa1503e0 	mov	x0, x21
 114225c:	97fff75d 	bl	113ffd0 <mbedtls_mpi_free>
 1142260:	aa1403e0 	mov	x0, x20
 1142264:	97fff75b 	bl	113ffd0 <mbedtls_mpi_free>
}
 1142268:	2a1303e0 	mov	w0, w19
 114226c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1142270:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1142274:	f9401bf7 	ldr	x23, [sp, #48]
 1142278:	a8c77bfd 	ldp	x29, x30, [sp], #112
 114227c:	d65f03c0 	ret
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( &TB, &TB, &TA ) );
 1142280:	aa1503e2 	mov	x2, x21
 1142284:	aa1403e0 	mov	x0, x20
 1142288:	97fff9d2 	bl	11409d0 <mbedtls_mpi_sub_abs>
 114228c:	2a0003f3 	mov	w19, w0
 1142290:	35fffe40 	cbnz	w0, 1142258 <mbedtls_mpi_gcd+0x15c>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TB, 1 ) );
 1142294:	aa1403e0 	mov	x0, x20
 1142298:	d2800021 	mov	x1, #0x1                   	// #1
 114229c:	17ffffec 	b	114224c <mbedtls_mpi_gcd+0x150>

00000000011422a0 <mbedtls_mpi_fill_random>:
{
 11422a0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    size_t const limbs = CHARS_TO_LIMBS( size );
 11422a4:	f240083f 	tst	x1, #0x7
{
 11422a8:	910003fd 	mov	x29, sp
 11422ac:	a9025bf5 	stp	x21, x22, [sp, #32]
    size_t const limbs = CHARS_TO_LIMBS( size );
 11422b0:	d343fc35 	lsr	x21, x1, #3
{
 11422b4:	aa0103f6 	mov	x22, x1
    if( X->n != limbs )
 11422b8:	f9400401 	ldr	x1, [x0, #8]
{
 11422bc:	a90153f3 	stp	x19, x20, [sp, #16]
    size_t const limbs = CHARS_TO_LIMBS( size );
 11422c0:	9a9506b5 	cinc	x21, x21, ne  // ne = any
{
 11422c4:	a90363f7 	stp	x23, x24, [sp, #48]
 11422c8:	aa0003f3 	mov	x19, x0
 11422cc:	aa0203f7 	mov	x23, x2
 11422d0:	aa0303f8 	mov	x24, x3
    if( X->n != limbs )
 11422d4:	eb15003f 	cmp	x1, x21
 11422d8:	54000181 	b.ne	1142308 <mbedtls_mpi_fill_random+0x68>  // b.any
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( X, 0 ) );
 11422dc:	aa1303e0 	mov	x0, x19
 11422e0:	d2800001 	mov	x1, #0x0                   	// #0
 11422e4:	97fff7bd 	bl	11401d8 <mbedtls_mpi_lset>
 11422e8:	2a0003f4 	mov	w20, w0
 11422ec:	34000220 	cbz	w0, 1142330 <mbedtls_mpi_fill_random+0x90>
}
 11422f0:	2a1403e0 	mov	w0, w20
 11422f4:	a94153f3 	ldp	x19, x20, [sp, #16]
 11422f8:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11422fc:	a94363f7 	ldp	x23, x24, [sp, #48]
 1142300:	a8c47bfd 	ldp	x29, x30, [sp], #64
 1142304:	d65f03c0 	ret
        mbedtls_mpi_free( X );
 1142308:	97fff732 	bl	113ffd0 <mbedtls_mpi_free>
    X->p = NULL;
 114230c:	a900fe7f 	stp	xzr, xzr, [x19, #8]
    X->s = 1;
 1142310:	52800020 	mov	w0, #0x1                   	// #1
 1142314:	b9000260 	str	w0, [x19]
        MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, limbs ) );
 1142318:	aa1503e1 	mov	x1, x21
 114231c:	aa1303e0 	mov	x0, x19
 1142320:	97fff747 	bl	114003c <mbedtls_mpi_grow>
 1142324:	2a0003f4 	mov	w20, w0
 1142328:	34fffda0 	cbz	w0, 11422dc <mbedtls_mpi_fill_random+0x3c>
 114232c:	17fffff1 	b	11422f0 <mbedtls_mpi_fill_random+0x50>
    f_rng( p_rng, Xp + overhead, size );
 1142330:	f9400a61 	ldr	x1, [x19, #16]
    size_t const overhead = ( limbs * ciL ) - size;
 1142334:	d37df2a0 	lsl	x0, x21, #3
 1142338:	cb160000 	sub	x0, x0, x22
    f_rng( p_rng, Xp + overhead, size );
 114233c:	aa1603e2 	mov	x2, x22
 1142340:	8b000021 	add	x1, x1, x0
 1142344:	aa1803e0 	mov	x0, x24
 1142348:	d63f02e0 	blr	x23
    if( limbs == 0 )
 114234c:	b4fffd35 	cbz	x21, 11422f0 <mbedtls_mpi_fill_random+0x50>
 1142350:	f9400a60 	ldr	x0, [x19, #16]
 1142354:	aa1503e1 	mov	x1, x21
 1142358:	97fff6f3 	bl	113ff24 <mpi_bigendian_to_host.part.0>
    return( ret );
 114235c:	17ffffe5 	b	11422f0 <mbedtls_mpi_fill_random+0x50>

0000000001142360 <mpi_miller_rabin>:
 * Miller-Rabin pseudo-primality test  (HAC 4.24)
 */
static int mpi_miller_rabin( const mbedtls_mpi *X, size_t rounds,
                             int (*f_rng)(void *, unsigned char *, size_t),
                             void *p_rng )
{
 1142360:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
 1142364:	910003fd 	mov	x29, sp
 1142368:	a9025bf5 	stp	x21, x22, [sp, #32]
    mbedtls_mpi W, R, T, A, RR;

    MPI_VALIDATE_RET( X     != NULL );
    MPI_VALIDATE_RET( f_rng != NULL );

    mbedtls_mpi_init_mempool( &W ); mbedtls_mpi_init_mempool( &R );
 114236c:	910223f5 	add	x21, sp, #0x88
{
 1142370:	aa0003f6 	mov	x22, x0
    mbedtls_mpi_init_mempool( &W ); mbedtls_mpi_init_mempool( &R );
 1142374:	aa1503e0 	mov	x0, x21
{
 1142378:	a90153f3 	stp	x19, x20, [sp, #16]
    mbedtls_mpi_init_mempool( &T ); mbedtls_mpi_init_mempool( &A );
 114237c:	910343f4 	add	x20, sp, #0xd0
{
 1142380:	a90363f7 	stp	x23, x24, [sp, #48]
    mbedtls_mpi_init_mempool( &W ); mbedtls_mpi_init_mempool( &R );
 1142384:	910283f7 	add	x23, sp, #0xa0
    mbedtls_mpi_init_mempool( &T ); mbedtls_mpi_init_mempool( &A );
 1142388:	9102e3f8 	add	x24, sp, #0xb8
{
 114238c:	a9046bf9 	stp	x25, x26, [sp, #64]
    mbedtls_mpi_init_mempool( &RR );
 1142390:	9103a3fa 	add	x26, sp, #0xe8
{
 1142394:	a90573fb 	stp	x27, x28, [sp, #80]
 1142398:	a9068be1 	stp	x1, x2, [sp, #104]
 114239c:	f9003fe3 	str	x3, [sp, #120]
    mbedtls_mpi_init_mempool( &W ); mbedtls_mpi_init_mempool( &R );
 11423a0:	97fff702 	bl	113ffa8 <mbedtls_mpi_init_mempool>
 11423a4:	aa1703e0 	mov	x0, x23
 11423a8:	97fff700 	bl	113ffa8 <mbedtls_mpi_init_mempool>
    mbedtls_mpi_init_mempool( &T ); mbedtls_mpi_init_mempool( &A );
 11423ac:	aa1803e0 	mov	x0, x24
 11423b0:	97fff6fe 	bl	113ffa8 <mbedtls_mpi_init_mempool>
 11423b4:	aa1403e0 	mov	x0, x20
 11423b8:	97fff6fc 	bl	113ffa8 <mbedtls_mpi_init_mempool>
    mbedtls_mpi_init_mempool( &RR );
 11423bc:	aa1a03e0 	mov	x0, x26
 11423c0:	97fff6fa 	bl	113ffa8 <mbedtls_mpi_init_mempool>

    /*
     * W = |X| - 1
     * R = W >> lsb( W )
     */
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &W, X, 1 ) );
 11423c4:	aa1603e1 	mov	x1, x22
 11423c8:	aa1503e0 	mov	x0, x21
 11423cc:	d2800022 	mov	x2, #0x1                   	// #1
 11423d0:	97fffa05 	bl	1140be4 <mbedtls_mpi_sub_int>
 11423d4:	2a0003f3 	mov	w19, w0
 11423d8:	350005c0 	cbnz	w0, 1142490 <mpi_miller_rabin+0x130>
    s = mbedtls_mpi_lsb( &W );
 11423dc:	aa1503e0 	mov	x0, x21
 11423e0:	97fff7bb 	bl	11402cc <mbedtls_mpi_lsb>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &R, &W ) );
 11423e4:	aa1503e1 	mov	x1, x21
    s = mbedtls_mpi_lsb( &W );
 11423e8:	aa0003f9 	mov	x25, x0
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &R, &W ) );
 11423ec:	aa1703e0 	mov	x0, x23
 11423f0:	97fff74d 	bl	1140124 <mbedtls_mpi_copy>
 11423f4:	2a0003f3 	mov	w19, w0
 11423f8:	350004c0 	cbnz	w0, 1142490 <mpi_miller_rabin+0x130>
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &R, s ) );
 11423fc:	aa1903e1 	mov	x1, x25
 1142400:	aa1703e0 	mov	x0, x23
 1142404:	97fff88d 	bl	1140638 <mbedtls_mpi_shift_r>
 1142408:	2a0003f3 	mov	w19, w0
 114240c:	35000420 	cbnz	w0, 1142490 <mpi_miller_rabin+0x130>

    for( i = 0; i < rounds; i++ )
 1142410:	d280001b 	mov	x27, #0x0                   	// #0
 1142414:	f94037e0 	ldr	x0, [sp, #104]
 1142418:	eb00037f 	cmp	x27, x0
 114241c:	540003a0 	b.eq	1142490 <mpi_miller_rabin+0x130>  // b.none
 1142420:	528025dc 	mov	w28, #0x12e                 	// #302
        /*
         * pick a random A, 1 < A < |X| - 1
         */
        count = 0;
        do {
            MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( &A, X->n * ciL, f_rng, p_rng ) );
 1142424:	a9470fe2 	ldp	x2, x3, [sp, #112]
 1142428:	aa1403e0 	mov	x0, x20
 114242c:	f94006c1 	ldr	x1, [x22, #8]
 1142430:	d37df021 	lsl	x1, x1, #3
 1142434:	97ffff9b 	bl	11422a0 <mbedtls_mpi_fill_random>
 1142438:	35000c60 	cbnz	w0, 11425c4 <mpi_miller_rabin+0x264>

            j = mbedtls_mpi_bitlen( &A );
 114243c:	aa1403e0 	mov	x0, x20
 1142440:	97fff7b8 	bl	1140320 <mbedtls_mpi_bitlen>
 1142444:	aa0003e4 	mov	x4, x0
            k = mbedtls_mpi_bitlen( &W );
 1142448:	aa1503e0 	mov	x0, x21
 114244c:	97fff7b5 	bl	1140320 <mbedtls_mpi_bitlen>
            if (j > k) {
 1142450:	eb00009f 	cmp	x4, x0
 1142454:	54000189 	b.ls	1142484 <mpi_miller_rabin+0x124>  // b.plast
                A.p[A.n - 1] &= ( (mbedtls_mpi_uint) 1 << ( k - ( A.n - 1 ) * biL - 1 ) ) - 1;
 1142458:	a94d8fe1 	ldp	x1, x3, [sp, #216]
 114245c:	d37df022 	lsl	x2, x1, #3
 1142460:	d1000421 	sub	x1, x1, #0x1
 1142464:	d1002042 	sub	x2, x2, #0x8
 1142468:	2a211be1 	mvn	w1, w1, lsl #6
 114246c:	0b000020 	add	w0, w1, w0
 1142470:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
 1142474:	9ac02020 	lsl	x0, x1, x0
 1142478:	f8626861 	ldr	x1, [x3, x2]
 114247c:	8a200020 	bic	x0, x1, x0
 1142480:	f8226860 	str	x0, [x3, x2]
            }

            if (count++ > 300) {
 1142484:	7100079c 	subs	w28, w28, #0x1
 1142488:	54000281 	b.ne	11424d8 <mpi_miller_rabin+0x178>  // b.any
                ret = MBEDTLS_ERR_MPI_NOT_ACCEPTABLE;
 114248c:	128001b3 	mov	w19, #0xfffffff2            	// #-14
            break;
        }
    }

cleanup:
    mbedtls_mpi_free( &W ); mbedtls_mpi_free( &R );
 1142490:	aa1503e0 	mov	x0, x21
 1142494:	97fff6cf 	bl	113ffd0 <mbedtls_mpi_free>
 1142498:	aa1703e0 	mov	x0, x23
 114249c:	97fff6cd 	bl	113ffd0 <mbedtls_mpi_free>
    mbedtls_mpi_free( &T ); mbedtls_mpi_free( &A );
 11424a0:	aa1803e0 	mov	x0, x24
 11424a4:	97fff6cb 	bl	113ffd0 <mbedtls_mpi_free>
 11424a8:	aa1403e0 	mov	x0, x20
 11424ac:	97fff6c9 	bl	113ffd0 <mbedtls_mpi_free>
    mbedtls_mpi_free( &RR );
 11424b0:	aa1a03e0 	mov	x0, x26
 11424b4:	97fff6c7 	bl	113ffd0 <mbedtls_mpi_free>

    return( ret );
}
 11424b8:	2a1303e0 	mov	w0, w19
 11424bc:	a94153f3 	ldp	x19, x20, [sp, #16]
 11424c0:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11424c4:	a94363f7 	ldp	x23, x24, [sp, #48]
 11424c8:	a9446bf9 	ldp	x25, x26, [sp, #64]
 11424cc:	a94573fb 	ldp	x27, x28, [sp, #80]
 11424d0:	a8d07bfd 	ldp	x29, x30, [sp], #256
 11424d4:	d65f03c0 	ret
        } while ( mbedtls_mpi_cmp_mpi( &A, &W ) >= 0 ||
 11424d8:	aa1503e1 	mov	x1, x21
 11424dc:	aa1403e0 	mov	x0, x20
 11424e0:	97fff8af 	bl	114079c <mbedtls_mpi_cmp_mpi>
                  mbedtls_mpi_cmp_int( &A, 1 )  <= 0    );
 11424e4:	36fffa00 	tbz	w0, #31, 1142424 <mpi_miller_rabin+0xc4>
 11424e8:	aa1403e0 	mov	x0, x20
 11424ec:	d2800021 	mov	x1, #0x1                   	// #1
 11424f0:	97fff8e0 	bl	1140870 <mbedtls_mpi_cmp_int>
        } while ( mbedtls_mpi_cmp_mpi( &A, &W ) >= 0 ||
 11424f4:	7100001f 	cmp	w0, #0x0
 11424f8:	54fff96d 	b.le	1142424 <mpi_miller_rabin+0xc4>
        MBEDTLS_MPI_CHK( mbedtls_mpi_exp_mod( &A, &A, &R, X, &RR ) );
 11424fc:	aa1a03e4 	mov	x4, x26
 1142500:	aa1603e3 	mov	x3, x22
 1142504:	aa1703e2 	mov	x2, x23
 1142508:	aa1403e1 	mov	x1, x20
 114250c:	aa1403e0 	mov	x0, x20
 1142510:	97fffd53 	bl	1141a5c <mbedtls_mpi_exp_mod>
 1142514:	35000580 	cbnz	w0, 11425c4 <mpi_miller_rabin+0x264>
        if( mbedtls_mpi_cmp_mpi( &A, &W ) == 0 ||
 1142518:	aa1503e1 	mov	x1, x21
 114251c:	aa1403e0 	mov	x0, x20
 1142520:	97fff89f 	bl	114079c <mbedtls_mpi_cmp_mpi>
 1142524:	35000060 	cbnz	w0, 1142530 <mpi_miller_rabin+0x1d0>
    for( i = 0; i < rounds; i++ )
 1142528:	9100077b 	add	x27, x27, #0x1
 114252c:	17ffffba 	b	1142414 <mpi_miller_rabin+0xb4>
            mbedtls_mpi_cmp_int( &A,  1 ) == 0 )
 1142530:	aa1403e0 	mov	x0, x20
 1142534:	d2800021 	mov	x1, #0x1                   	// #1
 1142538:	97fff8ce 	bl	1140870 <mbedtls_mpi_cmp_int>
        if( mbedtls_mpi_cmp_mpi( &A, &W ) == 0 ||
 114253c:	34ffff60 	cbz	w0, 1142528 <mpi_miller_rabin+0x1c8>
        j = 1;
 1142540:	d280003c 	mov	x28, #0x1                   	// #1
        while( j < s && mbedtls_mpi_cmp_mpi( &A, &W ) != 0 )
 1142544:	aa1503e1 	mov	x1, x21
 1142548:	aa1403e0 	mov	x0, x20
 114254c:	97fff894 	bl	114079c <mbedtls_mpi_cmp_mpi>
 1142550:	eb19039f 	cmp	x28, x25
 1142554:	540002e2 	b.cs	11425b0 <mpi_miller_rabin+0x250>  // b.hs, b.nlast
 1142558:	350000c0 	cbnz	w0, 1142570 <mpi_miller_rabin+0x210>
            mbedtls_mpi_cmp_int( &A,  1 ) == 0 )
 114255c:	aa1403e0 	mov	x0, x20
 1142560:	d2800021 	mov	x1, #0x1                   	// #1
 1142564:	97fff8c3 	bl	1140870 <mbedtls_mpi_cmp_int>
        if( mbedtls_mpi_cmp_mpi( &A, &W ) != 0 ||
 1142568:	35fffe00 	cbnz	w0, 1142528 <mpi_miller_rabin+0x1c8>
 114256c:	17ffffc8 	b	114248c <mpi_miller_rabin+0x12c>
            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T, &A, &A ) );
 1142570:	aa1403e2 	mov	x2, x20
 1142574:	aa1403e1 	mov	x1, x20
 1142578:	aa1803e0 	mov	x0, x24
 114257c:	97fff9aa 	bl	1140c24 <mbedtls_mpi_mul_mpi>
 1142580:	35000220 	cbnz	w0, 11425c4 <mpi_miller_rabin+0x264>
            MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &A, &T, X  ) );
 1142584:	aa1603e2 	mov	x2, x22
 1142588:	aa1803e1 	mov	x1, x24
 114258c:	aa1403e0 	mov	x0, x20
 1142590:	97fffbd6 	bl	11414e8 <mbedtls_mpi_mod_mpi>
 1142594:	35000180 	cbnz	w0, 11425c4 <mpi_miller_rabin+0x264>
            if( mbedtls_mpi_cmp_int( &A, 1 ) == 0 )
 1142598:	aa1403e0 	mov	x0, x20
 114259c:	d2800021 	mov	x1, #0x1                   	// #1
 11425a0:	97fff8b4 	bl	1140870 <mbedtls_mpi_cmp_int>
 11425a4:	34000060 	cbz	w0, 11425b0 <mpi_miller_rabin+0x250>
            j++;
 11425a8:	9100079c 	add	x28, x28, #0x1
 11425ac:	17ffffe6 	b	1142544 <mpi_miller_rabin+0x1e4>
        if( mbedtls_mpi_cmp_mpi( &A, &W ) != 0 ||
 11425b0:	aa1503e1 	mov	x1, x21
 11425b4:	aa1403e0 	mov	x0, x20
 11425b8:	97fff879 	bl	114079c <mbedtls_mpi_cmp_mpi>
 11425bc:	34fffd00 	cbz	w0, 114255c <mpi_miller_rabin+0x1fc>
 11425c0:	17ffffb3 	b	114248c <mpi_miller_rabin+0x12c>
 11425c4:	2a0003f3 	mov	w19, w0
 11425c8:	17ffffb2 	b	1142490 <mpi_miller_rabin+0x130>

00000000011425cc <mbedtls_mpi_inv_mod>:
{
 11425cc:	a9ab7bfd 	stp	x29, x30, [sp, #-336]!
 11425d0:	910003fd 	mov	x29, sp
 11425d4:	a90153f3 	stp	x19, x20, [sp, #16]
 11425d8:	aa0203f4 	mov	x20, x2
 11425dc:	a9025bf5 	stp	x21, x22, [sp, #32]
 11425e0:	a90363f7 	stp	x23, x24, [sp, #48]
 11425e4:	a9046bf9 	stp	x25, x26, [sp, #64]
 11425e8:	a90573fb 	stp	x27, x28, [sp, #80]
 11425ec:	a90603e1 	stp	x1, x0, [sp, #96]
    if( mbedtls_mpi_cmp_int( N, 1 ) <= 0 )
 11425f0:	aa0203e0 	mov	x0, x2
 11425f4:	d2800021 	mov	x1, #0x1                   	// #1
 11425f8:	97fff89e 	bl	1140870 <mbedtls_mpi_cmp_int>
 11425fc:	7100001f 	cmp	w0, #0x0
 1142600:	54001f6d 	b.le	11429ec <mbedtls_mpi_inv_mod+0x420>
    mbedtls_mpi_init_mempool( &TA ); mbedtls_mpi_init_mempool( &TU );
 1142604:	910243fa 	add	x26, sp, #0x90
 1142608:	9102a3f8 	add	x24, sp, #0xa8
 114260c:	aa1a03e0 	mov	x0, x26
 1142610:	97fff666 	bl	113ffa8 <mbedtls_mpi_init_mempool>
 1142614:	aa1803e0 	mov	x0, x24
    mbedtls_mpi_init_mempool( &U1 ); mbedtls_mpi_init_mempool( &U2 );
 1142618:	910303f7 	add	x23, sp, #0xc0
    mbedtls_mpi_init_mempool( &TA ); mbedtls_mpi_init_mempool( &TU );
 114261c:	97fff663 	bl	113ffa8 <mbedtls_mpi_init_mempool>
    mbedtls_mpi_init_mempool( &U1 ); mbedtls_mpi_init_mempool( &U2 );
 1142620:	910363f6 	add	x22, sp, #0xd8
 1142624:	aa1703e0 	mov	x0, x23
 1142628:	97fff660 	bl	113ffa8 <mbedtls_mpi_init_mempool>
 114262c:	aa1603e0 	mov	x0, x22
    mbedtls_mpi_init_mempool( &G ); mbedtls_mpi_init_mempool( &TB );
 1142630:	9101e3fc 	add	x28, sp, #0x78
    mbedtls_mpi_init_mempool( &U1 ); mbedtls_mpi_init_mempool( &U2 );
 1142634:	97fff65d 	bl	113ffa8 <mbedtls_mpi_init_mempool>
    mbedtls_mpi_init_mempool( &G ); mbedtls_mpi_init_mempool( &TB );
 1142638:	9103c3fb 	add	x27, sp, #0xf0
 114263c:	aa1c03e0 	mov	x0, x28
 1142640:	97fff65a 	bl	113ffa8 <mbedtls_mpi_init_mempool>
 1142644:	aa1b03e0 	mov	x0, x27
    mbedtls_mpi_init_mempool( &TV ); mbedtls_mpi_init_mempool( &V1 );
 1142648:	910423f9 	add	x25, sp, #0x108
    mbedtls_mpi_init_mempool( &G ); mbedtls_mpi_init_mempool( &TB );
 114264c:	97fff657 	bl	113ffa8 <mbedtls_mpi_init_mempool>
    mbedtls_mpi_init_mempool( &TV ); mbedtls_mpi_init_mempool( &V1 );
 1142650:	910483f3 	add	x19, sp, #0x120
 1142654:	aa1903e0 	mov	x0, x25
 1142658:	97fff654 	bl	113ffa8 <mbedtls_mpi_init_mempool>
 114265c:	aa1303e0 	mov	x0, x19
    mbedtls_mpi_init_mempool( &V2 );
 1142660:	9104e3f5 	add	x21, sp, #0x138
    mbedtls_mpi_init_mempool( &TV ); mbedtls_mpi_init_mempool( &V1 );
 1142664:	97fff651 	bl	113ffa8 <mbedtls_mpi_init_mempool>
    mbedtls_mpi_init_mempool( &V2 );
 1142668:	aa1503e0 	mov	x0, x21
 114266c:	97fff64f 	bl	113ffa8 <mbedtls_mpi_init_mempool>
    MBEDTLS_MPI_CHK( mbedtls_mpi_gcd( &G, A, N ) );
 1142670:	f94033e1 	ldr	x1, [sp, #96]
 1142674:	aa1403e2 	mov	x2, x20
 1142678:	aa1c03e0 	mov	x0, x28
 114267c:	97fffea0 	bl	11420fc <mbedtls_mpi_gcd>
 1142680:	2a0003e1 	mov	w1, w0
 1142684:	35000d60 	cbnz	w0, 1142830 <mbedtls_mpi_inv_mod+0x264>
    if( mbedtls_mpi_cmp_int( &G, 1 ) != 0 )
 1142688:	aa1c03e0 	mov	x0, x28
 114268c:	d2800021 	mov	x1, #0x1                   	// #1
 1142690:	97fff878 	bl	1140870 <mbedtls_mpi_cmp_int>
 1142694:	35001a80 	cbnz	w0, 11429e4 <mbedtls_mpi_inv_mod+0x418>
    MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &TA, A, N ) );
 1142698:	f94033e1 	ldr	x1, [sp, #96]
 114269c:	aa1403e2 	mov	x2, x20
 11426a0:	aa1a03e0 	mov	x0, x26
 11426a4:	97fffb91 	bl	11414e8 <mbedtls_mpi_mod_mpi>
 11426a8:	2a0003e1 	mov	w1, w0
 11426ac:	35000c20 	cbnz	w0, 1142830 <mbedtls_mpi_inv_mod+0x264>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TU, &TA ) );
 11426b0:	aa1a03e1 	mov	x1, x26
 11426b4:	aa1803e0 	mov	x0, x24
 11426b8:	97fff69b 	bl	1140124 <mbedtls_mpi_copy>
 11426bc:	2a0003e1 	mov	w1, w0
 11426c0:	35000b80 	cbnz	w0, 1142830 <mbedtls_mpi_inv_mod+0x264>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TB, N ) );
 11426c4:	aa1403e1 	mov	x1, x20
 11426c8:	aa1b03e0 	mov	x0, x27
 11426cc:	97fff696 	bl	1140124 <mbedtls_mpi_copy>
 11426d0:	2a0003e1 	mov	w1, w0
 11426d4:	35000ae0 	cbnz	w0, 1142830 <mbedtls_mpi_inv_mod+0x264>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TV, N ) );
 11426d8:	aa1403e1 	mov	x1, x20
 11426dc:	aa1903e0 	mov	x0, x25
 11426e0:	97fff691 	bl	1140124 <mbedtls_mpi_copy>
 11426e4:	2a0003e1 	mov	w1, w0
 11426e8:	35000a40 	cbnz	w0, 1142830 <mbedtls_mpi_inv_mod+0x264>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &U1, 1 ) );
 11426ec:	d2800021 	mov	x1, #0x1                   	// #1
 11426f0:	aa1703e0 	mov	x0, x23
 11426f4:	97fff6b9 	bl	11401d8 <mbedtls_mpi_lset>
 11426f8:	2a0003e1 	mov	w1, w0
 11426fc:	350009a0 	cbnz	w0, 1142830 <mbedtls_mpi_inv_mod+0x264>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &U2, 0 ) );
 1142700:	d2800001 	mov	x1, #0x0                   	// #0
 1142704:	aa1603e0 	mov	x0, x22
 1142708:	97fff6b4 	bl	11401d8 <mbedtls_mpi_lset>
 114270c:	2a0003e1 	mov	w1, w0
 1142710:	35000900 	cbnz	w0, 1142830 <mbedtls_mpi_inv_mod+0x264>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &V1, 0 ) );
 1142714:	d2800001 	mov	x1, #0x0                   	// #0
 1142718:	aa1303e0 	mov	x0, x19
 114271c:	97fff6af 	bl	11401d8 <mbedtls_mpi_lset>
 1142720:	2a0003e1 	mov	w1, w0
 1142724:	35000860 	cbnz	w0, 1142830 <mbedtls_mpi_inv_mod+0x264>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &V2, 1 ) );
 1142728:	aa1503e0 	mov	x0, x21
 114272c:	d2800021 	mov	x1, #0x1                   	// #1
 1142730:	97fff6aa 	bl	11401d8 <mbedtls_mpi_lset>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &U2, 1 ) );
 1142734:	2a0003e1 	mov	w1, w0
 1142738:	350007c0 	cbnz	w0, 1142830 <mbedtls_mpi_inv_mod+0x264>
        while( ( TU.p[0] & 1 ) == 0 )
 114273c:	f9405fe0 	ldr	x0, [sp, #184]
 1142740:	f9400000 	ldr	x0, [x0]
 1142744:	36000560 	tbz	w0, #0, 11427f0 <mbedtls_mpi_inv_mod+0x224>
        while( ( TV.p[0] & 1 ) == 0 )
 1142748:	f9408fe0 	ldr	x0, [sp, #280]
 114274c:	f9400000 	ldr	x0, [x0]
 1142750:	36000ca0 	tbz	w0, #0, 11428e4 <mbedtls_mpi_inv_mod+0x318>
        if( mbedtls_mpi_cmp_mpi( &TU, &TV ) >= 0 )
 1142754:	aa1903e1 	mov	x1, x25
 1142758:	aa1803e0 	mov	x0, x24
 114275c:	97fff810 	bl	114079c <mbedtls_mpi_cmp_mpi>
 1142760:	37f81080 	tbnz	w0, #31, 1142970 <mbedtls_mpi_inv_mod+0x3a4>
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &TU, &TU, &TV ) );
 1142764:	aa1803e1 	mov	x1, x24
 1142768:	aa1903e2 	mov	x2, x25
 114276c:	aa1803e0 	mov	x0, x24
 1142770:	97fff8ec 	bl	1140b20 <mbedtls_mpi_sub_mpi>
 1142774:	2a0003e1 	mov	w1, w0
 1142778:	350005c0 	cbnz	w0, 1142830 <mbedtls_mpi_inv_mod+0x264>
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &U1, &U1, &V1 ) );
 114277c:	aa1703e1 	mov	x1, x23
 1142780:	aa1303e2 	mov	x2, x19
 1142784:	aa1703e0 	mov	x0, x23
 1142788:	97fff8e6 	bl	1140b20 <mbedtls_mpi_sub_mpi>
 114278c:	2a0003e1 	mov	w1, w0
 1142790:	35000500 	cbnz	w0, 1142830 <mbedtls_mpi_inv_mod+0x264>
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &U2, &U2, &V2 ) );
 1142794:	aa1503e2 	mov	x2, x21
 1142798:	aa1603e1 	mov	x1, x22
 114279c:	aa1603e0 	mov	x0, x22
 11427a0:	97fff8e0 	bl	1140b20 <mbedtls_mpi_sub_mpi>
 11427a4:	2a0003e1 	mov	w1, w0
 11427a8:	35000440 	cbnz	w0, 1142830 <mbedtls_mpi_inv_mod+0x264>
    while( mbedtls_mpi_cmp_int( &TU, 0 ) != 0 );
 11427ac:	aa1803e0 	mov	x0, x24
 11427b0:	d2800001 	mov	x1, #0x0                   	// #0
 11427b4:	97fff82f 	bl	1140870 <mbedtls_mpi_cmp_int>
 11427b8:	35fffc20 	cbnz	w0, 114273c <mbedtls_mpi_inv_mod+0x170>
    while( mbedtls_mpi_cmp_int( &V1, 0 ) < 0 )
 11427bc:	aa1303e0 	mov	x0, x19
 11427c0:	d2800001 	mov	x1, #0x0                   	// #0
 11427c4:	97fff82b 	bl	1140870 <mbedtls_mpi_cmp_int>
 11427c8:	37f80f20 	tbnz	w0, #31, 11429ac <mbedtls_mpi_inv_mod+0x3e0>
    while( mbedtls_mpi_cmp_mpi( &V1, N ) >= 0 )
 11427cc:	aa1403e1 	mov	x1, x20
 11427d0:	aa1303e0 	mov	x0, x19
 11427d4:	97fff7f2 	bl	114079c <mbedtls_mpi_cmp_mpi>
 11427d8:	36f80f80 	tbz	w0, #31, 11429c8 <mbedtls_mpi_inv_mod+0x3fc>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( X, &V1 ) );
 11427dc:	f94037e0 	ldr	x0, [sp, #104]
 11427e0:	aa1303e1 	mov	x1, x19
 11427e4:	97fff650 	bl	1140124 <mbedtls_mpi_copy>
 11427e8:	2a0003e1 	mov	w1, w0
cleanup:
 11427ec:	14000011 	b	1142830 <mbedtls_mpi_inv_mod+0x264>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TU, 1 ) );
 11427f0:	d2800021 	mov	x1, #0x1                   	// #1
 11427f4:	aa1803e0 	mov	x0, x24
 11427f8:	97fff790 	bl	1140638 <mbedtls_mpi_shift_r>
 11427fc:	2a0003e1 	mov	w1, w0
 1142800:	35000180 	cbnz	w0, 1142830 <mbedtls_mpi_inv_mod+0x264>
            if( ( U1.p[0] & 1 ) != 0 || ( U2.p[0] & 1 ) != 0 )
 1142804:	f9406be0 	ldr	x0, [sp, #208]
 1142808:	f9400000 	ldr	x0, [x0]
 114280c:	370004a0 	tbnz	w0, #0, 11428a0 <mbedtls_mpi_inv_mod+0x2d4>
 1142810:	f94077e0 	ldr	x0, [sp, #232]
 1142814:	f9400000 	ldr	x0, [x0]
 1142818:	37000440 	tbnz	w0, #0, 11428a0 <mbedtls_mpi_inv_mod+0x2d4>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &U1, 1 ) );
 114281c:	d2800021 	mov	x1, #0x1                   	// #1
 1142820:	aa1703e0 	mov	x0, x23
 1142824:	97fff785 	bl	1140638 <mbedtls_mpi_shift_r>
 1142828:	2a0003e1 	mov	w1, w0
 114282c:	34000540 	cbz	w0, 11428d4 <mbedtls_mpi_inv_mod+0x308>
    mbedtls_mpi_free( &TA ); mbedtls_mpi_free( &TU ); mbedtls_mpi_free( &U1 ); mbedtls_mpi_free( &U2 );
 1142830:	aa1a03e0 	mov	x0, x26
 1142834:	b90063e1 	str	w1, [sp, #96]
 1142838:	97fff5e6 	bl	113ffd0 <mbedtls_mpi_free>
 114283c:	aa1803e0 	mov	x0, x24
 1142840:	97fff5e4 	bl	113ffd0 <mbedtls_mpi_free>
 1142844:	aa1703e0 	mov	x0, x23
 1142848:	97fff5e2 	bl	113ffd0 <mbedtls_mpi_free>
 114284c:	aa1603e0 	mov	x0, x22
 1142850:	97fff5e0 	bl	113ffd0 <mbedtls_mpi_free>
    mbedtls_mpi_free( &G ); mbedtls_mpi_free( &TB ); mbedtls_mpi_free( &TV );
 1142854:	aa1c03e0 	mov	x0, x28
 1142858:	97fff5de 	bl	113ffd0 <mbedtls_mpi_free>
 114285c:	aa1b03e0 	mov	x0, x27
 1142860:	97fff5dc 	bl	113ffd0 <mbedtls_mpi_free>
 1142864:	aa1903e0 	mov	x0, x25
 1142868:	97fff5da 	bl	113ffd0 <mbedtls_mpi_free>
    mbedtls_mpi_free( &V1 ); mbedtls_mpi_free( &V2 );
 114286c:	aa1303e0 	mov	x0, x19
 1142870:	97fff5d8 	bl	113ffd0 <mbedtls_mpi_free>
 1142874:	aa1503e0 	mov	x0, x21
 1142878:	97fff5d6 	bl	113ffd0 <mbedtls_mpi_free>
    return( ret );
 114287c:	b94063e1 	ldr	w1, [sp, #96]
}
 1142880:	2a0103e0 	mov	w0, w1
 1142884:	a94153f3 	ldp	x19, x20, [sp, #16]
 1142888:	a9425bf5 	ldp	x21, x22, [sp, #32]
 114288c:	a94363f7 	ldp	x23, x24, [sp, #48]
 1142890:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1142894:	a94573fb 	ldp	x27, x28, [sp, #80]
 1142898:	a8d57bfd 	ldp	x29, x30, [sp], #336
 114289c:	d65f03c0 	ret
                MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &U1, &U1, &TB ) );
 11428a0:	aa1703e1 	mov	x1, x23
 11428a4:	aa1b03e2 	mov	x2, x27
 11428a8:	aa1703e0 	mov	x0, x23
 11428ac:	97fff87d 	bl	1140aa0 <mbedtls_mpi_add_mpi>
 11428b0:	2a0003e1 	mov	w1, w0
 11428b4:	35fffbe0 	cbnz	w0, 1142830 <mbedtls_mpi_inv_mod+0x264>
                MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &U2, &U2, &TA ) );
 11428b8:	aa1603e1 	mov	x1, x22
 11428bc:	aa1a03e2 	mov	x2, x26
 11428c0:	aa1603e0 	mov	x0, x22
 11428c4:	97fff897 	bl	1140b20 <mbedtls_mpi_sub_mpi>
 11428c8:	2a0003e1 	mov	w1, w0
 11428cc:	34fffa80 	cbz	w0, 114281c <mbedtls_mpi_inv_mod+0x250>
 11428d0:	17ffffd8 	b	1142830 <mbedtls_mpi_inv_mod+0x264>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &U2, 1 ) );
 11428d4:	aa1603e0 	mov	x0, x22
 11428d8:	d2800021 	mov	x1, #0x1                   	// #1
 11428dc:	97fff757 	bl	1140638 <mbedtls_mpi_shift_r>
 11428e0:	17ffff95 	b	1142734 <mbedtls_mpi_inv_mod+0x168>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TV, 1 ) );
 11428e4:	d2800021 	mov	x1, #0x1                   	// #1
 11428e8:	aa1903e0 	mov	x0, x25
 11428ec:	97fff753 	bl	1140638 <mbedtls_mpi_shift_r>
 11428f0:	2a0003e1 	mov	w1, w0
 11428f4:	35fff9e0 	cbnz	w0, 1142830 <mbedtls_mpi_inv_mod+0x264>
            if( ( V1.p[0] & 1 ) != 0 || ( V2.p[0] & 1 ) != 0 )
 11428f8:	f9409be0 	ldr	x0, [sp, #304]
 11428fc:	f9400000 	ldr	x0, [x0]
 1142900:	370001e0 	tbnz	w0, #0, 114293c <mbedtls_mpi_inv_mod+0x370>
 1142904:	f940a7e0 	ldr	x0, [sp, #328]
 1142908:	f9400000 	ldr	x0, [x0]
 114290c:	37000180 	tbnz	w0, #0, 114293c <mbedtls_mpi_inv_mod+0x370>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &V1, 1 ) );
 1142910:	d2800021 	mov	x1, #0x1                   	// #1
 1142914:	aa1303e0 	mov	x0, x19
 1142918:	97fff748 	bl	1140638 <mbedtls_mpi_shift_r>
 114291c:	2a0003e1 	mov	w1, w0
 1142920:	35fff880 	cbnz	w0, 1142830 <mbedtls_mpi_inv_mod+0x264>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &V2, 1 ) );
 1142924:	d2800021 	mov	x1, #0x1                   	// #1
 1142928:	aa1503e0 	mov	x0, x21
 114292c:	97fff743 	bl	1140638 <mbedtls_mpi_shift_r>
 1142930:	2a0003e1 	mov	w1, w0
 1142934:	34fff0a0 	cbz	w0, 1142748 <mbedtls_mpi_inv_mod+0x17c>
 1142938:	17ffffbe 	b	1142830 <mbedtls_mpi_inv_mod+0x264>
                MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &V1, &V1, &TB ) );
 114293c:	aa1303e1 	mov	x1, x19
 1142940:	aa1b03e2 	mov	x2, x27
 1142944:	aa1303e0 	mov	x0, x19
 1142948:	97fff856 	bl	1140aa0 <mbedtls_mpi_add_mpi>
 114294c:	2a0003e1 	mov	w1, w0
 1142950:	35fff700 	cbnz	w0, 1142830 <mbedtls_mpi_inv_mod+0x264>
                MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &V2, &V2, &TA ) );
 1142954:	aa1503e1 	mov	x1, x21
 1142958:	aa1a03e2 	mov	x2, x26
 114295c:	aa1503e0 	mov	x0, x21
 1142960:	97fff870 	bl	1140b20 <mbedtls_mpi_sub_mpi>
 1142964:	2a0003e1 	mov	w1, w0
 1142968:	34fffd40 	cbz	w0, 1142910 <mbedtls_mpi_inv_mod+0x344>
 114296c:	17ffffb1 	b	1142830 <mbedtls_mpi_inv_mod+0x264>
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &TV, &TV, &TU ) );
 1142970:	aa1803e2 	mov	x2, x24
 1142974:	aa1903e0 	mov	x0, x25
 1142978:	97fff86a 	bl	1140b20 <mbedtls_mpi_sub_mpi>
 114297c:	2a0003e1 	mov	w1, w0
 1142980:	35fff580 	cbnz	w0, 1142830 <mbedtls_mpi_inv_mod+0x264>
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &V1, &V1, &U1 ) );
 1142984:	aa1303e1 	mov	x1, x19
 1142988:	aa1703e2 	mov	x2, x23
 114298c:	aa1303e0 	mov	x0, x19
 1142990:	97fff864 	bl	1140b20 <mbedtls_mpi_sub_mpi>
 1142994:	2a0003e1 	mov	w1, w0
 1142998:	35fff4c0 	cbnz	w0, 1142830 <mbedtls_mpi_inv_mod+0x264>
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &V2, &V2, &U2 ) );
 114299c:	aa1603e2 	mov	x2, x22
 11429a0:	aa1503e1 	mov	x1, x21
 11429a4:	aa1503e0 	mov	x0, x21
 11429a8:	17ffff7e 	b	11427a0 <mbedtls_mpi_inv_mod+0x1d4>
        MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &V1, &V1, N ) );
 11429ac:	aa1303e1 	mov	x1, x19
 11429b0:	aa1403e2 	mov	x2, x20
 11429b4:	aa1303e0 	mov	x0, x19
 11429b8:	97fff83a 	bl	1140aa0 <mbedtls_mpi_add_mpi>
 11429bc:	2a0003e1 	mov	w1, w0
 11429c0:	34ffefe0 	cbz	w0, 11427bc <mbedtls_mpi_inv_mod+0x1f0>
 11429c4:	17ffff9b 	b	1142830 <mbedtls_mpi_inv_mod+0x264>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &V1, &V1, N ) );
 11429c8:	aa1303e1 	mov	x1, x19
 11429cc:	aa1403e2 	mov	x2, x20
 11429d0:	aa1303e0 	mov	x0, x19
 11429d4:	97fff853 	bl	1140b20 <mbedtls_mpi_sub_mpi>
 11429d8:	2a0003e1 	mov	w1, w0
 11429dc:	34ffef80 	cbz	w0, 11427cc <mbedtls_mpi_inv_mod+0x200>
 11429e0:	17ffff94 	b	1142830 <mbedtls_mpi_inv_mod+0x264>
        ret = MBEDTLS_ERR_MPI_NOT_ACCEPTABLE;
 11429e4:	128001a1 	mov	w1, #0xfffffff2            	// #-14
 11429e8:	17ffff92 	b	1142830 <mbedtls_mpi_inv_mod+0x264>
        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );
 11429ec:	12800061 	mov	w1, #0xfffffffc            	// #-4
 11429f0:	17ffffa4 	b	1142880 <mbedtls_mpi_inv_mod+0x2b4>

00000000011429f4 <mbedtls_mpi_is_prime_ext>:
 * Pseudo-primality test: small factors, then Miller-Rabin
 */
int mbedtls_mpi_is_prime_ext( const mbedtls_mpi *X, int rounds,
                              int (*f_rng)(void *, unsigned char *, size_t),
                              void *p_rng )
{
 11429f4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 11429f8:	2a0103ec 	mov	w12, w1
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    mbedtls_mpi XX;
    MPI_VALIDATE_RET( X     != NULL );
    MPI_VALIDATE_RET( f_rng != NULL );

    XX.s = 1;
 11429fc:	52800021 	mov	w1, #0x1                   	// #1
{
 1142a00:	910003fd 	mov	x29, sp
    XX.s = 1;
 1142a04:	790033e1 	strh	w1, [sp, #24]
    XX.n = X->n;
    XX.p = X->p;

    if( mbedtls_mpi_cmp_int( &XX, 0 ) == 0 ||
 1142a08:	910063eb 	add	x11, sp, #0x18
    XX.p = X->p;
 1142a0c:	a9408001 	ldp	x1, x0, [x0, #8]
{
 1142a10:	aa0203ed 	mov	x13, x2
 1142a14:	aa0303ee 	mov	x14, x3
    XX.p = X->p;
 1142a18:	a90203e1 	stp	x1, x0, [sp, #32]
    if( mbedtls_mpi_cmp_int( &XX, 0 ) == 0 ||
 1142a1c:	aa0b03e0 	mov	x0, x11
 1142a20:	d2800001 	mov	x1, #0x0                   	// #0
 1142a24:	97fff793 	bl	1140870 <mbedtls_mpi_cmp_int>
 1142a28:	340002e0 	cbz	w0, 1142a84 <mbedtls_mpi_is_prime_ext+0x90>
        mbedtls_mpi_cmp_int( &XX, 1 ) == 0 )
 1142a2c:	aa0b03e0 	mov	x0, x11
 1142a30:	d2800021 	mov	x1, #0x1                   	// #1
 1142a34:	97fff78f 	bl	1140870 <mbedtls_mpi_cmp_int>
    if( mbedtls_mpi_cmp_int( &XX, 0 ) == 0 ||
 1142a38:	34000260 	cbz	w0, 1142a84 <mbedtls_mpi_is_prime_ext+0x90>
        return( MBEDTLS_ERR_MPI_NOT_ACCEPTABLE );

    if( mbedtls_mpi_cmp_int( &XX, 2 ) == 0 )
 1142a3c:	aa0b03e0 	mov	x0, x11
 1142a40:	d2800041 	mov	x1, #0x2                   	// #2
 1142a44:	97fff78b 	bl	1140870 <mbedtls_mpi_cmp_int>
 1142a48:	340000c0 	cbz	w0, 1142a60 <mbedtls_mpi_is_prime_ext+0x6c>
        return( 0 );

    if( ( ret = mpi_check_small_factors( &XX ) ) != 0 )
 1142a4c:	aa0b03e0 	mov	x0, x11
 1142a50:	97fffb77 	bl	114182c <mpi_check_small_factors>
 1142a54:	340000c0 	cbz	w0, 1142a6c <mbedtls_mpi_is_prime_ext+0x78>
    {
        if( ret == 1 )
 1142a58:	7100041f 	cmp	w0, #0x1
 1142a5c:	54000041 	b.ne	1142a64 <mbedtls_mpi_is_prime_ext+0x70>  // b.any
            return( 0 );
 1142a60:	52800000 	mov	w0, #0x0                   	// #0

        return( ret );
    }

    return( mpi_miller_rabin( &XX, rounds, f_rng, p_rng ) );
}
 1142a64:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1142a68:	d65f03c0 	ret
    return( mpi_miller_rabin( &XX, rounds, f_rng, p_rng ) );
 1142a6c:	aa0e03e3 	mov	x3, x14
 1142a70:	aa0d03e2 	mov	x2, x13
 1142a74:	93407d81 	sxtw	x1, w12
 1142a78:	aa0b03e0 	mov	x0, x11
 1142a7c:	97fffe39 	bl	1142360 <mpi_miller_rabin>
 1142a80:	17fffff9 	b	1142a64 <mbedtls_mpi_is_prime_ext+0x70>
        return( MBEDTLS_ERR_MPI_NOT_ACCEPTABLE );
 1142a84:	128001a0 	mov	w0, #0xfffffff2            	// #-14
 1142a88:	17fffff7 	b	1142a64 <mbedtls_mpi_is_prime_ext+0x70>

0000000001142a8c <mbedtls_mpi_is_prime>:
    /*
     * In the past our key generation aimed for an error rate of at most
     * 2^-80. Since this function is deprecated, aim for the same certainty
     * here as well.
     */
    return( mbedtls_mpi_is_prime_ext( X, 40, f_rng, p_rng ) );
 1142a8c:	aa0203e3 	mov	x3, x2
 1142a90:	aa0103e2 	mov	x2, x1
 1142a94:	52800501 	mov	w1, #0x28                  	// #40
 1142a98:	17ffffd7 	b	11429f4 <mbedtls_mpi_is_prime_ext>

0000000001142a9c <mbedtls_platform_zeroize>:
 * platform and needs.
 */
static void * (* const volatile memset_func)( void *, int, size_t ) = memset;

void mbedtls_platform_zeroize( void *buf, size_t len )
{
 1142a9c:	aa0103e2 	mov	x2, x1
    MBEDTLS_INTERNAL_VALIDATE( len == 0 || buf != NULL );

    if( len > 0 )
 1142aa0:	b40000c1 	cbz	x1, 1142ab8 <mbedtls_platform_zeroize+0x1c>
        memset_func( buf, 0, len );
 1142aa4:	f00000c1 	adrp	x1, 115d000 <_curve_names+0x590>
 1142aa8:	f945a823 	ldr	x3, [x1, #2896]
 1142aac:	52800001 	mov	w1, #0x0                   	// #0
 1142ab0:	aa0303f0 	mov	x16, x3
 1142ab4:	d61f0200 	br	x16
}
 1142ab8:	d65f03c0 	ret

0000000001142abc <raw_malloc_return_hook.constprop.0>:
#ifdef BufStats

static void raw_malloc_return_hook(void *p, size_t requested_size,
				   struct malloc_ctx *ctx)
{
	if (ctx->poolset.totalloc > ctx->mstats.max_allocated)
 1142abc:	f00000c2 	adrp	x2, 115d000 <_curve_names+0x590>
 1142ac0:	912d6044 	add	x4, x2, #0xb58
 1142ac4:	f9401083 	ldr	x3, [x4, #32]
 1142ac8:	b9406c85 	ldr	w5, [x4, #108]
 1142acc:	eb05007f 	cmp	x3, x5
 1142ad0:	5400004d 	b.le	1142ad8 <raw_malloc_return_hook.constprop.0+0x1c>
		ctx->mstats.max_allocated = ctx->poolset.totalloc;
 1142ad4:	b9006c83 	str	w3, [x4, #108]

	if (!p) {
 1142ad8:	b5000120 	cbnz	x0, 1142afc <raw_malloc_return_hook.constprop.0+0x40>
		ctx->mstats.num_alloc_fail++;
 1142adc:	912d6040 	add	x0, x2, #0xb58
 1142ae0:	b9407402 	ldr	w2, [x0, #116]
 1142ae4:	11000442 	add	w2, w2, #0x1
 1142ae8:	b9007402 	str	w2, [x0, #116]
		print_oom(requested_size, ctx);
		if (requested_size > ctx->mstats.biggest_alloc_fail) {
 1142aec:	b9407802 	ldr	w2, [x0, #120]
 1142af0:	eb01005f 	cmp	x2, x1
 1142af4:	54000042 	b.cs	1142afc <raw_malloc_return_hook.constprop.0+0x40>  // b.hs, b.nlast
			ctx->mstats.biggest_alloc_fail = requested_size;
			ctx->mstats.biggest_alloc_fail_used =
 1142af8:	290f0c01 	stp	w1, w3, [x0, #120]
				ctx->poolset.totalloc;
		}
	}
}
 1142afc:	d65f03c0 	ret

0000000001142b00 <malloc_lock.constprop.0>:
static uint32_t malloc_lock(struct malloc_ctx *ctx)
 1142b00:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
	uint32_t exceptions = thread_mask_exceptions(THREAD_EXCP_ALL);
 1142b04:	528000e0 	mov	w0, #0x7                   	// #7
 1142b08:	910003fd 	mov	x29, sp
 1142b0c:	a90153f3 	stp	x19, x20, [sp, #16]
 1142b10:	a9025bf5 	stp	x21, x22, [sp, #32]
 1142b14:	a90363f7 	stp	x23, x24, [sp, #48]
 1142b18:	97ff0988 	bl	1105138 <thread_mask_exceptions>
 1142b1c:	2a0003f5 	mov	w21, w0
 1142b20:	97ff08fd 	bl	1104f14 <thread_get_exceptions>
	assert(thread_foreign_intr_disabled());
 1142b24:	36080260 	tbz	w0, #1, 1142b70 <malloc_lock.constprop.0+0x70>
	while (__cpu_spin_trylock(lock)) {
 1142b28:	f00000d3 	adrp	x19, 115d000 <_curve_names+0x590>
 1142b2c:	912d6273 	add	x19, x19, #0xb58
			trace_printf(func, line, TRACE_ERROR, true,
 1142b30:	f0000077 	adrp	x23, 1151000 <small_prime+0x168>
	while (__cpu_spin_trylock(lock)) {
 1142b34:	91020273 	add	x19, x19, #0x80
			trace_printf(func, line, TRACE_ERROR, true,
 1142b38:	911316f7 	add	x23, x23, #0x4c5
 1142b3c:	52800014 	mov	w20, #0x0                   	// #0
		if (!retries) {
 1142b40:	d2c00038 	mov	x24, #0x100000000           	// #4294967296
	unsigned int reminder = 0;
 1142b44:	d2800016 	mov	x22, #0x0                   	// #0
	while (__cpu_spin_trylock(lock)) {
 1142b48:	aa1303e0 	mov	x0, x19
 1142b4c:	97ff0656 	bl	11044a4 <__cpu_spin_trylock>
 1142b50:	35000220 	cbnz	w0, 1142b94 <malloc_lock.constprop.0+0x94>
	spinlock_count_incr();
 1142b54:	97ff065d 	bl	11044c8 <spinlock_count_incr>
}
 1142b58:	2a1503e0 	mov	w0, w21
 1142b5c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1142b60:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1142b64:	a94363f7 	ldp	x23, x24, [sp, #48]
 1142b68:	a8c47bfd 	ldp	x29, x30, [sp], #64
 1142b6c:	d65f03c0 	ret
	assert(thread_foreign_intr_disabled());
 1142b70:	f00000a3 	adrp	x3, 1159000 <Worder+0x2854>
 1142b74:	f0000061 	adrp	x1, 1151000 <small_prime+0x168>
 1142b78:	91323063 	add	x3, x3, #0xc8c
 1142b7c:	9111f821 	add	x1, x1, #0x47e
 1142b80:	f0000060 	adrp	x0, 1151000 <small_prime+0x168>
 1142b84:	91129800 	add	x0, x0, #0x4a6
 1142b88:	528006e2 	mov	w2, #0x37                  	// #55
 1142b8c:	97ff3dc8 	bl	11122ac <_assert_log>
 1142b90:	97ff3dd8 	bl	11122f0 <_assert_break>
		if (!retries) {
 1142b94:	910006d6 	add	x22, x22, #0x1
 1142b98:	eb1802df 	cmp	x22, x24
 1142b9c:	54fffd61 	b.ne	1142b48 <malloc_lock.constprop.0+0x48>  // b.any
			trace_printf(func, line, TRACE_ERROR, true,
 1142ba0:	2a1403e5 	mov	w5, w20
 1142ba4:	aa1703e4 	mov	x4, x23
 1142ba8:	52800023 	mov	w3, #0x1                   	// #1
 1142bac:	52800022 	mov	w2, #0x1                   	// #1
 1142bb0:	528014a1 	mov	w1, #0xa5                  	// #165
 1142bb4:	f00000a0 	adrp	x0, 1159000 <Worder+0x2854>
 1142bb8:	91333c00 	add	x0, x0, #0xccf
 1142bbc:	94000862 	bl	1144d44 <trace_printf>
			if (reminder < UINT_MAX)
 1142bc0:	3100069f 	cmn	w20, #0x1
 1142bc4:	54fffc00 	b.eq	1142b44 <malloc_lock.constprop.0+0x44>  // b.none
				reminder++;
 1142bc8:	11000694 	add	w20, w20, #0x1
 1142bcc:	17ffffde 	b	1142b44 <malloc_lock.constprop.0+0x44>

0000000001142bd0 <cpu_spin_unlock_xrestore>:
{
 1142bd0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1142bd4:	910003fd 	mov	x29, sp
 1142bd8:	a90153f3 	stp	x19, x20, [sp, #16]
 1142bdc:	aa0003f4 	mov	x20, x0
 1142be0:	2a0103f3 	mov	w19, w1
 1142be4:	97ff08cc 	bl	1104f14 <thread_get_exceptions>
	assert(thread_foreign_intr_disabled());
 1142be8:	37080140 	tbnz	w0, #1, 1142c10 <cpu_spin_unlock_xrestore+0x40>
 1142bec:	f00000a3 	adrp	x3, 1159000 <Worder+0x2854>
 1142bf0:	f0000061 	adrp	x1, 1151000 <small_prime+0x168>
 1142bf4:	91328c63 	add	x3, x3, #0xca3
 1142bf8:	9111f821 	add	x1, x1, #0x47e
 1142bfc:	f0000060 	adrp	x0, 1151000 <small_prime+0x168>
 1142c00:	91129800 	add	x0, x0, #0x4a6
 1142c04:	52800b82 	mov	w2, #0x5c                  	// #92
 1142c08:	97ff3da9 	bl	11122ac <_assert_log>
 1142c0c:	97ff3db9 	bl	11122f0 <_assert_break>
	__cpu_spin_unlock(lock);
 1142c10:	aa1403e0 	mov	x0, x20
 1142c14:	97ff062b 	bl	11044c0 <__cpu_spin_unlock>
	spinlock_count_decr();
 1142c18:	97ff063e 	bl	1104510 <spinlock_count_decr>
	thread_unmask_exceptions(exceptions);
 1142c1c:	2a1303e0 	mov	w0, w19
}
 1142c20:	a94153f3 	ldp	x19, x20, [sp, #16]
 1142c24:	a8c27bfd 	ldp	x29, x30, [sp], #32
	thread_unmask_exceptions(exceptions);
 1142c28:	17ff0951 	b	110516c <thread_unmask_exceptions>

0000000001142c2c <bget>:
void *bget(requested_align, hdr_size, requested_size, poolset)
  bufsize requested_align;
  bufsize hdr_size;
  bufsize requested_size;
  struct bpoolset *poolset;
{
 1142c2c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    void *buf;
#ifdef BECtl
    int compactseq = 0;
#endif

    assert(size > 0);
 1142c30:	f100005f 	cmp	x2, #0x0
{
 1142c34:	910003fd 	mov	x29, sp
    assert(size > 0);
 1142c38:	5400014c 	b.gt	1142c60 <bget+0x34>
 1142c3c:	f00000a3 	adrp	x3, 1159000 <Worder+0x2854>
 1142c40:	f00000a1 	adrp	x1, 1159000 <Worder+0x2854>
 1142c44:	f00000a0 	adrp	x0, 1159000 <Worder+0x2854>
 1142c48:	9132cc63 	add	x3, x3, #0xcb3
 1142c4c:	91270421 	add	x1, x1, #0x9c1
 1142c50:	91302800 	add	x0, x0, #0xc0a
 1142c54:	52804e22 	mov	w2, #0x271                 	// #625
            pos = buf_get_pos(b, align, hdr_size, size);
            if (pos >= 0) {
                struct bhead *b_alloc = BH((char *)b + pos);
                struct bhead *b_next = BH((char *)b + b->bh.bsize);

                assert(b_next->prevfree == b->bh.bsize);
 1142c58:	97ff3d95 	bl	11122ac <_assert_log>
 1142c5c:	97ff3da5 	bl	11122f0 <_assert_break>
    if (align < 0 || (align > 0 && !IS_POWER_OF_TWO((unsigned long)align)))
 1142c60:	f100001f 	cmp	x0, #0x0
 1142c64:	5400022b 	b.lt	1142ca8 <bget+0x7c>  // b.tstop
 1142c68:	54000080 	b.eq	1142c78 <bget+0x4c>  // b.none
 1142c6c:	cb0003e4 	neg	x4, x0
 1142c70:	ea24001f 	bics	xzr, x0, x4
 1142c74:	540001a1 	b.ne	1142ca8 <bget+0x7c>  // b.any
    if (hdr_size % BGET_HDR_QUANTUM != 0)
 1142c78:	f2400c3f 	tst	x1, #0xf
 1142c7c:	54000161 	b.ne	1142ca8 <bget+0x7c>  // b.any
    if (ADD_OVERFLOW(size, SizeQuant - 1, &size))
 1142c80:	d2800205 	mov	x5, #0x10                  	// #16
 1142c84:	eb05005f 	cmp	x2, x5
 1142c88:	9a85a042 	csel	x2, x2, x5, ge  // ge = tcont
 1142c8c:	b1003c44 	adds	x4, x2, #0xf
 1142c90:	540000c4 	b.mi	1142ca8 <bget+0x7c>  // b.first
 1142c94:	eb02009f 	cmp	x4, x2
 1142c98:	54000083 	b.cc	1142ca8 <bget+0x7c>  // b.lo, b.ul, b.last
    size = ROUNDDOWN(size, SizeQuant);
 1142c9c:	927cec84 	and	x4, x4, #0xfffffffffffffff0
    if (ADD_OVERFLOW(size, sizeof(struct bhead), &size))
 1142ca0:	b1004084 	adds	x4, x4, #0x10
 1142ca4:	54000067 	b.vc	1142cb0 <bget+0x84>
        return NULL;
 1142ca8:	d2800000 	mov	x0, #0x0                   	// #0
 1142cac:	1400008d 	b	1142ee0 <bget+0x2b4>
    if (ADD_OVERFLOW(size, hdr_size, &size))
 1142cb0:	ab010084 	adds	x4, x4, x1
 1142cb4:	54ffffa6 	b.vs	1142ca8 <bget+0x7c>
 1142cb8:	f100401f 	cmp	x0, #0x10
 1142cbc:	91004027 	add	x7, x1, #0x10
 1142cc0:	9a85a000 	csel	x0, x0, x5, ge  // ge = tcont
    buf = (unsigned long)bf + bf->bh.bsize - size + sizeof(struct bhead) +
 1142cc4:	cb0400e7 	sub	x7, x7, x4
	b = poolset->freelist.ql.flink;
 1142cc8:	f9400862 	ldr	x2, [x3, #16]
    buf &= ~(align - 1);
 1142ccc:	cb0003e0 	neg	x0, x0
    if (pos >= SizeQ + sizeof(struct bhead)) /* room for an empty buffer */
 1142cd0:	b27be7ea 	mov	x10, #0x7fffffffffffffe0    	// #9223372036854775776
	while (b != &poolset->freelist) {
 1142cd4:	eb03005f 	cmp	x2, x3
 1142cd8:	54fffe80 	b.eq	1142ca8 <bget+0x7c>  // b.none
    if (bf->bh.bsize < size)
 1142cdc:	f9400445 	ldr	x5, [x2, #8]
 1142ce0:	eb05009f 	cmp	x4, x5
 1142ce4:	5400102c 	b.gt	1142ee8 <bget+0x2bc>
    buf = (unsigned long)bf + bf->bh.bsize - size + sizeof(struct bhead) +
 1142ce8:	8b0200a9 	add	x9, x5, x2
    pos = buf - (unsigned long)bf - sizeof(struct bhead) - hdr_size;
 1142cec:	8b010048 	add	x8, x2, x1
    buf = (unsigned long)bf + bf->bh.bsize - size + sizeof(struct bhead) +
 1142cf0:	8b070126 	add	x6, x9, x7
    buf &= ~(align - 1);
 1142cf4:	8a060006 	and	x6, x0, x6
    pos = buf - (unsigned long)bf - sizeof(struct bhead) - hdr_size;
 1142cf8:	cb0800c6 	sub	x6, x6, x8
    if (pos == 0) /* exact match */
 1142cfc:	f10040c8 	subs	x8, x6, #0x10
 1142d00:	54000080 	b.eq	1142d10 <bget+0xe4>  // b.none
    if (pos >= SizeQ + sizeof(struct bhead)) /* room for an empty buffer */
 1142d04:	d100c0c6 	sub	x6, x6, #0x30
 1142d08:	eb0a00df 	cmp	x6, x10
 1142d0c:	54000ee2 	b.cs	1142ee8 <bget+0x2bc>  // b.hs, b.nlast
                assert(b_next->prevfree == b->bh.bsize);
 1142d10:	f8656841 	ldr	x1, [x2, x5]
                struct bhead *b_alloc = BH((char *)b + pos);
 1142d14:	8b080040 	add	x0, x2, x8
                assert(b_next->prevfree == b->bh.bsize);
 1142d18:	eb05003f 	cmp	x1, x5
 1142d1c:	54000120 	b.eq	1142d40 <bget+0x114>  // b.none
 1142d20:	f00000a3 	adrp	x3, 1159000 <Worder+0x2854>
 1142d24:	f00000a1 	adrp	x1, 1159000 <Worder+0x2854>
 1142d28:	f00000a0 	adrp	x0, 1159000 <Worder+0x2854>
 1142d2c:	9132cc63 	add	x3, x3, #0xcb3
 1142d30:	91270421 	add	x1, x1, #0x9c1
 1142d34:	91276800 	add	x0, x0, #0x9da
 1142d38:	52805642 	mov	w2, #0x2b2                 	// #690
 1142d3c:	17ffffc7 	b	1142c58 <bget+0x2c>
                 * Zero the back pointer in the next buffer in memory
                 * to indicate that this buffer is allocated.
                 */
                b_next->prevfree = 0;

                assert(b->ql.blink->ql.flink == b);
 1142d40:	f9400c41 	ldr	x1, [x2, #24]
                b_next->prevfree = 0;
 1142d44:	f825685f 	str	xzr, [x2, x5]
                assert(b->ql.blink->ql.flink == b);
 1142d48:	f9400826 	ldr	x6, [x1, #16]
 1142d4c:	eb06005f 	cmp	x2, x6
 1142d50:	54000120 	b.eq	1142d74 <bget+0x148>  // b.none
 1142d54:	f00000a3 	adrp	x3, 1159000 <Worder+0x2854>
 1142d58:	f00000a1 	adrp	x1, 1159000 <Worder+0x2854>
 1142d5c:	f00000a0 	adrp	x0, 1159000 <Worder+0x2854>
 1142d60:	9132cc63 	add	x3, x3, #0xcb3
 1142d64:	91270421 	add	x1, x1, #0x9c1
 1142d68:	9127e800 	add	x0, x0, #0x9fa
 1142d6c:	52805742 	mov	w2, #0x2ba                 	// #698
 1142d70:	17ffffba 	b	1142c58 <bget+0x2c>
                assert(b->ql.flink->ql.blink == b);
 1142d74:	f9400846 	ldr	x6, [x2, #16]
 1142d78:	f9400cc7 	ldr	x7, [x6, #24]
 1142d7c:	eb07005f 	cmp	x2, x7
 1142d80:	54000120 	b.eq	1142da4 <bget+0x178>  // b.none
 1142d84:	f00000a3 	adrp	x3, 1159000 <Worder+0x2854>
 1142d88:	f00000a1 	adrp	x1, 1159000 <Worder+0x2854>
 1142d8c:	f00000a0 	adrp	x0, 1159000 <Worder+0x2854>
 1142d90:	9132cc63 	add	x3, x3, #0xcb3
 1142d94:	91270421 	add	x1, x1, #0x9c1
 1142d98:	91285400 	add	x0, x0, #0xa15
 1142d9c:	52805762 	mov	w2, #0x2bb                 	// #699
 1142da0:	17ffffae 	b	1142c58 <bget+0x2c>

                if (pos == 0) {
 1142da4:	b5000208 	cbnz	x8, 1142de4 <bget+0x1b8>
                    /*
                     * Need to allocate from the beginning of this free block.
                     * Unlink the block and mark it as allocated.
                     */
		    b->ql.blink->ql.flink = b->ql.flink;
 1142da8:	f9000826 	str	x6, [x1, #16]
		    b->ql.flink->ql.blink = b->ql.blink;

		    /* Negate size to mark buffer allocated. */
		    b->bh.bsize = -b->bh.bsize;
 1142dac:	cb0503e5 	neg	x5, x5
		    b->ql.flink->ql.blink = b->ql.blink;
 1142db0:	f9400846 	ldr	x6, [x2, #16]
 1142db4:	f9000cc1 	str	x1, [x6, #24]
		    b->bh.bsize = -b->bh.bsize;
 1142db8:	f9000445 	str	x5, [x2, #8]
                    b_alloc->bsize = -(b->bh.bsize - pos);
                    b_alloc->prevfree = pos;
                    b->bh.bsize = pos;
                }

                assert(b_alloc->bsize < 0);
 1142dbc:	f9400402 	ldr	x2, [x0, #8]
 1142dc0:	b7f801a2 	tbnz	x2, #63, 1142df4 <bget+0x1c8>
 1142dc4:	f00000a3 	adrp	x3, 1159000 <Worder+0x2854>
 1142dc8:	f00000a1 	adrp	x1, 1159000 <Worder+0x2854>
 1142dcc:	f00000a0 	adrp	x0, 1159000 <Worder+0x2854>
 1142dd0:	9132cc63 	add	x3, x3, #0xcb3
 1142dd4:	91270421 	add	x1, x1, #0x9c1
 1142dd8:	9128c000 	add	x0, x0, #0xa30
 1142ddc:	52805a22 	mov	w2, #0x2d1                 	// #721
 1142de0:	17ffff9e 	b	1142c58 <bget+0x2c>
                    b_alloc->bsize = -(b->bh.bsize - pos);
 1142de4:	cb050105 	sub	x5, x8, x5
 1142de8:	a9001408 	stp	x8, x5, [x0]
                    b->bh.bsize = pos;
 1142dec:	f9000448 	str	x8, [x2, #8]
 1142df0:	17fffff3 	b	1142dbc <bget+0x190>
                /*
                 * At this point is b_alloc pointing to the allocated
                 * buffer and b_next at the buffer following. b might be a
                 * free block or a used block now.
                 */
                if (-b_alloc->bsize - size > SizeQ + sizeof(struct bhead)) {
 1142df4:	cb0203e2 	neg	x2, x2
 1142df8:	cb040042 	sub	x2, x2, x4
 1142dfc:	f100805f 	cmp	x2, #0x20
 1142e00:	54000609 	b.ls	1142ec0 <bget+0x294>  // b.plast
                    /*
                     * b_alloc has too much unused memory at the
                     * end we need to split the block and register that
                     * last part as free.
                     */
                    b = BFH((char *)b_alloc + size);
 1142e04:	8b040001 	add	x1, x0, x4
                    b->bh.bsize = -b_alloc->bsize - size;
 1142e08:	f9000422 	str	x2, [x1, #8]
                    b->bh.prevfree = 0;
 1142e0c:	f824681f 	str	xzr, [x0, x4]
                    b_alloc->bsize += b->bh.bsize;
 1142e10:	f9400404 	ldr	x4, [x0, #8]
 1142e14:	8b020082 	add	x2, x4, x2
 1142e18:	f9000402 	str	x2, [x0, #8]

                    assert(poolset->freelist.ql.blink->ql.flink ==
 1142e1c:	f9400c62 	ldr	x2, [x3, #24]
 1142e20:	f9400844 	ldr	x4, [x2, #16]
 1142e24:	eb03009f 	cmp	x4, x3
 1142e28:	54000120 	b.eq	1142e4c <bget+0x220>  // b.none
 1142e2c:	f00000a3 	adrp	x3, 1159000 <Worder+0x2854>
 1142e30:	f00000a1 	adrp	x1, 1159000 <Worder+0x2854>
 1142e34:	f00000a0 	adrp	x0, 1159000 <Worder+0x2854>
 1142e38:	9132cc63 	add	x3, x3, #0xcb3
 1142e3c:	91270421 	add	x1, x1, #0x9c1
 1142e40:	91290c00 	add	x0, x0, #0xa43
 1142e44:	52805c42 	mov	w2, #0x2e2                 	// #738
 1142e48:	17ffff84 	b	1142c58 <bget+0x2c>
			   &poolset->freelist);
                    assert(poolset->freelist.ql.flink->ql.blink ==
 1142e4c:	f9400864 	ldr	x4, [x3, #16]
 1142e50:	f9400c84 	ldr	x4, [x4, #24]
 1142e54:	eb03009f 	cmp	x4, x3
 1142e58:	54000120 	b.eq	1142e7c <bget+0x250>  // b.none
 1142e5c:	f00000a3 	adrp	x3, 1159000 <Worder+0x2854>
 1142e60:	f00000a1 	adrp	x1, 1159000 <Worder+0x2854>
 1142e64:	f00000a0 	adrp	x0, 1159000 <Worder+0x2854>
 1142e68:	9132cc63 	add	x3, x3, #0xcb3
 1142e6c:	91270421 	add	x1, x1, #0x9c1
 1142e70:	9129f800 	add	x0, x0, #0xa7e
 1142e74:	52805c82 	mov	w2, #0x2e4                 	// #740
 1142e78:	17ffff78 	b	1142c58 <bget+0x2c>
			   &poolset->freelist);
                    b->ql.flink = &poolset->freelist;
                    b->ql.blink = poolset->freelist.ql.blink;
 1142e7c:	a9010823 	stp	x3, x2, [x1, #16]
                    poolset->freelist.ql.blink = b;
 1142e80:	f9000c61 	str	x1, [x3, #24]
                    b->ql.blink->ql.flink = b;
 1142e84:	f9400c22 	ldr	x2, [x1, #24]
 1142e88:	f9000841 	str	x1, [x2, #16]

                    assert(BH((char *)b + b->bh.bsize) == b_next);
 1142e8c:	f9400422 	ldr	x2, [x1, #8]
 1142e90:	8b020021 	add	x1, x1, x2
 1142e94:	eb01013f 	cmp	x9, x1
 1142e98:	54000120 	b.eq	1142ebc <bget+0x290>  // b.none
 1142e9c:	f00000a3 	adrp	x3, 1159000 <Worder+0x2854>
 1142ea0:	f00000a1 	adrp	x1, 1159000 <Worder+0x2854>
 1142ea4:	f00000a0 	adrp	x0, 1159000 <Worder+0x2854>
 1142ea8:	9132cc63 	add	x3, x3, #0xcb3
 1142eac:	91270421 	add	x1, x1, #0x9c1
 1142eb0:	912ae400 	add	x0, x0, #0xab9
 1142eb4:	52805d62 	mov	w2, #0x2eb                 	// #747
 1142eb8:	17ffff68 	b	1142c58 <bget+0x2c>
                    b_next->prevfree = b->bh.bsize;
 1142ebc:	f9000122 	str	x2, [x9]
                }

#ifdef BufStats
		poolset->totalloc -= b_alloc->bsize;
 1142ec0:	f9400402 	ldr	x2, [x0, #8]
		poolset->numget++;		  /* Increment number of bget() calls */
#endif
                buf = (char *)b_alloc + sizeof(struct bhead);
 1142ec4:	91004000 	add	x0, x0, #0x10
		poolset->totalloc -= b_alloc->bsize;
 1142ec8:	f9401061 	ldr	x1, [x3, #32]
 1142ecc:	cb020021 	sub	x1, x1, x2
 1142ed0:	f9001061 	str	x1, [x3, #32]
		poolset->numget++;		  /* Increment number of bget() calls */
 1142ed4:	f9401461 	ldr	x1, [x3, #40]
 1142ed8:	91000421 	add	x1, x1, #0x1
 1142edc:	f9001461 	str	x1, [x3, #40]
    /*	Still no buffer available */

#endif /* BECtl */

    return NULL;
}
 1142ee0:	a8c17bfd 	ldp	x29, x30, [sp], #16
 1142ee4:	d65f03c0 	ret
	    b = b->ql.flink;		  /* Link to next buffer */
 1142ee8:	f9400842 	ldr	x2, [x2, #16]
 1142eec:	17ffff7a 	b	1142cd4 <bget+0xa8>

0000000001142ef0 <bgetz>:
void *bgetz(align, hdr_size, size, poolset)
  bufsize align;
  bufsize hdr_size;
  bufsize size;
  struct bpoolset *poolset;
{
 1142ef0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1142ef4:	910003fd 	mov	x29, sp
 1142ef8:	f9000bf3 	str	x19, [sp, #16]
 1142efc:	aa0203f3 	mov	x19, x2
    char *buf = (char *) bget(align, hdr_size, size, poolset);
 1142f00:	97ffff4b 	bl	1142c2c <bget>
 1142f04:	aa0003e3 	mov	x3, x0

    if (buf != NULL) {
 1142f08:	b4000300 	cbz	x0, 1142f68 <bgetz+0x78>
	struct bhead *b;
	bufsize rsize;

	b = BH(buf - sizeof(struct bhead));
	rsize = -(b->bsize);
 1142f0c:	f85f8002 	ldur	x2, [x0, #-8]
	if (rsize == 0) {
 1142f10:	b50001e2 	cbnz	x2, 1142f4c <bgetz+0x5c>
	    struct bdhead *bd;

	    bd = BDH(buf - sizeof(struct bdhead));
	    rsize = bd->tsize - sizeof(struct bdhead) - bd->offs;
 1142f14:	a97e0801 	ldp	x1, x2, [x0, #-32]
 1142f18:	d1008021 	sub	x1, x1, #0x20
	} else {
	    rsize -= sizeof(struct bhead);
 1142f1c:	cb020022 	sub	x2, x1, x2
	}
	assert(rsize >= size);
 1142f20:	eb13005f 	cmp	x2, x19
 1142f24:	5400018a 	b.ge	1142f54 <bgetz+0x64>  // b.tcont
 1142f28:	f00000a3 	adrp	x3, 1159000 <Worder+0x2854>
 1142f2c:	f00000a1 	adrp	x1, 1159000 <Worder+0x2854>
 1142f30:	9132e063 	add	x3, x3, #0xcb8
 1142f34:	91270421 	add	x1, x1, #0x9c1
 1142f38:	f00000a0 	adrp	x0, 1159000 <Worder+0x2854>
 1142f3c:	912b7c00 	add	x0, x0, #0xadf
 1142f40:	52806c62 	mov	w2, #0x363                 	// #867
 1142f44:	97ff3cda 	bl	11122ac <_assert_log>
 1142f48:	97ff3cea 	bl	11122f0 <_assert_break>
	    rsize -= sizeof(struct bhead);
 1142f4c:	928001e1 	mov	x1, #0xfffffffffffffff0    	// #-16
 1142f50:	17fffff3 	b	1142f1c <bgetz+0x2c>
{
}

static inline void *asan_memset_unchecked(void *s, int c, size_t n)
{
	return memset(s, c, n);
 1142f54:	aa0303e0 	mov	x0, x3
 1142f58:	93407c42 	sxtw	x2, w2
 1142f5c:	52800001 	mov	w1, #0x0                   	// #0
 1142f60:	94000360 	bl	1143ce0 <memset>
 1142f64:	aa0003e3 	mov	x3, x0
	V memset_unchecked(buf, 0, (MemSize) rsize);
    }
    return ((void *) buf);
}
 1142f68:	aa0303e0 	mov	x0, x3
 1142f6c:	f9400bf3 	ldr	x19, [sp, #16]
 1142f70:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1142f74:	d65f03c0 	ret

0000000001142f78 <brel>:

void brel(buf, poolset, wipe)
  void *buf;
  struct bpoolset *poolset;
  int wipe;
{
 1142f78:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1142f7c:	910003fd 	mov	x29, sp
    struct bfhead *b, *bn;
    bufsize bs;

    b = BFH(((char *) buf) - sizeof(struct bhead));
#ifdef BufStats
    poolset->numrel++;		      /* Increment number of brel() calls */
 1142f80:	f9401823 	ldr	x3, [x1, #48]
{
 1142f84:	a90153f3 	stp	x19, x20, [sp, #16]
    poolset->numrel++;		      /* Increment number of brel() calls */
 1142f88:	91000463 	add	x3, x3, #0x1
 1142f8c:	f9001823 	str	x3, [x1, #48]
#endif
    assert(buf != NULL);
 1142f90:	b5000140 	cbnz	x0, 1142fb8 <brel+0x40>
 1142f94:	f00000a3 	adrp	x3, 1159000 <Worder+0x2854>
 1142f98:	f00000a1 	adrp	x1, 1159000 <Worder+0x2854>
 1142f9c:	f00000a0 	adrp	x0, 1159000 <Worder+0x2854>
 1142fa0:	91331063 	add	x3, x3, #0xcc4
 1142fa4:	91270421 	add	x1, x1, #0x9c1
 1142fa8:	912bb400 	add	x0, x0, #0xaed
 1142fac:	528074a2 	mov	w2, #0x3a5                 	// #933
       allocated. */

    if (b->bh.bsize >= 0) {
	bn = NULL;
    }
    assert(b->bh.bsize < 0);
 1142fb0:	97ff3cbf 	bl	11122ac <_assert_log>
 1142fb4:	97ff3ccf 	bl	11122f0 <_assert_break>
    if (b->bh.bsize >= 0) {
 1142fb8:	f85f8003 	ldur	x3, [x0, #-8]
    assert(b->bh.bsize < 0);
 1142fbc:	b7f80123 	tbnz	x3, #63, 1142fe0 <brel+0x68>
 1142fc0:	f00000a3 	adrp	x3, 1159000 <Worder+0x2854>
 1142fc4:	f00000a1 	adrp	x1, 1159000 <Worder+0x2854>
 1142fc8:	f00000a0 	adrp	x0, 1159000 <Worder+0x2854>
 1142fcc:	91331063 	add	x3, x3, #0xcc4
 1142fd0:	91270421 	add	x1, x1, #0x9c1
 1142fd4:	912be400 	add	x0, x0, #0xaf9
 1142fd8:	52807902 	mov	w2, #0x3c8                 	// #968
 1142fdc:	17fffff5 	b	1142fb0 <brel+0x38>
 1142fe0:	d1004013 	sub	x19, x0, #0x10
    bs = -b->bh.bsize;

    /*	Back pointer in next buffer must be zero, indicating the
	same thing: */

    assert(BH((char *) b - b->bh.bsize)->prevfree == 0);
 1142fe4:	cb030264 	sub	x4, x19, x3
 1142fe8:	f9400084 	ldr	x4, [x4]
 1142fec:	b4000124 	cbz	x4, 1143010 <brel+0x98>
 1142ff0:	f00000a3 	adrp	x3, 1159000 <Worder+0x2854>
 1142ff4:	f00000a1 	adrp	x1, 1159000 <Worder+0x2854>
 1142ff8:	f00000a0 	adrp	x0, 1159000 <Worder+0x2854>
 1142ffc:	91331063 	add	x3, x3, #0xcc4
 1143000:	91270421 	add	x1, x1, #0x9c1
 1143004:	912c2400 	add	x0, x0, #0xb09
 1143008:	528079c2 	mov	w2, #0x3ce                 	// #974
 114300c:	17ffffe9 	b	1142fb0 <brel+0x38>

#ifdef BufStats
    poolset->totalloc += b->bh.bsize;
 1143010:	f9401024 	ldr	x4, [x1, #32]
 1143014:	8b040064 	add	x4, x3, x4
 1143018:	f9001024 	str	x4, [x1, #32]
    assert(poolset->totalloc >= 0);
 114301c:	b6f80124 	tbz	x4, #63, 1143040 <brel+0xc8>
 1143020:	d00000a3 	adrp	x3, 1159000 <Worder+0x2854>
 1143024:	d00000a1 	adrp	x1, 1159000 <Worder+0x2854>
 1143028:	d00000a0 	adrp	x0, 1159000 <Worder+0x2854>
 114302c:	91331063 	add	x3, x3, #0xcc4
 1143030:	91270421 	add	x1, x1, #0x9c1
 1143034:	912cd400 	add	x0, x0, #0xb35
 1143038:	52807a42 	mov	w2, #0x3d2                 	// #978
 114303c:	17ffffdd 	b	1142fb0 <brel+0x38>
#endif

    /* If the back link is nonzero, the previous buffer is free.  */

    if (b->bh.prevfree != 0) {
 1143040:	f85f0004 	ldur	x4, [x0, #-16]
 1143044:	b40003e4 	cbz	x4, 11430c0 <brel+0x148>
	   allocated. */

	register bufsize size = b->bh.bsize;

        /* Make the previous buffer the one we're working on. */
	assert(BH((char *) b - b->bh.prevfree)->bsize == b->bh.prevfree);
 1143048:	cb040273 	sub	x19, x19, x4
 114304c:	f9400660 	ldr	x0, [x19, #8]
 1143050:	eb00009f 	cmp	x4, x0
 1143054:	54000120 	b.eq	1143078 <brel+0x100>  // b.none
 1143058:	d00000a3 	adrp	x3, 1159000 <Worder+0x2854>
 114305c:	d00000a1 	adrp	x1, 1159000 <Worder+0x2854>
 1143060:	d00000a0 	adrp	x0, 1159000 <Worder+0x2854>
 1143064:	91331063 	add	x3, x3, #0xcc4
 1143068:	91270421 	add	x1, x1, #0x9c1
 114306c:	912d3000 	add	x0, x0, #0xb4c
 1143070:	52807c42 	mov	w2, #0x3e2                 	// #994
 1143074:	17ffffcf 	b	1142fb0 <brel+0x38>
	b = BFH(((char *) b) - b->bh.prevfree);
	b->bh.bsize -= size;
 1143078:	cb030083 	sub	x3, x4, x3
 114307c:	f9000663 	str	x3, [x19, #8]
    /* Now we look at the next buffer in memory, located by advancing from
       the  start  of  this  buffer  by its size, to see if that buffer is
       free.  If it is, we combine  this  buffer  with	the  next  one	in
       memory, dechaining the second buffer from the free list. */

    bn =  BFH(((char *) b) + b->bh.bsize);
 1143080:	f9400660 	ldr	x0, [x19, #8]
 1143084:	8b000274 	add	x20, x19, x0
    if (bn->bh.bsize > 0) {
 1143088:	f9400681 	ldr	x1, [x20, #8]
 114308c:	f100003f 	cmp	x1, #0x0
 1143090:	5400090d 	b.le	11431b0 <brel+0x238>

	/* The buffer is free.	Remove it from the free list and add
	   its size to that of our buffer. */

	assert(BH((char *) bn + bn->bh.bsize)->prevfree == bn->bh.bsize);
 1143094:	f8616a83 	ldr	x3, [x20, x1]
 1143098:	eb03003f 	cmp	x1, x3
 114309c:	54000500 	b.eq	114313c <brel+0x1c4>  // b.none
 11430a0:	d00000a3 	adrp	x3, 1159000 <Worder+0x2854>
 11430a4:	d00000a1 	adrp	x1, 1159000 <Worder+0x2854>
 11430a8:	d00000a0 	adrp	x0, 1159000 <Worder+0x2854>
 11430ac:	91331063 	add	x3, x3, #0xcc4
 11430b0:	91270421 	add	x1, x1, #0x9c1
 11430b4:	912e1400 	add	x0, x0, #0xb85
 11430b8:	52807fc2 	mov	w2, #0x3fe                 	// #1022
 11430bc:	17ffffbd 	b	1142fb0 <brel+0x38>
	assert(poolset->freelist.ql.blink->ql.flink == &poolset->freelist);
 11430c0:	f9400c25 	ldr	x5, [x1, #24]
 11430c4:	f94008a4 	ldr	x4, [x5, #16]
 11430c8:	eb01009f 	cmp	x4, x1
 11430cc:	54000120 	b.eq	11430f0 <brel+0x178>  // b.none
 11430d0:	d00000a3 	adrp	x3, 1159000 <Worder+0x2854>
 11430d4:	d00000a1 	adrp	x1, 1159000 <Worder+0x2854>
 11430d8:	d00000a0 	adrp	x0, 1159000 <Worder+0x2854>
 11430dc:	91331063 	add	x3, x3, #0xcc4
 11430e0:	91270421 	add	x1, x1, #0x9c1
 11430e4:	91290c00 	add	x0, x0, #0xa43
 11430e8:	52807d42 	mov	w2, #0x3ea                 	// #1002
 11430ec:	17ffffb1 	b	1142fb0 <brel+0x38>
	assert(poolset->freelist.ql.flink->ql.blink == &poolset->freelist);
 11430f0:	f9400881 	ldr	x1, [x4, #16]
 11430f4:	f9400c21 	ldr	x1, [x1, #24]
 11430f8:	eb01009f 	cmp	x4, x1
 11430fc:	54000120 	b.eq	1143120 <brel+0x1a8>  // b.none
 1143100:	d00000a3 	adrp	x3, 1159000 <Worder+0x2854>
 1143104:	d00000a1 	adrp	x1, 1159000 <Worder+0x2854>
 1143108:	d00000a0 	adrp	x0, 1159000 <Worder+0x2854>
 114310c:	91331063 	add	x3, x3, #0xcc4
 1143110:	91270421 	add	x1, x1, #0x9c1
 1143114:	9129f800 	add	x0, x0, #0xa7e
 1143118:	52807d62 	mov	w2, #0x3eb                 	// #1003
 114311c:	17ffffa5 	b	1142fb0 <brel+0x38>
	b->ql.blink = poolset->freelist.ql.blink;
 1143120:	a9011664 	stp	x4, x5, [x19, #16]
    bs = -b->bh.bsize;
 1143124:	cb0303e3 	neg	x3, x3
	poolset->freelist.ql.blink = b;
 1143128:	f9000c93 	str	x19, [x4, #24]
	b->ql.blink->ql.flink = b;
 114312c:	f9400e61 	ldr	x1, [x19, #24]
 1143130:	f9000833 	str	x19, [x1, #16]
	b->bh.bsize = -b->bh.bsize;
 1143134:	f81f8003 	stur	x3, [x0, #-8]
 1143138:	17ffffd2 	b	1143080 <brel+0x108>
	assert(bn->ql.blink->ql.flink == bn);
 114313c:	f9400e84 	ldr	x4, [x20, #24]
 1143140:	f9400885 	ldr	x5, [x4, #16]
 1143144:	eb1400bf 	cmp	x5, x20
 1143148:	54000120 	b.eq	114316c <brel+0x1f4>  // b.none
 114314c:	d00000a3 	adrp	x3, 1159000 <Worder+0x2854>
 1143150:	d00000a1 	adrp	x1, 1159000 <Worder+0x2854>
 1143154:	d00000a0 	adrp	x0, 1159000 <Worder+0x2854>
 1143158:	91331063 	add	x3, x3, #0xcc4
 114315c:	91270421 	add	x1, x1, #0x9c1
 1143160:	912ef800 	add	x0, x0, #0xbbe
 1143164:	52807fe2 	mov	w2, #0x3ff                 	// #1023
 1143168:	17ffff92 	b	1142fb0 <brel+0x38>
	assert(bn->ql.flink->ql.blink == bn);
 114316c:	f94008a3 	ldr	x3, [x5, #16]
 1143170:	f9400c66 	ldr	x6, [x3, #24]
 1143174:	eb0500df 	cmp	x6, x5
 1143178:	54000120 	b.eq	114319c <brel+0x224>  // b.none
 114317c:	d00000a3 	adrp	x3, 1159000 <Worder+0x2854>
 1143180:	d00000a1 	adrp	x1, 1159000 <Worder+0x2854>
 1143184:	d00000a0 	adrp	x0, 1159000 <Worder+0x2854>
 1143188:	91331063 	add	x3, x3, #0xcc4
 114318c:	91270421 	add	x1, x1, #0x9c1
 1143190:	912f6c00 	add	x0, x0, #0xbdb
 1143194:	52808002 	mov	w2, #0x400                 	// #1024
 1143198:	17ffff86 	b	1142fb0 <brel+0x38>
	bn->ql.blink->ql.flink = bn->ql.flink;
 114319c:	f9000883 	str	x3, [x4, #16]
	bn->ql.flink->ql.blink = bn->ql.blink;
	b->bh.bsize += bn->bh.bsize;
 11431a0:	8b010014 	add	x20, x0, x1
	bn->ql.flink->ql.blink = bn->ql.blink;
 11431a4:	f9000c64 	str	x4, [x3, #24]
	b->bh.bsize += bn->bh.bsize;
 11431a8:	f9000674 	str	x20, [x19, #8]
	   head  of  the  consolidated free block.  We know the next block
	   must be an allocated block because the process of recombination
	   guarantees  that  two  free	blocks will never be contiguous in
	   memory.  */

	bn = BFH(((char *) b) + b->bh.bsize);
 11431ac:	8b140274 	add	x20, x19, x20
    }
    if (wipe) {
 11431b0:	340000e2 	cbz	w2, 11431cc <brel+0x254>
	V memset_unchecked(((char *) b) + sizeof(struct bfhead), 0x55,
			   (MemSize) (b->bh.bsize - sizeof(struct bfhead)));
 11431b4:	f9400662 	ldr	x2, [x19, #8]
 11431b8:	91008260 	add	x0, x19, #0x20
 11431bc:	52800aa1 	mov	w1, #0x55                  	// #85
 11431c0:	51008042 	sub	w2, w2, #0x20
 11431c4:	93407c42 	sxtw	x2, w2
 11431c8:	940002c6 	bl	1143ce0 <memset>
    }
    assert(bn->bh.bsize < 0);
 11431cc:	f9400680 	ldr	x0, [x20, #8]
 11431d0:	b7f80120 	tbnz	x0, #63, 11431f4 <brel+0x27c>
 11431d4:	d00000a3 	adrp	x3, 1159000 <Worder+0x2854>
 11431d8:	d00000a1 	adrp	x1, 1159000 <Worder+0x2854>
 11431dc:	d00000a0 	adrp	x0, 1159000 <Worder+0x2854>
 11431e0:	91331063 	add	x3, x3, #0xcc4
 11431e4:	91270421 	add	x1, x1, #0x9c1
 11431e8:	912fe000 	add	x0, x0, #0xbf8
 11431ec:	52808242 	mov	w2, #0x412                 	// #1042
 11431f0:	17ffff70 	b	1142fb0 <brel+0x38>

    /* The next buffer is allocated.  Set the backpointer in it  to  point
       to this buffer; the previous free buffer in memory. */

    bn->bh.prevfree = b->bh.bsize;
 11431f4:	f9400660 	ldr	x0, [x19, #8]
 11431f8:	f9000280 	str	x0, [x20]
	assert(numpblk == numpget - numprel);
#endif /* BufStats */
    }
#endif /* BECtl */
    tag_asan_free(buf, bs);
}
 11431fc:	a94153f3 	ldp	x19, x20, [sp, #16]
 1143200:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1143204:	d65f03c0 	ret

0000000001143208 <bgetr>:
{
 1143208:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 114320c:	910003fd 	mov	x29, sp
 1143210:	a90153f3 	stp	x19, x20, [sp, #16]
 1143214:	aa0303f4 	mov	x20, x3
 1143218:	aa0003f3 	mov	x19, x0
    if ((nbuf = bget(align, hdr_size, size, poolset)) == NULL) { /* Acquire new buffer */
 114321c:	aa0403e3 	mov	x3, x4
{
 1143220:	aa0103e0 	mov	x0, x1
 1143224:	aa0203e1 	mov	x1, x2
    if ((nbuf = bget(align, hdr_size, size, poolset)) == NULL) { /* Acquire new buffer */
 1143228:	aa1403e2 	mov	x2, x20
{
 114322c:	a9025bf5 	stp	x21, x22, [sp, #32]
 1143230:	aa0403f6 	mov	x22, x4
    if ((nbuf = bget(align, hdr_size, size, poolset)) == NULL) { /* Acquire new buffer */
 1143234:	97fffe7e 	bl	1142c2c <bget>
 1143238:	aa0003f5 	mov	x21, x0
 114323c:	b4000340 	cbz	x0, 11432a4 <bgetr+0x9c>
    if (buf == NULL) {
 1143240:	b4000333 	cbz	x19, 11432a4 <bgetr+0x9c>
	osize -= sizeof(struct bhead);
 1143244:	f85f8262 	ldur	x2, [x19, #-8]
 1143248:	928001e1 	mov	x1, #0xfffffffffffffff0    	// #-16
 114324c:	cb020021 	sub	x1, x1, x2
    assert(osize > 0);
 1143250:	f100003f 	cmp	x1, #0x0
 1143254:	5400014c 	b.gt	114327c <bgetr+0x74>
 1143258:	d00000a3 	adrp	x3, 1159000 <Worder+0x2854>
 114325c:	d00000a1 	adrp	x1, 1159000 <Worder+0x2854>
 1143260:	9132f863 	add	x3, x3, #0xcbe
 1143264:	91270421 	add	x1, x1, #0x9c1
 1143268:	d00000a0 	adrp	x0, 1159000 <Worder+0x2854>
 114326c:	91302400 	add	x0, x0, #0xc09
 1143270:	52807162 	mov	w2, #0x38b                 	// #907
 1143274:	97ff3c0e 	bl	11122ac <_assert_log>
 1143278:	97ff3c1e 	bl	11122f0 <_assert_break>
    V memcpy((char *) nbuf, (char *) buf, /* Copy the data */
 114327c:	93407c23 	sxtw	x3, w1
 1143280:	eb01029f 	cmp	x20, x1
 1143284:	93407e82 	sxtw	x2, w20
 1143288:	aa1303e1 	mov	x1, x19
 114328c:	9a82a062 	csel	x2, x3, x2, ge  // ge = tcont
 1143290:	97ff0040 	bl	1103390 <memcpy>
    brel(buf, poolset, false /* !wipe */);
 1143294:	aa1603e1 	mov	x1, x22
 1143298:	aa1303e0 	mov	x0, x19
 114329c:	52800002 	mov	w2, #0x0                   	// #0
 11432a0:	97ffff36 	bl	1142f78 <brel>
}
 11432a4:	aa1503e0 	mov	x0, x21
 11432a8:	a94153f3 	ldp	x19, x20, [sp, #16]
 11432ac:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11432b0:	a8c37bfd 	ldp	x29, x30, [sp], #48
 11432b4:	d65f03c0 	ret

00000000011432b8 <free_helper>:
	malloc_unlock(&malloc_ctx, exceptions);
	return p;
}

static void free_helper(void *ptr, bool wipe)
{
 11432b8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 11432bc:	910003fd 	mov	x29, sp
 11432c0:	a90153f3 	stp	x19, x20, [sp, #16]
 11432c4:	aa0003f4 	mov	x20, x0
 11432c8:	d00000d3 	adrp	x19, 115d000 <_curve_names+0x590>
 11432cc:	a9025bf5 	stp	x21, x22, [sp, #32]
 11432d0:	12001c36 	and	w22, w1, #0xff
	uint32_t exceptions = malloc_lock(&malloc_ctx);
 11432d4:	97fffe0b 	bl	1142b00 <malloc_lock.constprop.0>
 11432d8:	2a0003f5 	mov	w21, w0
	if (ptr)
 11432dc:	b40000b4 	cbz	x20, 11432f0 <free_helper+0x38>
		brel(ptr, &ctx->poolset, wipe);
 11432e0:	2a1603e2 	mov	w2, w22
 11432e4:	912d6261 	add	x1, x19, #0xb58
 11432e8:	aa1403e0 	mov	x0, x20
 11432ec:	97ffff23 	bl	1142f78 <brel>
	cpu_spin_unlock_xrestore(&ctx->spinlock, exceptions);
 11432f0:	912d6273 	add	x19, x19, #0xb58
 11432f4:	2a1503e1 	mov	w1, w21
 11432f8:	91020260 	add	x0, x19, #0x80

	raw_free(ptr, &malloc_ctx, wipe);
	malloc_unlock(&malloc_ctx, exceptions);
}
 11432fc:	a94153f3 	ldp	x19, x20, [sp, #16]
 1143300:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1143304:	a8c37bfd 	ldp	x29, x30, [sp], #48
	cpu_spin_unlock_xrestore(&ctx->spinlock, exceptions);
 1143308:	17fffe32 	b	1142bd0 <cpu_spin_unlock_xrestore>

000000000114330c <bpool>:

void bpool(buf, len, poolset)
  void *buf;
  bufsize len;
  struct bpoolset *poolset;
{
 114330c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    struct bfhead *b = BFH(buf);
    struct bhead *bn;

#ifdef SizeQuant
    len &= ~(SizeQuant - 1);
 1143310:	927cec21 	and	x1, x1, #0xfffffffffffffff0

    /* Since the block is initially occupied by a single free  buffer,
       it  had	better	not  be  (much) larger than the largest buffer
       whose size we can store in bhead.bsize. */

    assert(len - sizeof(struct bhead) <= -((bufsize) ESent + 1));
 1143314:	f1004021 	subs	x1, x1, #0x10
{
 1143318:	910003fd 	mov	x29, sp
    assert(len - sizeof(struct bhead) <= -((bufsize) ESent + 1));
 114331c:	54000145 	b.pl	1143344 <bpool+0x38>  // b.nfrst
 1143320:	d00000a3 	adrp	x3, 1159000 <Worder+0x2854>
 1143324:	d00000a1 	adrp	x1, 1159000 <Worder+0x2854>
 1143328:	d00000a0 	adrp	x0, 1159000 <Worder+0x2854>
 114332c:	91332463 	add	x3, x3, #0xcc9
 1143330:	91270421 	add	x1, x1, #0x9c1
 1143334:	91304c00 	add	x0, x0, #0xc13
 1143338:	52808ca2 	mov	w2, #0x465                 	// #1125

    b->bh.prevfree = 0;

    /* Chain the new block to the free list. */

    assert(poolset->freelist.ql.blink->ql.flink == &poolset->freelist);
 114333c:	97ff3bdc 	bl	11122ac <_assert_log>
 1143340:	97ff3bec 	bl	11122f0 <_assert_break>
 1143344:	f9400c44 	ldr	x4, [x2, #24]
 1143348:	f9400883 	ldr	x3, [x4, #16]
    b->bh.prevfree = 0;
 114334c:	f900001f 	str	xzr, [x0]
    assert(poolset->freelist.ql.blink->ql.flink == &poolset->freelist);
 1143350:	eb02007f 	cmp	x3, x2
 1143354:	54000120 	b.eq	1143378 <bpool+0x6c>  // b.none
 1143358:	d00000a3 	adrp	x3, 1159000 <Worder+0x2854>
 114335c:	d00000a1 	adrp	x1, 1159000 <Worder+0x2854>
 1143360:	d00000a0 	adrp	x0, 1159000 <Worder+0x2854>
 1143364:	91332463 	add	x3, x3, #0xcc9
 1143368:	91270421 	add	x1, x1, #0x9c1
 114336c:	91290c00 	add	x0, x0, #0xa43
 1143370:	52808de2 	mov	w2, #0x46f                 	// #1135
 1143374:	17fffff2 	b	114333c <bpool+0x30>
    assert(poolset->freelist.ql.flink->ql.blink == &poolset->freelist);
 1143378:	f9400862 	ldr	x2, [x3, #16]
 114337c:	f9400c42 	ldr	x2, [x2, #24]
 1143380:	eb02007f 	cmp	x3, x2
 1143384:	54000120 	b.eq	11433a8 <bpool+0x9c>  // b.none
 1143388:	d00000a3 	adrp	x3, 1159000 <Worder+0x2854>
 114338c:	d00000a1 	adrp	x1, 1159000 <Worder+0x2854>
 1143390:	d00000a0 	adrp	x0, 1159000 <Worder+0x2854>
 1143394:	91332463 	add	x3, x3, #0xcc9
 1143398:	91270421 	add	x1, x1, #0x9c1
 114339c:	9129f800 	add	x0, x0, #0xa7e
 11433a0:	52808e02 	mov	w2, #0x470                 	// #1136
 11433a4:	17ffffe6 	b	114333c <bpool+0x30>
    b->ql.flink = &poolset->freelist;
    b->ql.blink = poolset->freelist.ql.blink;
 11433a8:	a9011003 	stp	x3, x4, [x0, #16]
    poolset->freelist.ql.blink = b;
 11433ac:	f9000c60 	str	x0, [x3, #24]
    b->ql.blink->ql.flink = b;
 11433b0:	f9400c02 	ldr	x2, [x0, #24]
 11433b4:	f9000840 	str	x0, [x2, #16]
    b->bh.bsize = (bufsize) len;
#ifdef FreeWipe
    V memset_unchecked(((char *) b) + sizeof(struct bfhead), 0x55,
		       (MemSize) (len - sizeof(struct bfhead)));
#endif
    bn = BH(((char *) b) + len);
 11433b8:	8b010002 	add	x2, x0, x1
    b->bh.bsize = (bufsize) len;
 11433bc:	f9000401 	str	x1, [x0, #8]
    bn->prevfree = (bufsize) len;
 11433c0:	f8216801 	str	x1, [x0, x1]
    /* Definition of ESent assumes two's complement! */
    assert((~0) == -1);
    bn->bsize = ESent;
 11433c4:	d2f00000 	mov	x0, #0x8000000000000000    	// #-9223372036854775808
 11433c8:	f9000440 	str	x0, [x2, #8]
}
 11433cc:	a8c17bfd 	ldp	x29, x30, [sp], #16
 11433d0:	d65f03c0 	ret

00000000011433d4 <malloc_reset_stats>:
{
 11433d4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 11433d8:	910003fd 	mov	x29, sp
	uint32_t exceptions = malloc_lock(ctx);
 11433dc:	97fffdc9 	bl	1142b00 <malloc_lock.constprop.0>
	cpu_spin_unlock_xrestore(&ctx->spinlock, exceptions);
 11433e0:	2a0003e1 	mov	w1, w0
	ctx->mstats.max_allocated = 0;
 11433e4:	d00000c2 	adrp	x2, 115d000 <_curve_names+0x590>
 11433e8:	912d6042 	add	x2, x2, #0xb58
	cpu_spin_unlock_xrestore(&ctx->spinlock, exceptions);
 11433ec:	91020040 	add	x0, x2, #0x80
	ctx->mstats.max_allocated = 0;
 11433f0:	b9006c5f 	str	wzr, [x2, #108]
	ctx->mstats.num_alloc_fail = 0;
 11433f4:	b900745f 	str	wzr, [x2, #116]
	ctx->mstats.biggest_alloc_fail = 0;
 11433f8:	f9003c5f 	str	xzr, [x2, #120]
}
 11433fc:	a8c17bfd 	ldp	x29, x30, [sp], #16
	cpu_spin_unlock_xrestore(&ctx->spinlock, exceptions);
 1143400:	17fffdf4 	b	1142bd0 <cpu_spin_unlock_xrestore>

0000000001143404 <malloc_get_stats>:
{
 1143404:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1143408:	910003fd 	mov	x29, sp
 114340c:	a90153f3 	stp	x19, x20, [sp, #16]
}

static inline void *asan_memcpy_unchecked(void *__restrict s1,
					  const void *__restrict s2, size_t n)
{
	return memcpy(s1, s2, n);
 1143410:	d00000d3 	adrp	x19, 115d000 <_curve_names+0x590>
 1143414:	912d6273 	add	x19, x19, #0xb58
 1143418:	aa0003f4 	mov	x20, x0
 114341c:	f90013f5 	str	x21, [sp, #32]
	uint32_t exceptions = malloc_lock(ctx);
 1143420:	97fffdb8 	bl	1142b00 <malloc_lock.constprop.0>
 1143424:	2a0003f5 	mov	w21, w0
 1143428:	91012261 	add	x1, x19, #0x48
 114342c:	aa1403e0 	mov	x0, x20
 1143430:	d2800702 	mov	x2, #0x38                  	// #56
 1143434:	97feffd7 	bl	1103390 <memcpy>
	stats->allocated = ctx->poolset.totalloc;
 1143438:	f9401260 	ldr	x0, [x19, #32]
	cpu_spin_unlock_xrestore(&ctx->spinlock, exceptions);
 114343c:	2a1503e1 	mov	w1, w21
}
 1143440:	f94013f5 	ldr	x21, [sp, #32]
	stats->allocated = ctx->poolset.totalloc;
 1143444:	b9002280 	str	w0, [x20, #32]
	cpu_spin_unlock_xrestore(&ctx->spinlock, exceptions);
 1143448:	91020260 	add	x0, x19, #0x80
}
 114344c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1143450:	a8c37bfd 	ldp	x29, x30, [sp], #48
	cpu_spin_unlock_xrestore(&ctx->spinlock, exceptions);
 1143454:	17fffddf 	b	1142bd0 <cpu_spin_unlock_xrestore>

0000000001143458 <malloc>:
{
 1143458:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 114345c:	910003fd 	mov	x29, sp
 1143460:	a90153f3 	stp	x19, x20, [sp, #16]
 1143464:	aa0003f4 	mov	x20, x0
 1143468:	a9025bf5 	stp	x21, x22, [sp, #32]
	uint32_t exceptions = malloc_lock(&malloc_ctx);
 114346c:	97fffda5 	bl	1142b00 <malloc_lock.constprop.0>
	if (ADD_OVERFLOW(pl_size, ftr_size, &s))
 1143470:	f100029f 	cmp	x20, #0x0
	uint32_t exceptions = malloc_lock(&malloc_ctx);
 1143474:	2a0003f6 	mov	w22, w0
	if (ADD_OVERFLOW(pl_size, ftr_size, &s))
 1143478:	d00000d5 	adrp	x21, 115d000 <_curve_names+0x590>
 114347c:	5400026b 	b.lt	11434c8 <malloc+0x70>  // b.tstop
	ptr = bget(alignment, hdr_size, s, &ctx->poolset);
 1143480:	912d62a3 	add	x3, x21, #0xb58
 1143484:	9a9f1682 	csinc	x2, x20, xzr, ne  // ne = any
 1143488:	d2800001 	mov	x1, #0x0                   	// #0
 114348c:	d2800200 	mov	x0, #0x10                  	// #16
 1143490:	97fffde7 	bl	1142c2c <bget>
 1143494:	aa0003f3 	mov	x19, x0
	raw_malloc_return_hook(ptr, pl_size, ctx);
 1143498:	aa1403e1 	mov	x1, x20
 114349c:	aa1303e0 	mov	x0, x19
	cpu_spin_unlock_xrestore(&ctx->spinlock, exceptions);
 11434a0:	912d62b5 	add	x21, x21, #0xb58
	raw_malloc_return_hook(ptr, pl_size, ctx);
 11434a4:	97fffd86 	bl	1142abc <raw_malloc_return_hook.constprop.0>
	cpu_spin_unlock_xrestore(&ctx->spinlock, exceptions);
 11434a8:	2a1603e1 	mov	w1, w22
 11434ac:	910202a0 	add	x0, x21, #0x80
 11434b0:	97fffdc8 	bl	1142bd0 <cpu_spin_unlock_xrestore>
}
 11434b4:	aa1303e0 	mov	x0, x19
 11434b8:	a94153f3 	ldp	x19, x20, [sp, #16]
 11434bc:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11434c0:	a8c37bfd 	ldp	x29, x30, [sp], #48
 11434c4:	d65f03c0 	ret
	void *ptr = NULL;
 11434c8:	d2800013 	mov	x19, #0x0                   	// #0
 11434cc:	17fffff3 	b	1143498 <malloc+0x40>

00000000011434d0 <calloc>:

void *calloc(size_t nmemb, size_t size)
{
 11434d0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 11434d4:	910003fd 	mov	x29, sp
 11434d8:	a90153f3 	stp	x19, x20, [sp, #16]
 11434dc:	aa0103f4 	mov	x20, x1
 11434e0:	aa0003f3 	mov	x19, x0
 11434e4:	a9025bf5 	stp	x21, x22, [sp, #32]
	void *p;
	uint32_t exceptions = malloc_lock(&malloc_ctx);
 11434e8:	97fffd86 	bl	1142b00 <malloc_lock.constprop.0>
 11434ec:	2a0003f6 	mov	w22, w0
	if (MUL_OVERFLOW(pl_nmemb, pl_size, &s))
 11434f0:	9b147e75 	mul	x21, x19, x20
 11434f4:	d2800022 	mov	x2, #0x1                   	// #1
 11434f8:	9bd47e73 	umulh	x19, x19, x20
 11434fc:	d00000d4 	adrp	x20, 115d000 <_curve_names+0x590>
 1143500:	f100027f 	cmp	x19, #0x0
 1143504:	9a9f07e0 	cset	x0, ne  // ne = any
 1143508:	f10002bf 	cmp	x21, #0x0
 114350c:	9a82a000 	csel	x0, x0, x2, ge  // ge = tcont
 1143510:	b5000240 	cbnz	x0, 1143558 <calloc+0x88>
	ptr = bgetz(0, hdr_size, s, &ctx->poolset);
 1143514:	912d6283 	add	x3, x20, #0xb58
 1143518:	9a8212a2 	csel	x2, x21, x2, ne  // ne = any
 114351c:	d2800001 	mov	x1, #0x0                   	// #0
 1143520:	97fffe74 	bl	1142ef0 <bgetz>
 1143524:	aa0003f3 	mov	x19, x0
	raw_malloc_return_hook(ptr, pl_nmemb * pl_size, ctx);
 1143528:	aa1503e1 	mov	x1, x21
 114352c:	aa1303e0 	mov	x0, x19
	cpu_spin_unlock_xrestore(&ctx->spinlock, exceptions);
 1143530:	912d6294 	add	x20, x20, #0xb58
	raw_malloc_return_hook(ptr, pl_nmemb * pl_size, ctx);
 1143534:	97fffd62 	bl	1142abc <raw_malloc_return_hook.constprop.0>
	cpu_spin_unlock_xrestore(&ctx->spinlock, exceptions);
 1143538:	2a1603e1 	mov	w1, w22
 114353c:	91020280 	add	x0, x20, #0x80
 1143540:	97fffda4 	bl	1142bd0 <cpu_spin_unlock_xrestore>

	p = raw_calloc(0, 0, nmemb, size, &malloc_ctx);
	malloc_unlock(&malloc_ctx, exceptions);
	return p;
}
 1143544:	aa1303e0 	mov	x0, x19
 1143548:	a94153f3 	ldp	x19, x20, [sp, #16]
 114354c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1143550:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1143554:	d65f03c0 	ret
	void *ptr = NULL;
 1143558:	d2800013 	mov	x19, #0x0                   	// #0
 114355c:	17fffff3 	b	1143528 <calloc+0x58>

0000000001143560 <realloc>:
{
	return raw_realloc(ptr, 0, 0, size, ctx);
}

void *realloc(void *ptr, size_t size)
{
 1143560:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1143564:	910003fd 	mov	x29, sp
 1143568:	a90153f3 	stp	x19, x20, [sp, #16]
 114356c:	aa0003f4 	mov	x20, x0
 1143570:	aa0103f3 	mov	x19, x1
 1143574:	a9025bf5 	stp	x21, x22, [sp, #32]
	void *p;
	uint32_t exceptions = malloc_lock(&malloc_ctx);
 1143578:	97fffd62 	bl	1142b00 <malloc_lock.constprop.0>
 114357c:	d00000d5 	adrp	x21, 115d000 <_curve_names+0x590>
 1143580:	2a0003f6 	mov	w22, w0
	if (ADD_OVERFLOW(pl_size, hdr_size, &s))
 1143584:	b7f802b3 	tbnz	x19, #63, 11435d8 <realloc+0x78>
		s++;
 1143588:	f100027f 	cmp	x19, #0x0
	p = bgetr(ptr, 0, 0, s, &ctx->poolset);
 114358c:	aa1403e0 	mov	x0, x20
 1143590:	912d62a4 	add	x4, x21, #0xb58
 1143594:	9a9f1663 	csinc	x3, x19, xzr, ne  // ne = any
 1143598:	d2800002 	mov	x2, #0x0                   	// #0
 114359c:	d2800001 	mov	x1, #0x0                   	// #0
 11435a0:	97ffff1a 	bl	1143208 <bgetr>
 11435a4:	aa0003f4 	mov	x20, x0
	raw_malloc_return_hook(p, pl_size, ctx);
 11435a8:	aa1303e1 	mov	x1, x19
 11435ac:	aa1403e0 	mov	x0, x20
	cpu_spin_unlock_xrestore(&ctx->spinlock, exceptions);
 11435b0:	912d62b5 	add	x21, x21, #0xb58
	raw_malloc_return_hook(p, pl_size, ctx);
 11435b4:	97fffd42 	bl	1142abc <raw_malloc_return_hook.constprop.0>
	cpu_spin_unlock_xrestore(&ctx->spinlock, exceptions);
 11435b8:	2a1603e1 	mov	w1, w22
 11435bc:	910202a0 	add	x0, x21, #0x80
 11435c0:	97fffd84 	bl	1142bd0 <cpu_spin_unlock_xrestore>

	p = realloc_unlocked(&malloc_ctx, ptr, size);
	malloc_unlock(&malloc_ctx, exceptions);
	return p;
}
 11435c4:	aa1403e0 	mov	x0, x20
 11435c8:	a94153f3 	ldp	x19, x20, [sp, #16]
 11435cc:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11435d0:	a8c37bfd 	ldp	x29, x30, [sp], #48
 11435d4:	d65f03c0 	ret
	void *p = NULL;
 11435d8:	d2800014 	mov	x20, #0x0                   	// #0
 11435dc:	17fffff3 	b	11435a8 <realloc+0x48>

00000000011435e0 <free>:

#endif

void free(void *ptr)
{
	free_helper(ptr, false);
 11435e0:	52800001 	mov	w1, #0x0                   	// #0
 11435e4:	17ffff35 	b	11432b8 <free_helper>

00000000011435e8 <free_wipe>:
}

void free_wipe(void *ptr)
{
	free_helper(ptr, true);
 11435e8:	52800021 	mov	w1, #0x1                   	// #1
 11435ec:	17ffff33 	b	11432b8 <free_helper>

00000000011435f0 <malloc_add_pool>:
	malloc_unlock(ctx, exceptions);
	return ret;
}

void malloc_add_pool(void *buf, size_t len)
{
 11435f0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
 11435f4:	910003fd 	mov	x29, sp
 11435f8:	a90153f3 	stp	x19, x20, [sp, #16]
	uintptr_t end = start + len;
 11435fc:	8b010014 	add	x20, x0, x1
	start = ROUNDUP(start, SizeQuant);
 1143600:	91003c00 	add	x0, x0, #0xf
{
 1143604:	a9025bf5 	stp	x21, x22, [sp, #32]
	end = ROUNDDOWN(end, SizeQuant);
 1143608:	927cee94 	and	x20, x20, #0xfffffffffffffff0
	start = ROUNDUP(start, SizeQuant);
 114360c:	927cec15 	and	x21, x0, #0xfffffffffffffff0
{
 1143610:	a90363f7 	stp	x23, x24, [sp, #48]
	assert(start < end);
 1143614:	eb1402bf 	cmp	x21, x20
{
 1143618:	f90023f9 	str	x25, [sp, #64]
	assert(start < end);
 114361c:	54000143 	b.cc	1143644 <malloc_add_pool+0x54>  // b.lo, b.ul, b.last
 1143620:	d00000a3 	adrp	x3, 1159000 <Worder+0x2854>
 1143624:	d00000a1 	adrp	x1, 1159000 <Worder+0x2854>
 1143628:	d00000a0 	adrp	x0, 1159000 <Worder+0x2854>
 114362c:	91336c63 	add	x3, x3, #0xcdb
 1143630:	91312021 	add	x1, x1, #0xc48
 1143634:	9131a000 	add	x0, x0, #0xc68
 1143638:	528060e2 	mov	w2, #0x307                 	// #775
	assert(p);
 114363c:	97ff3b1c 	bl	11122ac <_assert_log>
 1143640:	97ff3b2c 	bl	11122f0 <_assert_break>
	if ((end - start) < min_len) {
 1143644:	cb150294 	sub	x20, x20, x21
 1143648:	f100be9f 	cmp	x20, #0x2f
 114364c:	540001c8 	b.hi	1143684 <malloc_add_pool+0x94>  // b.pmore
	gen_malloc_add_pool(&malloc_ctx, buf, len);
}
 1143650:	a94153f3 	ldp	x19, x20, [sp, #16]
		DMSG("Skipping too small pool");
 1143654:	d00000a4 	adrp	x4, 1159000 <Worder+0x2854>
}
 1143658:	a9425bf5 	ldp	x21, x22, [sp, #32]
		DMSG("Skipping too small pool");
 114365c:	9131d084 	add	x4, x4, #0xc74
}
 1143660:	a94363f7 	ldp	x23, x24, [sp, #48]
		DMSG("Skipping too small pool");
 1143664:	52800023 	mov	w3, #0x1                   	// #1
}
 1143668:	f94023f9 	ldr	x25, [sp, #64]
		DMSG("Skipping too small pool");
 114366c:	52800062 	mov	w2, #0x3                   	// #3
}
 1143670:	a8c57bfd 	ldp	x29, x30, [sp], #80
		DMSG("Skipping too small pool");
 1143674:	52806141 	mov	w1, #0x30a                 	// #778
 1143678:	d00000a0 	adrp	x0, 1159000 <Worder+0x2854>
 114367c:	91336c00 	add	x0, x0, #0xcdb
 1143680:	140005b1 	b	1144d44 <trace_printf>
	bpool((void *)start, end - start, &ctx->poolset);
 1143684:	d00000d3 	adrp	x19, 115d000 <_curve_names+0x590>
 1143688:	912d6279 	add	x25, x19, #0xb58
	exceptions = malloc_lock(ctx);
 114368c:	97fffd1d 	bl	1142b00 <malloc_lock.constprop.0>
 1143690:	2a0003f7 	mov	w23, w0
	bpool((void *)start, end - start, &ctx->poolset);
 1143694:	aa1903e2 	mov	x2, x25
 1143698:	aa1403e1 	mov	x1, x20
 114369c:	aa1503e0 	mov	x0, x21
 11436a0:	97ffff1b 	bl	114330c <bpool>
	l = ctx->pool_len + 1;
 11436a4:	f9402336 	ldr	x22, [x25, #64]
 11436a8:	910006d6 	add	x22, x22, #0x1
	p = realloc_unlocked(ctx, ctx->pool, sizeof(struct malloc_pool) * l);
 11436ac:	d37ceed8 	lsl	x24, x22, #4
	if (ADD_OVERFLOW(pl_size, hdr_size, &s))
 11436b0:	b7d802b6 	tbnz	x22, #59, 1143704 <malloc_add_pool+0x114>
	p = bgetr(ptr, 0, 0, s, &ctx->poolset);
 11436b4:	f9401f20 	ldr	x0, [x25, #56]
		s++;
 11436b8:	f100031f 	cmp	x24, #0x0
	p = bgetr(ptr, 0, 0, s, &ctx->poolset);
 11436bc:	aa1903e4 	mov	x4, x25
 11436c0:	9a9f1703 	csinc	x3, x24, xzr, ne  // ne = any
 11436c4:	d2800002 	mov	x2, #0x0                   	// #0
 11436c8:	d2800001 	mov	x1, #0x0                   	// #0
 11436cc:	97fffecf 	bl	1143208 <bgetr>
 11436d0:	aa0003e6 	mov	x6, x0
	raw_malloc_return_hook(p, pl_size, ctx);
 11436d4:	aa1803e1 	mov	x1, x24
 11436d8:	aa0603e0 	mov	x0, x6
 11436dc:	97fffcf8 	bl	1142abc <raw_malloc_return_hook.constprop.0>
	assert(p);
 11436e0:	b5000166 	cbnz	x6, 114370c <malloc_add_pool+0x11c>
 11436e4:	d00000a3 	adrp	x3, 1159000 <Worder+0x2854>
 11436e8:	d00000a1 	adrp	x1, 1159000 <Worder+0x2854>
 11436ec:	b0000080 	adrp	x0, 1154000 <__func__.1786+0x8>
 11436f0:	91336c63 	add	x3, x3, #0xcdb
 11436f4:	91312021 	add	x1, x1, #0xc48
 11436f8:	9139dc00 	add	x0, x0, #0xe77
 11436fc:	52806282 	mov	w2, #0x314                 	// #788
 1143700:	17ffffcf 	b	114363c <malloc_add_pool+0x4c>
	void *p = NULL;
 1143704:	d2800006 	mov	x6, #0x0                   	// #0
 1143708:	17fffff3 	b	11436d4 <malloc_add_pool+0xe4>
	ctx->pool = p;
 114370c:	912d6273 	add	x19, x19, #0xb58
}
 1143710:	f94023f9 	ldr	x25, [sp, #64]
	ctx->pool[ctx->pool_len].buf = (void *)start;
 1143714:	f9402260 	ldr	x0, [x19, #64]
	ctx->pool = p;
 1143718:	f9001e66 	str	x6, [x19, #56]
	ctx->pool[ctx->pool_len].buf = (void *)start;
 114371c:	d37cec01 	lsl	x1, x0, #4
 1143720:	8b0010c0 	add	x0, x6, x0, lsl #4
 1143724:	f82168d5 	str	x21, [x6, x1]
	cpu_spin_unlock_xrestore(&ctx->spinlock, exceptions);
 1143728:	2a1703e1 	mov	w1, w23
}
 114372c:	a94363f7 	ldp	x23, x24, [sp, #48]
	ctx->pool[ctx->pool_len].len = end - start;
 1143730:	f9000414 	str	x20, [x0, #8]
	ctx->mstats.size += ctx->pool[ctx->pool_len].len;
 1143734:	b9407260 	ldr	w0, [x19, #112]
	ctx->pool_len = l;
 1143738:	f9002276 	str	x22, [x19, #64]
	ctx->mstats.size += ctx->pool[ctx->pool_len].len;
 114373c:	0b140014 	add	w20, w0, w20
	cpu_spin_unlock_xrestore(&ctx->spinlock, exceptions);
 1143740:	91020260 	add	x0, x19, #0x80
	ctx->mstats.size += ctx->pool[ctx->pool_len].len;
 1143744:	b9007274 	str	w20, [x19, #112]
}
 1143748:	a94153f3 	ldp	x19, x20, [sp, #16]
 114374c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1143750:	a8c57bfd 	ldp	x29, x30, [sp], #80
	cpu_spin_unlock_xrestore(&ctx->spinlock, exceptions);
 1143754:	17fffd1f 	b	1142bd0 <cpu_spin_unlock_xrestore>

0000000001143758 <swapfunc>:
#define SWAPINIT(a, es) swaptype = ((char *)a - (char *)0) % sizeof(long) || \
		es % sizeof(long) ? 2 : es == sizeof(long)? 0 : 1;
static __inline void
swapfunc(char *a, char *b, int n, int swaptype)
{
	if (swaptype <= 1)
 1143758:	7100087f 	cmp	w3, #0x2
 114375c:	93407c42 	sxtw	x2, w2
 1143760:	54000180 	b.eq	1143790 <swapfunc+0x38>  // b.none
		swapcode(long, a, b, n)
 1143764:	d343fc42 	lsr	x2, x2, #3
 1143768:	d2800003 	mov	x3, #0x0                   	// #0
 114376c:	f8637825 	ldr	x5, [x1, x3, lsl #3]
 1143770:	f8637804 	ldr	x4, [x0, x3, lsl #3]
 1143774:	f8237805 	str	x5, [x0, x3, lsl #3]
 1143778:	f8237824 	str	x4, [x1, x3, lsl #3]
 114377c:	91000463 	add	x3, x3, #0x1
 1143780:	cb030044 	sub	x4, x2, x3
 1143784:	f100009f 	cmp	x4, #0x0
 1143788:	54ffff2c 	b.gt	114376c <swapfunc+0x14>
		else
			swapcode(char, a, b, n)
}
 114378c:	d65f03c0 	ret
 1143790:	d2800003 	mov	x3, #0x0                   	// #0
			swapcode(char, a, b, n)
 1143794:	38636825 	ldrb	w5, [x1, x3]
 1143798:	38636804 	ldrb	w4, [x0, x3]
 114379c:	38236805 	strb	w5, [x0, x3]
 11437a0:	38236824 	strb	w4, [x1, x3]
 11437a4:	91000463 	add	x3, x3, #0x1
 11437a8:	cb030044 	sub	x4, x2, x3
 11437ac:	f100009f 	cmp	x4, #0x0
 11437b0:	54ffff2c 	b.gt	1143794 <swapfunc+0x3c>
 11437b4:	17fffff6 	b	114378c <swapfunc+0x34>

00000000011437b8 <med3>:
		} else						\
		swapfunc(a, b, es, swaptype)
#define vecswap(a, b, n) 	if ((n) > 0) swapfunc(a, b, n, swaptype)
static __inline char *
med3(char *a, char *b, char *c, int (*cmp)(const void *, const void *))
{
 11437b8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 11437bc:	910003fd 	mov	x29, sp
 11437c0:	a90153f3 	stp	x19, x20, [sp, #16]
 11437c4:	aa0103f3 	mov	x19, x1
 11437c8:	aa0203f4 	mov	x20, x2
 11437cc:	a9025bf5 	stp	x21, x22, [sp, #32]
 11437d0:	aa0003f6 	mov	x22, x0
 11437d4:	aa0303f5 	mov	x21, x3
	return cmp(a, b) < 0 ?
 11437d8:	d63f0060 	blr	x3
			(cmp(b, c) < 0 ? b : (cmp(a, c) < 0 ? c : a ))
 11437dc:	aa1403e1 	mov	x1, x20
			:(cmp(b, c) > 0 ? b : (cmp(a, c) < 0 ? a : c ));
 11437e0:	36f801c0 	tbz	w0, #31, 1143818 <med3+0x60>
			(cmp(b, c) < 0 ? b : (cmp(a, c) < 0 ? c : a ))
 11437e4:	aa1303e0 	mov	x0, x19
 11437e8:	d63f02a0 	blr	x21
 11437ec:	37f800c0 	tbnz	w0, #31, 1143804 <med3+0x4c>
 11437f0:	aa1403e1 	mov	x1, x20
 11437f4:	aa1603e0 	mov	x0, x22
 11437f8:	d63f02a0 	blr	x21
 11437fc:	37f801e0 	tbnz	w0, #31, 1143838 <med3+0x80>
 1143800:	aa1603f3 	mov	x19, x22
}
 1143804:	aa1303e0 	mov	x0, x19
 1143808:	a94153f3 	ldp	x19, x20, [sp, #16]
 114380c:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1143810:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1143814:	d65f03c0 	ret
			:(cmp(b, c) > 0 ? b : (cmp(a, c) < 0 ? a : c ));
 1143818:	aa1303e0 	mov	x0, x19
 114381c:	d63f02a0 	blr	x21
 1143820:	7100001f 	cmp	w0, #0x0
 1143824:	54ffff0c 	b.gt	1143804 <med3+0x4c>
 1143828:	aa1403e1 	mov	x1, x20
 114382c:	aa1603e0 	mov	x0, x22
 1143830:	d63f02a0 	blr	x21
 1143834:	37fffe60 	tbnz	w0, #31, 1143800 <med3+0x48>
 1143838:	aa1403f3 	mov	x19, x20
 114383c:	17fffff2 	b	1143804 <med3+0x4c>

0000000001143840 <qsort>:
void
qsort(void *aa, size_t n, size_t es, int (*cmp)(const void *, const void *))
{
 1143840:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
 1143844:	910003fd 	mov	x29, sp
 1143848:	a90153f3 	stp	x19, x20, [sp, #16]
 114384c:	aa0203f3 	mov	x19, x2
 1143850:	a9025bf5 	stp	x21, x22, [sp, #32]
 1143854:	aa0003f5 	mov	x21, x0
 1143858:	a90363f7 	stp	x23, x24, [sp, #48]
 114385c:	aa0103f8 	mov	x24, x1
 1143860:	a90573fb 	stp	x27, x28, [sp, #80]
 1143864:	aa0303fb 	mov	x27, x3
 1143868:	a9046bf9 	stp	x25, x26, [sp, #64]
	char *pa, *pb, *pc, *pd, *pl, *pm, *pn;
	int d, r, swaptype, swap_cnt;
	char *a = aa;
	loop:	SWAPINIT(a, es);
 114386c:	aa1302a0 	orr	x0, x21, x19
 1143870:	f240081f 	tst	x0, #0x7
 1143874:	54000241 	b.ne	11438bc <qsort+0x7c>  // b.any
 1143878:	f100227f 	cmp	x19, #0x8
 114387c:	1a9f07f7 	cset	w23, ne  // ne = any
	swap_cnt = 0;
	if (n < 7) {
 1143880:	8b1302a0 	add	x0, x21, x19
 1143884:	f90037e0 	str	x0, [sp, #104]
 1143888:	f1001b1f 	cmp	x24, #0x6
 114388c:	540004c8 	b.hi	1143924 <qsort+0xe4>  // b.pmore
		for (pm = (char *)a + es; pm < (char *) a + n * es; pm += es)
 1143890:	9b135718 	madd	x24, x24, x19, x21
 1143894:	aa0003f6 	mov	x22, x0
 1143898:	eb16031f 	cmp	x24, x22
 114389c:	54000208 	b.hi	11438dc <qsort+0x9c>  // b.pmore
		a = pn - r;
		n = r / es;
		goto loop;
	}
	/* qsort(pn - r, r / es, es, cmp);*/
}
 11438a0:	a94153f3 	ldp	x19, x20, [sp, #16]
 11438a4:	a9425bf5 	ldp	x21, x22, [sp, #32]
 11438a8:	a94363f7 	ldp	x23, x24, [sp, #48]
 11438ac:	a9446bf9 	ldp	x25, x26, [sp, #64]
 11438b0:	a94573fb 	ldp	x27, x28, [sp, #80]
 11438b4:	a8c77bfd 	ldp	x29, x30, [sp], #112
 11438b8:	d65f03c0 	ret
	loop:	SWAPINIT(a, es);
 11438bc:	52800057 	mov	w23, #0x2                   	// #2
 11438c0:	17fffff0 	b	1143880 <qsort+0x40>
				swap(pl, pl - es);
 11438c4:	2a1703e3 	mov	w3, w23
 11438c8:	2a1303e2 	mov	w2, w19
 11438cc:	aa1903e1 	mov	x1, x25
 11438d0:	aa1403e0 	mov	x0, x20
 11438d4:	97ffffa1 	bl	1143758 <swapfunc>
 11438d8:	1400000e 	b	1143910 <qsort+0xd0>
 11438dc:	aa1603f4 	mov	x20, x22
 11438e0:	1400000d 	b	1143914 <qsort+0xd4>
			for (pl = pm; pl > (char *) a && cmp(pl - es, pl) > 0;
 11438e4:	cb130299 	sub	x25, x20, x19
 11438e8:	aa1403e1 	mov	x1, x20
 11438ec:	aa1903e0 	mov	x0, x25
 11438f0:	d63f0360 	blr	x27
 11438f4:	7100001f 	cmp	w0, #0x0
 11438f8:	5400012d 	b.le	114391c <qsort+0xdc>
				swap(pl, pl - es);
 11438fc:	35fffe57 	cbnz	w23, 11438c4 <qsort+0x84>
 1143900:	f9400321 	ldr	x1, [x25]
 1143904:	f9400280 	ldr	x0, [x20]
 1143908:	f9000281 	str	x1, [x20]
 114390c:	f9000320 	str	x0, [x25]
			for (pl = pm; pl > (char *) a && cmp(pl - es, pl) > 0;
 1143910:	aa1903f4 	mov	x20, x25
 1143914:	eb15029f 	cmp	x20, x21
 1143918:	54fffe68 	b.hi	11438e4 <qsort+0xa4>  // b.pmore
		for (pm = (char *)a + es; pm < (char *) a + n * es; pm += es)
 114391c:	8b1302d6 	add	x22, x22, x19
 1143920:	17ffffde 	b	1143898 <qsort+0x58>
	pm = (char *)a + (n / 2) * es;
 1143924:	d341ff19 	lsr	x25, x24, #1
 1143928:	d1000714 	sub	x20, x24, #0x1
	if (n > 7) {
 114392c:	f1001f1f 	cmp	x24, #0x7
	pm = (char *)a + (n / 2) * es;
 1143930:	9b135739 	madd	x25, x25, x19, x21
	if (n > 7) {
 1143934:	9b135694 	madd	x20, x20, x19, x21
 1143938:	540003c0 	b.eq	11439b0 <qsort+0x170>  // b.none
		if (n > 40) {
 114393c:	f100a31f 	cmp	x24, #0x28
 1143940:	54000729 	b.ls	1143a24 <qsort+0x1e4>  // b.plast
			d = (n / 8) * es;
 1143944:	d343ff1a 	lsr	x26, x24, #3
			pl = med3(pl, pl + d, pl + 2 * d, cmp);
 1143948:	aa1b03e3 	mov	x3, x27
 114394c:	aa1503e0 	mov	x0, x21
			d = (n / 8) * es;
 1143950:	1b137f5a 	mul	w26, w26, w19
			pl = med3(pl, pl + d, pl + 2 * d, cmp);
 1143954:	93407f56 	sxtw	x22, w26
 1143958:	8b3ac6a2 	add	x2, x21, w26, sxtw #1
 114395c:	8b3ac2a1 	add	x1, x21, w26, sxtw
 1143960:	531f7b5a 	lsl	w26, w26, #1
 1143964:	97ffff95 	bl	11437b8 <med3>
 1143968:	aa0003fc 	mov	x28, x0
			pm = med3(pm - d, pm, pm + d, cmp);
 114396c:	8b160322 	add	x2, x25, x22
 1143970:	aa1903e1 	mov	x1, x25
 1143974:	aa1b03e3 	mov	x3, x27
 1143978:	cb160320 	sub	x0, x25, x22
 114397c:	97ffff8f 	bl	11437b8 <med3>
 1143980:	aa0003f9 	mov	x25, x0
			pn = med3(pn - 2 * d, pn - d, pn, cmp);
 1143984:	aa1403e2 	mov	x2, x20
 1143988:	cb3ac280 	sub	x0, x20, w26, sxtw
 114398c:	aa1b03e3 	mov	x3, x27
 1143990:	8b160001 	add	x1, x0, x22
 1143994:	97ffff89 	bl	11437b8 <med3>
 1143998:	aa0003e2 	mov	x2, x0
		pm = med3(pl, pm, pn, cmp);
 114399c:	aa1903e1 	mov	x1, x25
 11439a0:	aa1b03e3 	mov	x3, x27
 11439a4:	aa1c03e0 	mov	x0, x28
 11439a8:	97ffff84 	bl	11437b8 <med3>
 11439ac:	aa0003f9 	mov	x25, x0
	swap(a, pm);
 11439b0:	35000417 	cbnz	w23, 1143a30 <qsort+0x1f0>
 11439b4:	f9400321 	ldr	x1, [x25]
 11439b8:	f94002a0 	ldr	x0, [x21]
 11439bc:	f90002a1 	str	x1, [x21]
 11439c0:	f9000320 	str	x0, [x25]
	pa = pb = (char *)a + es;
 11439c4:	8b1302bc 	add	x28, x21, x19
	pc = pd = (char *)a + (n - 1) * es;
 11439c8:	aa1403f6 	mov	x22, x20
 11439cc:	aa1c03f9 	mov	x25, x28
	pa = pb = (char *)a + es;
 11439d0:	aa1c03fa 	mov	x26, x28
	swap_cnt = 0;
 11439d4:	52800002 	mov	w2, #0x0                   	// #0
		while (pb <= pc && (r = cmp(pb, a)) <= 0) {
 11439d8:	eb14033f 	cmp	x25, x20
 11439dc:	54000588 	b.hi	1143a8c <qsort+0x24c>  // b.pmore
 11439e0:	aa1503e1 	mov	x1, x21
 11439e4:	aa1903e0 	mov	x0, x25
 11439e8:	b9006be2 	str	w2, [sp, #104]
 11439ec:	d63f0360 	blr	x27
 11439f0:	b9406be2 	ldr	w2, [sp, #104]
 11439f4:	7100001f 	cmp	w0, #0x0
 11439f8:	5400062c 	b.gt	1143abc <qsort+0x27c>
			if (r == 0) {
 11439fc:	54000101 	b.ne	1143a1c <qsort+0x1dc>  // b.any
				swap(pa, pb);
 1143a00:	35000257 	cbnz	w23, 1143a48 <qsort+0x208>
 1143a04:	f9400321 	ldr	x1, [x25]
 1143a08:	f9400340 	ldr	x0, [x26]
 1143a0c:	f9000341 	str	x1, [x26]
 1143a10:	f9000320 	str	x0, [x25]
				pa += es;
 1143a14:	8b13035a 	add	x26, x26, x19
				swap_cnt = 1;
 1143a18:	52800022 	mov	w2, #0x1                   	// #1
			pb += es;
 1143a1c:	8b130339 	add	x25, x25, x19
 1143a20:	17ffffee 	b	11439d8 <qsort+0x198>
		pn = (char *)a + (n - 1) * es;
 1143a24:	aa1403e2 	mov	x2, x20
 1143a28:	aa1503fc 	mov	x28, x21
 1143a2c:	17ffffdc 	b	114399c <qsort+0x15c>
	swap(a, pm);
 1143a30:	2a1703e3 	mov	w3, w23
 1143a34:	2a1303e2 	mov	w2, w19
 1143a38:	aa1903e1 	mov	x1, x25
 1143a3c:	aa1503e0 	mov	x0, x21
 1143a40:	97ffff46 	bl	1143758 <swapfunc>
 1143a44:	17ffffe0 	b	11439c4 <qsort+0x184>
				swap(pa, pb);
 1143a48:	2a1703e3 	mov	w3, w23
 1143a4c:	2a1303e2 	mov	w2, w19
 1143a50:	aa1903e1 	mov	x1, x25
 1143a54:	aa1a03e0 	mov	x0, x26
 1143a58:	97ffff40 	bl	1143758 <swapfunc>
 1143a5c:	17ffffee 	b	1143a14 <qsort+0x1d4>
			if (r == 0) {
 1143a60:	54000101 	b.ne	1143a80 <qsort+0x240>  // b.any
				swap(pc, pd);
 1143a64:	35000217 	cbnz	w23, 1143aa4 <qsort+0x264>
 1143a68:	f94002c1 	ldr	x1, [x22]
 1143a6c:	f9400280 	ldr	x0, [x20]
 1143a70:	f9000281 	str	x1, [x20]
 1143a74:	f90002c0 	str	x0, [x22]
				pd -= es;
 1143a78:	cb1302d6 	sub	x22, x22, x19
				swap_cnt = 1;
 1143a7c:	52800022 	mov	w2, #0x1                   	// #1
			pc -= es;
 1143a80:	aa0603f4 	mov	x20, x6
		while (pb <= pc && (r = cmp(pc, a)) >= 0) {
 1143a84:	eb06033f 	cmp	x25, x6
 1143a88:	540001a9 	b.ls	1143abc <qsort+0x27c>  // b.plast
	if (swap_cnt == 0) {  /* Switch to insertion sort */
 1143a8c:	9b135718 	madd	x24, x24, x19, x21
 1143a90:	350006c2 	cbnz	w2, 1143b68 <qsort+0x328>
		for (pm = (char *) a + es; pm < (char *) a + n * es; pm += es)
 1143a94:	eb18039f 	cmp	x28, x24
 1143a98:	54fff042 	b.cs	11438a0 <qsort+0x60>  // b.hs, b.nlast
 1143a9c:	aa1c03f4 	mov	x20, x28
 1143aa0:	1400002e 	b	1143b58 <qsort+0x318>
				swap(pc, pd);
 1143aa4:	2a1703e3 	mov	w3, w23
 1143aa8:	2a1303e2 	mov	w2, w19
 1143aac:	aa1603e1 	mov	x1, x22
 1143ab0:	aa1403e0 	mov	x0, x20
 1143ab4:	97ffff29 	bl	1143758 <swapfunc>
 1143ab8:	17fffff0 	b	1143a78 <qsort+0x238>
		while (pb <= pc && (r = cmp(pc, a)) >= 0) {
 1143abc:	aa1503e1 	mov	x1, x21
 1143ac0:	aa1403e0 	mov	x0, x20
 1143ac4:	b9006be2 	str	w2, [sp, #104]
 1143ac8:	d63f0360 	blr	x27
 1143acc:	b9406be2 	ldr	w2, [sp, #104]
 1143ad0:	7100001f 	cmp	w0, #0x0
 1143ad4:	cb130286 	sub	x6, x20, x19
 1143ad8:	54fffc4a 	b.ge	1143a60 <qsort+0x220>  // b.tcont
		swap(pb, pc);
 1143adc:	340000f7 	cbz	w23, 1143af8 <qsort+0x2b8>
 1143ae0:	2a1703e3 	mov	w3, w23
 1143ae4:	2a1303e2 	mov	w2, w19
 1143ae8:	aa1403e1 	mov	x1, x20
 1143aec:	aa1903e0 	mov	x0, x25
 1143af0:	97ffff1a 	bl	1143758 <swapfunc>
 1143af4:	14000005 	b	1143b08 <qsort+0x2c8>
 1143af8:	f9400281 	ldr	x1, [x20]
 1143afc:	f9400320 	ldr	x0, [x25]
 1143b00:	f9000321 	str	x1, [x25]
 1143b04:	f9000280 	str	x0, [x20]
		pc -= es;
 1143b08:	aa0603f4 	mov	x20, x6
	for (;;) {
 1143b0c:	17ffffc3 	b	1143a18 <qsort+0x1d8>
				swap(pl, pl - es);
 1143b10:	2a1703e3 	mov	w3, w23
 1143b14:	2a1303e2 	mov	w2, w19
 1143b18:	aa1603e1 	mov	x1, x22
 1143b1c:	aa1403e0 	mov	x0, x20
 1143b20:	97ffff0e 	bl	1143758 <swapfunc>
 1143b24:	1400000c 	b	1143b54 <qsort+0x314>
			for (pl = pm; pl > (char *) a && cmp(pl - es, pl) > 0;
 1143b28:	cb130296 	sub	x22, x20, x19
 1143b2c:	aa1403e1 	mov	x1, x20
 1143b30:	aa1603e0 	mov	x0, x22
 1143b34:	d63f0360 	blr	x27
 1143b38:	7100001f 	cmp	w0, #0x0
 1143b3c:	5400012d 	b.le	1143b60 <qsort+0x320>
				swap(pl, pl - es);
 1143b40:	35fffe97 	cbnz	w23, 1143b10 <qsort+0x2d0>
 1143b44:	f94002c1 	ldr	x1, [x22]
 1143b48:	f9400280 	ldr	x0, [x20]
 1143b4c:	f9000281 	str	x1, [x20]
 1143b50:	f90002c0 	str	x0, [x22]
			for (pl = pm; pl > (char *) a && cmp(pl - es, pl) > 0;
 1143b54:	aa1603f4 	mov	x20, x22
 1143b58:	eb15029f 	cmp	x20, x21
 1143b5c:	54fffe68 	b.hi	1143b28 <qsort+0x2e8>  // b.pmore
		for (pm = (char *) a + es; pm < (char *) a + n * es; pm += es)
 1143b60:	8b13039c 	add	x28, x28, x19
 1143b64:	17ffffcc 	b	1143a94 <qsort+0x254>
	r = min(pa - (char *)a, pb - pa);
 1143b68:	cb1a0326 	sub	x6, x25, x26
 1143b6c:	cb150341 	sub	x1, x26, x21
 1143b70:	eb06003f 	cmp	x1, x6
 1143b74:	9a86d021 	csel	x1, x1, x6, le
	vecswap(a, pb - r, r);
 1143b78:	7100003f 	cmp	w1, #0x0
 1143b7c:	540000cd 	b.le	1143b94 <qsort+0x354>
 1143b80:	2a0103e2 	mov	w2, w1
 1143b84:	2a1703e3 	mov	w3, w23
 1143b88:	cb21c321 	sub	x1, x25, w1, sxtw
 1143b8c:	aa1503e0 	mov	x0, x21
 1143b90:	97fffef2 	bl	1143758 <swapfunc>
	r = min(pd - pc, pn - pd - (int)es);
 1143b94:	cb160301 	sub	x1, x24, x22
 1143b98:	cb1402d4 	sub	x20, x22, x20
 1143b9c:	cb33c021 	sub	x1, x1, w19, sxtw
 1143ba0:	eb14003f 	cmp	x1, x20
 1143ba4:	9a94d021 	csel	x1, x1, x20, le
	vecswap(pb, pn - r, r);
 1143ba8:	7100003f 	cmp	w1, #0x0
 1143bac:	540000cd 	b.le	1143bc4 <qsort+0x384>
 1143bb0:	2a0103e2 	mov	w2, w1
 1143bb4:	2a1703e3 	mov	w3, w23
 1143bb8:	cb21c301 	sub	x1, x24, w1, sxtw
 1143bbc:	aa1903e0 	mov	x0, x25
 1143bc0:	97fffee6 	bl	1143758 <swapfunc>
	if ((r = pb - pa) > (int)es)
 1143bc4:	6b06027f 	cmp	w19, w6
 1143bc8:	540000ea 	b.ge	1143be4 <qsort+0x3a4>  // b.tcont
		qsort(a, r / es, es, cmp);
 1143bcc:	93407cc1 	sxtw	x1, w6
 1143bd0:	aa1b03e3 	mov	x3, x27
 1143bd4:	aa1303e2 	mov	x2, x19
 1143bd8:	aa1503e0 	mov	x0, x21
 1143bdc:	9ad30821 	udiv	x1, x1, x19
 1143be0:	97ffff18 	bl	1143840 <qsort>
	if ((r = pd - pc) > (int)es) {
 1143be4:	6b14027f 	cmp	w19, w20
 1143be8:	54ffe5ca 	b.ge	11438a0 <qsort+0x60>  // b.tcont
		a = pn - r;
 1143bec:	93407e81 	sxtw	x1, w20
 1143bf0:	cb34c315 	sub	x21, x24, w20, sxtw
		n = r / es;
 1143bf4:	9ad30838 	udiv	x24, x1, x19
		goto loop;
 1143bf8:	17ffff1d 	b	114386c <qsort+0x2c>

0000000001143bfc <snprintf>:

#include <stdio.h>
#include <printk.h>

int snprintf(char *bf, size_t size, const char *fmt, ...)
{
 1143bfc:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
 1143c00:	910003fd 	mov	x29, sp
 1143c04:	a90593e3 	stp	x3, x4, [sp, #88]
	int retval;
	va_list ap;

	va_start(ap, fmt);
 1143c08:	910203e3 	add	x3, sp, #0x80
 1143c0c:	a9030fe3 	stp	x3, x3, [sp, #48]
 1143c10:	910143e3 	add	x3, sp, #0x50
 1143c14:	f90023e3 	str	x3, [sp, #64]
 1143c18:	128004e3 	mov	w3, #0xffffffd8            	// #-40
 1143c1c:	b9004be3 	str	w3, [sp, #72]
	retval = __vsnprintf(bf, size, fmt, ap, false);
 1143c20:	910043e3 	add	x3, sp, #0x10
	va_start(ap, fmt);
 1143c24:	b9004fff 	str	wzr, [sp, #76]
{
 1143c28:	a9069be5 	stp	x5, x6, [sp, #104]
	retval = __vsnprintf(bf, size, fmt, ap, false);
 1143c2c:	a94317e4 	ldp	x4, x5, [sp, #48]
 1143c30:	a90117e4 	stp	x4, x5, [sp, #16]
 1143c34:	a94417e4 	ldp	x4, x5, [sp, #64]
 1143c38:	a90217e4 	stp	x4, x5, [sp, #32]
{
 1143c3c:	f9003fe7 	str	x7, [sp, #120]
	retval = __vsnprintf(bf, size, fmt, ap, false);
 1143c40:	52800004 	mov	w4, #0x0                   	// #0
 1143c44:	94000056 	bl	1143d9c <__vsnprintf>
	va_end(ap);

	return retval;
}
 1143c48:	a8c87bfd 	ldp	x29, x30, [sp], #128
 1143c4c:	d65f03c0 	ret

0000000001143c50 <memcmp>:
#if defined(PREFER_SIZE_OVER_SPEED) || defined(__OPTIMIZE_SIZE__)
	unsigned char *s1 = (unsigned char *)m1;
	unsigned char *s2 = (unsigned char *)m2;

	while (n--) {
		if (*s1 != *s2)
 1143c50:	d1000421 	sub	x1, x1, #0x1
	while (n--) {
 1143c54:	d2800004 	mov	x4, #0x0                   	// #0
 1143c58:	eb04005f 	cmp	x2, x4
 1143c5c:	54000061 	b.ne	1143c68 <memcmp+0x18>  // b.any
			return *s1 - *s2;
		s1++;
		s2++;
	}
	return 0;
 1143c60:	52800000 	mov	w0, #0x0                   	// #0
 1143c64:	14000007 	b	1143c80 <memcmp+0x30>
		if (*s1 != *s2)
 1143c68:	38646803 	ldrb	w3, [x0, x4]
 1143c6c:	91000484 	add	x4, x4, #0x1
 1143c70:	38646825 	ldrb	w5, [x1, x4]
 1143c74:	6b05007f 	cmp	w3, w5
 1143c78:	54ffff00 	b.eq	1143c58 <memcmp+0x8>  // b.none
			return *s1 - *s2;
 1143c7c:	4b050060 	sub	w0, w3, w5
		s2++;
	}

	return 0;
#endif /* not PREFER_SIZE_OVER_SPEED */
}
 1143c80:	d65f03c0 	ret

0000000001143c84 <memmove>:
{
#if defined(PREFER_SIZE_OVER_SPEED) || defined(__OPTIMIZE_SIZE__)
	char *dst = dst_void;
	_CONST char *src = src_void;

	if (src < dst && dst < src + length) {
 1143c84:	eb01001f 	cmp	x0, x1
 1143c88:	54000289 	b.ls	1143cd8 <memmove+0x54>  // b.plast
 1143c8c:	8b020023 	add	x3, x1, x2
 1143c90:	eb00007f 	cmp	x3, x0
 1143c94:	54000229 	b.ls	1143cd8 <memmove+0x54>  // b.plast
		/* Have to copy backwards */
		src += length;
		dst += length;
 1143c98:	8b020004 	add	x4, x0, x2
		while (length--)
 1143c9c:	aa2203e2 	mvn	x2, x2
 1143ca0:	d2800001 	mov	x1, #0x0                   	// #0
 1143ca4:	d1000421 	sub	x1, x1, #0x1
 1143ca8:	eb01005f 	cmp	x2, x1
 1143cac:	54000041 	b.ne	1143cb4 <memmove+0x30>  // b.any
			*dst++ = *src++;
	}

	return dst_void;
#endif /* not PREFER_SIZE_OVER_SPEED */
}
 1143cb0:	d65f03c0 	ret
			*--dst = *--src;
 1143cb4:	38616865 	ldrb	w5, [x3, x1]
 1143cb8:	38216885 	strb	w5, [x4, x1]
 1143cbc:	17fffffa 	b	1143ca4 <memmove+0x20>
			*dst++ = *src++;
 1143cc0:	38636824 	ldrb	w4, [x1, x3]
 1143cc4:	38236804 	strb	w4, [x0, x3]
 1143cc8:	91000463 	add	x3, x3, #0x1
		while (length--)
 1143ccc:	eb02007f 	cmp	x3, x2
 1143cd0:	54ffff81 	b.ne	1143cc0 <memmove+0x3c>  // b.any
 1143cd4:	17fffff7 	b	1143cb0 <memmove+0x2c>
 1143cd8:	d2800003 	mov	x3, #0x0                   	// #0
 1143cdc:	17fffffc 	b	1143ccc <memmove+0x48>

0000000001143ce0 <memset>:
		/* Pick up the remainder with a bytewise loop.  */
		s = (char *)aligned_addr;
	}
#endif /* not PREFER_SIZE_OVER_SPEED */

	while (n--)
 1143ce0:	d2800003 	mov	x3, #0x0                   	// #0
 1143ce4:	eb03005f 	cmp	x2, x3
 1143ce8:	54000041 	b.ne	1143cf0 <memset+0x10>  // b.any
		*s++ = (char)c;

	return m;
}
 1143cec:	d65f03c0 	ret
		*s++ = (char)c;
 1143cf0:	38236801 	strb	w1, [x0, x3]
 1143cf4:	91000463 	add	x3, x3, #0x1
 1143cf8:	17fffffb 	b	1143ce4 <memset+0x4>

0000000001143cfc <strcmp>:
#endif

int _DEFUN(strcmp, (s1, s2), _CONST char *s1 _AND _CONST char *s2)
{
#if defined(PREFER_SIZE_OVER_SPEED) || defined(__OPTIMIZE_SIZE__)
	while (*s1 != '\0' && *s1 == *s2) {
 1143cfc:	d2800002 	mov	x2, #0x0                   	// #0
 1143d00:	38626803 	ldrb	w3, [x0, x2]
 1143d04:	38626824 	ldrb	w4, [x1, x2]
 1143d08:	34000083 	cbz	w3, 1143d18 <strcmp+0x1c>
 1143d0c:	91000442 	add	x2, x2, #0x1
 1143d10:	6b04007f 	cmp	w3, w4
 1143d14:	54ffff60 	b.eq	1143d00 <strcmp+0x4>  // b.none
		s1++;
		s2++;
	}
	return (*(unsigned char *)s1) - (*(unsigned char *)s2);
#endif /* not PREFER_SIZE_OVER_SPEED */
}
 1143d18:	4b040060 	sub	w0, w3, w4
 1143d1c:	d65f03c0 	ret

0000000001143d20 <strlen>:
	   precise position of the null.  */
	str = (char *)aligned_addr;

#endif /* not PREFER_SIZE_OVER_SPEED */

	while (*str)
 1143d20:	aa0003e1 	mov	x1, x0
 1143d24:	39400022 	ldrb	w2, [x1]
 1143d28:	35000062 	cbnz	w2, 1143d34 <strlen+0x14>
		str++;
	return str - start;
}
 1143d2c:	cb000020 	sub	x0, x1, x0
 1143d30:	d65f03c0 	ret
		str++;
 1143d34:	91000421 	add	x1, x1, #0x1
 1143d38:	17fffffb 	b	1143d24 <strlen+0x4>

0000000001143d3c <strncpy>:
{
#if defined(PREFER_SIZE_OVER_SPEED) || defined(__OPTIMIZE_SIZE__)
  char *dscan;
  _CONST char *sscan;

  dscan = dst0;
 1143d3c:	aa0003e3 	mov	x3, x0
  sscan = src0;
  while (count > 0)
 1143d40:	b5000042 	cbnz	x2, 1143d48 <strncpy+0xc>
  while (count-- > 0)
    *dst++ = '\0';

  return dst0;
#endif /* not PREFER_SIZE_OVER_SPEED */
}
 1143d44:	d65f03c0 	ret
      if ((*dscan++ = *sscan++) == '\0')
 1143d48:	38401424 	ldrb	w4, [x1], #1
      --count;
 1143d4c:	d1000442 	sub	x2, x2, #0x1
      if ((*dscan++ = *sscan++) == '\0')
 1143d50:	38001464 	strb	w4, [x3], #1
 1143d54:	35ffff64 	cbnz	w4, 1143d40 <strncpy+0x4>
 1143d58:	d2800001 	mov	x1, #0x0                   	// #0
 1143d5c:	14000003 	b	1143d68 <strncpy+0x2c>
    *dscan++ = '\0';
 1143d60:	3821687f 	strb	wzr, [x3, x1]
 1143d64:	91000421 	add	x1, x1, #0x1
  while (count-- > 0)
 1143d68:	eb01005f 	cmp	x2, x1
 1143d6c:	54ffffa1 	b.ne	1143d60 <strncpy+0x24>  // b.any
 1143d70:	17fffff5 	b	1143d44 <strncpy+0x8>

0000000001143d74 <strnlen>:
	_CONST char *str _AND
	size_t n)
{
  _CONST char *start = str;

  while (n-- > 0 && *str)
 1143d74:	8b010001 	add	x1, x0, x1
 1143d78:	aa0003e2 	mov	x2, x0
 1143d7c:	eb01005f 	cmp	x2, x1
 1143d80:	54000061 	b.ne	1143d8c <strnlen+0x18>  // b.any
    str++;

  return str - start;
 1143d84:	cb000040 	sub	x0, x2, x0
}
 1143d88:	d65f03c0 	ret
  while (n-- > 0 && *str)
 1143d8c:	39400043 	ldrb	w3, [x2]
 1143d90:	34ffffa3 	cbz	w3, 1143d84 <strnlen+0x10>
    str++;
 1143d94:	91000442 	add	x2, x2, #0x1
 1143d98:	17fffff9 	b	1143d7c <strnlen+0x8>

0000000001143d9c <__vsnprintf>:

int
__vsnprintf(char *bf, size_t size, const char *fmt, va_list ap,
	    bool ext)

{
 1143d9c:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
 1143da0:	910003fd 	mov	x29, sp
 1143da4:	a90153f3 	stp	x19, x20, [sp, #16]
 1143da8:	aa0103f4 	mov	x20, x1
 1143dac:	aa0003f3 	mov	x19, x0
 1143db0:	aa0303e1 	mov	x1, x3
 1143db4:	a9025bf5 	stp	x21, x22, [sp, #32]
 1143db8:	aa0203f5 	mov	x21, x2
	int retval;
	char *p;

	p = bf + size;
 1143dbc:	8b140016 	add	x22, x0, x20
	retval = kprintf(fmt, TOBUFONLY, &p, bf, ap, ext);
 1143dc0:	d2800402 	mov	x2, #0x20                  	// #32
 1143dc4:	910103e0 	add	x0, sp, #0x40
{
 1143dc8:	f9001bf7 	str	x23, [sp, #48]
 1143dcc:	12001c97 	and	w23, w4, #0xff
	p = bf + size;
 1143dd0:	f90037f6 	str	x22, [sp, #104]
	retval = kprintf(fmt, TOBUFONLY, &p, bf, ap, ext);
 1143dd4:	97fefd6f 	bl	1103390 <memcpy>
 1143dd8:	aa0003e3 	mov	x3, x0
 1143ddc:	2a1703e4 	mov	w4, w23
 1143de0:	aa1303e2 	mov	x2, x19
 1143de4:	9101a3e1 	add	x1, sp, #0x68
 1143de8:	aa1503e0 	mov	x0, x21
 1143dec:	94000039 	bl	1143ed0 <kprintf.constprop.0>
	if (bf && size > 0) {
 1143df0:	f100027f 	cmp	x19, #0x0
 1143df4:	fa401a84 	ccmp	x20, #0x0, #0x4, ne  // ne = any
 1143df8:	540000a0 	b.eq	1143e0c <__vsnprintf+0x70>  // b.none
		/* nul terminate */
		if (size <= (size_t)retval)
 1143dfc:	93407c01 	sxtw	x1, w0
 1143e00:	eb20c29f 	cmp	x20, w0, sxtw
 1143e04:	540000e8 	b.hi	1143e20 <__vsnprintf+0x84>  // b.pmore
			bf[size - 1] = '\0';
 1143e08:	381ff2df 	sturb	wzr, [x22, #-1]
		else
			bf[retval] = '\0';
	}
	return retval;
}
 1143e0c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1143e10:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1143e14:	f9401bf7 	ldr	x23, [sp, #48]
 1143e18:	a8c77bfd 	ldp	x29, x30, [sp], #112
 1143e1c:	d65f03c0 	ret
			bf[retval] = '\0';
 1143e20:	38216a7f 	strb	wzr, [x19, x1]
	return retval;
 1143e24:	17fffffa 	b	1143e0c <__vsnprintf+0x70>

0000000001143e28 <vsnprintk>:
{
 1143e28:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
	return __vsnprintf(bf, size, fmt, ap, true);
 1143e2c:	9100c3e4 	add	x4, sp, #0x30
{
 1143e30:	910003fd 	mov	x29, sp
 1143e34:	a90153f3 	stp	x19, x20, [sp, #16]
 1143e38:	aa0003f3 	mov	x19, x0
 1143e3c:	aa0103f4 	mov	x20, x1
	return __vsnprintf(bf, size, fmt, ap, true);
 1143e40:	aa0403e0 	mov	x0, x4
{
 1143e44:	aa0303e1 	mov	x1, x3
 1143e48:	f90013f5 	str	x21, [sp, #32]
 1143e4c:	aa0203f5 	mov	x21, x2
	return __vsnprintf(bf, size, fmt, ap, true);
 1143e50:	d2800402 	mov	x2, #0x20                  	// #32
 1143e54:	97fefd4f 	bl	1103390 <memcpy>
 1143e58:	aa1503e2 	mov	x2, x21
 1143e5c:	aa0003e3 	mov	x3, x0
 1143e60:	aa1403e1 	mov	x1, x20
 1143e64:	aa1303e0 	mov	x0, x19
 1143e68:	52800024 	mov	w4, #0x1                   	// #1
 1143e6c:	97ffffcc 	bl	1143d9c <__vsnprintf>
}
 1143e70:	a94153f3 	ldp	x19, x20, [sp, #16]
 1143e74:	f94013f5 	ldr	x21, [sp, #32]
 1143e78:	a8c57bfd 	ldp	x29, x30, [sp], #80
 1143e7c:	d65f03c0 	ret

0000000001143e80 <snprintk>:
{
 1143e80:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
 1143e84:	910003fd 	mov	x29, sp
 1143e88:	a90593e3 	stp	x3, x4, [sp, #88]
	va_start(ap, fmt);
 1143e8c:	910203e3 	add	x3, sp, #0x80
 1143e90:	a9030fe3 	stp	x3, x3, [sp, #48]
 1143e94:	910143e3 	add	x3, sp, #0x50
 1143e98:	f90023e3 	str	x3, [sp, #64]
 1143e9c:	128004e3 	mov	w3, #0xffffffd8            	// #-40
 1143ea0:	b9004be3 	str	w3, [sp, #72]
	retval = vsnprintk(bf, size, fmt, ap);
 1143ea4:	910043e3 	add	x3, sp, #0x10
	va_start(ap, fmt);
 1143ea8:	b9004fff 	str	wzr, [sp, #76]
{
 1143eac:	a9069be5 	stp	x5, x6, [sp, #104]
	retval = vsnprintk(bf, size, fmt, ap);
 1143eb0:	a94317e4 	ldp	x4, x5, [sp, #48]
 1143eb4:	a90117e4 	stp	x4, x5, [sp, #16]
 1143eb8:	a94417e4 	ldp	x4, x5, [sp, #64]
 1143ebc:	a90217e4 	stp	x4, x5, [sp, #32]
{
 1143ec0:	f9003fe7 	str	x7, [sp, #120]
	retval = vsnprintk(bf, size, fmt, ap);
 1143ec4:	97ffffd9 	bl	1143e28 <vsnprintk>
}
 1143ec8:	a8c87bfd 	ldp	x29, x30, [sp], #128
 1143ecc:	d65f03c0 	ret

0000000001143ed0 <kprintf.constprop.0>:

/*
 * Guts of kernel printf.  Note, we already expect to be in a mutex!
 */
static int
kprintf(const char *fmt0, int oflags, void *vp, char *sbuf, va_list ap,
 1143ed0:	d103c3ff 	sub	sp, sp, #0xf0
 1143ed4:	aa0103e8 	mov	x8, x1
 1143ed8:	a9037bfd 	stp	x29, x30, [sp, #48]
 1143edc:	9100c3fd 	add	x29, sp, #0x30
 1143ee0:	a90453f3 	stp	x19, x20, [sp, #64]
 1143ee4:	b9401874 	ldr	w20, [x3, #24]
 1143ee8:	a9055bf5 	stp	x21, x22, [sp, #80]
 1143eec:	aa0203f6 	mov	x22, x2
 1143ef0:	a90663f7 	stp	x23, x24, [sp, #96]
 1143ef4:	a9076bf9 	stp	x25, x26, [sp, #112]
 1143ef8:	a90873fb 	stp	x27, x28, [sp, #128]
 1143efc:	aa0003fb 	mov	x27, x0
 1143f00:	12001c80 	and	w0, w4, #0xff
 1143f04:	b900a3e0 	str	w0, [sp, #160]
 1143f08:	a9406873 	ldp	x19, x26, [x3]
	int size;		/* size of converted field or string */
	const char *xdigs;	/* digits for [xX] conversion */
	char bf[KPRINTF_BUFSIZE]; /* space for %c, %[diouxX], possibly %pUl */
	char *tailp;		/* tail pointer for snprintk */

	if (oflags == TOBUFONLY && (vp != NULL))
 1143f0c:	b40004c1 	cbz	x1, 1143fa4 <kprintf.constprop.0+0xd4>
		tailp = *(char **)vp;
 1143f10:	f9400038 	ldr	x24, [x1]
					cp = __UNCONST("bug in kprintf: bad base");
					size = strlen(cp);
					goto skipsize;
				}
			}
			size = bf + KPRINTF_BUFSIZE - cp;
 1143f14:	910323ec 	add	x12, sp, #0xc8
 1143f18:	d0000060 	adrp	x0, 1151000 <small_prime+0x168>
	xdigs = NULL;		/* XXX: shut up gcc warning */
 1143f1c:	d2800017 	mov	x23, #0x0                   	// #0
 1143f20:	9104e000 	add	x0, x0, #0x138
	ret = 0;
 1143f24:	52800019 	mov	w25, #0x0                   	// #0
 1143f28:	f9004be0 	str	x0, [sp, #144]
		for (; *fmt != '%' && *fmt; fmt++) {
 1143f2c:	39400360 	ldrb	w0, [x27]
 1143f30:	7100941f 	cmp	w0, #0x25
 1143f34:	7a401804 	ccmp	w0, #0x0, #0x4, ne  // ne = any
 1143f38:	540003a1 	b.ne	1143fac <kprintf.constprop.0+0xdc>  // b.any
		if (*fmt == 0)
 1143f3c:	34005220 	cbz	w0, 1144980 <kprintf.constprop.0+0xab0>
		prec = -1;
 1143f40:	12800005 	mov	w5, #0xffffffff            	// #-1
 1143f44:	d0000066 	adrp	x6, 1151000 <small_prime+0x168>
		fmt++;		/* skip over '%' */
 1143f48:	9100077b 	add	x27, x27, #0x1
 1143f4c:	2a1403e4 	mov	w4, w20
 1143f50:	aa1303e3 	mov	x3, x19
 1143f54:	910550c6 	add	x6, x6, #0x154
				prec = n < 0 ? -1 : n;
 1143f58:	2a0503ee 	mov	w14, w5
		sign = '\0';
 1143f5c:	52800001 	mov	w1, #0x0                   	// #0
		width = 0;
 1143f60:	5280000a 	mov	w10, #0x0                   	// #0
		flags = 0;
 1143f64:	52800015 	mov	w21, #0x0                   	// #0
				n = 10 * n + to_digit(ch);
 1143f68:	5280014d 	mov	w13, #0xa                   	// #10
				sign = ' ';
 1143f6c:	5280040f 	mov	w15, #0x20                  	// #32
rflag:		ch = *fmt++;
 1143f70:	3840177c 	ldrb	w28, [x27], #1
reswitch:	switch (ch) {
 1143f74:	7100e79f 	cmp	w28, #0x39
 1143f78:	5400052c 	b.gt	114401c <kprintf.constprop.0+0x14c>
 1143f7c:	71007f9f 	cmp	w28, #0x1f
 1143f80:	54004fed 	b.le	114497c <kprintf.constprop.0+0xaac>
 1143f84:	51008380 	sub	w0, w28, #0x20
 1143f88:	7100641f 	cmp	w0, #0x19
 1143f8c:	540004e8 	b.hi	1144028 <kprintf.constprop.0+0x158>  // b.pmore
 1143f90:	f9404be2 	ldr	x2, [sp, #144]
 1143f94:	38604840 	ldrb	w0, [x2, w0, uxtw]
 1143f98:	10000062 	adr	x2, 1143fa4 <kprintf.constprop.0+0xd4>
 1143f9c:	8b208840 	add	x0, x2, w0, sxtb #2
 1143fa0:	d61f0000 	br	x0
		tailp = NULL;
 1143fa4:	d2800018 	mov	x24, #0x0                   	// #0
 1143fa8:	17ffffdb 	b	1143f14 <kprintf.constprop.0+0x44>
			ret++;
 1143fac:	11000739 	add	w25, w25, #0x1
			KPRINTF_PUTCHAR(*fmt);
 1143fb0:	b40000b6 	cbz	x22, 1143fc4 <kprintf.constprop.0+0xf4>
 1143fb4:	f100011f 	cmp	x8, #0x0
 1143fb8:	fa5812c0 	ccmp	x22, x24, #0x0, ne  // ne = any
 1143fbc:	54000042 	b.cs	1143fc4 <kprintf.constprop.0+0xf4>  // b.hs, b.nlast
 1143fc0:	380016c0 	strb	w0, [x22], #1
		for (; *fmt != '%' && *fmt; fmt++) {
 1143fc4:	9100077b 	add	x27, x27, #0x1
 1143fc8:	17ffffd9 	b	1143f2c <kprintf.constprop.0+0x5c>
			sign = '+';
 1143fcc:	52800561 	mov	w1, #0x2b                  	// #43
 1143fd0:	17ffffe8 	b	1143f70 <kprintf.constprop.0+0xa0>
 1143fd4:	786058c0 	ldrh	w0, [x6, w0, uxtw #1]
 1143fd8:	10000062 	adr	x2, 1143fe4 <kprintf.constprop.0+0x114>
 1143fdc:	8b20a840 	add	x0, x2, w0, sxth #2
 1143fe0:	d61f0000 	br	x0
			xdigs = hexdigits;
 1143fe4:	d00000b7 	adrp	x23, 1159000 <Worder+0x2854>
 1143fe8:	9134e2f7 	add	x23, x23, #0xd38
hex:			_uquad = UARG();
 1143fec:	363844f5 	tbz	w21, #7, 1144888 <kprintf.constprop.0+0x9b8>
 1143ff0:	37f84624 	tbnz	w4, #31, 11448b4 <kprintf.constprop.0+0x9e4>
 1143ff4:	91003c73 	add	x19, x3, #0xf
 1143ff8:	2a0403f4 	mov	w20, w4
 1143ffc:	927df273 	and	x19, x19, #0xfffffffffffffff8
 1144000:	f9400062 	ldr	x2, [x3]
			if (flags & ALT && _uquad != 0)
 1144004:	36003455 	tbz	w21, #0, 114468c <kprintf.constprop.0+0x7bc>
 1144008:	b4003422 	cbz	x2, 114468c <kprintf.constprop.0+0x7bc>
				flags |= HEXPREFIX;
 114400c:	321f02b5 	orr	w21, w21, #0x2
			base = HEX;
 1144010:	52800040 	mov	w0, #0x2                   	// #2
nosign:			sign = '\0';
 1144014:	52800001 	mov	w1, #0x0                   	// #0
 1144018:	14000078 	b	11441f8 <kprintf.constprop.0+0x328>
reswitch:	switch (ch) {
 114401c:	51011380 	sub	w0, w28, #0x44
 1144020:	7100d81f 	cmp	w0, #0x36
 1144024:	54fffd89 	b.ls	1143fd4 <kprintf.constprop.0+0x104>  // b.plast
			/* pretend it was %c with argument ch */
			cp = bf;
			*cp = ch;
			size = 1;
			sign = '\0';
			break;
 1144028:	2a0403f4 	mov	w20, w4
 114402c:	aa0303f3 	mov	x19, x3
			*cp = ch;
 1144030:	390323fc 	strb	w28, [sp, #200]
			break;
 1144034:	14000058 	b	1144194 <kprintf.constprop.0+0x2c4>
				sign = ' ';
 1144038:	7100003f 	cmp	w1, #0x0
 114403c:	1a8f1021 	csel	w1, w1, w15, ne  // ne = any
 1144040:	17ffffcc 	b	1143f70 <kprintf.constprop.0+0xa0>
			flags |= ALT;
 1144044:	320002b5 	orr	w21, w21, #0x1
			goto rflag;
 1144048:	17ffffca 	b	1143f70 <kprintf.constprop.0+0xa0>
			if ((width = va_arg(ap, int)) >= 0)
 114404c:	37f80124 	tbnz	w4, #31, 1144070 <kprintf.constprop.0+0x1a0>
 1144050:	91002c62 	add	x2, x3, #0xb
 1144054:	aa0303e0 	mov	x0, x3
 1144058:	927df043 	and	x3, x2, #0xfffffffffffffff8
 114405c:	b940000a 	ldr	w10, [x0]
 1144060:	36fff88a 	tbz	w10, #31, 1143f70 <kprintf.constprop.0+0xa0>
			width = -width;
 1144064:	4b0a03ea 	neg	w10, w10
			flags |= LADJUST;
 1144068:	321e02b5 	orr	w21, w21, #0x4
			goto rflag;
 114406c:	17ffffc1 	b	1143f70 <kprintf.constprop.0+0xa0>
			if ((width = va_arg(ap, int)) >= 0)
 1144070:	11002082 	add	w2, w4, #0x8
 1144074:	7100005f 	cmp	w2, #0x0
 1144078:	540000cd 	b.le	1144090 <kprintf.constprop.0+0x1c0>
 114407c:	91002c67 	add	x7, x3, #0xb
 1144080:	aa0303e0 	mov	x0, x3
 1144084:	2a0203e4 	mov	w4, w2
 1144088:	927df0e3 	and	x3, x7, #0xfffffffffffffff8
 114408c:	17fffff4 	b	114405c <kprintf.constprop.0+0x18c>
 1144090:	8b24c340 	add	x0, x26, w4, sxtw
 1144094:	2a0203e4 	mov	w4, w2
 1144098:	17fffff1 	b	114405c <kprintf.constprop.0+0x18c>
			if ((ch = *fmt++) == '*') {
 114409c:	3840177c 	ldrb	w28, [x27], #1
 11440a0:	7100ab9f 	cmp	w28, #0x2a
 11440a4:	54000341 	b.ne	114410c <kprintf.constprop.0+0x23c>  // b.any
				n = va_arg(ap, int);
 11440a8:	37f80144 	tbnz	w4, #31, 11440d0 <kprintf.constprop.0+0x200>
 11440ac:	91002c62 	add	x2, x3, #0xb
 11440b0:	2a0403e7 	mov	w7, w4
 11440b4:	927df042 	and	x2, x2, #0xfffffffffffffff8
				prec = n < 0 ? -1 : n;
 11440b8:	b9400065 	ldr	w5, [x3]
				goto rflag;
 11440bc:	2a0703e4 	mov	w4, w7
 11440c0:	aa0203e3 	mov	x3, x2
				prec = n < 0 ? -1 : n;
 11440c4:	710000bf 	cmp	w5, #0x0
 11440c8:	1a8ea0a5 	csel	w5, w5, w14, ge  // ge = tcont
				goto rflag;
 11440cc:	17ffffa9 	b	1143f70 <kprintf.constprop.0+0xa0>
				n = va_arg(ap, int);
 11440d0:	11002087 	add	w7, w4, #0x8
 11440d4:	710000ff 	cmp	w7, #0x0
 11440d8:	5400008d 	b.le	11440e8 <kprintf.constprop.0+0x218>
 11440dc:	91002c62 	add	x2, x3, #0xb
 11440e0:	927df042 	and	x2, x2, #0xfffffffffffffff8
 11440e4:	17fffff5 	b	11440b8 <kprintf.constprop.0+0x1e8>
 11440e8:	aa0303e2 	mov	x2, x3
 11440ec:	8b24c343 	add	x3, x26, w4, sxtw
 11440f0:	17fffff2 	b	11440b8 <kprintf.constprop.0+0x1e8>
				n = 10 * n + to_digit(ch);
 11440f4:	1b0d00a5 	madd	w5, w5, w13, w0
				ch = *fmt++;
 11440f8:	3840177c 	ldrb	w28, [x27], #1
			while (is_digit(ch)) {
 11440fc:	5100c380 	sub	w0, w28, #0x30
 1144100:	7100241f 	cmp	w0, #0x9
 1144104:	54ffff89 	b.ls	11440f4 <kprintf.constprop.0+0x224>  // b.plast
 1144108:	17ffff9b 	b	1143f74 <kprintf.constprop.0+0xa4>
			n = 0;
 114410c:	52800005 	mov	w5, #0x0                   	// #0
 1144110:	17fffffb 	b	11440fc <kprintf.constprop.0+0x22c>
			flags |= ZEROPAD;
 1144114:	321602b5 	orr	w21, w21, #0x400
			goto rflag;
 1144118:	17ffff96 	b	1143f70 <kprintf.constprop.0+0xa0>
reswitch:	switch (ch) {
 114411c:	5280000a 	mov	w10, #0x0                   	// #0
				n = 10 * n + to_digit(ch);
 1144120:	5100c39c 	sub	w28, w28, #0x30
 1144124:	1b0d714a 	madd	w10, w10, w13, w28
				ch = *fmt++;
 1144128:	3840177c 	ldrb	w28, [x27], #1
			} while (is_digit(ch));
 114412c:	5100c380 	sub	w0, w28, #0x30
 1144130:	7100241f 	cmp	w0, #0x9
 1144134:	54ffff69 	b.ls	1144120 <kprintf.constprop.0+0x250>  // b.plast
 1144138:	17ffff8f 	b	1143f74 <kprintf.constprop.0+0xa4>
			flags |= SHORTINT;
 114413c:	321a02b5 	orr	w21, w21, #0x40
			goto rflag;
 1144140:	17ffff8c 	b	1143f70 <kprintf.constprop.0+0xa0>
			flags |= MAXINT;
 1144144:	321902b5 	orr	w21, w21, #0x80
			goto rflag;
 1144148:	17ffff8a 	b	1143f70 <kprintf.constprop.0+0xa0>
			if (*fmt == 'l') {
 114414c:	39400360 	ldrb	w0, [x27]
 1144150:	7101b01f 	cmp	w0, #0x6c
 1144154:	54000081 	b.ne	1144164 <kprintf.constprop.0+0x294>  // b.any
 1144158:	9100077b 	add	x27, x27, #0x1
			flags |= QUADINT;
 114415c:	321b02b5 	orr	w21, w21, #0x20
			goto rflag;
 1144160:	17ffff84 	b	1143f70 <kprintf.constprop.0+0xa0>
				flags |= LONGINT;
 1144164:	321c02b5 	orr	w21, w21, #0x10
 1144168:	17ffff82 	b	1143f70 <kprintf.constprop.0+0xa0>
			flags |= PTRINT;
 114416c:	321802b5 	orr	w21, w21, #0x100
			goto rflag;
 1144170:	17ffff80 	b	1143f70 <kprintf.constprop.0+0xa0>
			flags |= SIZEINT;
 1144174:	321702b5 	orr	w21, w21, #0x200
			goto rflag;
 1144178:	17ffff7e 	b	1143f70 <kprintf.constprop.0+0xa0>
			*(cp = bf) = va_arg(ap, int);
 114417c:	37f80164 	tbnz	w4, #31, 11441a8 <kprintf.constprop.0+0x2d8>
 1144180:	91002c73 	add	x19, x3, #0xb
 1144184:	2a0403f4 	mov	w20, w4
 1144188:	927df273 	and	x19, x19, #0xfffffffffffffff8
 114418c:	b9400060 	ldr	w0, [x3]
 1144190:	390323e0 	strb	w0, [sp, #200]
			cp = bf;
 1144194:	910323e3 	add	x3, sp, #0xc8
			size = 1;
 1144198:	52800025 	mov	w5, #0x1                   	// #1
		dprec = 0;
 114419c:	52800006 	mov	w6, #0x0                   	// #0
			sign = '\0';
 11441a0:	52800001 	mov	w1, #0x0                   	// #0
			break;
 11441a4:	140000fa 	b	114458c <kprintf.constprop.0+0x6bc>
			*(cp = bf) = va_arg(ap, int);
 11441a8:	11002094 	add	w20, w4, #0x8
 11441ac:	7100029f 	cmp	w20, #0x0
 11441b0:	5400008d 	b.le	11441c0 <kprintf.constprop.0+0x2f0>
 11441b4:	91002c73 	add	x19, x3, #0xb
 11441b8:	927df273 	and	x19, x19, #0xfffffffffffffff8
 11441bc:	17fffff4 	b	114418c <kprintf.constprop.0+0x2bc>
 11441c0:	aa0303f3 	mov	x19, x3
 11441c4:	8b24c343 	add	x3, x26, w4, sxtw
 11441c8:	17fffff1 	b	114418c <kprintf.constprop.0+0x2bc>
			flags |= LONGINT;
 11441cc:	321c02b5 	orr	w21, w21, #0x10
			_uquad = SARG();
 11441d0:	363802f5 	tbz	w21, #7, 114422c <kprintf.constprop.0+0x35c>
 11441d4:	37f80424 	tbnz	w4, #31, 1144258 <kprintf.constprop.0+0x388>
 11441d8:	91003c73 	add	x19, x3, #0xf
 11441dc:	2a0403f4 	mov	w20, w4
 11441e0:	927df273 	and	x19, x19, #0xfffffffffffffff8
 11441e4:	f9400062 	ldr	x2, [x3]
			if ((int64_t)_uquad < 0) {
 11441e8:	b6f82de2 	tbz	x2, #63, 11447a4 <kprintf.constprop.0+0x8d4>
				_uquad = -_uquad;
 11441ec:	cb0203e2 	neg	x2, x2
			base = DEC;
 11441f0:	52800020 	mov	w0, #0x1                   	// #1
				sign = '-';
 11441f4:	528005a1 	mov	w1, #0x2d                  	// #45
number:			if ((dprec = prec) >= 0)
 11441f8:	310004bf 	cmn	w5, #0x1
 11441fc:	54003a01 	b.ne	114493c <kprintf.constprop.0+0xa6c>  // b.any
				switch (base) {
 1144200:	7100041f 	cmp	w0, #0x1
 1144204:	54002d40 	b.eq	11447ac <kprintf.constprop.0+0x8dc>  // b.none
 1144208:	7100081f 	cmp	w0, #0x2
 114420c:	54000ea1 	b.ne	11443e0 <kprintf.constprop.0+0x510>  // b.any
			cp = bf + KPRINTF_BUFSIZE;
 1144210:	91009583 	add	x3, x12, #0x25
						*--cp = xdigs[_uquad & 15];
 1144214:	92400c40 	and	x0, x2, #0xf
						_uquad >>= 4;
 1144218:	d344fc42 	lsr	x2, x2, #4
						*--cp = xdigs[_uquad & 15];
 114421c:	38606ae0 	ldrb	w0, [x23, x0]
 1144220:	381ffc60 	strb	w0, [x3, #-1]!
					} while (_uquad);
 1144224:	b5ffff82 	cbnz	x2, 1144214 <kprintf.constprop.0+0x344>
 1144228:	1400007b 	b	1144414 <kprintf.constprop.0+0x544>
			_uquad = SARG();
 114422c:	3747fd55 	tbnz	w21, #8, 11441d4 <kprintf.constprop.0+0x304>
 1144230:	374ffd35 	tbnz	w21, #9, 11441d4 <kprintf.constprop.0+0x304>
 1144234:	372ffd15 	tbnz	w21, #5, 11441d4 <kprintf.constprop.0+0x304>
 1144238:	3727fcf5 	tbnz	w21, #4, 11441d4 <kprintf.constprop.0+0x304>
 114423c:	36300335 	tbz	w21, #6, 11442a0 <kprintf.constprop.0+0x3d0>
 1144240:	37f801e4 	tbnz	w4, #31, 114427c <kprintf.constprop.0+0x3ac>
 1144244:	91002c73 	add	x19, x3, #0xb
 1144248:	2a0403f4 	mov	w20, w4
 114424c:	927df273 	and	x19, x19, #0xfffffffffffffff8
 1144250:	79800062 	ldrsh	x2, [x3]
 1144254:	17ffffe5 	b	11441e8 <kprintf.constprop.0+0x318>
 1144258:	11002094 	add	w20, w4, #0x8
 114425c:	7100029f 	cmp	w20, #0x0
 1144260:	5400008d 	b.le	1144270 <kprintf.constprop.0+0x3a0>
 1144264:	91003c73 	add	x19, x3, #0xf
 1144268:	927df273 	and	x19, x19, #0xfffffffffffffff8
 114426c:	17ffffde 	b	11441e4 <kprintf.constprop.0+0x314>
 1144270:	aa0303f3 	mov	x19, x3
 1144274:	8b24c343 	add	x3, x26, w4, sxtw
 1144278:	17ffffdb 	b	11441e4 <kprintf.constprop.0+0x314>
 114427c:	11002094 	add	w20, w4, #0x8
 1144280:	7100029f 	cmp	w20, #0x0
 1144284:	5400008d 	b.le	1144294 <kprintf.constprop.0+0x3c4>
 1144288:	91002c73 	add	x19, x3, #0xb
 114428c:	927df273 	and	x19, x19, #0xfffffffffffffff8
 1144290:	17fffff0 	b	1144250 <kprintf.constprop.0+0x380>
 1144294:	aa0303f3 	mov	x19, x3
 1144298:	8b24c343 	add	x3, x26, w4, sxtw
 114429c:	17ffffed 	b	1144250 <kprintf.constprop.0+0x380>
 11442a0:	37f800c4 	tbnz	w4, #31, 11442b8 <kprintf.constprop.0+0x3e8>
 11442a4:	91002c73 	add	x19, x3, #0xb
 11442a8:	2a0403f4 	mov	w20, w4
 11442ac:	927df273 	and	x19, x19, #0xfffffffffffffff8
 11442b0:	b9800062 	ldrsw	x2, [x3]
 11442b4:	17ffffcd 	b	11441e8 <kprintf.constprop.0+0x318>
 11442b8:	11002094 	add	w20, w4, #0x8
 11442bc:	7100029f 	cmp	w20, #0x0
 11442c0:	5400008d 	b.le	11442d0 <kprintf.constprop.0+0x400>
 11442c4:	91002c73 	add	x19, x3, #0xb
 11442c8:	927df273 	and	x19, x19, #0xfffffffffffffff8
 11442cc:	17fffff9 	b	11442b0 <kprintf.constprop.0+0x3e0>
 11442d0:	aa0303f3 	mov	x19, x3
 11442d4:	8b24c343 	add	x3, x26, w4, sxtw
 11442d8:	17fffff6 	b	11442b0 <kprintf.constprop.0+0x3e0>
			if (flags & MAXINT)
 11442dc:	36380135 	tbz	w21, #7, 1144300 <kprintf.constprop.0+0x430>
				*va_arg(ap, long *) = ret;
 11442e0:	37f80284 	tbnz	w4, #31, 1144330 <kprintf.constprop.0+0x460>
 11442e4:	91003c73 	add	x19, x3, #0xf
 11442e8:	2a0403f4 	mov	w20, w4
 11442ec:	927df273 	and	x19, x19, #0xfffffffffffffff8
 11442f0:	f9400060 	ldr	x0, [x3]
 11442f4:	93407f21 	sxtw	x1, w25
 11442f8:	f9000001 	str	x1, [x0]
 11442fc:	17ffff0c 	b	1143f2c <kprintf.constprop.0+0x5c>
			else if (flags & PTRINT)
 1144300:	3747ff15 	tbnz	w21, #8, 11442e0 <kprintf.constprop.0+0x410>
			else if (flags & SIZEINT)
 1144304:	374ffef5 	tbnz	w21, #9, 11442e0 <kprintf.constprop.0+0x410>
			else if (flags & QUADINT)
 1144308:	372ffed5 	tbnz	w21, #5, 11442e0 <kprintf.constprop.0+0x410>
			else if (flags & LONGINT)
 114430c:	3727feb5 	tbnz	w21, #4, 11442e0 <kprintf.constprop.0+0x410>
			else if (flags & SHORTINT)
 1144310:	36300355 	tbz	w21, #6, 1144378 <kprintf.constprop.0+0x4a8>
				*va_arg(ap, short *) = ret;
 1144314:	37f80204 	tbnz	w4, #31, 1144354 <kprintf.constprop.0+0x484>
 1144318:	91003c73 	add	x19, x3, #0xf
 114431c:	2a0403f4 	mov	w20, w4
 1144320:	927df273 	and	x19, x19, #0xfffffffffffffff8
 1144324:	f9400060 	ldr	x0, [x3]
 1144328:	79000019 	strh	w25, [x0]
 114432c:	17ffff00 	b	1143f2c <kprintf.constprop.0+0x5c>
				*va_arg(ap, long *) = ret;
 1144330:	11002094 	add	w20, w4, #0x8
 1144334:	7100029f 	cmp	w20, #0x0
 1144338:	5400008d 	b.le	1144348 <kprintf.constprop.0+0x478>
 114433c:	91003c73 	add	x19, x3, #0xf
 1144340:	927df273 	and	x19, x19, #0xfffffffffffffff8
 1144344:	17ffffeb 	b	11442f0 <kprintf.constprop.0+0x420>
 1144348:	aa0303f3 	mov	x19, x3
 114434c:	8b24c343 	add	x3, x26, w4, sxtw
 1144350:	17ffffe8 	b	11442f0 <kprintf.constprop.0+0x420>
				*va_arg(ap, short *) = ret;
 1144354:	11002094 	add	w20, w4, #0x8
 1144358:	7100029f 	cmp	w20, #0x0
 114435c:	5400008d 	b.le	114436c <kprintf.constprop.0+0x49c>
 1144360:	91003c73 	add	x19, x3, #0xf
 1144364:	927df273 	and	x19, x19, #0xfffffffffffffff8
 1144368:	17ffffef 	b	1144324 <kprintf.constprop.0+0x454>
 114436c:	aa0303f3 	mov	x19, x3
 1144370:	8b24c343 	add	x3, x26, w4, sxtw
 1144374:	17ffffec 	b	1144324 <kprintf.constprop.0+0x454>
				*va_arg(ap, int *) = ret;
 1144378:	37f800e4 	tbnz	w4, #31, 1144394 <kprintf.constprop.0+0x4c4>
 114437c:	91003c73 	add	x19, x3, #0xf
 1144380:	2a0403f4 	mov	w20, w4
 1144384:	927df273 	and	x19, x19, #0xfffffffffffffff8
 1144388:	f9400060 	ldr	x0, [x3]
 114438c:	b9000019 	str	w25, [x0]
 1144390:	17fffee7 	b	1143f2c <kprintf.constprop.0+0x5c>
 1144394:	11002094 	add	w20, w4, #0x8
 1144398:	7100029f 	cmp	w20, #0x0
 114439c:	5400008d 	b.le	11443ac <kprintf.constprop.0+0x4dc>
 11443a0:	91003c73 	add	x19, x3, #0xf
 11443a4:	927df273 	and	x19, x19, #0xfffffffffffffff8
 11443a8:	17fffff8 	b	1144388 <kprintf.constprop.0+0x4b8>
 11443ac:	aa0303f3 	mov	x19, x3
 11443b0:	8b24c343 	add	x3, x26, w4, sxtw
 11443b4:	17fffff5 	b	1144388 <kprintf.constprop.0+0x4b8>
			flags |= LONGINT;
 11443b8:	321c02b5 	orr	w21, w21, #0x10
			_uquad = UARG();
 11443bc:	36380355 	tbz	w21, #7, 1144424 <kprintf.constprop.0+0x554>
 11443c0:	37f80484 	tbnz	w4, #31, 1144450 <kprintf.constprop.0+0x580>
 11443c4:	91003c73 	add	x19, x3, #0xf
 11443c8:	2a0403f4 	mov	w20, w4
 11443cc:	927df273 	and	x19, x19, #0xfffffffffffffff8
 11443d0:	f9400062 	ldr	x2, [x3]
number:			if ((dprec = prec) >= 0)
 11443d4:	310004bf 	cmn	w5, #0x1
 11443d8:	52800001 	mov	w1, #0x0                   	// #0
 11443dc:	54002ae1 	b.ne	1144938 <kprintf.constprop.0+0xa68>  // b.any
			cp = bf + KPRINTF_BUFSIZE;
 11443e0:	91009583 	add	x3, x12, #0x25
						*--cp = to_char(_uquad & 7);
 11443e4:	12000840 	and	w0, w2, #0x7
 11443e8:	aa0303e4 	mov	x4, x3
 11443ec:	1100c000 	add	w0, w0, #0x30
 11443f0:	381ffc60 	strb	w0, [x3, #-1]!
						_uquad >>= 3;
 11443f4:	d343fc42 	lsr	x2, x2, #3
					} while (_uquad);
 11443f8:	b5ffff62 	cbnz	x2, 11443e4 <kprintf.constprop.0+0x514>
					if (flags & ALT && *cp != '0')
 11443fc:	360000d5 	tbz	w21, #0, 1144414 <kprintf.constprop.0+0x544>
 1144400:	7100c01f 	cmp	w0, #0x30
 1144404:	54000080 	b.eq	1144414 <kprintf.constprop.0+0x544>  // b.none
						*--cp = '0';
 1144408:	52800600 	mov	w0, #0x30                  	// #48
 114440c:	381ff060 	sturb	w0, [x3, #-1]
 1144410:	d1000883 	sub	x3, x4, #0x2
			size = bf + KPRINTF_BUFSIZE - cp;
 1144414:	91009580 	add	x0, x12, #0x25
 1144418:	2a0503e6 	mov	w6, w5
 114441c:	4b030005 	sub	w5, w0, w3
 1144420:	1400005b 	b	114458c <kprintf.constprop.0+0x6bc>
			_uquad = UARG();
 1144424:	3747fcf5 	tbnz	w21, #8, 11443c0 <kprintf.constprop.0+0x4f0>
 1144428:	374ffcd5 	tbnz	w21, #9, 11443c0 <kprintf.constprop.0+0x4f0>
 114442c:	372ffcb5 	tbnz	w21, #5, 11443c0 <kprintf.constprop.0+0x4f0>
 1144430:	3727fc95 	tbnz	w21, #4, 11443c0 <kprintf.constprop.0+0x4f0>
 1144434:	36300335 	tbz	w21, #6, 1144498 <kprintf.constprop.0+0x5c8>
 1144438:	37f801e4 	tbnz	w4, #31, 1144474 <kprintf.constprop.0+0x5a4>
 114443c:	91002c73 	add	x19, x3, #0xb
 1144440:	2a0403f4 	mov	w20, w4
 1144444:	927df273 	and	x19, x19, #0xfffffffffffffff8
 1144448:	79400062 	ldrh	w2, [x3]
 114444c:	17ffffe2 	b	11443d4 <kprintf.constprop.0+0x504>
 1144450:	11002094 	add	w20, w4, #0x8
 1144454:	7100029f 	cmp	w20, #0x0
 1144458:	5400008d 	b.le	1144468 <kprintf.constprop.0+0x598>
 114445c:	91003c73 	add	x19, x3, #0xf
 1144460:	927df273 	and	x19, x19, #0xfffffffffffffff8
 1144464:	17ffffdb 	b	11443d0 <kprintf.constprop.0+0x500>
 1144468:	aa0303f3 	mov	x19, x3
 114446c:	8b24c343 	add	x3, x26, w4, sxtw
 1144470:	17ffffd8 	b	11443d0 <kprintf.constprop.0+0x500>
 1144474:	11002094 	add	w20, w4, #0x8
 1144478:	7100029f 	cmp	w20, #0x0
 114447c:	5400008d 	b.le	114448c <kprintf.constprop.0+0x5bc>
 1144480:	91002c73 	add	x19, x3, #0xb
 1144484:	927df273 	and	x19, x19, #0xfffffffffffffff8
 1144488:	17fffff0 	b	1144448 <kprintf.constprop.0+0x578>
 114448c:	aa0303f3 	mov	x19, x3
 1144490:	8b24c343 	add	x3, x26, w4, sxtw
 1144494:	17ffffed 	b	1144448 <kprintf.constprop.0+0x578>
 1144498:	37f800c4 	tbnz	w4, #31, 11444b0 <kprintf.constprop.0+0x5e0>
 114449c:	91002c73 	add	x19, x3, #0xb
 11444a0:	2a0403f4 	mov	w20, w4
 11444a4:	927df273 	and	x19, x19, #0xfffffffffffffff8
 11444a8:	b9400062 	ldr	w2, [x3]
 11444ac:	17ffffca 	b	11443d4 <kprintf.constprop.0+0x504>
 11444b0:	11002094 	add	w20, w4, #0x8
 11444b4:	7100029f 	cmp	w20, #0x0
 11444b8:	5400008d 	b.le	11444c8 <kprintf.constprop.0+0x5f8>
 11444bc:	91002c73 	add	x19, x3, #0xb
 11444c0:	927df273 	and	x19, x19, #0xfffffffffffffff8
 11444c4:	17fffff9 	b	11444a8 <kprintf.constprop.0+0x5d8>
 11444c8:	aa0303f3 	mov	x19, x3
 11444cc:	8b24c343 	add	x3, x26, w4, sxtw
 11444d0:	17fffff6 	b	11444a8 <kprintf.constprop.0+0x5d8>
			if (ext && *fmt == 'U' && *(fmt+1) == 'l') {
 11444d4:	b940a3e0 	ldr	w0, [sp, #160]
 11444d8:	34000c80 	cbz	w0, 1144668 <kprintf.constprop.0+0x798>
 11444dc:	39400360 	ldrb	w0, [x27]
 11444e0:	7101541f 	cmp	w0, #0x55
 11444e4:	54000c21 	b.ne	1144668 <kprintf.constprop.0+0x798>  // b.any
 11444e8:	39400760 	ldrb	w0, [x27, #1]
 11444ec:	7101b01f 	cmp	w0, #0x6c
 11444f0:	54000bc1 	b.ne	1144668 <kprintf.constprop.0+0x798>  // b.any
				fmt += 2;
 11444f4:	91000b7b 	add	x27, x27, #0x2
				size = uuid2str(bf, sizeof(bf),
 11444f8:	37f80a64 	tbnz	w4, #31, 1144644 <kprintf.constprop.0+0x774>
 11444fc:	91003c73 	add	x19, x3, #0xf
 1144500:	2a0403f4 	mov	w20, w4
 1144504:	927df273 	and	x19, x19, #0xfffffffffffffff8
 1144508:	f9400060 	ldr	x0, [x3]
	return snprintk(dst, size,
 114450c:	b00000a2 	adrp	x2, 1159000 <Worder+0x2854>
 1144510:	9133d842 	add	x2, x2, #0xcf6
 1144514:	f9004fec 	str	x12, [sp, #152]
 1144518:	b900a7ea 	str	w10, [sp, #164]
 114451c:	39403c01 	ldrb	w1, [x0, #15]
 1144520:	39402006 	ldrb	w6, [x0, #8]
 1144524:	79400c05 	ldrh	w5, [x0, #6]
 1144528:	39402407 	ldrb	w7, [x0, #9]
 114452c:	79400804 	ldrh	w4, [x0, #4]
 1144530:	b9002be1 	str	w1, [sp, #40]
 1144534:	f90057e8 	str	x8, [sp, #168]
 1144538:	39403801 	ldrb	w1, [x0, #14]
 114453c:	b90023e1 	str	w1, [sp, #32]
 1144540:	39403401 	ldrb	w1, [x0, #13]
 1144544:	b9001be1 	str	w1, [sp, #24]
 1144548:	39403001 	ldrb	w1, [x0, #12]
 114454c:	b90013e1 	str	w1, [sp, #16]
 1144550:	39402c01 	ldrb	w1, [x0, #11]
 1144554:	b9000be1 	str	w1, [sp, #8]
 1144558:	39402801 	ldrb	w1, [x0, #10]
 114455c:	b90003e1 	str	w1, [sp]
 1144560:	d28004a1 	mov	x1, #0x25                  	// #37
 1144564:	b9400003 	ldr	w3, [x0]
 1144568:	aa0c03e0 	mov	x0, x12
 114456c:	97fffe45 	bl	1143e80 <snprintk>
 1144570:	2a0003e5 	mov	w5, w0
				cp = bf;
 1144574:	f9404fec 	ldr	x12, [sp, #152]
		dprec = 0;
 1144578:	52800006 	mov	w6, #0x0                   	// #0
				break;
 114457c:	b940a7ea 	ldr	w10, [sp, #164]
				sign = '\0';
 1144580:	52800001 	mov	w1, #0x0                   	// #0
				break;
 1144584:	f94057e8 	ldr	x8, [sp, #168]
				cp = bf;
 1144588:	aa0c03e3 	mov	x3, x12
		 * floating precision; finally, if LADJUST, pad with blanks.
		 *
		 * Compute actual size, so we know how much to pad.
		 * size excludes decimal prec; realsz includes it.
		 */
		realsz = dprec > size ? dprec : size;
 114458c:	6b0500df 	cmp	w6, w5
 1144590:	1a85a0c4 	csel	w4, w6, w5, ge  // ge = tcont
		if (sign)
 1144594:	340020c1 	cbz	w1, 11449ac <kprintf.constprop.0+0xadc>
			realsz++;
 1144598:	11000484 	add	w4, w4, #0x1
		else if (flags & HEXPREFIX)
			realsz+= 2;

		/* adjust ret */
		ret += width > realsz ? width : realsz;
 114459c:	6b0a009f 	cmp	w4, w10
 11445a0:	1a8aa080 	csel	w0, w4, w10, ge  // ge = tcont
 11445a4:	0b000339 	add	w25, w25, w0

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0) {
 11445a8:	52808080 	mov	w0, #0x404                 	// #1028
 11445ac:	6a0002a0 	ands	w0, w21, w0
 11445b0:	540000a1 	b.ne	11445c4 <kprintf.constprop.0+0x6f4>  // b.any
			n = width - realsz;
 11445b4:	4b040147 	sub	w7, w10, w4
			while (n-- > 0)
				KPRINTF_PUTCHAR(' ');
 11445b8:	52800402 	mov	w2, #0x20                  	// #32
			while (n-- > 0)
 11445bc:	710000ff 	cmp	w7, #0x0
 11445c0:	54001fcc 	b.gt	11449b8 <kprintf.constprop.0+0xae8>
		}

		/* prefix */
		if (sign) {
 11445c4:	34002081 	cbz	w1, 11449d4 <kprintf.constprop.0+0xb04>
			KPRINTF_PUTCHAR(sign);
 11445c8:	b40000b6 	cbz	x22, 11445dc <kprintf.constprop.0+0x70c>
 11445cc:	f100011f 	cmp	x8, #0x0
 11445d0:	fa561302 	ccmp	x24, x22, #0x2, ne  // ne = any
 11445d4:	54000049 	b.ls	11445dc <kprintf.constprop.0+0x70c>  // b.plast
 11445d8:	380016c1 	strb	w1, [x22], #1
			KPRINTF_PUTCHAR('0');
			KPRINTF_PUTCHAR(ch);
		}

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD) {
 11445dc:	7110001f 	cmp	w0, #0x400
 11445e0:	540000a1 	b.ne	11445f4 <kprintf.constprop.0+0x724>  // b.any
			n = width - realsz;
 11445e4:	4b040140 	sub	w0, w10, w4
			while (n-- > 0)
				KPRINTF_PUTCHAR('0');
 11445e8:	52800601 	mov	w1, #0x30                  	// #48
			while (n-- > 0)
 11445ec:	7100001f 	cmp	w0, #0x0
 11445f0:	5400216c 	b.gt	1144a1c <kprintf.constprop.0+0xb4c>
		}

		/* leading zeroes from decimal precision */
		n = dprec - size;
 11445f4:	4b0500c6 	sub	w6, w6, w5
		while (n-- > 0)
			KPRINTF_PUTCHAR('0');
 11445f8:	52800600 	mov	w0, #0x30                  	// #48
		while (n-- > 0)
 11445fc:	710000df 	cmp	w6, #0x0
 1144600:	540021cc 	b.gt	1144a38 <kprintf.constprop.0+0xb68>
 1144604:	2a0503e5 	mov	w5, w5
 1144608:	d2800001 	mov	x1, #0x0                   	// #0

		/* the string or number proper */
		for (; size--; cp++)
 114460c:	eb05003f 	cmp	x1, x5
 1144610:	54002221 	b.ne	1144a54 <kprintf.constprop.0+0xb84>  // b.any
			KPRINTF_PUTCHAR(*cp);
		/* left-adjusting padding (always blank) */
		if (flags & LADJUST) {
 1144614:	3617c8d5 	tbz	w21, #2, 1143f2c <kprintf.constprop.0+0x5c>
			n = width - realsz;
 1144618:	4b04014a 	sub	w10, w10, w4
			while (n-- > 0)
				KPRINTF_PUTCHAR(' ');
 114461c:	52800400 	mov	w0, #0x20                  	// #32
			while (n-- > 0)
 1144620:	7100015f 	cmp	w10, #0x0
 1144624:	54ffc84d 	b.le	1143f2c <kprintf.constprop.0+0x5c>
				KPRINTF_PUTCHAR(' ');
 1144628:	b40000b6 	cbz	x22, 114463c <kprintf.constprop.0+0x76c>
 114462c:	f100011f 	cmp	x8, #0x0
 1144630:	fa561302 	ccmp	x24, x22, #0x2, ne  // ne = any
 1144634:	54000049 	b.ls	114463c <kprintf.constprop.0+0x76c>  // b.plast
 1144638:	380016c0 	strb	w0, [x22], #1
 114463c:	5100054a 	sub	w10, w10, #0x1
 1144640:	17fffff8 	b	1144620 <kprintf.constprop.0+0x750>
				size = uuid2str(bf, sizeof(bf),
 1144644:	11002094 	add	w20, w4, #0x8
 1144648:	7100029f 	cmp	w20, #0x0
 114464c:	5400008d 	b.le	114465c <kprintf.constprop.0+0x78c>
 1144650:	91003c73 	add	x19, x3, #0xf
 1144654:	927df273 	and	x19, x19, #0xfffffffffffffff8
 1144658:	17ffffac 	b	1144508 <kprintf.constprop.0+0x638>
 114465c:	aa0303f3 	mov	x19, x3
 1144660:	8b24c343 	add	x3, x26, w4, sxtw
 1144664:	17ffffa9 	b	1144508 <kprintf.constprop.0+0x638>
			_uquad = (unsigned long)va_arg(ap, void *);
 1144668:	37f801c4 	tbnz	w4, #31, 11446a0 <kprintf.constprop.0+0x7d0>
 114466c:	91003c73 	add	x19, x3, #0xf
 1144670:	2a0403f4 	mov	w20, w4
 1144674:	927df273 	and	x19, x19, #0xfffffffffffffff8
 1144678:	f9400062 	ldr	x2, [x3]
			xdigs = hexdigits;
 114467c:	b00000b7 	adrp	x23, 1159000 <Worder+0x2854>
			flags |= HEXPREFIX;
 1144680:	321f02b5 	orr	w21, w21, #0x2
			xdigs = hexdigits;
 1144684:	9134e2f7 	add	x23, x23, #0xd38
			ch = 'x';
 1144688:	52800f1c 	mov	w28, #0x78                  	// #120
number:			if ((dprec = prec) >= 0)
 114468c:	310004bf 	cmn	w5, #0x1
 1144690:	52800001 	mov	w1, #0x0                   	// #0
 1144694:	54ffdbe0 	b.eq	1144210 <kprintf.constprop.0+0x340>  // b.none
 1144698:	52800040 	mov	w0, #0x2                   	// #2
 114469c:	140000a8 	b	114493c <kprintf.constprop.0+0xa6c>
			_uquad = (unsigned long)va_arg(ap, void *);
 11446a0:	11002094 	add	w20, w4, #0x8
 11446a4:	7100029f 	cmp	w20, #0x0
 11446a8:	5400008d 	b.le	11446b8 <kprintf.constprop.0+0x7e8>
 11446ac:	91003c73 	add	x19, x3, #0xf
 11446b0:	927df273 	and	x19, x19, #0xfffffffffffffff8
 11446b4:	17fffff1 	b	1144678 <kprintf.constprop.0+0x7a8>
 11446b8:	aa0303f3 	mov	x19, x3
 11446bc:	8b24c343 	add	x3, x26, w4, sxtw
 11446c0:	17ffffee 	b	1144678 <kprintf.constprop.0+0x7a8>
			if ((cp = va_arg(ap, char *)) == NULL)
 11446c4:	37f80364 	tbnz	w4, #31, 1144730 <kprintf.constprop.0+0x860>
 11446c8:	91003c73 	add	x19, x3, #0xf
 11446cc:	2a0403f4 	mov	w20, w4
 11446d0:	927df273 	and	x19, x19, #0xfffffffffffffff8
 11446d4:	f9400063 	ldr	x3, [x3]
 11446d8:	b5000063 	cbnz	x3, 11446e4 <kprintf.constprop.0+0x814>
				cp = __UNCONST("(null)");
 11446dc:	b00000a3 	adrp	x3, 1159000 <Worder+0x2854>
 11446e0:	9133bc63 	add	x3, x3, #0xcef
			if (prec >= 0) {
 11446e4:	310004bf 	cmn	w5, #0x1
 11446e8:	54000360 	b.eq	1144754 <kprintf.constprop.0+0x884>  // b.none
				char *p = memchr(cp, 0, prec);
 11446ec:	93407ca2 	sxtw	x2, w5
 11446f0:	aa0303e0 	mov	x0, x3
 11446f4:	52800001 	mov	w1, #0x0                   	// #0
 11446f8:	f9004fe3 	str	x3, [sp, #152]
 11446fc:	2914abe5 	stp	w5, w10, [sp, #164]
 1144700:	a90b33e8 	stp	x8, x12, [sp, #176]
 1144704:	94000242 	bl	114500c <memchr>
				if (p != NULL) {
 1144708:	2954abe5 	ldp	w5, w10, [sp, #164]
 114470c:	f9404fe3 	ldr	x3, [sp, #152]
 1144710:	a94b33e8 	ldp	x8, x12, [sp, #176]
 1144714:	b4000080 	cbz	x0, 1144724 <kprintf.constprop.0+0x854>
					size = p - cp;
 1144718:	cb030000 	sub	x0, x0, x3
 114471c:	6b0000bf 	cmp	w5, w0
 1144720:	1a80d0a5 	csel	w5, w5, w0, le
		dprec = 0;
 1144724:	52800006 	mov	w6, #0x0                   	// #0
			sign = '\0';
 1144728:	52800001 	mov	w1, #0x0                   	// #0
 114472c:	17ffff98 	b	114458c <kprintf.constprop.0+0x6bc>
			if ((cp = va_arg(ap, char *)) == NULL)
 1144730:	11002094 	add	w20, w4, #0x8
 1144734:	7100029f 	cmp	w20, #0x0
 1144738:	5400008d 	b.le	1144748 <kprintf.constprop.0+0x878>
 114473c:	91003c73 	add	x19, x3, #0xf
 1144740:	927df273 	and	x19, x19, #0xfffffffffffffff8
 1144744:	17ffffe4 	b	11446d4 <kprintf.constprop.0+0x804>
 1144748:	aa0303f3 	mov	x19, x3
 114474c:	8b24c343 	add	x3, x26, w4, sxtw
 1144750:	17ffffe1 	b	11446d4 <kprintf.constprop.0+0x804>
				size = strlen(cp);
 1144754:	aa0303e0 	mov	x0, x3
 1144758:	f9004fe3 	str	x3, [sp, #152]
 114475c:	b900a7ea 	str	w10, [sp, #164]
 1144760:	a90ab3e8 	stp	x8, x12, [sp, #168]
 1144764:	97fffd6f 	bl	1143d20 <strlen>
 1144768:	b940a7ea 	ldr	w10, [sp, #164]
 114476c:	2a0003e5 	mov	w5, w0
		dprec = 0;
 1144770:	52800006 	mov	w6, #0x0                   	// #0
			sign = '\0';
 1144774:	52800001 	mov	w1, #0x0                   	// #0
 1144778:	f9404fe3 	ldr	x3, [sp, #152]
 114477c:	a94ab3e8 	ldp	x8, x12, [sp, #168]
 1144780:	17ffff83 	b	114458c <kprintf.constprop.0+0x6bc>
			flags |= LONGINT;
 1144784:	321c02b5 	orr	w21, w21, #0x10
			_uquad = UARG();
 1144788:	36380235 	tbz	w21, #7, 11447cc <kprintf.constprop.0+0x8fc>
 114478c:	37f80364 	tbnz	w4, #31, 11447f8 <kprintf.constprop.0+0x928>
 1144790:	91003c73 	add	x19, x3, #0xf
 1144794:	2a0403f4 	mov	w20, w4
 1144798:	927df273 	and	x19, x19, #0xfffffffffffffff8
 114479c:	f9400062 	ldr	x2, [x3]
nosign:			sign = '\0';
 11447a0:	52800001 	mov	w1, #0x0                   	// #0
number:			if ((dprec = prec) >= 0)
 11447a4:	310004bf 	cmn	w5, #0x1
 11447a8:	54000d81 	b.ne	1144958 <kprintf.constprop.0+0xa88>  // b.any
			cp = bf + KPRINTF_BUFSIZE;
 11447ac:	91009580 	add	x0, x12, #0x25
						*--cp = to_char(_uquad % 10);
 11447b0:	d2800144 	mov	x4, #0xa                   	// #10
					while (_uquad >= 10) {
 11447b4:	d1000403 	sub	x3, x0, #0x1
 11447b8:	f100245f 	cmp	x2, #0x9
 11447bc:	54000d28 	b.hi	1144960 <kprintf.constprop.0+0xa90>  // b.pmore
					*--cp = to_char(_uquad);
 11447c0:	1100c042 	add	w2, w2, #0x30
 11447c4:	381ff002 	sturb	w2, [x0, #-1]
					break;
 11447c8:	17ffff13 	b	1144414 <kprintf.constprop.0+0x544>
			_uquad = UARG();
 11447cc:	3747fe15 	tbnz	w21, #8, 114478c <kprintf.constprop.0+0x8bc>
 11447d0:	374ffdf5 	tbnz	w21, #9, 114478c <kprintf.constprop.0+0x8bc>
 11447d4:	372ffdd5 	tbnz	w21, #5, 114478c <kprintf.constprop.0+0x8bc>
 11447d8:	3727fdb5 	tbnz	w21, #4, 114478c <kprintf.constprop.0+0x8bc>
 11447dc:	36300335 	tbz	w21, #6, 1144840 <kprintf.constprop.0+0x970>
 11447e0:	37f801e4 	tbnz	w4, #31, 114481c <kprintf.constprop.0+0x94c>
 11447e4:	91002c73 	add	x19, x3, #0xb
 11447e8:	2a0403f4 	mov	w20, w4
 11447ec:	927df273 	and	x19, x19, #0xfffffffffffffff8
 11447f0:	79400062 	ldrh	w2, [x3]
 11447f4:	17ffffeb 	b	11447a0 <kprintf.constprop.0+0x8d0>
 11447f8:	11002094 	add	w20, w4, #0x8
 11447fc:	7100029f 	cmp	w20, #0x0
 1144800:	5400008d 	b.le	1144810 <kprintf.constprop.0+0x940>
 1144804:	91003c73 	add	x19, x3, #0xf
 1144808:	927df273 	and	x19, x19, #0xfffffffffffffff8
 114480c:	17ffffe4 	b	114479c <kprintf.constprop.0+0x8cc>
 1144810:	aa0303f3 	mov	x19, x3
 1144814:	8b24c343 	add	x3, x26, w4, sxtw
 1144818:	17ffffe1 	b	114479c <kprintf.constprop.0+0x8cc>
 114481c:	11002094 	add	w20, w4, #0x8
 1144820:	7100029f 	cmp	w20, #0x0
 1144824:	5400008d 	b.le	1144834 <kprintf.constprop.0+0x964>
 1144828:	91002c73 	add	x19, x3, #0xb
 114482c:	927df273 	and	x19, x19, #0xfffffffffffffff8
 1144830:	17fffff0 	b	11447f0 <kprintf.constprop.0+0x920>
 1144834:	aa0303f3 	mov	x19, x3
 1144838:	8b24c343 	add	x3, x26, w4, sxtw
 114483c:	17ffffed 	b	11447f0 <kprintf.constprop.0+0x920>
 1144840:	37f800c4 	tbnz	w4, #31, 1144858 <kprintf.constprop.0+0x988>
 1144844:	91002c73 	add	x19, x3, #0xb
 1144848:	2a0403f4 	mov	w20, w4
 114484c:	927df273 	and	x19, x19, #0xfffffffffffffff8
 1144850:	b9400062 	ldr	w2, [x3]
 1144854:	17ffffd3 	b	11447a0 <kprintf.constprop.0+0x8d0>
 1144858:	11002094 	add	w20, w4, #0x8
 114485c:	7100029f 	cmp	w20, #0x0
 1144860:	5400008d 	b.le	1144870 <kprintf.constprop.0+0x9a0>
 1144864:	91002c73 	add	x19, x3, #0xb
 1144868:	927df273 	and	x19, x19, #0xfffffffffffffff8
 114486c:	17fffff9 	b	1144850 <kprintf.constprop.0+0x980>
 1144870:	aa0303f3 	mov	x19, x3
 1144874:	8b24c343 	add	x3, x26, w4, sxtw
 1144878:	17fffff6 	b	1144850 <kprintf.constprop.0+0x980>
			xdigs = HEXDIGITS;
 114487c:	b00000b7 	adrp	x23, 1159000 <Worder+0x2854>
 1144880:	91349ef7 	add	x23, x23, #0xd27
 1144884:	17fffdda 	b	1143fec <kprintf.constprop.0+0x11c>
hex:			_uquad = UARG();
 1144888:	3747bb55 	tbnz	w21, #8, 1143ff0 <kprintf.constprop.0+0x120>
 114488c:	374fbb35 	tbnz	w21, #9, 1143ff0 <kprintf.constprop.0+0x120>
 1144890:	372fbb15 	tbnz	w21, #5, 1143ff0 <kprintf.constprop.0+0x120>
 1144894:	3727baf5 	tbnz	w21, #4, 1143ff0 <kprintf.constprop.0+0x120>
 1144898:	36300335 	tbz	w21, #6, 11448fc <kprintf.constprop.0+0xa2c>
 114489c:	37f801e4 	tbnz	w4, #31, 11448d8 <kprintf.constprop.0+0xa08>
 11448a0:	91002c73 	add	x19, x3, #0xb
 11448a4:	2a0403f4 	mov	w20, w4
 11448a8:	927df273 	and	x19, x19, #0xfffffffffffffff8
 11448ac:	79400062 	ldrh	w2, [x3]
 11448b0:	17fffdd5 	b	1144004 <kprintf.constprop.0+0x134>
 11448b4:	11002094 	add	w20, w4, #0x8
 11448b8:	7100029f 	cmp	w20, #0x0
 11448bc:	5400008d 	b.le	11448cc <kprintf.constprop.0+0x9fc>
 11448c0:	91003c73 	add	x19, x3, #0xf
 11448c4:	927df273 	and	x19, x19, #0xfffffffffffffff8
 11448c8:	17fffdce 	b	1144000 <kprintf.constprop.0+0x130>
 11448cc:	aa0303f3 	mov	x19, x3
 11448d0:	8b24c343 	add	x3, x26, w4, sxtw
 11448d4:	17fffdcb 	b	1144000 <kprintf.constprop.0+0x130>
 11448d8:	11002094 	add	w20, w4, #0x8
 11448dc:	7100029f 	cmp	w20, #0x0
 11448e0:	5400008d 	b.le	11448f0 <kprintf.constprop.0+0xa20>
 11448e4:	91002c73 	add	x19, x3, #0xb
 11448e8:	927df273 	and	x19, x19, #0xfffffffffffffff8
 11448ec:	17fffff0 	b	11448ac <kprintf.constprop.0+0x9dc>
 11448f0:	aa0303f3 	mov	x19, x3
 11448f4:	8b24c343 	add	x3, x26, w4, sxtw
 11448f8:	17ffffed 	b	11448ac <kprintf.constprop.0+0x9dc>
 11448fc:	37f800c4 	tbnz	w4, #31, 1144914 <kprintf.constprop.0+0xa44>
 1144900:	91002c73 	add	x19, x3, #0xb
 1144904:	2a0403f4 	mov	w20, w4
 1144908:	927df273 	and	x19, x19, #0xfffffffffffffff8
 114490c:	b9400062 	ldr	w2, [x3]
 1144910:	17fffdbd 	b	1144004 <kprintf.constprop.0+0x134>
 1144914:	11002094 	add	w20, w4, #0x8
 1144918:	7100029f 	cmp	w20, #0x0
 114491c:	5400008d 	b.le	114492c <kprintf.constprop.0+0xa5c>
 1144920:	91002c73 	add	x19, x3, #0xb
 1144924:	927df273 	and	x19, x19, #0xfffffffffffffff8
 1144928:	17fffff9 	b	114490c <kprintf.constprop.0+0xa3c>
 114492c:	aa0303f3 	mov	x19, x3
 1144930:	8b24c343 	add	x3, x26, w4, sxtw
 1144934:	17fffff6 	b	114490c <kprintf.constprop.0+0xa3c>
number:			if ((dprec = prec) >= 0)
 1144938:	52800000 	mov	w0, #0x0                   	// #0
			if (_uquad != 0 || prec != 0) {
 114493c:	f100005f 	cmp	x2, #0x0
				flags &= ~ZEROPAD;
 1144940:	12157ab5 	and	w21, w21, #0xfffffbff
			if (_uquad != 0 || prec != 0) {
 1144944:	7a4008a0 	ccmp	w5, #0x0, #0x0, eq  // eq = none
 1144948:	54ffc5c1 	b.ne	1144200 <kprintf.constprop.0+0x330>  // b.any
			cp = bf + KPRINTF_BUFSIZE;
 114494c:	91009583 	add	x3, x12, #0x25
			}
 1144950:	52800005 	mov	w5, #0x0                   	// #0
 1144954:	17fffeb0 	b	1144414 <kprintf.constprop.0+0x544>
number:			if ((dprec = prec) >= 0)
 1144958:	52800020 	mov	w0, #0x1                   	// #1
 114495c:	17fffff8 	b	114493c <kprintf.constprop.0+0xa6c>
						*--cp = to_char(_uquad % 10);
 1144960:	9ac40846 	udiv	x6, x2, x4
 1144964:	9b0488c2 	msub	x2, x6, x4, x2
 1144968:	1100c042 	add	w2, w2, #0x30
 114496c:	381ff002 	sturb	w2, [x0, #-1]
						_uquad /= 10;
 1144970:	aa0603e2 	mov	x2, x6
 1144974:	aa0303e0 	mov	x0, x3
 1144978:	17ffff8f 	b	11447b4 <kprintf.constprop.0+0x8e4>
			if (ch == '\0')
 114497c:	35ffb57c 	cbnz	w28, 1144028 <kprintf.constprop.0+0x158>
		}
	}

done:
	if ((oflags == TOBUFONLY) && (vp != NULL))
 1144980:	b4000048 	cbz	x8, 1144988 <kprintf.constprop.0+0xab8>
		*(char **)vp = sbuf;
 1144984:	f9000116 	str	x22, [x8]
	return ret;
}
 1144988:	2a1903e0 	mov	w0, w25
 114498c:	a9437bfd 	ldp	x29, x30, [sp, #48]
 1144990:	a94453f3 	ldp	x19, x20, [sp, #64]
 1144994:	a9455bf5 	ldp	x21, x22, [sp, #80]
 1144998:	a94663f7 	ldp	x23, x24, [sp, #96]
 114499c:	a9476bf9 	ldp	x25, x26, [sp, #112]
 11449a0:	a94873fb 	ldp	x27, x28, [sp, #128]
 11449a4:	9103c3ff 	add	sp, sp, #0xf0
 11449a8:	d65f03c0 	ret
		else if (flags & HEXPREFIX)
 11449ac:	360fdf95 	tbz	w21, #1, 114459c <kprintf.constprop.0+0x6cc>
			realsz+= 2;
 11449b0:	11000884 	add	w4, w4, #0x2
 11449b4:	17fffefa 	b	114459c <kprintf.constprop.0+0x6cc>
				KPRINTF_PUTCHAR(' ');
 11449b8:	b40000b6 	cbz	x22, 11449cc <kprintf.constprop.0+0xafc>
 11449bc:	f100011f 	cmp	x8, #0x0
 11449c0:	fa561302 	ccmp	x24, x22, #0x2, ne  // ne = any
 11449c4:	54000049 	b.ls	11449cc <kprintf.constprop.0+0xafc>  // b.plast
 11449c8:	380016c2 	strb	w2, [x22], #1
 11449cc:	510004e7 	sub	w7, w7, #0x1
 11449d0:	17fffefb 	b	11445bc <kprintf.constprop.0+0x6ec>
		} else if (flags & HEXPREFIX) {
 11449d4:	360fe055 	tbz	w21, #1, 11445dc <kprintf.constprop.0+0x70c>
			KPRINTF_PUTCHAR('0');
 11449d8:	b4ffe036 	cbz	x22, 11445dc <kprintf.constprop.0+0x70c>
 11449dc:	f100011f 	cmp	x8, #0x0
 11449e0:	1a9f17e2 	cset	w2, eq  // eq = none
 11449e4:	7100005f 	cmp	w2, #0x0
 11449e8:	fa560302 	ccmp	x24, x22, #0x2, eq  // eq = none
 11449ec:	54ffdf89 	b.ls	11445dc <kprintf.constprop.0+0x70c>  // b.plast
 11449f0:	aa1603e1 	mov	x1, x22
 11449f4:	52800607 	mov	w7, #0x30                  	// #48
			KPRINTF_PUTCHAR(ch);
 11449f8:	7100005f 	cmp	w2, #0x0
			KPRINTF_PUTCHAR('0');
 11449fc:	38001427 	strb	w7, [x1], #1
			KPRINTF_PUTCHAR(ch);
 1144a00:	fa410302 	ccmp	x24, x1, #0x2, eq  // eq = none
 1144a04:	54000089 	b.ls	1144a14 <kprintf.constprop.0+0xb44>  // b.plast
 1144a08:	91000ad6 	add	x22, x22, #0x2
 1144a0c:	381ff2dc 	sturb	w28, [x22, #-1]
 1144a10:	17fffef3 	b	11445dc <kprintf.constprop.0+0x70c>
 1144a14:	aa0103f6 	mov	x22, x1
 1144a18:	17fffef1 	b	11445dc <kprintf.constprop.0+0x70c>
				KPRINTF_PUTCHAR('0');
 1144a1c:	b40000b6 	cbz	x22, 1144a30 <kprintf.constprop.0+0xb60>
 1144a20:	f100011f 	cmp	x8, #0x0
 1144a24:	fa561302 	ccmp	x24, x22, #0x2, ne  // ne = any
 1144a28:	54000049 	b.ls	1144a30 <kprintf.constprop.0+0xb60>  // b.plast
 1144a2c:	380016c1 	strb	w1, [x22], #1
 1144a30:	51000400 	sub	w0, w0, #0x1
 1144a34:	17fffeee 	b	11445ec <kprintf.constprop.0+0x71c>
			KPRINTF_PUTCHAR('0');
 1144a38:	b40000b6 	cbz	x22, 1144a4c <kprintf.constprop.0+0xb7c>
 1144a3c:	f100011f 	cmp	x8, #0x0
 1144a40:	fa561302 	ccmp	x24, x22, #0x2, ne  // ne = any
 1144a44:	54000049 	b.ls	1144a4c <kprintf.constprop.0+0xb7c>  // b.plast
 1144a48:	380016c0 	strb	w0, [x22], #1
 1144a4c:	510004c6 	sub	w6, w6, #0x1
 1144a50:	17fffeeb 	b	11445fc <kprintf.constprop.0+0x72c>
			KPRINTF_PUTCHAR(*cp);
 1144a54:	b40000d6 	cbz	x22, 1144a6c <kprintf.constprop.0+0xb9c>
 1144a58:	f100011f 	cmp	x8, #0x0
 1144a5c:	fa561302 	ccmp	x24, x22, #0x2, ne  // ne = any
 1144a60:	54000069 	b.ls	1144a6c <kprintf.constprop.0+0xb9c>  // b.plast
 1144a64:	38616860 	ldrb	w0, [x3, x1]
 1144a68:	380016c0 	strb	w0, [x22], #1
		for (; size--; cp++)
 1144a6c:	91000421 	add	x1, x1, #0x1
 1144a70:	17fffee7 	b	114460c <kprintf.constprop.0+0x73c>

0000000001144a74 <strlcpy>:
	register char *d = dst;
	register const char *s = src;
	register size_t n = siz;

	/* Copy as many bytes as will fit */
	if (n != 0 && --n != 0) {
 1144a74:	b40001c2 	cbz	x2, 1144aac <strlcpy+0x38>
 1144a78:	f100045f 	cmp	x2, #0x1
 1144a7c:	54000240 	b.eq	1144ac4 <strlcpy+0x50>  // b.none
 1144a80:	91000424 	add	x4, x1, #0x1
		do {
			if ((*d++ = *s++) == 0)
				break;
		} while (--n != 0);
 1144a84:	8b020022 	add	x2, x1, x2
			if ((*d++ = *s++) == 0)
 1144a88:	385ff085 	ldurb	w5, [x4, #-1]
 1144a8c:	aa0403e3 	mov	x3, x4
 1144a90:	38001405 	strb	w5, [x0], #1
 1144a94:	34000125 	cbz	w5, 1144ab8 <strlcpy+0x44>
		} while (--n != 0);
 1144a98:	91000484 	add	x4, x4, #0x1
 1144a9c:	eb04005f 	cmp	x2, x4
 1144aa0:	54ffff41 	b.ne	1144a88 <strlcpy+0x14>  // b.any
	}

	/* Not enough room in dst, add NUL and traverse rest of src */
	if (n == 0) {
		if (siz != 0)
			*d = '\0';	/* NUL-terminate dst */
 1144aa4:	3900001f 	strb	wzr, [x0]
 1144aa8:	14000002 	b	1144ab0 <strlcpy+0x3c>
	register const char *s = src;
 1144aac:	aa0103e3 	mov	x3, x1
		while (*s++)
 1144ab0:	38401460 	ldrb	w0, [x3], #1
 1144ab4:	35ffffe0 	cbnz	w0, 1144ab0 <strlcpy+0x3c>
			;
	}

	return s - src - 1;	/* count does not include NUL */
 1144ab8:	cb010060 	sub	x0, x3, x1
 1144abc:	d1000400 	sub	x0, x0, #0x1
}
 1144ac0:	d65f03c0 	ret
	register const char *s = src;
 1144ac4:	aa0103e3 	mov	x3, x1
 1144ac8:	17fffff7 	b	1144aa4 <strlcpy+0x30>

0000000001144acc <trace_vprintf>:
	trace_vprintf(function, line, level, level_ok, fmt, ap);
	va_end(ap);
}
void trace_vprintf(const char *function, int line, int level, bool level_ok,
		   const char *fmt, va_list ap)
{
 1144acc:	a9a87bfd 	stp	x29, x30, [sp, #-384]!
 1144ad0:	910003fd 	mov	x29, sp
 1144ad4:	a90153f3 	stp	x19, x20, [sp, #16]
 1144ad8:	a9025bf5 	stp	x21, x22, [sp, #32]
 1144adc:	aa0003f6 	mov	x22, x0
 1144ae0:	a90363f7 	stp	x23, x24, [sp, #48]
 1144ae4:	aa0403f7 	mov	x23, x4
 1144ae8:	aa0503f8 	mov	x24, x5
 1144aec:	a9046bf9 	stp	x25, x26, [sp, #64]
 1144af0:	2a0103f9 	mov	w25, w1
 1144af4:	2a0203fa 	mov	w26, w2
 1144af8:	f9002bfb 	str	x27, [sp, #80]
	char buf[MAX_PRINT_SIZE];
	size_t boffs = 0;
	int res;

	if (level_ok && level > trace_level)
 1144afc:	72001c7b 	ands	w27, w3, #0xff
 1144b00:	54000600 	b.eq	1144bc0 <trace_vprintf+0xf4>  // b.none
 1144b04:	d00000a3 	adrp	x3, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1144b08:	f9416063 	ldr	x3, [x3, #704]
 1144b0c:	b9400060 	ldr	w0, [x3]
 1144b10:	6b02001f 	cmp	w0, w2
 1144b14:	54000d6b 	b.lt	1144cc0 <trace_vprintf+0x1f4>  // b.tstop
	if ((level >= TRACE_MIN) && (level <= TRACE_MAX))
 1144b18:	7100105f 	cmp	w2, #0x4
	return lvl_strs[l];
 1144b1c:	b00000a0 	adrp	x0, 1159000 <Worder+0x2854>
	if ((level >= TRACE_MIN) && (level <= TRACE_MAX))
 1144b20:	1a9f9041 	csel	w1, w2, wzr, ls  // ls = plast
	return lvl_strs[l];
 1144b24:	9135ec00 	add	x0, x0, #0xd7b
 1144b28:	3861c803 	ldrb	w3, [x0, w1, sxtw]
		return;

	/* Print the type of message */
	res = snprintk(buf, sizeof(buf), "%c/",
 1144b2c:	910203f4 	add	x20, sp, #0x80
 1144b30:	b00000a2 	adrp	x2, 1159000 <Worder+0x2854>
 1144b34:	aa1403e0 	mov	x0, x20
 1144b38:	91352442 	add	x2, x2, #0xd49
 1144b3c:	d2802001 	mov	x1, #0x100                 	// #256
 1144b40:	97fffcd0 	bl	1143e80 <snprintk>
		       trace_level_to_string(level, level_ok));
	if (res < 0)
 1144b44:	37f80be0 	tbnz	w0, #31, 1144cc0 <trace_vprintf+0x1f4>
		return;
	boffs += res;

	/* Print the location, i.e., TEE core or TA */
	res = snprintk(buf + boffs, sizeof(buf) - boffs, "%s:",
 1144b48:	d00000a3 	adrp	x3, 115a000 <__scattered_array_1phys_mem_map+0x8>
 1144b4c:	d2802013 	mov	x19, #0x100                 	// #256
	boffs += res;
 1144b50:	93407c15 	sxtw	x21, w0
	res = snprintk(buf + boffs, sizeof(buf) - boffs, "%s:",
 1144b54:	cb20c261 	sub	x1, x19, w0, sxtw
 1144b58:	f9416c63 	ldr	x3, [x3, #728]
 1144b5c:	b00000a2 	adrp	x2, 1159000 <Worder+0x2854>
 1144b60:	8b20c280 	add	x0, x20, w0, sxtw
 1144b64:	91353442 	add	x2, x2, #0xd4d
 1144b68:	97fffcc6 	bl	1143e80 <snprintk>
		       trace_ext_prefix);
	if (res < 0)
 1144b6c:	37f80aa0 	tbnz	w0, #31, 1144cc0 <trace_vprintf+0x1f4>
		return;
	boffs += res;
 1144b70:	8b20c2b5 	add	x21, x21, w0, sxtw

	if (level_ok && (BIT(level) & CFG_MSG_LONG_PREFIX_MASK)) {
 1144b74:	34000d7b 	cbz	w27, 1144d20 <trace_vprintf+0x254>
 1144b78:	52800342 	mov	w2, #0x1a                  	// #26
 1144b7c:	1ada245a 	lsr	w26, w2, w26
 1144b80:	36000d1a 	tbz	w26, #0, 1144d20 <trace_vprintf+0x254>
		/* Print the core ID if in atomic context  */
		res = print_core_id(buf + boffs, sizeof(buf) - boffs);
 1144b84:	8b15029a 	add	x26, x20, x21
 1144b88:	cb150273 	sub	x19, x19, x21
	if (thread_get_exceptions() & THREAD_EXCP_FOREIGN_INTR)
 1144b8c:	97ff00e2 	bl	1104f14 <thread_get_exceptions>
 1144b90:	36080a60 	tbz	w0, #1, 1144cdc <trace_vprintf+0x210>
	assert(thread_get_exceptions() & THREAD_EXCP_FOREIGN_INTR);
 1144b94:	97ff00e0 	bl	1104f14 <thread_get_exceptions>
 1144b98:	37080180 	tbnz	w0, #1, 1144bc8 <trace_vprintf+0xfc>
 1144b9c:	b00000a3 	adrp	x3, 1159000 <Worder+0x2854>
 1144ba0:	b0000061 	adrp	x1, 1151000 <small_prime+0x168>
 1144ba4:	9135b863 	add	x3, x3, #0xd6e
 1144ba8:	9113b021 	add	x1, x1, #0x4ec
 1144bac:	b0000060 	adrp	x0, 1151000 <small_prime+0x168>
 1144bb0:	91144000 	add	x0, x0, #0x510
 1144bb4:	528002c2 	mov	w2, #0x16                  	// #22
 1144bb8:	97ff35bd 	bl	11122ac <_assert_log>
 1144bbc:	97ff35cd 	bl	11122f0 <_assert_break>
		return 'M';
 1144bc0:	528009a3 	mov	w3, #0x4d                  	// #77
 1144bc4:	17ffffda 	b	1144b2c <trace_vprintf+0x60>
	return __get_core_pos();
 1144bc8:	97fef363 	bl	1101954 <__get_core_pos>
		return snprintk(buf, bs, "%0*zu ", num_digits, get_core_pos());
 1144bcc:	aa0003e4 	mov	x4, x0
 1144bd0:	b00000a2 	adrp	x2, 1159000 <Worder+0x2854>
 1144bd4:	aa1303e1 	mov	x1, x19
 1144bd8:	91354442 	add	x2, x2, #0xd51
 1144bdc:	aa1a03e0 	mov	x0, x26
 1144be0:	52800023 	mov	w3, #0x1                   	// #1
 1144be4:	97fffca7 	bl	1143e80 <snprintk>
		if (res < 0)
 1144be8:	37f806c0 	tbnz	w0, #31, 1144cc0 <trace_vprintf+0x1f4>
			return;
		boffs += res;
 1144bec:	8b20c2b3 	add	x19, x21, w0, sxtw

		/* Print the Thread ID */
		res = print_thread_id(buf + boffs, sizeof(buf) - boffs);
 1144bf0:	d2802015 	mov	x21, #0x100                 	// #256
	int thread_id = trace_ext_get_thread_id();
 1144bf4:	97ff0c89 	bl	1107e18 <trace_ext_get_thread_id>
		res = print_thread_id(buf + boffs, sizeof(buf) - boffs);
 1144bf8:	8b13029a 	add	x26, x20, x19
 1144bfc:	cb1302b5 	sub	x21, x21, x19
	int thread_id = trace_ext_get_thread_id();
 1144c00:	2a0003e4 	mov	w4, w0
	if (thread_id >= 0)
 1144c04:	37f807c0 	tbnz	w0, #31, 1144cfc <trace_vprintf+0x230>
		return snprintk(buf, bs, "%0*d ", num_thread_digits, thread_id);
 1144c08:	b00000a2 	adrp	x2, 1159000 <Worder+0x2854>
 1144c0c:	aa1503e1 	mov	x1, x21
 1144c10:	91357042 	add	x2, x2, #0xd5c
 1144c14:	aa1a03e0 	mov	x0, x26
 1144c18:	52800023 	mov	w3, #0x1                   	// #1
 1144c1c:	97fffc99 	bl	1143e80 <snprintk>
		if (res < 0)
 1144c20:	37f80500 	tbnz	w0, #31, 1144cc0 <trace_vprintf+0x1f4>
			return;
		boffs += res;
 1144c24:	8b20c273 	add	x19, x19, w0, sxtw

		if (function) {
 1144c28:	b4000176 	cbz	x22, 1144c54 <trace_vprintf+0x188>
			res = snprintk(buf + boffs, sizeof(buf) - boffs, "%s:%d ",
 1144c2c:	b00000a2 	adrp	x2, 1159000 <Worder+0x2854>
 1144c30:	d2802001 	mov	x1, #0x100                 	// #256
 1144c34:	2a1903e4 	mov	w4, w25
 1144c38:	aa1603e3 	mov	x3, x22
 1144c3c:	91359c42 	add	x2, x2, #0xd67
 1144c40:	cb130021 	sub	x1, x1, x19
 1144c44:	8b130280 	add	x0, x20, x19
 1144c48:	97fffc8e 	bl	1143e80 <snprintk>
				       function, line);
			if (res < 0)
 1144c4c:	37f803a0 	tbnz	w0, #31, 1144cc0 <trace_vprintf+0x1f4>
				return;
			boffs += res;
 1144c50:	8b20c273 	add	x19, x19, w0, sxtw
		    return;
		buf[boffs++] = ' ';
		buf[boffs] = 0;
	}

	res = vsnprintk(buf + boffs, sizeof(buf) - boffs, fmt, ap);
 1144c54:	910183e3 	add	x3, sp, #0x60
 1144c58:	aa1803e1 	mov	x1, x24
 1144c5c:	aa0303e0 	mov	x0, x3
 1144c60:	d2800402 	mov	x2, #0x20                  	// #32
 1144c64:	97fef9cb 	bl	1103390 <memcpy>
 1144c68:	aa0003e3 	mov	x3, x0
 1144c6c:	aa1703e2 	mov	x2, x23
 1144c70:	8b130280 	add	x0, x20, x19
 1144c74:	d2802001 	mov	x1, #0x100                 	// #256
 1144c78:	cb130021 	sub	x1, x1, x19
 1144c7c:	97fffc6b 	bl	1143e28 <vsnprintk>
	if (res > 0)
 1144c80:	7100001f 	cmp	w0, #0x0
 1144c84:	5400004d 	b.le	1144c8c <trace_vprintf+0x1c0>
		boffs += res;
 1144c88:	8b20c273 	add	x19, x19, w0, sxtw

	if (boffs >= (sizeof(buf) - 1))
 1144c8c:	f103fa7f 	cmp	x19, #0xfe
 1144c90:	d2801fc0 	mov	x0, #0xfe                  	// #254
 1144c94:	9a809273 	csel	x19, x19, x0, ls  // ls = plast
		boffs = sizeof(buf) - 2;

	buf[boffs] = '\n';
 1144c98:	52800140 	mov	w0, #0xa                   	// #10
 1144c9c:	38336a80 	strb	w0, [x20, x19]
	while (boffs && buf[boffs] == '\n')
 1144ca0:	b4000093 	cbz	x19, 1144cb0 <trace_vprintf+0x1e4>
 1144ca4:	38736a80 	ldrb	w0, [x20, x19]
 1144ca8:	7100281f 	cmp	w0, #0xa
 1144cac:	54000480 	b.eq	1144d3c <trace_vprintf+0x270>  // b.none
		boffs--;
	boffs++;
	buf[boffs + 1] = '\0';
 1144cb0:	91020be0 	add	x0, sp, #0x82
 1144cb4:	3833681f 	strb	wzr, [x0, x19]

	trace_ext_puts(buf);
 1144cb8:	aa1403e0 	mov	x0, x20
 1144cbc:	97ff0c13 	bl	1107d08 <trace_ext_puts>
}
 1144cc0:	a94153f3 	ldp	x19, x20, [sp, #16]
 1144cc4:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1144cc8:	a94363f7 	ldp	x23, x24, [sp, #48]
 1144ccc:	a9446bf9 	ldp	x25, x26, [sp, #64]
 1144cd0:	f9402bfb 	ldr	x27, [sp, #80]
 1144cd4:	a8d87bfd 	ldp	x29, x30, [sp], #384
 1144cd8:	d65f03c0 	ret
		return snprintk(buf, bs, "%s ", num_digits > 1 ? "??" : "?");
 1144cdc:	aa1303e1 	mov	x1, x19
 1144ce0:	aa1a03e0 	mov	x0, x26
 1144ce4:	90000083 	adrp	x3, 1154000 <__func__.1786+0x8>
 1144ce8:	b00000a2 	adrp	x2, 1159000 <Worder+0x2854>
 1144cec:	9110d863 	add	x3, x3, #0x436
 1144cf0:	91356042 	add	x2, x2, #0xd58
 1144cf4:	97fffc63 	bl	1143e80 <snprintk>
 1144cf8:	17ffffbc 	b	1144be8 <trace_vprintf+0x11c>
		return snprintk(buf, bs, "%*s ", num_thread_digits, "");
 1144cfc:	aa1503e1 	mov	x1, x21
 1144d00:	aa1a03e0 	mov	x0, x26
 1144d04:	d0000064 	adrp	x4, 1152000 <trace_ext_prefix+0x2e>
 1144d08:	52800023 	mov	w3, #0x1                   	// #1
 1144d0c:	9104a884 	add	x4, x4, #0x12a
 1144d10:	b00000a2 	adrp	x2, 1159000 <Worder+0x2854>
 1144d14:	91358842 	add	x2, x2, #0xd62
 1144d18:	97fffc5a 	bl	1143e80 <snprintk>
 1144d1c:	17ffffc1 	b	1144c20 <trace_vprintf+0x154>
		if (boffs >= sizeof(buf) - 1)
 1144d20:	f103fabf 	cmp	x21, #0xfe
 1144d24:	54fffce8 	b.hi	1144cc0 <trace_vprintf+0x1f4>  // b.pmore
		buf[boffs++] = ' ';
 1144d28:	910006b3 	add	x19, x21, #0x1
 1144d2c:	52800400 	mov	w0, #0x20                  	// #32
 1144d30:	38356a80 	strb	w0, [x20, x21]
		buf[boffs] = 0;
 1144d34:	38336a9f 	strb	wzr, [x20, x19]
 1144d38:	17ffffc7 	b	1144c54 <trace_vprintf+0x188>
		boffs--;
 1144d3c:	d1000673 	sub	x19, x19, #0x1
 1144d40:	17ffffd8 	b	1144ca0 <trace_vprintf+0x1d4>

0000000001144d44 <trace_printf>:
{
 1144d44:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
 1144d48:	910003fd 	mov	x29, sp
 1144d4c:	a9059be5 	stp	x5, x6, [sp, #88]
	va_start(ap, fmt);
 1144d50:	9101c3e5 	add	x5, sp, #0x70
 1144d54:	a90317e5 	stp	x5, x5, [sp, #48]
 1144d58:	910143e5 	add	x5, sp, #0x50
 1144d5c:	f90023e5 	str	x5, [sp, #64]
 1144d60:	128002e5 	mov	w5, #0xffffffe8            	// #-24
 1144d64:	b9004be5 	str	w5, [sp, #72]
	trace_vprintf(function, line, level, level_ok, fmt, ap);
 1144d68:	910043e5 	add	x5, sp, #0x10
	va_start(ap, fmt);
 1144d6c:	b9004fff 	str	wzr, [sp, #76]
{
 1144d70:	f90037e7 	str	x7, [sp, #104]
	trace_vprintf(function, line, level, level_ok, fmt, ap);
 1144d74:	a9431fe6 	ldp	x6, x7, [sp, #48]
 1144d78:	a9011fe6 	stp	x6, x7, [sp, #16]
 1144d7c:	a9441fe6 	ldp	x6, x7, [sp, #64]
 1144d80:	a9021fe6 	stp	x6, x7, [sp, #32]
 1144d84:	97ffff52 	bl	1144acc <trace_vprintf>
}
 1144d88:	a8c77bfd 	ldp	x29, x30, [sp], #112
 1144d8c:	d65f03c0 	ret

0000000001144d90 <put_pool>:
	mutex_lock_recursive(&pool->mu);
#endif
}

static void put_pool(struct mempool *pool __maybe_unused)
{
 1144d90:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1144d94:	910003fd 	mov	x29, sp
 1144d98:	a90153f3 	stp	x19, x20, [sp, #16]
#if defined(__KERNEL__)
	if (mutex_get_recursive_lock_depth(&pool->mu) == 1) {
 1144d9c:	91008014 	add	x20, x0, #0x20
{
 1144da0:	aa0003f3 	mov	x19, x0
	if (mutex_get_recursive_lock_depth(&pool->mu) == 1) {
 1144da4:	aa1403e0 	mov	x0, x20
 1144da8:	97ff42d5 	bl	11158fc <mutex_get_recursive_lock_depth>
 1144dac:	7100041f 	cmp	w0, #0x1
 1144db0:	540001e1 	b.ne	1144dec <put_pool+0x5c>  // b.any
		/*
		 * As the refcount is about to become 0 there should be no items
		 * left
		 */
		if (pool->last_offset >= 0)
 1144db4:	f9400660 	ldr	x0, [x19, #8]
 1144db8:	b7f80100 	tbnz	x0, #63, 1144dd8 <put_pool+0x48>
			panic();
 1144dbc:	b00000a2 	adrp	x2, 1159000 <Worder+0x2854>
 1144dc0:	b00000a0 	adrp	x0, 1159000 <Worder+0x2854>
 1144dc4:	9137e842 	add	x2, x2, #0xdfa
 1144dc8:	91360000 	add	x0, x0, #0xd80
 1144dcc:	d2800003 	mov	x3, #0x0                   	// #0
 1144dd0:	52800b21 	mov	w1, #0x59                  	// #89
 1144dd4:	97ff39a5 	bl	1113468 <__do_panic>
		if (pool->release_mem)
 1144dd8:	f9400e62 	ldr	x2, [x19, #24]
 1144ddc:	b4000082 	cbz	x2, 1144dec <put_pool+0x5c>
			pool->release_mem((void *)pool->data, pool->size);
 1144de0:	f9400261 	ldr	x1, [x19]
 1144de4:	f9400a60 	ldr	x0, [x19, #16]
 1144de8:	d63f0040 	blr	x2
	}
	mutex_unlock_recursive(&pool->mu);
 1144dec:	aa1403e0 	mov	x0, x20
#endif
}
 1144df0:	a94153f3 	ldp	x19, x20, [sp, #16]
 1144df4:	a8c27bfd 	ldp	x29, x30, [sp], #32
	mutex_unlock_recursive(&pool->mu);
 1144df8:	17ff41b7 	b	11154d4 <mutex_unlock_recursive>

0000000001144dfc <mempool_alloc_pool>:

struct mempool *
mempool_alloc_pool(void *data, size_t size,
		   void (*release_mem)(void *ptr, size_t size) __maybe_unused)
{
 1144dfc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 1144e00:	910003fd 	mov	x29, sp
 1144e04:	a90153f3 	stp	x19, x20, [sp, #16]
 1144e08:	aa0003f4 	mov	x20, x0
	struct mempool *pool = calloc(1, sizeof(*pool));
 1144e0c:	d2800020 	mov	x0, #0x1                   	// #1
{
 1144e10:	a9025bf5 	stp	x21, x22, [sp, #32]
 1144e14:	aa0103f6 	mov	x22, x1
 1144e18:	aa0203f5 	mov	x21, x2
	struct mempool *pool = calloc(1, sizeof(*pool));
 1144e1c:	d2800801 	mov	x1, #0x40                  	// #64
 1144e20:	97fff9ac 	bl	11434d0 <calloc>

	COMPILE_TIME_ASSERT(MEMPOOL_ALIGN >= __alignof__(struct mempool_item));
	assert(!((vaddr_t)data & (MEMPOOL_ALIGN - 1)));
 1144e24:	f2400a9f 	tst	x20, #0x7
 1144e28:	54000140 	b.eq	1144e50 <mempool_alloc_pool+0x54>  // b.none
 1144e2c:	b00000a3 	adrp	x3, 1159000 <Worder+0x2854>
 1144e30:	b00000a1 	adrp	x1, 1159000 <Worder+0x2854>
 1144e34:	91380c63 	add	x3, x3, #0xe03
 1144e38:	91360021 	add	x1, x1, #0xd80
 1144e3c:	b00000a0 	adrp	x0, 1159000 <Worder+0x2854>
 1144e40:	91366c00 	add	x0, x0, #0xd9b
 1144e44:	52800d02 	mov	w2, #0x68                  	// #104
 1144e48:	97ff3519 	bl	11122ac <_assert_log>
 1144e4c:	97ff3529 	bl	11122f0 <_assert_break>
 1144e50:	aa0003f3 	mov	x19, x0

	if (pool) {
 1144e54:	b40000c0 	cbz	x0, 1144e6c <mempool_alloc_pool+0x70>
		pool->size = size;
		pool->data = (vaddr_t)data;
		pool->last_offset = -1;
 1144e58:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
 1144e5c:	a9000276 	stp	x22, x0, [x19]
#if defined(__KERNEL__)
		pool->release_mem = release_mem;
		mutex_init_recursive(&pool->mu);
 1144e60:	91008260 	add	x0, x19, #0x20
		pool->release_mem = release_mem;
 1144e64:	a9015674 	stp	x20, x21, [x19, #16]
		mutex_init_recursive(&pool->mu);
 1144e68:	97ff4195 	bl	11154bc <mutex_init_recursive>
#endif
	}

	return pool;
}
 1144e6c:	aa1303e0 	mov	x0, x19
 1144e70:	a94153f3 	ldp	x19, x20, [sp, #16]
 1144e74:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1144e78:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1144e7c:	d65f03c0 	ret

0000000001144e80 <mempool_alloc>:

void *mempool_alloc(struct mempool *pool, size_t size)
{
 1144e80:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
 1144e84:	910003fd 	mov	x29, sp
 1144e88:	a90153f3 	stp	x19, x20, [sp, #16]
 1144e8c:	aa0003f3 	mov	x19, x0
 1144e90:	aa0103f4 	mov	x20, x1
	mutex_lock_recursive(&pool->mu);
 1144e94:	91008000 	add	x0, x0, #0x20
 1144e98:	97ff41b0 	bl	1115558 <mutex_lock_recursive>
	struct mempool_item *new_item;
	struct mempool_item *last_item = NULL;

	get_pool(pool);

	if (pool->last_offset < 0) {
 1144e9c:	a9400660 	ldp	x0, x1, [x19]
 1144ea0:	b7f802c1 	tbnz	x1, #63, 1144ef8 <mempool_alloc+0x78>
		offset = 0;
	} else {
		last_item = (struct mempool_item *)(pool->data +
 1144ea4:	f9400a64 	ldr	x4, [x19, #16]
						    pool->last_offset);
		offset = pool->last_offset + last_item->size;

		offset = ROUNDUP(offset, MEMPOOL_ALIGN);
 1144ea8:	91001c22 	add	x2, x1, #0x7
		last_item = (struct mempool_item *)(pool->data +
 1144eac:	8b040023 	add	x3, x1, x4
		offset = ROUNDUP(offset, MEMPOOL_ALIGN);
 1144eb0:	f8646824 	ldr	x4, [x1, x4]
 1144eb4:	8b040042 	add	x2, x2, x4
 1144eb8:	927df042 	and	x2, x2, #0xfffffffffffffff8
		if (offset > pool->size)
 1144ebc:	eb02001f 	cmp	x0, x2
 1144ec0:	54000202 	b.cs	1144f00 <mempool_alloc+0x80>  // b.hs, b.nlast
#endif

	return new_item + 1;

error:
	EMSG("Failed to allocate %zu bytes, please tune the pool size", size);
 1144ec4:	aa1403e5 	mov	x5, x20
 1144ec8:	b00000a4 	adrp	x4, 1159000 <Worder+0x2854>
 1144ecc:	91370884 	add	x4, x4, #0xdc2
 1144ed0:	52800023 	mov	w3, #0x1                   	// #1
 1144ed4:	52800022 	mov	w2, #0x1                   	// #1
 1144ed8:	52801441 	mov	w1, #0xa2                  	// #162
 1144edc:	b00000a0 	adrp	x0, 1159000 <Worder+0x2854>
 1144ee0:	91385800 	add	x0, x0, #0xe16
 1144ee4:	97ffff98 	bl	1144d44 <trace_printf>
	put_pool(pool);
 1144ee8:	aa1303e0 	mov	x0, x19
 1144eec:	97ffffa9 	bl	1144d90 <put_pool>
	return NULL;
 1144ef0:	d2800000 	mov	x0, #0x0                   	// #0
 1144ef4:	14000012 	b	1144f3c <mempool_alloc+0xbc>
	struct mempool_item *last_item = NULL;
 1144ef8:	d2800003 	mov	x3, #0x0                   	// #0
		offset = 0;
 1144efc:	d2800002 	mov	x2, #0x0                   	// #0
	size = ROUNDUP(size, MEMPOOL_ALIGN);
 1144f00:	91007e94 	add	x20, x20, #0x1f
 1144f04:	927df294 	and	x20, x20, #0xfffffffffffffff8
	if (offset + size > pool->size)
 1144f08:	8b140044 	add	x4, x2, x20
 1144f0c:	eb00009f 	cmp	x4, x0
 1144f10:	54fffda8 	b.hi	1144ec4 <mempool_alloc+0x44>  // b.pmore
	new_item = (struct mempool_item *)(pool->data + offset);
 1144f14:	f9400a64 	ldr	x4, [x19, #16]
 1144f18:	8b040040 	add	x0, x2, x4
	new_item->size = size;
 1144f1c:	f8246854 	str	x20, [x2, x4]
	new_item->prev_item_offset = pool->last_offset;
 1144f20:	f9000401 	str	x1, [x0, #8]
	if (last_item)
 1144f24:	b4000043 	cbz	x3, 1144f2c <mempool_alloc+0xac>
		last_item->next_item_offset = offset;
 1144f28:	f9000862 	str	x2, [x3, #16]
	new_item->next_item_offset = -1;
 1144f2c:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
	return new_item + 1;
 1144f30:	91006000 	add	x0, x0, #0x18
	new_item->next_item_offset = -1;
 1144f34:	f81f8001 	stur	x1, [x0, #-8]
	pool->last_offset = offset;
 1144f38:	f9000662 	str	x2, [x19, #8]
}
 1144f3c:	a94153f3 	ldp	x19, x20, [sp, #16]
 1144f40:	a8c27bfd 	ldp	x29, x30, [sp], #32
 1144f44:	d65f03c0 	ret

0000000001144f48 <mempool_free>:
	struct mempool_item *item;
	struct mempool_item *prev_item;
	struct mempool_item *next_item;
	ssize_t last_offset = -1;

	if (!ptr)
 1144f48:	b4000221 	cbz	x1, 1144f8c <mempool_free+0x44>
		return;

	item = (struct mempool_item *)((vaddr_t)ptr -
				       sizeof(struct mempool_item));
	if (item->prev_item_offset >= 0) {
 1144f4c:	f85f0022 	ldur	x2, [x1, #-16]
 1144f50:	b7f801a2 	tbnz	x2, #63, 1144f84 <mempool_free+0x3c>
		prev_item = (struct mempool_item *)(pool->data +
						    item->prev_item_offset);
		prev_item->next_item_offset = item->next_item_offset;
 1144f54:	f9400803 	ldr	x3, [x0, #16]
 1144f58:	f85f8024 	ldur	x4, [x1, #-8]
 1144f5c:	8b020063 	add	x3, x3, x2
 1144f60:	f9000864 	str	x4, [x3, #16]
 1144f64:	aa0203e3 	mov	x3, x2
		last_offset = item->prev_item_offset;
	}

	if (item->next_item_offset >= 0) {
 1144f68:	f85f8024 	ldur	x4, [x1, #-8]
 1144f6c:	b7f80084 	tbnz	x4, #63, 1144f7c <mempool_free+0x34>
		next_item = (struct mempool_item *)(pool->data +
						    item->next_item_offset);
		next_item->prev_item_offset = item->prev_item_offset;
 1144f70:	a9408403 	ldp	x3, x1, [x0, #8]
 1144f74:	8b040021 	add	x1, x1, x4
 1144f78:	f9000422 	str	x2, [x1, #8]
		last_offset = pool->last_offset;
	}

	pool->last_offset = last_offset;
 1144f7c:	f9000403 	str	x3, [x0, #8]
	put_pool(pool);
 1144f80:	17ffff84 	b	1144d90 <put_pool>
	ssize_t last_offset = -1;
 1144f84:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
 1144f88:	17fffff8 	b	1144f68 <mempool_free+0x20>
}
 1144f8c:	d65f03c0 	ret

0000000001144f90 <consttime_memcmp>:
 * signed values. This is a rewrite from scratch that should not suffer from
 * such issues.
 *
 * 2015-12-12, J. Perlinger (perlinger-at-ntp-dot-org)
 */
int consttime_memcmp(const void *p1, const void *p2, size_t nb) {
 1144f90:	d10043ff 	sub	sp, sp, #0x10
	const unsigned char *ucp1 = p1;
	const unsigned char *ucp2 = p2;
	unsigned int isLT = 0u;
	unsigned int isGT = 0u;
	volatile unsigned int mask = (1u << CHAR_BIT);
 1144f94:	52802003 	mov	w3, #0x100                 	// #256

	for (/*NOP*/; 0 != nb; --nb, ++ucp1, ++ucp2) {
 1144f98:	d2800005 	mov	x5, #0x0                   	// #0
	unsigned int isLT = 0u;
 1144f9c:	52800006 	mov	w6, #0x0                   	// #0
	volatile unsigned int mask = (1u << CHAR_BIT);
 1144fa0:	b9000fe3 	str	w3, [sp, #12]
	unsigned int isGT = 0u;
 1144fa4:	52800003 	mov	w3, #0x0                   	// #0
	for (/*NOP*/; 0 != nb; --nb, ++ucp1, ++ucp2) {
 1144fa8:	eb0200bf 	cmp	x5, x2
 1144fac:	540000a1 	b.ne	1144fc0 <consttime_memcmp+0x30>  // b.any
		    ((unsigned int)*ucp1 - (unsigned int)*ucp2);
		isGT |= mask &
		    ((unsigned int)*ucp2 - (unsigned int)*ucp1);
		mask &= ~(isLT | isGT);
	}
	return (int)(isGT >> CHAR_BIT) - (int)(isLT >> CHAR_BIT);
 1144fb0:	53087c63 	lsr	w3, w3, #8
}
 1144fb4:	4b462060 	sub	w0, w3, w6, lsr #8
 1144fb8:	910043ff 	add	sp, sp, #0x10
 1144fbc:	d65f03c0 	ret
		    ((unsigned int)*ucp1 - (unsigned int)*ucp2);
 1144fc0:	38656808 	ldrb	w8, [x0, x5]
 1144fc4:	38656824 	ldrb	w4, [x1, x5]
 1144fc8:	910004a5 	add	x5, x5, #0x1
		isLT |= mask &
 1144fcc:	b9400fe9 	ldr	w9, [sp, #12]
		    ((unsigned int)*ucp1 - (unsigned int)*ucp2);
 1144fd0:	4b040107 	sub	w7, w8, w4
		    ((unsigned int)*ucp2 - (unsigned int)*ucp1);
 1144fd4:	4b080084 	sub	w4, w4, w8
		isLT |= mask &
 1144fd8:	0a0900e7 	and	w7, w7, w9
 1144fdc:	2a0700c6 	orr	w6, w6, w7
		isGT |= mask &
 1144fe0:	b9400fe7 	ldr	w7, [sp, #12]
 1144fe4:	0a070084 	and	w4, w4, w7
		mask &= ~(isLT | isGT);
 1144fe8:	b9400fe7 	ldr	w7, [sp, #12]
		isGT |= mask &
 1144fec:	2a040063 	orr	w3, w3, w4
		mask &= ~(isLT | isGT);
 1144ff0:	2a0300c4 	orr	w4, w6, w3
 1144ff4:	0a2400e4 	bic	w4, w7, w4
 1144ff8:	b9000fe4 	str	w4, [sp, #12]
	for (/*NOP*/; 0 != nb; --nb, ++ucp1, ++ucp2) {
 1144ffc:	17ffffeb 	b	1144fa8 <consttime_memcmp+0x18>

0000000001145000 <memzero_explicit>:
static volatile void * (*memset_func)(void *, int, size_t) =
	(volatile void * (*)(void *, int, size_t))&memset;

void memzero_explicit(void *s, size_t count)
{
	memset_func(s, 0, count);
 1145000:	aa0103e2 	mov	x2, x1
 1145004:	52800001 	mov	w1, #0x0                   	// #0
 1145008:	17fffb36 	b	1143ce0 <memset>

000000000114500c <memchr>:
_PTR
_DEFUN(memchr, (src_void, c, length), _CONST _PTR src_void _AND int c
	_AND size_t length)
{
	_CONST unsigned char *src = (_CONST unsigned char *)src_void;
	unsigned char d = c;
 114500c:	12001c21 	and	w1, w1, #0xff

		src = (unsigned char *)asrc;
	}
#endif /* not PREFER_SIZE_OVER_SPEED */

	while (length--) {
 1145010:	8b020002 	add	x2, x0, x2
 1145014:	eb02001f 	cmp	x0, x2
 1145018:	54000061 	b.ne	1145024 <memchr+0x18>  // b.any
		if (*src == d)
			return (void *)src;
		src++;
	}

	return NULL;
 114501c:	d2800000 	mov	x0, #0x0                   	// #0
}
 1145020:	d65f03c0 	ret
		if (*src == d)
 1145024:	39400003 	ldrb	w3, [x0]
 1145028:	6b01007f 	cmp	w3, w1
 114502c:	54ffffa0 	b.eq	1145020 <memchr+0x14>  // b.none
		src++;
 1145030:	91000400 	add	x0, x0, #0x1
 1145034:	17fffff8 	b	1145014 <memchr+0x8>
